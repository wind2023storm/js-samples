<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Simple ThreeJS Overlay View</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>

    <script type="module" crossorigin>
      const tf = function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
          n(i);
        new MutationObserver((i) => {
          for (const r of i)
            if (r.type === "childList")
              for (const s of r.addedNodes)
                s.tagName === "LINK" && s.rel === "modulepreload" && n(s);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(i) {
          const r = {};
          return (
            i.integrity && (r.integrity = i.integrity),
            i.referrerpolicy && (r.referrerPolicy = i.referrerpolicy),
            i.crossorigin === "use-credentials"
              ? (r.credentials = "include")
              : i.crossorigin === "anonymous"
              ? (r.credentials = "omit")
              : (r.credentials = "same-origin"),
            r
          );
        }
        function n(i) {
          if (i.ep) return;
          i.ep = !0;
          const r = t(i);
          fetch(i.href, r);
        }
      };
      tf();
      /**
       * @license
       * Copyright 2010-2022 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const So = "140",
        nf = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        rf = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        Hu = 0,
        Ba = 1,
        Gu = 2,
        sf = 3,
        of = 0,
        vl = 1,
        ku = 2,
        ir = 3,
        Gn = 0,
        Ft = 1,
        kn = 2,
        Ml = 1,
        af = 2,
        vn = 0,
        yi = 1,
        Na = 2,
        Oa = 3,
        Ua = 4,
        Vu = 5,
        pi = 100,
        Wu = 101,
        qu = 102,
        za = 103,
        Ha = 104,
        Xu = 200,
        Ju = 201,
        Yu = 202,
        ju = 203,
        bl = 204,
        wl = 205,
        Ku = 206,
        Zu = 207,
        $u = 208,
        Qu = 209,
        eh = 210,
        th = 0,
        nh = 1,
        ih = 2,
        Mo = 3,
        rh = 4,
        sh = 5,
        oh = 6,
        ah = 7,
        hs = 0,
        lh = 1,
        ch = 2,
        sn = 0,
        uh = 1,
        hh = 2,
        dh = 3,
        fh = 4,
        ph = 5,
        To = 300,
        Vn = 301,
        Wn = 302,
        Qr = 303,
        es = 304,
        Rr = 306,
        qn = 1e3,
        Mt = 1001,
        ar = 1002,
        at = 1003,
        ts = 1004,
        lf = 1004,
        ns = 1005,
        cf = 1005,
        tt = 1006,
        Eo = 1007,
        uf = 1007,
        Sn = 1008,
        hf = 1008,
        Xn = 1009,
        mh = 1010,
        gh = 1011,
        lr = 1012,
        xh = 1013,
        jr = 1014,
        _n = 1015,
        cr = 1016,
        yh = 1017,
        _h = 1018,
        _i = 1020,
        vh = 1021,
        Mh = 1022,
        Dt = 1023,
        bh = 1024,
        wh = 1025,
        zn = 1026,
        wi = 1027,
        Sh = 1028,
        Th = 1029,
        Eh = 1030,
        Ah = 1031,
        Rh = 1033,
        po = 33776,
        mo = 33777,
        go = 33778,
        xo = 33779,
        Ga = 35840,
        ka = 35841,
        Va = 35842,
        Wa = 35843,
        Ch = 36196,
        qa = 37492,
        Xa = 37496,
        Ja = 37808,
        Ya = 37809,
        ja = 37810,
        Ka = 37811,
        Za = 37812,
        $a = 37813,
        Qa = 37814,
        el = 37815,
        tl = 37816,
        nl = 37817,
        il = 37818,
        rl = 37819,
        sl = 37820,
        ol = 37821,
        al = 36492,
        Lh = 2200,
        Ph = 2201,
        Ih = 2202,
        ur = 2300,
        Si = 2301,
        yo = 2302,
        gi = 2400,
        xi = 2401,
        is = 2402,
        Ao = 2500,
        Sl = 2501,
        Dh = 0,
        Fh = 1,
        Tl = 2,
        Mn = 3e3,
        We = 3001,
        Bh = 3200,
        Nh = 3201,
        Kn = 0,
        Oh = 1,
        df = "",
        tn = "srgb",
        On = "srgb-linear",
        ff = 0,
        _o = 7680,
        pf = 7681,
        mf = 7682,
        gf = 7683,
        xf = 34055,
        yf = 34056,
        _f = 5386,
        vf = 512,
        Mf = 513,
        bf = 514,
        wf = 515,
        Sf = 516,
        Tf = 517,
        Ef = 518,
        Uh = 519,
        hr = 35044,
        dr = 35048,
        Af = 35040,
        Rf = 35045,
        Cf = 35049,
        Lf = 35041,
        Pf = 35046,
        If = 35050,
        Df = 35042,
        Ff = "100",
        ll = "300 es",
        bo = 1035;
      class Zn {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e];
          if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e.type];
          if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, s = i.length; r < s; r++) i[r].call(this, e);
            e.target = null;
          }
        }
      }
      const _t = [];
      for (let o = 0; o < 256; o++)
        _t[o] = (o < 16 ? "0" : "") + o.toString(16);
      let cc = 1234567;
      const vi = Math.PI / 180,
        rs = 180 / Math.PI;
      function Bt() {
        const o = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          _t[o & 255] +
          _t[(o >> 8) & 255] +
          _t[(o >> 16) & 255] +
          _t[(o >> 24) & 255] +
          "-" +
          _t[e & 255] +
          _t[(e >> 8) & 255] +
          "-" +
          _t[((e >> 16) & 15) | 64] +
          _t[(e >> 24) & 255] +
          "-" +
          _t[(t & 63) | 128] +
          _t[(t >> 8) & 255] +
          "-" +
          _t[(t >> 16) & 255] +
          _t[(t >> 24) & 255] +
          _t[n & 255] +
          _t[(n >> 8) & 255] +
          _t[(n >> 16) & 255] +
          _t[(n >> 24) & 255]
        ).toLowerCase();
      }
      function lt(o, e, t) {
        return Math.max(e, Math.min(t, o));
      }
      function El(o, e) {
        return ((o % e) + e) % e;
      }
      function Bf(o, e, t, n, i) {
        return n + ((o - e) * (i - n)) / (t - e);
      }
      function Nf(o, e, t) {
        return o !== e ? (t - o) / (e - o) : 0;
      }
      function Kr(o, e, t) {
        return (1 - t) * o + t * e;
      }
      function Of(o, e, t, n) {
        return Kr(o, e, 1 - Math.exp(-t * n));
      }
      function Uf(o, e = 1) {
        return e - Math.abs(El(o, e * 2) - e);
      }
      function zf(o, e, t) {
        return o <= e
          ? 0
          : o >= t
          ? 1
          : ((o = (o - e) / (t - e)), o * o * (3 - 2 * o));
      }
      function Hf(o, e, t) {
        return o <= e
          ? 0
          : o >= t
          ? 1
          : ((o = (o - e) / (t - e)), o * o * o * (o * (o * 6 - 15) + 10));
      }
      function Gf(o, e) {
        return o + Math.floor(Math.random() * (e - o + 1));
      }
      function kf(o, e) {
        return o + Math.random() * (e - o);
      }
      function Vf(o) {
        return o * (0.5 - Math.random());
      }
      function Wf(o) {
        o !== void 0 && (cc = o);
        let e = (cc += 1831565813);
        return (
          (e = Math.imul(e ^ (e >>> 15), e | 1)),
          (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
          ((e ^ (e >>> 14)) >>> 0) / 4294967296
        );
      }
      function qf(o) {
        return o * vi;
      }
      function Xf(o) {
        return o * rs;
      }
      function cl(o) {
        return (o & (o - 1)) === 0 && o !== 0;
      }
      function zh(o) {
        return Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
      }
      function wo(o) {
        return Math.pow(2, Math.floor(Math.log(o) / Math.LN2));
      }
      function Jf(o, e, t, n, i) {
        const r = Math.cos,
          s = Math.sin,
          a = r(t / 2),
          l = s(t / 2),
          c = r((e + n) / 2),
          u = s((e + n) / 2),
          h = r((e - n) / 2),
          d = s((e - n) / 2),
          f = r((n - e) / 2),
          g = s((n - e) / 2);
        switch (i) {
          case "XYX":
            o.set(a * u, l * h, l * d, a * c);
            break;
          case "YZY":
            o.set(l * d, a * u, l * h, a * c);
            break;
          case "ZXZ":
            o.set(l * h, l * d, a * u, a * c);
            break;
          case "XZX":
            o.set(a * u, l * g, l * f, a * c);
            break;
          case "YXY":
            o.set(l * f, a * u, l * g, a * c);
            break;
          case "ZYZ":
            o.set(l * g, l * f, a * u, a * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
            );
        }
      }
      function Yf(o, e) {
        switch (e.constructor) {
          case Float32Array:
            return o;
          case Uint16Array:
            return o / 65535;
          case Uint8Array:
            return o / 255;
          case Int16Array:
            return Math.max(o / 32767, -1);
          case Int8Array:
            return Math.max(o / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function jf(o, e) {
        switch (e.constructor) {
          case Float32Array:
            return o;
          case Uint16Array:
            return Math.round(o * 65535);
          case Uint8Array:
            return Math.round(o * 255);
          case Int16Array:
            return Math.round(o * 32767);
          case Int8Array:
            return Math.round(o * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      var ul = Object.freeze({
        __proto__: null,
        DEG2RAD: vi,
        RAD2DEG: rs,
        generateUUID: Bt,
        clamp: lt,
        euclideanModulo: El,
        mapLinear: Bf,
        inverseLerp: Nf,
        lerp: Kr,
        damp: Of,
        pingpong: Uf,
        smoothstep: zf,
        smootherstep: Hf,
        randInt: Gf,
        randFloat: kf,
        randFloatSpread: Vf,
        seededRandom: Wf,
        degToRad: qf,
        radToDeg: Xf,
        isPowerOfTwo: cl,
        ceilPowerOfTwo: zh,
        floorPowerOfTwo: wo,
        setQuaternionFromProperEuler: Jf,
        normalize: jf,
        denormalize: Yf,
      });
      class W {
        constructor(e = 0, t = 0) {
          (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            s = this.y - e.y;
          return (
            (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      W.prototype.isVector2 = !0;
      class mt {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, s, a, l, c) {
          const u = this.elements;
          return (
            (u[0] = e),
            (u[1] = i),
            (u[2] = a),
            (u[3] = t),
            (u[4] = r),
            (u[5] = l),
            (u[6] = n),
            (u[7] = s),
            (u[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            u = n[4],
            h = n[7],
            d = n[2],
            f = n[5],
            g = n[8],
            m = i[0],
            p = i[3],
            x = i[6],
            y = i[1],
            v = i[4],
            M = i[7],
            b = i[2],
            T = i[5],
            C = i[8];
          return (
            (r[0] = s * m + a * y + l * b),
            (r[3] = s * p + a * v + l * T),
            (r[6] = s * x + a * M + l * C),
            (r[1] = c * m + u * y + h * b),
            (r[4] = c * p + u * v + h * T),
            (r[7] = c * x + u * M + h * C),
            (r[2] = d * m + f * y + g * b),
            (r[5] = d * p + f * v + g * T),
            (r[8] = d * x + f * M + g * C),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8];
          return (
            t * s * u -
            t * a * c -
            n * r * u +
            n * a * l +
            i * r * c -
            i * s * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = u * s - a * c,
            d = a * l - u * r,
            f = c * r - s * l,
            g = t * h + n * d + i * f;
          if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m = 1 / g;
          return (
            (e[0] = h * m),
            (e[1] = (i * c - u * n) * m),
            (e[2] = (a * n - i * s) * m),
            (e[3] = d * m),
            (e[4] = (u * t - i * l) * m),
            (e[5] = (i * r - a * t) * m),
            (e[6] = f * m),
            (e[7] = (n * l - c * t) * m),
            (e[8] = (s * t - n * r) * m),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, s, a) {
          const l = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * l,
              n * c,
              -n * (l * s + c * a) + s + e,
              -i * c,
              i * l,
              -i * (-c * s + l * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            s = i[3],
            a = i[6],
            l = i[1],
            c = i[4],
            u = i[7];
          return (
            (i[0] = t * r + n * l),
            (i[3] = t * s + n * c),
            (i[6] = t * a + n * u),
            (i[1] = -n * r + t * l),
            (i[4] = -n * s + t * c),
            (i[7] = -n * a + t * u),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      mt.prototype.isMatrix3 = !0;
      function Hh(o) {
        for (let e = o.length - 1; e >= 0; --e) if (o[e] > 65535) return !0;
        return !1;
      }
      const Kf = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function rr(o, e) {
        return new Kf[o](e);
      }
      function ss(o) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", o);
      }
      function Mi(o) {
        return o < 0.04045
          ? o * 0.0773993808
          : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
      }
      function vo(o) {
        return o < 0.0031308 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
      }
      const Zo = { [tn]: { [On]: Mi }, [On]: { [tn]: vo } },
        Ut = {
          legacyMode: !0,
          get workingColorSpace() {
            return On;
          },
          set workingColorSpace(o) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function (o, e, t) {
            if (this.legacyMode || e === t || !e || !t) return o;
            if (Zo[e] && Zo[e][t] !== void 0) {
              const n = Zo[e][t];
              return (o.r = n(o.r)), (o.g = n(o.g)), (o.b = n(o.b)), o;
            }
            throw new Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (o, e) {
            return this.convert(o, this.workingColorSpace, e);
          },
          toWorkingColorSpace: function (o, e) {
            return this.convert(o, e, this.workingColorSpace);
          },
        },
        Gh = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        ft = { r: 0, g: 0, b: 0 },
        Gt = { h: 0, s: 0, l: 0 },
        Es = { h: 0, s: 0, l: 0 };
      function $o(o, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? o + (e - o) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? o + (e - o) * 6 * (2 / 3 - t)
            : o
        );
      }
      function As(o, e) {
        return (e.r = o.r), (e.g = o.g), (e.b = o.b), e;
      }
      class ne {
        constructor(e, t, n) {
          return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : typeof e == "number"
              ? this.setHex(e)
              : typeof e == "string" && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = tn) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            Ut.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, n, i = On) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            Ut.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(e, t, n, i = On) {
          if (((e = El(e, 1)), (t = lt(t, 0, 1)), (n = lt(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
          else {
            const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              s = 2 * n - r;
            (this.r = $o(s, r, e + 1 / 3)),
              (this.g = $o(s, r, e)),
              (this.b = $o(s, r, e - 1 / 3));
          }
          return Ut.toWorkingColorSpace(this, i), this;
        }
        setStyle(e, t = tn) {
          function n(r) {
            r !== void 0 &&
              parseFloat(r) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let i;
          if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let r;
            const s = i[1],
              a = i[2];
            switch (s) {
              case "rgb":
              case "rgba":
                if (
                  (r =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                    Ut.toWorkingColorSpace(this, t),
                    n(r[4]),
                    this
                  );
                if (
                  (r =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                    Ut.toWorkingColorSpace(this, t),
                    n(r[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                ) {
                  const l = parseFloat(r[1]) / 360,
                    c = parseInt(r[2], 10) / 100,
                    u = parseInt(r[3], 10) / 100;
                  return n(r[4]), this.setHSL(l, c, u, t);
                }
                break;
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const r = i[1],
              s = r.length;
            if (s === 3)
              return (
                (this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255),
                (this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255),
                (this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255),
                Ut.toWorkingColorSpace(this, t),
                this
              );
            if (s === 6)
              return (
                (this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255),
                (this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255),
                (this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255),
                Ut.toWorkingColorSpace(this, t),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e, t) : this;
        }
        setColorName(e, t = tn) {
          const n = Gh[e.toLowerCase()];
          return (
            n !== void 0
              ? this.setHex(n, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = Mi(e.r)), (this.g = Mi(e.g)), (this.b = Mi(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = vo(e.r)), (this.g = vo(e.g)), (this.b = vo(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = tn) {
          return (
            Ut.fromWorkingColorSpace(As(this, ft), e),
            (lt(ft.r * 255, 0, 255) << 16) ^
              (lt(ft.g * 255, 0, 255) << 8) ^
              (lt(ft.b * 255, 0, 255) << 0)
          );
        }
        getHexString(e = tn) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = On) {
          Ut.fromWorkingColorSpace(As(this, ft), t);
          const n = ft.r,
            i = ft.g,
            r = ft.b,
            s = Math.max(n, i, r),
            a = Math.min(n, i, r);
          let l, c;
          const u = (a + s) / 2;
          if (a === s) (l = 0), (c = 0);
          else {
            const h = s - a;
            switch (((c = u <= 0.5 ? h / (s + a) : h / (2 - s - a)), s)) {
              case n:
                l = (i - r) / h + (i < r ? 6 : 0);
                break;
              case i:
                l = (r - n) / h + 2;
                break;
              case r:
                l = (n - i) / h + 4;
                break;
            }
            l /= 6;
          }
          return (e.h = l), (e.s = c), (e.l = u), e;
        }
        getRGB(e, t = On) {
          return (
            Ut.fromWorkingColorSpace(As(this, ft), t),
            (e.r = ft.r),
            (e.g = ft.g),
            (e.b = ft.b),
            e
          );
        }
        getStyle(e = tn) {
          return (
            Ut.fromWorkingColorSpace(As(this, ft), e),
            e !== tn
              ? `color(${e} ${ft.r} ${ft.g} ${ft.b})`
              : `rgb(${(ft.r * 255) | 0},${(ft.g * 255) | 0},${
                  (ft.b * 255) | 0
                })`
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(Gt),
            (Gt.h += e),
            (Gt.s += t),
            (Gt.l += n),
            this.setHSL(Gt.h, Gt.s, Gt.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(Gt), e.getHSL(Es);
          const n = Kr(Gt.h, Es.h, t),
            i = Kr(Gt.s, Es.s, t),
            r = Kr(Gt.l, Es.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      ne.NAMES = Gh;
      ne.prototype.isColor = !0;
      ne.prototype.r = 1;
      ne.prototype.g = 1;
      ne.prototype.b = 1;
      let zi;
      class $n {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            zi === void 0 && (zi = ss("canvas")),
              (zi.width = e.width),
              (zi.height = e.height);
            const n = zi.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = zi);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            (typeof HTMLImageElement != "undefined" &&
              e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement != "undefined" &&
              e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
          ) {
            const t = ss("canvas");
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
              r = i.data;
            for (let s = 0; s < r.length; s++) r[s] = Mi(r[s] / 255) * 255;
            return n.putImageData(i, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray
                ? (t[n] = Math.floor(Mi(t[n] / 255) * 255))
                : (t[n] = Mi(t[n]));
            return { data: t, width: e.width, height: e.height };
          } else
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              e
            );
        }
      }
      class Un {
        constructor(e = null) {
          (this.uuid = Bt()), (this.data = e), (this.version = 0);
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            i = this.data;
          if (i !== null) {
            let r;
            if (Array.isArray(i)) {
              r = [];
              for (let s = 0, a = i.length; s < a; s++)
                i[s].isDataTexture ? r.push(Qo(i[s].image)) : r.push(Qo(i[s]));
            } else r = Qo(i);
            n.url = r;
          }
          return t || (e.images[this.uuid] = n), n;
        }
      }
      function Qo(o) {
        return (typeof HTMLImageElement != "undefined" &&
          o instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            o instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && o instanceof ImageBitmap)
          ? $n.getDataURL(o)
          : o.data
          ? {
              data: Array.prototype.slice.call(o.data),
              width: o.width,
              height: o.height,
              type: o.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      Un.prototype.isSource = !0;
      let Zf = 0;
      class st extends Zn {
        constructor(
          e = st.DEFAULT_IMAGE,
          t = st.DEFAULT_MAPPING,
          n = Mt,
          i = Mt,
          r = tt,
          s = Sn,
          a = Dt,
          l = Xn,
          c = 1,
          u = Mn
        ) {
          super(),
            Object.defineProperty(this, "id", { value: Zf++ }),
            (this.uuid = Bt()),
            (this.name = ""),
            (this.source = new Un(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = c),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = l),
            (this.offset = new W(0, 0)),
            (this.repeat = new W(1, 1)),
            (this.center = new W(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new mt()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = u),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        get image() {
          return this.source.data;
        }
        set image(e) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== To) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case qn:
                e.x = e.x - Math.floor(e.x);
                break;
              case Mt:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case ar:
                Math.abs(Math.floor(e.x) % 2) === 1
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case qn:
                e.y = e.y - Math.floor(e.y);
                break;
              case Mt:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case ar:
                Math.abs(Math.floor(e.y) % 2) === 1
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && (this.version++, (this.source.needsUpdate = !0));
        }
      }
      st.DEFAULT_IMAGE = null;
      st.DEFAULT_MAPPING = To;
      st.prototype.isTexture = !0;
      class Je {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.x = e), (this.y = t), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
            (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
            (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
            (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const l = e.elements,
            c = l[0],
            u = l[4],
            h = l[8],
            d = l[1],
            f = l[5],
            g = l[9],
            m = l[2],
            p = l[6],
            x = l[10];
          if (
            Math.abs(u - d) < 0.01 &&
            Math.abs(h - m) < 0.01 &&
            Math.abs(g - p) < 0.01
          ) {
            if (
              Math.abs(u + d) < 0.1 &&
              Math.abs(h + m) < 0.1 &&
              Math.abs(g + p) < 0.1 &&
              Math.abs(c + f + x - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const v = (c + 1) / 2,
              M = (f + 1) / 2,
              b = (x + 1) / 2,
              T = (u + d) / 4,
              C = (h + m) / 4,
              _ = (g + p) / 4;
            return (
              v > M && v > b
                ? v < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(v)), (i = T / n), (r = C / n))
                : M > b
                ? M < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(M)), (n = T / i), (r = _ / i))
                : b < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(b)), (n = C / r), (i = _ / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let y = Math.sqrt(
            (p - g) * (p - g) + (h - m) * (h - m) + (d - u) * (d - u)
          );
          return (
            Math.abs(y) < 0.001 && (y = 1),
            (this.x = (p - g) / y),
            (this.y = (h - m) / y),
            (this.z = (d - u) / y),
            (this.w = Math.acos((c + f + x - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      Je.prototype.isVector4 = !0;
      class Tt extends Zn {
        constructor(e, t, n = {}) {
          super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Je(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Je(0, 0, e, t));
          const i = { width: e, height: t, depth: 1 };
          (this.texture = new st(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps =
              n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.internalFormat =
              n.internalFormat !== void 0 ? n.internalFormat : null),
            (this.texture.minFilter =
              n.minFilter !== void 0 ? n.minFilter : tt),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
              n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
              n.depthTexture !== void 0 ? n.depthTexture : null),
            (this.samples = n.samples !== void 0 ? n.samples : 0);
        }
        setSize(e, t, n = 1) {
          (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new Un(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            e.depthTexture !== null &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Tt.prototype.isWebGLRenderTarget = !0;
      class Cr extends st {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = at),
            (this.minFilter = at),
            (this.wrapR = Mt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      Cr.prototype.isDataArrayTexture = !0;
      class kh extends Tt {
        constructor(e, t, n) {
          super(e, t),
            (this.depth = n),
            (this.texture = new Cr(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
        }
      }
      kh.prototype.isWebGLArrayRenderTarget = !0;
      class ds extends st {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = at),
            (this.minFilter = at),
            (this.wrapR = Mt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      ds.prototype.isData3DTexture = !0;
      class Vh extends Tt {
        constructor(e, t, n) {
          super(e, t),
            (this.depth = n),
            (this.texture = new ds(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
        }
      }
      Vh.prototype.isWebGL3DRenderTarget = !0;
      class Wh extends Tt {
        constructor(e, t, n, i = {}) {
          super(e, t, i);
          const r = this.texture;
          this.texture = [];
          for (let s = 0; s < n; s++)
            (this.texture[s] = r.clone()),
              (this.texture[s].isRenderTargetTexture = !0);
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = e),
                (this.texture[i].image.height = t),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
          );
        }
        copy(e) {
          this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            e.depthTexture !== null &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.texture.length = 0);
          for (let t = 0, n = e.texture.length; t < n; t++)
            (this.texture[t] = e.texture[t].clone()),
              (this.texture[t].isRenderTargetTexture = !0);
          return this;
        }
      }
      Wh.prototype.isWebGLMultipleRenderTargets = !0;
      class yt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this._x = e), (this._y = t), (this._z = n), (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, r, s, a) {
          let l = n[i + 0],
            c = n[i + 1],
            u = n[i + 2],
            h = n[i + 3];
          const d = r[s + 0],
            f = r[s + 1],
            g = r[s + 2],
            m = r[s + 3];
          if (a === 0) {
            (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
            return;
          }
          if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = g), (e[t + 3] = m);
            return;
          }
          if (h !== m || l !== d || c !== f || u !== g) {
            let p = 1 - a;
            const x = l * d + c * f + u * g + h * m,
              y = x >= 0 ? 1 : -1,
              v = 1 - x * x;
            if (v > Number.EPSILON) {
              const b = Math.sqrt(v),
                T = Math.atan2(b, x * y);
              (p = Math.sin(p * T) / b), (a = Math.sin(a * T) / b);
            }
            const M = a * y;
            if (
              ((l = l * p + d * M),
              (c = c * p + f * M),
              (u = u * p + g * M),
              (h = h * p + m * M),
              p === 1 - a)
            ) {
              const b = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
              (l *= b), (c *= b), (u *= b), (h *= b);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, s) {
          const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3],
            h = r[s],
            d = r[s + 1],
            f = r[s + 2],
            g = r[s + 3];
          return (
            (e[t] = a * g + u * h + l * f - c * d),
            (e[t + 1] = l * g + u * d + c * h - a * f),
            (e[t + 2] = c * g + u * f + a * d - l * h),
            (e[t + 3] = u * g - a * h - l * d - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!(e && e.isEuler))
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            u = a(i / 2),
            h = a(r / 2),
            d = l(n / 2),
            f = l(i / 2),
            g = l(r / 2);
          switch (s) {
            case "XYZ":
              (this._x = d * u * h + c * f * g),
                (this._y = c * f * h - d * u * g),
                (this._z = c * u * g + d * f * h),
                (this._w = c * u * h - d * f * g);
              break;
            case "YXZ":
              (this._x = d * u * h + c * f * g),
                (this._y = c * f * h - d * u * g),
                (this._z = c * u * g - d * f * h),
                (this._w = c * u * h + d * f * g);
              break;
            case "ZXY":
              (this._x = d * u * h - c * f * g),
                (this._y = c * f * h + d * u * g),
                (this._z = c * u * g + d * f * h),
                (this._w = c * u * h - d * f * g);
              break;
            case "ZYX":
              (this._x = d * u * h - c * f * g),
                (this._y = c * f * h + d * u * g),
                (this._z = c * u * g - d * f * h),
                (this._w = c * u * h + d * f * g);
              break;
            case "YZX":
              (this._x = d * u * h + c * f * g),
                (this._y = c * f * h + d * u * g),
                (this._z = c * u * g - d * f * h),
                (this._w = c * u * h - d * f * g);
              break;
            case "XZY":
              (this._x = d * u * h - c * f * g),
                (this._y = c * f * h - d * u * g),
                (this._z = c * u * g + d * f * h),
                (this._w = c * u * h + d * f * g);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
              );
          }
          return t !== !1 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            s = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            u = t[6],
            h = t[10],
            d = n + a + h;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
              (this._x = (u - l) * f),
              (this._y = (r - c) * f),
              (this._z = (s - i) * f);
          } else if (n > a && n > h) {
            const f = 2 * Math.sqrt(1 + n - a - h);
            (this._w = (u - l) / f),
              (this._x = 0.25 * f),
              (this._y = (i + s) / f),
              (this._z = (r + c) / f);
          } else if (a > h) {
            const f = 2 * Math.sqrt(1 + a - n - h);
            (this._w = (r - c) / f),
              (this._x = (i + s) / f),
              (this._y = 0.25 * f),
              (this._z = (l + u) / f);
          } else {
            const f = 2 * Math.sqrt(1 + h - n - a);
            (this._w = (s - i) / f),
              (this._x = (r + c) / f),
              (this._y = (l + u) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(lt(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (n === 0) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            u = t._w;
          return (
            (this._x = n * u + s * a + i * c - r * l),
            (this._y = i * u + s * l + r * a - n * c),
            (this._z = r * u + s * c + n * l - i * a),
            (this._w = s * u - n * a - i * l - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            s = this._w;
          let a = s * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * s + t * this._w),
              (this._x = f * n + t * this._x),
              (this._y = f * i + t * this._y),
              (this._z = f * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            u = Math.atan2(c, a),
            h = Math.sin((1 - t) * u) / c,
            d = Math.sin(t * u) / c;
          return (
            (this._w = s * h + this._w * d),
            (this._x = n * h + this._x * d),
            (this._y = i * h + this._y * d),
            (this._z = r * h + this._z * d),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          return this.copy(e).slerp(t, n);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            n = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
          return this.set(
            t * Math.cos(i),
            n * Math.sin(r),
            n * Math.cos(r),
            t * Math.sin(i)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      yt.prototype.isQuaternion = !0;
      class S {
        constructor(e = 0, t = 0, n = 0) {
          (this.x = e), (this.y = t), (this.z = n);
        }
        set(e, t, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(uc.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(uc.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            s = e.y,
            a = e.z,
            l = e.w,
            c = l * t + s * i - a * n,
            u = l * n + a * t - r * i,
            h = l * i + r * n - s * t,
            d = -r * t - s * n - a * i;
          return (
            (this.x = c * l + d * -r + u * -a - h * -s),
            (this.y = u * l + d * -s + h * -r - c * -a),
            (this.z = h * l + d * -a + c * -s - u * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            s = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = i * l - r * a),
            (this.y = r * s - n * l),
            (this.z = n * a - i * s),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return ea.copy(this).projectOnVector(e), this.sub(ea);
        }
        reflect(e) {
          return this.sub(ea.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(lt(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = (Math.random() - 0.5) * 2,
            t = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - e ** 2);
          return (
            (this.x = n * Math.cos(t)),
            (this.y = n * Math.sin(t)),
            (this.z = e),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      S.prototype.isVector3 = !0;
      const ea = new S(),
        uc = new yt();
      class Lt {
        constructor(
          e = new S(1 / 0, 1 / 0, 1 / 0),
          t = new S(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.length; l < c; l += 3) {
            const u = e[l],
              h = e[l + 1],
              d = e[l + 2];
            u < t && (t = u),
              h < n && (n = h),
              d < i && (i = d),
              u > r && (r = u),
              h > s && (s = h),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, s, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.count; l < c; l++) {
            const u = e.getX(l),
              h = e.getY(l),
              d = e.getZ(l);
            u < t && (t = u),
              h < n && (n = h),
              d < i && (i = d),
              u > r && (r = u),
              h > s && (s = h),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, s, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = ri.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const n = e.geometry;
          if (n !== void 0)
            if (t && n.attributes != null && n.attributes.position !== void 0) {
              const r = n.attributes.position;
              for (let s = 0, a = r.count; s < a; s++)
                ri.fromBufferAttribute(r, s).applyMatrix4(e.matrixWorld),
                  this.expandByPoint(ri);
            } else
              n.boundingBox === null && n.computeBoundingBox(),
                ta.copy(n.boundingBox),
                ta.applyMatrix4(e.matrixWorld),
                this.union(ta);
          const i = e.children;
          for (let r = 0, s = i.length; r < s; r++)
            this.expandByObject(i[r], t);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, ri),
            ri.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(Ur),
            Rs.subVectors(this.max, Ur),
            Hi.subVectors(e.a, Ur),
            Gi.subVectors(e.b, Ur),
            ki.subVectors(e.c, Ur),
            Rn.subVectors(Gi, Hi),
            Cn.subVectors(ki, Gi),
            si.subVectors(Hi, ki);
          let t = [
            0,
            -Rn.z,
            Rn.y,
            0,
            -Cn.z,
            Cn.y,
            0,
            -si.z,
            si.y,
            Rn.z,
            0,
            -Rn.x,
            Cn.z,
            0,
            -Cn.x,
            si.z,
            0,
            -si.x,
            -Rn.y,
            Rn.x,
            0,
            -Cn.y,
            Cn.x,
            0,
            -si.y,
            si.x,
            0,
          ];
          return !na(t, Hi, Gi, ki, Rs) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !na(t, Hi, Gi, ki, Rs))
            ? !1
            : (Cs.crossVectors(Rn, Cn),
              (t = [Cs.x, Cs.y, Cs.z]),
              na(t, Hi, Gi, ki, Rs));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return ri.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            this.getCenter(e.center),
            (e.radius = this.getSize(ri).length() * 0.5),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (dn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              dn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              dn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              dn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              dn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              dn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              dn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              dn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(dn),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      Lt.prototype.isBox3 = !0;
      const dn = [
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
        ],
        ri = new S(),
        ta = new Lt(),
        Hi = new S(),
        Gi = new S(),
        ki = new S(),
        Rn = new S(),
        Cn = new S(),
        si = new S(),
        Ur = new S(),
        Rs = new S(),
        Cs = new S(),
        oi = new S();
      function na(o, e, t, n, i) {
        for (let r = 0, s = o.length - 3; r <= s; r += 3) {
          oi.fromArray(o, r);
          const a =
              i.x * Math.abs(oi.x) +
              i.y * Math.abs(oi.y) +
              i.z * Math.abs(oi.z),
            l = e.dot(oi),
            c = t.dot(oi),
            u = n.dot(oi);
          if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
        }
        return !0;
      }
      const $f = new Lt(),
        hc = new S(),
        Ls = new S(),
        ia = new S();
      class Tn {
        constructor(e = new S(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          t !== void 0 ? n.copy(t) : $f.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let r = 0, s = e.length; r < s; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          ia.subVectors(e, this.center);
          const t = ia.lengthSq();
          if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
              i = (n - this.radius) * 0.5;
            this.center.add(ia.multiplyScalar(i / n)), (this.radius += i);
          }
          return this;
        }
        union(e) {
          return (
            this.center.equals(e.center) === !0
              ? Ls.set(0, 0, 1).multiplyScalar(e.radius)
              : Ls.subVectors(e.center, this.center)
                  .normalize()
                  .multiplyScalar(e.radius),
            this.expandByPoint(hc.copy(e.center).add(Ls)),
            this.expandByPoint(hc.copy(e.center).sub(Ls)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const fn = new S(),
        ra = new S(),
        Ps = new S(),
        Ln = new S(),
        sa = new S(),
        Is = new S(),
        oa = new S();
      class Qn {
        constructor(e = new S(), t = new S(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, fn)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = fn.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (fn.copy(this.direction).multiplyScalar(t).add(this.origin),
              fn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          ra.copy(e).add(t).multiplyScalar(0.5),
            Ps.copy(t).sub(e).normalize(),
            Ln.copy(this.origin).sub(ra);
          const r = e.distanceTo(t) * 0.5,
            s = -this.direction.dot(Ps),
            a = Ln.dot(this.direction),
            l = -Ln.dot(Ps),
            c = Ln.lengthSq(),
            u = Math.abs(1 - s * s);
          let h, d, f, g;
          if (u > 0)
            if (((h = s * l - a), (d = s * a - l), (g = r * u), h >= 0))
              if (d >= -g)
                if (d <= g) {
                  const m = 1 / u;
                  (h *= m),
                    (d *= m),
                    (f = h * (h + s * d + 2 * a) + d * (s * h + d + 2 * l) + c);
                } else
                  (d = r),
                    (h = Math.max(0, -(s * d + a))),
                    (f = -h * h + d * (d + 2 * l) + c);
              else
                (d = -r),
                  (h = Math.max(0, -(s * d + a))),
                  (f = -h * h + d * (d + 2 * l) + c);
            else
              d <= -g
                ? ((h = Math.max(0, -(-s * r + a))),
                  (d = h > 0 ? -r : Math.min(Math.max(-r, -l), r)),
                  (f = -h * h + d * (d + 2 * l) + c))
                : d <= g
                ? ((h = 0),
                  (d = Math.min(Math.max(-r, -l), r)),
                  (f = d * (d + 2 * l) + c))
                : ((h = Math.max(0, -(s * r + a))),
                  (d = h > 0 ? r : Math.min(Math.max(-r, -l), r)),
                  (f = -h * h + d * (d + 2 * l) + c));
          else
            (d = s > 0 ? -r : r),
              (h = Math.max(0, -(s * d + a))),
              (f = -h * h + d * (d + 2 * l) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
            i && i.copy(Ps).multiplyScalar(d).add(ra),
            f
          );
        }
        intersectSphere(e, t) {
          fn.subVectors(e.center, this.origin);
          const n = fn.dot(this.direction),
            i = fn.dot(fn) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const s = Math.sqrt(r - i),
            a = n - s,
            l = n + s;
          return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, s, a, l;
          const c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            h = 1 / this.direction.z,
            d = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
              : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
            u >= 0
              ? ((r = (e.min.y - d.y) * u), (s = (e.max.y - d.y) * u))
              : ((r = (e.max.y - d.y) * u), (s = (e.min.y - d.y) * u)),
            n > s ||
            r > i ||
            ((r > n || n !== n) && (n = r),
            (s < i || i !== i) && (i = s),
            h >= 0
              ? ((a = (e.min.z - d.z) * h), (l = (e.max.z - d.z) * h))
              : ((a = (e.max.z - d.z) * h), (l = (e.min.z - d.z) * h)),
            n > l || a > i) ||
            ((a > n || n !== n) && (n = a),
            (l < i || i !== i) && (i = l),
            i < 0)
              ? null
              : this.at(n >= 0 ? n : i, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, fn) !== null;
        }
        intersectTriangle(e, t, n, i, r) {
          sa.subVectors(t, e), Is.subVectors(n, e), oa.crossVectors(sa, Is);
          let s = this.direction.dot(oa),
            a;
          if (s > 0) {
            if (i) return null;
            a = 1;
          } else if (s < 0) (a = -1), (s = -s);
          else return null;
          Ln.subVectors(this.origin, e);
          const l = a * this.direction.dot(Is.crossVectors(Ln, Is));
          if (l < 0) return null;
          const c = a * this.direction.dot(sa.cross(Ln));
          if (c < 0 || l + c > s) return null;
          const u = -a * Ln.dot(oa);
          return u < 0 ? null : this.at(u / s, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class fe {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, s, a, l, c, u, h, d, f, g, m, p) {
          const x = this.elements;
          return (
            (x[0] = e),
            (x[4] = t),
            (x[8] = n),
            (x[12] = i),
            (x[1] = r),
            (x[5] = s),
            (x[9] = a),
            (x[13] = l),
            (x[2] = c),
            (x[6] = u),
            (x[10] = h),
            (x[14] = d),
            (x[3] = f),
            (x[7] = g),
            (x[11] = m),
            (x[15] = p),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new fe().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / Vi.setFromMatrixColumn(e, 0).length(),
            r = 1 / Vi.setFromMatrixColumn(e, 1).length(),
            s = 1 / Vi.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * s),
            (t[9] = n[9] * s),
            (t[10] = n[10] * s),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            s = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            u = Math.cos(r),
            h = Math.sin(r);
          if (e.order === "XYZ") {
            const d = s * u,
              f = s * h,
              g = a * u,
              m = a * h;
            (t[0] = l * u),
              (t[4] = -l * h),
              (t[8] = c),
              (t[1] = f + g * c),
              (t[5] = d - m * c),
              (t[9] = -a * l),
              (t[2] = m - d * c),
              (t[6] = g + f * c),
              (t[10] = s * l);
          } else if (e.order === "YXZ") {
            const d = l * u,
              f = l * h,
              g = c * u,
              m = c * h;
            (t[0] = d + m * a),
              (t[4] = g * a - f),
              (t[8] = s * c),
              (t[1] = s * h),
              (t[5] = s * u),
              (t[9] = -a),
              (t[2] = f * a - g),
              (t[6] = m + d * a),
              (t[10] = s * l);
          } else if (e.order === "ZXY") {
            const d = l * u,
              f = l * h,
              g = c * u,
              m = c * h;
            (t[0] = d - m * a),
              (t[4] = -s * h),
              (t[8] = g + f * a),
              (t[1] = f + g * a),
              (t[5] = s * u),
              (t[9] = m - d * a),
              (t[2] = -s * c),
              (t[6] = a),
              (t[10] = s * l);
          } else if (e.order === "ZYX") {
            const d = s * u,
              f = s * h,
              g = a * u,
              m = a * h;
            (t[0] = l * u),
              (t[4] = g * c - f),
              (t[8] = d * c + m),
              (t[1] = l * h),
              (t[5] = m * c + d),
              (t[9] = f * c - g),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = s * l);
          } else if (e.order === "YZX") {
            const d = s * l,
              f = s * c,
              g = a * l,
              m = a * c;
            (t[0] = l * u),
              (t[4] = m - d * h),
              (t[8] = g * h + f),
              (t[1] = h),
              (t[5] = s * u),
              (t[9] = -a * u),
              (t[2] = -c * u),
              (t[6] = f * h + g),
              (t[10] = d - m * h);
          } else if (e.order === "XZY") {
            const d = s * l,
              f = s * c,
              g = a * l,
              m = a * c;
            (t[0] = l * u),
              (t[4] = -h),
              (t[8] = c * u),
              (t[1] = d * h + m),
              (t[5] = s * u),
              (t[9] = f * h - g),
              (t[2] = g * h - f),
              (t[6] = a * u),
              (t[10] = m * h + d);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(Qf, e, ep);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            Pt.subVectors(e, t),
            Pt.lengthSq() === 0 && (Pt.z = 1),
            Pt.normalize(),
            Pn.crossVectors(n, Pt),
            Pn.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (Pt.x += 1e-4) : (Pt.z += 1e-4),
              Pt.normalize(),
              Pn.crossVectors(n, Pt)),
            Pn.normalize(),
            Ds.crossVectors(Pt, Pn),
            (i[0] = Pn.x),
            (i[4] = Ds.x),
            (i[8] = Pt.x),
            (i[1] = Pn.y),
            (i[5] = Ds.y),
            (i[9] = Pt.y),
            (i[2] = Pn.z),
            (i[6] = Ds.z),
            (i[10] = Pt.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            u = n[1],
            h = n[5],
            d = n[9],
            f = n[13],
            g = n[2],
            m = n[6],
            p = n[10],
            x = n[14],
            y = n[3],
            v = n[7],
            M = n[11],
            b = n[15],
            T = i[0],
            C = i[4],
            _ = i[8],
            R = i[12],
            P = i[1],
            D = i[5],
            Z = i[9],
            j = i[13],
            I = i[2],
            U = i[6],
            N = i[10],
            V = i[14],
            J = i[3],
            z = i[7],
            q = i[11],
            ee = i[15];
          return (
            (r[0] = s * T + a * P + l * I + c * J),
            (r[4] = s * C + a * D + l * U + c * z),
            (r[8] = s * _ + a * Z + l * N + c * q),
            (r[12] = s * R + a * j + l * V + c * ee),
            (r[1] = u * T + h * P + d * I + f * J),
            (r[5] = u * C + h * D + d * U + f * z),
            (r[9] = u * _ + h * Z + d * N + f * q),
            (r[13] = u * R + h * j + d * V + f * ee),
            (r[2] = g * T + m * P + p * I + x * J),
            (r[6] = g * C + m * D + p * U + x * z),
            (r[10] = g * _ + m * Z + p * N + x * q),
            (r[14] = g * R + m * j + p * V + x * ee),
            (r[3] = y * T + v * P + M * I + b * J),
            (r[7] = y * C + v * D + M * U + b * z),
            (r[11] = y * _ + v * Z + M * N + b * q),
            (r[15] = y * R + v * j + M * V + b * ee),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            s = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            u = e[2],
            h = e[6],
            d = e[10],
            f = e[14],
            g = e[3],
            m = e[7],
            p = e[11],
            x = e[15];
          return (
            g *
              (+r * l * h -
                i * c * h -
                r * a * d +
                n * c * d +
                i * a * f -
                n * l * f) +
            m *
              (+t * l * f -
                t * c * d +
                r * s * d -
                i * s * f +
                i * c * u -
                r * l * u) +
            p *
              (+t * c * h -
                t * a * f -
                r * s * h +
                n * s * f +
                r * a * u -
                n * c * u) +
            x *
              (-i * a * u -
                t * l * h +
                t * a * d +
                i * s * h -
                n * s * d +
                n * l * u)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = e[9],
            d = e[10],
            f = e[11],
            g = e[12],
            m = e[13],
            p = e[14],
            x = e[15],
            y =
              h * p * c -
              m * d * c +
              m * l * f -
              a * p * f -
              h * l * x +
              a * d * x,
            v =
              g * d * c -
              u * p * c -
              g * l * f +
              s * p * f +
              u * l * x -
              s * d * x,
            M =
              u * m * c -
              g * h * c +
              g * a * f -
              s * m * f -
              u * a * x +
              s * h * x,
            b =
              g * h * l -
              u * m * l -
              g * a * d +
              s * m * d +
              u * a * p -
              s * h * p,
            T = t * y + n * v + i * M + r * b;
          if (T === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const C = 1 / T;
          return (
            (e[0] = y * C),
            (e[1] =
              (m * d * r -
                h * p * r -
                m * i * f +
                n * p * f +
                h * i * x -
                n * d * x) *
              C),
            (e[2] =
              (a * p * r -
                m * l * r +
                m * i * c -
                n * p * c -
                a * i * x +
                n * l * x) *
              C),
            (e[3] =
              (h * l * r -
                a * d * r -
                h * i * c +
                n * d * c +
                a * i * f -
                n * l * f) *
              C),
            (e[4] = v * C),
            (e[5] =
              (u * p * r -
                g * d * r +
                g * i * f -
                t * p * f -
                u * i * x +
                t * d * x) *
              C),
            (e[6] =
              (g * l * r -
                s * p * r -
                g * i * c +
                t * p * c +
                s * i * x -
                t * l * x) *
              C),
            (e[7] =
              (s * d * r -
                u * l * r +
                u * i * c -
                t * d * c -
                s * i * f +
                t * l * f) *
              C),
            (e[8] = M * C),
            (e[9] =
              (g * h * r -
                u * m * r -
                g * n * f +
                t * m * f +
                u * n * x -
                t * h * x) *
              C),
            (e[10] =
              (s * m * r -
                g * a * r +
                g * n * c -
                t * m * c -
                s * n * x +
                t * a * x) *
              C),
            (e[11] =
              (u * a * r -
                s * h * r -
                u * n * c +
                t * h * c +
                s * n * f -
                t * a * f) *
              C),
            (e[12] = b * C),
            (e[13] =
              (u * m * i -
                g * h * i +
                g * n * d -
                t * m * d -
                u * n * p +
                t * h * p) *
              C),
            (e[14] =
              (g * a * i -
                s * m * i -
                g * n * l +
                t * m * l +
                s * n * p -
                t * a * p) *
              C),
            (e[15] =
              (s * h * i -
                u * a * i +
                u * n * l -
                t * h * l -
                s * n * d +
                t * a * d) *
              C),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            s = e.x,
            a = e.y,
            l = e.z,
            c = r * s,
            u = r * a;
          return (
            this.set(
              c * s + n,
              c * a - i * l,
              c * l + i * a,
              0,
              c * a + i * l,
              u * a + n,
              u * l - i * s,
              0,
              c * l - i * a,
              u * l + i * s,
              r * l * l + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, s) {
          return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            s = t._y,
            a = t._z,
            l = t._w,
            c = r + r,
            u = s + s,
            h = a + a,
            d = r * c,
            f = r * u,
            g = r * h,
            m = s * u,
            p = s * h,
            x = a * h,
            y = l * c,
            v = l * u,
            M = l * h,
            b = n.x,
            T = n.y,
            C = n.z;
          return (
            (i[0] = (1 - (m + x)) * b),
            (i[1] = (f + M) * b),
            (i[2] = (g - v) * b),
            (i[3] = 0),
            (i[4] = (f - M) * T),
            (i[5] = (1 - (d + x)) * T),
            (i[6] = (p + y) * T),
            (i[7] = 0),
            (i[8] = (g + v) * C),
            (i[9] = (p - y) * C),
            (i[10] = (1 - (d + m)) * C),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = Vi.set(i[0], i[1], i[2]).length();
          const s = Vi.set(i[4], i[5], i[6]).length(),
            a = Vi.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            kt.copy(this);
          const c = 1 / r,
            u = 1 / s,
            h = 1 / a;
          return (
            (kt.elements[0] *= c),
            (kt.elements[1] *= c),
            (kt.elements[2] *= c),
            (kt.elements[4] *= u),
            (kt.elements[5] *= u),
            (kt.elements[6] *= u),
            (kt.elements[8] *= h),
            (kt.elements[9] *= h),
            (kt.elements[10] *= h),
            t.setFromRotationMatrix(kt),
            (n.x = r),
            (n.y = s),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, s) {
          s === void 0 &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            l = (2 * r) / (t - e),
            c = (2 * r) / (n - i),
            u = (t + e) / (t - e),
            h = (n + i) / (n - i),
            d = -(s + r) / (s - r),
            f = (-2 * s * r) / (s - r);
          return (
            (a[0] = l),
            (a[4] = 0),
            (a[8] = u),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = h),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, s) {
          const a = this.elements,
            l = 1 / (t - e),
            c = 1 / (n - i),
            u = 1 / (s - r),
            h = (t + e) * l,
            d = (n + i) * c,
            f = (s + r) * u;
          return (
            (a[0] = 2 * l),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -h),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * u),
            (a[14] = -f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      fe.prototype.isMatrix4 = !0;
      const Vi = new S(),
        kt = new fe(),
        Qf = new S(0, 0, 0),
        ep = new S(1, 1, 1),
        Pn = new S(),
        Ds = new S(),
        Pt = new S(),
        dc = new fe(),
        fc = new yt();
      class ei {
        constructor(e = 0, t = 0, n = 0, i = ei.DefaultOrder) {
          (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
          const i = e.elements,
            r = i[0],
            s = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            u = i[9],
            h = i[2],
            d = i[6],
            f = i[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin(lt(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-u, f)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(d, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-lt(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
                  : ((this._y = Math.atan2(-h, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(lt(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-s, c)))
                  : ((this._y = 0), (this._z = Math.atan2(l, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-lt(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, c)));
              break;
            case "YZX":
              (this._z = Math.asin(lt(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-u, c)),
                    (this._y = Math.atan2(-h, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-lt(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-u, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            dc.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(dc, t, n)
          );
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return fc.setFromEuler(this), this.setFromQuaternion(fc, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      ei.prototype.isEuler = !0;
      ei.DefaultOrder = "XYZ";
      ei.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Ro {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & ((1 << e) | 0)) !== 0;
        }
      }
      let tp = 0;
      const pc = new S(),
        Wi = new yt(),
        pn = new fe(),
        Fs = new S(),
        zr = new S(),
        np = new S(),
        ip = new yt(),
        mc = new S(1, 0, 0),
        gc = new S(0, 1, 0),
        xc = new S(0, 0, 1),
        rp = { type: "added" },
        yc = { type: "removed" };
      class Ne extends Zn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: tp++ }),
            (this.uuid = Bt()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Ne.DefaultUp.clone());
          const e = new S(),
            t = new ei(),
            n = new yt(),
            i = new S(1, 1, 1);
          function r() {
            n.setFromEuler(t, !1);
          }
          function s() {
            t.setFromQuaternion(n, void 0, !1);
          }
          t._onChange(r),
            n._onChange(s),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new fe() },
              normalMatrix: { value: new mt() },
            }),
            (this.matrix = new fe()),
            (this.matrixWorld = new fe()),
            (this.matrixAutoUpdate = Ne.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Ro()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return Wi.setFromAxisAngle(e, t), this.quaternion.multiply(Wi), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            Wi.setFromAxisAngle(e, t), this.quaternion.premultiply(Wi), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(mc, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(gc, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(xc, e);
        }
        translateOnAxis(e, t) {
          return (
            pc.copy(e).applyQuaternion(this.quaternion),
            this.position.add(pc.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(mc, e);
        }
        translateY(e) {
          return this.translateOnAxis(gc, e);
        }
        translateZ(e) {
          return this.translateOnAxis(xc, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(pn.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? Fs.copy(e) : Fs.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            zr.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? pn.lookAt(zr, Fs, this.up)
              : pn.lookAt(Fs, zr, this.up),
            this.quaternion.setFromRotationMatrix(pn),
            i &&
              (pn.extractRotation(i.matrixWorld),
              Wi.setFromRotationMatrix(pn),
              this.quaternion.premultiply(Wi.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.parent !== null && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(rp))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(yc)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(yc);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            pn.copy(this.matrixWorld).invert(),
            e.parent !== null &&
              (e.parent.updateWorldMatrix(!0, !1),
              pn.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(pn),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const s = this.children[n].getObjectByProperty(e, t);
            if (s !== void 0) return s;
          }
        }
        getWorldPosition(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(zr, e, np),
            e
          );
        }
        getWorldScale(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(zr, ip, e),
            e
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            t === !0)
          ) {
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++)
              i[r].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            JSON.stringify(this.userData) !== "{}" &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (i.instanceColor = this.instanceColor.toJSON()));
          function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
          }
          if (this.isScene)
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const l = a.shapes;
              if (Array.isArray(l))
                for (let c = 0, u = l.length; c < u; c++) {
                  const h = l[c];
                  r(e.shapes, h);
                }
              else r(e.shapes, l);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const a = [];
              for (let l = 0, c = this.material.length; l < c; l++)
                a.push(r(e.materials, this.material[l]));
              i.material = a;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
              i.children.push(this.children[a].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const l = this.animations[a];
              i.animations.push(r(e.animations, l));
            }
          }
          if (t) {
            const a = s(e.geometries),
              l = s(e.materials),
              c = s(e.textures),
              u = s(e.images),
              h = s(e.shapes),
              d = s(e.skeletons),
              f = s(e.animations),
              g = s(e.nodes);
            a.length > 0 && (n.geometries = a),
              l.length > 0 && (n.materials = l),
              c.length > 0 && (n.textures = c),
              u.length > 0 && (n.images = u),
              h.length > 0 && (n.shapes = h),
              d.length > 0 && (n.skeletons = d),
              f.length > 0 && (n.animations = f),
              g.length > 0 && (n.nodes = g);
          }
          return (n.object = i), n;
          function s(a) {
            const l = [];
            for (const c in a) {
              const u = a[c];
              delete u.metadata, l.push(u);
            }
            return l;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let n = 0; n < e.children.length; n++) {
              const i = e.children[n];
              this.add(i.clone());
            }
          return this;
        }
      }
      Ne.DefaultUp = new S(0, 1, 0);
      Ne.DefaultMatrixAutoUpdate = !0;
      Ne.prototype.isObject3D = !0;
      const Vt = new S(),
        mn = new S(),
        aa = new S(),
        gn = new S(),
        qi = new S(),
        Xi = new S(),
        _c = new S(),
        la = new S(),
        ca = new S(),
        ua = new S();
      class ct {
        constructor(e = new S(), t = new S(), n = new S()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i.subVectors(n, t), Vt.subVectors(e, t), i.cross(Vt);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          Vt.subVectors(i, t), mn.subVectors(n, t), aa.subVectors(e, t);
          const s = Vt.dot(Vt),
            a = Vt.dot(mn),
            l = Vt.dot(aa),
            c = mn.dot(mn),
            u = mn.dot(aa),
            h = s * c - a * a;
          if (h === 0) return r.set(-2, -1, -1);
          const d = 1 / h,
            f = (c * l - a * u) * d,
            g = (s * u - a * l) * d;
          return r.set(1 - f - g, g, f);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, gn),
            gn.x >= 0 && gn.y >= 0 && gn.x + gn.y <= 1
          );
        }
        static getUV(e, t, n, i, r, s, a, l) {
          return (
            this.getBarycoord(e, t, n, i, gn),
            l.set(0, 0),
            l.addScaledVector(r, gn.x),
            l.addScaledVector(s, gn.y),
            l.addScaledVector(a, gn.z),
            l
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            Vt.subVectors(n, t), mn.subVectors(e, t), Vt.cross(mn).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            Vt.subVectors(this.c, this.b),
            mn.subVectors(this.a, this.b),
            Vt.cross(mn).length() * 0.5
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return ct.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return ct.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return ct.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return ct.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return ct.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let s, a;
          qi.subVectors(i, n), Xi.subVectors(r, n), la.subVectors(e, n);
          const l = qi.dot(la),
            c = Xi.dot(la);
          if (l <= 0 && c <= 0) return t.copy(n);
          ca.subVectors(e, i);
          const u = qi.dot(ca),
            h = Xi.dot(ca);
          if (u >= 0 && h <= u) return t.copy(i);
          const d = l * h - u * c;
          if (d <= 0 && l >= 0 && u <= 0)
            return (s = l / (l - u)), t.copy(n).addScaledVector(qi, s);
          ua.subVectors(e, r);
          const f = qi.dot(ua),
            g = Xi.dot(ua);
          if (g >= 0 && f <= g) return t.copy(r);
          const m = f * c - l * g;
          if (m <= 0 && c >= 0 && g <= 0)
            return (a = c / (c - g)), t.copy(n).addScaledVector(Xi, a);
          const p = u * g - f * h;
          if (p <= 0 && h - u >= 0 && f - g >= 0)
            return (
              _c.subVectors(r, i),
              (a = (h - u) / (h - u + (f - g))),
              t.copy(i).addScaledVector(_c, a)
            );
          const x = 1 / (p + m + d);
          return (
            (s = m * x),
            (a = d * x),
            t.copy(n).addScaledVector(qi, s).addScaledVector(Xi, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let sp = 0;
      class et extends Zn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: sp++ }),
            (this.uuid = Bt()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = yi),
            (this.side = Gn),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = bl),
            (this.blendDst = wl),
            (this.blendEquation = pi),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = Mo),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Uh),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = _o),
            (this.stencilZFail = _o),
            (this.stencilZPass = _o),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const n = e[t];
              if (n === void 0) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if (t === "shading") {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === Ml);
                continue;
              }
              const i = this[t];
              if (i === void 0) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
                continue;
              }
              i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen !== void 0 && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== yi && (n.blending = this.blending),
            this.side !== Gn && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation !== void 0 &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 &&
              (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            this.fog === !1 && (n.fog = !1),
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData);
          function i(r) {
            const s = [];
            for (const a in r) {
              const l = r[a];
              delete l.metadata, s.push(l);
            }
            return s;
          }
          if (t) {
            const r = i(e.textures),
              s = i(e.images);
            r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      et.prototype.isMaterial = !0;
      et.fromType = function () {
        return null;
      };
      class Ct extends et {
        constructor(e) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new ne(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = hs),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      Ct.prototype.isMeshBasicMaterial = !0;
      const dt = new S(),
        Bs = new W();
      class Ue {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n === !0),
            (this.usage = hr),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let s = e[i];
            s === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (s = new ne())),
              (t[n++] = s.r),
              (t[n++] = s.g),
              (t[n++] = s.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let s = e[i];
            s === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (s = new W())),
              (t[n++] = s.x),
              (t[n++] = s.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let s = e[i];
            s === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (s = new S())),
              (t[n++] = s.x),
              (t[n++] = s.y),
              (t[n++] = s.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let s = e[i];
            s === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (s = new Je())),
              (t[n++] = s.x),
              (t[n++] = s.y),
              (t[n++] = s.z),
              (t[n++] = s.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
              Bs.fromBufferAttribute(this, t),
                Bs.applyMatrix3(e),
                this.setXY(t, Bs.x, Bs.y);
          else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
              dt.fromBufferAttribute(this, t),
                dt.applyMatrix3(e),
                this.setXYZ(t, dt.x, dt.y, dt.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            dt.fromBufferAttribute(this, t),
              dt.applyMatrix4(e),
              this.setXYZ(t, dt.x, dt.y, dt.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            dt.fromBufferAttribute(this, t),
              dt.applyNormalMatrix(e),
              this.setXYZ(t, dt.x, dt.y, dt.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            dt.fromBufferAttribute(this, t),
              dt.transformDirection(e),
              this.setXYZ(t, dt.x, dt.y, dt.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (e.name = this.name),
            this.usage !== hr && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      Ue.prototype.isBufferAttribute = !0;
      class qh extends Ue {
        constructor(e, t, n) {
          super(new Int8Array(e), t, n);
        }
      }
      class Xh extends Ue {
        constructor(e, t, n) {
          super(new Uint8Array(e), t, n);
        }
      }
      class Jh extends Ue {
        constructor(e, t, n) {
          super(new Uint8ClampedArray(e), t, n);
        }
      }
      class Yh extends Ue {
        constructor(e, t, n) {
          super(new Int16Array(e), t, n);
        }
      }
      class Co extends Ue {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class jh extends Ue {
        constructor(e, t, n) {
          super(new Int32Array(e), t, n);
        }
      }
      class Lo extends Ue {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class Kh extends Ue {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      Kh.prototype.isFloat16BufferAttribute = !0;
      class pe extends Ue {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      class Zh extends Ue {
        constructor(e, t, n) {
          super(new Float64Array(e), t, n);
        }
      }
      let op = 0;
      const Ot = new fe(),
        ha = new Ne(),
        Ji = new S(),
        It = new Lt(),
        Hr = new Lt(),
        xt = new S();
      class _e extends Zn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: op++ }),
            (this.uuid = Bt()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (Hh(e) ? Lo : Co)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const r = new mt().getNormalMatrix(e);
            n.applyNormalMatrix(r), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Ot.makeRotationFromQuaternion(e), this.applyMatrix4(Ot), this;
        }
        rotateX(e) {
          return Ot.makeRotationX(e), this.applyMatrix4(Ot), this;
        }
        rotateY(e) {
          return Ot.makeRotationY(e), this.applyMatrix4(Ot), this;
        }
        rotateZ(e) {
          return Ot.makeRotationZ(e), this.applyMatrix4(Ot), this;
        }
        translate(e, t, n) {
          return Ot.makeTranslation(e, t, n), this.applyMatrix4(Ot), this;
        }
        scale(e, t, n) {
          return Ot.makeScale(e, t, n), this.applyMatrix4(Ot), this;
        }
        lookAt(e) {
          return (
            ha.lookAt(e), ha.updateMatrix(), this.applyMatrix4(ha.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Ji).negate(),
            this.translate(Ji.x, Ji.y, Ji.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0);
          }
          return this.setAttribute("position", new pe(t, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new Lt());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingBox.set(
                new S(-1 / 0, -1 / 0, -1 / 0),
                new S(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let n = 0, i = t.length; n < i; n++) {
                const r = t[n];
                It.setFromBufferAttribute(r),
                  this.morphTargetsRelative
                    ? (xt.addVectors(this.boundingBox.min, It.min),
                      this.boundingBox.expandByPoint(xt),
                      xt.addVectors(this.boundingBox.max, It.max),
                      this.boundingBox.expandByPoint(xt))
                    : (this.boundingBox.expandByPoint(It.min),
                      this.boundingBox.expandByPoint(It.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new Tn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingSphere.set(new S(), 1 / 0);
            return;
          }
          if (e) {
            const n = this.boundingSphere.center;
            if ((It.setFromBufferAttribute(e), t))
              for (let r = 0, s = t.length; r < s; r++) {
                const a = t[r];
                Hr.setFromBufferAttribute(a),
                  this.morphTargetsRelative
                    ? (xt.addVectors(It.min, Hr.min),
                      It.expandByPoint(xt),
                      xt.addVectors(It.max, Hr.max),
                      It.expandByPoint(xt))
                    : (It.expandByPoint(Hr.min), It.expandByPoint(Hr.max));
              }
            It.getCenter(n);
            let i = 0;
            for (let r = 0, s = e.count; r < s; r++)
              xt.fromBufferAttribute(e, r),
                (i = Math.max(i, n.distanceToSquared(xt)));
            if (t)
              for (let r = 0, s = t.length; r < s; r++) {
                const a = t[r],
                  l = this.morphTargetsRelative;
                for (let c = 0, u = a.count; c < u; c++)
                  xt.fromBufferAttribute(a, c),
                    l && (Ji.fromBufferAttribute(e, c), xt.add(Ji)),
                    (i = Math.max(i, n.distanceToSquared(xt)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            s = t.uv.array,
            a = i.length / 3;
          this.hasAttribute("tangent") === !1 &&
            this.setAttribute("tangent", new Ue(new Float32Array(4 * a), 4));
          const l = this.getAttribute("tangent").array,
            c = [],
            u = [];
          for (let P = 0; P < a; P++) (c[P] = new S()), (u[P] = new S());
          const h = new S(),
            d = new S(),
            f = new S(),
            g = new W(),
            m = new W(),
            p = new W(),
            x = new S(),
            y = new S();
          function v(P, D, Z) {
            h.fromArray(i, P * 3),
              d.fromArray(i, D * 3),
              f.fromArray(i, Z * 3),
              g.fromArray(s, P * 2),
              m.fromArray(s, D * 2),
              p.fromArray(s, Z * 2),
              d.sub(h),
              f.sub(h),
              m.sub(g),
              p.sub(g);
            const j = 1 / (m.x * p.y - p.x * m.y);
            !isFinite(j) ||
              (x
                .copy(d)
                .multiplyScalar(p.y)
                .addScaledVector(f, -m.y)
                .multiplyScalar(j),
              y
                .copy(f)
                .multiplyScalar(m.x)
                .addScaledVector(d, -p.x)
                .multiplyScalar(j),
              c[P].add(x),
              c[D].add(x),
              c[Z].add(x),
              u[P].add(y),
              u[D].add(y),
              u[Z].add(y));
          }
          let M = this.groups;
          M.length === 0 && (M = [{ start: 0, count: n.length }]);
          for (let P = 0, D = M.length; P < D; ++P) {
            const Z = M[P],
              j = Z.start,
              I = Z.count;
            for (let U = j, N = j + I; U < N; U += 3)
              v(n[U + 0], n[U + 1], n[U + 2]);
          }
          const b = new S(),
            T = new S(),
            C = new S(),
            _ = new S();
          function R(P) {
            C.fromArray(r, P * 3), _.copy(C);
            const D = c[P];
            b.copy(D),
              b.sub(C.multiplyScalar(C.dot(D))).normalize(),
              T.crossVectors(_, D);
            const j = T.dot(u[P]) < 0 ? -1 : 1;
            (l[P * 4] = b.x),
              (l[P * 4 + 1] = b.y),
              (l[P * 4 + 2] = b.z),
              (l[P * 4 + 3] = j);
          }
          for (let P = 0, D = M.length; P < D; ++P) {
            const Z = M[P],
              j = Z.start,
              I = Z.count;
            for (let U = j, N = j + I; U < N; U += 3)
              R(n[U + 0]), R(n[U + 1]), R(n[U + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new Ue(new Float32Array(t.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const i = new S(),
              r = new S(),
              s = new S(),
              a = new S(),
              l = new S(),
              c = new S(),
              u = new S(),
              h = new S();
            if (e)
              for (let d = 0, f = e.count; d < f; d += 3) {
                const g = e.getX(d + 0),
                  m = e.getX(d + 1),
                  p = e.getX(d + 2);
                i.fromBufferAttribute(t, g),
                  r.fromBufferAttribute(t, m),
                  s.fromBufferAttribute(t, p),
                  u.subVectors(s, r),
                  h.subVectors(i, r),
                  u.cross(h),
                  a.fromBufferAttribute(n, g),
                  l.fromBufferAttribute(n, m),
                  c.fromBufferAttribute(n, p),
                  a.add(u),
                  l.add(u),
                  c.add(u),
                  n.setXYZ(g, a.x, a.y, a.z),
                  n.setXYZ(m, l.x, l.y, l.z),
                  n.setXYZ(p, c.x, c.y, c.z);
              }
            else
              for (let d = 0, f = t.count; d < f; d += 3)
                i.fromBufferAttribute(t, d + 0),
                  r.fromBufferAttribute(t, d + 1),
                  s.fromBufferAttribute(t, d + 2),
                  u.subVectors(s, r),
                  h.subVectors(i, r),
                  u.cross(h),
                  n.setXYZ(d + 0, u.x, u.y, u.z),
                  n.setXYZ(d + 1, u.x, u.y, u.z),
                  n.setXYZ(d + 2, u.x, u.y, u.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!(e && e.isBufferGeometry)) {
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
            return;
          }
          t === void 0 &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (e.attributes[i] === void 0) continue;
            const s = n[i].array,
              a = e.attributes[i],
              l = a.array,
              c = a.itemSize * t,
              u = Math.min(l.length, s.length - c);
            for (let h = 0, d = c; h < u; h++, d++) s[d] = l[h];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            xt.fromBufferAttribute(e, t),
              xt.normalize(),
              e.setXYZ(t, xt.x, xt.y, xt.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              u = a.itemSize,
              h = a.normalized,
              d = new c.constructor(l.length * u);
            let f = 0,
              g = 0;
            for (let m = 0, p = l.length; m < p; m++) {
              a.isInterleavedBufferAttribute
                ? (f = l[m] * a.data.stride + a.offset)
                : (f = l[m] * u);
              for (let x = 0; x < u; x++) d[g++] = c[f++];
            }
            return new Ue(d, u, h);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new _e(),
            n = this.index.array,
            i = this.attributes;
          for (const a in i) {
            const l = i[a],
              c = e(l, n);
            t.setAttribute(a, c);
          }
          const r = this.morphAttributes;
          for (const a in r) {
            const l = [],
              c = r[a];
            for (let u = 0, h = c.length; u < h; u++) {
              const d = c[u],
                f = e(d, n);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let a = 0, l = s.length; a < l; a++) {
            const c = s[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              u = [];
            for (let h = 0, d = c.length; h < d; h++) {
              const f = c[h];
              u.push(f.toJSON(e.data));
            }
            u.length > 0 && ((i[l] = u), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          const a = this.boundingSphere;
          return (
            a !== null &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          n !== null && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const c in i) {
            const u = i[c];
            this.setAttribute(c, u.clone(t));
          }
          const r = e.morphAttributes;
          for (const c in r) {
            const u = [],
              h = r[c];
            for (let d = 0, f = h.length; d < f; d++) u.push(h[d].clone(t));
            this.morphAttributes[c] = u;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const s = e.groups;
          for (let c = 0, u = s.length; c < u; c++) {
            const h = s[c];
            this.addGroup(h.start, h.count, h.materialIndex);
          }
          const a = e.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            l !== null && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            e.parameters !== void 0 &&
              (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      _e.prototype.isBufferGeometry = !0;
      const vc = new fe(),
        Yi = new Qn(),
        da = new Tn(),
        In = new S(),
        Dn = new S(),
        Fn = new S(),
        fa = new S(),
        pa = new S(),
        ma = new S(),
        Ns = new S(),
        Os = new S(),
        Us = new S(),
        zs = new W(),
        Hs = new W(),
        Gs = new W(),
        ga = new S(),
        ks = new S();
      class ut extends Ne {
        constructor(e = new _e(), t = new Ct()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            e.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, s = i.length; r < s; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (
            i === void 0 ||
            (n.boundingSphere === null && n.computeBoundingSphere(),
            da.copy(n.boundingSphere),
            da.applyMatrix4(r),
            e.ray.intersectsSphere(da) === !1) ||
            (vc.copy(r).invert(),
            Yi.copy(e.ray).applyMatrix4(vc),
            n.boundingBox !== null && Yi.intersectsBox(n.boundingBox) === !1)
          )
            return;
          let s;
          if (n.isBufferGeometry) {
            const a = n.index,
              l = n.attributes.position,
              c = n.morphAttributes.position,
              u = n.morphTargetsRelative,
              h = n.attributes.uv,
              d = n.attributes.uv2,
              f = n.groups,
              g = n.drawRange;
            if (a !== null)
              if (Array.isArray(i))
                for (let m = 0, p = f.length; m < p; m++) {
                  const x = f[m],
                    y = i[x.materialIndex],
                    v = Math.max(x.start, g.start),
                    M = Math.min(
                      a.count,
                      Math.min(x.start + x.count, g.start + g.count)
                    );
                  for (let b = v, T = M; b < T; b += 3) {
                    const C = a.getX(b),
                      _ = a.getX(b + 1),
                      R = a.getX(b + 2);
                    (s = Vs(this, y, e, Yi, l, c, u, h, d, C, _, R)),
                      s &&
                        ((s.faceIndex = Math.floor(b / 3)),
                        (s.face.materialIndex = x.materialIndex),
                        t.push(s));
                  }
                }
              else {
                const m = Math.max(0, g.start),
                  p = Math.min(a.count, g.start + g.count);
                for (let x = m, y = p; x < y; x += 3) {
                  const v = a.getX(x),
                    M = a.getX(x + 1),
                    b = a.getX(x + 2);
                  (s = Vs(this, i, e, Yi, l, c, u, h, d, v, M, b)),
                    s && ((s.faceIndex = Math.floor(x / 3)), t.push(s));
                }
              }
            else if (l !== void 0)
              if (Array.isArray(i))
                for (let m = 0, p = f.length; m < p; m++) {
                  const x = f[m],
                    y = i[x.materialIndex],
                    v = Math.max(x.start, g.start),
                    M = Math.min(
                      l.count,
                      Math.min(x.start + x.count, g.start + g.count)
                    );
                  for (let b = v, T = M; b < T; b += 3) {
                    const C = b,
                      _ = b + 1,
                      R = b + 2;
                    (s = Vs(this, y, e, Yi, l, c, u, h, d, C, _, R)),
                      s &&
                        ((s.faceIndex = Math.floor(b / 3)),
                        (s.face.materialIndex = x.materialIndex),
                        t.push(s));
                  }
                }
              else {
                const m = Math.max(0, g.start),
                  p = Math.min(l.count, g.start + g.count);
                for (let x = m, y = p; x < y; x += 3) {
                  const v = x,
                    M = x + 1,
                    b = x + 2;
                  (s = Vs(this, i, e, Yi, l, c, u, h, d, v, M, b)),
                    s && ((s.faceIndex = Math.floor(x / 3)), t.push(s));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      ut.prototype.isMesh = !0;
      function ap(o, e, t, n, i, r, s, a) {
        let l;
        if (
          (e.side === Ft
            ? (l = n.intersectTriangle(s, r, i, !0, a))
            : (l = n.intersectTriangle(i, r, s, e.side !== kn, a)),
          l === null)
        )
          return null;
        ks.copy(a), ks.applyMatrix4(o.matrixWorld);
        const c = t.ray.origin.distanceTo(ks);
        return c < t.near || c > t.far
          ? null
          : { distance: c, point: ks.clone(), object: o };
      }
      function Vs(o, e, t, n, i, r, s, a, l, c, u, h) {
        In.fromBufferAttribute(i, c),
          Dn.fromBufferAttribute(i, u),
          Fn.fromBufferAttribute(i, h);
        const d = o.morphTargetInfluences;
        if (r && d) {
          Ns.set(0, 0, 0), Os.set(0, 0, 0), Us.set(0, 0, 0);
          for (let g = 0, m = r.length; g < m; g++) {
            const p = d[g],
              x = r[g];
            p !== 0 &&
              (fa.fromBufferAttribute(x, c),
              pa.fromBufferAttribute(x, u),
              ma.fromBufferAttribute(x, h),
              s
                ? (Ns.addScaledVector(fa, p),
                  Os.addScaledVector(pa, p),
                  Us.addScaledVector(ma, p))
                : (Ns.addScaledVector(fa.sub(In), p),
                  Os.addScaledVector(pa.sub(Dn), p),
                  Us.addScaledVector(ma.sub(Fn), p)));
          }
          In.add(Ns), Dn.add(Os), Fn.add(Us);
        }
        o.isSkinnedMesh &&
          (o.boneTransform(c, In),
          o.boneTransform(u, Dn),
          o.boneTransform(h, Fn));
        const f = ap(o, e, t, n, In, Dn, Fn, ga);
        if (f) {
          a &&
            (zs.fromBufferAttribute(a, c),
            Hs.fromBufferAttribute(a, u),
            Gs.fromBufferAttribute(a, h),
            (f.uv = ct.getUV(ga, In, Dn, Fn, zs, Hs, Gs, new W()))),
            l &&
              (zs.fromBufferAttribute(l, c),
              Hs.fromBufferAttribute(l, u),
              Gs.fromBufferAttribute(l, h),
              (f.uv2 = ct.getUV(ga, In, Dn, Fn, zs, Hs, Gs, new W())));
          const g = { a: c, b: u, c: h, normal: new S(), materialIndex: 0 };
          ct.getNormal(In, Dn, Fn, g.normal), (f.face = g);
        }
        return f;
      }
      class bn extends _e {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: s,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
          const l = [],
            c = [],
            u = [],
            h = [];
          let d = 0,
            f = 0;
          g("z", "y", "x", -1, -1, n, t, e, s, r, 0),
            g("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
            g("x", "z", "y", 1, 1, e, n, t, i, s, 2),
            g("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
            g("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            g("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(l),
            this.setAttribute("position", new pe(c, 3)),
            this.setAttribute("normal", new pe(u, 3)),
            this.setAttribute("uv", new pe(h, 2));
          function g(m, p, x, y, v, M, b, T, C, _, R) {
            const P = M / C,
              D = b / _,
              Z = M / 2,
              j = b / 2,
              I = T / 2,
              U = C + 1,
              N = _ + 1;
            let V = 0,
              J = 0;
            const z = new S();
            for (let q = 0; q < N; q++) {
              const ee = q * D - j;
              for (let $ = 0; $ < U; $++) {
                const te = $ * P - Z;
                (z[m] = te * y),
                  (z[p] = ee * v),
                  (z[x] = I),
                  c.push(z.x, z.y, z.z),
                  (z[m] = 0),
                  (z[p] = 0),
                  (z[x] = T > 0 ? 1 : -1),
                  u.push(z.x, z.y, z.z),
                  h.push($ / C),
                  h.push(1 - q / _),
                  (V += 1);
              }
            }
            for (let q = 0; q < _; q++)
              for (let ee = 0; ee < C; ee++) {
                const $ = d + ee + U * q,
                  te = d + ee + U * (q + 1),
                  xe = d + (ee + 1) + U * (q + 1),
                  ye = d + (ee + 1) + U * q;
                l.push($, te, ye), l.push(te, xe, ye), (J += 6);
              }
            a.addGroup(f, J, R), (f += J), (d += V);
          }
        }
        static fromJSON(e) {
          return new bn(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function fr(o) {
        const e = {};
        for (const t in o) {
          e[t] = {};
          for (const n in o[t]) {
            const i = o[t][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (e[t][n] = i.clone())
              : Array.isArray(i)
              ? (e[t][n] = i.slice())
              : (e[t][n] = i);
          }
        }
        return e;
      }
      function vt(o) {
        const e = {};
        for (let t = 0; t < o.length; t++) {
          const n = fr(o[t]);
          for (const i in n) e[i] = n[i];
        }
        return e;
      }
      const $h = { clone: fr, merge: vt };
      var lp = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        cp = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class zt extends et {
        constructor(e) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = lp),
            (this.fragmentShader = cp),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 &&
              (e.attributes !== void 0 &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = fr(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const i in this.uniforms) {
            const s = this.uniforms[i].value;
            s && s.isTexture
              ? (t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
              : s && s.isColor
              ? (t.uniforms[i] = { type: "c", value: s.getHex() })
              : s && s.isVector2
              ? (t.uniforms[i] = { type: "v2", value: s.toArray() })
              : s && s.isVector3
              ? (t.uniforms[i] = { type: "v3", value: s.toArray() })
              : s && s.isVector4
              ? (t.uniforms[i] = { type: "v4", value: s.toArray() })
              : s && s.isMatrix3
              ? (t.uniforms[i] = { type: "m3", value: s.toArray() })
              : s && s.isMatrix4
              ? (t.uniforms[i] = { type: "m4", value: s.toArray() })
              : (t.uniforms[i] = { value: s });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      zt.prototype.isShaderMaterial = !0;
      class fs extends Ne {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new fe()),
            (this.projectionMatrix = new fe()),
            (this.projectionMatrixInverse = new fe());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      fs.prototype.isCamera = !0;
      class pt extends fs {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = rs * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(vi * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return rs * 2 * Math.atan(Math.tan(vi * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, r, s) {
          (this.aspect = e / t),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(vi * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const s = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = s.fullWidth,
              c = s.fullHeight;
            (r += (s.offsetX * i) / l),
              (t -= (s.offsetY * n) / c),
              (i *= s.width / l),
              (n *= s.height / c);
          }
          const a = this.filmOffset;
          a !== 0 && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      pt.prototype.isPerspectiveCamera = !0;
      const ji = 90,
        Ki = 1;
      class Po extends Ne {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            n.isWebGLCubeRenderTarget !== !0)
          ) {
            console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
            return;
          }
          this.renderTarget = n;
          const i = new pt(ji, Ki, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new S(1, 0, 0)),
            this.add(i);
          const r = new pt(ji, Ki, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new S(-1, 0, 0)),
            this.add(r);
          const s = new pt(ji, Ki, e, t);
          (s.layers = this.layers),
            s.up.set(0, 0, 1),
            s.lookAt(new S(0, 1, 0)),
            this.add(s);
          const a = new pt(ji, Ki, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new S(0, -1, 0)),
            this.add(a);
          const l = new pt(ji, Ki, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new S(0, 0, 1)),
            this.add(l);
          const c = new pt(ji, Ki, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new S(0, 0, -1)),
            this.add(c);
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, s, a, l, c] = this.children,
            u = e.getRenderTarget(),
            h = e.toneMapping,
            d = e.xr.enabled;
          (e.toneMapping = sn), (e.xr.enabled = !1);
          const f = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, r),
            e.setRenderTarget(n, 2),
            e.render(t, s),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            (n.texture.generateMipmaps = f),
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            (e.toneMapping = h),
            (e.xr.enabled = d),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class Lr extends st {
        constructor(e, t, n, i, r, s, a, l, c, u) {
          (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : Vn),
            super(e, t, n, i, r, s, a, l, c, u),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      Lr.prototype.isCubeTexture = !0;
      class Io extends Tt {
        constructor(e, t = {}) {
          super(e, e, t);
          const n = { width: e, height: e, depth: 1 },
            i = [n, n, n, n, n, n];
          (this.texture = new Lr(
            i,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
              t.minFilter !== void 0 ? t.minFilter : tt);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new bn(5, 5, 5),
            r = new zt({
              name: "CubemapFromEquirect",
              uniforms: fr(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: Ft,
              blending: vn,
            });
          r.uniforms.tEquirect.value = t;
          const s = new ut(i, r),
            a = t.minFilter;
          return (
            t.minFilter === Sn && (t.minFilter = tt),
            new Po(1, 10, this).update(e, s),
            (t.minFilter = a),
            s.geometry.dispose(),
            s.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let s = 0; s < 6; s++)
            e.setRenderTarget(this, s), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      Io.prototype.isWebGLCubeRenderTarget = !0;
      const xa = new S(),
        up = new S(),
        hp = new mt();
      class nn {
        constructor(e = new S(1, 0, 0), t = 0) {
          (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = xa.subVectors(n, t).cross(up.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(e))
            .add(e);
        }
        intersectLine(e, t) {
          const n = e.delta(xa),
            i = this.normal.dot(n);
          if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const n = t || hp.getNormalMatrix(e),
            i = this.coplanarPoint(xa).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      nn.prototype.isPlane = !0;
      const Zi = new Tn(),
        Ws = new S();
      class ps {
        constructor(
          e = new nn(),
          t = new nn(),
          n = new nn(),
          i = new nn(),
          r = new nn(),
          s = new nn()
        ) {
          this.planes = [e, t, n, i, r, s];
        }
        set(e, t, n, i, r, s) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(s),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            s = n[2],
            a = n[3],
            l = n[4],
            c = n[5],
            u = n[6],
            h = n[7],
            d = n[8],
            f = n[9],
            g = n[10],
            m = n[11],
            p = n[12],
            x = n[13],
            y = n[14],
            v = n[15];
          return (
            t[0].setComponents(a - i, h - l, m - d, v - p).normalize(),
            t[1].setComponents(a + i, h + l, m + d, v + p).normalize(),
            t[2].setComponents(a + r, h + c, m + f, v + x).normalize(),
            t[3].setComponents(a - r, h - c, m - f, v - x).normalize(),
            t[4].setComponents(a - s, h - u, m - g, v - y).normalize(),
            t[5].setComponents(a + s, h + u, m + g, v + y).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            t.boundingSphere === null && t.computeBoundingSphere(),
            Zi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Zi)
          );
        }
        intersectsSprite(e) {
          return (
            Zi.center.set(0, 0, 0),
            (Zi.radius = 0.7071067811865476),
            Zi.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Zi)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((Ws.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (Ws.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (Ws.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(Ws) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Qh() {
        let o = null,
          e = !1,
          t = null,
          n = null;
        function i(r, s) {
          t(r, s), (n = o.requestAnimationFrame(i));
        }
        return {
          start: function () {
            e !== !0 &&
              t !== null &&
              ((n = o.requestAnimationFrame(i)), (e = !0));
          },
          stop: function () {
            o.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (r) {
            t = r;
          },
          setContext: function (r) {
            o = r;
          },
        };
      }
      function dp(o, e) {
        const t = e.isWebGL2,
          n = new WeakMap();
        function i(c, u) {
          const h = c.array,
            d = c.usage,
            f = o.createBuffer();
          o.bindBuffer(u, f), o.bufferData(u, h, d), c.onUploadCallback();
          let g;
          if (h instanceof Float32Array) g = 5126;
          else if (h instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
              if (t) g = 5131;
              else
                throw new Error(
                  "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                );
            else g = 5123;
          else if (h instanceof Int16Array) g = 5122;
          else if (h instanceof Uint32Array) g = 5125;
          else if (h instanceof Int32Array) g = 5124;
          else if (h instanceof Int8Array) g = 5120;
          else if (h instanceof Uint8Array) g = 5121;
          else if (h instanceof Uint8ClampedArray) g = 5121;
          else
            throw new Error(
              "THREE.WebGLAttributes: Unsupported buffer data format: " + h
            );
          return {
            buffer: f,
            type: g,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: c.version,
          };
        }
        function r(c, u, h) {
          const d = u.array,
            f = u.updateRange;
          o.bindBuffer(h, c),
            f.count === -1
              ? o.bufferSubData(h, 0, d)
              : (t
                  ? o.bufferSubData(
                      h,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d,
                      f.offset,
                      f.count
                    )
                  : o.bufferSubData(
                      h,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d.subarray(f.offset, f.offset + f.count)
                    ),
                (f.count = -1));
        }
        function s(c) {
          return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
        }
        function a(c) {
          c.isInterleavedBufferAttribute && (c = c.data);
          const u = n.get(c);
          u && (o.deleteBuffer(u.buffer), n.delete(c));
        }
        function l(c, u) {
          if (c.isGLBufferAttribute) {
            const d = n.get(c);
            (!d || d.version < c.version) &&
              n.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version,
              });
            return;
          }
          c.isInterleavedBufferAttribute && (c = c.data);
          const h = n.get(c);
          h === void 0
            ? n.set(c, i(c, u))
            : h.version < c.version &&
              (r(h.buffer, c, u), (h.version = c.version));
        }
        return { get: s, remove: a, update: l };
      }
      class Ti extends _e {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            s = t / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            u = l + 1,
            h = e / a,
            d = t / l,
            f = [],
            g = [],
            m = [],
            p = [];
          for (let x = 0; x < u; x++) {
            const y = x * d - s;
            for (let v = 0; v < c; v++) {
              const M = v * h - r;
              g.push(M, -y, 0),
                m.push(0, 0, 1),
                p.push(v / a),
                p.push(1 - x / l);
            }
          }
          for (let x = 0; x < l; x++)
            for (let y = 0; y < a; y++) {
              const v = y + c * x,
                M = y + c * (x + 1),
                b = y + 1 + c * (x + 1),
                T = y + 1 + c * x;
              f.push(v, M, T), f.push(M, b, T);
            }
          this.setIndex(f),
            this.setAttribute("position", new pe(g, 3)),
            this.setAttribute("normal", new pe(m, 3)),
            this.setAttribute("uv", new pe(p, 2));
        }
        static fromJSON(e) {
          return new Ti(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      var fp = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
        pp = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        mp = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
        gp = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        xp = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        yp = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        _p = "vec3 transformed = vec3( position );",
        vp = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        Mp = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
        bp = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        wp = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
        Sp = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        Tp = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        Ep = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        Ap = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        Rp = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        Cp = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
        Lp = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
        Pp = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
        Ip = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        Dp = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Fp = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        Bp = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
        Np = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        Op = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        Up = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        zp = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        Hp = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        Gp = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        kp = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        Vp = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        Wp = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        qp = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        Xp = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        Jp = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        Yp = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        jp = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
        Kp = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
        Zp = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        $p = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
        Qp = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        em = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
        tm = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        nm = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
        im = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        rm = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
        sm = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
        om = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        am = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        lm = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        cm = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
        um = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        hm = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        dm = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
        fm = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
        pm = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        mm = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        gm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        xm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        ym = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        _m = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        vm = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        Mm = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
        bm = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
        wm = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
        Sm = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
        Tm = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        Em = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        Am = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        Rm = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        Cm = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
        Lm = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
        Pm = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
        Im = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
        Dm = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        Fm = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
        Bm = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        Nm = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        Om = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        Um = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        zm = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        Hm = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        Gm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
        km = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        Vm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
        Wm = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        qm = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        Xm = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
        Jm = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        Ym = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        jm = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        Km = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        Zm = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        $m = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        Qm = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
        eg = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
        tg = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
        ng = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
        ig = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
        rg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
        sg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
        og = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
        ag = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const lg = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        cg = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        ug = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        hg = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        dg = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        fg = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
        pg = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        mg = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        gg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        xg = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        yg = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        _g = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        vg = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        Mg = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        bg = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        wg = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Sg = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        Tg = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Eg = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        Ag = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
        Rg = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Cg = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Lg = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
        Pg = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Ig = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Dg = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Fg = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        Bg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        Ng = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Og = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Ug = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        zg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Be = {
          alphamap_fragment: fp,
          alphamap_pars_fragment: pp,
          alphatest_fragment: mp,
          alphatest_pars_fragment: gp,
          aomap_fragment: xp,
          aomap_pars_fragment: yp,
          begin_vertex: _p,
          beginnormal_vertex: vp,
          bsdfs: Mp,
          bumpmap_pars_fragment: bp,
          clipping_planes_fragment: wp,
          clipping_planes_pars_fragment: Sp,
          clipping_planes_pars_vertex: Tp,
          clipping_planes_vertex: Ep,
          color_fragment: Ap,
          color_pars_fragment: Rp,
          color_pars_vertex: Cp,
          color_vertex: Lp,
          common: Pp,
          cube_uv_reflection_fragment: Ip,
          defaultnormal_vertex: Dp,
          displacementmap_pars_vertex: Fp,
          displacementmap_vertex: Bp,
          emissivemap_fragment: Np,
          emissivemap_pars_fragment: Op,
          encodings_fragment: Up,
          encodings_pars_fragment: zp,
          envmap_fragment: Hp,
          envmap_common_pars_fragment: Gp,
          envmap_pars_fragment: kp,
          envmap_pars_vertex: Vp,
          envmap_physical_pars_fragment: em,
          envmap_vertex: Wp,
          fog_vertex: qp,
          fog_pars_vertex: Xp,
          fog_fragment: Jp,
          fog_pars_fragment: Yp,
          gradientmap_pars_fragment: jp,
          lightmap_fragment: Kp,
          lightmap_pars_fragment: Zp,
          lights_lambert_vertex: $p,
          lights_pars_begin: Qp,
          lights_toon_fragment: tm,
          lights_toon_pars_fragment: nm,
          lights_phong_fragment: im,
          lights_phong_pars_fragment: rm,
          lights_physical_fragment: sm,
          lights_physical_pars_fragment: om,
          lights_fragment_begin: am,
          lights_fragment_maps: lm,
          lights_fragment_end: cm,
          logdepthbuf_fragment: um,
          logdepthbuf_pars_fragment: hm,
          logdepthbuf_pars_vertex: dm,
          logdepthbuf_vertex: fm,
          map_fragment: pm,
          map_pars_fragment: mm,
          map_particle_fragment: gm,
          map_particle_pars_fragment: xm,
          metalnessmap_fragment: ym,
          metalnessmap_pars_fragment: _m,
          morphcolor_vertex: vm,
          morphnormal_vertex: Mm,
          morphtarget_pars_vertex: bm,
          morphtarget_vertex: wm,
          normal_fragment_begin: Sm,
          normal_fragment_maps: Tm,
          normal_pars_fragment: Em,
          normal_pars_vertex: Am,
          normal_vertex: Rm,
          normalmap_pars_fragment: Cm,
          clearcoat_normal_fragment_begin: Lm,
          clearcoat_normal_fragment_maps: Pm,
          clearcoat_pars_fragment: Im,
          output_fragment: Dm,
          packing: Fm,
          premultiplied_alpha_fragment: Bm,
          project_vertex: Nm,
          dithering_fragment: Om,
          dithering_pars_fragment: Um,
          roughnessmap_fragment: zm,
          roughnessmap_pars_fragment: Hm,
          shadowmap_pars_fragment: Gm,
          shadowmap_pars_vertex: km,
          shadowmap_vertex: Vm,
          shadowmask_pars_fragment: Wm,
          skinbase_vertex: qm,
          skinning_pars_vertex: Xm,
          skinning_vertex: Jm,
          skinnormal_vertex: Ym,
          specularmap_fragment: jm,
          specularmap_pars_fragment: Km,
          tonemapping_fragment: Zm,
          tonemapping_pars_fragment: $m,
          transmission_fragment: Qm,
          transmission_pars_fragment: eg,
          uv_pars_fragment: tg,
          uv_pars_vertex: ng,
          uv_vertex: ig,
          uv2_pars_fragment: rg,
          uv2_pars_vertex: sg,
          uv2_vertex: og,
          worldpos_vertex: ag,
          background_vert: lg,
          background_frag: cg,
          cube_vert: ug,
          cube_frag: hg,
          depth_vert: dg,
          depth_frag: fg,
          distanceRGBA_vert: pg,
          distanceRGBA_frag: mg,
          equirect_vert: gg,
          equirect_frag: xg,
          linedashed_vert: yg,
          linedashed_frag: _g,
          meshbasic_vert: vg,
          meshbasic_frag: Mg,
          meshlambert_vert: bg,
          meshlambert_frag: wg,
          meshmatcap_vert: Sg,
          meshmatcap_frag: Tg,
          meshnormal_vert: Eg,
          meshnormal_frag: Ag,
          meshphong_vert: Rg,
          meshphong_frag: Cg,
          meshphysical_vert: Lg,
          meshphysical_frag: Pg,
          meshtoon_vert: Ig,
          meshtoon_frag: Dg,
          points_vert: Fg,
          points_frag: Bg,
          shadow_vert: Ng,
          shadow_frag: Og,
          sprite_vert: Ug,
          sprite_frag: zg,
        },
        ae = {
          common: {
            diffuse: { value: new ne(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new mt() },
            uv2Transform: { value: new mt() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new W(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new ne(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new ne(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new mt() },
          },
          sprite: {
            diffuse: { value: new ne(16777215) },
            opacity: { value: 1 },
            center: { value: new W(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new mt() },
          },
        },
        Xt = {
          basic: {
            uniforms: vt([
              ae.common,
              ae.specularmap,
              ae.envmap,
              ae.aomap,
              ae.lightmap,
              ae.fog,
            ]),
            vertexShader: Be.meshbasic_vert,
            fragmentShader: Be.meshbasic_frag,
          },
          lambert: {
            uniforms: vt([
              ae.common,
              ae.specularmap,
              ae.envmap,
              ae.aomap,
              ae.lightmap,
              ae.emissivemap,
              ae.fog,
              ae.lights,
              { emissive: { value: new ne(0) } },
            ]),
            vertexShader: Be.meshlambert_vert,
            fragmentShader: Be.meshlambert_frag,
          },
          phong: {
            uniforms: vt([
              ae.common,
              ae.specularmap,
              ae.envmap,
              ae.aomap,
              ae.lightmap,
              ae.emissivemap,
              ae.bumpmap,
              ae.normalmap,
              ae.displacementmap,
              ae.fog,
              ae.lights,
              {
                emissive: { value: new ne(0) },
                specular: { value: new ne(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Be.meshphong_vert,
            fragmentShader: Be.meshphong_frag,
          },
          standard: {
            uniforms: vt([
              ae.common,
              ae.envmap,
              ae.aomap,
              ae.lightmap,
              ae.emissivemap,
              ae.bumpmap,
              ae.normalmap,
              ae.displacementmap,
              ae.roughnessmap,
              ae.metalnessmap,
              ae.fog,
              ae.lights,
              {
                emissive: { value: new ne(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Be.meshphysical_vert,
            fragmentShader: Be.meshphysical_frag,
          },
          toon: {
            uniforms: vt([
              ae.common,
              ae.aomap,
              ae.lightmap,
              ae.emissivemap,
              ae.bumpmap,
              ae.normalmap,
              ae.displacementmap,
              ae.gradientmap,
              ae.fog,
              ae.lights,
              { emissive: { value: new ne(0) } },
            ]),
            vertexShader: Be.meshtoon_vert,
            fragmentShader: Be.meshtoon_frag,
          },
          matcap: {
            uniforms: vt([
              ae.common,
              ae.bumpmap,
              ae.normalmap,
              ae.displacementmap,
              ae.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Be.meshmatcap_vert,
            fragmentShader: Be.meshmatcap_frag,
          },
          points: {
            uniforms: vt([ae.points, ae.fog]),
            vertexShader: Be.points_vert,
            fragmentShader: Be.points_frag,
          },
          dashed: {
            uniforms: vt([
              ae.common,
              ae.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Be.linedashed_vert,
            fragmentShader: Be.linedashed_frag,
          },
          depth: {
            uniforms: vt([ae.common, ae.displacementmap]),
            vertexShader: Be.depth_vert,
            fragmentShader: Be.depth_frag,
          },
          normal: {
            uniforms: vt([
              ae.common,
              ae.bumpmap,
              ae.normalmap,
              ae.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Be.meshnormal_vert,
            fragmentShader: Be.meshnormal_frag,
          },
          sprite: {
            uniforms: vt([ae.sprite, ae.fog]),
            vertexShader: Be.sprite_vert,
            fragmentShader: Be.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new mt() },
              t2D: { value: null },
            },
            vertexShader: Be.background_vert,
            fragmentShader: Be.background_frag,
          },
          cube: {
            uniforms: vt([ae.envmap, { opacity: { value: 1 } }]),
            vertexShader: Be.cube_vert,
            fragmentShader: Be.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Be.equirect_vert,
            fragmentShader: Be.equirect_frag,
          },
          distanceRGBA: {
            uniforms: vt([
              ae.common,
              ae.displacementmap,
              {
                referencePosition: { value: new S() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Be.distanceRGBA_vert,
            fragmentShader: Be.distanceRGBA_frag,
          },
          shadow: {
            uniforms: vt([
              ae.lights,
              ae.fog,
              { color: { value: new ne(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Be.shadow_vert,
            fragmentShader: Be.shadow_frag,
          },
        };
      Xt.physical = {
        uniforms: vt([
          Xt.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new W(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new ne(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new W() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new ne(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new ne(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: Be.meshphysical_vert,
        fragmentShader: Be.meshphysical_frag,
      };
      function Hg(o, e, t, n, i, r) {
        const s = new ne(0);
        let a = i === !0 ? 0 : 1,
          l,
          c,
          u = null,
          h = 0,
          d = null;
        function f(m, p) {
          let x = !1,
            y = p.isScene === !0 ? p.background : null;
          y && y.isTexture && (y = e.get(y));
          const v = o.xr,
            M = v.getSession && v.getSession();
          M && M.environmentBlendMode === "additive" && (y = null),
            y === null ? g(s, a) : y && y.isColor && (g(y, 1), (x = !0)),
            (o.autoClear || x) &&
              o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil),
            y && (y.isCubeTexture || y.mapping === Rr)
              ? (c === void 0 &&
                  ((c = new ut(
                    new bn(1, 1, 1),
                    new zt({
                      name: "BackgroundCubeMaterial",
                      uniforms: fr(Xt.cube.uniforms),
                      vertexShader: Xt.cube.vertexShader,
                      fragmentShader: Xt.cube.fragmentShader,
                      side: Ft,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  c.geometry.deleteAttribute("uv"),
                  (c.onBeforeRender = function (b, T, C) {
                    this.matrixWorld.copyPosition(C.matrixWorld);
                  }),
                  Object.defineProperty(c.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(c)),
                (c.material.uniforms.envMap.value = y),
                (c.material.uniforms.flipEnvMap.value =
                  y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
                (u !== y || h !== y.version || d !== o.toneMapping) &&
                  ((c.material.needsUpdate = !0),
                  (u = y),
                  (h = y.version),
                  (d = o.toneMapping)),
                c.layers.enableAll(),
                m.unshift(c, c.geometry, c.material, 0, 0, null))
              : y &&
                y.isTexture &&
                (l === void 0 &&
                  ((l = new ut(
                    new Ti(2, 2),
                    new zt({
                      name: "BackgroundMaterial",
                      uniforms: fr(Xt.background.uniforms),
                      vertexShader: Xt.background.vertexShader,
                      fragmentShader: Xt.background.fragmentShader,
                      side: Gn,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  Object.defineProperty(l.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(l)),
                (l.material.uniforms.t2D.value = y),
                y.matrixAutoUpdate === !0 && y.updateMatrix(),
                l.material.uniforms.uvTransform.value.copy(y.matrix),
                (u !== y || h !== y.version || d !== o.toneMapping) &&
                  ((l.material.needsUpdate = !0),
                  (u = y),
                  (h = y.version),
                  (d = o.toneMapping)),
                l.layers.enableAll(),
                m.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function g(m, p) {
          t.buffers.color.setClear(m.r, m.g, m.b, p, r);
        }
        return {
          getClearColor: function () {
            return s;
          },
          setClearColor: function (m, p = 1) {
            s.set(m), (a = p), g(s, a);
          },
          getClearAlpha: function () {
            return a;
          },
          setClearAlpha: function (m) {
            (a = m), g(s, a);
          },
          render: f,
        };
      }
      function Gg(o, e, t, n) {
        const i = o.getParameter(34921),
          r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          s = n.isWebGL2 || r !== null,
          a = {},
          l = p(null);
        let c = l,
          u = !1;
        function h(I, U, N, V, J) {
          let z = !1;
          if (s) {
            const q = m(V, N, U);
            c !== q && ((c = q), f(c.object)),
              (z = x(I, V, N, J)),
              z && y(I, V, N, J);
          } else {
            const q = U.wireframe === !0;
            (c.geometry !== V.id || c.program !== N.id || c.wireframe !== q) &&
              ((c.geometry = V.id),
              (c.program = N.id),
              (c.wireframe = q),
              (z = !0));
          }
          J !== null && t.update(J, 34963),
            (z || u) &&
              ((u = !1),
              _(I, U, N, V),
              J !== null && o.bindBuffer(34963, t.get(J).buffer));
        }
        function d() {
          return n.isWebGL2 ? o.createVertexArray() : r.createVertexArrayOES();
        }
        function f(I) {
          return n.isWebGL2 ? o.bindVertexArray(I) : r.bindVertexArrayOES(I);
        }
        function g(I) {
          return n.isWebGL2
            ? o.deleteVertexArray(I)
            : r.deleteVertexArrayOES(I);
        }
        function m(I, U, N) {
          const V = N.wireframe === !0;
          let J = a[I.id];
          J === void 0 && ((J = {}), (a[I.id] = J));
          let z = J[U.id];
          z === void 0 && ((z = {}), (J[U.id] = z));
          let q = z[V];
          return q === void 0 && ((q = p(d())), (z[V] = q)), q;
        }
        function p(I) {
          const U = [],
            N = [],
            V = [];
          for (let J = 0; J < i; J++) (U[J] = 0), (N[J] = 0), (V[J] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: U,
            enabledAttributes: N,
            attributeDivisors: V,
            object: I,
            attributes: {},
            index: null,
          };
        }
        function x(I, U, N, V) {
          const J = c.attributes,
            z = U.attributes;
          let q = 0;
          const ee = N.getAttributes();
          for (const $ in ee)
            if (ee[$].location >= 0) {
              const xe = J[$];
              let ye = z[$];
              if (
                (ye === void 0 &&
                  ($ === "instanceMatrix" &&
                    I.instanceMatrix &&
                    (ye = I.instanceMatrix),
                  $ === "instanceColor" &&
                    I.instanceColor &&
                    (ye = I.instanceColor)),
                xe === void 0 ||
                  xe.attribute !== ye ||
                  (ye && xe.data !== ye.data))
              )
                return !0;
              q++;
            }
          return c.attributesNum !== q || c.index !== V;
        }
        function y(I, U, N, V) {
          const J = {},
            z = U.attributes;
          let q = 0;
          const ee = N.getAttributes();
          for (const $ in ee)
            if (ee[$].location >= 0) {
              let xe = z[$];
              xe === void 0 &&
                ($ === "instanceMatrix" &&
                  I.instanceMatrix &&
                  (xe = I.instanceMatrix),
                $ === "instanceColor" &&
                  I.instanceColor &&
                  (xe = I.instanceColor));
              const ye = {};
              (ye.attribute = xe),
                xe && xe.data && (ye.data = xe.data),
                (J[$] = ye),
                q++;
            }
          (c.attributes = J), (c.attributesNum = q), (c.index = V);
        }
        function v() {
          const I = c.newAttributes;
          for (let U = 0, N = I.length; U < N; U++) I[U] = 0;
        }
        function M(I) {
          b(I, 0);
        }
        function b(I, U) {
          const N = c.newAttributes,
            V = c.enabledAttributes,
            J = c.attributeDivisors;
          (N[I] = 1),
            V[I] === 0 && (o.enableVertexAttribArray(I), (V[I] = 1)),
            J[I] !== U &&
              ((n.isWebGL2 ? o : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](I, U),
              (J[I] = U));
        }
        function T() {
          const I = c.newAttributes,
            U = c.enabledAttributes;
          for (let N = 0, V = U.length; N < V; N++)
            U[N] !== I[N] && (o.disableVertexAttribArray(N), (U[N] = 0));
        }
        function C(I, U, N, V, J, z) {
          n.isWebGL2 === !0 && (N === 5124 || N === 5125)
            ? o.vertexAttribIPointer(I, U, N, J, z)
            : o.vertexAttribPointer(I, U, N, V, J, z);
        }
        function _(I, U, N, V) {
          if (
            n.isWebGL2 === !1 &&
            (I.isInstancedMesh || V.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
          )
            return;
          v();
          const J = V.attributes,
            z = N.getAttributes(),
            q = U.defaultAttributeValues;
          for (const ee in z) {
            const $ = z[ee];
            if ($.location >= 0) {
              let te = J[ee];
              if (
                (te === void 0 &&
                  (ee === "instanceMatrix" &&
                    I.instanceMatrix &&
                    (te = I.instanceMatrix),
                  ee === "instanceColor" &&
                    I.instanceColor &&
                    (te = I.instanceColor)),
                te !== void 0)
              ) {
                const xe = te.normalized,
                  ye = te.itemSize,
                  k = t.get(te);
                if (k === void 0) continue;
                const qe = k.buffer,
                  Se = k.type,
                  Pe = k.bytesPerElement;
                if (te.isInterleavedBufferAttribute) {
                  const se = te.data,
                    ze = se.stride,
                    K = te.offset;
                  if (se.isInstancedInterleavedBuffer) {
                    for (let Y = 0; Y < $.locationSize; Y++)
                      b($.location + Y, se.meshPerAttribute);
                    I.isInstancedMesh !== !0 &&
                      V._maxInstanceCount === void 0 &&
                      (V._maxInstanceCount = se.meshPerAttribute * se.count);
                  } else
                    for (let Y = 0; Y < $.locationSize; Y++) M($.location + Y);
                  o.bindBuffer(34962, qe);
                  for (let Y = 0; Y < $.locationSize; Y++)
                    C(
                      $.location + Y,
                      ye / $.locationSize,
                      Se,
                      xe,
                      ze * Pe,
                      (K + (ye / $.locationSize) * Y) * Pe
                    );
                } else {
                  if (te.isInstancedBufferAttribute) {
                    for (let se = 0; se < $.locationSize; se++)
                      b($.location + se, te.meshPerAttribute);
                    I.isInstancedMesh !== !0 &&
                      V._maxInstanceCount === void 0 &&
                      (V._maxInstanceCount = te.meshPerAttribute * te.count);
                  } else
                    for (let se = 0; se < $.locationSize; se++)
                      M($.location + se);
                  o.bindBuffer(34962, qe);
                  for (let se = 0; se < $.locationSize; se++)
                    C(
                      $.location + se,
                      ye / $.locationSize,
                      Se,
                      xe,
                      ye * Pe,
                      (ye / $.locationSize) * se * Pe
                    );
                }
              } else if (q !== void 0) {
                const xe = q[ee];
                if (xe !== void 0)
                  switch (xe.length) {
                    case 2:
                      o.vertexAttrib2fv($.location, xe);
                      break;
                    case 3:
                      o.vertexAttrib3fv($.location, xe);
                      break;
                    case 4:
                      o.vertexAttrib4fv($.location, xe);
                      break;
                    default:
                      o.vertexAttrib1fv($.location, xe);
                  }
              }
            }
          }
          T();
        }
        function R() {
          Z();
          for (const I in a) {
            const U = a[I];
            for (const N in U) {
              const V = U[N];
              for (const J in V) g(V[J].object), delete V[J];
              delete U[N];
            }
            delete a[I];
          }
        }
        function P(I) {
          if (a[I.id] === void 0) return;
          const U = a[I.id];
          for (const N in U) {
            const V = U[N];
            for (const J in V) g(V[J].object), delete V[J];
            delete U[N];
          }
          delete a[I.id];
        }
        function D(I) {
          for (const U in a) {
            const N = a[U];
            if (N[I.id] === void 0) continue;
            const V = N[I.id];
            for (const J in V) g(V[J].object), delete V[J];
            delete N[I.id];
          }
        }
        function Z() {
          j(), (u = !0), c !== l && ((c = l), f(c.object));
        }
        function j() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: h,
          reset: Z,
          resetDefaultState: j,
          dispose: R,
          releaseStatesOfGeometry: P,
          releaseStatesOfProgram: D,
          initAttributes: v,
          enableAttribute: M,
          disableUnusedAttributes: T,
        };
      }
      function kg(o, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function s(c) {
          r = c;
        }
        function a(c, u) {
          o.drawArrays(r, c, u), t.update(u, r, 1);
        }
        function l(c, u, h) {
          if (h === 0) return;
          let d, f;
          if (i) (d = o), (f = "drawArraysInstanced");
          else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
          ) {
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          d[f](r, c, u, h), t.update(u, r, h);
        }
        (this.setMode = s), (this.render = a), (this.renderInstances = l);
      }
      function Vg(o, e, t) {
        let n;
        function i() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            n = o.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function r(C) {
          if (C === "highp") {
            if (
              o.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              o.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            C = "mediump";
          }
          return C === "mediump" &&
            o.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            o.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const s =
          (typeof WebGL2RenderingContext != "undefined" &&
            o instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext != "undefined" &&
            o instanceof WebGL2ComputeRenderingContext);
        let a = t.precision !== void 0 ? t.precision : "highp";
        const l = r(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
          ),
          (a = l));
        const c = s || e.has("WEBGL_draw_buffers"),
          u = t.logarithmicDepthBuffer === !0,
          h = o.getParameter(34930),
          d = o.getParameter(35660),
          f = o.getParameter(3379),
          g = o.getParameter(34076),
          m = o.getParameter(34921),
          p = o.getParameter(36347),
          x = o.getParameter(36348),
          y = o.getParameter(36349),
          v = d > 0,
          M = s || e.has("OES_texture_float"),
          b = v && M,
          T = s ? o.getParameter(36183) : 0;
        return {
          isWebGL2: s,
          drawBuffers: c,
          getMaxAnisotropy: i,
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: u,
          maxTextures: h,
          maxVertexTextures: d,
          maxTextureSize: f,
          maxCubemapSize: g,
          maxAttributes: m,
          maxVertexUniforms: p,
          maxVaryings: x,
          maxFragmentUniforms: y,
          vertexTextures: v,
          floatFragmentTextures: M,
          floatVertexTextures: b,
          maxSamples: T,
        };
      }
      function Wg(o) {
        const e = this;
        let t = null,
          n = 0,
          i = !1,
          r = !1;
        const s = new nn(),
          a = new mt(),
          l = { value: null, needsUpdate: !1 };
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (h, d, f) {
            const g = h.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = u(h, f, 0)), (n = h.length), g;
          }),
          (this.beginShadows = function () {
            (r = !0), u(null);
          }),
          (this.endShadows = function () {
            (r = !1), c();
          }),
          (this.setState = function (h, d, f) {
            const g = h.clippingPlanes,
              m = h.clipIntersection,
              p = h.clipShadows,
              x = o.get(h);
            if (!i || g === null || g.length === 0 || (r && !p))
              r ? u(null) : c();
            else {
              const y = r ? 0 : n,
                v = y * 4;
              let M = x.clippingState || null;
              (l.value = M), (M = u(g, d, v, f));
              for (let b = 0; b !== v; ++b) M[b] = t[b];
              (x.clippingState = M),
                (this.numIntersection = m ? this.numPlanes : 0),
                (this.numPlanes += y);
            }
          });
        function c() {
          l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function u(h, d, f, g) {
          const m = h !== null ? h.length : 0;
          let p = null;
          if (m !== 0) {
            if (((p = l.value), g !== !0 || p === null)) {
              const x = f + m * 4,
                y = d.matrixWorldInverse;
              a.getNormalMatrix(y),
                (p === null || p.length < x) && (p = new Float32Array(x));
              for (let v = 0, M = f; v !== m; ++v, M += 4)
                s.copy(h[v]).applyMatrix4(y, a),
                  s.normal.toArray(p, M),
                  (p[M + 3] = s.constant);
            }
            (l.value = p), (l.needsUpdate = !0);
          }
          return (e.numPlanes = m), (e.numIntersection = 0), p;
        }
      }
      function qg(o) {
        let e = new WeakMap();
        function t(s, a) {
          return a === Qr ? (s.mapping = Vn) : a === es && (s.mapping = Wn), s;
        }
        function n(s) {
          if (s && s.isTexture && s.isRenderTargetTexture === !1) {
            const a = s.mapping;
            if (a === Qr || a === es)
              if (e.has(s)) {
                const l = e.get(s).texture;
                return t(l, s.mapping);
              } else {
                const l = s.image;
                if (l && l.height > 0) {
                  const c = new Io(l.height / 2);
                  return (
                    c.fromEquirectangularTexture(o, s),
                    e.set(s, c),
                    s.addEventListener("dispose", i),
                    t(c.texture, s.mapping)
                  );
                } else return null;
              }
          }
          return s;
        }
        function i(s) {
          const a = s.target;
          a.removeEventListener("dispose", i);
          const l = e.get(a);
          l !== void 0 && (e.delete(a), l.dispose());
        }
        function r() {
          e = new WeakMap();
        }
        return { get: n, dispose: r };
      }
      class Pr extends fs {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, s) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            s = n + e,
            a = i + t,
            l = i - t;
          if (this.view !== null && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += c * this.view.offsetX),
              (s = r + c * this.view.width),
              (a -= u * this.view.offsetY),
              (l = a - u * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            a,
            l,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      Pr.prototype.isOrthographicCamera = !0;
      const sr = 4,
        Mc = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        mi = 20,
        ya = new Pr(),
        bc = new ne();
      let _a = null;
      const di = (1 + Math.sqrt(5)) / 2,
        $i = 1 / di,
        wc = [
          new S(1, 1, 1),
          new S(-1, 1, 1),
          new S(1, 1, -1),
          new S(-1, 1, -1),
          new S(0, di, $i),
          new S(0, di, -$i),
          new S($i, 0, di),
          new S(-$i, 0, di),
          new S(di, $i, 0),
          new S(-di, $i, 0),
        ];
      class hl {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          (_a = this._renderer.getRenderTarget()), this._setSize(256);
          const r = this._allocateTargets();
          return (
            (r.depthBuffer = !0),
            this._sceneToCubeUV(e, n, i, r),
            t > 0 && this._blur(r, 0, 0, t),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null &&
            ((this._cubemapMaterial = Ec()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null &&
            ((this._equirectMaterial = Tc()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(_a),
            (e.scissorTest = !1),
            qs(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === Vn || e.mapping === Wn
            ? this._setSize(
                e.image.length === 0
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            (_a = this._renderer.getRenderTarget());
          const n = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
              magFilter: tt,
              minFilter: tt,
              generateMipmaps: !1,
              type: cr,
              format: Dt,
              encoding: Mn,
              depthBuffer: !1,
            },
            i = Sc(e, t, n);
          if (
            this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== e
          ) {
            this._pingPongRenderTarget !== null && this._dispose(),
              (this._pingPongRenderTarget = Sc(e, t, n));
            const { _lodMax: r } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = Xg(r)),
              (this._blurMaterial = Jg(r, e, t));
          }
          return i;
        }
        _compileMaterial(e) {
          const t = new ut(this._lodPlanes[0], e);
          this._renderer.compile(t, ya);
        }
        _sceneToCubeUV(e, t, n, i) {
          const a = new pt(90, 1, t, n),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            h = u.autoClear,
            d = u.toneMapping;
          u.getClearColor(bc), (u.toneMapping = sn), (u.autoClear = !1);
          const f = new Ct({
              name: "PMREM.Background",
              side: Ft,
              depthWrite: !1,
              depthTest: !1,
            }),
            g = new ut(new bn(), f);
          let m = !1;
          const p = e.background;
          p
            ? p.isColor && (f.color.copy(p), (e.background = null), (m = !0))
            : (f.color.copy(bc), (m = !0));
          for (let x = 0; x < 6; x++) {
            const y = x % 3;
            y === 0
              ? (a.up.set(0, l[x], 0), a.lookAt(c[x], 0, 0))
              : y === 1
              ? (a.up.set(0, 0, l[x]), a.lookAt(0, c[x], 0))
              : (a.up.set(0, l[x], 0), a.lookAt(0, 0, c[x]));
            const v = this._cubeSize;
            qs(i, y * v, x > 2 ? v : 0, v, v),
              u.setRenderTarget(i),
              m && u.render(g, a),
              u.render(e, a);
          }
          g.geometry.dispose(),
            g.material.dispose(),
            (u.toneMapping = d),
            (u.autoClear = h),
            (e.background = p);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer,
            i = e.mapping === Vn || e.mapping === Wn;
          i
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ec()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                e.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null &&
              (this._equirectMaterial = Tc());
          const r = i ? this._cubemapMaterial : this._equirectMaterial,
            s = new ut(this._lodPlanes[0], r),
            a = r.uniforms;
          a.envMap.value = e;
          const l = this._cubeSize;
          qs(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(s, ya);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          for (let i = 1; i < this._lodPlanes.length; i++) {
            const r = Math.sqrt(
                this._sigmas[i] * this._sigmas[i] -
                  this._sigmas[i - 1] * this._sigmas[i - 1]
              ),
              s = wc[(i - 1) % wc.length];
            this._blur(e, i - 1, i, r, s);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(e, s, t, n, i, "latitudinal", r),
            this._halfBlur(s, e, n, n, i, "longitudinal", r);
        }
        _halfBlur(e, t, n, i, r, s, a) {
          const l = this._renderer,
            c = this._blurMaterial;
          s !== "latitudinal" &&
            s !== "longitudinal" &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const u = 3,
            h = new ut(this._lodPlanes[i], c),
            d = c.uniforms,
            f = this._sizeLods[n] - 1,
            g = isFinite(r) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * mi - 1),
            m = r / g,
            p = isFinite(r) ? 1 + Math.floor(u * m) : mi;
          p > mi &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${mi}`
            );
          const x = [];
          let y = 0;
          for (let C = 0; C < mi; ++C) {
            const _ = C / m,
              R = Math.exp((-_ * _) / 2);
            x.push(R), C === 0 ? (y += R) : C < p && (y += 2 * R);
          }
          for (let C = 0; C < x.length; C++) x[C] = x[C] / y;
          (d.envMap.value = e.texture),
            (d.samples.value = p),
            (d.weights.value = x),
            (d.latitudinal.value = s === "latitudinal"),
            a && (d.poleAxis.value = a);
          const { _lodMax: v } = this;
          (d.dTheta.value = g), (d.mipInt.value = v - n);
          const M = this._sizeLods[i],
            b = 3 * M * (i > v - sr ? i - v + sr : 0),
            T = 4 * (this._cubeSize - M);
          qs(t, b, T, 3 * M, 2 * M), l.setRenderTarget(t), l.render(h, ya);
        }
      }
      function Xg(o) {
        const e = [],
          t = [],
          n = [];
        let i = o;
        const r = o - sr + 1 + Mc.length;
        for (let s = 0; s < r; s++) {
          const a = Math.pow(2, i);
          t.push(a);
          let l = 1 / a;
          s > o - sr ? (l = Mc[s - o + sr - 1]) : s === 0 && (l = 0), n.push(l);
          const c = 1 / (a - 2),
            u = -c,
            h = 1 + c,
            d = [u, u, h, u, h, h, u, u, h, h, u, h],
            f = 6,
            g = 6,
            m = 3,
            p = 2,
            x = 1,
            y = new Float32Array(m * g * f),
            v = new Float32Array(p * g * f),
            M = new Float32Array(x * g * f);
          for (let T = 0; T < f; T++) {
            const C = ((T % 3) * 2) / 3 - 1,
              _ = T > 2 ? 0 : -1,
              R = [
                C,
                _,
                0,
                C + 2 / 3,
                _,
                0,
                C + 2 / 3,
                _ + 1,
                0,
                C,
                _,
                0,
                C + 2 / 3,
                _ + 1,
                0,
                C,
                _ + 1,
                0,
              ];
            y.set(R, m * g * T), v.set(d, p * g * T);
            const P = [T, T, T, T, T, T];
            M.set(P, x * g * T);
          }
          const b = new _e();
          b.setAttribute("position", new Ue(y, m)),
            b.setAttribute("uv", new Ue(v, p)),
            b.setAttribute("faceIndex", new Ue(M, x)),
            e.push(b),
            i > sr && i--;
        }
        return { lodPlanes: e, sizeLods: t, sigmas: n };
      }
      function Sc(o, e, t) {
        const n = new Tt(o, e, t);
        return (
          (n.texture.mapping = Rr),
          (n.texture.name = "PMREM.cubeUv"),
          (n.scissorTest = !0),
          n
        );
      }
      function qs(o, e, t, n, i) {
        o.viewport.set(e, t, n, i), o.scissor.set(e, t, n, i);
      }
      function Jg(o, e, t) {
        const n = new Float32Array(mi),
          i = new S(0, 1, 0);
        return new zt({
          name: "SphericalGaussianBlur",
          defines: {
            n: mi,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${o}.0`,
          },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: n },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: i },
          },
          vertexShader: Al(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: vn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Tc() {
        return new zt({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: Al(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: vn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Ec() {
        return new zt({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: Al(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: vn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Al() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function Yg(o) {
        let e = new WeakMap(),
          t = null;
        function n(a) {
          if (a && a.isTexture) {
            const l = a.mapping,
              c = l === Qr || l === es,
              u = l === Vn || l === Wn;
            if (c || u)
              if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                a.needsPMREMUpdate = !1;
                let h = e.get(a);
                return (
                  t === null && (t = new hl(o)),
                  (h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h)),
                  e.set(a, h),
                  h.texture
                );
              } else {
                if (e.has(a)) return e.get(a).texture;
                {
                  const h = a.image;
                  if ((c && h && h.height > 0) || (u && h && i(h))) {
                    t === null && (t = new hl(o));
                    const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                    return (
                      e.set(a, d), a.addEventListener("dispose", r), d.texture
                    );
                  } else return null;
                }
              }
          }
          return a;
        }
        function i(a) {
          let l = 0;
          const c = 6;
          for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
          return l === c;
        }
        function r(a) {
          const l = a.target;
          l.removeEventListener("dispose", r);
          const c = e.get(l);
          c !== void 0 && (e.delete(l), c.dispose());
        }
        function s() {
          (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
        }
        return { get: n, dispose: s };
      }
      function jg(o) {
        const e = {};
        function t(n) {
          if (e[n] !== void 0) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                o.getExtension("WEBGL_depth_texture") ||
                o.getExtension("MOZ_WEBGL_depth_texture") ||
                o.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                o.getExtension("EXT_texture_filter_anisotropic") ||
                o.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                o.getExtension("WEBGL_compressed_texture_s3tc") ||
                o.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                o.getExtension("WEBGL_compressed_texture_pvrtc") ||
                o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = o.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (n) {
            return t(n) !== null;
          },
          init: function (n) {
            n.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float"),
              t("WEBGL_multisampled_render_to_texture");
          },
          get: function (n) {
            const i = t(n);
            return (
              i === null &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              i
            );
          },
        };
      }
      function Kg(o, e, t, n) {
        const i = {},
          r = new WeakMap();
        function s(h) {
          const d = h.target;
          d.index !== null && e.remove(d.index);
          for (const g in d.attributes) e.remove(d.attributes[g]);
          d.removeEventListener("dispose", s), delete i[d.id];
          const f = r.get(d);
          f && (e.remove(f), r.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
        }
        function a(h, d) {
          return (
            i[d.id] === !0 ||
              (d.addEventListener("dispose", s),
              (i[d.id] = !0),
              t.memory.geometries++),
            d
          );
        }
        function l(h) {
          const d = h.attributes;
          for (const g in d) e.update(d[g], 34962);
          const f = h.morphAttributes;
          for (const g in f) {
            const m = f[g];
            for (let p = 0, x = m.length; p < x; p++) e.update(m[p], 34962);
          }
        }
        function c(h) {
          const d = [],
            f = h.index,
            g = h.attributes.position;
          let m = 0;
          if (f !== null) {
            const y = f.array;
            m = f.version;
            for (let v = 0, M = y.length; v < M; v += 3) {
              const b = y[v + 0],
                T = y[v + 1],
                C = y[v + 2];
              d.push(b, T, T, C, C, b);
            }
          } else {
            const y = g.array;
            m = g.version;
            for (let v = 0, M = y.length / 3 - 1; v < M; v += 3) {
              const b = v + 0,
                T = v + 1,
                C = v + 2;
              d.push(b, T, T, C, C, b);
            }
          }
          const p = new (Hh(d) ? Lo : Co)(d, 1);
          p.version = m;
          const x = r.get(h);
          x && e.remove(x), r.set(h, p);
        }
        function u(h) {
          const d = r.get(h);
          if (d) {
            const f = h.index;
            f !== null && d.version < f.version && c(h);
          } else c(h);
          return r.get(h);
        }
        return { get: a, update: l, getWireframeAttribute: u };
      }
      function Zg(o, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function s(d) {
          r = d;
        }
        let a, l;
        function c(d) {
          (a = d.type), (l = d.bytesPerElement);
        }
        function u(d, f) {
          o.drawElements(r, f, a, d * l), t.update(f, r, 1);
        }
        function h(d, f, g) {
          if (g === 0) return;
          let m, p;
          if (i) (m = o), (p = "drawElementsInstanced");
          else if (
            ((m = e.get("ANGLE_instanced_arrays")),
            (p = "drawElementsInstancedANGLE"),
            m === null)
          ) {
            console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          m[p](r, f, a, d * l, g), t.update(f, r, g);
        }
        (this.setMode = s),
          (this.setIndex = c),
          (this.render = u),
          (this.renderInstances = h);
      }
      function $g(o) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(r, s, a) {
          switch ((t.calls++, s)) {
            case 4:
              t.triangles += a * (r / 3);
              break;
            case 1:
              t.lines += a * (r / 2);
              break;
            case 3:
              t.lines += a * (r - 1);
              break;
            case 2:
              t.lines += a * r;
              break;
            case 0:
              t.points += a * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", s);
              break;
          }
        }
        function i() {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: !0,
          reset: i,
          update: n,
        };
      }
      function Qg(o, e) {
        return o[0] - e[0];
      }
      function ex(o, e) {
        return Math.abs(e[1]) - Math.abs(o[1]);
      }
      function va(o, e) {
        let t = 1;
        const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
        n instanceof Int8Array
          ? (t = 127)
          : n instanceof Int16Array
          ? (t = 32767)
          : n instanceof Int32Array
          ? (t = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              n
            ),
          o.divideScalar(t);
      }
      function tx(o, e, t) {
        const n = {},
          i = new Float32Array(8),
          r = new WeakMap(),
          s = new Je(),
          a = [];
        for (let c = 0; c < 8; c++) a[c] = [c, 0];
        function l(c, u, h, d) {
          const f = c.morphTargetInfluences;
          if (e.isWebGL2 === !0) {
            const m =
                u.morphAttributes.position ||
                u.morphAttributes.normal ||
                u.morphAttributes.color,
              p = m !== void 0 ? m.length : 0;
            let x = r.get(u);
            if (x === void 0 || x.count !== p) {
              let N = function () {
                I.dispose(), r.delete(u), u.removeEventListener("dispose", N);
              };
              var g = N;
              x !== void 0 && x.texture.dispose();
              const M = u.morphAttributes.position !== void 0,
                b = u.morphAttributes.normal !== void 0,
                T = u.morphAttributes.color !== void 0,
                C = u.morphAttributes.position || [],
                _ = u.morphAttributes.normal || [],
                R = u.morphAttributes.color || [];
              let P = 0;
              M === !0 && (P = 1), b === !0 && (P = 2), T === !0 && (P = 3);
              let D = u.attributes.position.count * P,
                Z = 1;
              D > e.maxTextureSize &&
                ((Z = Math.ceil(D / e.maxTextureSize)), (D = e.maxTextureSize));
              const j = new Float32Array(D * Z * 4 * p),
                I = new Cr(j, D, Z, p);
              (I.type = _n), (I.needsUpdate = !0);
              const U = P * 4;
              for (let V = 0; V < p; V++) {
                const J = C[V],
                  z = _[V],
                  q = R[V],
                  ee = D * Z * 4 * V;
                for (let $ = 0; $ < J.count; $++) {
                  const te = $ * U;
                  M === !0 &&
                    (s.fromBufferAttribute(J, $),
                    J.normalized === !0 && va(s, J),
                    (j[ee + te + 0] = s.x),
                    (j[ee + te + 1] = s.y),
                    (j[ee + te + 2] = s.z),
                    (j[ee + te + 3] = 0)),
                    b === !0 &&
                      (s.fromBufferAttribute(z, $),
                      z.normalized === !0 && va(s, z),
                      (j[ee + te + 4] = s.x),
                      (j[ee + te + 5] = s.y),
                      (j[ee + te + 6] = s.z),
                      (j[ee + te + 7] = 0)),
                    T === !0 &&
                      (s.fromBufferAttribute(q, $),
                      q.normalized === !0 && va(s, q),
                      (j[ee + te + 8] = s.x),
                      (j[ee + te + 9] = s.y),
                      (j[ee + te + 10] = s.z),
                      (j[ee + te + 11] = q.itemSize === 4 ? s.w : 1));
                }
              }
              (x = { count: p, texture: I, size: new W(D, Z) }),
                r.set(u, x),
                u.addEventListener("dispose", N);
            }
            let y = 0;
            for (let M = 0; M < f.length; M++) y += f[M];
            const v = u.morphTargetsRelative ? 1 : 1 - y;
            d.getUniforms().setValue(o, "morphTargetBaseInfluence", v),
              d.getUniforms().setValue(o, "morphTargetInfluences", f),
              d.getUniforms().setValue(o, "morphTargetsTexture", x.texture, t),
              d.getUniforms().setValue(o, "morphTargetsTextureSize", x.size);
          } else {
            const m = f === void 0 ? 0 : f.length;
            let p = n[u.id];
            if (p === void 0 || p.length !== m) {
              p = [];
              for (let b = 0; b < m; b++) p[b] = [b, 0];
              n[u.id] = p;
            }
            for (let b = 0; b < m; b++) {
              const T = p[b];
              (T[0] = b), (T[1] = f[b]);
            }
            p.sort(ex);
            for (let b = 0; b < 8; b++)
              b < m && p[b][1]
                ? ((a[b][0] = p[b][0]), (a[b][1] = p[b][1]))
                : ((a[b][0] = Number.MAX_SAFE_INTEGER), (a[b][1] = 0));
            a.sort(Qg);
            const x = u.morphAttributes.position,
              y = u.morphAttributes.normal;
            let v = 0;
            for (let b = 0; b < 8; b++) {
              const T = a[b],
                C = T[0],
                _ = T[1];
              C !== Number.MAX_SAFE_INTEGER && _
                ? (x &&
                    u.getAttribute("morphTarget" + b) !== x[C] &&
                    u.setAttribute("morphTarget" + b, x[C]),
                  y &&
                    u.getAttribute("morphNormal" + b) !== y[C] &&
                    u.setAttribute("morphNormal" + b, y[C]),
                  (i[b] = _),
                  (v += _))
                : (x &&
                    u.hasAttribute("morphTarget" + b) === !0 &&
                    u.deleteAttribute("morphTarget" + b),
                  y &&
                    u.hasAttribute("morphNormal" + b) === !0 &&
                    u.deleteAttribute("morphNormal" + b),
                  (i[b] = 0));
            }
            const M = u.morphTargetsRelative ? 1 : 1 - v;
            d.getUniforms().setValue(o, "morphTargetBaseInfluence", M),
              d.getUniforms().setValue(o, "morphTargetInfluences", i);
          }
        }
        return { update: l };
      }
      function nx(o, e, t, n) {
        let i = new WeakMap();
        function r(l) {
          const c = n.render.frame,
            u = l.geometry,
            h = e.get(l, u);
          return (
            i.get(h) !== c && (e.update(h), i.set(h, c)),
            l.isInstancedMesh &&
              (l.hasEventListener("dispose", a) === !1 &&
                l.addEventListener("dispose", a),
              t.update(l.instanceMatrix, 34962),
              l.instanceColor !== null && t.update(l.instanceColor, 34962)),
            h
          );
        }
        function s() {
          i = new WeakMap();
        }
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return { update: r, dispose: s };
      }
      const ed = new st(),
        td = new Cr(),
        nd = new ds(),
        id = new Lr(),
        Ac = [],
        Rc = [],
        Cc = new Float32Array(16),
        Lc = new Float32Array(9),
        Pc = new Float32Array(4);
      function Ir(o, e, t) {
        const n = o[0];
        if (n <= 0 || n > 0) return o;
        const i = e * t;
        let r = Ac[i];
        if (
          (r === void 0 && ((r = new Float32Array(i)), (Ac[i] = r)), e !== 0)
        ) {
          n.toArray(r, 0);
          for (let s = 1, a = 0; s !== e; ++s) (a += t), o[s].toArray(r, a);
        }
        return r;
      }
      function Et(o, e) {
        if (o.length !== e.length) return !1;
        for (let t = 0, n = o.length; t < n; t++) if (o[t] !== e[t]) return !1;
        return !0;
      }
      function At(o, e) {
        for (let t = 0, n = e.length; t < n; t++) o[t] = e[t];
      }
      function Do(o, e) {
        let t = Rc[e];
        t === void 0 && ((t = new Int32Array(e)), (Rc[e] = t));
        for (let n = 0; n !== e; ++n) t[n] = o.allocateTextureUnit();
        return t;
      }
      function ix(o, e) {
        const t = this.cache;
        t[0] !== e && (o.uniform1f(this.addr, e), (t[0] = e));
      }
      function rx(o, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y) &&
            (o.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (Et(t, e)) return;
          o.uniform2fv(this.addr, e), At(t, e);
        }
      }
      function sx(o, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (o.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (o.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (Et(t, e)) return;
          o.uniform3fv(this.addr, e), At(t, e);
        }
      }
      function ox(o, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (o.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (Et(t, e)) return;
          o.uniform4fv(this.addr, e), At(t, e);
        }
      }
      function ax(o, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Et(t, e)) return;
          o.uniformMatrix2fv(this.addr, !1, e), At(t, e);
        } else {
          if (Et(t, n)) return;
          Pc.set(n), o.uniformMatrix2fv(this.addr, !1, Pc), At(t, n);
        }
      }
      function lx(o, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Et(t, e)) return;
          o.uniformMatrix3fv(this.addr, !1, e), At(t, e);
        } else {
          if (Et(t, n)) return;
          Lc.set(n), o.uniformMatrix3fv(this.addr, !1, Lc), At(t, n);
        }
      }
      function cx(o, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Et(t, e)) return;
          o.uniformMatrix4fv(this.addr, !1, e), At(t, e);
        } else {
          if (Et(t, n)) return;
          Cc.set(n), o.uniformMatrix4fv(this.addr, !1, Cc), At(t, n);
        }
      }
      function ux(o, e) {
        const t = this.cache;
        t[0] !== e && (o.uniform1i(this.addr, e), (t[0] = e));
      }
      function hx(o, e) {
        const t = this.cache;
        Et(t, e) || (o.uniform2iv(this.addr, e), At(t, e));
      }
      function dx(o, e) {
        const t = this.cache;
        Et(t, e) || (o.uniform3iv(this.addr, e), At(t, e));
      }
      function fx(o, e) {
        const t = this.cache;
        Et(t, e) || (o.uniform4iv(this.addr, e), At(t, e));
      }
      function px(o, e) {
        const t = this.cache;
        t[0] !== e && (o.uniform1ui(this.addr, e), (t[0] = e));
      }
      function mx(o, e) {
        const t = this.cache;
        Et(t, e) || (o.uniform2uiv(this.addr, e), At(t, e));
      }
      function gx(o, e) {
        const t = this.cache;
        Et(t, e) || (o.uniform3uiv(this.addr, e), At(t, e));
      }
      function xx(o, e) {
        const t = this.cache;
        Et(t, e) || (o.uniform4uiv(this.addr, e), At(t, e));
      }
      function yx(o, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (o.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2D(e || ed, i);
      }
      function _x(o, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (o.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture3D(e || nd, i);
      }
      function vx(o, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (o.uniform1i(this.addr, i), (n[0] = i)),
          t.setTextureCube(e || id, i);
      }
      function Mx(o, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (o.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2DArray(e || td, i);
      }
      function bx(o) {
        switch (o) {
          case 5126:
            return ix;
          case 35664:
            return rx;
          case 35665:
            return sx;
          case 35666:
            return ox;
          case 35674:
            return ax;
          case 35675:
            return lx;
          case 35676:
            return cx;
          case 5124:
          case 35670:
            return ux;
          case 35667:
          case 35671:
            return hx;
          case 35668:
          case 35672:
            return dx;
          case 35669:
          case 35673:
            return fx;
          case 5125:
            return px;
          case 36294:
            return mx;
          case 36295:
            return gx;
          case 36296:
            return xx;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return yx;
          case 35679:
          case 36299:
          case 36307:
            return _x;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return vx;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return Mx;
        }
      }
      function wx(o, e) {
        o.uniform1fv(this.addr, e);
      }
      function Sx(o, e) {
        const t = Ir(e, this.size, 2);
        o.uniform2fv(this.addr, t);
      }
      function Tx(o, e) {
        const t = Ir(e, this.size, 3);
        o.uniform3fv(this.addr, t);
      }
      function Ex(o, e) {
        const t = Ir(e, this.size, 4);
        o.uniform4fv(this.addr, t);
      }
      function Ax(o, e) {
        const t = Ir(e, this.size, 4);
        o.uniformMatrix2fv(this.addr, !1, t);
      }
      function Rx(o, e) {
        const t = Ir(e, this.size, 9);
        o.uniformMatrix3fv(this.addr, !1, t);
      }
      function Cx(o, e) {
        const t = Ir(e, this.size, 16);
        o.uniformMatrix4fv(this.addr, !1, t);
      }
      function Lx(o, e) {
        o.uniform1iv(this.addr, e);
      }
      function Px(o, e) {
        o.uniform2iv(this.addr, e);
      }
      function Ix(o, e) {
        o.uniform3iv(this.addr, e);
      }
      function Dx(o, e) {
        o.uniform4iv(this.addr, e);
      }
      function Fx(o, e) {
        o.uniform1uiv(this.addr, e);
      }
      function Bx(o, e) {
        o.uniform2uiv(this.addr, e);
      }
      function Nx(o, e) {
        o.uniform3uiv(this.addr, e);
      }
      function Ox(o, e) {
        o.uniform4uiv(this.addr, e);
      }
      function Ux(o, e, t) {
        const n = e.length,
          i = Do(t, n);
        o.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTexture2D(e[r] || ed, i[r]);
      }
      function zx(o, e, t) {
        const n = e.length,
          i = Do(t, n);
        o.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTexture3D(e[r] || nd, i[r]);
      }
      function Hx(o, e, t) {
        const n = e.length,
          i = Do(t, n);
        o.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTextureCube(e[r] || id, i[r]);
      }
      function Gx(o, e, t) {
        const n = e.length,
          i = Do(t, n);
        o.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTexture2DArray(e[r] || td, i[r]);
      }
      function kx(o) {
        switch (o) {
          case 5126:
            return wx;
          case 35664:
            return Sx;
          case 35665:
            return Tx;
          case 35666:
            return Ex;
          case 35674:
            return Ax;
          case 35675:
            return Rx;
          case 35676:
            return Cx;
          case 5124:
          case 35670:
            return Lx;
          case 35667:
          case 35671:
            return Px;
          case 35668:
          case 35672:
            return Ix;
          case 35669:
          case 35673:
            return Dx;
          case 5125:
            return Fx;
          case 36294:
            return Bx;
          case 36295:
            return Nx;
          case 36296:
            return Ox;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Ux;
          case 35679:
          case 36299:
          case 36307:
            return zx;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Hx;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return Gx;
        }
      }
      function Vx(o, e, t) {
        (this.id = o),
          (this.addr = t),
          (this.cache = []),
          (this.setValue = bx(e.type));
      }
      function Wx(o, e, t) {
        (this.id = o),
          (this.addr = t),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = kx(e.type));
      }
      function rd(o) {
        (this.id = o), (this.seq = []), (this.map = {});
      }
      rd.prototype.setValue = function (o, e, t) {
        const n = this.seq;
        for (let i = 0, r = n.length; i !== r; ++i) {
          const s = n[i];
          s.setValue(o, e[s.id], t);
        }
      };
      const Ma = /(\w+)(\])?(\[|\.)?/g;
      function Ic(o, e) {
        o.seq.push(e), (o.map[e.id] = e);
      }
      function qx(o, e, t) {
        const n = o.name,
          i = n.length;
        for (Ma.lastIndex = 0; ; ) {
          const r = Ma.exec(n),
            s = Ma.lastIndex;
          let a = r[1];
          const l = r[2] === "]",
            c = r[3];
          if ((l && (a = a | 0), c === void 0 || (c === "[" && s + 2 === i))) {
            Ic(t, c === void 0 ? new Vx(a, o, e) : new Wx(a, o, e));
            break;
          } else {
            let h = t.map[a];
            h === void 0 && ((h = new rd(a)), Ic(t, h)), (t = h);
          }
        }
      }
      function Hn(o, e) {
        (this.seq = []), (this.map = {});
        const t = o.getProgramParameter(e, 35718);
        for (let n = 0; n < t; ++n) {
          const i = o.getActiveUniform(e, n),
            r = o.getUniformLocation(e, i.name);
          qx(i, r, this);
        }
      }
      Hn.prototype.setValue = function (o, e, t, n) {
        const i = this.map[e];
        i !== void 0 && i.setValue(o, t, n);
      };
      Hn.prototype.setOptional = function (o, e, t) {
        const n = e[t];
        n !== void 0 && this.setValue(o, t, n);
      };
      Hn.upload = function (o, e, t, n) {
        for (let i = 0, r = e.length; i !== r; ++i) {
          const s = e[i],
            a = t[s.id];
          a.needsUpdate !== !1 && s.setValue(o, a.value, n);
        }
      };
      Hn.seqWithValue = function (o, e) {
        const t = [];
        for (let n = 0, i = o.length; n !== i; ++n) {
          const r = o[n];
          r.id in e && t.push(r);
        }
        return t;
      };
      function Dc(o, e, t) {
        const n = o.createShader(e);
        return o.shaderSource(n, t), o.compileShader(n), n;
      }
      let Xx = 0;
      function Jx(o, e) {
        const t = o.split(`
`),
          n = [],
          i = Math.max(e - 6, 0),
          r = Math.min(e + 6, t.length);
        for (let s = i; s < r; s++) n.push(s + 1 + ": " + t[s]);
        return n.join(`
`);
      }
      function Yx(o) {
        switch (o) {
          case Mn:
            return ["Linear", "( value )"];
          case We:
            return ["sRGB", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", o),
              ["Linear", "( value )"]
            );
        }
      }
      function Fc(o, e, t) {
        const n = o.getShaderParameter(e, 35713),
          i = o.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(i);
        if (r) {
          const s = parseInt(r[0]);
          return (
            t.toUpperCase() +
            `

` +
            i +
            `

` +
            Jx(o.getShaderSource(e), s)
          );
        } else return i;
      }
      function jx(o, e) {
        const t = Yx(e);
        return (
          "vec4 " + o + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function Kx(o, e) {
        let t;
        switch (e) {
          case uh:
            t = "Linear";
            break;
          case hh:
            t = "Reinhard";
            break;
          case dh:
            t = "OptimizedCineon";
            break;
          case fh:
            t = "ACESFilmic";
            break;
          case ph:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          o +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function Zx(o) {
        return [
          o.extensionDerivatives ||
          !!o.envMapCubeUVHeight ||
          o.bumpMap ||
          o.tangentSpaceNormalMap ||
          o.clearcoatNormalMap ||
          o.flatShading ||
          o.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (o.extensionFragDepth || o.logarithmicDepthBuffer) &&
          o.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          o.extensionDrawBuffers && o.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (o.extensionShaderTextureLOD || o.envMap || o.transmission) &&
          o.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ].filter(Yr).join(`
`);
      }
      function $x(o) {
        const e = [];
        for (const t in o) {
          const n = o[t];
          n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
      }
      function Qx(o, e) {
        const t = {},
          n = o.getProgramParameter(e, 35721);
        for (let i = 0; i < n; i++) {
          const r = o.getActiveAttrib(e, i),
            s = r.name;
          let a = 1;
          r.type === 35674 && (a = 2),
            r.type === 35675 && (a = 3),
            r.type === 35676 && (a = 4),
            (t[s] = {
              type: r.type,
              location: o.getAttribLocation(e, s),
              locationSize: a,
            });
        }
        return t;
      }
      function Yr(o) {
        return o !== "";
      }
      function Bc(o, e) {
        return o
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Nc(o, e) {
        return o
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const ey = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function dl(o) {
        return o.replace(ey, ty);
      }
      function ty(o, e) {
        const t = Be[e];
        if (t === void 0)
          throw new Error("Can not resolve #include <" + e + ">");
        return dl(t);
      }
      const ny =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        iy =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Oc(o) {
        return o.replace(iy, sd).replace(ny, ry);
      }
      function ry(o, e, t, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          sd(o, e, t, n)
        );
      }
      function sd(o, e, t, n) {
        let i = "";
        for (let r = parseInt(e); r < parseInt(t); r++)
          i += n
            .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, r);
        return i;
      }
      function Uc(o) {
        let e =
          "precision " +
          o.precision +
          ` float;
precision ` +
          o.precision +
          " int;";
        return (
          o.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : o.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : o.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function sy(o) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          o.shadowMapType === vl
            ? (e = "SHADOWMAP_TYPE_PCF")
            : o.shadowMapType === ku
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : o.shadowMapType === ir && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function oy(o) {
        let e = "ENVMAP_TYPE_CUBE";
        if (o.envMap)
          switch (o.envMapMode) {
            case Vn:
            case Wn:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case Rr:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function ay(o) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (o.envMap)
          switch (o.envMapMode) {
            case Wn:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function ly(o) {
        let e = "ENVMAP_BLENDING_NONE";
        if (o.envMap)
          switch (o.combine) {
            case hs:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case lh:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case ch:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function cy(o) {
        const e = o.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2,
          n = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
          texelHeight: n,
          maxMip: t,
        };
      }
      function uy(o, e, t, n) {
        const i = o.getContext(),
          r = t.defines;
        let s = t.vertexShader,
          a = t.fragmentShader;
        const l = sy(t),
          c = oy(t),
          u = ay(t),
          h = ly(t),
          d = cy(t),
          f = t.isWebGL2 ? "" : Zx(t),
          g = $x(r),
          m = i.createProgram();
        let p,
          x,
          y = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((p = [g].filter(Yr).join(`
`)),
            p.length > 0 &&
              (p += `
`),
            (x = [f, g].filter(Yr).join(`
`)),
            x.length > 0 &&
              (x += `
`))
          : ((p = [
              Uc(t),
              "#define SHADER_NAME " + t.shaderName,
              g,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(Yr).join(`
`)),
            (x = [
              f,
              Uc(t),
              "#define SHADER_NAME " + t.shaderName,
              g,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + u : "",
              t.envMap ? "#define " + h : "",
              d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
              d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
              d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== sn ? "#define TONE_MAPPING" : "",
              t.toneMapping !== sn ? Be.tonemapping_pars_fragment : "",
              t.toneMapping !== sn ? Kx("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.opaque ? "#define OPAQUE" : "",
              Be.encodings_pars_fragment,
              jx("linearToOutputTexel", t.outputEncoding),
              t.useDepthPacking
                ? "#define DEPTH_PACKING " + t.depthPacking
                : "",
              `
`,
            ].filter(Yr).join(`
`))),
          (s = dl(s)),
          (s = Bc(s, t)),
          (s = Nc(s, t)),
          (a = dl(a)),
          (a = Bc(a, t)),
          (a = Nc(a, t)),
          (s = Oc(s)),
          (a = Oc(a)),
          t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((y = `#version 300 es
`),
            (p =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              p),
            (x =
              [
                "#define varying in",
                t.glslVersion === ll
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                t.glslVersion === ll ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              x));
        const v = y + p + s,
          M = y + x + a,
          b = Dc(i, 35633, v),
          T = Dc(i, 35632, M);
        if (
          (i.attachShader(m, b),
          i.attachShader(m, T),
          t.index0AttributeName !== void 0
            ? i.bindAttribLocation(m, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"),
          i.linkProgram(m),
          o.debug.checkShaderErrors)
        ) {
          const R = i.getProgramInfoLog(m).trim(),
            P = i.getShaderInfoLog(b).trim(),
            D = i.getShaderInfoLog(T).trim();
          let Z = !0,
            j = !0;
          if (i.getProgramParameter(m, 35714) === !1) {
            Z = !1;
            const I = Fc(i, b, "vertex"),
              U = Fc(i, T, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                i.getError() +
                " - VALIDATE_STATUS " +
                i.getProgramParameter(m, 35715) +
                `

Program Info Log: ` +
                R +
                `
` +
                I +
                `
` +
                U
            );
          } else
            R !== ""
              ? console.warn("THREE.WebGLProgram: Program Info Log:", R)
              : (P === "" || D === "") && (j = !1);
          j &&
            (this.diagnostics = {
              runnable: Z,
              programLog: R,
              vertexShader: { log: P, prefix: p },
              fragmentShader: { log: D, prefix: x },
            });
        }
        i.deleteShader(b), i.deleteShader(T);
        let C;
        this.getUniforms = function () {
          return C === void 0 && (C = new Hn(i, m)), C;
        };
        let _;
        return (
          (this.getAttributes = function () {
            return _ === void 0 && (_ = Qx(i, m)), _;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              i.deleteProgram(m),
              (this.program = void 0);
          }),
          (this.name = t.shaderName),
          (this.id = Xx++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = m),
          (this.vertexShader = b),
          (this.fragmentShader = T),
          this
        );
      }
      let hy = 0;
      class dy {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            r = this._getShaderStage(n),
            s = this._getShaderCacheForMaterial(e);
          return (
            s.has(i) === !1 && (s.add(i), i.usedTimes++),
            s.has(r) === !1 && (s.add(r), r.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const n of t)
            n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          if (t.has(e) === !1) {
            const n = new fy(e);
            t.set(e, n);
          }
          return t.get(e);
        }
      }
      class fy {
        constructor(e) {
          (this.id = hy++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function py(o, e, t, n, i, r, s) {
        const a = new Ro(),
          l = new dy(),
          c = [],
          u = i.isWebGL2,
          h = i.logarithmicDepthBuffer,
          d = i.vertexTextures;
        let f = i.precision;
        const g = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function m(_, R, P, D, Z) {
          const j = D.fog,
            I = Z.geometry,
            U = _.isMeshStandardMaterial ? D.environment : null,
            N = (_.isMeshStandardMaterial ? t : e).get(_.envMap || U),
            V = !!N && N.mapping === Rr ? N.image.height : null,
            J = g[_.type];
          _.precision !== null &&
            ((f = i.getMaxPrecision(_.precision)),
            f !== _.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                _.precision,
                "not supported, using",
                f,
                "instead."
              ));
          const z =
              I.morphAttributes.position ||
              I.morphAttributes.normal ||
              I.morphAttributes.color,
            q = z !== void 0 ? z.length : 0;
          let ee = 0;
          I.morphAttributes.position !== void 0 && (ee = 1),
            I.morphAttributes.normal !== void 0 && (ee = 2),
            I.morphAttributes.color !== void 0 && (ee = 3);
          let $, te, xe, ye;
          if (J) {
            const se = Xt[J];
            ($ = se.vertexShader), (te = se.fragmentShader);
          } else
            ($ = _.vertexShader),
              (te = _.fragmentShader),
              l.update(_),
              (xe = l.getVertexShaderID(_)),
              (ye = l.getFragmentShaderID(_));
          const k = o.getRenderTarget(),
            qe = _.alphaTest > 0,
            Se = _.clearcoat > 0;
          return {
            isWebGL2: u,
            shaderID: J,
            shaderName: _.type,
            vertexShader: $,
            fragmentShader: te,
            defines: _.defines,
            customVertexShaderID: xe,
            customFragmentShaderID: ye,
            isRawShaderMaterial: _.isRawShaderMaterial === !0,
            glslVersion: _.glslVersion,
            precision: f,
            instancing: Z.isInstancedMesh === !0,
            instancingColor:
              Z.isInstancedMesh === !0 && Z.instanceColor !== null,
            supportsVertexTextures: d,
            outputEncoding:
              k === null
                ? o.outputEncoding
                : k.isXRRenderTarget === !0
                ? k.texture.encoding
                : Mn,
            map: !!_.map,
            matcap: !!_.matcap,
            envMap: !!N,
            envMapMode: N && N.mapping,
            envMapCubeUVHeight: V,
            lightMap: !!_.lightMap,
            aoMap: !!_.aoMap,
            emissiveMap: !!_.emissiveMap,
            bumpMap: !!_.bumpMap,
            normalMap: !!_.normalMap,
            objectSpaceNormalMap: _.normalMapType === Oh,
            tangentSpaceNormalMap: _.normalMapType === Kn,
            decodeVideoTexture:
              !!_.map && _.map.isVideoTexture === !0 && _.map.encoding === We,
            clearcoat: Se,
            clearcoatMap: Se && !!_.clearcoatMap,
            clearcoatRoughnessMap: Se && !!_.clearcoatRoughnessMap,
            clearcoatNormalMap: Se && !!_.clearcoatNormalMap,
            displacementMap: !!_.displacementMap,
            roughnessMap: !!_.roughnessMap,
            metalnessMap: !!_.metalnessMap,
            specularMap: !!_.specularMap,
            specularIntensityMap: !!_.specularIntensityMap,
            specularColorMap: !!_.specularColorMap,
            opaque: _.transparent === !1 && _.blending === yi,
            alphaMap: !!_.alphaMap,
            alphaTest: qe,
            gradientMap: !!_.gradientMap,
            sheen: _.sheen > 0,
            sheenColorMap: !!_.sheenColorMap,
            sheenRoughnessMap: !!_.sheenRoughnessMap,
            transmission: _.transmission > 0,
            transmissionMap: !!_.transmissionMap,
            thicknessMap: !!_.thicknessMap,
            combine: _.combine,
            vertexTangents: !!_.normalMap && !!I.attributes.tangent,
            vertexColors: _.vertexColors,
            vertexAlphas:
              _.vertexColors === !0 &&
              !!I.attributes.color &&
              I.attributes.color.itemSize === 4,
            vertexUvs:
              !!_.map ||
              !!_.bumpMap ||
              !!_.normalMap ||
              !!_.specularMap ||
              !!_.alphaMap ||
              !!_.emissiveMap ||
              !!_.roughnessMap ||
              !!_.metalnessMap ||
              !!_.clearcoatMap ||
              !!_.clearcoatRoughnessMap ||
              !!_.clearcoatNormalMap ||
              !!_.displacementMap ||
              !!_.transmissionMap ||
              !!_.thicknessMap ||
              !!_.specularIntensityMap ||
              !!_.specularColorMap ||
              !!_.sheenColorMap ||
              !!_.sheenRoughnessMap,
            uvsVertexOnly:
              !(
                !!_.map ||
                !!_.bumpMap ||
                !!_.normalMap ||
                !!_.specularMap ||
                !!_.alphaMap ||
                !!_.emissiveMap ||
                !!_.roughnessMap ||
                !!_.metalnessMap ||
                !!_.clearcoatNormalMap ||
                _.transmission > 0 ||
                !!_.transmissionMap ||
                !!_.thicknessMap ||
                !!_.specularIntensityMap ||
                !!_.specularColorMap ||
                _.sheen > 0 ||
                !!_.sheenColorMap ||
                !!_.sheenRoughnessMap
              ) && !!_.displacementMap,
            fog: !!j,
            useFog: _.fog === !0,
            fogExp2: j && j.isFogExp2,
            flatShading: !!_.flatShading,
            sizeAttenuation: _.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: Z.isSkinnedMesh === !0,
            morphTargets: I.morphAttributes.position !== void 0,
            morphNormals: I.morphAttributes.normal !== void 0,
            morphColors: I.morphAttributes.color !== void 0,
            morphTargetsCount: q,
            morphTextureStride: ee,
            numDirLights: R.directional.length,
            numPointLights: R.point.length,
            numSpotLights: R.spot.length,
            numRectAreaLights: R.rectArea.length,
            numHemiLights: R.hemi.length,
            numDirLightShadows: R.directionalShadowMap.length,
            numPointLightShadows: R.pointShadowMap.length,
            numSpotLightShadows: R.spotShadowMap.length,
            numClippingPlanes: s.numPlanes,
            numClipIntersection: s.numIntersection,
            dithering: _.dithering,
            shadowMapEnabled: o.shadowMap.enabled && P.length > 0,
            shadowMapType: o.shadowMap.type,
            toneMapping: _.toneMapped ? o.toneMapping : sn,
            physicallyCorrectLights: o.physicallyCorrectLights,
            premultipliedAlpha: _.premultipliedAlpha,
            doubleSided: _.side === kn,
            flipSided: _.side === Ft,
            useDepthPacking: !!_.depthPacking,
            depthPacking: _.depthPacking || 0,
            index0AttributeName: _.index0AttributeName,
            extensionDerivatives: _.extensions && _.extensions.derivatives,
            extensionFragDepth: _.extensions && _.extensions.fragDepth,
            extensionDrawBuffers: _.extensions && _.extensions.drawBuffers,
            extensionShaderTextureLOD:
              _.extensions && _.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              u || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: _.customProgramCacheKey(),
          };
        }
        function p(_) {
          const R = [];
          if (
            (_.shaderID
              ? R.push(_.shaderID)
              : (R.push(_.customVertexShaderID),
                R.push(_.customFragmentShaderID)),
            _.defines !== void 0)
          )
            for (const P in _.defines) R.push(P), R.push(_.defines[P]);
          return (
            _.isRawShaderMaterial === !1 &&
              (x(R, _), y(R, _), R.push(o.outputEncoding)),
            R.push(_.customProgramCacheKey),
            R.join()
          );
        }
        function x(_, R) {
          _.push(R.precision),
            _.push(R.outputEncoding),
            _.push(R.envMapMode),
            _.push(R.envMapCubeUVHeight),
            _.push(R.combine),
            _.push(R.vertexUvs),
            _.push(R.fogExp2),
            _.push(R.sizeAttenuation),
            _.push(R.morphTargetsCount),
            _.push(R.morphAttributeCount),
            _.push(R.numDirLights),
            _.push(R.numPointLights),
            _.push(R.numSpotLights),
            _.push(R.numHemiLights),
            _.push(R.numRectAreaLights),
            _.push(R.numDirLightShadows),
            _.push(R.numPointLightShadows),
            _.push(R.numSpotLightShadows),
            _.push(R.shadowMapType),
            _.push(R.toneMapping),
            _.push(R.numClippingPlanes),
            _.push(R.numClipIntersection),
            _.push(R.depthPacking);
        }
        function y(_, R) {
          a.disableAll(),
            R.isWebGL2 && a.enable(0),
            R.supportsVertexTextures && a.enable(1),
            R.instancing && a.enable(2),
            R.instancingColor && a.enable(3),
            R.map && a.enable(4),
            R.matcap && a.enable(5),
            R.envMap && a.enable(6),
            R.lightMap && a.enable(7),
            R.aoMap && a.enable(8),
            R.emissiveMap && a.enable(9),
            R.bumpMap && a.enable(10),
            R.normalMap && a.enable(11),
            R.objectSpaceNormalMap && a.enable(12),
            R.tangentSpaceNormalMap && a.enable(13),
            R.clearcoat && a.enable(14),
            R.clearcoatMap && a.enable(15),
            R.clearcoatRoughnessMap && a.enable(16),
            R.clearcoatNormalMap && a.enable(17),
            R.displacementMap && a.enable(18),
            R.specularMap && a.enable(19),
            R.roughnessMap && a.enable(20),
            R.metalnessMap && a.enable(21),
            R.gradientMap && a.enable(22),
            R.alphaMap && a.enable(23),
            R.alphaTest && a.enable(24),
            R.vertexColors && a.enable(25),
            R.vertexAlphas && a.enable(26),
            R.vertexUvs && a.enable(27),
            R.vertexTangents && a.enable(28),
            R.uvsVertexOnly && a.enable(29),
            R.fog && a.enable(30),
            _.push(a.mask),
            a.disableAll(),
            R.useFog && a.enable(0),
            R.flatShading && a.enable(1),
            R.logarithmicDepthBuffer && a.enable(2),
            R.skinning && a.enable(3),
            R.morphTargets && a.enable(4),
            R.morphNormals && a.enable(5),
            R.morphColors && a.enable(6),
            R.premultipliedAlpha && a.enable(7),
            R.shadowMapEnabled && a.enable(8),
            R.physicallyCorrectLights && a.enable(9),
            R.doubleSided && a.enable(10),
            R.flipSided && a.enable(11),
            R.useDepthPacking && a.enable(12),
            R.dithering && a.enable(13),
            R.specularIntensityMap && a.enable(14),
            R.specularColorMap && a.enable(15),
            R.transmission && a.enable(16),
            R.transmissionMap && a.enable(17),
            R.thicknessMap && a.enable(18),
            R.sheen && a.enable(19),
            R.sheenColorMap && a.enable(20),
            R.sheenRoughnessMap && a.enable(21),
            R.decodeVideoTexture && a.enable(22),
            R.opaque && a.enable(23),
            _.push(a.mask);
        }
        function v(_) {
          const R = g[_.type];
          let P;
          if (R) {
            const D = Xt[R];
            P = $h.clone(D.uniforms);
          } else P = _.uniforms;
          return P;
        }
        function M(_, R) {
          let P;
          for (let D = 0, Z = c.length; D < Z; D++) {
            const j = c[D];
            if (j.cacheKey === R) {
              (P = j), ++P.usedTimes;
              break;
            }
          }
          return P === void 0 && ((P = new uy(o, R, _, r)), c.push(P)), P;
        }
        function b(_) {
          if (--_.usedTimes === 0) {
            const R = c.indexOf(_);
            (c[R] = c[c.length - 1]), c.pop(), _.destroy();
          }
        }
        function T(_) {
          l.remove(_);
        }
        function C() {
          l.dispose();
        }
        return {
          getParameters: m,
          getProgramCacheKey: p,
          getUniforms: v,
          acquireProgram: M,
          releaseProgram: b,
          releaseShaderCache: T,
          programs: c,
          dispose: C,
        };
      }
      function my() {
        let o = new WeakMap();
        function e(r) {
          let s = o.get(r);
          return s === void 0 && ((s = {}), o.set(r, s)), s;
        }
        function t(r) {
          o.delete(r);
        }
        function n(r, s, a) {
          o.get(r)[s] = a;
        }
        function i() {
          o = new WeakMap();
        }
        return { get: e, remove: t, update: n, dispose: i };
      }
      function gy(o, e) {
        return o.groupOrder !== e.groupOrder
          ? o.groupOrder - e.groupOrder
          : o.renderOrder !== e.renderOrder
          ? o.renderOrder - e.renderOrder
          : o.material.id !== e.material.id
          ? o.material.id - e.material.id
          : o.z !== e.z
          ? o.z - e.z
          : o.id - e.id;
      }
      function zc(o, e) {
        return o.groupOrder !== e.groupOrder
          ? o.groupOrder - e.groupOrder
          : o.renderOrder !== e.renderOrder
          ? o.renderOrder - e.renderOrder
          : o.z !== e.z
          ? e.z - o.z
          : o.id - e.id;
      }
      function Hc() {
        const o = [];
        let e = 0;
        const t = [],
          n = [],
          i = [];
        function r() {
          (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
        }
        function s(h, d, f, g, m, p) {
          let x = o[e];
          return (
            x === void 0
              ? ((x = {
                  id: h.id,
                  object: h,
                  geometry: d,
                  material: f,
                  groupOrder: g,
                  renderOrder: h.renderOrder,
                  z: m,
                  group: p,
                }),
                (o[e] = x))
              : ((x.id = h.id),
                (x.object = h),
                (x.geometry = d),
                (x.material = f),
                (x.groupOrder = g),
                (x.renderOrder = h.renderOrder),
                (x.z = m),
                (x.group = p)),
            e++,
            x
          );
        }
        function a(h, d, f, g, m, p) {
          const x = s(h, d, f, g, m, p);
          f.transmission > 0
            ? n.push(x)
            : f.transparent === !0
            ? i.push(x)
            : t.push(x);
        }
        function l(h, d, f, g, m, p) {
          const x = s(h, d, f, g, m, p);
          f.transmission > 0
            ? n.unshift(x)
            : f.transparent === !0
            ? i.unshift(x)
            : t.unshift(x);
        }
        function c(h, d) {
          t.length > 1 && t.sort(h || gy),
            n.length > 1 && n.sort(d || zc),
            i.length > 1 && i.sort(d || zc);
        }
        function u() {
          for (let h = e, d = o.length; h < d; h++) {
            const f = o[h];
            if (f.id === null) break;
            (f.id = null),
              (f.object = null),
              (f.geometry = null),
              (f.material = null),
              (f.group = null);
          }
        }
        return {
          opaque: t,
          transmissive: n,
          transparent: i,
          init: r,
          push: a,
          unshift: l,
          finish: u,
          sort: c,
        };
      }
      function xy() {
        let o = new WeakMap();
        function e(n, i) {
          let r;
          return (
            o.has(n) === !1
              ? ((r = new Hc()), o.set(n, [r]))
              : i >= o.get(n).length
              ? ((r = new Hc()), o.get(n).push(r))
              : (r = o.get(n)[i]),
            r
          );
        }
        function t() {
          o = new WeakMap();
        }
        return { get: e, dispose: t };
      }
      function yy() {
        const o = {};
        return {
          get: function (e) {
            if (o[e.id] !== void 0) return o[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new S(), color: new ne() };
                break;
              case "SpotLight":
                t = {
                  position: new S(),
                  direction: new S(),
                  color: new ne(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new S(),
                  color: new ne(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new S(),
                  skyColor: new ne(),
                  groundColor: new ne(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new ne(),
                  position: new S(),
                  halfWidth: new S(),
                  halfHeight: new S(),
                };
                break;
            }
            return (o[e.id] = t), t;
          },
        };
      }
      function _y() {
        const o = {};
        return {
          get: function (e) {
            if (o[e.id] !== void 0) return o[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new W(),
                };
                break;
              case "SpotLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new W(),
                };
                break;
              case "PointLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new W(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (o[e.id] = t), t;
          },
        };
      }
      let vy = 0;
      function My(o, e) {
        return (e.castShadow ? 1 : 0) - (o.castShadow ? 1 : 0);
      }
      function by(o, e) {
        const t = new yy(),
          n = _y(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let u = 0; u < 9; u++) i.probe.push(new S());
        const r = new S(),
          s = new fe(),
          a = new fe();
        function l(u, h) {
          let d = 0,
            f = 0,
            g = 0;
          for (let R = 0; R < 9; R++) i.probe[R].set(0, 0, 0);
          let m = 0,
            p = 0,
            x = 0,
            y = 0,
            v = 0,
            M = 0,
            b = 0,
            T = 0;
          u.sort(My);
          const C = h !== !0 ? Math.PI : 1;
          for (let R = 0, P = u.length; R < P; R++) {
            const D = u[R],
              Z = D.color,
              j = D.intensity,
              I = D.distance,
              U = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight)
              (d += Z.r * j * C), (f += Z.g * j * C), (g += Z.b * j * C);
            else if (D.isLightProbe)
              for (let N = 0; N < 9; N++)
                i.probe[N].addScaledVector(D.sh.coefficients[N], j);
            else if (D.isDirectionalLight) {
              const N = t.get(D);
              if (
                (N.color.copy(D.color).multiplyScalar(D.intensity * C),
                D.castShadow)
              ) {
                const V = D.shadow,
                  J = n.get(D);
                (J.shadowBias = V.bias),
                  (J.shadowNormalBias = V.normalBias),
                  (J.shadowRadius = V.radius),
                  (J.shadowMapSize = V.mapSize),
                  (i.directionalShadow[m] = J),
                  (i.directionalShadowMap[m] = U),
                  (i.directionalShadowMatrix[m] = D.shadow.matrix),
                  M++;
              }
              (i.directional[m] = N), m++;
            } else if (D.isSpotLight) {
              const N = t.get(D);
              if (
                (N.position.setFromMatrixPosition(D.matrixWorld),
                N.color.copy(Z).multiplyScalar(j * C),
                (N.distance = I),
                (N.coneCos = Math.cos(D.angle)),
                (N.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
                (N.decay = D.decay),
                D.castShadow)
              ) {
                const V = D.shadow,
                  J = n.get(D);
                (J.shadowBias = V.bias),
                  (J.shadowNormalBias = V.normalBias),
                  (J.shadowRadius = V.radius),
                  (J.shadowMapSize = V.mapSize),
                  (i.spotShadow[x] = J),
                  (i.spotShadowMap[x] = U),
                  (i.spotShadowMatrix[x] = D.shadow.matrix),
                  T++;
              }
              (i.spot[x] = N), x++;
            } else if (D.isRectAreaLight) {
              const N = t.get(D);
              N.color.copy(Z).multiplyScalar(j),
                N.halfWidth.set(D.width * 0.5, 0, 0),
                N.halfHeight.set(0, D.height * 0.5, 0),
                (i.rectArea[y] = N),
                y++;
            } else if (D.isPointLight) {
              const N = t.get(D);
              if (
                (N.color.copy(D.color).multiplyScalar(D.intensity * C),
                (N.distance = D.distance),
                (N.decay = D.decay),
                D.castShadow)
              ) {
                const V = D.shadow,
                  J = n.get(D);
                (J.shadowBias = V.bias),
                  (J.shadowNormalBias = V.normalBias),
                  (J.shadowRadius = V.radius),
                  (J.shadowMapSize = V.mapSize),
                  (J.shadowCameraNear = V.camera.near),
                  (J.shadowCameraFar = V.camera.far),
                  (i.pointShadow[p] = J),
                  (i.pointShadowMap[p] = U),
                  (i.pointShadowMatrix[p] = D.shadow.matrix),
                  b++;
              }
              (i.point[p] = N), p++;
            } else if (D.isHemisphereLight) {
              const N = t.get(D);
              N.skyColor.copy(D.color).multiplyScalar(j * C),
                N.groundColor.copy(D.groundColor).multiplyScalar(j * C),
                (i.hemi[v] = N),
                v++;
            }
          }
          y > 0 &&
            (e.isWebGL2 || o.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = ae.LTC_FLOAT_1),
                (i.rectAreaLTC2 = ae.LTC_FLOAT_2))
              : o.has("OES_texture_half_float_linear") === !0
              ? ((i.rectAreaLTC1 = ae.LTC_HALF_1),
                (i.rectAreaLTC2 = ae.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = d),
            (i.ambient[1] = f),
            (i.ambient[2] = g);
          const _ = i.hash;
          (_.directionalLength !== m ||
            _.pointLength !== p ||
            _.spotLength !== x ||
            _.rectAreaLength !== y ||
            _.hemiLength !== v ||
            _.numDirectionalShadows !== M ||
            _.numPointShadows !== b ||
            _.numSpotShadows !== T) &&
            ((i.directional.length = m),
            (i.spot.length = x),
            (i.rectArea.length = y),
            (i.point.length = p),
            (i.hemi.length = v),
            (i.directionalShadow.length = M),
            (i.directionalShadowMap.length = M),
            (i.pointShadow.length = b),
            (i.pointShadowMap.length = b),
            (i.spotShadow.length = T),
            (i.spotShadowMap.length = T),
            (i.directionalShadowMatrix.length = M),
            (i.pointShadowMatrix.length = b),
            (i.spotShadowMatrix.length = T),
            (_.directionalLength = m),
            (_.pointLength = p),
            (_.spotLength = x),
            (_.rectAreaLength = y),
            (_.hemiLength = v),
            (_.numDirectionalShadows = M),
            (_.numPointShadows = b),
            (_.numSpotShadows = T),
            (i.version = vy++));
        }
        function c(u, h) {
          let d = 0,
            f = 0,
            g = 0,
            m = 0,
            p = 0;
          const x = h.matrixWorldInverse;
          for (let y = 0, v = u.length; y < v; y++) {
            const M = u[y];
            if (M.isDirectionalLight) {
              const b = i.directional[d];
              b.direction.setFromMatrixPosition(M.matrixWorld),
                r.setFromMatrixPosition(M.target.matrixWorld),
                b.direction.sub(r),
                b.direction.transformDirection(x),
                d++;
            } else if (M.isSpotLight) {
              const b = i.spot[g];
              b.position.setFromMatrixPosition(M.matrixWorld),
                b.position.applyMatrix4(x),
                b.direction.setFromMatrixPosition(M.matrixWorld),
                r.setFromMatrixPosition(M.target.matrixWorld),
                b.direction.sub(r),
                b.direction.transformDirection(x),
                g++;
            } else if (M.isRectAreaLight) {
              const b = i.rectArea[m];
              b.position.setFromMatrixPosition(M.matrixWorld),
                b.position.applyMatrix4(x),
                a.identity(),
                s.copy(M.matrixWorld),
                s.premultiply(x),
                a.extractRotation(s),
                b.halfWidth.set(M.width * 0.5, 0, 0),
                b.halfHeight.set(0, M.height * 0.5, 0),
                b.halfWidth.applyMatrix4(a),
                b.halfHeight.applyMatrix4(a),
                m++;
            } else if (M.isPointLight) {
              const b = i.point[f];
              b.position.setFromMatrixPosition(M.matrixWorld),
                b.position.applyMatrix4(x),
                f++;
            } else if (M.isHemisphereLight) {
              const b = i.hemi[p];
              b.direction.setFromMatrixPosition(M.matrixWorld),
                b.direction.transformDirection(x),
                p++;
            }
          }
        }
        return { setup: l, setupView: c, state: i };
      }
      function Gc(o, e) {
        const t = new by(o, e),
          n = [],
          i = [];
        function r() {
          (n.length = 0), (i.length = 0);
        }
        function s(h) {
          n.push(h);
        }
        function a(h) {
          i.push(h);
        }
        function l(h) {
          t.setup(n, h);
        }
        function c(h) {
          t.setupView(n, h);
        }
        return {
          init: r,
          state: { lightsArray: n, shadowsArray: i, lights: t },
          setupLights: l,
          setupLightsView: c,
          pushLight: s,
          pushShadow: a,
        };
      }
      function wy(o, e) {
        let t = new WeakMap();
        function n(r, s = 0) {
          let a;
          return (
            t.has(r) === !1
              ? ((a = new Gc(o, e)), t.set(r, [a]))
              : s >= t.get(r).length
              ? ((a = new Gc(o, e)), t.get(r).push(a))
              : (a = t.get(r)[s]),
            a
          );
        }
        function i() {
          t = new WeakMap();
        }
        return { get: n, dispose: i };
      }
      class Fo extends et {
        constructor(e) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = Bh),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      Fo.prototype.isMeshDepthMaterial = !0;
      class Bo extends et {
        constructor(e) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new S()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      Bo.prototype.isMeshDistanceMaterial = !0;
      const Sy = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        Ty = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function od(o, e, t) {
        let n = new ps();
        const i = new W(),
          r = new W(),
          s = new Je(),
          a = new Fo({ depthPacking: Nh }),
          l = new Bo(),
          c = {},
          u = t.maxTextureSize,
          h = { 0: Ft, 1: Gn, 2: kn },
          d = new zt({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new W() },
              radius: { value: 4 },
            },
            vertexShader: Sy,
            fragmentShader: Ty,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const g = new _e();
        g.setAttribute(
          "position",
          new Ue(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const m = new ut(g, d),
          p = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = vl),
          (this.render = function (M, b, T) {
            if (
              p.enabled === !1 ||
              (p.autoUpdate === !1 && p.needsUpdate === !1) ||
              M.length === 0
            )
              return;
            const C = o.getRenderTarget(),
              _ = o.getActiveCubeFace(),
              R = o.getActiveMipmapLevel(),
              P = o.state;
            P.setBlending(vn),
              P.buffers.color.setClear(1, 1, 1, 1),
              P.buffers.depth.setTest(!0),
              P.setScissorTest(!1);
            for (let D = 0, Z = M.length; D < Z; D++) {
              const j = M[D],
                I = j.shadow;
              if (I === void 0) {
                console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
                continue;
              }
              if (I.autoUpdate === !1 && I.needsUpdate === !1) continue;
              i.copy(I.mapSize);
              const U = I.getFrameExtents();
              if (
                (i.multiply(U),
                r.copy(I.mapSize),
                (i.x > u || i.y > u) &&
                  (i.x > u &&
                    ((r.x = Math.floor(u / U.x)),
                    (i.x = r.x * U.x),
                    (I.mapSize.x = r.x)),
                  i.y > u &&
                    ((r.y = Math.floor(u / U.y)),
                    (i.y = r.y * U.y),
                    (I.mapSize.y = r.y))),
                I.map === null &&
                  !I.isPointLightShadow &&
                  this.type === ir &&
                  ((I.map = new Tt(i.x, i.y)),
                  (I.map.texture.name = j.name + ".shadowMap"),
                  (I.mapPass = new Tt(i.x, i.y)),
                  I.camera.updateProjectionMatrix()),
                I.map === null)
              ) {
                const V = { minFilter: at, magFilter: at, format: Dt };
                (I.map = new Tt(i.x, i.y, V)),
                  (I.map.texture.name = j.name + ".shadowMap"),
                  I.camera.updateProjectionMatrix();
              }
              o.setRenderTarget(I.map), o.clear();
              const N = I.getViewportCount();
              for (let V = 0; V < N; V++) {
                const J = I.getViewport(V);
                s.set(r.x * J.x, r.y * J.y, r.x * J.z, r.y * J.w),
                  P.viewport(s),
                  I.updateMatrices(j, V),
                  (n = I.getFrustum()),
                  v(b, T, I.camera, j, this.type);
              }
              !I.isPointLightShadow && this.type === ir && x(I, T),
                (I.needsUpdate = !1);
            }
            (p.needsUpdate = !1), o.setRenderTarget(C, _, R);
          });
        function x(M, b) {
          const T = e.update(m);
          d.defines.VSM_SAMPLES !== M.blurSamples &&
            ((d.defines.VSM_SAMPLES = M.blurSamples),
            (f.defines.VSM_SAMPLES = M.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            (d.uniforms.shadow_pass.value = M.map.texture),
            (d.uniforms.resolution.value = M.mapSize),
            (d.uniforms.radius.value = M.radius),
            o.setRenderTarget(M.mapPass),
            o.clear(),
            o.renderBufferDirect(b, null, T, d, m, null),
            (f.uniforms.shadow_pass.value = M.mapPass.texture),
            (f.uniforms.resolution.value = M.mapSize),
            (f.uniforms.radius.value = M.radius),
            o.setRenderTarget(M.map),
            o.clear(),
            o.renderBufferDirect(b, null, T, f, m, null);
        }
        function y(M, b, T, C, _, R) {
          let P = null;
          const D =
            T.isPointLight === !0
              ? M.customDistanceMaterial
              : M.customDepthMaterial;
          if (
            (D !== void 0 ? (P = D) : (P = T.isPointLight === !0 ? l : a),
            (o.localClippingEnabled &&
              b.clipShadows === !0 &&
              b.clippingPlanes.length !== 0) ||
              (b.displacementMap && b.displacementScale !== 0) ||
              (b.alphaMap && b.alphaTest > 0))
          ) {
            const Z = P.uuid,
              j = b.uuid;
            let I = c[Z];
            I === void 0 && ((I = {}), (c[Z] = I));
            let U = I[j];
            U === void 0 && ((U = P.clone()), (I[j] = U)), (P = U);
          }
          return (
            (P.visible = b.visible),
            (P.wireframe = b.wireframe),
            R === ir
              ? (P.side = b.shadowSide !== null ? b.shadowSide : b.side)
              : (P.side = b.shadowSide !== null ? b.shadowSide : h[b.side]),
            (P.alphaMap = b.alphaMap),
            (P.alphaTest = b.alphaTest),
            (P.clipShadows = b.clipShadows),
            (P.clippingPlanes = b.clippingPlanes),
            (P.clipIntersection = b.clipIntersection),
            (P.displacementMap = b.displacementMap),
            (P.displacementScale = b.displacementScale),
            (P.displacementBias = b.displacementBias),
            (P.wireframeLinewidth = b.wireframeLinewidth),
            (P.linewidth = b.linewidth),
            T.isPointLight === !0 &&
              P.isMeshDistanceMaterial === !0 &&
              (P.referencePosition.setFromMatrixPosition(T.matrixWorld),
              (P.nearDistance = C),
              (P.farDistance = _)),
            P
          );
        }
        function v(M, b, T, C, _) {
          if (M.visible === !1) return;
          if (
            M.layers.test(b.layers) &&
            (M.isMesh || M.isLine || M.isPoints) &&
            (M.castShadow || (M.receiveShadow && _ === ir)) &&
            (!M.frustumCulled || n.intersectsObject(M))
          ) {
            M.modelViewMatrix.multiplyMatrices(
              T.matrixWorldInverse,
              M.matrixWorld
            );
            const D = e.update(M),
              Z = M.material;
            if (Array.isArray(Z)) {
              const j = D.groups;
              for (let I = 0, U = j.length; I < U; I++) {
                const N = j[I],
                  V = Z[N.materialIndex];
                if (V && V.visible) {
                  const J = y(M, V, C, T.near, T.far, _);
                  o.renderBufferDirect(T, null, D, J, M, N);
                }
              }
            } else if (Z.visible) {
              const j = y(M, Z, C, T.near, T.far, _);
              o.renderBufferDirect(T, null, D, j, M, null);
            }
          }
          const P = M.children;
          for (let D = 0, Z = P.length; D < Z; D++) v(P[D], b, T, C, _);
        }
      }
      function Ey(o, e, t) {
        const n = t.isWebGL2;
        function i() {
          let L = !1;
          const le = new Je();
          let oe = null;
          const Te = new Je(0, 0, 0, 0);
          return {
            setMask: function (de) {
              oe !== de && !L && (o.colorMask(de, de, de, de), (oe = de));
            },
            setLocked: function (de) {
              L = de;
            },
            setClear: function (de, we, re, Ee, Ye) {
              Ye === !0 && ((de *= Ee), (we *= Ee), (re *= Ee)),
                le.set(de, we, re, Ee),
                Te.equals(le) === !1 &&
                  (o.clearColor(de, we, re, Ee), Te.copy(le));
            },
            reset: function () {
              (L = !1), (oe = null), Te.set(-1, 0, 0, 0);
            },
          };
        }
        function r() {
          let L = !1,
            le = null,
            oe = null,
            Te = null;
          return {
            setTest: function (de) {
              de ? ye(2929) : k(2929);
            },
            setMask: function (de) {
              le !== de && !L && (o.depthMask(de), (le = de));
            },
            setFunc: function (de) {
              if (oe !== de) {
                if (de)
                  switch (de) {
                    case th:
                      o.depthFunc(512);
                      break;
                    case nh:
                      o.depthFunc(519);
                      break;
                    case ih:
                      o.depthFunc(513);
                      break;
                    case Mo:
                      o.depthFunc(515);
                      break;
                    case rh:
                      o.depthFunc(514);
                      break;
                    case sh:
                      o.depthFunc(518);
                      break;
                    case oh:
                      o.depthFunc(516);
                      break;
                    case ah:
                      o.depthFunc(517);
                      break;
                    default:
                      o.depthFunc(515);
                  }
                else o.depthFunc(515);
                oe = de;
              }
            },
            setLocked: function (de) {
              L = de;
            },
            setClear: function (de) {
              Te !== de && (o.clearDepth(de), (Te = de));
            },
            reset: function () {
              (L = !1), (le = null), (oe = null), (Te = null);
            },
          };
        }
        function s() {
          let L = !1,
            le = null,
            oe = null,
            Te = null,
            de = null,
            we = null,
            re = null,
            Ee = null,
            Ye = null;
          return {
            setTest: function (He) {
              L || (He ? ye(2960) : k(2960));
            },
            setMask: function (He) {
              le !== He && !L && (o.stencilMask(He), (le = He));
            },
            setFunc: function (He, Kt, Zt) {
              (oe !== He || Te !== Kt || de !== Zt) &&
                (o.stencilFunc(He, Kt, Zt), (oe = He), (Te = Kt), (de = Zt));
            },
            setOp: function (He, Kt, Zt) {
              (we !== He || re !== Kt || Ee !== Zt) &&
                (o.stencilOp(He, Kt, Zt), (we = He), (re = Kt), (Ee = Zt));
            },
            setLocked: function (He) {
              L = He;
            },
            setClear: function (He) {
              Ye !== He && (o.clearStencil(He), (Ye = He));
            },
            reset: function () {
              (L = !1),
                (le = null),
                (oe = null),
                (Te = null),
                (de = null),
                (we = null),
                (re = null),
                (Ee = null),
                (Ye = null);
            },
          };
        }
        const a = new i(),
          l = new r(),
          c = new s();
        let u = {},
          h = {},
          d = new WeakMap(),
          f = [],
          g = null,
          m = !1,
          p = null,
          x = null,
          y = null,
          v = null,
          M = null,
          b = null,
          T = null,
          C = !1,
          _ = null,
          R = null,
          P = null,
          D = null,
          Z = null;
        const j = o.getParameter(35661);
        let I = !1,
          U = 0;
        const N = o.getParameter(7938);
        N.indexOf("WebGL") !== -1
          ? ((U = parseFloat(/^WebGL (\d)/.exec(N)[1])), (I = U >= 1))
          : N.indexOf("OpenGL ES") !== -1 &&
            ((U = parseFloat(/^OpenGL ES (\d)/.exec(N)[1])), (I = U >= 2));
        let V = null,
          J = {};
        const z = o.getParameter(3088),
          q = o.getParameter(2978),
          ee = new Je().fromArray(z),
          $ = new Je().fromArray(q);
        function te(L, le, oe) {
          const Te = new Uint8Array(4),
            de = o.createTexture();
          o.bindTexture(L, de),
            o.texParameteri(L, 10241, 9728),
            o.texParameteri(L, 10240, 9728);
          for (let we = 0; we < oe; we++)
            o.texImage2D(le + we, 0, 6408, 1, 1, 0, 6408, 5121, Te);
          return de;
        }
        const xe = {};
        (xe[3553] = te(3553, 3553, 1)),
          (xe[34067] = te(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          ye(2929),
          l.setFunc(Mo),
          ie(!1),
          me(Ba),
          ye(2884),
          K(vn);
        function ye(L) {
          u[L] !== !0 && (o.enable(L), (u[L] = !0));
        }
        function k(L) {
          u[L] !== !1 && (o.disable(L), (u[L] = !1));
        }
        function qe(L, le) {
          return h[L] !== le
            ? (o.bindFramebuffer(L, le),
              (h[L] = le),
              n &&
                (L === 36009 && (h[36160] = le),
                L === 36160 && (h[36009] = le)),
              !0)
            : !1;
        }
        function Se(L, le) {
          let oe = f,
            Te = !1;
          if (L)
            if (
              ((oe = d.get(le)),
              oe === void 0 && ((oe = []), d.set(le, oe)),
              L.isWebGLMultipleRenderTargets)
            ) {
              const de = L.texture;
              if (oe.length !== de.length || oe[0] !== 36064) {
                for (let we = 0, re = de.length; we < re; we++)
                  oe[we] = 36064 + we;
                (oe.length = de.length), (Te = !0);
              }
            } else oe[0] !== 36064 && ((oe[0] = 36064), (Te = !0));
          else oe[0] !== 1029 && ((oe[0] = 1029), (Te = !0));
          Te &&
            (t.isWebGL2
              ? o.drawBuffers(oe)
              : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(oe));
        }
        function Pe(L) {
          return g !== L ? (o.useProgram(L), (g = L), !0) : !1;
        }
        const se = { [pi]: 32774, [Wu]: 32778, [qu]: 32779 };
        if (n) (se[za] = 32775), (se[Ha] = 32776);
        else {
          const L = e.get("EXT_blend_minmax");
          L !== null && ((se[za] = L.MIN_EXT), (se[Ha] = L.MAX_EXT));
        }
        const ze = {
          [Xu]: 0,
          [Ju]: 1,
          [Yu]: 768,
          [bl]: 770,
          [eh]: 776,
          [$u]: 774,
          [Ku]: 772,
          [ju]: 769,
          [wl]: 771,
          [Qu]: 775,
          [Zu]: 773,
        };
        function K(L, le, oe, Te, de, we, re, Ee) {
          if (L === vn) {
            m === !0 && (k(3042), (m = !1));
            return;
          }
          if ((m === !1 && (ye(3042), (m = !0)), L !== Vu)) {
            if (L !== p || Ee !== C) {
              if (
                ((x !== pi || M !== pi) &&
                  (o.blendEquation(32774), (x = pi), (M = pi)),
                Ee)
              )
                switch (L) {
                  case yi:
                    o.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case Na:
                    o.blendFunc(1, 1);
                    break;
                  case Oa:
                    o.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case Ua:
                    o.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", L);
                    break;
                }
              else
                switch (L) {
                  case yi:
                    o.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case Na:
                    o.blendFunc(770, 1);
                    break;
                  case Oa:
                    o.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case Ua:
                    o.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", L);
                    break;
                }
              (y = null), (v = null), (b = null), (T = null), (p = L), (C = Ee);
            }
            return;
          }
          (de = de || le),
            (we = we || oe),
            (re = re || Te),
            (le !== x || de !== M) &&
              (o.blendEquationSeparate(se[le], se[de]), (x = le), (M = de)),
            (oe !== y || Te !== v || we !== b || re !== T) &&
              (o.blendFuncSeparate(ze[oe], ze[Te], ze[we], ze[re]),
              (y = oe),
              (v = Te),
              (b = we),
              (T = re)),
            (p = L),
            (C = null);
        }
        function Y(L, le) {
          L.side === kn ? k(2884) : ye(2884);
          let oe = L.side === Ft;
          le && (oe = !oe),
            ie(oe),
            L.blending === yi && L.transparent === !1
              ? K(vn)
              : K(
                  L.blending,
                  L.blendEquation,
                  L.blendSrc,
                  L.blendDst,
                  L.blendEquationAlpha,
                  L.blendSrcAlpha,
                  L.blendDstAlpha,
                  L.premultipliedAlpha
                ),
            l.setFunc(L.depthFunc),
            l.setTest(L.depthTest),
            l.setMask(L.depthWrite),
            a.setMask(L.colorWrite);
          const Te = L.stencilWrite;
          c.setTest(Te),
            Te &&
              (c.setMask(L.stencilWriteMask),
              c.setFunc(L.stencilFunc, L.stencilRef, L.stencilFuncMask),
              c.setOp(L.stencilFail, L.stencilZFail, L.stencilZPass)),
            Re(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits),
            L.alphaToCoverage === !0 ? ye(32926) : k(32926);
        }
        function ie(L) {
          _ !== L && (L ? o.frontFace(2304) : o.frontFace(2305), (_ = L));
        }
        function me(L) {
          L !== Hu
            ? (ye(2884),
              L !== R &&
                (L === Ba
                  ? o.cullFace(1029)
                  : L === Gu
                  ? o.cullFace(1028)
                  : o.cullFace(1032)))
            : k(2884),
            (R = L);
        }
        function ue(L) {
          L !== P && (I && o.lineWidth(L), (P = L));
        }
        function Re(L, le, oe) {
          L
            ? (ye(32823),
              (D !== le || Z !== oe) &&
                (o.polygonOffset(le, oe), (D = le), (Z = oe)))
            : k(32823);
        }
        function be(L) {
          L ? ye(3089) : k(3089);
        }
        function ve(L) {
          L === void 0 && (L = 33984 + j - 1),
            V !== L && (o.activeTexture(L), (V = L));
        }
        function $e(L, le) {
          V === null && ve();
          let oe = J[V];
          oe === void 0 &&
            ((oe = { type: void 0, texture: void 0 }), (J[V] = oe)),
            (oe.type !== L || oe.texture !== le) &&
              (o.bindTexture(L, le || xe[L]), (oe.type = L), (oe.texture = le));
        }
        function Ze() {
          const L = J[V];
          L !== void 0 &&
            L.type !== void 0 &&
            (o.bindTexture(L.type, null),
            (L.type = void 0),
            (L.texture = void 0));
        }
        function A() {
          try {
            o.compressedTexImage2D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function w() {
          try {
            o.texSubImage2D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function H() {
          try {
            o.texSubImage3D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function Q() {
          try {
            o.compressedTexSubImage2D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function ce() {
          try {
            o.texStorage2D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function he() {
          try {
            o.texStorage3D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function Me() {
          try {
            o.texImage2D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function G() {
          try {
            o.texImage3D.apply(o, arguments);
          } catch (L) {
            console.error("THREE.WebGLState:", L);
          }
        }
        function Le(L) {
          ee.equals(L) === !1 && (o.scissor(L.x, L.y, L.z, L.w), ee.copy(L));
        }
        function De(L) {
          $.equals(L) === !1 && (o.viewport(L.x, L.y, L.z, L.w), $.copy(L));
        }
        function ge() {
          o.disable(3042),
            o.disable(2884),
            o.disable(2929),
            o.disable(32823),
            o.disable(3089),
            o.disable(2960),
            o.disable(32926),
            o.blendEquation(32774),
            o.blendFunc(1, 0),
            o.blendFuncSeparate(1, 0, 1, 0),
            o.colorMask(!0, !0, !0, !0),
            o.clearColor(0, 0, 0, 0),
            o.depthMask(!0),
            o.depthFunc(513),
            o.clearDepth(1),
            o.stencilMask(4294967295),
            o.stencilFunc(519, 0, 4294967295),
            o.stencilOp(7680, 7680, 7680),
            o.clearStencil(0),
            o.cullFace(1029),
            o.frontFace(2305),
            o.polygonOffset(0, 0),
            o.activeTexture(33984),
            o.bindFramebuffer(36160, null),
            n === !0 &&
              (o.bindFramebuffer(36009, null), o.bindFramebuffer(36008, null)),
            o.useProgram(null),
            o.lineWidth(1),
            o.scissor(0, 0, o.canvas.width, o.canvas.height),
            o.viewport(0, 0, o.canvas.width, o.canvas.height),
            (u = {}),
            (V = null),
            (J = {}),
            (h = {}),
            (d = new WeakMap()),
            (f = []),
            (g = null),
            (m = !1),
            (p = null),
            (x = null),
            (y = null),
            (v = null),
            (M = null),
            (b = null),
            (T = null),
            (C = !1),
            (_ = null),
            (R = null),
            (P = null),
            (D = null),
            (Z = null),
            ee.set(0, 0, o.canvas.width, o.canvas.height),
            $.set(0, 0, o.canvas.width, o.canvas.height),
            a.reset(),
            l.reset(),
            c.reset();
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: ye,
          disable: k,
          bindFramebuffer: qe,
          drawBuffers: Se,
          useProgram: Pe,
          setBlending: K,
          setMaterial: Y,
          setFlipSided: ie,
          setCullFace: me,
          setLineWidth: ue,
          setPolygonOffset: Re,
          setScissorTest: be,
          activeTexture: ve,
          bindTexture: $e,
          unbindTexture: Ze,
          compressedTexImage2D: A,
          texImage2D: Me,
          texImage3D: G,
          texStorage2D: ce,
          texStorage3D: he,
          texSubImage2D: w,
          texSubImage3D: H,
          compressedTexSubImage2D: Q,
          scissor: Le,
          viewport: De,
          reset: ge,
        };
      }
      function Ay(o, e, t, n, i, r, s) {
        const a = i.isWebGL2,
          l = i.maxTextures,
          c = i.maxCubemapSize,
          u = i.maxTextureSize,
          h = i.maxSamples,
          d = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : null,
          f = /OculusBrowser/g.test(navigator.userAgent),
          g = new WeakMap();
        let m;
        const p = new WeakMap();
        let x = !1;
        try {
          x =
            typeof OffscreenCanvas != "undefined" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function y(A, w) {
          return x ? new OffscreenCanvas(A, w) : ss("canvas");
        }
        function v(A, w, H, Q) {
          let ce = 1;
          if (
            ((A.width > Q || A.height > Q) &&
              (ce = Q / Math.max(A.width, A.height)),
            ce < 1 || w === !0)
          )
            if (
              (typeof HTMLImageElement != "undefined" &&
                A instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement != "undefined" &&
                A instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap != "undefined" && A instanceof ImageBitmap)
            ) {
              const he = w ? wo : Math.floor,
                Me = he(ce * A.width),
                G = he(ce * A.height);
              m === void 0 && (m = y(Me, G));
              const Le = H ? y(Me, G) : m;
              return (
                (Le.width = Me),
                (Le.height = G),
                Le.getContext("2d").drawImage(A, 0, 0, Me, G),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    A.width +
                    "x" +
                    A.height +
                    ") to (" +
                    Me +
                    "x" +
                    G +
                    ")."
                ),
                Le
              );
            } else
              return (
                "data" in A &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      A.width +
                      "x" +
                      A.height +
                      ")."
                  ),
                A
              );
          return A;
        }
        function M(A) {
          return cl(A.width) && cl(A.height);
        }
        function b(A) {
          return a
            ? !1
            : A.wrapS !== Mt ||
                A.wrapT !== Mt ||
                (A.minFilter !== at && A.minFilter !== tt);
        }
        function T(A, w) {
          return (
            A.generateMipmaps && w && A.minFilter !== at && A.minFilter !== tt
          );
        }
        function C(A) {
          o.generateMipmap(A);
        }
        function _(A, w, H, Q, ce = !1) {
          if (a === !1) return w;
          if (A !== null) {
            if (o[A] !== void 0) return o[A];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                A +
                "'"
            );
          }
          let he = w;
          return (
            w === 6403 &&
              (H === 5126 && (he = 33326),
              H === 5131 && (he = 33325),
              H === 5121 && (he = 33321)),
            w === 33319 &&
              (H === 5126 && (he = 33328),
              H === 5131 && (he = 33327),
              H === 5121 && (he = 33323)),
            w === 6408 &&
              (H === 5126 && (he = 34836),
              H === 5131 && (he = 34842),
              H === 5121 && (he = Q === We && ce === !1 ? 35907 : 32856),
              H === 32819 && (he = 32854),
              H === 32820 && (he = 32855)),
            (he === 33325 ||
              he === 33326 ||
              he === 33327 ||
              he === 33328 ||
              he === 34842 ||
              he === 34836) &&
              e.get("EXT_color_buffer_float"),
            he
          );
        }
        function R(A, w, H) {
          return T(A, H) === !0 ||
            (A.isFramebufferTexture && A.minFilter !== at && A.minFilter !== tt)
            ? Math.log2(Math.max(w.width, w.height)) + 1
            : A.mipmaps !== void 0 && A.mipmaps.length > 0
            ? A.mipmaps.length
            : A.isCompressedTexture && Array.isArray(A.image)
            ? w.mipmaps.length
            : 1;
        }
        function P(A) {
          return A === at || A === ts || A === ns ? 9728 : 9729;
        }
        function D(A) {
          const w = A.target;
          w.removeEventListener("dispose", D),
            j(w),
            w.isVideoTexture && g.delete(w);
        }
        function Z(A) {
          const w = A.target;
          w.removeEventListener("dispose", Z), U(w);
        }
        function j(A) {
          const w = n.get(A);
          if (w.__webglInit === void 0) return;
          const H = A.source,
            Q = p.get(H);
          if (Q) {
            const ce = Q[w.__cacheKey];
            ce.usedTimes--,
              ce.usedTimes === 0 && I(A),
              Object.keys(Q).length === 0 && p.delete(H);
          }
          n.remove(A);
        }
        function I(A) {
          const w = n.get(A);
          o.deleteTexture(w.__webglTexture);
          const H = A.source,
            Q = p.get(H);
          delete Q[w.__cacheKey], s.memory.textures--;
        }
        function U(A) {
          const w = A.texture,
            H = n.get(A),
            Q = n.get(w);
          if (
            (Q.__webglTexture !== void 0 &&
              (o.deleteTexture(Q.__webglTexture), s.memory.textures--),
            A.depthTexture && A.depthTexture.dispose(),
            A.isWebGLCubeRenderTarget)
          )
            for (let ce = 0; ce < 6; ce++)
              o.deleteFramebuffer(H.__webglFramebuffer[ce]),
                H.__webglDepthbuffer &&
                  o.deleteRenderbuffer(H.__webglDepthbuffer[ce]);
          else
            o.deleteFramebuffer(H.__webglFramebuffer),
              H.__webglDepthbuffer &&
                o.deleteRenderbuffer(H.__webglDepthbuffer),
              H.__webglMultisampledFramebuffer &&
                o.deleteFramebuffer(H.__webglMultisampledFramebuffer),
              H.__webglColorRenderbuffer &&
                o.deleteRenderbuffer(H.__webglColorRenderbuffer),
              H.__webglDepthRenderbuffer &&
                o.deleteRenderbuffer(H.__webglDepthRenderbuffer);
          if (A.isWebGLMultipleRenderTargets)
            for (let ce = 0, he = w.length; ce < he; ce++) {
              const Me = n.get(w[ce]);
              Me.__webglTexture &&
                (o.deleteTexture(Me.__webglTexture), s.memory.textures--),
                n.remove(w[ce]);
            }
          n.remove(w), n.remove(A);
        }
        let N = 0;
        function V() {
          N = 0;
        }
        function J() {
          const A = N;
          return (
            A >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  A +
                  " texture units while this GPU supports only " +
                  l
              ),
            (N += 1),
            A
          );
        }
        function z(A) {
          const w = [];
          return (
            w.push(A.wrapS),
            w.push(A.wrapT),
            w.push(A.magFilter),
            w.push(A.minFilter),
            w.push(A.anisotropy),
            w.push(A.internalFormat),
            w.push(A.format),
            w.push(A.type),
            w.push(A.generateMipmaps),
            w.push(A.premultiplyAlpha),
            w.push(A.flipY),
            w.push(A.unpackAlignment),
            w.push(A.encoding),
            w.join()
          );
        }
        function q(A, w) {
          const H = n.get(A);
          if (
            (A.isVideoTexture && $e(A),
            A.isRenderTargetTexture === !1 &&
              A.version > 0 &&
              H.__version !== A.version)
          ) {
            const Q = A.image;
            if (Q === null)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else if (Q.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              Se(H, A, w);
              return;
            }
          }
          t.activeTexture(33984 + w), t.bindTexture(3553, H.__webglTexture);
        }
        function ee(A, w) {
          const H = n.get(A);
          if (A.version > 0 && H.__version !== A.version) {
            Se(H, A, w);
            return;
          }
          t.activeTexture(33984 + w), t.bindTexture(35866, H.__webglTexture);
        }
        function $(A, w) {
          const H = n.get(A);
          if (A.version > 0 && H.__version !== A.version) {
            Se(H, A, w);
            return;
          }
          t.activeTexture(33984 + w), t.bindTexture(32879, H.__webglTexture);
        }
        function te(A, w) {
          const H = n.get(A);
          if (A.version > 0 && H.__version !== A.version) {
            Pe(H, A, w);
            return;
          }
          t.activeTexture(33984 + w), t.bindTexture(34067, H.__webglTexture);
        }
        const xe = { [qn]: 10497, [Mt]: 33071, [ar]: 33648 },
          ye = {
            [at]: 9728,
            [ts]: 9984,
            [ns]: 9986,
            [tt]: 9729,
            [Eo]: 9985,
            [Sn]: 9987,
          };
        function k(A, w, H) {
          if (
            (H
              ? (o.texParameteri(A, 10242, xe[w.wrapS]),
                o.texParameteri(A, 10243, xe[w.wrapT]),
                (A === 32879 || A === 35866) &&
                  o.texParameteri(A, 32882, xe[w.wrapR]),
                o.texParameteri(A, 10240, ye[w.magFilter]),
                o.texParameteri(A, 10241, ye[w.minFilter]))
              : (o.texParameteri(A, 10242, 33071),
                o.texParameteri(A, 10243, 33071),
                (A === 32879 || A === 35866) &&
                  o.texParameteri(A, 32882, 33071),
                (w.wrapS !== Mt || w.wrapT !== Mt) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                o.texParameteri(A, 10240, P(w.magFilter)),
                o.texParameteri(A, 10241, P(w.minFilter)),
                w.minFilter !== at &&
                  w.minFilter !== tt &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            const Q = e.get("EXT_texture_filter_anisotropic");
            if (
              (w.type === _n && e.has("OES_texture_float_linear") === !1) ||
              (a === !1 &&
                w.type === cr &&
                e.has("OES_texture_half_float_linear") === !1)
            )
              return;
            (w.anisotropy > 1 || n.get(w).__currentAnisotropy) &&
              (o.texParameterf(
                A,
                Q.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(w.anisotropy, i.getMaxAnisotropy())
              ),
              (n.get(w).__currentAnisotropy = w.anisotropy));
          }
        }
        function qe(A, w) {
          let H = !1;
          A.__webglInit === void 0 &&
            ((A.__webglInit = !0), w.addEventListener("dispose", D));
          const Q = w.source;
          let ce = p.get(Q);
          ce === void 0 && ((ce = {}), p.set(Q, ce));
          const he = z(w);
          if (he !== A.__cacheKey) {
            ce[he] === void 0 &&
              ((ce[he] = { texture: o.createTexture(), usedTimes: 0 }),
              s.memory.textures++,
              (H = !0)),
              ce[he].usedTimes++;
            const Me = ce[A.__cacheKey];
            Me !== void 0 &&
              (ce[A.__cacheKey].usedTimes--, Me.usedTimes === 0 && I(w)),
              (A.__cacheKey = he),
              (A.__webglTexture = ce[he].texture);
          }
          return H;
        }
        function Se(A, w, H) {
          let Q = 3553;
          w.isDataArrayTexture && (Q = 35866), w.isData3DTexture && (Q = 32879);
          const ce = qe(A, w),
            he = w.source;
          if (
            (t.activeTexture(33984 + H),
            t.bindTexture(Q, A.__webglTexture),
            he.version !== he.__currentVersion || ce === !0)
          ) {
            o.pixelStorei(37440, w.flipY),
              o.pixelStorei(37441, w.premultiplyAlpha),
              o.pixelStorei(3317, w.unpackAlignment),
              o.pixelStorei(37443, 0);
            const Me = b(w) && M(w.image) === !1;
            let G = v(w.image, Me, !1, u);
            G = Ze(w, G);
            const Le = M(G) || a,
              De = r.convert(w.format, w.encoding);
            let ge = r.convert(w.type),
              L = _(w.internalFormat, De, ge, w.encoding, w.isVideoTexture);
            k(Q, w, Le);
            let le;
            const oe = w.mipmaps,
              Te = a && w.isVideoTexture !== !0,
              de = A.__version === void 0 || ce === !0,
              we = R(w, G, Le);
            if (w.isDepthTexture)
              (L = 6402),
                a
                  ? w.type === _n
                    ? (L = 36012)
                    : w.type === jr
                    ? (L = 33190)
                    : w.type === _i
                    ? (L = 35056)
                    : (L = 33189)
                  : w.type === _n &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                w.format === zn &&
                  L === 6402 &&
                  w.type !== lr &&
                  w.type !== jr &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (w.type = lr),
                  (ge = r.convert(w.type))),
                w.format === wi &&
                  L === 6402 &&
                  ((L = 34041),
                  w.type !== _i &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (w.type = _i),
                    (ge = r.convert(w.type)))),
                de &&
                  (Te
                    ? t.texStorage2D(3553, 1, L, G.width, G.height)
                    : t.texImage2D(
                        3553,
                        0,
                        L,
                        G.width,
                        G.height,
                        0,
                        De,
                        ge,
                        null
                      ));
            else if (w.isDataTexture)
              if (oe.length > 0 && Le) {
                Te &&
                  de &&
                  t.texStorage2D(3553, we, L, oe[0].width, oe[0].height);
                for (let re = 0, Ee = oe.length; re < Ee; re++)
                  (le = oe[re]),
                    Te
                      ? t.texSubImage2D(
                          3553,
                          re,
                          0,
                          0,
                          le.width,
                          le.height,
                          De,
                          ge,
                          le.data
                        )
                      : t.texImage2D(
                          3553,
                          re,
                          L,
                          le.width,
                          le.height,
                          0,
                          De,
                          ge,
                          le.data
                        );
                w.generateMipmaps = !1;
              } else
                Te
                  ? (de && t.texStorage2D(3553, we, L, G.width, G.height),
                    t.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      G.width,
                      G.height,
                      De,
                      ge,
                      G.data
                    ))
                  : t.texImage2D(
                      3553,
                      0,
                      L,
                      G.width,
                      G.height,
                      0,
                      De,
                      ge,
                      G.data
                    );
            else if (w.isCompressedTexture) {
              Te &&
                de &&
                t.texStorage2D(3553, we, L, oe[0].width, oe[0].height);
              for (let re = 0, Ee = oe.length; re < Ee; re++)
                (le = oe[re]),
                  w.format !== Dt
                    ? De !== null
                      ? Te
                        ? t.compressedTexSubImage2D(
                            3553,
                            re,
                            0,
                            0,
                            le.width,
                            le.height,
                            De,
                            le.data
                          )
                        : t.compressedTexImage2D(
                            3553,
                            re,
                            L,
                            le.width,
                            le.height,
                            0,
                            le.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : Te
                    ? t.texSubImage2D(
                        3553,
                        re,
                        0,
                        0,
                        le.width,
                        le.height,
                        De,
                        ge,
                        le.data
                      )
                    : t.texImage2D(
                        3553,
                        re,
                        L,
                        le.width,
                        le.height,
                        0,
                        De,
                        ge,
                        le.data
                      );
            } else if (w.isDataArrayTexture)
              Te
                ? (de &&
                    t.texStorage3D(35866, we, L, G.width, G.height, G.depth),
                  t.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    G.width,
                    G.height,
                    G.depth,
                    De,
                    ge,
                    G.data
                  ))
                : t.texImage3D(
                    35866,
                    0,
                    L,
                    G.width,
                    G.height,
                    G.depth,
                    0,
                    De,
                    ge,
                    G.data
                  );
            else if (w.isData3DTexture)
              Te
                ? (de &&
                    t.texStorage3D(32879, we, L, G.width, G.height, G.depth),
                  t.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    G.width,
                    G.height,
                    G.depth,
                    De,
                    ge,
                    G.data
                  ))
                : t.texImage3D(
                    32879,
                    0,
                    L,
                    G.width,
                    G.height,
                    G.depth,
                    0,
                    De,
                    ge,
                    G.data
                  );
            else if (w.isFramebufferTexture) {
              if (de)
                if (Te) t.texStorage2D(3553, we, L, G.width, G.height);
                else {
                  let re = G.width,
                    Ee = G.height;
                  for (let Ye = 0; Ye < we; Ye++)
                    t.texImage2D(3553, Ye, L, re, Ee, 0, De, ge, null),
                      (re >>= 1),
                      (Ee >>= 1);
                }
            } else if (oe.length > 0 && Le) {
              Te &&
                de &&
                t.texStorage2D(3553, we, L, oe[0].width, oe[0].height);
              for (let re = 0, Ee = oe.length; re < Ee; re++)
                (le = oe[re]),
                  Te
                    ? t.texSubImage2D(3553, re, 0, 0, De, ge, le)
                    : t.texImage2D(3553, re, L, De, ge, le);
              w.generateMipmaps = !1;
            } else
              Te
                ? (de && t.texStorage2D(3553, we, L, G.width, G.height),
                  t.texSubImage2D(3553, 0, 0, 0, De, ge, G))
                : t.texImage2D(3553, 0, L, De, ge, G);
            T(w, Le) && C(Q),
              (he.__currentVersion = he.version),
              w.onUpdate && w.onUpdate(w);
          }
          A.__version = w.version;
        }
        function Pe(A, w, H) {
          if (w.image.length !== 6) return;
          const Q = qe(A, w),
            ce = w.source;
          if (
            (t.activeTexture(33984 + H),
            t.bindTexture(34067, A.__webglTexture),
            ce.version !== ce.__currentVersion || Q === !0)
          ) {
            o.pixelStorei(37440, w.flipY),
              o.pixelStorei(37441, w.premultiplyAlpha),
              o.pixelStorei(3317, w.unpackAlignment),
              o.pixelStorei(37443, 0);
            const he = w.isCompressedTexture || w.image[0].isCompressedTexture,
              Me = w.image[0] && w.image[0].isDataTexture,
              G = [];
            for (let re = 0; re < 6; re++)
              !he && !Me
                ? (G[re] = v(w.image[re], !1, !0, c))
                : (G[re] = Me ? w.image[re].image : w.image[re]),
                (G[re] = Ze(w, G[re]));
            const Le = G[0],
              De = M(Le) || a,
              ge = r.convert(w.format, w.encoding),
              L = r.convert(w.type),
              le = _(w.internalFormat, ge, L, w.encoding),
              oe = a && w.isVideoTexture !== !0,
              Te = A.__version === void 0;
            let de = R(w, Le, De);
            k(34067, w, De);
            let we;
            if (he) {
              oe && Te && t.texStorage2D(34067, de, le, Le.width, Le.height);
              for (let re = 0; re < 6; re++) {
                we = G[re].mipmaps;
                for (let Ee = 0; Ee < we.length; Ee++) {
                  const Ye = we[Ee];
                  w.format !== Dt
                    ? ge !== null
                      ? oe
                        ? t.compressedTexSubImage2D(
                            34069 + re,
                            Ee,
                            0,
                            0,
                            Ye.width,
                            Ye.height,
                            ge,
                            Ye.data
                          )
                        : t.compressedTexImage2D(
                            34069 + re,
                            Ee,
                            le,
                            Ye.width,
                            Ye.height,
                            0,
                            Ye.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : oe
                    ? t.texSubImage2D(
                        34069 + re,
                        Ee,
                        0,
                        0,
                        Ye.width,
                        Ye.height,
                        ge,
                        L,
                        Ye.data
                      )
                    : t.texImage2D(
                        34069 + re,
                        Ee,
                        le,
                        Ye.width,
                        Ye.height,
                        0,
                        ge,
                        L,
                        Ye.data
                      );
                }
              }
            } else {
              (we = w.mipmaps),
                oe &&
                  Te &&
                  (we.length > 0 && de++,
                  t.texStorage2D(34067, de, le, G[0].width, G[0].height));
              for (let re = 0; re < 6; re++)
                if (Me) {
                  oe
                    ? t.texSubImage2D(
                        34069 + re,
                        0,
                        0,
                        0,
                        G[re].width,
                        G[re].height,
                        ge,
                        L,
                        G[re].data
                      )
                    : t.texImage2D(
                        34069 + re,
                        0,
                        le,
                        G[re].width,
                        G[re].height,
                        0,
                        ge,
                        L,
                        G[re].data
                      );
                  for (let Ee = 0; Ee < we.length; Ee++) {
                    const He = we[Ee].image[re].image;
                    oe
                      ? t.texSubImage2D(
                          34069 + re,
                          Ee + 1,
                          0,
                          0,
                          He.width,
                          He.height,
                          ge,
                          L,
                          He.data
                        )
                      : t.texImage2D(
                          34069 + re,
                          Ee + 1,
                          le,
                          He.width,
                          He.height,
                          0,
                          ge,
                          L,
                          He.data
                        );
                  }
                } else {
                  oe
                    ? t.texSubImage2D(34069 + re, 0, 0, 0, ge, L, G[re])
                    : t.texImage2D(34069 + re, 0, le, ge, L, G[re]);
                  for (let Ee = 0; Ee < we.length; Ee++) {
                    const Ye = we[Ee];
                    oe
                      ? t.texSubImage2D(
                          34069 + re,
                          Ee + 1,
                          0,
                          0,
                          ge,
                          L,
                          Ye.image[re]
                        )
                      : t.texImage2D(
                          34069 + re,
                          Ee + 1,
                          le,
                          ge,
                          L,
                          Ye.image[re]
                        );
                  }
                }
            }
            T(w, De) && C(34067),
              (ce.__currentVersion = ce.version),
              w.onUpdate && w.onUpdate(w);
          }
          A.__version = w.version;
        }
        function se(A, w, H, Q, ce) {
          const he = r.convert(H.format, H.encoding),
            Me = r.convert(H.type),
            G = _(H.internalFormat, he, Me, H.encoding);
          n.get(w).__hasExternalTextures ||
            (ce === 32879 || ce === 35866
              ? t.texImage3D(
                  ce,
                  0,
                  G,
                  w.width,
                  w.height,
                  w.depth,
                  0,
                  he,
                  Me,
                  null
                )
              : t.texImage2D(ce, 0, G, w.width, w.height, 0, he, Me, null)),
            t.bindFramebuffer(36160, A),
            ve(w)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  Q,
                  ce,
                  n.get(H).__webglTexture,
                  0,
                  be(w)
                )
              : o.framebufferTexture2D(
                  36160,
                  Q,
                  ce,
                  n.get(H).__webglTexture,
                  0
                ),
            t.bindFramebuffer(36160, null);
        }
        function ze(A, w, H) {
          if (
            (o.bindRenderbuffer(36161, A), w.depthBuffer && !w.stencilBuffer)
          ) {
            let Q = 33189;
            if (H || ve(w)) {
              const ce = w.depthTexture;
              ce &&
                ce.isDepthTexture &&
                (ce.type === _n ? (Q = 36012) : ce.type === jr && (Q = 33190));
              const he = be(w);
              ve(w)
                ? d.renderbufferStorageMultisampleEXT(
                    36161,
                    he,
                    Q,
                    w.width,
                    w.height
                  )
                : o.renderbufferStorageMultisample(
                    36161,
                    he,
                    Q,
                    w.width,
                    w.height
                  );
            } else o.renderbufferStorage(36161, Q, w.width, w.height);
            o.framebufferRenderbuffer(36160, 36096, 36161, A);
          } else if (w.depthBuffer && w.stencilBuffer) {
            const Q = be(w);
            H && ve(w) === !1
              ? o.renderbufferStorageMultisample(
                  36161,
                  Q,
                  35056,
                  w.width,
                  w.height
                )
              : ve(w)
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  Q,
                  35056,
                  w.width,
                  w.height
                )
              : o.renderbufferStorage(36161, 34041, w.width, w.height),
              o.framebufferRenderbuffer(36160, 33306, 36161, A);
          } else {
            const Q =
                w.isWebGLMultipleRenderTargets === !0
                  ? w.texture[0]
                  : w.texture,
              ce = r.convert(Q.format, Q.encoding),
              he = r.convert(Q.type),
              Me = _(Q.internalFormat, ce, he, Q.encoding),
              G = be(w);
            H && ve(w) === !1
              ? o.renderbufferStorageMultisample(
                  36161,
                  G,
                  Me,
                  w.width,
                  w.height
                )
              : ve(w)
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  G,
                  Me,
                  w.width,
                  w.height
                )
              : o.renderbufferStorage(36161, Me, w.width, w.height);
          }
          o.bindRenderbuffer(36161, null);
        }
        function K(A, w) {
          if (w && w.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(36160, A),
            !(w.depthTexture && w.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(w.depthTexture).__webglTexture ||
            w.depthTexture.image.width !== w.width ||
            w.depthTexture.image.height !== w.height) &&
            ((w.depthTexture.image.width = w.width),
            (w.depthTexture.image.height = w.height),
            (w.depthTexture.needsUpdate = !0)),
            q(w.depthTexture, 0);
          const Q = n.get(w.depthTexture).__webglTexture,
            ce = be(w);
          if (w.depthTexture.format === zn)
            ve(w)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  36096,
                  3553,
                  Q,
                  0,
                  ce
                )
              : o.framebufferTexture2D(36160, 36096, 3553, Q, 0);
          else if (w.depthTexture.format === wi)
            ve(w)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  33306,
                  3553,
                  Q,
                  0,
                  ce
                )
              : o.framebufferTexture2D(36160, 33306, 3553, Q, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Y(A) {
          const w = n.get(A),
            H = A.isWebGLCubeRenderTarget === !0;
          if (A.depthTexture && !w.__autoAllocateDepthBuffer) {
            if (H)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            K(w.__webglFramebuffer, A);
          } else if (H) {
            w.__webglDepthbuffer = [];
            for (let Q = 0; Q < 6; Q++)
              t.bindFramebuffer(36160, w.__webglFramebuffer[Q]),
                (w.__webglDepthbuffer[Q] = o.createRenderbuffer()),
                ze(w.__webglDepthbuffer[Q], A, !1);
          } else
            t.bindFramebuffer(36160, w.__webglFramebuffer),
              (w.__webglDepthbuffer = o.createRenderbuffer()),
              ze(w.__webglDepthbuffer, A, !1);
          t.bindFramebuffer(36160, null);
        }
        function ie(A, w, H) {
          const Q = n.get(A);
          w !== void 0 && se(Q.__webglFramebuffer, A, A.texture, 36064, 3553),
            H !== void 0 && Y(A);
        }
        function me(A) {
          const w = A.texture,
            H = n.get(A),
            Q = n.get(w);
          A.addEventListener("dispose", Z),
            A.isWebGLMultipleRenderTargets !== !0 &&
              (Q.__webglTexture === void 0 &&
                (Q.__webglTexture = o.createTexture()),
              (Q.__version = w.version),
              s.memory.textures++);
          const ce = A.isWebGLCubeRenderTarget === !0,
            he = A.isWebGLMultipleRenderTargets === !0,
            Me = M(A) || a;
          if (ce) {
            H.__webglFramebuffer = [];
            for (let G = 0; G < 6; G++)
              H.__webglFramebuffer[G] = o.createFramebuffer();
          } else if (((H.__webglFramebuffer = o.createFramebuffer()), he))
            if (i.drawBuffers) {
              const G = A.texture;
              for (let Le = 0, De = G.length; Le < De; Le++) {
                const ge = n.get(G[Le]);
                ge.__webglTexture === void 0 &&
                  ((ge.__webglTexture = o.createTexture()),
                  s.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (a && A.samples > 0 && ve(A) === !1) {
            (H.__webglMultisampledFramebuffer = o.createFramebuffer()),
              (H.__webglColorRenderbuffer = o.createRenderbuffer()),
              o.bindRenderbuffer(36161, H.__webglColorRenderbuffer);
            const G = r.convert(w.format, w.encoding),
              Le = r.convert(w.type),
              De = _(w.internalFormat, G, Le, w.encoding),
              ge = be(A);
            o.renderbufferStorageMultisample(36161, ge, De, A.width, A.height),
              t.bindFramebuffer(36160, H.__webglMultisampledFramebuffer),
              o.framebufferRenderbuffer(
                36160,
                36064,
                36161,
                H.__webglColorRenderbuffer
              ),
              o.bindRenderbuffer(36161, null),
              A.depthBuffer &&
                ((H.__webglDepthRenderbuffer = o.createRenderbuffer()),
                ze(H.__webglDepthRenderbuffer, A, !0)),
              t.bindFramebuffer(36160, null);
          }
          if (ce) {
            t.bindTexture(34067, Q.__webglTexture), k(34067, w, Me);
            for (let G = 0; G < 6; G++)
              se(H.__webglFramebuffer[G], A, w, 36064, 34069 + G);
            T(w, Me) && C(34067), t.unbindTexture();
          } else if (he) {
            const G = A.texture;
            for (let Le = 0, De = G.length; Le < De; Le++) {
              const ge = G[Le],
                L = n.get(ge);
              t.bindTexture(3553, L.__webglTexture),
                k(3553, ge, Me),
                se(H.__webglFramebuffer, A, ge, 36064 + Le, 3553),
                T(ge, Me) && C(3553);
            }
            t.unbindTexture();
          } else {
            let G = 3553;
            (A.isWebGL3DRenderTarget || A.isWebGLArrayRenderTarget) &&
              (a
                ? (G = A.isWebGL3DRenderTarget ? 32879 : 35866)
                : console.error(
                    "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                  )),
              t.bindTexture(G, Q.__webglTexture),
              k(G, w, Me),
              se(H.__webglFramebuffer, A, w, 36064, G),
              T(w, Me) && C(G),
              t.unbindTexture();
          }
          A.depthBuffer && Y(A);
        }
        function ue(A) {
          const w = M(A) || a,
            H = A.isWebGLMultipleRenderTargets === !0 ? A.texture : [A.texture];
          for (let Q = 0, ce = H.length; Q < ce; Q++) {
            const he = H[Q];
            if (T(he, w)) {
              const Me = A.isWebGLCubeRenderTarget ? 34067 : 3553,
                G = n.get(he).__webglTexture;
              t.bindTexture(Me, G), C(Me), t.unbindTexture();
            }
          }
        }
        function Re(A) {
          if (a && A.samples > 0 && ve(A) === !1) {
            const w = A.width,
              H = A.height;
            let Q = 16384;
            const ce = [36064],
              he = A.stencilBuffer ? 33306 : 36096;
            A.depthBuffer && ce.push(he);
            const Me = n.get(A),
              G =
                Me.__ignoreDepthValues !== void 0 ? Me.__ignoreDepthValues : !1;
            G === !1 &&
              (A.depthBuffer && (Q |= 256), A.stencilBuffer && (Q |= 1024)),
              t.bindFramebuffer(36008, Me.__webglMultisampledFramebuffer),
              t.bindFramebuffer(36009, Me.__webglFramebuffer),
              G === !0 &&
                (o.invalidateFramebuffer(36008, [he]),
                o.invalidateFramebuffer(36009, [he])),
              o.blitFramebuffer(0, 0, w, H, 0, 0, w, H, Q, 9728),
              f && o.invalidateFramebuffer(36008, ce),
              t.bindFramebuffer(36008, null),
              t.bindFramebuffer(36009, Me.__webglMultisampledFramebuffer);
          }
        }
        function be(A) {
          return Math.min(h, A.samples);
        }
        function ve(A) {
          const w = n.get(A);
          return (
            a &&
            A.samples > 0 &&
            e.has("WEBGL_multisampled_render_to_texture") === !0 &&
            w.__useRenderToTexture !== !1
          );
        }
        function $e(A) {
          const w = s.render.frame;
          g.get(A) !== w && (g.set(A, w), A.update());
        }
        function Ze(A, w) {
          const H = A.encoding,
            Q = A.format,
            ce = A.type;
          return (
            A.isCompressedTexture === !0 ||
              A.isVideoTexture === !0 ||
              A.format === bo ||
              (H !== Mn &&
                (H === We
                  ? a === !1
                    ? e.has("EXT_sRGB") === !0 && Q === Dt
                      ? ((A.format = bo),
                        (A.minFilter = tt),
                        (A.generateMipmaps = !1))
                      : (w = $n.sRGBToLinear(w))
                    : (Q !== Dt || ce !== Xn) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      H
                    ))),
            w
          );
        }
        (this.allocateTextureUnit = J),
          (this.resetTextureUnits = V),
          (this.setTexture2D = q),
          (this.setTexture2DArray = ee),
          (this.setTexture3D = $),
          (this.setTextureCube = te),
          (this.rebindTextures = ie),
          (this.setupRenderTarget = me),
          (this.updateRenderTargetMipmap = ue),
          (this.updateMultisampleRenderTarget = Re),
          (this.setupDepthRenderbuffer = Y),
          (this.setupFrameBufferTexture = se),
          (this.useMultisampledRTT = ve);
      }
      function ad(o, e, t) {
        const n = t.isWebGL2;
        function i(r, s = null) {
          let a;
          if (r === Xn) return 5121;
          if (r === yh) return 32819;
          if (r === _h) return 32820;
          if (r === mh) return 5120;
          if (r === gh) return 5122;
          if (r === lr) return 5123;
          if (r === xh) return 5124;
          if (r === jr) return 5125;
          if (r === _n) return 5126;
          if (r === cr)
            return n
              ? 5131
              : ((a = e.get("OES_texture_half_float")),
                a !== null ? a.HALF_FLOAT_OES : null);
          if (r === vh) return 6406;
          if (r === Dt) return 6408;
          if (r === bh) return 6409;
          if (r === wh) return 6410;
          if (r === zn) return 6402;
          if (r === wi) return 34041;
          if (r === Sh) return 6403;
          if (r === Mh)
            return (
              console.warn(
                "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
              ),
              6408
            );
          if (r === bo)
            return (
              (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null
            );
          if (r === Th) return 36244;
          if (r === Eh) return 33319;
          if (r === Ah) return 33320;
          if (r === Rh) return 36249;
          if (r === po || r === mo || r === go || r === xo)
            if (s === We)
              if (
                ((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)
              ) {
                if (r === po) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (r === mo) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (r === go) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (r === xo) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else return null;
            else if (
              ((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)
            ) {
              if (r === po) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (r === mo) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (r === go) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (r === xo) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (r === Ga || r === ka || r === Va || r === Wa)
            if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
              if (r === Ga) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (r === ka) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (r === Va) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (r === Wa) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (r === Ch)
            return (
              (a = e.get("WEBGL_compressed_texture_etc1")),
              a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (r === qa || r === Xa)
            if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
              if (r === qa)
                return s === We
                  ? a.COMPRESSED_SRGB8_ETC2
                  : a.COMPRESSED_RGB8_ETC2;
              if (r === Xa)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : a.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
          if (
            r === Ja ||
            r === Ya ||
            r === ja ||
            r === Ka ||
            r === Za ||
            r === $a ||
            r === Qa ||
            r === el ||
            r === tl ||
            r === nl ||
            r === il ||
            r === rl ||
            r === sl ||
            r === ol
          )
            if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
              if (r === Ja)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (r === Ya)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (r === ja)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (r === Ka)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (r === Za)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (r === $a)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (r === Qa)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (r === el)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (r === tl)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (r === nl)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (r === il)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (r === rl)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (r === sl)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (r === ol)
                return s === We
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
          if (r === al)
            if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
              if (r === al)
                return s === We
                  ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else return null;
          return r === _i
            ? n
              ? 34042
              : ((a = e.get("WEBGL_depth_texture")),
                a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
            : o[r] !== void 0
            ? o[r]
            : null;
        }
        return { convert: i };
      }
      class Rl extends pt {
        constructor(e = []) {
          super(), (this.cameras = e);
        }
      }
      Rl.prototype.isArrayCamera = !0;
      class rn extends Ne {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      rn.prototype.isGroup = !0;
      const Ry = { type: "move" };
      class ba {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new rn()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new rn()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new S()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new S())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new rn()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new S()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new S())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            s = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred")
            if (
              (a !== null &&
                ((i = t.getPose(e.targetRaySpace, n)),
                i !== null &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(Ry))),
              c && e.hand)
            ) {
              s = !0;
              for (const m of e.hand.values()) {
                const p = t.getJointPose(m, n);
                if (c.joints[m.jointName] === void 0) {
                  const y = new rn();
                  (y.matrixAutoUpdate = !1),
                    (y.visible = !1),
                    (c.joints[m.jointName] = y),
                    c.add(y);
                }
                const x = c.joints[m.jointName];
                p !== null &&
                  (x.matrix.fromArray(p.transform.matrix),
                  x.matrix.decompose(x.position, x.rotation, x.scale),
                  (x.jointRadius = p.radius)),
                  (x.visible = p !== null);
              }
              const u = c.joints["index-finger-tip"],
                h = c.joints["thumb-tip"],
                d = u.position.distanceTo(h.position),
                f = 0.02,
                g = 0.005;
              c.inputState.pinching && d > f + g
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  d <= f - g &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              l !== null &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                r !== null &&
                  (l.matrix.fromArray(r.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  r.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(r.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(r.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
          return (
            a !== null && (a.visible = i !== null),
            l !== null && (l.visible = r !== null),
            c !== null && (c.visible = s !== null),
            this
          );
        }
      }
      class Cl extends st {
        constructor(e, t, n, i, r, s, a, l, c, u) {
          if (((u = u !== void 0 ? u : zn), u !== zn && u !== wi))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && u === zn && (n = lr),
            n === void 0 && u === wi && (n = _i),
            super(null, i, r, s, a, l, u, n, c),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : at),
            (this.minFilter = l !== void 0 ? l : at),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      Cl.prototype.isDepthTexture = !0;
      class Cy extends Zn {
        constructor(e, t) {
          super();
          const n = this;
          let i = null,
            r = 1,
            s = null,
            a = "local-floor",
            l = null,
            c = null,
            u = null,
            h = null,
            d = null,
            f = null;
          const g = t.getContextAttributes();
          let m = null,
            p = null;
          const x = [],
            y = new Map(),
            v = new pt();
          v.layers.enable(1), (v.viewport = new Je());
          const M = new pt();
          M.layers.enable(2), (M.viewport = new Je());
          const b = [v, M],
            T = new Rl();
          T.layers.enable(1), T.layers.enable(2);
          let C = null,
            _ = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (z) {
              let q = x[z];
              return (
                q === void 0 && ((q = new ba()), (x[z] = q)),
                q.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (z) {
              let q = x[z];
              return (
                q === void 0 && ((q = new ba()), (x[z] = q)), q.getGripSpace()
              );
            }),
            (this.getHand = function (z) {
              let q = x[z];
              return (
                q === void 0 && ((q = new ba()), (x[z] = q)), q.getHandSpace()
              );
            });
          function R(z) {
            const q = y.get(z.inputSource);
            q && q.dispatchEvent({ type: z.type, data: z.inputSource });
          }
          function P() {
            y.forEach(function (z, q) {
              z.disconnect(q);
            }),
              y.clear(),
              (C = null),
              (_ = null),
              e.setRenderTarget(m),
              (d = null),
              (h = null),
              (u = null),
              (i = null),
              (p = null),
              J.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (z) {
            (r = z),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (z) {
              (a = z),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return l || s;
            }),
            (this.setReferenceSpace = function (z) {
              l = z;
            }),
            (this.getBaseLayer = function () {
              return h !== null ? h : d;
            }),
            (this.getBinding = function () {
              return u;
            }),
            (this.getFrame = function () {
              return f;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (z) {
              if (((i = z), i !== null)) {
                if (
                  ((m = e.getRenderTarget()),
                  i.addEventListener("select", R),
                  i.addEventListener("selectstart", R),
                  i.addEventListener("selectend", R),
                  i.addEventListener("squeeze", R),
                  i.addEventListener("squeezestart", R),
                  i.addEventListener("squeezeend", R),
                  i.addEventListener("end", P),
                  i.addEventListener("inputsourceschange", D),
                  g.xrCompatible !== !0 && (await t.makeXRCompatible()),
                  i.renderState.layers === void 0 ||
                    e.capabilities.isWebGL2 === !1)
                ) {
                  const q = {
                    antialias:
                      i.renderState.layers === void 0 ? g.antialias : !0,
                    alpha: g.alpha,
                    depth: g.depth,
                    stencil: g.stencil,
                    framebufferScaleFactor: r,
                  };
                  (d = new XRWebGLLayer(i, t, q)),
                    i.updateRenderState({ baseLayer: d }),
                    (p = new Tt(d.framebufferWidth, d.framebufferHeight, {
                      format: Dt,
                      type: Xn,
                      encoding: e.outputEncoding,
                    }));
                } else {
                  let q = null,
                    ee = null,
                    $ = null;
                  g.depth &&
                    (($ = g.stencil ? 35056 : 33190),
                    (q = g.stencil ? wi : zn),
                    (ee = g.stencil ? _i : lr));
                  const te = {
                    colorFormat: e.outputEncoding === We ? 35907 : 32856,
                    depthFormat: $,
                    scaleFactor: r,
                  };
                  (u = new XRWebGLBinding(i, t)),
                    (h = u.createProjectionLayer(te)),
                    i.updateRenderState({ layers: [h] }),
                    (p = new Tt(h.textureWidth, h.textureHeight, {
                      format: Dt,
                      type: Xn,
                      depthTexture: new Cl(
                        h.textureWidth,
                        h.textureHeight,
                        ee,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        q
                      ),
                      stencilBuffer: g.stencil,
                      encoding: e.outputEncoding,
                      samples: g.antialias ? 4 : 0,
                    }));
                  const xe = e.properties.get(p);
                  xe.__ignoreDepthValues = h.ignoreDepthValues;
                }
                (p.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (s = await i.requestReferenceSpace(a)),
                  J.setContext(i),
                  J.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          function D(z) {
            const q = i.inputSources;
            for (let ee = 0; ee < q.length; ee++) {
              const $ = q[ee].handedness === "right" ? 1 : 0;
              y.set(q[ee], x[$]);
            }
            for (let ee = 0; ee < z.removed.length; ee++) {
              const $ = z.removed[ee],
                te = y.get($);
              te &&
                (te.dispatchEvent({ type: "disconnected", data: $ }),
                y.delete($));
            }
            for (let ee = 0; ee < z.added.length; ee++) {
              const $ = z.added[ee],
                te = y.get($);
              te && te.dispatchEvent({ type: "connected", data: $ });
            }
          }
          const Z = new S(),
            j = new S();
          function I(z, q, ee) {
            Z.setFromMatrixPosition(q.matrixWorld),
              j.setFromMatrixPosition(ee.matrixWorld);
            const $ = Z.distanceTo(j),
              te = q.projectionMatrix.elements,
              xe = ee.projectionMatrix.elements,
              ye = te[14] / (te[10] - 1),
              k = te[14] / (te[10] + 1),
              qe = (te[9] + 1) / te[5],
              Se = (te[9] - 1) / te[5],
              Pe = (te[8] - 1) / te[0],
              se = (xe[8] + 1) / xe[0],
              ze = ye * Pe,
              K = ye * se,
              Y = $ / (-Pe + se),
              ie = Y * -Pe;
            q.matrixWorld.decompose(z.position, z.quaternion, z.scale),
              z.translateX(ie),
              z.translateZ(Y),
              z.matrixWorld.compose(z.position, z.quaternion, z.scale),
              z.matrixWorldInverse.copy(z.matrixWorld).invert();
            const me = ye + Y,
              ue = k + Y,
              Re = ze - ie,
              be = K + ($ - ie),
              ve = ((qe * k) / ue) * me,
              $e = ((Se * k) / ue) * me;
            z.projectionMatrix.makePerspective(Re, be, ve, $e, me, ue);
          }
          function U(z, q) {
            q === null
              ? z.matrixWorld.copy(z.matrix)
              : z.matrixWorld.multiplyMatrices(q.matrixWorld, z.matrix),
              z.matrixWorldInverse.copy(z.matrixWorld).invert();
          }
          (this.updateCamera = function (z) {
            if (i === null) return;
            (T.near = M.near = v.near = z.near),
              (T.far = M.far = v.far = z.far),
              (C !== T.near || _ !== T.far) &&
                (i.updateRenderState({ depthNear: T.near, depthFar: T.far }),
                (C = T.near),
                (_ = T.far));
            const q = z.parent,
              ee = T.cameras;
            U(T, q);
            for (let te = 0; te < ee.length; te++) U(ee[te], q);
            T.matrixWorld.decompose(T.position, T.quaternion, T.scale),
              z.position.copy(T.position),
              z.quaternion.copy(T.quaternion),
              z.scale.copy(T.scale),
              z.matrix.copy(T.matrix),
              z.matrixWorld.copy(T.matrixWorld);
            const $ = z.children;
            for (let te = 0, xe = $.length; te < xe; te++)
              $[te].updateMatrixWorld(!0);
            ee.length === 2
              ? I(T, v, M)
              : T.projectionMatrix.copy(v.projectionMatrix);
          }),
            (this.getCamera = function () {
              return T;
            }),
            (this.getFoveation = function () {
              if (h !== null) return h.fixedFoveation;
              if (d !== null) return d.fixedFoveation;
            }),
            (this.setFoveation = function (z) {
              h !== null && (h.fixedFoveation = z),
                d !== null &&
                  d.fixedFoveation !== void 0 &&
                  (d.fixedFoveation = z);
            });
          let N = null;
          function V(z, q) {
            if (((c = q.getViewerPose(l || s)), (f = q), c !== null)) {
              const $ = c.views;
              d !== null &&
                (e.setRenderTargetFramebuffer(p, d.framebuffer),
                e.setRenderTarget(p));
              let te = !1;
              $.length !== T.cameras.length &&
                ((T.cameras.length = 0), (te = !0));
              for (let xe = 0; xe < $.length; xe++) {
                const ye = $[xe];
                let k = null;
                if (d !== null) k = d.getViewport(ye);
                else {
                  const Se = u.getViewSubImage(h, ye);
                  (k = Se.viewport),
                    xe === 0 &&
                      (e.setRenderTargetTextures(
                        p,
                        Se.colorTexture,
                        h.ignoreDepthValues ? void 0 : Se.depthStencilTexture
                      ),
                      e.setRenderTarget(p));
                }
                const qe = b[xe];
                qe.matrix.fromArray(ye.transform.matrix),
                  qe.projectionMatrix.fromArray(ye.projectionMatrix),
                  qe.viewport.set(k.x, k.y, k.width, k.height),
                  xe === 0 && T.matrix.copy(qe.matrix),
                  te === !0 && T.cameras.push(qe);
              }
            }
            const ee = i.inputSources;
            for (let $ = 0; $ < x.length; $++) {
              const te = ee[$],
                xe = y.get(te);
              xe !== void 0 && xe.update(te, q, l || s);
            }
            N && N(z, q), (f = null);
          }
          const J = new Qh();
          J.setAnimationLoop(V),
            (this.setAnimationLoop = function (z) {
              N = z;
            }),
            (this.dispose = function () {});
        }
      }
      function Ly(o, e) {
        function t(m, p) {
          m.fogColor.value.copy(p.color),
            p.isFog
              ? ((m.fogNear.value = p.near), (m.fogFar.value = p.far))
              : p.isFogExp2 && (m.fogDensity.value = p.density);
        }
        function n(m, p, x, y, v) {
          p.isMeshBasicMaterial || p.isMeshLambertMaterial
            ? i(m, p)
            : p.isMeshToonMaterial
            ? (i(m, p), u(m, p))
            : p.isMeshPhongMaterial
            ? (i(m, p), c(m, p))
            : p.isMeshStandardMaterial
            ? (i(m, p), h(m, p), p.isMeshPhysicalMaterial && d(m, p, v))
            : p.isMeshMatcapMaterial
            ? (i(m, p), f(m, p))
            : p.isMeshDepthMaterial
            ? i(m, p)
            : p.isMeshDistanceMaterial
            ? (i(m, p), g(m, p))
            : p.isMeshNormalMaterial
            ? i(m, p)
            : p.isLineBasicMaterial
            ? (r(m, p), p.isLineDashedMaterial && s(m, p))
            : p.isPointsMaterial
            ? a(m, p, x, y)
            : p.isSpriteMaterial
            ? l(m, p)
            : p.isShadowMaterial
            ? (m.color.value.copy(p.color), (m.opacity.value = p.opacity))
            : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
        }
        function i(m, p) {
          (m.opacity.value = p.opacity),
            p.color && m.diffuse.value.copy(p.color),
            p.emissive &&
              m.emissive.value
                .copy(p.emissive)
                .multiplyScalar(p.emissiveIntensity),
            p.map && (m.map.value = p.map),
            p.alphaMap && (m.alphaMap.value = p.alphaMap),
            p.bumpMap &&
              ((m.bumpMap.value = p.bumpMap),
              (m.bumpScale.value = p.bumpScale),
              p.side === Ft && (m.bumpScale.value *= -1)),
            p.displacementMap &&
              ((m.displacementMap.value = p.displacementMap),
              (m.displacementScale.value = p.displacementScale),
              (m.displacementBias.value = p.displacementBias)),
            p.emissiveMap && (m.emissiveMap.value = p.emissiveMap),
            p.normalMap &&
              ((m.normalMap.value = p.normalMap),
              m.normalScale.value.copy(p.normalScale),
              p.side === Ft && m.normalScale.value.negate()),
            p.specularMap && (m.specularMap.value = p.specularMap),
            p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          const x = e.get(p).envMap;
          if (
            (x &&
              ((m.envMap.value = x),
              (m.flipEnvMap.value =
                x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
              (m.reflectivity.value = p.reflectivity),
              (m.ior.value = p.ior),
              (m.refractionRatio.value = p.refractionRatio)),
            p.lightMap)
          ) {
            m.lightMap.value = p.lightMap;
            const M = o.physicallyCorrectLights !== !0 ? Math.PI : 1;
            m.lightMapIntensity.value = p.lightMapIntensity * M;
          }
          p.aoMap &&
            ((m.aoMap.value = p.aoMap),
            (m.aoMapIntensity.value = p.aoMapIntensity));
          let y;
          p.map
            ? (y = p.map)
            : p.specularMap
            ? (y = p.specularMap)
            : p.displacementMap
            ? (y = p.displacementMap)
            : p.normalMap
            ? (y = p.normalMap)
            : p.bumpMap
            ? (y = p.bumpMap)
            : p.roughnessMap
            ? (y = p.roughnessMap)
            : p.metalnessMap
            ? (y = p.metalnessMap)
            : p.alphaMap
            ? (y = p.alphaMap)
            : p.emissiveMap
            ? (y = p.emissiveMap)
            : p.clearcoatMap
            ? (y = p.clearcoatMap)
            : p.clearcoatNormalMap
            ? (y = p.clearcoatNormalMap)
            : p.clearcoatRoughnessMap
            ? (y = p.clearcoatRoughnessMap)
            : p.specularIntensityMap
            ? (y = p.specularIntensityMap)
            : p.specularColorMap
            ? (y = p.specularColorMap)
            : p.transmissionMap
            ? (y = p.transmissionMap)
            : p.thicknessMap
            ? (y = p.thicknessMap)
            : p.sheenColorMap
            ? (y = p.sheenColorMap)
            : p.sheenRoughnessMap && (y = p.sheenRoughnessMap),
            y !== void 0 &&
              (y.isWebGLRenderTarget && (y = y.texture),
              y.matrixAutoUpdate === !0 && y.updateMatrix(),
              m.uvTransform.value.copy(y.matrix));
          let v;
          p.aoMap ? (v = p.aoMap) : p.lightMap && (v = p.lightMap),
            v !== void 0 &&
              (v.isWebGLRenderTarget && (v = v.texture),
              v.matrixAutoUpdate === !0 && v.updateMatrix(),
              m.uv2Transform.value.copy(v.matrix));
        }
        function r(m, p) {
          m.diffuse.value.copy(p.color), (m.opacity.value = p.opacity);
        }
        function s(m, p) {
          (m.dashSize.value = p.dashSize),
            (m.totalSize.value = p.dashSize + p.gapSize),
            (m.scale.value = p.scale);
        }
        function a(m, p, x, y) {
          m.diffuse.value.copy(p.color),
            (m.opacity.value = p.opacity),
            (m.size.value = p.size * x),
            (m.scale.value = y * 0.5),
            p.map && (m.map.value = p.map),
            p.alphaMap && (m.alphaMap.value = p.alphaMap),
            p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          let v;
          p.map ? (v = p.map) : p.alphaMap && (v = p.alphaMap),
            v !== void 0 &&
              (v.matrixAutoUpdate === !0 && v.updateMatrix(),
              m.uvTransform.value.copy(v.matrix));
        }
        function l(m, p) {
          m.diffuse.value.copy(p.color),
            (m.opacity.value = p.opacity),
            (m.rotation.value = p.rotation),
            p.map && (m.map.value = p.map),
            p.alphaMap && (m.alphaMap.value = p.alphaMap),
            p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          let x;
          p.map ? (x = p.map) : p.alphaMap && (x = p.alphaMap),
            x !== void 0 &&
              (x.matrixAutoUpdate === !0 && x.updateMatrix(),
              m.uvTransform.value.copy(x.matrix));
        }
        function c(m, p) {
          m.specular.value.copy(p.specular),
            (m.shininess.value = Math.max(p.shininess, 1e-4));
        }
        function u(m, p) {
          p.gradientMap && (m.gradientMap.value = p.gradientMap);
        }
        function h(m, p) {
          (m.roughness.value = p.roughness),
            (m.metalness.value = p.metalness),
            p.roughnessMap && (m.roughnessMap.value = p.roughnessMap),
            p.metalnessMap && (m.metalnessMap.value = p.metalnessMap),
            e.get(p).envMap && (m.envMapIntensity.value = p.envMapIntensity);
        }
        function d(m, p, x) {
          (m.ior.value = p.ior),
            p.sheen > 0 &&
              (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
              (m.sheenRoughness.value = p.sheenRoughness),
              p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap),
              p.sheenRoughnessMap &&
                (m.sheenRoughnessMap.value = p.sheenRoughnessMap)),
            p.clearcoat > 0 &&
              ((m.clearcoat.value = p.clearcoat),
              (m.clearcoatRoughness.value = p.clearcoatRoughness),
              p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap),
              p.clearcoatRoughnessMap &&
                (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
              p.clearcoatNormalMap &&
                (m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
                (m.clearcoatNormalMap.value = p.clearcoatNormalMap),
                p.side === Ft && m.clearcoatNormalScale.value.negate())),
            p.transmission > 0 &&
              ((m.transmission.value = p.transmission),
              (m.transmissionSamplerMap.value = x.texture),
              m.transmissionSamplerSize.value.set(x.width, x.height),
              p.transmissionMap &&
                (m.transmissionMap.value = p.transmissionMap),
              (m.thickness.value = p.thickness),
              p.thicknessMap && (m.thicknessMap.value = p.thicknessMap),
              (m.attenuationDistance.value = p.attenuationDistance),
              m.attenuationColor.value.copy(p.attenuationColor)),
            (m.specularIntensity.value = p.specularIntensity),
            m.specularColor.value.copy(p.specularColor),
            p.specularIntensityMap &&
              (m.specularIntensityMap.value = p.specularIntensityMap),
            p.specularColorMap &&
              (m.specularColorMap.value = p.specularColorMap);
        }
        function f(m, p) {
          p.matcap && (m.matcap.value = p.matcap);
        }
        function g(m, p) {
          m.referencePosition.value.copy(p.referencePosition),
            (m.nearDistance.value = p.nearDistance),
            (m.farDistance.value = p.farDistance);
        }
        return { refreshFogUniforms: t, refreshMaterialUniforms: n };
      }
      function Py() {
        const o = ss("canvas");
        return (o.style.display = "block"), o;
      }
      function Ke(o = {}) {
        const e = o.canvas !== void 0 ? o.canvas : Py(),
          t = o.context !== void 0 ? o.context : null,
          n = o.depth !== void 0 ? o.depth : !0,
          i = o.stencil !== void 0 ? o.stencil : !0,
          r = o.antialias !== void 0 ? o.antialias : !1,
          s = o.premultipliedAlpha !== void 0 ? o.premultipliedAlpha : !0,
          a = o.preserveDrawingBuffer !== void 0 ? o.preserveDrawingBuffer : !1,
          l = o.powerPreference !== void 0 ? o.powerPreference : "default",
          c =
            o.failIfMajorPerformanceCaveat !== void 0
              ? o.failIfMajorPerformanceCaveat
              : !1;
        let u;
        t !== null
          ? (u = t.getContextAttributes().alpha)
          : (u = o.alpha !== void 0 ? o.alpha : !1);
        let h = null,
          d = null;
        const f = [],
          g = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = Mn),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = sn),
          (this.toneMappingExposure = 1);
        const m = this;
        let p = !1,
          x = 0,
          y = 0,
          v = null,
          M = -1,
          b = null;
        const T = new Je(),
          C = new Je();
        let _ = null,
          R = e.width,
          P = e.height,
          D = 1,
          Z = null,
          j = null;
        const I = new Je(0, 0, R, P),
          U = new Je(0, 0, R, P);
        let N = !1;
        const V = new ps();
        let J = !1,
          z = !1,
          q = null;
        const ee = new fe(),
          $ = new W(),
          te = new S(),
          xe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function ye() {
          return v === null ? D : 1;
        }
        let k = t;
        function qe(E, F) {
          for (let O = 0; O < E.length; O++) {
            const B = E[O],
              X = e.getContext(B, F);
            if (X !== null) return X;
          }
          return null;
        }
        try {
          const E = {
            alpha: !0,
            depth: n,
            stencil: i,
            antialias: r,
            premultipliedAlpha: s,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c,
          };
          if (
            ("setAttribute" in e &&
              e.setAttribute("data-engine", `three.js r${So}`),
            e.addEventListener("webglcontextlost", L, !1),
            e.addEventListener("webglcontextrestored", le, !1),
            k === null)
          ) {
            const F = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (m.isWebGL1Renderer === !0 && F.shift(),
              (k = qe(F, E)),
              k === null)
            )
              throw qe(F)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          k.getShaderPrecisionFormat === void 0 &&
            (k.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (E) {
          throw (console.error("THREE.WebGLRenderer: " + E.message), E);
        }
        let Se,
          Pe,
          se,
          ze,
          K,
          Y,
          ie,
          me,
          ue,
          Re,
          be,
          ve,
          $e,
          Ze,
          A,
          w,
          H,
          Q,
          ce,
          he,
          Me,
          G,
          Le;
        function De() {
          (Se = new jg(k)),
            (Pe = new Vg(k, Se, o)),
            Se.init(Pe),
            (G = new ad(k, Se, Pe)),
            (se = new Ey(k, Se, Pe)),
            (ze = new $g(k)),
            (K = new my()),
            (Y = new Ay(k, Se, se, K, Pe, G, ze)),
            (ie = new qg(m)),
            (me = new Yg(m)),
            (ue = new dp(k, Pe)),
            (Le = new Gg(k, Se, ue, Pe)),
            (Re = new Kg(k, ue, ze, Le)),
            (be = new nx(k, Re, ue, ze)),
            (ce = new tx(k, Pe, Y)),
            (w = new Wg(K)),
            (ve = new py(m, ie, me, Se, Pe, Le, w)),
            ($e = new Ly(m, K)),
            (Ze = new xy()),
            (A = new wy(Se, Pe)),
            (Q = new Hg(m, ie, se, be, u, s)),
            (H = new od(m, be, Pe)),
            (he = new kg(k, Se, ze, Pe)),
            (Me = new Zg(k, Se, ze, Pe)),
            (ze.programs = ve.programs),
            (m.capabilities = Pe),
            (m.extensions = Se),
            (m.properties = K),
            (m.renderLists = Ze),
            (m.shadowMap = H),
            (m.state = se),
            (m.info = ze);
        }
        De();
        const ge = new Cy(m, k);
        (this.xr = ge),
          (this.getContext = function () {
            return k;
          }),
          (this.getContextAttributes = function () {
            return k.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const E = Se.get("WEBGL_lose_context");
            E && E.loseContext();
          }),
          (this.forceContextRestore = function () {
            const E = Se.get("WEBGL_lose_context");
            E && E.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return D;
          }),
          (this.setPixelRatio = function (E) {
            E !== void 0 && ((D = E), this.setSize(R, P, !1));
          }),
          (this.getSize = function (E) {
            return E.set(R, P);
          }),
          (this.setSize = function (E, F, O) {
            if (ge.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (R = E),
              (P = F),
              (e.width = Math.floor(E * D)),
              (e.height = Math.floor(F * D)),
              O !== !1 &&
                ((e.style.width = E + "px"), (e.style.height = F + "px")),
              this.setViewport(0, 0, E, F);
          }),
          (this.getDrawingBufferSize = function (E) {
            return E.set(R * D, P * D).floor();
          }),
          (this.setDrawingBufferSize = function (E, F, O) {
            (R = E),
              (P = F),
              (D = O),
              (e.width = Math.floor(E * O)),
              (e.height = Math.floor(F * O)),
              this.setViewport(0, 0, E, F);
          }),
          (this.getCurrentViewport = function (E) {
            return E.copy(T);
          }),
          (this.getViewport = function (E) {
            return E.copy(I);
          }),
          (this.setViewport = function (E, F, O, B) {
            E.isVector4 ? I.set(E.x, E.y, E.z, E.w) : I.set(E, F, O, B),
              se.viewport(T.copy(I).multiplyScalar(D).floor());
          }),
          (this.getScissor = function (E) {
            return E.copy(U);
          }),
          (this.setScissor = function (E, F, O, B) {
            E.isVector4 ? U.set(E.x, E.y, E.z, E.w) : U.set(E, F, O, B),
              se.scissor(C.copy(U).multiplyScalar(D).floor());
          }),
          (this.getScissorTest = function () {
            return N;
          }),
          (this.setScissorTest = function (E) {
            se.setScissorTest((N = E));
          }),
          (this.setOpaqueSort = function (E) {
            Z = E;
          }),
          (this.setTransparentSort = function (E) {
            j = E;
          }),
          (this.getClearColor = function (E) {
            return E.copy(Q.getClearColor());
          }),
          (this.setClearColor = function () {
            Q.setClearColor.apply(Q, arguments);
          }),
          (this.getClearAlpha = function () {
            return Q.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            Q.setClearAlpha.apply(Q, arguments);
          }),
          (this.clear = function (E = !0, F = !0, O = !0) {
            let B = 0;
            E && (B |= 16384), F && (B |= 256), O && (B |= 1024), k.clear(B);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", L, !1),
              e.removeEventListener("webglcontextrestored", le, !1),
              Ze.dispose(),
              A.dispose(),
              K.dispose(),
              ie.dispose(),
              me.dispose(),
              be.dispose(),
              Le.dispose(),
              ve.dispose(),
              ge.dispose(),
              ge.removeEventListener("sessionstart", Ee),
              ge.removeEventListener("sessionend", Ye),
              q && (q.dispose(), (q = null)),
              He.stop();
          });
        function L(E) {
          E.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (p = !0);
        }
        function le() {
          console.log("THREE.WebGLRenderer: Context Restored."), (p = !1);
          const E = ze.autoReset,
            F = H.enabled,
            O = H.autoUpdate,
            B = H.needsUpdate,
            X = H.type;
          De(),
            (ze.autoReset = E),
            (H.enabled = F),
            (H.autoUpdate = O),
            (H.needsUpdate = B),
            (H.type = X);
        }
        function oe(E) {
          const F = E.target;
          F.removeEventListener("dispose", oe), Te(F);
        }
        function Te(E) {
          de(E), K.remove(E);
        }
        function de(E) {
          const F = K.get(E).programs;
          F !== void 0 &&
            (F.forEach(function (O) {
              ve.releaseProgram(O);
            }),
            E.isShaderMaterial && ve.releaseShaderCache(E));
        }
        (this.renderBufferDirect = function (E, F, O, B, X, Ae) {
          F === null && (F = xe);
          const Ce = X.isMesh && X.matrixWorld.determinant() < 0,
            Fe = $d(E, F, O, B, X);
          se.setMaterial(B, Ce);
          let Ie = O.index;
          const je = O.attributes.position;
          if (Ie === null) {
            if (je === void 0 || je.count === 0) return;
          } else if (Ie.count === 0) return;
          let ke = 1;
          B.wireframe === !0 && ((Ie = Re.getWireframeAttribute(O)), (ke = 2)),
            Le.setup(X, B, Fe, O, Ie);
          let Ve,
            it = he;
          Ie !== null && ((Ve = ue.get(Ie)), (it = Me), it.setIndex(Ve));
          const ii = Ie !== null ? Ie.count : je.count,
            Ni = O.drawRange.start * ke,
            Oi = O.drawRange.count * ke,
            $t = Ae !== null ? Ae.start * ke : 0,
            Xe = Ae !== null ? Ae.count * ke : 1 / 0,
            Ui = Math.max(Ni, $t),
            ht = Math.min(ii, Ni + Oi, $t + Xe) - 1,
            Qt = Math.max(0, ht - Ui + 1);
          if (Qt !== 0) {
            if (X.isMesh)
              B.wireframe === !0
                ? (se.setLineWidth(B.wireframeLinewidth * ye()), it.setMode(1))
                : it.setMode(4);
            else if (X.isLine) {
              let An = B.linewidth;
              An === void 0 && (An = 1),
                se.setLineWidth(An * ye()),
                X.isLineSegments
                  ? it.setMode(1)
                  : X.isLineLoop
                  ? it.setMode(2)
                  : it.setMode(3);
            } else X.isPoints ? it.setMode(0) : X.isSprite && it.setMode(4);
            if (X.isInstancedMesh) it.renderInstances(Ui, Qt, X.count);
            else if (O.isInstancedBufferGeometry) {
              const An = Math.min(O.instanceCount, O._maxInstanceCount);
              it.renderInstances(Ui, Qt, An);
            } else it.render(Ui, Qt);
          }
        }),
          (this.compile = function (E, F) {
            (d = A.get(E)),
              d.init(),
              g.push(d),
              E.traverseVisible(function (O) {
                O.isLight &&
                  O.layers.test(F.layers) &&
                  (d.pushLight(O), O.castShadow && d.pushShadow(O));
              }),
              d.setupLights(m.physicallyCorrectLights),
              E.traverse(function (O) {
                const B = O.material;
                if (B)
                  if (Array.isArray(B))
                    for (let X = 0; X < B.length; X++) {
                      const Ae = B[X];
                      Yo(Ae, E, O);
                    }
                  else Yo(B, E, O);
              }),
              g.pop(),
              (d = null);
          });
        let we = null;
        function re(E) {
          we && we(E);
        }
        function Ee() {
          He.stop();
        }
        function Ye() {
          He.start();
        }
        const He = new Qh();
        He.setAnimationLoop(re),
          typeof self != "undefined" && He.setContext(self),
          (this.setAnimationLoop = function (E) {
            (we = E),
              ge.setAnimationLoop(E),
              E === null ? He.stop() : He.start();
          }),
          ge.addEventListener("sessionstart", Ee),
          ge.addEventListener("sessionend", Ye),
          (this.render = function (E, F) {
            if (F !== void 0 && F.isCamera !== !0) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (p === !0) return;
            E.autoUpdate === !0 && E.updateMatrixWorld(),
              F.parent === null && F.updateMatrixWorld(),
              ge.enabled === !0 &&
                ge.isPresenting === !0 &&
                (ge.cameraAutoUpdate === !0 && ge.updateCamera(F),
                (F = ge.getCamera())),
              E.isScene === !0 && E.onBeforeRender(m, E, F, v),
              (d = A.get(E, g.length)),
              d.init(),
              g.push(d),
              ee.multiplyMatrices(F.projectionMatrix, F.matrixWorldInverse),
              V.setFromProjectionMatrix(ee),
              (z = this.localClippingEnabled),
              (J = w.init(this.clippingPlanes, z, F)),
              (h = Ze.get(E, f.length)),
              h.init(),
              f.push(h),
              Kt(E, F, 0, m.sortObjects),
              h.finish(),
              m.sortObjects === !0 && h.sort(Z, j),
              J === !0 && w.beginShadows();
            const O = d.state.shadowsArray;
            if (
              (H.render(O, E, F),
              J === !0 && w.endShadows(),
              this.info.autoReset === !0 && this.info.reset(),
              Q.render(h, E),
              d.setupLights(m.physicallyCorrectLights),
              F.isArrayCamera)
            ) {
              const B = F.cameras;
              for (let X = 0, Ae = B.length; X < Ae; X++) {
                const Ce = B[X];
                Zt(h, E, Ce, Ce.viewport);
              }
            } else Zt(h, E, F);
            v !== null &&
              (Y.updateMultisampleRenderTarget(v),
              Y.updateRenderTargetMipmap(v)),
              E.isScene === !0 && E.onAfterRender(m, E, F),
              Le.resetDefaultState(),
              (M = -1),
              (b = null),
              g.pop(),
              g.length > 0 ? (d = g[g.length - 1]) : (d = null),
              f.pop(),
              f.length > 0 ? (h = f[f.length - 1]) : (h = null);
          });
        function Kt(E, F, O, B) {
          if (E.visible === !1) return;
          if (E.layers.test(F.layers)) {
            if (E.isGroup) O = E.renderOrder;
            else if (E.isLOD) E.autoUpdate === !0 && E.update(F);
            else if (E.isLight) d.pushLight(E), E.castShadow && d.pushShadow(E);
            else if (E.isSprite) {
              if (!E.frustumCulled || V.intersectsSprite(E)) {
                B && te.setFromMatrixPosition(E.matrixWorld).applyMatrix4(ee);
                const Ce = be.update(E),
                  Fe = E.material;
                Fe.visible && h.push(E, Ce, Fe, O, te.z, null);
              }
            } else if (
              (E.isMesh || E.isLine || E.isPoints) &&
              (E.isSkinnedMesh &&
                E.skeleton.frame !== ze.render.frame &&
                (E.skeleton.update(), (E.skeleton.frame = ze.render.frame)),
              !E.frustumCulled || V.intersectsObject(E))
            ) {
              B && te.setFromMatrixPosition(E.matrixWorld).applyMatrix4(ee);
              const Ce = be.update(E),
                Fe = E.material;
              if (Array.isArray(Fe)) {
                const Ie = Ce.groups;
                for (let je = 0, ke = Ie.length; je < ke; je++) {
                  const Ve = Ie[je],
                    it = Fe[Ve.materialIndex];
                  it && it.visible && h.push(E, Ce, it, O, te.z, Ve);
                }
              } else Fe.visible && h.push(E, Ce, Fe, O, te.z, null);
            }
          }
          const Ae = E.children;
          for (let Ce = 0, Fe = Ae.length; Ce < Fe; Ce++) Kt(Ae[Ce], F, O, B);
        }
        function Zt(E, F, O, B) {
          const X = E.opaque,
            Ae = E.transmissive,
            Ce = E.transparent;
          d.setupLightsView(O),
            Ae.length > 0 && Kd(X, F, O),
            B && se.viewport(T.copy(B)),
            X.length > 0 && Ts(X, F, O),
            Ae.length > 0 && Ts(Ae, F, O),
            Ce.length > 0 && Ts(Ce, F, O),
            se.buffers.depth.setTest(!0),
            se.buffers.depth.setMask(!0),
            se.buffers.color.setMask(!0),
            se.setPolygonOffset(!1);
        }
        function Kd(E, F, O) {
          const B = Pe.isWebGL2;
          q === null &&
            (q = new Tt(1, 1, {
              generateMipmaps: !0,
              type: Se.has("EXT_color_buffer_half_float") ? cr : Xn,
              minFilter: Sn,
              samples: B && r === !0 ? 4 : 0,
            })),
            m.getDrawingBufferSize($),
            B ? q.setSize($.x, $.y) : q.setSize(wo($.x), wo($.y));
          const X = m.getRenderTarget();
          m.setRenderTarget(q), m.clear();
          const Ae = m.toneMapping;
          (m.toneMapping = sn),
            Ts(E, F, O),
            (m.toneMapping = Ae),
            Y.updateMultisampleRenderTarget(q),
            Y.updateRenderTargetMipmap(q),
            m.setRenderTarget(X);
        }
        function Ts(E, F, O) {
          const B = F.isScene === !0 ? F.overrideMaterial : null;
          for (let X = 0, Ae = E.length; X < Ae; X++) {
            const Ce = E[X],
              Fe = Ce.object,
              Ie = Ce.geometry,
              je = B === null ? Ce.material : B,
              ke = Ce.group;
            Fe.layers.test(O.layers) && Zd(Fe, F, O, Ie, je, ke);
          }
        }
        function Zd(E, F, O, B, X, Ae) {
          E.onBeforeRender(m, F, O, B, X, Ae),
            E.modelViewMatrix.multiplyMatrices(
              O.matrixWorldInverse,
              E.matrixWorld
            ),
            E.normalMatrix.getNormalMatrix(E.modelViewMatrix),
            X.onBeforeRender(m, F, O, B, E, Ae),
            X.transparent === !0 && X.side === kn
              ? ((X.side = Ft),
                (X.needsUpdate = !0),
                m.renderBufferDirect(O, F, B, X, E, Ae),
                (X.side = Gn),
                (X.needsUpdate = !0),
                m.renderBufferDirect(O, F, B, X, E, Ae),
                (X.side = kn))
              : m.renderBufferDirect(O, F, B, X, E, Ae),
            E.onAfterRender(m, F, O, B, X, Ae);
        }
        function Yo(E, F, O) {
          F.isScene !== !0 && (F = xe);
          const B = K.get(E),
            X = d.state.lights,
            Ae = d.state.shadowsArray,
            Ce = X.state.version,
            Fe = ve.getParameters(E, X.state, Ae, F, O),
            Ie = ve.getProgramCacheKey(Fe);
          let je = B.programs;
          (B.environment = E.isMeshStandardMaterial ? F.environment : null),
            (B.fog = F.fog),
            (B.envMap = (E.isMeshStandardMaterial ? me : ie).get(
              E.envMap || B.environment
            )),
            je === void 0 &&
              (E.addEventListener("dispose", oe),
              (je = new Map()),
              (B.programs = je));
          let ke = je.get(Ie);
          if (ke !== void 0) {
            if (B.currentProgram === ke && B.lightsStateVersion === Ce)
              return lc(E, Fe), ke;
          } else
            (Fe.uniforms = ve.getUniforms(E)),
              E.onBuild(O, Fe, m),
              E.onBeforeCompile(Fe, m),
              (ke = ve.acquireProgram(Fe, Ie)),
              je.set(Ie, ke),
              (B.uniforms = Fe.uniforms);
          const Ve = B.uniforms;
          ((!E.isShaderMaterial && !E.isRawShaderMaterial) ||
            E.clipping === !0) &&
            (Ve.clippingPlanes = w.uniform),
            lc(E, Fe),
            (B.needsLights = ef(E)),
            (B.lightsStateVersion = Ce),
            B.needsLights &&
              ((Ve.ambientLightColor.value = X.state.ambient),
              (Ve.lightProbe.value = X.state.probe),
              (Ve.directionalLights.value = X.state.directional),
              (Ve.directionalLightShadows.value = X.state.directionalShadow),
              (Ve.spotLights.value = X.state.spot),
              (Ve.spotLightShadows.value = X.state.spotShadow),
              (Ve.rectAreaLights.value = X.state.rectArea),
              (Ve.ltc_1.value = X.state.rectAreaLTC1),
              (Ve.ltc_2.value = X.state.rectAreaLTC2),
              (Ve.pointLights.value = X.state.point),
              (Ve.pointLightShadows.value = X.state.pointShadow),
              (Ve.hemisphereLights.value = X.state.hemi),
              (Ve.directionalShadowMap.value = X.state.directionalShadowMap),
              (Ve.directionalShadowMatrix.value =
                X.state.directionalShadowMatrix),
              (Ve.spotShadowMap.value = X.state.spotShadowMap),
              (Ve.spotShadowMatrix.value = X.state.spotShadowMatrix),
              (Ve.pointShadowMap.value = X.state.pointShadowMap),
              (Ve.pointShadowMatrix.value = X.state.pointShadowMatrix));
          const it = ke.getUniforms(),
            ii = Hn.seqWithValue(it.seq, Ve);
          return (B.currentProgram = ke), (B.uniformsList = ii), ke;
        }
        function lc(E, F) {
          const O = K.get(E);
          (O.outputEncoding = F.outputEncoding),
            (O.instancing = F.instancing),
            (O.skinning = F.skinning),
            (O.morphTargets = F.morphTargets),
            (O.morphNormals = F.morphNormals),
            (O.morphColors = F.morphColors),
            (O.morphTargetsCount = F.morphTargetsCount),
            (O.numClippingPlanes = F.numClippingPlanes),
            (O.numIntersection = F.numClipIntersection),
            (O.vertexAlphas = F.vertexAlphas),
            (O.vertexTangents = F.vertexTangents),
            (O.toneMapping = F.toneMapping);
        }
        function $d(E, F, O, B, X) {
          F.isScene !== !0 && (F = xe), Y.resetTextureUnits();
          const Ae = F.fog,
            Ce = B.isMeshStandardMaterial ? F.environment : null,
            Fe =
              v === null
                ? m.outputEncoding
                : v.isXRRenderTarget === !0
                ? v.texture.encoding
                : Mn,
            Ie = (B.isMeshStandardMaterial ? me : ie).get(B.envMap || Ce),
            je =
              B.vertexColors === !0 &&
              !!O.attributes.color &&
              O.attributes.color.itemSize === 4,
            ke = !!B.normalMap && !!O.attributes.tangent,
            Ve = !!O.morphAttributes.position,
            it = !!O.morphAttributes.normal,
            ii = !!O.morphAttributes.color,
            Ni = B.toneMapped ? m.toneMapping : sn,
            Oi =
              O.morphAttributes.position ||
              O.morphAttributes.normal ||
              O.morphAttributes.color,
            $t = Oi !== void 0 ? Oi.length : 0,
            Xe = K.get(B),
            Ui = d.state.lights;
          if (J === !0 && (z === !0 || E !== b)) {
            const en = E === b && B.id === M;
            w.setState(B, E, en);
          }
          let ht = !1;
          B.version === Xe.__version
            ? ((Xe.needsLights && Xe.lightsStateVersion !== Ui.state.version) ||
                Xe.outputEncoding !== Fe ||
                (X.isInstancedMesh && Xe.instancing === !1) ||
                (!X.isInstancedMesh && Xe.instancing === !0) ||
                (X.isSkinnedMesh && Xe.skinning === !1) ||
                (!X.isSkinnedMesh && Xe.skinning === !0) ||
                Xe.envMap !== Ie ||
                (B.fog === !0 && Xe.fog !== Ae) ||
                (Xe.numClippingPlanes !== void 0 &&
                  (Xe.numClippingPlanes !== w.numPlanes ||
                    Xe.numIntersection !== w.numIntersection)) ||
                Xe.vertexAlphas !== je ||
                Xe.vertexTangents !== ke ||
                Xe.morphTargets !== Ve ||
                Xe.morphNormals !== it ||
                Xe.morphColors !== ii ||
                Xe.toneMapping !== Ni ||
                (Pe.isWebGL2 === !0 && Xe.morphTargetsCount !== $t)) &&
              (ht = !0)
            : ((ht = !0), (Xe.__version = B.version));
          let Qt = Xe.currentProgram;
          ht === !0 && (Qt = Yo(B, F, X));
          let An = !1,
            Nr = !1,
            jo = !1;
          const wt = Qt.getUniforms(),
            Or = Xe.uniforms;
          if (
            (se.useProgram(Qt.program) && ((An = !0), (Nr = !0), (jo = !0)),
            B.id !== M && ((M = B.id), (Nr = !0)),
            An || b !== E)
          ) {
            if (
              (wt.setValue(k, "projectionMatrix", E.projectionMatrix),
              Pe.logarithmicDepthBuffer &&
                wt.setValue(
                  k,
                  "logDepthBufFC",
                  2 / (Math.log(E.far + 1) / Math.LN2)
                ),
              b !== E && ((b = E), (Nr = !0), (jo = !0)),
              B.isShaderMaterial ||
                B.isMeshPhongMaterial ||
                B.isMeshToonMaterial ||
                B.isMeshStandardMaterial ||
                B.envMap)
            ) {
              const en = wt.map.cameraPosition;
              en !== void 0 &&
                en.setValue(k, te.setFromMatrixPosition(E.matrixWorld));
            }
            (B.isMeshPhongMaterial ||
              B.isMeshToonMaterial ||
              B.isMeshLambertMaterial ||
              B.isMeshBasicMaterial ||
              B.isMeshStandardMaterial ||
              B.isShaderMaterial) &&
              wt.setValue(k, "isOrthographic", E.isOrthographicCamera === !0),
              (B.isMeshPhongMaterial ||
                B.isMeshToonMaterial ||
                B.isMeshLambertMaterial ||
                B.isMeshBasicMaterial ||
                B.isMeshStandardMaterial ||
                B.isShaderMaterial ||
                B.isShadowMaterial ||
                X.isSkinnedMesh) &&
                wt.setValue(k, "viewMatrix", E.matrixWorldInverse);
          }
          if (X.isSkinnedMesh) {
            wt.setOptional(k, X, "bindMatrix"),
              wt.setOptional(k, X, "bindMatrixInverse");
            const en = X.skeleton;
            en &&
              (Pe.floatVertexTextures
                ? (en.boneTexture === null && en.computeBoneTexture(),
                  wt.setValue(k, "boneTexture", en.boneTexture, Y),
                  wt.setValue(k, "boneTextureSize", en.boneTextureSize))
                : console.warn(
                    "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                  ));
          }
          const Ko = O.morphAttributes;
          return (
            (Ko.position !== void 0 ||
              Ko.normal !== void 0 ||
              (Ko.color !== void 0 && Pe.isWebGL2 === !0)) &&
              ce.update(X, O, B, Qt),
            (Nr || Xe.receiveShadow !== X.receiveShadow) &&
              ((Xe.receiveShadow = X.receiveShadow),
              wt.setValue(k, "receiveShadow", X.receiveShadow)),
            Nr &&
              (wt.setValue(k, "toneMappingExposure", m.toneMappingExposure),
              Xe.needsLights && Qd(Or, jo),
              Ae && B.fog === !0 && $e.refreshFogUniforms(Or, Ae),
              $e.refreshMaterialUniforms(Or, B, D, P, q),
              Hn.upload(k, Xe.uniformsList, Or, Y)),
            B.isShaderMaterial &&
              B.uniformsNeedUpdate === !0 &&
              (Hn.upload(k, Xe.uniformsList, Or, Y),
              (B.uniformsNeedUpdate = !1)),
            B.isSpriteMaterial && wt.setValue(k, "center", X.center),
            wt.setValue(k, "modelViewMatrix", X.modelViewMatrix),
            wt.setValue(k, "normalMatrix", X.normalMatrix),
            wt.setValue(k, "modelMatrix", X.matrixWorld),
            Qt
          );
        }
        function Qd(E, F) {
          (E.ambientLightColor.needsUpdate = F),
            (E.lightProbe.needsUpdate = F),
            (E.directionalLights.needsUpdate = F),
            (E.directionalLightShadows.needsUpdate = F),
            (E.pointLights.needsUpdate = F),
            (E.pointLightShadows.needsUpdate = F),
            (E.spotLights.needsUpdate = F),
            (E.spotLightShadows.needsUpdate = F),
            (E.rectAreaLights.needsUpdate = F),
            (E.hemisphereLights.needsUpdate = F);
        }
        function ef(E) {
          return (
            E.isMeshLambertMaterial ||
            E.isMeshToonMaterial ||
            E.isMeshPhongMaterial ||
            E.isMeshStandardMaterial ||
            E.isShadowMaterial ||
            (E.isShaderMaterial && E.lights === !0)
          );
        }
        (this.getActiveCubeFace = function () {
          return x;
        }),
          (this.getActiveMipmapLevel = function () {
            return y;
          }),
          (this.getRenderTarget = function () {
            return v;
          }),
          (this.setRenderTargetTextures = function (E, F, O) {
            (K.get(E.texture).__webglTexture = F),
              (K.get(E.depthTexture).__webglTexture = O);
            const B = K.get(E);
            (B.__hasExternalTextures = !0),
              B.__hasExternalTextures &&
                ((B.__autoAllocateDepthBuffer = O === void 0),
                B.__autoAllocateDepthBuffer ||
                  (Se.has("WEBGL_multisampled_render_to_texture") === !0 &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (B.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (E, F) {
            const O = K.get(E);
            (O.__webglFramebuffer = F),
              (O.__useDefaultFramebuffer = F === void 0);
          }),
          (this.setRenderTarget = function (E, F = 0, O = 0) {
            (v = E), (x = F), (y = O);
            let B = !0;
            if (E) {
              const Ie = K.get(E);
              Ie.__useDefaultFramebuffer !== void 0
                ? (se.bindFramebuffer(36160, null), (B = !1))
                : Ie.__webglFramebuffer === void 0
                ? Y.setupRenderTarget(E)
                : Ie.__hasExternalTextures &&
                  Y.rebindTextures(
                    E,
                    K.get(E.texture).__webglTexture,
                    K.get(E.depthTexture).__webglTexture
                  );
            }
            let X = null,
              Ae = !1,
              Ce = !1;
            if (E) {
              const Ie = E.texture;
              (Ie.isData3DTexture || Ie.isDataArrayTexture) && (Ce = !0);
              const je = K.get(E).__webglFramebuffer;
              E.isWebGLCubeRenderTarget
                ? ((X = je[F]), (Ae = !0))
                : Pe.isWebGL2 && E.samples > 0 && Y.useMultisampledRTT(E) === !1
                ? (X = K.get(E).__webglMultisampledFramebuffer)
                : (X = je),
                T.copy(E.viewport),
                C.copy(E.scissor),
                (_ = E.scissorTest);
            } else
              T.copy(I).multiplyScalar(D).floor(),
                C.copy(U).multiplyScalar(D).floor(),
                (_ = N);
            if (
              (se.bindFramebuffer(36160, X) &&
                Pe.drawBuffers &&
                B &&
                se.drawBuffers(E, X),
              se.viewport(T),
              se.scissor(C),
              se.setScissorTest(_),
              Ae)
            ) {
              const Ie = K.get(E.texture);
              k.framebufferTexture2D(
                36160,
                36064,
                34069 + F,
                Ie.__webglTexture,
                O
              );
            } else if (Ce) {
              const Ie = K.get(E.texture),
                je = F || 0;
              k.framebufferTextureLayer(
                36160,
                36064,
                Ie.__webglTexture,
                O || 0,
                je
              );
            }
            M = -1;
          }),
          (this.readRenderTargetPixels = function (E, F, O, B, X, Ae, Ce) {
            if (!(E && E.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let Fe = K.get(E).__webglFramebuffer;
            if (
              (E.isWebGLCubeRenderTarget && Ce !== void 0 && (Fe = Fe[Ce]), Fe)
            ) {
              se.bindFramebuffer(36160, Fe);
              try {
                const Ie = E.texture,
                  je = Ie.format,
                  ke = Ie.type;
                if (je !== Dt && G.convert(je) !== k.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                const Ve =
                  ke === cr &&
                  (Se.has("EXT_color_buffer_half_float") ||
                    (Pe.isWebGL2 && Se.has("EXT_color_buffer_float")));
                if (
                  ke !== Xn &&
                  G.convert(ke) !== k.getParameter(35738) &&
                  !(
                    ke === _n &&
                    (Pe.isWebGL2 ||
                      Se.has("OES_texture_float") ||
                      Se.has("WEBGL_color_buffer_float"))
                  ) &&
                  !Ve
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                F >= 0 &&
                  F <= E.width - B &&
                  O >= 0 &&
                  O <= E.height - X &&
                  k.readPixels(F, O, B, X, G.convert(je), G.convert(ke), Ae);
              } finally {
                const Ie = v !== null ? K.get(v).__webglFramebuffer : null;
                se.bindFramebuffer(36160, Ie);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (E, F, O = 0) {
            if (F.isFramebufferTexture !== !0) {
              console.error(
                "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
              );
              return;
            }
            const B = Math.pow(2, -O),
              X = Math.floor(F.image.width * B),
              Ae = Math.floor(F.image.height * B);
            Y.setTexture2D(F, 0),
              k.copyTexSubImage2D(3553, O, 0, 0, E.x, E.y, X, Ae),
              se.unbindTexture();
          }),
          (this.copyTextureToTexture = function (E, F, O, B = 0) {
            const X = F.image.width,
              Ae = F.image.height,
              Ce = G.convert(O.format),
              Fe = G.convert(O.type);
            Y.setTexture2D(O, 0),
              k.pixelStorei(37440, O.flipY),
              k.pixelStorei(37441, O.premultiplyAlpha),
              k.pixelStorei(3317, O.unpackAlignment),
              F.isDataTexture
                ? k.texSubImage2D(
                    3553,
                    B,
                    E.x,
                    E.y,
                    X,
                    Ae,
                    Ce,
                    Fe,
                    F.image.data
                  )
                : F.isCompressedTexture
                ? k.compressedTexSubImage2D(
                    3553,
                    B,
                    E.x,
                    E.y,
                    F.mipmaps[0].width,
                    F.mipmaps[0].height,
                    Ce,
                    F.mipmaps[0].data
                  )
                : k.texSubImage2D(3553, B, E.x, E.y, Ce, Fe, F.image),
              B === 0 && O.generateMipmaps && k.generateMipmap(3553),
              se.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (E, F, O, B, X = 0) {
            if (m.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            const Ae = E.max.x - E.min.x + 1,
              Ce = E.max.y - E.min.y + 1,
              Fe = E.max.z - E.min.z + 1,
              Ie = G.convert(B.format),
              je = G.convert(B.type);
            let ke;
            if (B.isData3DTexture) Y.setTexture3D(B, 0), (ke = 32879);
            else if (B.isDataArrayTexture)
              Y.setTexture2DArray(B, 0), (ke = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            k.pixelStorei(37440, B.flipY),
              k.pixelStorei(37441, B.premultiplyAlpha),
              k.pixelStorei(3317, B.unpackAlignment);
            const Ve = k.getParameter(3314),
              it = k.getParameter(32878),
              ii = k.getParameter(3316),
              Ni = k.getParameter(3315),
              Oi = k.getParameter(32877),
              $t = O.isCompressedTexture ? O.mipmaps[0] : O.image;
            k.pixelStorei(3314, $t.width),
              k.pixelStorei(32878, $t.height),
              k.pixelStorei(3316, E.min.x),
              k.pixelStorei(3315, E.min.y),
              k.pixelStorei(32877, E.min.z),
              O.isDataTexture || O.isData3DTexture
                ? k.texSubImage3D(
                    ke,
                    X,
                    F.x,
                    F.y,
                    F.z,
                    Ae,
                    Ce,
                    Fe,
                    Ie,
                    je,
                    $t.data
                  )
                : O.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  k.compressedTexSubImage3D(
                    ke,
                    X,
                    F.x,
                    F.y,
                    F.z,
                    Ae,
                    Ce,
                    Fe,
                    Ie,
                    $t.data
                  ))
                : k.texSubImage3D(ke, X, F.x, F.y, F.z, Ae, Ce, Fe, Ie, je, $t),
              k.pixelStorei(3314, Ve),
              k.pixelStorei(32878, it),
              k.pixelStorei(3316, ii),
              k.pixelStorei(3315, Ni),
              k.pixelStorei(32877, Oi),
              X === 0 && B.generateMipmaps && k.generateMipmap(ke),
              se.unbindTexture();
          }),
          (this.initTexture = function (E) {
            Y.setTexture2D(E, 0), se.unbindTexture();
          }),
          (this.resetState = function () {
            (x = 0), (y = 0), (v = null), se.reset(), Le.reset();
          }),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      Ke.prototype.isWebGLRenderer = !0;
      class ld extends Ke {}
      ld.prototype.isWebGL1Renderer = !0;
      class ms {
        constructor(e, t = 25e-5) {
          (this.name = ""), (this.color = new ne(e)), (this.density = t);
        }
        clone() {
          return new ms(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        }
      }
      ms.prototype.isFogExp2 = !0;
      class gs {
        constructor(e, t = 1, n = 1e3) {
          (this.name = ""),
            (this.color = new ne(e)),
            (this.near = t),
            (this.far = n);
        }
        clone() {
          return new gs(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      gs.prototype.isFog = !0;
      class xs extends Ne {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ != "undefined" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
              (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
        }
      }
      xs.prototype.isScene = !0;
      class ti {
        constructor(e, t) {
          (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = hr),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Bt());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = Bt()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = Bt()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      ti.prototype.isInterleavedBuffer = !0;
      const St = new S();
      class wn {
        constructor(e, t, n, i = !1) {
          (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i === !0);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            St.fromBufferAttribute(this, t),
              St.applyMatrix4(e),
              this.setXYZ(t, St.x, St.y, St.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            St.fromBufferAttribute(this, t),
              St.applyNormalMatrix(e),
              this.setXYZ(t, St.x, St.y, St.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            St.fromBufferAttribute(this, t),
              St.transformDirection(e),
              this.setXYZ(t, St.x, St.y, St.z);
          return this;
        }
        setX(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset] = t), this
          );
        }
        setY(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 1] = t), this
          );
        }
        setZ(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 2] = t), this
          );
        }
        setW(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 3] = t), this
          );
        }
        getX(e) {
          return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
          return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
          return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
          return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return new Ue(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new wn(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
        }
      }
      wn.prototype.isInterleavedBufferAttribute = !0;
      class No extends et {
        constructor(e) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new ne(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      No.prototype.isSpriteMaterial = !0;
      let Qi;
      const Gr = new S(),
        er = new S(),
        tr = new S(),
        nr = new W(),
        kr = new W(),
        cd = new fe(),
        Xs = new S(),
        Vr = new S(),
        Js = new S(),
        kc = new W(),
        wa = new W(),
        Vc = new W();
      class Oo extends Ne {
        constructor(e) {
          if ((super(), (this.type = "Sprite"), Qi === void 0)) {
            Qi = new _e();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              n = new ti(t, 5);
            Qi.setIndex([0, 1, 2, 0, 2, 3]),
              Qi.setAttribute("position", new wn(n, 3, 0, !1)),
              Qi.setAttribute("uv", new wn(n, 2, 3, !1));
          }
          (this.geometry = Qi),
            (this.material = e !== void 0 ? e : new No()),
            (this.center = new W(0.5, 0.5));
        }
        raycast(e, t) {
          e.camera === null &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            er.setFromMatrixScale(this.matrixWorld),
            cd.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            tr.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              this.material.sizeAttenuation === !1 &&
              er.multiplyScalar(-tr.z);
          const n = this.material.rotation;
          let i, r;
          n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
          const s = this.center;
          Ys(Xs.set(-0.5, -0.5, 0), tr, s, er, i, r),
            Ys(Vr.set(0.5, -0.5, 0), tr, s, er, i, r),
            Ys(Js.set(0.5, 0.5, 0), tr, s, er, i, r),
            kc.set(0, 0),
            wa.set(1, 0),
            Vc.set(1, 1);
          let a = e.ray.intersectTriangle(Xs, Vr, Js, !1, Gr);
          if (
            a === null &&
            (Ys(Vr.set(-0.5, 0.5, 0), tr, s, er, i, r),
            wa.set(0, 1),
            (a = e.ray.intersectTriangle(Xs, Js, Vr, !1, Gr)),
            a === null)
          )
            return;
          const l = e.ray.origin.distanceTo(Gr);
          l < e.near ||
            l > e.far ||
            t.push({
              distance: l,
              point: Gr.clone(),
              uv: ct.getUV(Gr, Xs, Vr, Js, kc, wa, Vc, new W()),
              face: null,
              object: this,
            });
        }
        copy(e) {
          return (
            super.copy(e),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        }
      }
      Oo.prototype.isSprite = !0;
      function Ys(o, e, t, n, i, r) {
        nr.subVectors(o, t).addScalar(0.5).multiply(n),
          i !== void 0
            ? ((kr.x = r * nr.x - i * nr.y), (kr.y = i * nr.x + r * nr.y))
            : kr.copy(nr),
          o.copy(e),
          (o.x += kr.x),
          (o.y += kr.y),
          o.applyMatrix4(cd);
      }
      const js = new S(),
        Wc = new S();
      class ud extends Ne {
        constructor() {
          super(),
            (this._currentLevel = 0),
            (this.type = "LOD"),
            Object.defineProperties(this, {
              levels: { enumerable: !0, value: [] },
              isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
        }
        copy(e) {
          super.copy(e, !1);
          const t = e.levels;
          for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            this.addLevel(r.object.clone(), r.distance);
          }
          return (this.autoUpdate = e.autoUpdate), this;
        }
        addLevel(e, t = 0) {
          t = Math.abs(t);
          const n = this.levels;
          let i;
          for (i = 0; i < n.length && !(t < n[i].distance); i++);
          return n.splice(i, 0, { distance: t, object: e }), this.add(e), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(e) {
          const t = this.levels;
          if (t.length > 0) {
            let n, i;
            for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
            return t[n - 1].object;
          }
          return null;
        }
        raycast(e, t) {
          if (this.levels.length > 0) {
            js.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(js);
            this.getObjectForDistance(i).raycast(e, t);
          }
        }
        update(e) {
          const t = this.levels;
          if (t.length > 1) {
            js.setFromMatrixPosition(e.matrixWorld),
              Wc.setFromMatrixPosition(this.matrixWorld);
            const n = js.distanceTo(Wc) / e.zoom;
            t[0].object.visible = !0;
            let i, r;
            for (i = 1, r = t.length; i < r && n >= t[i].distance; i++)
              (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
            for (this._currentLevel = i - 1; i < r; i++)
              t[i].object.visible = !1;
          }
        }
        toJSON(e) {
          const t = super.toJSON(e);
          this.autoUpdate === !1 && (t.object.autoUpdate = !1),
            (t.object.levels = []);
          const n = this.levels;
          for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.object.levels.push({
              object: s.object.uuid,
              distance: s.distance,
            });
          }
          return t;
        }
      }
      const qc = new S(),
        Xc = new Je(),
        Jc = new Je(),
        Iy = new S(),
        Yc = new fe();
      class ys extends ut {
        constructor(e, t) {
          super(e, t),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new fe()),
            (this.bindMatrixInverse = new fe());
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new Je(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === "attached"
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === "detached"
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          Xc.fromBufferAttribute(i.attributes.skinIndex, e),
            Jc.fromBufferAttribute(i.attributes.skinWeight, e),
            qc.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const s = Jc.getComponent(r);
            if (s !== 0) {
              const a = Xc.getComponent(r);
              Yc.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(Iy.copy(qc).applyMatrix4(Yc), s);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      ys.prototype.isSkinnedMesh = !0;
      class _s extends Ne {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      _s.prototype.isBone = !0;
      class bi extends st {
        constructor(
          e = null,
          t = 1,
          n = 1,
          i,
          r,
          s,
          a,
          l,
          c = at,
          u = at,
          h,
          d
        ) {
          super(null, s, a, l, c, u, i, r, h, d),
            (this.image = { data: e, width: t, height: n }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      bi.prototype.isDataTexture = !0;
      const jc = new fe(),
        Dy = new fe();
      class vs {
        constructor(e = [], t = []) {
          (this.uuid = Bt()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(e.length * 16)),
            t.length === 0)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let n = 0, i = this.bones.length; n < i; n++)
              this.boneInverses.push(new fe());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new fe();
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(n);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n &&
              (n.parent && n.parent.isBone
                ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                  n.matrix.multiply(n.matrixWorld))
                : n.matrix.copy(n.matrixWorld),
              n.matrix.decompose(n.position, n.quaternion, n.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let r = 0, s = e.length; r < s; r++) {
            const a = e[r] ? e[r].matrixWorld : Dy;
            jc.multiplyMatrices(a, t[r]), jc.toArray(n, r * 16);
          }
          i !== null && (i.needsUpdate = !0);
        }
        clone() {
          return new vs(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          (e = zh(e)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new bi(t, e, e, Dt, _n);
          return (
            (n.needsUpdate = !0),
            (this.boneMatrices = t),
            (this.boneTexture = n),
            (this.boneTextureSize = e),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e) return i;
          }
        }
        dispose() {
          this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const r = e.bones[n];
            let s = t[r];
            s === void 0 &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", r),
              (s = new _s())),
              this.bones.push(s),
              this.boneInverses.push(new fe().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            e.bones.push(s.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray());
          }
          return e;
        }
      }
      class Ei extends Ue {
        constructor(e, t, n, i = 1) {
          typeof n == "number" &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(e, t, n),
            (this.meshPerAttribute = i);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      Ei.prototype.isInstancedBufferAttribute = !0;
      const Kc = new fe(),
        Zc = new fe(),
        Ks = [],
        Wr = new ut();
      class Ll extends ut {
        constructor(e, t, n) {
          super(e, t),
            (this.instanceMatrix = new Ei(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(e) {
          return (
            super.copy(e),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((Wr.geometry = this.geometry),
            (Wr.material = this.material),
            Wr.material !== void 0)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, Kc),
                Zc.multiplyMatrices(n, Kc),
                (Wr.matrixWorld = Zc),
                Wr.raycast(e, Ks);
              for (let s = 0, a = Ks.length; s < a; s++) {
                const l = Ks[s];
                (l.instanceId = r), (l.object = this), t.push(l);
              }
              Ks.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null &&
            (this.instanceColor = new Ei(
              new Float32Array(this.instanceMatrix.count * 3),
              3
            )),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Ll.prototype.isInstancedMesh = !0;
      class gt extends et {
        constructor(e) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new ne(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      gt.prototype.isLineBasicMaterial = !0;
      const $c = new S(),
        Qc = new S(),
        eu = new fe(),
        Sa = new Qn(),
        Zs = new Tn();
      class ln extends Ne {
        constructor(e = new _e(), t = new gt()) {
          super(),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [0];
              for (let i = 1, r = t.count; i < r; i++)
                $c.fromBufferAttribute(t, i - 1),
                  Qc.fromBufferAttribute(t, i),
                  (n[i] = n[i - 1]),
                  (n[i] += $c.distanceTo(Qc));
              e.setAttribute("lineDistance", new pe(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            s = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Zs.copy(n.boundingSphere),
            Zs.applyMatrix4(i),
            (Zs.radius += r),
            e.ray.intersectsSphere(Zs) === !1)
          )
            return;
          eu.copy(i).invert(), Sa.copy(e.ray).applyMatrix4(eu);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new S(),
            u = new S(),
            h = new S(),
            d = new S(),
            f = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const g = n.index,
              p = n.attributes.position;
            if (g !== null) {
              const x = Math.max(0, s.start),
                y = Math.min(g.count, s.start + s.count);
              for (let v = x, M = y - 1; v < M; v += f) {
                const b = g.getX(v),
                  T = g.getX(v + 1);
                if (
                  (c.fromBufferAttribute(p, b),
                  u.fromBufferAttribute(p, T),
                  Sa.distanceSqToSegment(c, u, d, h) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const _ = e.ray.origin.distanceTo(d);
                _ < e.near ||
                  _ > e.far ||
                  t.push({
                    distance: _,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: v,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const x = Math.max(0, s.start),
                y = Math.min(p.count, s.start + s.count);
              for (let v = x, M = y - 1; v < M; v += f) {
                if (
                  (c.fromBufferAttribute(p, v),
                  u.fromBufferAttribute(p, v + 1),
                  Sa.distanceSqToSegment(c, u, d, h) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const T = e.ray.origin.distanceTo(d);
                T < e.near ||
                  T > e.far ||
                  t.push({
                    distance: T,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: v,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, s = i.length; r < s; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      ln.prototype.isLine = !0;
      const tu = new S(),
        nu = new S();
      class Rt extends ln {
        constructor(e, t) {
          super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [];
              for (let i = 0, r = t.count; i < r; i += 2)
                tu.fromBufferAttribute(t, i),
                  nu.fromBufferAttribute(t, i + 1),
                  (n[i] = i === 0 ? 0 : n[i - 1]),
                  (n[i + 1] = n[i] + tu.distanceTo(nu));
              e.setAttribute("lineDistance", new pe(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      Rt.prototype.isLineSegments = !0;
      class Uo extends ln {
        constructor(e, t) {
          super(e, t), (this.type = "LineLoop");
        }
      }
      Uo.prototype.isLineLoop = !0;
      class ni extends et {
        constructor(e) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new ne(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      ni.prototype.isPointsMaterial = !0;
      const iu = new fe(),
        fl = new Qn(),
        $s = new Tn(),
        Qs = new S();
      class Dr extends Ne {
        constructor(e = new _e(), t = new ni()) {
          super(),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            s = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            $s.copy(n.boundingSphere),
            $s.applyMatrix4(i),
            ($s.radius += r),
            e.ray.intersectsSphere($s) === !1)
          )
            return;
          iu.copy(i).invert(), fl.copy(e.ray).applyMatrix4(iu);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a;
          if (n.isBufferGeometry) {
            const c = n.index,
              h = n.attributes.position;
            if (c !== null) {
              const d = Math.max(0, s.start),
                f = Math.min(c.count, s.start + s.count);
              for (let g = d, m = f; g < m; g++) {
                const p = c.getX(g);
                Qs.fromBufferAttribute(h, p), ru(Qs, p, l, i, e, t, this);
              }
            } else {
              const d = Math.max(0, s.start),
                f = Math.min(h.count, s.start + s.count);
              for (let g = d, m = f; g < m; g++)
                Qs.fromBufferAttribute(h, g), ru(Qs, g, l, i, e, t, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, s = i.length; r < s; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Dr.prototype.isPoints = !0;
      function ru(o, e, t, n, i, r, s) {
        const a = fl.distanceSqToPoint(o);
        if (a < t) {
          const l = new S();
          fl.closestPointToPoint(o, l), l.applyMatrix4(n);
          const c = i.ray.origin.distanceTo(l);
          if (c < i.near || c > i.far) return;
          r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: s,
          });
        }
      }
      class hd extends st {
        constructor(e, t, n, i, r, s, a, l, c) {
          super(e, t, n, i, r, s, a, l, c),
            (this.minFilter = s !== void 0 ? s : tt),
            (this.magFilter = r !== void 0 ? r : tt),
            (this.generateMipmaps = !1);
          const u = this;
          function h() {
            (u.needsUpdate = !0), e.requestVideoFrameCallback(h);
          }
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      hd.prototype.isVideoTexture = !0;
      class dd extends st {
        constructor(e, t, n) {
          super({ width: e, height: t }),
            (this.format = n),
            (this.magFilter = at),
            (this.minFilter = at),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
        }
      }
      dd.prototype.isFramebufferTexture = !0;
      class Pl extends st {
        constructor(e, t, n, i, r, s, a, l, c, u, h, d) {
          super(null, s, a, l, c, u, i, r, h, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      Pl.prototype.isCompressedTexture = !0;
      class fd extends st {
        constructor(e, t, n, i, r, s, a, l, c) {
          super(e, t, n, i, r, s, a, l, c), (this.needsUpdate = !0);
        }
      }
      fd.prototype.isCanvasTexture = !0;
      class Nt {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let s = 1; s <= e; s++)
            (n = this.getPoint(s / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let s;
          t ? (s = t) : (s = e * n[r - 1]);
          let a = 0,
            l = r - 1,
            c;
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - s), c < 0))
              a = i + 1;
            else if (c > 0) l = i - 1;
            else {
              l = i;
              break;
            }
          if (((i = l), n[i] === s)) return i / (r - 1);
          const u = n[i],
            d = n[i + 1] - u,
            f = (s - u) / d;
          return (i + f) / (r - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4,
            r = e + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const s = this.getPoint(i),
            a = this.getPoint(r),
            l = t || (s.isVector2 ? new W() : new S());
          return l.copy(a).sub(s).normalize(), l;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new S(),
            i = [],
            r = [],
            s = [],
            a = new S(),
            l = new fe();
          for (let f = 0; f <= e; f++) {
            const g = f / e;
            i[f] = this.getTangentAt(g, new S());
          }
          (r[0] = new S()), (s[0] = new S());
          let c = Number.MAX_VALUE;
          const u = Math.abs(i[0].x),
            h = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
          u <= c && ((c = u), n.set(1, 0, 0)),
            h <= c && ((c = h), n.set(0, 1, 0)),
            d <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            s[0].crossVectors(i[0], r[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((r[f] = r[f - 1].clone()),
              (s[f] = s[f - 1].clone()),
              a.crossVectors(i[f - 1], i[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const g = Math.acos(lt(i[f - 1].dot(i[f]), -1, 1));
              r[f].applyMatrix4(l.makeRotationAxis(a, g));
            }
            s[f].crossVectors(i[f], r[f]);
          }
          if (t === !0) {
            let f = Math.acos(lt(r[0].dot(r[e]), -1, 1));
            (f /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let g = 1; g <= e; g++)
              r[g].applyMatrix4(l.makeRotationAxis(i[g], f * g)),
                s[g].crossVectors(i[g], r[g]);
          }
          return { tangents: i, normals: r, binormals: s };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class Ms extends Nt {
        constructor(
          e = 0,
          t = 0,
          n = 1,
          i = 1,
          r = 0,
          s = Math.PI * 2,
          a = !1,
          l = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = s),
            (this.aClockwise = a),
            (this.aRotation = l);
        }
        getPoint(e, t) {
          const n = t || new W(),
            i = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const s = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (s ? (r = 0) : (r = i)),
            this.aClockwise === !0 && !s && (r === i ? (r = -i) : (r = r - i));
          const a = this.aStartAngle + e * r;
          let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
          if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation),
              h = Math.sin(this.aRotation),
              d = l - this.aX,
              f = c - this.aY;
            (l = d * u - f * h + this.aX), (c = d * h + f * u + this.aY);
          }
          return n.set(l, c);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
      }
      Ms.prototype.isEllipseCurve = !0;
      class Il extends Ms {
        constructor(e, t, n, i, r, s) {
          super(e, t, n, n, i, r, s), (this.type = "ArcCurve");
        }
      }
      Il.prototype.isArcCurve = !0;
      function Dl() {
        let o = 0,
          e = 0,
          t = 0,
          n = 0;
        function i(r, s, a, l) {
          (o = r),
            (e = a),
            (t = -3 * r + 3 * s - 2 * a - l),
            (n = 2 * r - 2 * s + a + l);
        }
        return {
          initCatmullRom: function (r, s, a, l, c) {
            i(s, a, c * (a - r), c * (l - s));
          },
          initNonuniformCatmullRom: function (r, s, a, l, c, u, h) {
            let d = (s - r) / c - (a - r) / (c + u) + (a - s) / u,
              f = (a - s) / u - (l - s) / (u + h) + (l - a) / h;
            (d *= u), (f *= u), i(s, a, d, f);
          },
          calc: function (r) {
            const s = r * r,
              a = s * r;
            return o + e * r + t * s + n * a;
          },
        };
      }
      const eo = new S(),
        Ta = new Dl(),
        Ea = new Dl(),
        Aa = new Dl();
      class Fl extends Nt {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(e, t = new S()) {
          const n = t,
            i = this.points,
            r = i.length,
            s = (r - (this.closed ? 0 : 1)) * e;
          let a = Math.floor(s),
            l = s - a;
          this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r)
            : l === 0 && a === r - 1 && ((a = r - 2), (l = 1));
          let c, u;
          this.closed || a > 0
            ? (c = i[(a - 1) % r])
            : (eo.subVectors(i[0], i[1]).add(i[0]), (c = eo));
          const h = i[a % r],
            d = i[(a + 1) % r];
          if (
            (this.closed || a + 2 < r
              ? (u = i[(a + 2) % r])
              : (eo.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (u = eo)),
            this.curveType === "centripetal" || this.curveType === "chordal")
          ) {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let g = Math.pow(c.distanceToSquared(h), f),
              m = Math.pow(h.distanceToSquared(d), f),
              p = Math.pow(d.distanceToSquared(u), f);
            m < 1e-4 && (m = 1),
              g < 1e-4 && (g = m),
              p < 1e-4 && (p = m),
              Ta.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, g, m, p),
              Ea.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, g, m, p),
              Aa.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, g, m, p);
          } else
            this.curveType === "catmullrom" &&
              (Ta.initCatmullRom(c.x, h.x, d.x, u.x, this.tension),
              Ea.initCatmullRom(c.y, h.y, d.y, u.y, this.tension),
              Aa.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
          return n.set(Ta.calc(l), Ea.calc(l), Aa.calc(l)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new S().fromArray(i));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
      }
      Fl.prototype.isCatmullRomCurve3 = !0;
      function su(o, e, t, n, i) {
        const r = (n - e) * 0.5,
          s = (i - t) * 0.5,
          a = o * o,
          l = o * a;
        return (
          (2 * t - 2 * n + r + s) * l +
          (-3 * t + 3 * n - 2 * r - s) * a +
          r * o +
          t
        );
      }
      function Fy(o, e) {
        const t = 1 - o;
        return t * t * e;
      }
      function By(o, e) {
        return 2 * (1 - o) * o * e;
      }
      function Ny(o, e) {
        return o * o * e;
      }
      function Zr(o, e, t, n) {
        return Fy(o, e) + By(o, t) + Ny(o, n);
      }
      function Oy(o, e) {
        const t = 1 - o;
        return t * t * t * e;
      }
      function Uy(o, e) {
        const t = 1 - o;
        return 3 * t * t * o * e;
      }
      function zy(o, e) {
        return 3 * (1 - o) * o * o * e;
      }
      function Hy(o, e) {
        return o * o * o * e;
      }
      function $r(o, e, t, n, i) {
        return Oy(o, e) + Uy(o, t) + zy(o, n) + Hy(o, i);
      }
      class zo extends Nt {
        constructor(e = new W(), t = new W(), n = new W(), i = new W()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new W()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            s = this.v2,
            a = this.v3;
          return n.set($r(e, i.x, r.x, s.x, a.x), $r(e, i.y, r.y, s.y, a.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      zo.prototype.isCubicBezierCurve = !0;
      class Bl extends Nt {
        constructor(e = new S(), t = new S(), n = new S(), i = new S()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new S()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            s = this.v2,
            a = this.v3;
          return (
            n.set(
              $r(e, i.x, r.x, s.x, a.x),
              $r(e, i.y, r.y, s.y, a.y),
              $r(e, i.z, r.z, s.z, a.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      Bl.prototype.isCubicBezierCurve3 = !0;
      class bs extends Nt {
        constructor(e = new W(), t = new W()) {
          super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new W()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const n = t || new W();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      bs.prototype.isLineCurve = !0;
      class pd extends Nt {
        constructor(e = new S(), t = new S()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new S()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      class Ho extends Nt {
        constructor(e = new W(), t = new W(), n = new W()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new W()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            s = this.v2;
          return n.set(Zr(e, i.x, r.x, s.x), Zr(e, i.y, r.y, s.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Ho.prototype.isQuadraticBezierCurve = !0;
      class Go extends Nt {
        constructor(e = new S(), t = new S(), n = new S()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new S()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            s = this.v2;
          return (
            n.set(
              Zr(e, i.x, r.x, s.x),
              Zr(e, i.y, r.y, s.y),
              Zr(e, i.z, r.z, s.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Go.prototype.isQuadraticBezierCurve3 = !0;
      class ko extends Nt {
        constructor(e = []) {
          super(), (this.type = "SplineCurve"), (this.points = e);
        }
        getPoint(e, t = new W()) {
          const n = t,
            i = this.points,
            r = (i.length - 1) * e,
            s = Math.floor(r),
            a = r - s,
            l = i[s === 0 ? s : s - 1],
            c = i[s],
            u = i[s > i.length - 2 ? i.length - 1 : s + 1],
            h = i[s > i.length - 3 ? i.length - 1 : s + 2];
          return n.set(su(a, l.x, c.x, u.x, h.x), su(a, l.y, c.y, u.y, h.y)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new W().fromArray(i));
          }
          return this;
        }
      }
      ko.prototype.isSplineCurve = !0;
      var Nl = Object.freeze({
        __proto__: null,
        ArcCurve: Il,
        CatmullRomCurve3: Fl,
        CubicBezierCurve: zo,
        CubicBezierCurve3: Bl,
        EllipseCurve: Ms,
        LineCurve: bs,
        LineCurve3: pd,
        QuadraticBezierCurve: Ho,
        QuadraticBezierCurve3: Go,
        SplineCurve: ko,
      });
      class md extends Nt {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new bs(t, e));
        }
        getPoint(e, t) {
          const n = e * this.getLength(),
            i = this.getCurveLengths();
          let r = 0;
          for (; r < i.length; ) {
            if (i[r] >= n) {
              const s = i[r] - n,
                a = this.curves[r],
                l = a.getLength(),
                c = l === 0 ? 0 : 1 - s / l;
              return a.getPointAt(c, t);
            }
            r++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const s = r[i],
              a = s.isEllipseCurve
                ? e * 2
                : s.isLineCurve || s.isLineCurve3
                ? 1
                : s.isSplineCurve
                ? e * s.points.length
                : e,
              l = s.getPoints(a);
            for (let c = 0; c < l.length; c++) {
              const u = l[c];
              (n && n.equals(u)) || (t.push(u), (n = u));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        }
        copy(e) {
          super.copy(e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone());
          }
          return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Nl[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class pr extends md {
        constructor(e) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new W()),
            e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const n = new bs(this.currentPoint.clone(), new W(e, t));
          return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          const r = new Ho(this.currentPoint.clone(), new W(e, t), new W(n, i));
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, s) {
          const a = new zo(
            this.currentPoint.clone(),
            new W(e, t),
            new W(n, i),
            new W(r, s)
          );
          return this.curves.push(a), this.currentPoint.set(r, s), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            n = new ko(t);
          return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
          );
        }
        arc(e, t, n, i, r, s) {
          const a = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absarc(e + a, t + l, n, i, r, s), this;
        }
        absarc(e, t, n, i, r, s) {
          return this.absellipse(e, t, n, n, i, r, s), this;
        }
        ellipse(e, t, n, i, r, s, a, l) {
          const c = this.currentPoint.x,
            u = this.currentPoint.y;
          return this.absellipse(e + c, t + u, n, i, r, s, a, l), this;
        }
        absellipse(e, t, n, i, r, s, a, l) {
          const c = new Ms(e, t, n, i, r, s, a, l);
          if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
          }
          this.curves.push(c);
          const u = c.getPoint(1);
          return this.currentPoint.copy(u), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
          );
        }
      }
      class Ai extends _e {
        constructor(
          e = [new W(0, 0.5), new W(0.5, 0), new W(0, -0.5)],
          t = 12,
          n = 0,
          i = Math.PI * 2
        ) {
          super(),
            (this.type = "LatheGeometry"),
            (this.parameters = {
              points: e,
              segments: t,
              phiStart: n,
              phiLength: i,
            }),
            (t = Math.floor(t)),
            (i = lt(i, 0, Math.PI * 2));
          const r = [],
            s = [],
            a = [],
            l = [],
            c = [],
            u = 1 / t,
            h = new S(),
            d = new W(),
            f = new S(),
            g = new S(),
            m = new S();
          let p = 0,
            x = 0;
          for (let y = 0; y <= e.length - 1; y++)
            switch (y) {
              case 0:
                (p = e[y + 1].x - e[y].x),
                  (x = e[y + 1].y - e[y].y),
                  (f.x = x * 1),
                  (f.y = -p),
                  (f.z = x * 0),
                  m.copy(f),
                  f.normalize(),
                  l.push(f.x, f.y, f.z);
                break;
              case e.length - 1:
                l.push(m.x, m.y, m.z);
                break;
              default:
                (p = e[y + 1].x - e[y].x),
                  (x = e[y + 1].y - e[y].y),
                  (f.x = x * 1),
                  (f.y = -p),
                  (f.z = x * 0),
                  g.copy(f),
                  (f.x += m.x),
                  (f.y += m.y),
                  (f.z += m.z),
                  f.normalize(),
                  l.push(f.x, f.y, f.z),
                  m.copy(g);
            }
          for (let y = 0; y <= t; y++) {
            const v = n + y * u * i,
              M = Math.sin(v),
              b = Math.cos(v);
            for (let T = 0; T <= e.length - 1; T++) {
              (h.x = e[T].x * M),
                (h.y = e[T].y),
                (h.z = e[T].x * b),
                s.push(h.x, h.y, h.z),
                (d.x = y / t),
                (d.y = T / (e.length - 1)),
                a.push(d.x, d.y);
              const C = l[3 * T + 0] * M,
                _ = l[3 * T + 1],
                R = l[3 * T + 0] * b;
              c.push(C, _, R);
            }
          }
          for (let y = 0; y < t; y++)
            for (let v = 0; v < e.length - 1; v++) {
              const M = v + y * e.length,
                b = M,
                T = M + e.length,
                C = M + e.length + 1,
                _ = M + 1;
              r.push(b, T, _), r.push(C, _, T);
            }
          this.setIndex(r),
            this.setAttribute("position", new pe(s, 3)),
            this.setAttribute("uv", new pe(a, 2)),
            this.setAttribute("normal", new pe(c, 3));
        }
        static fromJSON(e) {
          return new Ai(e.points, e.segments, e.phiStart, e.phiLength);
        }
      }
      class mr extends Ai {
        constructor(e = 1, t = 1, n = 4, i = 8) {
          const r = new pr();
          r.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
            r.absarc(0, t / 2, e, 0, Math.PI * 0.5),
            super(r.getPoints(n), i),
            (this.type = "CapsuleGeometry"),
            (this.parameters = {
              radius: e,
              height: t,
              capSegments: n,
              radialSegments: i,
            });
        }
        static fromJSON(e) {
          return new mr(e.radius, e.length, e.capSegments, e.radialSegments);
        }
      }
      class gr extends _e {
        constructor(e = 1, t = 8, n = 0, i = Math.PI * 2) {
          super(),
            (this.type = "CircleGeometry"),
            (this.parameters = {
              radius: e,
              segments: t,
              thetaStart: n,
              thetaLength: i,
            }),
            (t = Math.max(3, t));
          const r = [],
            s = [],
            a = [],
            l = [],
            c = new S(),
            u = new W();
          s.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
          for (let h = 0, d = 3; h <= t; h++, d += 3) {
            const f = n + (h / t) * i;
            (c.x = e * Math.cos(f)),
              (c.y = e * Math.sin(f)),
              s.push(c.x, c.y, c.z),
              a.push(0, 0, 1),
              (u.x = (s[d] / e + 1) / 2),
              (u.y = (s[d + 1] / e + 1) / 2),
              l.push(u.x, u.y);
          }
          for (let h = 1; h <= t; h++) r.push(h, h + 1, 0);
          this.setIndex(r),
            this.setAttribute("position", new pe(s, 3)),
            this.setAttribute("normal", new pe(a, 3)),
            this.setAttribute("uv", new pe(l, 2));
        }
        static fromJSON(e) {
          return new gr(e.radius, e.segments, e.thetaStart, e.thetaLength);
        }
      }
      class Jn extends _e {
        constructor(
          e = 1,
          t = 1,
          n = 1,
          i = 8,
          r = 1,
          s = !1,
          a = 0,
          l = Math.PI * 2
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: e,
              radiusBottom: t,
              height: n,
              radialSegments: i,
              heightSegments: r,
              openEnded: s,
              thetaStart: a,
              thetaLength: l,
            });
          const c = this;
          (i = Math.floor(i)), (r = Math.floor(r));
          const u = [],
            h = [],
            d = [],
            f = [];
          let g = 0;
          const m = [],
            p = n / 2;
          let x = 0;
          y(),
            s === !1 && (e > 0 && v(!0), t > 0 && v(!1)),
            this.setIndex(u),
            this.setAttribute("position", new pe(h, 3)),
            this.setAttribute("normal", new pe(d, 3)),
            this.setAttribute("uv", new pe(f, 2));
          function y() {
            const M = new S(),
              b = new S();
            let T = 0;
            const C = (t - e) / n;
            for (let _ = 0; _ <= r; _++) {
              const R = [],
                P = _ / r,
                D = P * (t - e) + e;
              for (let Z = 0; Z <= i; Z++) {
                const j = Z / i,
                  I = j * l + a,
                  U = Math.sin(I),
                  N = Math.cos(I);
                (b.x = D * U),
                  (b.y = -P * n + p),
                  (b.z = D * N),
                  h.push(b.x, b.y, b.z),
                  M.set(U, C, N).normalize(),
                  d.push(M.x, M.y, M.z),
                  f.push(j, 1 - P),
                  R.push(g++);
              }
              m.push(R);
            }
            for (let _ = 0; _ < i; _++)
              for (let R = 0; R < r; R++) {
                const P = m[R][_],
                  D = m[R + 1][_],
                  Z = m[R + 1][_ + 1],
                  j = m[R][_ + 1];
                u.push(P, D, j), u.push(D, Z, j), (T += 6);
              }
            c.addGroup(x, T, 0), (x += T);
          }
          function v(M) {
            const b = g,
              T = new W(),
              C = new S();
            let _ = 0;
            const R = M === !0 ? e : t,
              P = M === !0 ? 1 : -1;
            for (let Z = 1; Z <= i; Z++)
              h.push(0, p * P, 0), d.push(0, P, 0), f.push(0.5, 0.5), g++;
            const D = g;
            for (let Z = 0; Z <= i; Z++) {
              const I = (Z / i) * l + a,
                U = Math.cos(I),
                N = Math.sin(I);
              (C.x = R * N),
                (C.y = p * P),
                (C.z = R * U),
                h.push(C.x, C.y, C.z),
                d.push(0, P, 0),
                (T.x = U * 0.5 + 0.5),
                (T.y = N * 0.5 * P + 0.5),
                f.push(T.x, T.y),
                g++;
            }
            for (let Z = 0; Z < i; Z++) {
              const j = b + Z,
                I = D + Z;
              M === !0 ? u.push(I, I + 1, j) : u.push(I + 1, I, j), (_ += 3);
            }
            c.addGroup(x, _, M === !0 ? 1 : 2), (x += _);
          }
        }
        static fromJSON(e) {
          return new Jn(
            e.radiusTop,
            e.radiusBottom,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class xr extends Jn {
        constructor(
          e = 1,
          t = 1,
          n = 8,
          i = 1,
          r = !1,
          s = 0,
          a = Math.PI * 2
        ) {
          super(0, e, t, n, i, r, s, a),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: e,
              height: t,
              radialSegments: n,
              heightSegments: i,
              openEnded: r,
              thetaStart: s,
              thetaLength: a,
            });
        }
        static fromJSON(e) {
          return new xr(
            e.radius,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class cn extends _e {
        constructor(e = [], t = [], n = 1, i = 0) {
          super(),
            (this.type = "PolyhedronGeometry"),
            (this.parameters = {
              vertices: e,
              indices: t,
              radius: n,
              detail: i,
            });
          const r = [],
            s = [];
          a(i),
            c(n),
            u(),
            this.setAttribute("position", new pe(r, 3)),
            this.setAttribute("normal", new pe(r.slice(), 3)),
            this.setAttribute("uv", new pe(s, 2)),
            i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
          function a(y) {
            const v = new S(),
              M = new S(),
              b = new S();
            for (let T = 0; T < t.length; T += 3)
              f(t[T + 0], v), f(t[T + 1], M), f(t[T + 2], b), l(v, M, b, y);
          }
          function l(y, v, M, b) {
            const T = b + 1,
              C = [];
            for (let _ = 0; _ <= T; _++) {
              C[_] = [];
              const R = y.clone().lerp(M, _ / T),
                P = v.clone().lerp(M, _ / T),
                D = T - _;
              for (let Z = 0; Z <= D; Z++)
                Z === 0 && _ === T
                  ? (C[_][Z] = R)
                  : (C[_][Z] = R.clone().lerp(P, Z / D));
            }
            for (let _ = 0; _ < T; _++)
              for (let R = 0; R < 2 * (T - _) - 1; R++) {
                const P = Math.floor(R / 2);
                R % 2 === 0
                  ? (d(C[_][P + 1]), d(C[_ + 1][P]), d(C[_][P]))
                  : (d(C[_][P + 1]), d(C[_ + 1][P + 1]), d(C[_ + 1][P]));
              }
          }
          function c(y) {
            const v = new S();
            for (let M = 0; M < r.length; M += 3)
              (v.x = r[M + 0]),
                (v.y = r[M + 1]),
                (v.z = r[M + 2]),
                v.normalize().multiplyScalar(y),
                (r[M + 0] = v.x),
                (r[M + 1] = v.y),
                (r[M + 2] = v.z);
          }
          function u() {
            const y = new S();
            for (let v = 0; v < r.length; v += 3) {
              (y.x = r[v + 0]), (y.y = r[v + 1]), (y.z = r[v + 2]);
              const M = p(y) / 2 / Math.PI + 0.5,
                b = x(y) / Math.PI + 0.5;
              s.push(M, 1 - b);
            }
            g(), h();
          }
          function h() {
            for (let y = 0; y < s.length; y += 6) {
              const v = s[y + 0],
                M = s[y + 2],
                b = s[y + 4],
                T = Math.max(v, M, b),
                C = Math.min(v, M, b);
              T > 0.9 &&
                C < 0.1 &&
                (v < 0.2 && (s[y + 0] += 1),
                M < 0.2 && (s[y + 2] += 1),
                b < 0.2 && (s[y + 4] += 1));
            }
          }
          function d(y) {
            r.push(y.x, y.y, y.z);
          }
          function f(y, v) {
            const M = y * 3;
            (v.x = e[M + 0]), (v.y = e[M + 1]), (v.z = e[M + 2]);
          }
          function g() {
            const y = new S(),
              v = new S(),
              M = new S(),
              b = new S(),
              T = new W(),
              C = new W(),
              _ = new W();
            for (let R = 0, P = 0; R < r.length; R += 9, P += 6) {
              y.set(r[R + 0], r[R + 1], r[R + 2]),
                v.set(r[R + 3], r[R + 4], r[R + 5]),
                M.set(r[R + 6], r[R + 7], r[R + 8]),
                T.set(s[P + 0], s[P + 1]),
                C.set(s[P + 2], s[P + 3]),
                _.set(s[P + 4], s[P + 5]),
                b.copy(y).add(v).add(M).divideScalar(3);
              const D = p(b);
              m(T, P + 0, y, D), m(C, P + 2, v, D), m(_, P + 4, M, D);
            }
          }
          function m(y, v, M, b) {
            b < 0 && y.x === 1 && (s[v] = y.x - 1),
              M.x === 0 && M.z === 0 && (s[v] = b / 2 / Math.PI + 0.5);
          }
          function p(y) {
            return Math.atan2(y.z, -y.x);
          }
          function x(y) {
            return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
          }
        }
        static fromJSON(e) {
          return new cn(e.vertices, e.indices, e.radius, e.details);
        }
      }
      class yr extends cn {
        constructor(e = 1, t = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n,
            r = [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              0,
              -n,
              0,
              -i,
              n,
              0,
              -i,
              -n,
              0,
              i,
              n,
              0,
              i,
            ],
            s = [
              3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17,
              4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12,
              1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18,
              2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
              12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14,
              4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ];
          super(r, s, e, t),
            (this.type = "DodecahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
          return new yr(e.radius, e.detail);
        }
      }
      const to = new S(),
        no = new S(),
        Ra = new S(),
        io = new ct();
      class Ol extends _e {
        constructor(e = null, t = 1) {
          if (
            (super(),
            (this.type = "EdgesGeometry"),
            (this.parameters = { geometry: e, thresholdAngle: t }),
            e !== null)
          ) {
            const i = Math.pow(10, 4),
              r = Math.cos(vi * t),
              s = e.getIndex(),
              a = e.getAttribute("position"),
              l = s ? s.count : a.count,
              c = [0, 0, 0],
              u = ["a", "b", "c"],
              h = new Array(3),
              d = {},
              f = [];
            for (let g = 0; g < l; g += 3) {
              s
                ? ((c[0] = s.getX(g)),
                  (c[1] = s.getX(g + 1)),
                  (c[2] = s.getX(g + 2)))
                : ((c[0] = g), (c[1] = g + 1), (c[2] = g + 2));
              const { a: m, b: p, c: x } = io;
              if (
                (m.fromBufferAttribute(a, c[0]),
                p.fromBufferAttribute(a, c[1]),
                x.fromBufferAttribute(a, c[2]),
                io.getNormal(Ra),
                (h[0] = `${Math.round(m.x * i)},${Math.round(
                  m.y * i
                )},${Math.round(m.z * i)}`),
                (h[1] = `${Math.round(p.x * i)},${Math.round(
                  p.y * i
                )},${Math.round(p.z * i)}`),
                (h[2] = `${Math.round(x.x * i)},${Math.round(
                  x.y * i
                )},${Math.round(x.z * i)}`),
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
              )
                for (let y = 0; y < 3; y++) {
                  const v = (y + 1) % 3,
                    M = h[y],
                    b = h[v],
                    T = io[u[y]],
                    C = io[u[v]],
                    _ = `${M}_${b}`,
                    R = `${b}_${M}`;
                  R in d && d[R]
                    ? (Ra.dot(d[R].normal) <= r &&
                        (f.push(T.x, T.y, T.z), f.push(C.x, C.y, C.z)),
                      (d[R] = null))
                    : _ in d ||
                      (d[_] = {
                        index0: c[y],
                        index1: c[v],
                        normal: Ra.clone(),
                      });
                }
            }
            for (const g in d)
              if (d[g]) {
                const { index0: m, index1: p } = d[g];
                to.fromBufferAttribute(a, m),
                  no.fromBufferAttribute(a, p),
                  f.push(to.x, to.y, to.z),
                  f.push(no.x, no.y, no.z);
              }
            this.setAttribute("position", new pe(f, 3));
          }
        }
      }
      class on extends pr {
        constructor(e) {
          super(e),
            (this.uuid = Bt()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(e) {
          const t = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
          super.copy(e), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.uuid = this.uuid), (e.holes = []);
          for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new pr().fromJSON(i));
          }
          return this;
        }
      }
      const Gy = {
        triangulate: function (o, e, t = 2) {
          const n = e && e.length,
            i = n ? e[0] * t : o.length;
          let r = gd(o, 0, i, t, !0);
          const s = [];
          if (!r || r.next === r.prev) return s;
          let a, l, c, u, h, d, f;
          if ((n && (r = Xy(o, e, r, t)), o.length > 80 * t)) {
            (a = c = o[0]), (l = u = o[1]);
            for (let g = t; g < i; g += t)
              (h = o[g]),
                (d = o[g + 1]),
                h < a && (a = h),
                d < l && (l = d),
                h > c && (c = h),
                d > u && (u = d);
            (f = Math.max(c - a, u - l)), (f = f !== 0 ? 1 / f : 0);
          }
          return os(r, s, t, a, l, f), s;
        },
      };
      function gd(o, e, t, n, i) {
        let r, s;
        if (i === i0(o, e, t, n) > 0)
          for (r = e; r < t; r += n) s = ou(r, o[r], o[r + 1], s);
        else for (r = t - n; r >= e; r -= n) s = ou(r, o[r], o[r + 1], s);
        return s && Vo(s, s.next) && (ls(s), (s = s.next)), s;
      }
      function Yn(o, e) {
        if (!o) return o;
        e || (e = o);
        let t = o,
          n;
        do
          if (
            ((n = !1),
            !t.steiner && (Vo(t, t.next) || nt(t.prev, t, t.next) === 0))
          ) {
            if ((ls(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
          } else t = t.next;
        while (n || t !== e);
        return e;
      }
      function os(o, e, t, n, i, r, s) {
        if (!o) return;
        !s && r && Zy(o, n, i, r);
        let a = o,
          l,
          c;
        for (; o.prev !== o.next; ) {
          if (((l = o.prev), (c = o.next), r ? Vy(o, n, i, r) : ky(o))) {
            e.push(l.i / t),
              e.push(o.i / t),
              e.push(c.i / t),
              ls(o),
              (o = c.next),
              (a = c.next);
            continue;
          }
          if (((o = c), o === a)) {
            s
              ? s === 1
                ? ((o = Wy(Yn(o), e, t)), os(o, e, t, n, i, r, 2))
                : s === 2 && qy(o, e, t, n, i, r)
              : os(Yn(o), e, t, n, i, r, 1);
            break;
          }
        }
      }
      function ky(o) {
        const e = o.prev,
          t = o,
          n = o.next;
        if (nt(e, t, n) >= 0) return !1;
        let i = o.next.next;
        for (; i !== o.prev; ) {
          if (
            or(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            nt(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function Vy(o, e, t, n) {
        const i = o.prev,
          r = o,
          s = o.next;
        if (nt(i, r, s) >= 0) return !1;
        const a = i.x < r.x ? (i.x < s.x ? i.x : s.x) : r.x < s.x ? r.x : s.x,
          l = i.y < r.y ? (i.y < s.y ? i.y : s.y) : r.y < s.y ? r.y : s.y,
          c = i.x > r.x ? (i.x > s.x ? i.x : s.x) : r.x > s.x ? r.x : s.x,
          u = i.y > r.y ? (i.y > s.y ? i.y : s.y) : r.y > s.y ? r.y : s.y,
          h = pl(a, l, e, t, n),
          d = pl(c, u, e, t, n);
        let f = o.prevZ,
          g = o.nextZ;
        for (; f && f.z >= h && g && g.z <= d; ) {
          if (
            (f !== o.prev &&
              f !== o.next &&
              or(i.x, i.y, r.x, r.y, s.x, s.y, f.x, f.y) &&
              nt(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            g !== o.prev &&
              g !== o.next &&
              or(i.x, i.y, r.x, r.y, s.x, s.y, g.x, g.y) &&
              nt(g.prev, g, g.next) >= 0)
          )
            return !1;
          g = g.nextZ;
        }
        for (; f && f.z >= h; ) {
          if (
            f !== o.prev &&
            f !== o.next &&
            or(i.x, i.y, r.x, r.y, s.x, s.y, f.x, f.y) &&
            nt(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; g && g.z <= d; ) {
          if (
            g !== o.prev &&
            g !== o.next &&
            or(i.x, i.y, r.x, r.y, s.x, s.y, g.x, g.y) &&
            nt(g.prev, g, g.next) >= 0
          )
            return !1;
          g = g.nextZ;
        }
        return !0;
      }
      function Wy(o, e, t) {
        let n = o;
        do {
          const i = n.prev,
            r = n.next.next;
          !Vo(i, r) &&
            xd(i, n, n.next, r) &&
            as(i, r) &&
            as(r, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(r.i / t),
            ls(n),
            ls(n.next),
            (n = o = r)),
            (n = n.next);
        } while (n !== o);
        return Yn(n);
      }
      function qy(o, e, t, n, i, r) {
        let s = o;
        do {
          let a = s.next.next;
          for (; a !== s.prev; ) {
            if (s.i !== a.i && e0(s, a)) {
              let l = yd(s, a);
              (s = Yn(s, s.next)),
                (l = Yn(l, l.next)),
                os(s, e, t, n, i, r),
                os(l, e, t, n, i, r);
              return;
            }
            a = a.next;
          }
          s = s.next;
        } while (s !== o);
      }
      function Xy(o, e, t, n) {
        const i = [];
        let r, s, a, l, c;
        for (r = 0, s = e.length; r < s; r++)
          (a = e[r] * n),
            (l = r < s - 1 ? e[r + 1] * n : o.length),
            (c = gd(o, a, l, n, !1)),
            c === c.next && (c.steiner = !0),
            i.push(Qy(c));
        for (i.sort(Jy), r = 0; r < i.length; r++)
          Yy(i[r], t), (t = Yn(t, t.next));
        return t;
      }
      function Jy(o, e) {
        return o.x - e.x;
      }
      function Yy(o, e) {
        if (((e = jy(o, e)), e)) {
          const t = yd(e, o);
          Yn(e, e.next), Yn(t, t.next);
        }
      }
      function jy(o, e) {
        let t = e;
        const n = o.x,
          i = o.y;
        let r = -1 / 0,
          s;
        do {
          if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > r) {
              if (((r = d), d === n)) {
                if (i === t.y) return t;
                if (i === t.next.y) return t.next;
              }
              s = t.x < t.next.x ? t : t.next;
            }
          }
          t = t.next;
        } while (t !== e);
        if (!s) return null;
        if (n === r) return s;
        const a = s,
          l = s.x,
          c = s.y;
        let u = 1 / 0,
          h;
        t = s;
        do
          n >= t.x &&
            t.x >= l &&
            n !== t.x &&
            or(i < c ? n : r, i, l, c, i < c ? r : n, i, t.x, t.y) &&
            ((h = Math.abs(i - t.y) / (n - t.x)),
            as(t, o) &&
              (h < u ||
                (h === u && (t.x > s.x || (t.x === s.x && Ky(s, t))))) &&
              ((s = t), (u = h))),
            (t = t.next);
        while (t !== a);
        return s;
      }
      function Ky(o, e) {
        return nt(o.prev, o, e.prev) < 0 && nt(e.next, o, o.next) < 0;
      }
      function Zy(o, e, t, n) {
        let i = o;
        do
          i.z === null && (i.z = pl(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
        while (i !== o);
        (i.prevZ.nextZ = null), (i.prevZ = null), $y(i);
      }
      function $y(o) {
        let e,
          t,
          n,
          i,
          r,
          s,
          a,
          l,
          c = 1;
        do {
          for (t = o, o = null, r = null, s = 0; t; ) {
            for (
              s++, n = t, a = 0, e = 0;
              e < c && (a++, (n = n.nextZ), !!n);
              e++
            );
            for (l = c; a > 0 || (l > 0 && n); )
              a !== 0 && (l === 0 || !n || t.z <= n.z)
                ? ((i = t), (t = t.nextZ), a--)
                : ((i = n), (n = n.nextZ), l--),
                r ? (r.nextZ = i) : (o = i),
                (i.prevZ = r),
                (r = i);
            t = n;
          }
          (r.nextZ = null), (c *= 2);
        } while (s > 1);
        return o;
      }
      function pl(o, e, t, n, i) {
        return (
          (o = 32767 * (o - t) * i),
          (e = 32767 * (e - n) * i),
          (o = (o | (o << 8)) & 16711935),
          (o = (o | (o << 4)) & 252645135),
          (o = (o | (o << 2)) & 858993459),
          (o = (o | (o << 1)) & 1431655765),
          (e = (e | (e << 8)) & 16711935),
          (e = (e | (e << 4)) & 252645135),
          (e = (e | (e << 2)) & 858993459),
          (e = (e | (e << 1)) & 1431655765),
          o | (e << 1)
        );
      }
      function Qy(o) {
        let e = o,
          t = o;
        do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
        while (e !== o);
        return t;
      }
      function or(o, e, t, n, i, r, s, a) {
        return (
          (i - s) * (e - a) - (o - s) * (r - a) >= 0 &&
          (o - s) * (n - a) - (t - s) * (e - a) >= 0 &&
          (t - s) * (r - a) - (i - s) * (n - a) >= 0
        );
      }
      function e0(o, e) {
        return (
          o.next.i !== e.i &&
          o.prev.i !== e.i &&
          !t0(o, e) &&
          ((as(o, e) &&
            as(e, o) &&
            n0(o, e) &&
            (nt(o.prev, o, e.prev) || nt(o, e.prev, e))) ||
            (Vo(o, e) &&
              nt(o.prev, o, o.next) > 0 &&
              nt(e.prev, e, e.next) > 0))
        );
      }
      function nt(o, e, t) {
        return (e.y - o.y) * (t.x - e.x) - (e.x - o.x) * (t.y - e.y);
      }
      function Vo(o, e) {
        return o.x === e.x && o.y === e.y;
      }
      function xd(o, e, t, n) {
        const i = so(nt(o, e, t)),
          r = so(nt(o, e, n)),
          s = so(nt(t, n, o)),
          a = so(nt(t, n, e));
        return !!(
          (i !== r && s !== a) ||
          (i === 0 && ro(o, t, e)) ||
          (r === 0 && ro(o, n, e)) ||
          (s === 0 && ro(t, o, n)) ||
          (a === 0 && ro(t, e, n))
        );
      }
      function ro(o, e, t) {
        return (
          e.x <= Math.max(o.x, t.x) &&
          e.x >= Math.min(o.x, t.x) &&
          e.y <= Math.max(o.y, t.y) &&
          e.y >= Math.min(o.y, t.y)
        );
      }
      function so(o) {
        return o > 0 ? 1 : o < 0 ? -1 : 0;
      }
      function t0(o, e) {
        let t = o;
        do {
          if (
            t.i !== o.i &&
            t.next.i !== o.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            xd(t, t.next, o, e)
          )
            return !0;
          t = t.next;
        } while (t !== o);
        return !1;
      }
      function as(o, e) {
        return nt(o.prev, o, o.next) < 0
          ? nt(o, e, o.next) >= 0 && nt(o, o.prev, e) >= 0
          : nt(o, e, o.prev) < 0 || nt(o, o.next, e) < 0;
      }
      function n0(o, e) {
        let t = o,
          n = !1;
        const i = (o.x + e.x) / 2,
          r = (o.y + e.y) / 2;
        do
          t.y > r != t.next.y > r &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
        while (t !== o);
        return n;
      }
      function yd(o, e) {
        const t = new ml(o.i, o.x, o.y),
          n = new ml(e.i, e.x, e.y),
          i = o.next,
          r = e.prev;
        return (
          (o.next = e),
          (e.prev = o),
          (t.next = i),
          (i.prev = t),
          (n.next = t),
          (t.prev = n),
          (r.next = n),
          (n.prev = r),
          n
        );
      }
      function ou(o, e, t, n) {
        const i = new ml(o, e, t);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function ls(o) {
        (o.next.prev = o.prev),
          (o.prev.next = o.next),
          o.prevZ && (o.prevZ.nextZ = o.nextZ),
          o.nextZ && (o.nextZ.prevZ = o.prevZ);
      }
      function ml(o, e, t) {
        (this.i = o),
          (this.x = e),
          (this.y = t),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function i0(o, e, t, n) {
        let i = 0;
        for (let r = e, s = t - n; r < t; r += n)
          (i += (o[s] - o[r]) * (o[r + 1] + o[s + 1])), (s = r);
        return i;
      }
      class an {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return n * 0.5;
        }
        static isClockWise(e) {
          return an.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          au(e), lu(n, e);
          let s = e.length;
          t.forEach(au);
          for (let l = 0; l < t.length; l++)
            i.push(s), (s += t[l].length), lu(n, t[l]);
          const a = Gy.triangulate(n, i);
          for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
          return r;
        }
      }
      function au(o) {
        const e = o.length;
        e > 2 && o[e - 1].equals(o[0]) && o.pop();
      }
      function lu(o, e) {
        for (let t = 0; t < e.length; t++) o.push(e[t].x), o.push(e[t].y);
      }
      class un extends _e {
        constructor(
          e = new on([
            new W(0.5, 0.5),
            new W(-0.5, 0.5),
            new W(-0.5, -0.5),
            new W(0.5, -0.5),
          ]),
          t = {}
        ) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            r = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            s(c);
          }
          this.setAttribute("position", new pe(i, 3)),
            this.setAttribute("uv", new pe(r, 2)),
            this.computeVertexNormals();
          function s(a) {
            const l = [],
              c = t.curveSegments !== void 0 ? t.curveSegments : 12,
              u = t.steps !== void 0 ? t.steps : 1;
            let h = t.depth !== void 0 ? t.depth : 1,
              d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
              f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
              g = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
              m = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
              p = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const x = t.extrudePath,
              y = t.UVGenerator !== void 0 ? t.UVGenerator : r0;
            t.amount !== void 0 &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (h = t.amount));
            let v,
              M = !1,
              b,
              T,
              C,
              _;
            x &&
              ((v = x.getSpacedPoints(u)),
              (M = !0),
              (d = !1),
              (b = x.computeFrenetFrames(u, !1)),
              (T = new S()),
              (C = new S()),
              (_ = new S())),
              d || ((p = 0), (f = 0), (g = 0), (m = 0));
            const R = a.extractPoints(c);
            let P = R.shape;
            const D = R.holes;
            if (!an.isClockWise(P)) {
              P = P.reverse();
              for (let K = 0, Y = D.length; K < Y; K++) {
                const ie = D[K];
                an.isClockWise(ie) && (D[K] = ie.reverse());
              }
            }
            const j = an.triangulateShape(P, D),
              I = P;
            for (let K = 0, Y = D.length; K < Y; K++) {
              const ie = D[K];
              P = P.concat(ie);
            }
            function U(K, Y, ie) {
              return (
                Y || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Y.clone().multiplyScalar(ie).add(K)
              );
            }
            const N = P.length,
              V = j.length;
            function J(K, Y, ie) {
              let me, ue, Re;
              const be = K.x - Y.x,
                ve = K.y - Y.y,
                $e = ie.x - K.x,
                Ze = ie.y - K.y,
                A = be * be + ve * ve,
                w = be * Ze - ve * $e;
              if (Math.abs(w) > Number.EPSILON) {
                const H = Math.sqrt(A),
                  Q = Math.sqrt($e * $e + Ze * Ze),
                  ce = Y.x - ve / H,
                  he = Y.y + be / H,
                  Me = ie.x - Ze / Q,
                  G = ie.y + $e / Q,
                  Le = ((Me - ce) * Ze - (G - he) * $e) / (be * Ze - ve * $e);
                (me = ce + be * Le - K.x), (ue = he + ve * Le - K.y);
                const De = me * me + ue * ue;
                if (De <= 2) return new W(me, ue);
                Re = Math.sqrt(De / 2);
              } else {
                let H = !1;
                be > Number.EPSILON
                  ? $e > Number.EPSILON && (H = !0)
                  : be < -Number.EPSILON
                  ? $e < -Number.EPSILON && (H = !0)
                  : Math.sign(ve) === Math.sign(Ze) && (H = !0),
                  H
                    ? ((me = -ve), (ue = be), (Re = Math.sqrt(A)))
                    : ((me = be), (ue = ve), (Re = Math.sqrt(A / 2)));
              }
              return new W(me / Re, ue / Re);
            }
            const z = [];
            for (
              let K = 0, Y = I.length, ie = Y - 1, me = K + 1;
              K < Y;
              K++, ie++, me++
            )
              ie === Y && (ie = 0),
                me === Y && (me = 0),
                (z[K] = J(I[K], I[ie], I[me]));
            const q = [];
            let ee,
              $ = z.concat();
            for (let K = 0, Y = D.length; K < Y; K++) {
              const ie = D[K];
              ee = [];
              for (
                let me = 0, ue = ie.length, Re = ue - 1, be = me + 1;
                me < ue;
                me++, Re++, be++
              )
                Re === ue && (Re = 0),
                  be === ue && (be = 0),
                  (ee[me] = J(ie[me], ie[Re], ie[be]));
              q.push(ee), ($ = $.concat(ee));
            }
            for (let K = 0; K < p; K++) {
              const Y = K / p,
                ie = f * Math.cos((Y * Math.PI) / 2),
                me = g * Math.sin((Y * Math.PI) / 2) + m;
              for (let ue = 0, Re = I.length; ue < Re; ue++) {
                const be = U(I[ue], z[ue], me);
                qe(be.x, be.y, -ie);
              }
              for (let ue = 0, Re = D.length; ue < Re; ue++) {
                const be = D[ue];
                ee = q[ue];
                for (let ve = 0, $e = be.length; ve < $e; ve++) {
                  const Ze = U(be[ve], ee[ve], me);
                  qe(Ze.x, Ze.y, -ie);
                }
              }
            }
            const te = g + m;
            for (let K = 0; K < N; K++) {
              const Y = d ? U(P[K], $[K], te) : P[K];
              M
                ? (C.copy(b.normals[0]).multiplyScalar(Y.x),
                  T.copy(b.binormals[0]).multiplyScalar(Y.y),
                  _.copy(v[0]).add(C).add(T),
                  qe(_.x, _.y, _.z))
                : qe(Y.x, Y.y, 0);
            }
            for (let K = 1; K <= u; K++)
              for (let Y = 0; Y < N; Y++) {
                const ie = d ? U(P[Y], $[Y], te) : P[Y];
                M
                  ? (C.copy(b.normals[K]).multiplyScalar(ie.x),
                    T.copy(b.binormals[K]).multiplyScalar(ie.y),
                    _.copy(v[K]).add(C).add(T),
                    qe(_.x, _.y, _.z))
                  : qe(ie.x, ie.y, (h / u) * K);
              }
            for (let K = p - 1; K >= 0; K--) {
              const Y = K / p,
                ie = f * Math.cos((Y * Math.PI) / 2),
                me = g * Math.sin((Y * Math.PI) / 2) + m;
              for (let ue = 0, Re = I.length; ue < Re; ue++) {
                const be = U(I[ue], z[ue], me);
                qe(be.x, be.y, h + ie);
              }
              for (let ue = 0, Re = D.length; ue < Re; ue++) {
                const be = D[ue];
                ee = q[ue];
                for (let ve = 0, $e = be.length; ve < $e; ve++) {
                  const Ze = U(be[ve], ee[ve], me);
                  M
                    ? qe(Ze.x, Ze.y + v[u - 1].y, v[u - 1].x + ie)
                    : qe(Ze.x, Ze.y, h + ie);
                }
              }
            }
            xe(), ye();
            function xe() {
              const K = i.length / 3;
              if (d) {
                let Y = 0,
                  ie = N * Y;
                for (let me = 0; me < V; me++) {
                  const ue = j[me];
                  Se(ue[2] + ie, ue[1] + ie, ue[0] + ie);
                }
                (Y = u + p * 2), (ie = N * Y);
                for (let me = 0; me < V; me++) {
                  const ue = j[me];
                  Se(ue[0] + ie, ue[1] + ie, ue[2] + ie);
                }
              } else {
                for (let Y = 0; Y < V; Y++) {
                  const ie = j[Y];
                  Se(ie[2], ie[1], ie[0]);
                }
                for (let Y = 0; Y < V; Y++) {
                  const ie = j[Y];
                  Se(ie[0] + N * u, ie[1] + N * u, ie[2] + N * u);
                }
              }
              n.addGroup(K, i.length / 3 - K, 0);
            }
            function ye() {
              const K = i.length / 3;
              let Y = 0;
              k(I, Y), (Y += I.length);
              for (let ie = 0, me = D.length; ie < me; ie++) {
                const ue = D[ie];
                k(ue, Y), (Y += ue.length);
              }
              n.addGroup(K, i.length / 3 - K, 1);
            }
            function k(K, Y) {
              let ie = K.length;
              for (; --ie >= 0; ) {
                const me = ie;
                let ue = ie - 1;
                ue < 0 && (ue = K.length - 1);
                for (let Re = 0, be = u + p * 2; Re < be; Re++) {
                  const ve = N * Re,
                    $e = N * (Re + 1),
                    Ze = Y + me + ve,
                    A = Y + ue + ve,
                    w = Y + ue + $e,
                    H = Y + me + $e;
                  Pe(Ze, A, w, H);
                }
              }
            }
            function qe(K, Y, ie) {
              l.push(K), l.push(Y), l.push(ie);
            }
            function Se(K, Y, ie) {
              se(K), se(Y), se(ie);
              const me = i.length / 3,
                ue = y.generateTopUV(n, i, me - 3, me - 2, me - 1);
              ze(ue[0]), ze(ue[1]), ze(ue[2]);
            }
            function Pe(K, Y, ie, me) {
              se(K), se(Y), se(me), se(Y), se(ie), se(me);
              const ue = i.length / 3,
                Re = y.generateSideWallUV(n, i, ue - 6, ue - 3, ue - 2, ue - 1);
              ze(Re[0]), ze(Re[1]), ze(Re[3]), ze(Re[1]), ze(Re[2]), ze(Re[3]);
            }
            function se(K) {
              i.push(l[K * 3 + 0]), i.push(l[K * 3 + 1]), i.push(l[K * 3 + 2]);
            }
            function ze(K) {
              r.push(K.x), r.push(K.y);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
          return s0(t, n, e);
        }
        static fromJSON(e, t) {
          const n = [];
          for (let r = 0, s = e.shapes.length; r < s; r++) {
            const a = t[e.shapes[r]];
            n.push(a);
          }
          const i = e.options.extrudePath;
          return (
            i !== void 0 &&
              (e.options.extrudePath = new Nl[i.type]().fromJSON(i)),
            new un(n, e.options)
          );
        }
      }
      const r0 = {
        generateTopUV: function (o, e, t, n, i) {
          const r = e[t * 3],
            s = e[t * 3 + 1],
            a = e[n * 3],
            l = e[n * 3 + 1],
            c = e[i * 3],
            u = e[i * 3 + 1];
          return [new W(r, s), new W(a, l), new W(c, u)];
        },
        generateSideWallUV: function (o, e, t, n, i, r) {
          const s = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[n * 3],
            u = e[n * 3 + 1],
            h = e[n * 3 + 2],
            d = e[i * 3],
            f = e[i * 3 + 1],
            g = e[i * 3 + 2],
            m = e[r * 3],
            p = e[r * 3 + 1],
            x = e[r * 3 + 2];
          return Math.abs(a - u) < Math.abs(s - c)
            ? [
                new W(s, 1 - l),
                new W(c, 1 - h),
                new W(d, 1 - g),
                new W(m, 1 - x),
              ]
            : [
                new W(a, 1 - l),
                new W(u, 1 - h),
                new W(f, 1 - g),
                new W(p, 1 - x),
              ];
        },
      };
      function s0(o, e, t) {
        if (((t.shapes = []), Array.isArray(o)))
          for (let n = 0, i = o.length; n < i; n++) {
            const r = o[n];
            t.shapes.push(r.uuid);
          }
        else t.shapes.push(o.uuid);
        return (
          e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
          t
        );
      }
      class _r extends cn {
        constructor(e = 1, t = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = [
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              0,
              0,
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              n,
              0,
              -1,
              n,
              0,
              1,
              -n,
              0,
              -1,
              -n,
              0,
              1,
            ],
            r = [
              0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
              4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6,
              8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ];
          super(i, r, e, t),
            (this.type = "IcosahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
          return new _r(e.radius, e.detail);
        }
      }
      class Ri extends cn {
        constructor(e = 1, t = 0) {
          const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            i = [
              0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1,
              4, 2,
            ];
          super(n, i, e, t),
            (this.type = "OctahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
          return new Ri(e.radius, e.detail);
        }
      }
      class vr extends _e {
        constructor(e = 0.5, t = 1, n = 8, i = 1, r = 0, s = Math.PI * 2) {
          super(),
            (this.type = "RingGeometry"),
            (this.parameters = {
              innerRadius: e,
              outerRadius: t,
              thetaSegments: n,
              phiSegments: i,
              thetaStart: r,
              thetaLength: s,
            }),
            (n = Math.max(3, n)),
            (i = Math.max(1, i));
          const a = [],
            l = [],
            c = [],
            u = [];
          let h = e;
          const d = (t - e) / i,
            f = new S(),
            g = new W();
          for (let m = 0; m <= i; m++) {
            for (let p = 0; p <= n; p++) {
              const x = r + (p / n) * s;
              (f.x = h * Math.cos(x)),
                (f.y = h * Math.sin(x)),
                l.push(f.x, f.y, f.z),
                c.push(0, 0, 1),
                (g.x = (f.x / t + 1) / 2),
                (g.y = (f.y / t + 1) / 2),
                u.push(g.x, g.y);
            }
            h += d;
          }
          for (let m = 0; m < i; m++) {
            const p = m * (n + 1);
            for (let x = 0; x < n; x++) {
              const y = x + p,
                v = y,
                M = y + n + 1,
                b = y + n + 2,
                T = y + 1;
              a.push(v, M, T), a.push(M, b, T);
            }
          }
          this.setIndex(a),
            this.setAttribute("position", new pe(l, 3)),
            this.setAttribute("normal", new pe(c, 3)),
            this.setAttribute("uv", new pe(u, 2));
        }
        static fromJSON(e) {
          return new vr(
            e.innerRadius,
            e.outerRadius,
            e.thetaSegments,
            e.phiSegments,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class Ci extends _e {
        constructor(
          e = new on([new W(0, 0.5), new W(-0.5, -0.5), new W(0.5, -0.5)]),
          t = 12
        ) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            r = [],
            s = [];
          let a = 0,
            l = 0;
          if (Array.isArray(e) === !1) c(e);
          else
            for (let u = 0; u < e.length; u++)
              c(e[u]), this.addGroup(a, l, u), (a += l), (l = 0);
          this.setIndex(n),
            this.setAttribute("position", new pe(i, 3)),
            this.setAttribute("normal", new pe(r, 3)),
            this.setAttribute("uv", new pe(s, 2));
          function c(u) {
            const h = i.length / 3,
              d = u.extractPoints(t);
            let f = d.shape;
            const g = d.holes;
            an.isClockWise(f) === !1 && (f = f.reverse());
            for (let p = 0, x = g.length; p < x; p++) {
              const y = g[p];
              an.isClockWise(y) === !0 && (g[p] = y.reverse());
            }
            const m = an.triangulateShape(f, g);
            for (let p = 0, x = g.length; p < x; p++) {
              const y = g[p];
              f = f.concat(y);
            }
            for (let p = 0, x = f.length; p < x; p++) {
              const y = f[p];
              i.push(y.x, y.y, 0), r.push(0, 0, 1), s.push(y.x, y.y);
            }
            for (let p = 0, x = m.length; p < x; p++) {
              const y = m[p],
                v = y[0] + h,
                M = y[1] + h,
                b = y[2] + h;
              n.push(v, M, b), (l += 3);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes;
          return o0(t, e);
        }
        static fromJSON(e, t) {
          const n = [];
          for (let i = 0, r = e.shapes.length; i < r; i++) {
            const s = t[e.shapes[i]];
            n.push(s);
          }
          return new Ci(n, e.curveSegments);
        }
      }
      function o0(o, e) {
        if (((e.shapes = []), Array.isArray(o)))
          for (let t = 0, n = o.length; t < n; t++) {
            const i = o[t];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(o.uuid);
        return e;
      }
      class Li extends _e {
        constructor(
          e = 1,
          t = 32,
          n = 16,
          i = 0,
          r = Math.PI * 2,
          s = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: e,
              widthSegments: t,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: s,
              thetaLength: a,
            }),
            (t = Math.max(3, Math.floor(t))),
            (n = Math.max(2, Math.floor(n)));
          const l = Math.min(s + a, Math.PI);
          let c = 0;
          const u = [],
            h = new S(),
            d = new S(),
            f = [],
            g = [],
            m = [],
            p = [];
          for (let x = 0; x <= n; x++) {
            const y = [],
              v = x / n;
            let M = 0;
            x == 0 && s == 0
              ? (M = 0.5 / t)
              : x == n && l == Math.PI && (M = -0.5 / t);
            for (let b = 0; b <= t; b++) {
              const T = b / t;
              (h.x = -e * Math.cos(i + T * r) * Math.sin(s + v * a)),
                (h.y = e * Math.cos(s + v * a)),
                (h.z = e * Math.sin(i + T * r) * Math.sin(s + v * a)),
                g.push(h.x, h.y, h.z),
                d.copy(h).normalize(),
                m.push(d.x, d.y, d.z),
                p.push(T + M, 1 - v),
                y.push(c++);
            }
            u.push(y);
          }
          for (let x = 0; x < n; x++)
            for (let y = 0; y < t; y++) {
              const v = u[x][y + 1],
                M = u[x][y],
                b = u[x + 1][y],
                T = u[x + 1][y + 1];
              (x !== 0 || s > 0) && f.push(v, M, T),
                (x !== n - 1 || l < Math.PI) && f.push(M, b, T);
            }
          this.setIndex(f),
            this.setAttribute("position", new pe(g, 3)),
            this.setAttribute("normal", new pe(m, 3)),
            this.setAttribute("uv", new pe(p, 2));
        }
        static fromJSON(e) {
          return new Li(
            e.radius,
            e.widthSegments,
            e.heightSegments,
            e.phiStart,
            e.phiLength,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class Mr extends cn {
        constructor(e = 1, t = 0) {
          const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(n, i, e, t),
            (this.type = "TetrahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
          return new Mr(e.radius, e.detail);
        }
      }
      class br extends _e {
        constructor(e = 1, t = 0.4, n = 8, i = 6, r = Math.PI * 2) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const s = [],
            a = [],
            l = [],
            c = [],
            u = new S(),
            h = new S(),
            d = new S();
          for (let f = 0; f <= n; f++)
            for (let g = 0; g <= i; g++) {
              const m = (g / i) * r,
                p = (f / n) * Math.PI * 2;
              (h.x = (e + t * Math.cos(p)) * Math.cos(m)),
                (h.y = (e + t * Math.cos(p)) * Math.sin(m)),
                (h.z = t * Math.sin(p)),
                a.push(h.x, h.y, h.z),
                (u.x = e * Math.cos(m)),
                (u.y = e * Math.sin(m)),
                d.subVectors(h, u).normalize(),
                l.push(d.x, d.y, d.z),
                c.push(g / i),
                c.push(f / n);
            }
          for (let f = 1; f <= n; f++)
            for (let g = 1; g <= i; g++) {
              const m = (i + 1) * f + g - 1,
                p = (i + 1) * (f - 1) + g - 1,
                x = (i + 1) * (f - 1) + g,
                y = (i + 1) * f + g;
              s.push(m, p, y), s.push(p, x, y);
            }
          this.setIndex(s),
            this.setAttribute("position", new pe(a, 3)),
            this.setAttribute("normal", new pe(l, 3)),
            this.setAttribute("uv", new pe(c, 2));
        }
        static fromJSON(e) {
          return new br(
            e.radius,
            e.tube,
            e.radialSegments,
            e.tubularSegments,
            e.arc
          );
        }
      }
      class wr extends _e {
        constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, s = 3) {
          super(),
            (this.type = "TorusKnotGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              tubularSegments: n,
              radialSegments: i,
              p: r,
              q: s,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const a = [],
            l = [],
            c = [],
            u = [],
            h = new S(),
            d = new S(),
            f = new S(),
            g = new S(),
            m = new S(),
            p = new S(),
            x = new S();
          for (let v = 0; v <= n; ++v) {
            const M = (v / n) * r * Math.PI * 2;
            y(M, r, s, e, f),
              y(M + 0.01, r, s, e, g),
              p.subVectors(g, f),
              x.addVectors(g, f),
              m.crossVectors(p, x),
              x.crossVectors(m, p),
              m.normalize(),
              x.normalize();
            for (let b = 0; b <= i; ++b) {
              const T = (b / i) * Math.PI * 2,
                C = -t * Math.cos(T),
                _ = t * Math.sin(T);
              (h.x = f.x + (C * x.x + _ * m.x)),
                (h.y = f.y + (C * x.y + _ * m.y)),
                (h.z = f.z + (C * x.z + _ * m.z)),
                l.push(h.x, h.y, h.z),
                d.subVectors(h, f).normalize(),
                c.push(d.x, d.y, d.z),
                u.push(v / n),
                u.push(b / i);
            }
          }
          for (let v = 1; v <= n; v++)
            for (let M = 1; M <= i; M++) {
              const b = (i + 1) * (v - 1) + (M - 1),
                T = (i + 1) * v + (M - 1),
                C = (i + 1) * v + M,
                _ = (i + 1) * (v - 1) + M;
              a.push(b, T, _), a.push(T, C, _);
            }
          this.setIndex(a),
            this.setAttribute("position", new pe(l, 3)),
            this.setAttribute("normal", new pe(c, 3)),
            this.setAttribute("uv", new pe(u, 2));
          function y(v, M, b, T, C) {
            const _ = Math.cos(v),
              R = Math.sin(v),
              P = (b / M) * v,
              D = Math.cos(P);
            (C.x = T * (2 + D) * 0.5 * _),
              (C.y = T * (2 + D) * R * 0.5),
              (C.z = T * Math.sin(P) * 0.5);
          }
        }
        static fromJSON(e) {
          return new wr(
            e.radius,
            e.tube,
            e.tubularSegments,
            e.radialSegments,
            e.p,
            e.q
          );
        }
      }
      class Sr extends _e {
        constructor(
          e = new Go(new S(-1, -1, 0), new S(-1, 1, 0), new S(1, 1, 0)),
          t = 64,
          n = 1,
          i = 8,
          r = !1
        ) {
          super(),
            (this.type = "TubeGeometry"),
            (this.parameters = {
              path: e,
              tubularSegments: t,
              radius: n,
              radialSegments: i,
              closed: r,
            });
          const s = e.computeFrenetFrames(t, r);
          (this.tangents = s.tangents),
            (this.normals = s.normals),
            (this.binormals = s.binormals);
          const a = new S(),
            l = new S(),
            c = new W();
          let u = new S();
          const h = [],
            d = [],
            f = [],
            g = [];
          m(),
            this.setIndex(g),
            this.setAttribute("position", new pe(h, 3)),
            this.setAttribute("normal", new pe(d, 3)),
            this.setAttribute("uv", new pe(f, 2));
          function m() {
            for (let v = 0; v < t; v++) p(v);
            p(r === !1 ? t : 0), y(), x();
          }
          function p(v) {
            u = e.getPointAt(v / t, u);
            const M = s.normals[v],
              b = s.binormals[v];
            for (let T = 0; T <= i; T++) {
              const C = (T / i) * Math.PI * 2,
                _ = Math.sin(C),
                R = -Math.cos(C);
              (l.x = R * M.x + _ * b.x),
                (l.y = R * M.y + _ * b.y),
                (l.z = R * M.z + _ * b.z),
                l.normalize(),
                d.push(l.x, l.y, l.z),
                (a.x = u.x + n * l.x),
                (a.y = u.y + n * l.y),
                (a.z = u.z + n * l.z),
                h.push(a.x, a.y, a.z);
            }
          }
          function x() {
            for (let v = 1; v <= t; v++)
              for (let M = 1; M <= i; M++) {
                const b = (i + 1) * (v - 1) + (M - 1),
                  T = (i + 1) * v + (M - 1),
                  C = (i + 1) * v + M,
                  _ = (i + 1) * (v - 1) + M;
                g.push(b, T, _), g.push(T, C, _);
              }
          }
          function y() {
            for (let v = 0; v <= t; v++)
              for (let M = 0; M <= i; M++)
                (c.x = v / t), (c.y = M / i), f.push(c.x, c.y);
          }
        }
        toJSON() {
          const e = super.toJSON();
          return (e.path = this.parameters.path.toJSON()), e;
        }
        static fromJSON(e) {
          return new Sr(
            new Nl[e.path.type]().fromJSON(e.path),
            e.tubularSegments,
            e.radius,
            e.radialSegments,
            e.closed
          );
        }
      }
      class Ul extends _e {
        constructor(e = null) {
          if (
            (super(),
            (this.type = "WireframeGeometry"),
            (this.parameters = { geometry: e }),
            e !== null)
          ) {
            const t = [],
              n = new Set(),
              i = new S(),
              r = new S();
            if (e.index !== null) {
              const s = e.attributes.position,
                a = e.index;
              let l = e.groups;
              l.length === 0 &&
                (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
              for (let c = 0, u = l.length; c < u; ++c) {
                const h = l[c],
                  d = h.start,
                  f = h.count;
                for (let g = d, m = d + f; g < m; g += 3)
                  for (let p = 0; p < 3; p++) {
                    const x = a.getX(g + p),
                      y = a.getX(g + ((p + 1) % 3));
                    i.fromBufferAttribute(s, x),
                      r.fromBufferAttribute(s, y),
                      cu(i, r, n) === !0 &&
                        (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
                  }
              }
            } else {
              const s = e.attributes.position;
              for (let a = 0, l = s.count / 3; a < l; a++)
                for (let c = 0; c < 3; c++) {
                  const u = 3 * a + c,
                    h = 3 * a + ((c + 1) % 3);
                  i.fromBufferAttribute(s, u),
                    r.fromBufferAttribute(s, h),
                    cu(i, r, n) === !0 &&
                      (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
                }
            }
            this.setAttribute("position", new pe(t, 3));
          }
        }
      }
      function cu(o, e, t) {
        const n = `${o.x},${o.y},${o.z}-${e.x},${e.y},${e.z}`,
          i = `${e.x},${e.y},${e.z}-${o.x},${o.y},${o.z}`;
        return t.has(n) === !0 || t.has(i) === !0
          ? !1
          : (t.add(n), t.add(i), !0);
      }
      var uu = Object.freeze({
        __proto__: null,
        BoxGeometry: bn,
        BoxBufferGeometry: bn,
        CapsuleGeometry: mr,
        CapsuleBufferGeometry: mr,
        CircleGeometry: gr,
        CircleBufferGeometry: gr,
        ConeGeometry: xr,
        ConeBufferGeometry: xr,
        CylinderGeometry: Jn,
        CylinderBufferGeometry: Jn,
        DodecahedronGeometry: yr,
        DodecahedronBufferGeometry: yr,
        EdgesGeometry: Ol,
        ExtrudeGeometry: un,
        ExtrudeBufferGeometry: un,
        IcosahedronGeometry: _r,
        IcosahedronBufferGeometry: _r,
        LatheGeometry: Ai,
        LatheBufferGeometry: Ai,
        OctahedronGeometry: Ri,
        OctahedronBufferGeometry: Ri,
        PlaneGeometry: Ti,
        PlaneBufferGeometry: Ti,
        PolyhedronGeometry: cn,
        PolyhedronBufferGeometry: cn,
        RingGeometry: vr,
        RingBufferGeometry: vr,
        ShapeGeometry: Ci,
        ShapeBufferGeometry: Ci,
        SphereGeometry: Li,
        SphereBufferGeometry: Li,
        TetrahedronGeometry: Mr,
        TetrahedronBufferGeometry: Mr,
        TorusGeometry: br,
        TorusBufferGeometry: br,
        TorusKnotGeometry: wr,
        TorusKnotBufferGeometry: wr,
        TubeGeometry: Sr,
        TubeBufferGeometry: Sr,
        WireframeGeometry: Ul,
      });
      class zl extends et {
        constructor(e) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new ne(0)),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this
          );
        }
      }
      zl.prototype.isShadowMaterial = !0;
      class Hl extends zt {
        constructor(e) {
          super(e), (this.type = "RawShaderMaterial");
        }
      }
      Hl.prototype.isRawShaderMaterial = !0;
      class Di extends et {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new ne(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ne(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Kn),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      Di.prototype.isMeshStandardMaterial = !0;
      class En extends Di {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new W(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return lt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.sheenColor = new ne(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new ne(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new ne(1, 1, 1)),
            (this.specularColorMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.ior = e.ior),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      En.prototype.isMeshPhysicalMaterial = !0;
      class Gl extends et {
        constructor(e) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new ne(16777215)),
            (this.specular = new ne(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ne(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Kn),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = hs),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      Gl.prototype.isMeshPhongMaterial = !0;
      class kl extends et {
        constructor(e) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new ne(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ne(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Kn),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      kl.prototype.isMeshToonMaterial = !0;
      class Vl extends et {
        constructor(e) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Kn),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Vl.prototype.isMeshNormalMaterial = !0;
      class Wl extends et {
        constructor(e) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new ne(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ne(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = hs),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      Wl.prototype.isMeshLambertMaterial = !0;
      class ql extends et {
        constructor(e) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new ne(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Kn),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      ql.prototype.isMeshMatcapMaterial = !0;
      class Xl extends gt {
        constructor(e) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        }
      }
      Xl.prototype.isLineDashedMaterial = !0;
      const a0 = {
        ShadowMaterial: zl,
        SpriteMaterial: No,
        RawShaderMaterial: Hl,
        ShaderMaterial: zt,
        PointsMaterial: ni,
        MeshPhysicalMaterial: En,
        MeshStandardMaterial: Di,
        MeshPhongMaterial: Gl,
        MeshToonMaterial: kl,
        MeshNormalMaterial: Vl,
        MeshLambertMaterial: Wl,
        MeshDepthMaterial: Fo,
        MeshDistanceMaterial: Bo,
        MeshBasicMaterial: Ct,
        MeshMatcapMaterial: ql,
        LineDashedMaterial: Xl,
        LineBasicMaterial: gt,
        Material: et,
      };
      et.fromType = function (o) {
        return new a0[o]();
      };
      const Qe = {
        arraySlice: function (o, e, t) {
          return Qe.isTypedArray(o)
            ? new o.constructor(o.subarray(e, t !== void 0 ? t : o.length))
            : o.slice(e, t);
        },
        convertArray: function (o, e, t) {
          return !o || (!t && o.constructor === e)
            ? o
            : typeof e.BYTES_PER_ELEMENT == "number"
            ? new e(o)
            : Array.prototype.slice.call(o);
        },
        isTypedArray: function (o) {
          return ArrayBuffer.isView(o) && !(o instanceof DataView);
        },
        getKeyframeOrder: function (o) {
          function e(i, r) {
            return o[i] - o[r];
          }
          const t = o.length,
            n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = i;
          return n.sort(e), n;
        },
        sortedArray: function (o, e, t) {
          const n = o.length,
            i = new o.constructor(n);
          for (let r = 0, s = 0; s !== n; ++r) {
            const a = t[r] * e;
            for (let l = 0; l !== e; ++l) i[s++] = o[a + l];
          }
          return i;
        },
        flattenJSON: function (o, e, t, n) {
          let i = 1,
            r = o[0];
          for (; r !== void 0 && r[n] === void 0; ) r = o[i++];
          if (r === void 0) return;
          let s = r[n];
          if (s !== void 0)
            if (Array.isArray(s))
              do
                (s = r[n]),
                  s !== void 0 && (e.push(r.time), t.push.apply(t, s)),
                  (r = o[i++]);
              while (r !== void 0);
            else if (s.toArray !== void 0)
              do
                (s = r[n]),
                  s !== void 0 && (e.push(r.time), s.toArray(t, t.length)),
                  (r = o[i++]);
              while (r !== void 0);
            else
              do
                (s = r[n]),
                  s !== void 0 && (e.push(r.time), t.push(s)),
                  (r = o[i++]);
              while (r !== void 0);
        },
        subclip: function (o, e, t, n, i = 30) {
          const r = o.clone();
          r.name = e;
          const s = [];
          for (let l = 0; l < r.tracks.length; ++l) {
            const c = r.tracks[l],
              u = c.getValueSize(),
              h = [],
              d = [];
            for (let f = 0; f < c.times.length; ++f) {
              const g = c.times[f] * i;
              if (!(g < t || g >= n)) {
                h.push(c.times[f]);
                for (let m = 0; m < u; ++m) d.push(c.values[f * u + m]);
              }
            }
            h.length !== 0 &&
              ((c.times = Qe.convertArray(h, c.times.constructor)),
              (c.values = Qe.convertArray(d, c.values.constructor)),
              s.push(c));
          }
          r.tracks = s;
          let a = 1 / 0;
          for (let l = 0; l < r.tracks.length; ++l)
            a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
          for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
          return r.resetDuration(), r;
        },
        makeClipAdditive: function (o, e = 0, t = o, n = 30) {
          n <= 0 && (n = 30);
          const i = t.tracks.length,
            r = e / n;
          for (let s = 0; s < i; ++s) {
            const a = t.tracks[s],
              l = a.ValueTypeName;
            if (l === "bool" || l === "string") continue;
            const c = o.tracks.find(function (x) {
              return x.name === a.name && x.ValueTypeName === l;
            });
            if (c === void 0) continue;
            let u = 0;
            const h = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (u = h / 3);
            let d = 0;
            const f = c.getValueSize();
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (d = f / 3);
            const g = a.times.length - 1;
            let m;
            if (r <= a.times[0]) {
              const x = u,
                y = h - u;
              m = Qe.arraySlice(a.values, x, y);
            } else if (r >= a.times[g]) {
              const x = g * h + u,
                y = x + h - u;
              m = Qe.arraySlice(a.values, x, y);
            } else {
              const x = a.createInterpolant(),
                y = u,
                v = h - u;
              x.evaluate(r), (m = Qe.arraySlice(x.resultBuffer, y, v));
            }
            l === "quaternion" &&
              new yt().fromArray(m).normalize().conjugate().toArray(m);
            const p = c.times.length;
            for (let x = 0; x < p; ++x) {
              const y = x * f + d;
              if (l === "quaternion")
                yt.multiplyQuaternionsFlat(c.values, y, m, 0, c.values, y);
              else {
                const v = f - d * 2;
                for (let M = 0; M < v; ++M) c.values[y + M] -= m[M];
              }
            }
          }
          return (o.blendMode = Sl), o;
        },
      };
      class hn {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let s;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (i === void 0) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  s = t.length;
                  break n;
                }
                if (!(e >= r)) {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let l = n - 2; ; ) {
                    if (r === void 0)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === l) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (s = n), (n = 0);
                  break n;
                }
                break e;
              }
              for (; n < s; ) {
                const a = (n + s) >>> 1;
                e < t[a] ? (s = a) : (n = a + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), r === void 0))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (i === void 0)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let s = 0; s !== i; ++s) t[s] = n[r + s];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      hn.prototype.beforeStart_ = hn.prototype.copySampleValue_;
      hn.prototype.afterEnd_ = hn.prototype.copySampleValue_;
      class _d extends hn {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: gi, endingEnd: gi });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            s = e + 1,
            a = i[r],
            l = i[s];
          if (a === void 0)
            switch (this.getSettings_().endingStart) {
              case xi:
                (r = e), (a = 2 * t - n);
                break;
              case is:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (l === void 0)
            switch (this.getSettings_().endingEnd) {
              case xi:
                (s = e), (l = 2 * n - t);
                break;
              case is:
                (s = 1), (l = n + i[1] - i[0]);
                break;
              default:
                (s = e - 1), (l = t);
            }
          const c = (n - t) * 0.5,
            u = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - n)),
            (this._offsetPrev = r * u),
            (this._offsetNext = s * u);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = this._offsetPrev,
            h = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            g = (n - t) / (i - t),
            m = g * g,
            p = m * g,
            x = -d * p + 2 * d * m - d * g,
            y = (1 + d) * p + (-1.5 - 2 * d) * m + (-0.5 + d) * g + 1,
            v = (-1 - f) * p + (1.5 + f) * m + 0.5 * g,
            M = f * p - f * m;
          for (let b = 0; b !== a; ++b)
            r[b] = x * s[u + b] + y * s[c + b] + v * s[l + b] + M * s[h + b];
          return r;
        }
      }
      class Jl extends hn {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = (n - t) / (i - t),
            h = 1 - u;
          for (let d = 0; d !== a; ++d) r[d] = s[c + d] * h + s[l + d] * u;
          return r;
        }
      }
      class vd extends hn {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class jt {
        constructor(e, t, n, i) {
          if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = Qe.convertArray(t, this.TimeBufferType)),
            (this.values = Qe.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: Qe.convertArray(e.times, Array),
              values: Qe.convertArray(e.values, Array),
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new vd(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new Jl(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new _d(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case ur:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case Si:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case yo:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return ur;
            case this.InterpolantFactoryMethodLinear:
              return Si;
            case this.InterpolantFactoryMethodSmooth:
              return yo;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            s = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; s !== -1 && n[s] > t; ) --s;
          if ((++s, r !== 0 || s !== i)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
            const a = this.getValueSize();
            (this.times = Qe.arraySlice(n, r, s)),
              (this.values = Qe.arraySlice(this.values, r * a, s * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          r === 0 &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let s = null;
          for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l
              ),
                (e = !1);
              break;
            }
            if (s !== null && s > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                s
              ),
                (e = !1);
              break;
            }
            s = l;
          }
          if (i !== void 0 && Qe.isTypedArray(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
              const c = i[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = Qe.arraySlice(this.times),
            t = Qe.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === yo,
            r = e.length - 1;
          let s = 1;
          for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a],
              u = e[a + 1];
            if (c !== u && (a !== 1 || c !== e[0]))
              if (i) l = !0;
              else {
                const h = a * n,
                  d = h - n,
                  f = h + n;
                for (let g = 0; g !== n; ++g) {
                  const m = t[h + g];
                  if (m !== t[d + g] || m !== t[f + g]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== s) {
                e[s] = e[a];
                const h = a * n,
                  d = s * n;
                for (let f = 0; f !== n; ++f) t[d + f] = t[h + f];
              }
              ++s;
            }
          }
          if (r > 0) {
            e[s] = e[r];
            for (let a = r * n, l = s * n, c = 0; c !== n; ++c)
              t[l + c] = t[a + c];
            ++s;
          }
          return (
            s !== e.length
              ? ((this.times = Qe.arraySlice(e, 0, s)),
                (this.values = Qe.arraySlice(t, 0, s * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = Qe.arraySlice(this.times, 0),
            t = Qe.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, e, t);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      jt.prototype.TimeBufferType = Float32Array;
      jt.prototype.ValueBufferType = Float32Array;
      jt.prototype.DefaultInterpolation = Si;
      class Fi extends jt {}
      Fi.prototype.ValueTypeName = "bool";
      Fi.prototype.ValueBufferType = Array;
      Fi.prototype.DefaultInterpolation = ur;
      Fi.prototype.InterpolantFactoryMethodLinear = void 0;
      Fi.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Yl extends jt {}
      Yl.prototype.ValueTypeName = "color";
      class Tr extends jt {}
      Tr.prototype.ValueTypeName = "number";
      class Md extends hn {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            l = (n - t) / (i - t);
          let c = e * a;
          for (let u = c + a; c !== u; c += 4)
            yt.slerpFlat(r, 0, s, c - a, s, c, l);
          return r;
        }
      }
      class jn extends jt {
        InterpolantFactoryMethodLinear(e) {
          return new Md(this.times, this.values, this.getValueSize(), e);
        }
      }
      jn.prototype.ValueTypeName = "quaternion";
      jn.prototype.DefaultInterpolation = Si;
      jn.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Bi extends jt {}
      Bi.prototype.ValueTypeName = "string";
      Bi.prototype.ValueBufferType = Array;
      Bi.prototype.DefaultInterpolation = ur;
      Bi.prototype.InterpolantFactoryMethodLinear = void 0;
      Bi.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Er extends jt {}
      Er.prototype.ValueTypeName = "vector";
      class Ar {
        constructor(e, t = -1, n, i = Ao) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = Bt()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let s = 0, a = n.length; s !== a; ++s) t.push(c0(n[s]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let r = 0, s = n.length; r !== s; ++r) t.push(jt.toJSON(n[r]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            s = [];
          for (let a = 0; a < r; a++) {
            let l = [],
              c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            const u = Qe.getKeyframeOrder(l);
            (l = Qe.sortedArray(l, 1, u)),
              (c = Qe.sortedArray(c, 1, u)),
              !i && l[0] === 0 && (l.push(r), c.push(c[0])),
              s.push(
                new Tr(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, s);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              u = c.name.match(r);
            if (u && u.length > 1) {
              const h = u[1];
              let d = i[h];
              d || (i[h] = d = []), d.push(c);
            }
          }
          const s = [];
          for (const a in i)
            s.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
          return s;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (h, d, f, g, m) {
              if (f.length !== 0) {
                const p = [],
                  x = [];
                Qe.flattenJSON(f, p, x, g),
                  p.length !== 0 && m.push(new h(d, p, x));
              }
            },
            i = [],
            r = e.name || "default",
            s = e.fps || 30,
            a = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let h = 0; h < c.length; h++) {
            const d = c[h].keys;
            if (!(!d || d.length === 0))
              if (d[0].morphTargets) {
                const f = {};
                let g;
                for (g = 0; g < d.length; g++)
                  if (d[g].morphTargets)
                    for (let m = 0; m < d[g].morphTargets.length; m++)
                      f[d[g].morphTargets[m]] = -1;
                for (const m in f) {
                  const p = [],
                    x = [];
                  for (let y = 0; y !== d[g].morphTargets.length; ++y) {
                    const v = d[g];
                    p.push(v.time), x.push(v.morphTarget === m ? 1 : 0);
                  }
                  i.push(new Tr(".morphTargetInfluence[" + m + "]", p, x));
                }
                l = f.length * s;
              } else {
                const f = ".bones[" + t[h].name + "]";
                n(Er, f + ".position", d, "pos", i),
                  n(jn, f + ".quaternion", d, "rot", i),
                  n(Er, f + ".scale", d, "scl", i);
              }
          }
          return i.length === 0 ? null : new this(r, l, i, a);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function l0(o) {
        switch (o.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Tr;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Er;
          case "color":
            return Yl;
          case "quaternion":
            return jn;
          case "bool":
          case "boolean":
            return Fi;
          case "string":
            return Bi;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + o);
      }
      function c0(o) {
        if (o.type === void 0)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = l0(o.type);
        if (o.times === void 0) {
          const t = [],
            n = [];
          Qe.flattenJSON(o.keys, t, n, "value"), (o.times = t), (o.values = n);
        }
        return e.parse !== void 0
          ? e.parse(o)
          : new e(o.name, o.times, o.values, o.interpolation);
      }
      const Pi = {
        enabled: !1,
        files: {},
        add: function (o, e) {
          this.enabled !== !1 && (this.files[o] = e);
        },
        get: function (o) {
          if (this.enabled !== !1) return this.files[o];
        },
        remove: function (o) {
          delete this.files[o];
        },
        clear: function () {
          this.files = {};
        },
      };
      class jl {
        constructor(e, t, n) {
          const i = this;
          let r = !1,
            s = 0,
            a = 0,
            l;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (u) {
              a++,
                r === !1 && i.onStart !== void 0 && i.onStart(u, s, a),
                (r = !0);
            }),
            (this.itemEnd = function (u) {
              s++,
                i.onProgress !== void 0 && i.onProgress(u, s, a),
                s === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
            }),
            (this.itemError = function (u) {
              i.onError !== void 0 && i.onError(u);
            }),
            (this.resolveURL = function (u) {
              return l ? l(u) : u;
            }),
            (this.setURLModifier = function (u) {
              return (l = u), this;
            }),
            (this.addHandler = function (u, h) {
              return c.push(u, h), this;
            }),
            (this.removeHandler = function (u) {
              const h = c.indexOf(u);
              return h !== -1 && c.splice(h, 2), this;
            }),
            (this.getHandler = function (u) {
              for (let h = 0, d = c.length; h < d; h += 2) {
                const f = c[h],
                  g = c[h + 1];
                if ((f.global && (f.lastIndex = 0), f.test(u))) return g;
              }
              return null;
            });
        }
      }
      const bd = new jl();
      class bt {
        constructor(e) {
          (this.manager = e !== void 0 ? e : bd),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      const xn = {};
      class Ht extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = Pi.get(e);
          if (r !== void 0)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(r), this.manager.itemEnd(e);
              }, 0),
              r
            );
          if (xn[e] !== void 0) {
            xn[e].push({ onLoad: t, onProgress: n, onError: i });
            return;
          }
          (xn[e] = []), xn[e].push({ onLoad: t, onProgress: n, onError: i });
          const s = new Request(e, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            l = this.responseType;
          fetch(s)
            .then((c) => {
              if (c.status === 200 || c.status === 0) {
                if (
                  (c.status === 0 &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  typeof ReadableStream == "undefined" ||
                    c.body === void 0 ||
                    c.body.getReader === void 0)
                )
                  return c;
                const u = xn[e],
                  h = c.body.getReader(),
                  d = c.headers.get("Content-Length"),
                  f = d ? parseInt(d) : 0,
                  g = f !== 0;
                let m = 0;
                const p = new ReadableStream({
                  start(x) {
                    y();
                    function y() {
                      h.read().then(({ done: v, value: M }) => {
                        if (v) x.close();
                        else {
                          m += M.byteLength;
                          const b = new ProgressEvent("progress", {
                            lengthComputable: g,
                            loaded: m,
                            total: f,
                          });
                          for (let T = 0, C = u.length; T < C; T++) {
                            const _ = u[T];
                            _.onProgress && _.onProgress(b);
                          }
                          x.enqueue(M), y();
                        }
                      });
                    }
                  },
                });
                return new Response(p);
              } else
                throw Error(
                  `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`
                );
            })
            .then((c) => {
              switch (l) {
                case "arraybuffer":
                  return c.arrayBuffer();
                case "blob":
                  return c.blob();
                case "document":
                  return c
                    .text()
                    .then((u) => new DOMParser().parseFromString(u, a));
                case "json":
                  return c.json();
                default:
                  if (a === void 0) return c.text();
                  {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a),
                      d = h && h[1] ? h[1].toLowerCase() : void 0,
                      f = new TextDecoder(d);
                    return c.arrayBuffer().then((g) => f.decode(g));
                  }
              }
            })
            .then((c) => {
              Pi.add(e, c);
              const u = xn[e];
              delete xn[e];
              for (let h = 0, d = u.length; h < d; h++) {
                const f = u[h];
                f.onLoad && f.onLoad(c);
              }
            })
            .catch((c) => {
              const u = xn[e];
              if (u === void 0) throw (this.manager.itemError(e), c);
              delete xn[e];
              for (let h = 0, d = u.length; h < d; h++) {
                const f = u[h];
                f.onError && f.onError(c);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class u0 extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = new Ht(this.manager);
          s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              function (a) {
                try {
                  t(r.parse(JSON.parse(a)));
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e) {
          const t = [];
          for (let n = 0; n < e.length; n++) {
            const i = Ar.parse(e[n]);
            t.push(i);
          }
          return t;
        }
      }
      class h0 extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = [],
            a = new Pl(),
            l = new Ht(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(r.withCredentials);
          let c = 0;
          function u(h) {
            l.load(
              e[h],
              function (d) {
                const f = r.parse(d, !0);
                (s[h] = {
                  width: f.width,
                  height: f.height,
                  format: f.format,
                  mipmaps: f.mipmaps,
                }),
                  (c += 1),
                  c === 6 &&
                    (f.mipmapCount === 1 && (a.minFilter = tt),
                    (a.image = s),
                    (a.format = f.format),
                    (a.needsUpdate = !0),
                    t && t(a));
              },
              n,
              i
            );
          }
          if (Array.isArray(e)) for (let h = 0, d = e.length; h < d; ++h) u(h);
          else
            l.load(
              e,
              function (h) {
                const d = r.parse(h, !0);
                if (d.isCubemap) {
                  const f = d.mipmaps.length / d.mipmapCount;
                  for (let g = 0; g < f; g++) {
                    s[g] = { mipmaps: [] };
                    for (let m = 0; m < d.mipmapCount; m++)
                      s[g].mipmaps.push(d.mipmaps[g * d.mipmapCount + m]),
                        (s[g].format = d.format),
                        (s[g].width = d.width),
                        (s[g].height = d.height);
                  }
                  a.image = s;
                } else
                  (a.image.width = d.width),
                    (a.image.height = d.height),
                    (a.mipmaps = d.mipmaps);
                d.mipmapCount === 1 && (a.minFilter = tt),
                  (a.format = d.format),
                  (a.needsUpdate = !0),
                  t && t(a);
              },
              n,
              i
            );
          return a;
        }
      }
      class cs extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            s = Pi.get(e);
          if (s !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(s), r.manager.itemEnd(e);
              }, 0),
              s
            );
          const a = ss("img");
          function l() {
            u(), Pi.add(e, this), t && t(this), r.manager.itemEnd(e);
          }
          function c(h) {
            u(), i && i(h), r.manager.itemError(e), r.manager.itemEnd(e);
          }
          function u() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            e.slice(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class wd extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Lr(),
            s = new cs(this.manager);
          s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
          let a = 0;
          function l(c) {
            s.load(
              e[c],
              function (u) {
                (r.images[c] = u),
                  a++,
                  a === 6 && ((r.needsUpdate = !0), t && t(r));
              },
              void 0,
              i
            );
          }
          for (let c = 0; c < e.length; ++c) l(c);
          return r;
        }
      }
      class Sd extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = new bi(),
            a = new Ht(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (l) {
                const c = r.parse(l);
                !c ||
                  (c.image !== void 0
                    ? (s.image = c.image)
                    : c.data !== void 0 &&
                      ((s.image.width = c.width),
                      (s.image.height = c.height),
                      (s.image.data = c.data)),
                  (s.wrapS = c.wrapS !== void 0 ? c.wrapS : Mt),
                  (s.wrapT = c.wrapT !== void 0 ? c.wrapT : Mt),
                  (s.magFilter = c.magFilter !== void 0 ? c.magFilter : tt),
                  (s.minFilter = c.minFilter !== void 0 ? c.minFilter : tt),
                  (s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
                  c.encoding !== void 0 && (s.encoding = c.encoding),
                  c.flipY !== void 0 && (s.flipY = c.flipY),
                  c.format !== void 0 && (s.format = c.format),
                  c.type !== void 0 && (s.type = c.type),
                  c.mipmaps !== void 0 &&
                    ((s.mipmaps = c.mipmaps), (s.minFilter = Sn)),
                  c.mipmapCount === 1 && (s.minFilter = tt),
                  c.generateMipmaps !== void 0 &&
                    (s.generateMipmaps = c.generateMipmaps),
                  (s.needsUpdate = !0),
                  t && t(s, c));
              },
              n,
              i
            ),
            s
          );
        }
      }
      class Kl extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new st(),
            s = new cs(this.manager);
          return (
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(
              e,
              function (a) {
                (r.image = a), (r.needsUpdate = !0), t !== void 0 && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class Yt extends Ne {
        constructor(e, t = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new ne(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      Yt.prototype.isLight = !0;
      class Zl extends Yt {
        constructor(e, t, n) {
          super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Ne.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new ne(t));
        }
        copy(e) {
          return (
            Yt.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
          );
        }
      }
      Zl.prototype.isHemisphereLight = !0;
      const hu = new fe(),
        du = new S(),
        fu = new S();
      class $l {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new W(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new fe()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new ps()),
            (this._frameExtents = new W(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Je(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          du.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(du),
            fu.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(fu),
            t.updateMatrixWorld(),
            hu.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(hu),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class Td extends $l {
        constructor() {
          super(new pt(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = rs * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n !== t.fov || i !== t.aspect || r !== t.far) &&
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      Td.prototype.isSpotLightShadow = !0;
      class Wo extends Yt {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
          super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(Ne.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ne()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = s),
            (this.shadow = new Td());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Wo.prototype.isSpotLight = !0;
      const pu = new fe(),
        qr = new S(),
        Ca = new S();
      class Ed extends $l {
        constructor() {
          super(new pt(90, 1, 0.5, 500)),
            (this._frameExtents = new W(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Je(2, 1, 1, 1),
              new Je(0, 1, 1, 1),
              new Je(3, 1, 1, 1),
              new Je(1, 1, 1, 1),
              new Je(3, 0, 1, 1),
              new Je(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new S(1, 0, 0),
              new S(-1, 0, 0),
              new S(0, 0, 1),
              new S(0, 0, -1),
              new S(0, 1, 0),
              new S(0, -1, 0),
            ]),
            (this._cubeUps = [
              new S(0, 1, 0),
              new S(0, 1, 0),
              new S(0, 1, 0),
              new S(0, 1, 0),
              new S(0, 0, 1),
              new S(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            qr.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(qr),
            Ca.copy(n.position),
            Ca.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(Ca),
            n.updateMatrixWorld(),
            i.makeTranslation(-qr.x, -qr.y, -qr.z),
            pu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(pu);
        }
      }
      Ed.prototype.isPointLightShadow = !0;
      class qo extends Yt {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Ed());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      qo.prototype.isPointLight = !0;
      class Ad extends $l {
        constructor() {
          super(new Pr(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Ad.prototype.isDirectionalLightShadow = !0;
      class ws extends Yt {
        constructor(e, t) {
          super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(Ne.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ne()),
            (this.shadow = new Ad());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      ws.prototype.isDirectionalLight = !0;
      class Xo extends Yt {
        constructor(e, t) {
          super(e, t), (this.type = "AmbientLight");
        }
      }
      Xo.prototype.isAmbientLight = !0;
      class Ql extends Yt {
        constructor(e, t, n = 10, i = 10) {
          super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(e) {
          this.intensity = e / (this.width * this.height * Math.PI);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.width = this.width), (t.object.height = this.height), t
          );
        }
      }
      Ql.prototype.isRectAreaLight = !0;
      class ec {
        constructor() {
          this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new S());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            s = this.coefficients;
          return (
            t.copy(s[0]).multiplyScalar(0.282095),
            t.addScaledVector(s[1], 0.488603 * i),
            t.addScaledVector(s[2], 0.488603 * r),
            t.addScaledVector(s[3], 0.488603 * n),
            t.addScaledVector(s[4], 1.092548 * (n * i)),
            t.addScaledVector(s[5], 1.092548 * (i * r)),
            t.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
            t.addScaledVector(s[7], 1.092548 * (n * r)),
            t.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            s = this.coefficients;
          return (
            t.copy(s[0]).multiplyScalar(0.886227),
            t.addScaledVector(s[1], 2 * 0.511664 * i),
            t.addScaledVector(s[2], 2 * 0.511664 * r),
            t.addScaledVector(s[3], 2 * 0.511664 * n),
            t.addScaledVector(s[4], 2 * 0.429043 * n * i),
            t.addScaledVector(s[5], 2 * 0.429043 * i * r),
            t.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
            t.addScaledVector(s[7], 2 * 0.429043 * n * r),
            t.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * r),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * r),
            (t[6] = 0.315392 * (3 * r * r - 1)),
            (t[7] = 1.092548 * n * r),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      ec.prototype.isSphericalHarmonics3 = !0;
      class Ss extends Yt {
        constructor(e = new ec(), t = 1) {
          super(void 0, t), (this.sh = e);
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (t.object.sh = this.sh.toArray()), t;
        }
      }
      Ss.prototype.isLightProbe = !0;
      class Rd extends bt {
        constructor(e) {
          super(e), (this.textures = {});
        }
        load(e, t, n, i) {
          const r = this,
            s = new Ht(r.manager);
          s.setPath(r.path),
            s.setRequestHeader(r.requestHeader),
            s.setWithCredentials(r.withCredentials),
            s.load(
              e,
              function (a) {
                try {
                  t(r.parse(JSON.parse(a)));
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e) {
          const t = this.textures;
          function n(r) {
            return (
              t[r] === void 0 &&
                console.warn("THREE.MaterialLoader: Undefined texture", r),
              t[r]
            );
          }
          const i = et.fromType(e.type);
          if (
            (e.uuid !== void 0 && (i.uuid = e.uuid),
            e.name !== void 0 && (i.name = e.name),
            e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
            e.roughness !== void 0 && (i.roughness = e.roughness),
            e.metalness !== void 0 && (i.metalness = e.metalness),
            e.sheen !== void 0 && (i.sheen = e.sheen),
            e.sheenColor !== void 0 &&
              (i.sheenColor = new ne().setHex(e.sheenColor)),
            e.sheenRoughness !== void 0 &&
              (i.sheenRoughness = e.sheenRoughness),
            e.emissive !== void 0 &&
              i.emissive !== void 0 &&
              i.emissive.setHex(e.emissive),
            e.specular !== void 0 &&
              i.specular !== void 0 &&
              i.specular.setHex(e.specular),
            e.specularIntensity !== void 0 &&
              (i.specularIntensity = e.specularIntensity),
            e.specularColor !== void 0 &&
              i.specularColor !== void 0 &&
              i.specularColor.setHex(e.specularColor),
            e.shininess !== void 0 && (i.shininess = e.shininess),
            e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
            e.clearcoatRoughness !== void 0 &&
              (i.clearcoatRoughness = e.clearcoatRoughness),
            e.transmission !== void 0 && (i.transmission = e.transmission),
            e.thickness !== void 0 && (i.thickness = e.thickness),
            e.attenuationDistance !== void 0 &&
              (i.attenuationDistance = e.attenuationDistance),
            e.attenuationColor !== void 0 &&
              i.attenuationColor !== void 0 &&
              i.attenuationColor.setHex(e.attenuationColor),
            e.fog !== void 0 && (i.fog = e.fog),
            e.flatShading !== void 0 && (i.flatShading = e.flatShading),
            e.blending !== void 0 && (i.blending = e.blending),
            e.combine !== void 0 && (i.combine = e.combine),
            e.side !== void 0 && (i.side = e.side),
            e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
            e.opacity !== void 0 && (i.opacity = e.opacity),
            e.transparent !== void 0 && (i.transparent = e.transparent),
            e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
            e.depthTest !== void 0 && (i.depthTest = e.depthTest),
            e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
            e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
            e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
            e.stencilWriteMask !== void 0 &&
              (i.stencilWriteMask = e.stencilWriteMask),
            e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
            e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
            e.stencilFuncMask !== void 0 &&
              (i.stencilFuncMask = e.stencilFuncMask),
            e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
            e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
            e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
            e.wireframe !== void 0 && (i.wireframe = e.wireframe),
            e.wireframeLinewidth !== void 0 &&
              (i.wireframeLinewidth = e.wireframeLinewidth),
            e.wireframeLinecap !== void 0 &&
              (i.wireframeLinecap = e.wireframeLinecap),
            e.wireframeLinejoin !== void 0 &&
              (i.wireframeLinejoin = e.wireframeLinejoin),
            e.rotation !== void 0 && (i.rotation = e.rotation),
            e.linewidth !== 1 && (i.linewidth = e.linewidth),
            e.dashSize !== void 0 && (i.dashSize = e.dashSize),
            e.gapSize !== void 0 && (i.gapSize = e.gapSize),
            e.scale !== void 0 && (i.scale = e.scale),
            e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
            e.polygonOffsetFactor !== void 0 &&
              (i.polygonOffsetFactor = e.polygonOffsetFactor),
            e.polygonOffsetUnits !== void 0 &&
              (i.polygonOffsetUnits = e.polygonOffsetUnits),
            e.dithering !== void 0 && (i.dithering = e.dithering),
            e.alphaToCoverage !== void 0 &&
              (i.alphaToCoverage = e.alphaToCoverage),
            e.premultipliedAlpha !== void 0 &&
              (i.premultipliedAlpha = e.premultipliedAlpha),
            e.visible !== void 0 && (i.visible = e.visible),
            e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
            e.userData !== void 0 && (i.userData = e.userData),
            e.vertexColors !== void 0 &&
              (typeof e.vertexColors == "number"
                ? (i.vertexColors = e.vertexColors > 0)
                : (i.vertexColors = e.vertexColors)),
            e.uniforms !== void 0)
          )
            for (const r in e.uniforms) {
              const s = e.uniforms[r];
              switch (((i.uniforms[r] = {}), s.type)) {
                case "t":
                  i.uniforms[r].value = n(s.value);
                  break;
                case "c":
                  i.uniforms[r].value = new ne().setHex(s.value);
                  break;
                case "v2":
                  i.uniforms[r].value = new W().fromArray(s.value);
                  break;
                case "v3":
                  i.uniforms[r].value = new S().fromArray(s.value);
                  break;
                case "v4":
                  i.uniforms[r].value = new Je().fromArray(s.value);
                  break;
                case "m3":
                  i.uniforms[r].value = new mt().fromArray(s.value);
                  break;
                case "m4":
                  i.uniforms[r].value = new fe().fromArray(s.value);
                  break;
                default:
                  i.uniforms[r].value = s.value;
              }
            }
          if (
            (e.defines !== void 0 && (i.defines = e.defines),
            e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
            e.fragmentShader !== void 0 &&
              (i.fragmentShader = e.fragmentShader),
            e.extensions !== void 0)
          )
            for (const r in e.extensions) i.extensions[r] = e.extensions[r];
          if (
            (e.shading !== void 0 && (i.flatShading = e.shading === 1),
            e.size !== void 0 && (i.size = e.size),
            e.sizeAttenuation !== void 0 &&
              (i.sizeAttenuation = e.sizeAttenuation),
            e.map !== void 0 && (i.map = n(e.map)),
            e.matcap !== void 0 && (i.matcap = n(e.matcap)),
            e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
            e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
            e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
            e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
            e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
            e.normalScale !== void 0)
          ) {
            let r = e.normalScale;
            Array.isArray(r) === !1 && (r = [r, r]),
              (i.normalScale = new W().fromArray(r));
          }
          return (
            e.displacementMap !== void 0 &&
              (i.displacementMap = n(e.displacementMap)),
            e.displacementScale !== void 0 &&
              (i.displacementScale = e.displacementScale),
            e.displacementBias !== void 0 &&
              (i.displacementBias = e.displacementBias),
            e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
            e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
            e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
            e.emissiveIntensity !== void 0 &&
              (i.emissiveIntensity = e.emissiveIntensity),
            e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
            e.specularIntensityMap !== void 0 &&
              (i.specularIntensityMap = n(e.specularIntensityMap)),
            e.specularColorMap !== void 0 &&
              (i.specularColorMap = n(e.specularColorMap)),
            e.envMap !== void 0 && (i.envMap = n(e.envMap)),
            e.envMapIntensity !== void 0 &&
              (i.envMapIntensity = e.envMapIntensity),
            e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
            e.refractionRatio !== void 0 &&
              (i.refractionRatio = e.refractionRatio),
            e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
            e.lightMapIntensity !== void 0 &&
              (i.lightMapIntensity = e.lightMapIntensity),
            e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
            e.aoMapIntensity !== void 0 &&
              (i.aoMapIntensity = e.aoMapIntensity),
            e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
            e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
            e.clearcoatRoughnessMap !== void 0 &&
              (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
            e.clearcoatNormalMap !== void 0 &&
              (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
            e.clearcoatNormalScale !== void 0 &&
              (i.clearcoatNormalScale = new W().fromArray(
                e.clearcoatNormalScale
              )),
            e.transmissionMap !== void 0 &&
              (i.transmissionMap = n(e.transmissionMap)),
            e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
            e.sheenColorMap !== void 0 &&
              (i.sheenColorMap = n(e.sheenColorMap)),
            e.sheenRoughnessMap !== void 0 &&
              (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
            i
          );
        }
        setTextures(e) {
          return (this.textures = e), this;
        }
      }
      class Jt {
        static decodeText(e) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return typeof e != "string" || e === ""
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
      }
      class tc extends _e {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(e) {
          return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        }
      }
      tc.prototype.isInstancedBufferGeometry = !0;
      class Cd extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = new Ht(r.manager);
          s.setPath(r.path),
            s.setRequestHeader(r.requestHeader),
            s.setWithCredentials(r.withCredentials),
            s.load(
              e,
              function (a) {
                try {
                  t(r.parse(JSON.parse(a)));
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e) {
          const t = {},
            n = {};
          function i(f, g) {
            if (t[g] !== void 0) return t[g];
            const p = f.interleavedBuffers[g],
              x = r(f, p.buffer),
              y = rr(p.type, x),
              v = new ti(y, p.stride);
            return (v.uuid = p.uuid), (t[g] = v), v;
          }
          function r(f, g) {
            if (n[g] !== void 0) return n[g];
            const p = f.arrayBuffers[g],
              x = new Uint32Array(p).buffer;
            return (n[g] = x), x;
          }
          const s = e.isInstancedBufferGeometry ? new tc() : new _e(),
            a = e.data.index;
          if (a !== void 0) {
            const f = rr(a.type, a.array);
            s.setIndex(new Ue(f, 1));
          }
          const l = e.data.attributes;
          for (const f in l) {
            const g = l[f];
            let m;
            if (g.isInterleavedBufferAttribute) {
              const p = i(e.data, g.data);
              m = new wn(p, g.itemSize, g.offset, g.normalized);
            } else {
              const p = rr(g.type, g.array),
                x = g.isInstancedBufferAttribute ? Ei : Ue;
              m = new x(p, g.itemSize, g.normalized);
            }
            g.name !== void 0 && (m.name = g.name),
              g.usage !== void 0 && m.setUsage(g.usage),
              g.updateRange !== void 0 &&
                ((m.updateRange.offset = g.updateRange.offset),
                (m.updateRange.count = g.updateRange.count)),
              s.setAttribute(f, m);
          }
          const c = e.data.morphAttributes;
          if (c)
            for (const f in c) {
              const g = c[f],
                m = [];
              for (let p = 0, x = g.length; p < x; p++) {
                const y = g[p];
                let v;
                if (y.isInterleavedBufferAttribute) {
                  const M = i(e.data, y.data);
                  v = new wn(M, y.itemSize, y.offset, y.normalized);
                } else {
                  const M = rr(y.type, y.array);
                  v = new Ue(M, y.itemSize, y.normalized);
                }
                y.name !== void 0 && (v.name = y.name), m.push(v);
              }
              s.morphAttributes[f] = m;
            }
          e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
          const h = e.data.groups || e.data.drawcalls || e.data.offsets;
          if (h !== void 0)
            for (let f = 0, g = h.length; f !== g; ++f) {
              const m = h[f];
              s.addGroup(m.start, m.count, m.materialIndex);
            }
          const d = e.data.boundingSphere;
          if (d !== void 0) {
            const f = new S();
            d.center !== void 0 && f.fromArray(d.center),
              (s.boundingSphere = new Tn(f, d.radius));
          }
          return (
            e.name && (s.name = e.name),
            e.userData && (s.userData = e.userData),
            s
          );
        }
      }
      class d0 extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = this.path === "" ? Jt.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || s;
          const a = new Ht(this.manager);
          a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              e,
              function (l) {
                let c = null;
                try {
                  c = JSON.parse(l);
                } catch (h) {
                  i !== void 0 && i(h),
                    console.error(
                      "THREE:ObjectLoader: Can't parse " + e + ".",
                      h.message
                    );
                  return;
                }
                const u = c.metadata;
                if (
                  u === void 0 ||
                  u.type === void 0 ||
                  u.type.toLowerCase() === "geometry"
                ) {
                  console.error("THREE.ObjectLoader: Can't load " + e);
                  return;
                }
                r.parse(c, t);
              },
              n,
              i
            );
        }
        async loadAsync(e, t) {
          const n = this,
            i = this.path === "" ? Jt.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || i;
          const r = new Ht(this.manager);
          r.setPath(this.path),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials);
          const s = await r.loadAsync(e, t),
            a = JSON.parse(s),
            l = a.metadata;
          if (
            l === void 0 ||
            l.type === void 0 ||
            l.type.toLowerCase() === "geometry"
          )
            throw new Error("THREE.ObjectLoader: Can't load " + e);
          return await n.parseAsync(a);
        }
        parse(e, t) {
          const n = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            r = this.parseGeometries(e.geometries, i),
            s = this.parseImages(e.images, function () {
              t !== void 0 && t(c);
            }),
            a = this.parseTextures(e.textures, s),
            l = this.parseMaterials(e.materials, a),
            c = this.parseObject(e.object, r, l, a, n),
            u = this.parseSkeletons(e.skeletons, c);
          if ((this.bindSkeletons(c, u), t !== void 0)) {
            let h = !1;
            for (const d in s)
              if (s[d] instanceof HTMLImageElement) {
                h = !0;
                break;
              }
            h === !1 && t(c);
          }
          return c;
        }
        async parseAsync(e) {
          const t = this.parseAnimations(e.animations),
            n = this.parseShapes(e.shapes),
            i = this.parseGeometries(e.geometries, n),
            r = await this.parseImagesAsync(e.images),
            s = this.parseTextures(e.textures, r),
            a = this.parseMaterials(e.materials, s),
            l = this.parseObject(e.object, i, a, s, t),
            c = this.parseSkeletons(e.skeletons, l);
          return this.bindSkeletons(l, c), l;
        }
        parseShapes(e) {
          const t = {};
          if (e !== void 0)
            for (let n = 0, i = e.length; n < i; n++) {
              const r = new on().fromJSON(e[n]);
              t[r.uuid] = r;
            }
          return t;
        }
        parseSkeletons(e, t) {
          const n = {},
            i = {};
          if (
            (t.traverse(function (r) {
              r.isBone && (i[r.uuid] = r);
            }),
            e !== void 0)
          )
            for (let r = 0, s = e.length; r < s; r++) {
              const a = new vs().fromJSON(e[r], i);
              n[a.uuid] = a;
            }
          return n;
        }
        parseGeometries(e, t) {
          const n = {};
          if (e !== void 0) {
            const i = new Cd();
            for (let r = 0, s = e.length; r < s; r++) {
              let a;
              const l = e[r];
              switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  a = i.parse(l);
                  break;
                case "Geometry":
                  console.error(
                    "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                  );
                  break;
                default:
                  l.type in uu
                    ? (a = uu[l.type].fromJSON(l, t))
                    : console.warn(
                        `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                      );
              }
              (a.uuid = l.uuid),
                l.name !== void 0 && (a.name = l.name),
                a.isBufferGeometry === !0 &&
                  l.userData !== void 0 &&
                  (a.userData = l.userData),
                (n[l.uuid] = a);
            }
          }
          return n;
        }
        parseMaterials(e, t) {
          const n = {},
            i = {};
          if (e !== void 0) {
            const r = new Rd();
            r.setTextures(t);
            for (let s = 0, a = e.length; s < a; s++) {
              const l = e[s];
              if (l.type === "MultiMaterial") {
                const c = [];
                for (let u = 0; u < l.materials.length; u++) {
                  const h = l.materials[u];
                  n[h.uuid] === void 0 && (n[h.uuid] = r.parse(h)),
                    c.push(n[h.uuid]);
                }
                i[l.uuid] = c;
              } else
                n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)),
                  (i[l.uuid] = n[l.uuid]);
            }
          }
          return i;
        }
        parseAnimations(e) {
          const t = {};
          if (e !== void 0)
            for (let n = 0; n < e.length; n++) {
              const i = e[n],
                r = Ar.parse(i);
              t[r.uuid] = r;
            }
          return t;
        }
        parseImages(e, t) {
          const n = this,
            i = {};
          let r;
          function s(l) {
            return (
              n.manager.itemStart(l),
              r.load(
                l,
                function () {
                  n.manager.itemEnd(l);
                },
                void 0,
                function () {
                  n.manager.itemError(l), n.manager.itemEnd(l);
                }
              )
            );
          }
          function a(l) {
            if (typeof l == "string") {
              const c = l,
                u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)
                  ? c
                  : n.resourcePath + c;
              return s(u);
            } else
              return l.data
                ? { data: rr(l.type, l.data), width: l.width, height: l.height }
                : null;
          }
          if (e !== void 0 && e.length > 0) {
            const l = new jl(t);
            (r = new cs(l)), r.setCrossOrigin(this.crossOrigin);
            for (let c = 0, u = e.length; c < u; c++) {
              const h = e[c],
                d = h.url;
              if (Array.isArray(d)) {
                const f = [];
                for (let g = 0, m = d.length; g < m; g++) {
                  const p = d[g],
                    x = a(p);
                  x !== null &&
                    (x instanceof HTMLImageElement
                      ? f.push(x)
                      : f.push(new bi(x.data, x.width, x.height)));
                }
                i[h.uuid] = new Un(f);
              } else {
                const f = a(h.url);
                i[h.uuid] = new Un(f);
              }
            }
          }
          return i;
        }
        async parseImagesAsync(e) {
          const t = this,
            n = {};
          let i;
          async function r(s) {
            if (typeof s == "string") {
              const a = s,
                l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)
                  ? a
                  : t.resourcePath + a;
              return await i.loadAsync(l);
            } else
              return s.data
                ? { data: rr(s.type, s.data), width: s.width, height: s.height }
                : null;
          }
          if (e !== void 0 && e.length > 0) {
            (i = new cs(this.manager)), i.setCrossOrigin(this.crossOrigin);
            for (let s = 0, a = e.length; s < a; s++) {
              const l = e[s],
                c = l.url;
              if (Array.isArray(c)) {
                const u = [];
                for (let h = 0, d = c.length; h < d; h++) {
                  const f = c[h],
                    g = await r(f);
                  g !== null &&
                    (g instanceof HTMLImageElement
                      ? u.push(g)
                      : u.push(new bi(g.data, g.width, g.height)));
                }
                n[l.uuid] = new Un(u);
              } else {
                const u = await r(l.url);
                n[l.uuid] = new Un(u);
              }
            }
          }
          return n;
        }
        parseTextures(e, t) {
          function n(r, s) {
            return typeof r == "number"
              ? r
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  r
                ),
                s[r]);
          }
          const i = {};
          if (e !== void 0)
            for (let r = 0, s = e.length; r < s; r++) {
              const a = e[r];
              a.image === void 0 &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  a.uuid
                ),
                t[a.image] === void 0 &&
                  console.warn("THREE.ObjectLoader: Undefined image", a.image);
              const l = t[a.image],
                c = l.data;
              let u;
              Array.isArray(c)
                ? ((u = new Lr()), c.length === 6 && (u.needsUpdate = !0))
                : (c && c.data ? (u = new bi()) : (u = new st()),
                  c && (u.needsUpdate = !0)),
                (u.source = l),
                (u.uuid = a.uuid),
                a.name !== void 0 && (u.name = a.name),
                a.mapping !== void 0 && (u.mapping = n(a.mapping, f0)),
                a.offset !== void 0 && u.offset.fromArray(a.offset),
                a.repeat !== void 0 && u.repeat.fromArray(a.repeat),
                a.center !== void 0 && u.center.fromArray(a.center),
                a.rotation !== void 0 && (u.rotation = a.rotation),
                a.wrap !== void 0 &&
                  ((u.wrapS = n(a.wrap[0], mu)), (u.wrapT = n(a.wrap[1], mu))),
                a.format !== void 0 && (u.format = a.format),
                a.type !== void 0 && (u.type = a.type),
                a.encoding !== void 0 && (u.encoding = a.encoding),
                a.minFilter !== void 0 && (u.minFilter = n(a.minFilter, gu)),
                a.magFilter !== void 0 && (u.magFilter = n(a.magFilter, gu)),
                a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (u.flipY = a.flipY),
                a.premultiplyAlpha !== void 0 &&
                  (u.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 &&
                  (u.unpackAlignment = a.unpackAlignment),
                a.userData !== void 0 && (u.userData = a.userData),
                (i[a.uuid] = u);
            }
          return i;
        }
        parseObject(e, t, n, i, r) {
          let s;
          function a(d) {
            return (
              t[d] === void 0 &&
                console.warn("THREE.ObjectLoader: Undefined geometry", d),
              t[d]
            );
          }
          function l(d) {
            if (d !== void 0) {
              if (Array.isArray(d)) {
                const f = [];
                for (let g = 0, m = d.length; g < m; g++) {
                  const p = d[g];
                  n[p] === void 0 &&
                    console.warn("THREE.ObjectLoader: Undefined material", p),
                    f.push(n[p]);
                }
                return f;
              }
              return (
                n[d] === void 0 &&
                  console.warn("THREE.ObjectLoader: Undefined material", d),
                n[d]
              );
            }
          }
          function c(d) {
            return (
              i[d] === void 0 &&
                console.warn("THREE.ObjectLoader: Undefined texture", d),
              i[d]
            );
          }
          let u, h;
          switch (e.type) {
            case "Scene":
              (s = new xs()),
                e.background !== void 0 &&
                  (Number.isInteger(e.background)
                    ? (s.background = new ne(e.background))
                    : (s.background = c(e.background))),
                e.environment !== void 0 && (s.environment = c(e.environment)),
                e.fog !== void 0 &&
                  (e.fog.type === "Fog"
                    ? (s.fog = new gs(e.fog.color, e.fog.near, e.fog.far))
                    : e.fog.type === "FogExp2" &&
                      (s.fog = new ms(e.fog.color, e.fog.density)));
              break;
            case "PerspectiveCamera":
              (s = new pt(e.fov, e.aspect, e.near, e.far)),
                e.focus !== void 0 && (s.focus = e.focus),
                e.zoom !== void 0 && (s.zoom = e.zoom),
                e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge),
                e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset),
                e.view !== void 0 && (s.view = Object.assign({}, e.view));
              break;
            case "OrthographicCamera":
              (s = new Pr(e.left, e.right, e.top, e.bottom, e.near, e.far)),
                e.zoom !== void 0 && (s.zoom = e.zoom),
                e.view !== void 0 && (s.view = Object.assign({}, e.view));
              break;
            case "AmbientLight":
              s = new Xo(e.color, e.intensity);
              break;
            case "DirectionalLight":
              s = new ws(e.color, e.intensity);
              break;
            case "PointLight":
              s = new qo(e.color, e.intensity, e.distance, e.decay);
              break;
            case "RectAreaLight":
              s = new Ql(e.color, e.intensity, e.width, e.height);
              break;
            case "SpotLight":
              s = new Wo(
                e.color,
                e.intensity,
                e.distance,
                e.angle,
                e.penumbra,
                e.decay
              );
              break;
            case "HemisphereLight":
              s = new Zl(e.color, e.groundColor, e.intensity);
              break;
            case "LightProbe":
              s = new Ss().fromJSON(e);
              break;
            case "SkinnedMesh":
              (u = a(e.geometry)),
                (h = l(e.material)),
                (s = new ys(u, h)),
                e.bindMode !== void 0 && (s.bindMode = e.bindMode),
                e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix),
                e.skeleton !== void 0 && (s.skeleton = e.skeleton);
              break;
            case "Mesh":
              (u = a(e.geometry)), (h = l(e.material)), (s = new ut(u, h));
              break;
            case "InstancedMesh":
              (u = a(e.geometry)), (h = l(e.material));
              const d = e.count,
                f = e.instanceMatrix,
                g = e.instanceColor;
              (s = new Ll(u, h, d)),
                (s.instanceMatrix = new Ei(new Float32Array(f.array), 16)),
                g !== void 0 &&
                  (s.instanceColor = new Ei(
                    new Float32Array(g.array),
                    g.itemSize
                  ));
              break;
            case "LOD":
              s = new ud();
              break;
            case "Line":
              s = new ln(a(e.geometry), l(e.material));
              break;
            case "LineLoop":
              s = new Uo(a(e.geometry), l(e.material));
              break;
            case "LineSegments":
              s = new Rt(a(e.geometry), l(e.material));
              break;
            case "PointCloud":
            case "Points":
              s = new Dr(a(e.geometry), l(e.material));
              break;
            case "Sprite":
              s = new Oo(l(e.material));
              break;
            case "Group":
              s = new rn();
              break;
            case "Bone":
              s = new _s();
              break;
            default:
              s = new Ne();
          }
          if (
            ((s.uuid = e.uuid),
            e.name !== void 0 && (s.name = e.name),
            e.matrix !== void 0
              ? (s.matrix.fromArray(e.matrix),
                e.matrixAutoUpdate !== void 0 &&
                  (s.matrixAutoUpdate = e.matrixAutoUpdate),
                s.matrixAutoUpdate &&
                  s.matrix.decompose(s.position, s.quaternion, s.scale))
              : (e.position !== void 0 && s.position.fromArray(e.position),
                e.rotation !== void 0 && s.rotation.fromArray(e.rotation),
                e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion),
                e.scale !== void 0 && s.scale.fromArray(e.scale)),
            e.castShadow !== void 0 && (s.castShadow = e.castShadow),
            e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow),
            e.shadow &&
              (e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias),
              e.shadow.normalBias !== void 0 &&
                (s.shadow.normalBias = e.shadow.normalBias),
              e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius),
              e.shadow.mapSize !== void 0 &&
                s.shadow.mapSize.fromArray(e.shadow.mapSize),
              e.shadow.camera !== void 0 &&
                (s.shadow.camera = this.parseObject(e.shadow.camera))),
            e.visible !== void 0 && (s.visible = e.visible),
            e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled),
            e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder),
            e.userData !== void 0 && (s.userData = e.userData),
            e.layers !== void 0 && (s.layers.mask = e.layers),
            e.children !== void 0)
          ) {
            const d = e.children;
            for (let f = 0; f < d.length; f++)
              s.add(this.parseObject(d[f], t, n, i, r));
          }
          if (e.animations !== void 0) {
            const d = e.animations;
            for (let f = 0; f < d.length; f++) {
              const g = d[f];
              s.animations.push(r[g]);
            }
          }
          if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
            const d = e.levels;
            for (let f = 0; f < d.length; f++) {
              const g = d[f],
                m = s.getObjectByProperty("uuid", g.object);
              m !== void 0 && s.addLevel(m, g.distance);
            }
          }
          return s;
        }
        bindSkeletons(e, t) {
          Object.keys(t).length !== 0 &&
            e.traverse(function (n) {
              if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                const i = t[n.skeleton];
                i === void 0
                  ? console.warn(
                      "THREE.ObjectLoader: No skeleton found with UUID:",
                      n.skeleton
                    )
                  : n.bind(i, n.bindMatrix);
              }
            });
        }
        setTexturePath(e) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(e)
          );
        }
      }
      const f0 = {
          UVMapping: To,
          CubeReflectionMapping: Vn,
          CubeRefractionMapping: Wn,
          EquirectangularReflectionMapping: Qr,
          EquirectangularRefractionMapping: es,
          CubeUVReflectionMapping: Rr,
        },
        mu = {
          RepeatWrapping: qn,
          ClampToEdgeWrapping: Mt,
          MirroredRepeatWrapping: ar,
        },
        gu = {
          NearestFilter: at,
          NearestMipmapNearestFilter: ts,
          NearestMipmapLinearFilter: ns,
          LinearFilter: tt,
          LinearMipmapNearestFilter: Eo,
          LinearMipmapLinearFilter: Sn,
        };
      class nc extends bt {
        constructor(e) {
          super(e),
            typeof createImageBitmap == "undefined" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch == "undefined" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            s = Pi.get(e);
          if (s !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(s), r.manager.itemEnd(e);
              }, 0),
              s
            );
          const a = {};
          (a.credentials =
            this.crossOrigin === "anonymous" ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (l) {
                return l.blob();
              })
              .then(function (l) {
                return createImageBitmap(
                  l,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (l) {
                Pi.add(e, l), t && t(l), r.manager.itemEnd(e);
              })
              .catch(function (l) {
                i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
              }),
            r.manager.itemStart(e);
        }
      }
      nc.prototype.isImageBitmapLoader = !0;
      let oo;
      const ic = {
        getContext: function () {
          return (
            oo === void 0 &&
              (oo = new (window.AudioContext || window.webkitAudioContext)()),
            oo
          );
        },
        setContext: function (o) {
          oo = o;
        },
      };
      class Ld extends bt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = new Ht(this.manager);
          s.setResponseType("arraybuffer"),
            s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              function (a) {
                try {
                  const l = a.slice(0);
                  ic.getContext().decodeAudioData(l, function (u) {
                    t(u);
                  });
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
      }
      class Pd extends Ss {
        constructor(e, t, n = 1) {
          super(void 0, n);
          const i = new ne().set(e),
            r = new ne().set(t),
            s = new S(i.r, i.g, i.b),
            a = new S(r.r, r.g, r.b),
            l = Math.sqrt(Math.PI),
            c = l * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(s).add(a).multiplyScalar(l),
            this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(c);
        }
      }
      Pd.prototype.isHemisphereLightProbe = !0;
      class Id extends Ss {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new ne().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Id.prototype.isAmbientLightProbe = !0;
      const xu = new fe(),
        yu = new fe(),
        ai = new fe();
      class p0 {
        constructor() {
          (this.type = "StereoCamera"),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new pt()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new pt()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
              focus: null,
              fov: null,
              aspect: null,
              near: null,
              far: null,
              zoom: null,
              eyeSep: null,
            });
        }
        update(e) {
          const t = this._cache;
          if (
            t.focus !== e.focus ||
            t.fov !== e.fov ||
            t.aspect !== e.aspect * this.aspect ||
            t.near !== e.near ||
            t.far !== e.far ||
            t.zoom !== e.zoom ||
            t.eyeSep !== this.eyeSep
          ) {
            (t.focus = e.focus),
              (t.fov = e.fov),
              (t.aspect = e.aspect * this.aspect),
              (t.near = e.near),
              (t.far = e.far),
              (t.zoom = e.zoom),
              (t.eyeSep = this.eyeSep),
              ai.copy(e.projectionMatrix);
            const i = t.eyeSep / 2,
              r = (i * t.near) / t.focus,
              s = (t.near * Math.tan(vi * t.fov * 0.5)) / t.zoom;
            let a, l;
            (yu.elements[12] = -i),
              (xu.elements[12] = i),
              (a = -s * t.aspect + r),
              (l = s * t.aspect + r),
              (ai.elements[0] = (2 * t.near) / (l - a)),
              (ai.elements[8] = (l + a) / (l - a)),
              this.cameraL.projectionMatrix.copy(ai),
              (a = -s * t.aspect - r),
              (l = s * t.aspect - r),
              (ai.elements[0] = (2 * t.near) / (l - a)),
              (ai.elements[8] = (l + a) / (l - a)),
              this.cameraR.projectionMatrix.copy(ai);
          }
          this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(yu),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(xu);
        }
      }
      class Dd {
        constructor(e = !0) {
          (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = _u()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = _u();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function _u() {
        return (typeof performance == "undefined" ? Date : performance).now();
      }
      const li = new S(),
        vu = new yt(),
        m0 = new S(),
        ci = new S();
      class g0 extends Ne {
        constructor() {
          super(),
            (this.type = "AudioListener"),
            (this.context = ic.getContext()),
            (this.gain = this.context.createGain()),
            this.gain.connect(this.context.destination),
            (this.filter = null),
            (this.timeDelta = 0),
            (this._clock = new Dd());
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return (
            this.filter !== null &&
              (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination),
              this.gain.connect(this.context.destination),
              (this.filter = null)),
            this
          );
        }
        getFilter() {
          return this.filter;
        }
        setFilter(e) {
          return (
            this.filter !== null
              ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination))
              : this.gain.disconnect(this.context.destination),
            (this.filter = e),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
          );
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e);
          const t = this.context.listener,
            n = this.up;
          if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose(li, vu, m0),
            ci.set(0, 0, -1).applyQuaternion(vu),
            t.positionX)
          ) {
            const i = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(li.x, i),
              t.positionY.linearRampToValueAtTime(li.y, i),
              t.positionZ.linearRampToValueAtTime(li.z, i),
              t.forwardX.linearRampToValueAtTime(ci.x, i),
              t.forwardY.linearRampToValueAtTime(ci.y, i),
              t.forwardZ.linearRampToValueAtTime(ci.z, i),
              t.upX.linearRampToValueAtTime(n.x, i),
              t.upY.linearRampToValueAtTime(n.y, i),
              t.upZ.linearRampToValueAtTime(n.z, i);
          } else
            t.setPosition(li.x, li.y, li.z),
              t.setOrientation(ci.x, ci.y, ci.z, n.x, n.y, n.z);
        }
      }
      class rc extends Ne {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            this.isPlaying === !0 &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.loop === !0 &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            this._connected === !0
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), this.source.detune !== void 0))
            return (
              this.isPlaying === !0 &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return this.hasPlaybackControl === !1
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }
      const ui = new S(),
        Mu = new yt(),
        x0 = new S(),
        hi = new S();
      class y0 extends rc {
        constructor(e) {
          super(e),
            (this.panner = this.context.createPanner()),
            (this.panner.panningModel = "HRTF"),
            this.panner.connect(this.gain);
        }
        disconnect() {
          super.disconnect(), this.panner.disconnect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(e) {
          return (this.panner.refDistance = e), this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(e) {
          return (this.panner.rolloffFactor = e), this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(e) {
          return (this.panner.distanceModel = e), this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(e) {
          return (this.panner.maxDistance = e), this;
        }
        setDirectionalCone(e, t, n) {
          return (
            (this.panner.coneInnerAngle = e),
            (this.panner.coneOuterAngle = t),
            (this.panner.coneOuterGain = n),
            this
          );
        }
        updateMatrixWorld(e) {
          if (
            (super.updateMatrixWorld(e),
            this.hasPlaybackControl === !0 && this.isPlaying === !1)
          )
            return;
          this.matrixWorld.decompose(ui, Mu, x0),
            hi.set(0, 0, 1).applyQuaternion(Mu);
          const t = this.panner;
          if (t.positionX) {
            const n = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(ui.x, n),
              t.positionY.linearRampToValueAtTime(ui.y, n),
              t.positionZ.linearRampToValueAtTime(ui.z, n),
              t.orientationX.linearRampToValueAtTime(hi.x, n),
              t.orientationY.linearRampToValueAtTime(hi.y, n),
              t.orientationZ.linearRampToValueAtTime(hi.z, n);
          } else
            t.setPosition(ui.x, ui.y, ui.z), t.setOrientation(hi.x, hi.y, hi.z);
        }
      }
      class Fd {
        constructor(e, t = 2048) {
          (this.analyser = e.context.createAnalyser()),
            (this.analyser.fftSize = t),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            e.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let e = 0;
          const t = this.getFrequencyData();
          for (let n = 0; n < t.length; n++) e += t[n];
          return e / t.length;
        }
      }
      class Bd {
        constructor(e, t, n) {
          (this.binding = e), (this.valueSize = n);
          let i, r, s;
          switch (t) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (s = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(n * 6)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (s = this._setAdditiveIdentityOther),
                (this.buffer = new Array(n * 5));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (s = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(n * 5));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = s),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let s = this.cumulativeWeight;
          if (s === 0) {
            for (let a = 0; a !== i; ++a) n[r + a] = n[a];
            s = t;
          } else {
            s += t;
            const a = t / s;
            this._mixBufferRegion(n, r, 0, a, i);
          }
          this.cumulativeWeight = s;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            s = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const l = t * this._origIndex;
            this._mixBufferRegion(n, i, l, 1 - r, t);
          }
          s > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let l = t, c = t + t; l !== c; ++l)
            if (n[l] !== n[l + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let r = n, s = i; r !== s; ++r) t[r] = t[i + (r % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let s = 0; s !== r; ++s) e[t + s] = e[n + s];
        }
        _slerp(e, t, n, i) {
          yt.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const s = this._workIndex * r;
          yt.multiplyQuaternionsFlat(e, s, e, t, e, n),
            yt.slerpFlat(e, t, e, t, e, s, i);
        }
        _lerp(e, t, n, i, r) {
          const s = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const l = t + a;
            e[l] = e[l] * s + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let s = 0; s !== r; ++s) {
            const a = t + s;
            e[a] = e[a] + e[n + s] * i;
          }
        }
      }
      const sc = "\\[\\]\\.:\\/",
        _0 = new RegExp("[" + sc + "]", "g"),
        oc = "[^" + sc + "]",
        v0 = "[^" + sc.replace("\\.", "") + "]",
        M0 = /((?:WC+[\/:])*)/.source.replace("WC", oc),
        b0 = /(WCOD+)?/.source.replace("WCOD", v0),
        w0 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", oc),
        S0 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", oc),
        T0 = new RegExp("^" + M0 + b0 + w0 + S0 + "$"),
        E0 = ["material", "materials", "bones"];
      class A0 {
        constructor(e, t, n) {
          const i = n || Ge.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }
      class Ge {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || Ge.parseTrackName(t)),
            (this.node = Ge.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new Ge.Composite(e, t, n)
            : new Ge(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(_0, "");
        }
        static parseTrackName(e) {
          const t = T0.exec(e);
          if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            E0.indexOf(r) !== -1 &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
          }
          if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            t === void 0 ||
            t === "" ||
            t === "." ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
          }
          if (e.children) {
            const n = function (r) {
                for (let s = 0; s < r.length; s++) {
                  const a = r[s];
                  if (a.name === t || a.uuid === t) return a;
                  const l = n(a.children);
                  if (l) return l;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = Ge.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
            return;
          }
          if (n) {
            let c = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!e.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                e = e.skeleton.bones;
                for (let u = 0; u < e.length; u++)
                  if (e[u].name === c) {
                    c = u;
                    break;
                  }
                break;
              default:
                if (e[n] === void 0) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                e = e[n];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
                return;
              }
              e = e[c];
            }
          }
          const s = e[i];
          if (s === void 0) {
            const c = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                c +
                "." +
                i +
                " but it wasn't found.",
              e
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            e.needsUpdate !== void 0
              ? (a = this.Versioning.NeedsUpdate)
              : e.matrixWorldNeedsUpdate !== void 0 &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let l = this.BindingType.Direct;
          if (r !== void 0) {
            if (i === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (e.geometry.isBufferGeometry) {
                if (!e.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                e.morphTargetDictionary[r] !== void 0 &&
                  (r = e.morphTargetDictionary[r]);
              } else {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
                return;
              }
            }
            (l = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r);
          } else
            s.fromArray !== void 0 && s.toArray !== void 0
              ? ((l = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((l = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[l]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      Ge.Composite = A0;
      Ge.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      };
      Ge.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      };
      Ge.prototype.GetterByBindingType = [
        Ge.prototype._getValue_direct,
        Ge.prototype._getValue_array,
        Ge.prototype._getValue_arrayElement,
        Ge.prototype._getValue_toArray,
      ];
      Ge.prototype.SetterByBindingTypeAndVersioning = [
        [
          Ge.prototype._setValue_direct,
          Ge.prototype._setValue_direct_setNeedsUpdate,
          Ge.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          Ge.prototype._setValue_array,
          Ge.prototype._setValue_array_setNeedsUpdate,
          Ge.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          Ge.prototype._setValue_arrayElement,
          Ge.prototype._setValue_arrayElement_setNeedsUpdate,
          Ge.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          Ge.prototype._setValue_fromArray,
          Ge.prototype._setValue_fromArray_setNeedsUpdate,
          Ge.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ];
      class Nd {
        constructor() {
          (this.uuid = Bt()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          const e = {};
          this._indicesByUUID = e;
          for (let n = 0, i = arguments.length; n !== i; ++n)
            e[arguments[n].uuid] = n;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          const t = this;
          this.stats = {
            objects: {
              get total() {
                return t._objects.length;
              },
              get inUse() {
                return this.total - t.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return t._bindings.length;
            },
          };
        }
        add() {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            r = this._bindings,
            s = r.length;
          let a,
            l = e.length,
            c = this.nCachedObjects_;
          for (let u = 0, h = arguments.length; u !== h; ++u) {
            const d = arguments[u],
              f = d.uuid;
            let g = t[f];
            if (g === void 0) {
              (g = l++), (t[f] = g), e.push(d);
              for (let m = 0, p = s; m !== p; ++m)
                r[m].push(new Ge(d, n[m], i[m]));
            } else if (g < c) {
              a = e[g];
              const m = --c,
                p = e[m];
              (t[p.uuid] = g), (e[g] = p), (t[f] = m), (e[m] = d);
              for (let x = 0, y = s; x !== y; ++x) {
                const v = r[x],
                  M = v[m];
                let b = v[g];
                (v[g] = M),
                  b === void 0 && (b = new Ge(d, n[x], i[x])),
                  (v[m] = b);
              }
            } else
              e[g] !== a &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = c;
        }
        remove() {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_;
          for (let s = 0, a = arguments.length; s !== a; ++s) {
            const l = arguments[s],
              c = l.uuid,
              u = t[c];
            if (u !== void 0 && u >= r) {
              const h = r++,
                d = e[h];
              (t[d.uuid] = u), (e[u] = d), (t[c] = h), (e[h] = l);
              for (let f = 0, g = i; f !== g; ++f) {
                const m = n[f],
                  p = m[h],
                  x = m[u];
                (m[u] = p), (m[h] = x);
              }
            }
          }
          this.nCachedObjects_ = r;
        }
        uncache() {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_,
            s = e.length;
          for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a],
              u = c.uuid,
              h = t[u];
            if (h !== void 0)
              if ((delete t[u], h < r)) {
                const d = --r,
                  f = e[d],
                  g = --s,
                  m = e[g];
                (t[f.uuid] = h),
                  (e[h] = f),
                  (t[m.uuid] = d),
                  (e[d] = m),
                  e.pop();
                for (let p = 0, x = i; p !== x; ++p) {
                  const y = n[p],
                    v = y[d],
                    M = y[g];
                  (y[h] = v), (y[d] = M), y.pop();
                }
              } else {
                const d = --s,
                  f = e[d];
                d > 0 && (t[f.uuid] = h), (e[h] = f), e.pop();
                for (let g = 0, m = i; g !== m; ++g) {
                  const p = n[g];
                  (p[h] = p[d]), p.pop();
                }
              }
          }
          this.nCachedObjects_ = r;
        }
        subscribe_(e, t) {
          const n = this._bindingsIndicesByPath;
          let i = n[e];
          const r = this._bindings;
          if (i !== void 0) return r[i];
          const s = this._paths,
            a = this._parsedPaths,
            l = this._objects,
            c = l.length,
            u = this.nCachedObjects_,
            h = new Array(c);
          (i = r.length), (n[e] = i), s.push(e), a.push(t), r.push(h);
          for (let d = u, f = l.length; d !== f; ++d) {
            const g = l[d];
            h[d] = new Ge(g, e, t);
          }
          return h;
        }
        unsubscribe_(e) {
          const t = this._bindingsIndicesByPath,
            n = t[e];
          if (n !== void 0) {
            const i = this._paths,
              r = this._parsedPaths,
              s = this._bindings,
              a = s.length - 1,
              l = s[a],
              c = e[a];
            (t[c] = n),
              (s[n] = l),
              s.pop(),
              (r[n] = r[a]),
              r.pop(),
              (i[n] = i[a]),
              i.pop();
          }
        }
      }
      Nd.prototype.isAnimationObjectGroup = !0;
      class R0 {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            s = r.length,
            a = new Array(s),
            l = { endingStart: gi, endingEnd: gi };
          for (let c = 0; c !== s; ++c) {
            const u = r[c].createInterpolant(null);
            (a[c] = u), (u.settings = l);
          }
          (this._interpolantSettings = l),
            (this._interpolants = a),
            (this._propertyBindings = new Array(s)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = Ph),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const i = this._clip.duration,
              r = e._clip.duration,
              s = r / i,
              a = i / r;
            e.warp(1, s, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            e !== null &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            s = this.timeScale;
          let a = this._timeScaleInterpolant;
          a === null &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const l = a.parameterPositions,
            c = a.sampleValues;
          return (
            (l[0] = r), (l[1] = r + n), (c[0] = e / s), (c[1] = t / s), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            e !== null &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const l = (e - r) * n;
            if (l < 0 || n === 0) return;
            (this._startTime = null), (t = n * l);
          }
          t *= this._updateTimeScale(e);
          const s = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const l = this._interpolants,
              c = this._propertyBindings;
            switch (this.blendMode) {
              case Sl:
                for (let u = 0, h = l.length; u !== h; ++u)
                  l[u].evaluate(s), c[u].accumulateAdditive(a);
                break;
              case Ao:
              default:
                for (let u = 0, h = l.length; u !== h; ++u)
                  l[u].evaluate(s), c[u].accumulate(i, a);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), i === 0 && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            n !== null &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                t === 0 ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const s = n === Ih;
          if (e === 0) return r === -1 ? i : s && (r & 1) === 1 ? t - i : i;
          if (n === Lh) {
            r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else if (i < 0) i = 0;
              else {
                this.time = i;
                break e;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (r === -1 &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, this.repetitions === 0, s))
                  : this._setEndings(this.repetitions === 0, !0, s)),
              i >= t || i < 0)
            ) {
              const a = Math.floor(i / t);
              (i -= t * a), (r += Math.abs(a));
              const l = this.repetitions - r;
              if (l <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (l === 1) {
                  const c = e < 0;
                  this._setEndings(c, !c, s);
                } else this._setEndings(!1, !1, s);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = i;
            if (s && (r & 1) === 1) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = xi), (i.endingEnd = xi))
            : (e
                ? (i.endingStart = this.zeroSlopeAtStart ? xi : gi)
                : (i.endingStart = is),
              t
                ? (i.endingEnd = this.zeroSlopeAtEnd ? xi : gi)
                : (i.endingEnd = is));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let s = this._weightInterpolant;
          s === null &&
            ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
          const a = s.parameterPositions,
            l = s.sampleValues;
          return (a[0] = r), (l[0] = t), (a[1] = r + e), (l[1] = n), this;
        }
      }
      class Od extends Zn {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            s = e._propertyBindings,
            a = e._interpolants,
            l = n.uuid,
            c = this._bindingsByRootAndName;
          let u = c[l];
          u === void 0 && ((u = {}), (c[l] = u));
          for (let h = 0; h !== r; ++h) {
            const d = i[h],
              f = d.name;
            let g = u[f];
            if (g !== void 0) ++g.referenceCount, (s[h] = g);
            else {
              if (((g = s[h]), g !== void 0)) {
                g._cacheIndex === null &&
                  (++g.referenceCount, this._addInactiveBinding(g, l, f));
                continue;
              }
              const m = t && t._propertyBindings[h].binding.parsedPath;
              (g = new Bd(
                Ge.create(n, f, m),
                d.ValueTypeName,
                d.getValueSize()
              )),
                ++g.referenceCount,
                this._addInactiveBinding(g, l, f),
                (s[h] = g);
            }
            a[h].resultBuffer = g.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const n = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                r = this._actionsByClip[i];
              this._bindAction(e, r && r.knownActions[0]),
                this._addInactiveAction(e, i, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              r.useCount++ === 0 &&
                (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              --r.useCount === 0 &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let s = r[t];
          if (s === void 0)
            (s = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = s);
          else {
            const a = s.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            s = this._actionsByClip,
            a = s[r],
            l = a.knownActions,
            c = l[l.length - 1],
            u = e._byClipCacheIndex;
          (c._byClipCacheIndex = u),
            (l[u] = c),
            l.pop(),
            (e._byClipCacheIndex = null);
          const h = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
          delete h[d],
            l.length === 0 && delete s[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const r = t[n];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let s = i[t];
          s === void 0 && ((s = {}), (i[t] = s)),
            (s[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            s = this._bindingsByRootAndName,
            a = s[i],
            l = t[t.length - 1],
            c = e._cacheIndex;
          (l._cacheIndex = c),
            (t[c] = l),
            t.pop(),
            delete a[r],
            Object.keys(a).length === 0 && delete s[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            n === void 0 &&
              ((n = new Jl(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let s = typeof e == "string" ? Ar.findByName(i, e) : e;
          const a = s !== null ? s.uuid : e,
            l = this._actionsByClip[a];
          let c = null;
          if (
            (n === void 0 && (s !== null ? (n = s.blendMode) : (n = Ao)),
            l !== void 0)
          ) {
            const h = l.actionByRoot[r];
            if (h !== void 0 && h.blendMode === n) return h;
            (c = l.knownActions[0]), s === null && (s = c._clip);
          }
          if (s === null) return null;
          const u = new R0(this, s, t, n);
          return this._bindAction(u, c), this._addInactiveAction(u, a, r), u;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = typeof e == "string" ? Ar.findByName(n, e) : e,
            s = r ? r.uuid : e,
            a = this._actionsByClip[s];
          return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions,
            t = this._nActiveActions;
          for (let n = t - 1; n >= 0; --n) e[n].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            s = (this._accuIndex ^= 1);
          for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, s);
          const a = this._bindings,
            l = this._nActiveBindings;
          for (let c = 0; c !== l; ++c) a[c].apply(s);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (r !== void 0) {
            const s = r.knownActions;
            for (let a = 0, l = s.length; a !== l; ++a) {
              const c = s[a];
              this._deactivateAction(c);
              const u = c._cacheIndex,
                h = t[t.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (h._cacheIndex = u),
                (t[u] = h),
                t.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const s in n) {
            const a = n[s].actionByRoot,
              l = a[t];
            l !== void 0 &&
              (this._deactivateAction(l), this._removeInactiveAction(l));
          }
          const i = this._bindingsByRootAndName,
            r = i[t];
          if (r !== void 0)
            for (const s in r) {
              const a = r[s];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      Od.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Jo {
        constructor(e) {
          typeof e == "string" &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (e = arguments[1])),
            (this.value = e);
        }
        clone() {
          return new Jo(
            this.value.clone === void 0 ? this.value : this.value.clone()
          );
        }
      }
      class Ud extends ti {
        constructor(e, t, n = 1) {
          super(e, t), (this.meshPerAttribute = n);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        clone(e) {
          const t = super.clone(e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        }
      }
      Ud.prototype.isInstancedInterleavedBuffer = !0;
      class zd {
        constructor(e, t, n, i, r) {
          (this.buffer = e),
            (this.type = t),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = r),
            (this.version = 0);
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setBuffer(e) {
          return (this.buffer = e), this;
        }
        setType(e, t) {
          return (this.type = e), (this.elementSize = t), this;
        }
        setItemSize(e) {
          return (this.itemSize = e), this;
        }
        setCount(e) {
          return (this.count = e), this;
        }
      }
      zd.prototype.isGLBufferAttribute = !0;
      class C0 {
        constructor(e, t, n = 0, i = 1 / 0) {
          (this.ray = new Qn(e, t)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Ro()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            });
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                .set(e.x, e.y, 0.5)
                .unproject(t)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = t))
            : t.isOrthographicCamera
            ? (this.ray.origin
                .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                .unproject(t),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(t.matrixWorld),
              (this.camera = t))
            : console.error(
                "THREE.Raycaster: Unsupported camera type: " + t.type
              );
        }
        intersectObject(e, t = !0, n = []) {
          return gl(e, this, n, t), n.sort(bu), n;
        }
        intersectObjects(e, t = !0, n = []) {
          for (let i = 0, r = e.length; i < r; i++) gl(e[i], this, n, t);
          return n.sort(bu), n;
        }
      }
      function bu(o, e) {
        return o.distance - e.distance;
      }
      function gl(o, e, t, n) {
        if ((o.layers.test(e.layers) && o.raycast(e, t), n === !0)) {
          const i = o.children;
          for (let r = 0, s = i.length; r < s; r++) gl(i[r], e, t, !0);
        }
      }
      class L0 {
        constructor(e = 1, t = 0, n = 0) {
          return (this.radius = e), (this.phi = t), (this.theta = n), this;
        }
        set(e, t, n) {
          return (this.radius = e), (this.phi = t), (this.theta = n), this;
        }
        copy(e) {
          return (
            (this.radius = e.radius),
            (this.phi = e.phi),
            (this.theta = e.theta),
            this
          );
        }
        makeSafe() {
          return (
            (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
            this
          );
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
          return (
            (this.radius = Math.sqrt(e * e + t * t + n * n)),
            this.radius === 0
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(e, n)),
                (this.phi = Math.acos(lt(t / this.radius, -1, 1)))),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class P0 {
        constructor(e = 1, t = 0, n = 0) {
          return (this.radius = e), (this.theta = t), (this.y = n), this;
        }
        set(e, t, n) {
          return (this.radius = e), (this.theta = t), (this.y = n), this;
        }
        copy(e) {
          return (
            (this.radius = e.radius),
            (this.theta = e.theta),
            (this.y = e.y),
            this
          );
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
          return (
            (this.radius = Math.sqrt(e * e + n * n)),
            (this.theta = Math.atan2(e, n)),
            (this.y = t),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const wu = new W();
      class Fr {
        constructor(e = new W(1 / 0, 1 / 0), t = new W(-1 / 0, -1 / 0)) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = wu.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return wu.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      Fr.prototype.isBox2 = !0;
      const Su = new S(),
        ao = new S();
      class Hd {
        constructor(e = new S(), t = new S()) {
          (this.start = e), (this.end = t);
        }
        set(e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
          return e.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(e) {
          return e.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(e, t) {
          return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
          Su.subVectors(e, this.start), ao.subVectors(this.end, this.start);
          const n = ao.dot(ao);
          let r = ao.dot(Su) / n;
          return t && (r = lt(r, 0, 1)), r;
        }
        closestPointToPoint(e, t, n) {
          const i = this.closestPointToPointParameter(e, t);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Tu = new S();
      class I0 extends Ne {
        constructor(e, t) {
          super(),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = t);
          const n = new _e(),
            i = [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, -1, 1,
            ];
          for (let s = 0, a = 1, l = 32; s < l; s++, a++) {
            const c = (s / l) * Math.PI * 2,
              u = (a / l) * Math.PI * 2;
            i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
          }
          n.setAttribute("position", new pe(i, 3));
          const r = new gt({ fog: !1, toneMapped: !1 });
          (this.cone = new Rt(n, r)), this.add(this.cone), this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
          this.cone.scale.set(t, t, e),
            Tu.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(Tu),
            this.color !== void 0
              ? this.cone.material.color.set(this.color)
              : this.cone.material.color.copy(this.light.color);
        }
      }
      const Bn = new S(),
        lo = new fe(),
        La = new fe();
      class Gd extends Rt {
        constructor(e) {
          const t = kd(e),
            n = new _e(),
            i = [],
            r = [],
            s = new ne(0, 0, 1),
            a = new ne(0, 1, 0);
          for (let c = 0; c < t.length; c++) {
            const u = t[c];
            u.parent &&
              u.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(s.r, s.g, s.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new pe(i, 3)),
            n.setAttribute("color", new pe(r, 3));
          const l = new gt({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, l),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          La.copy(this.root.matrixWorld).invert();
          for (let r = 0, s = 0; r < t.length; r++) {
            const a = t[r];
            a.parent &&
              a.parent.isBone &&
              (lo.multiplyMatrices(La, a.matrixWorld),
              Bn.setFromMatrixPosition(lo),
              i.setXYZ(s, Bn.x, Bn.y, Bn.z),
              lo.multiplyMatrices(La, a.parent.matrixWorld),
              Bn.setFromMatrixPosition(lo),
              i.setXYZ(s + 1, Bn.x, Bn.y, Bn.z),
              (s += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }
      function kd(o) {
        const e = [];
        o.isBone === !0 && e.push(o);
        for (let t = 0; t < o.children.length; t++)
          e.push.apply(e, kd(o.children[t]));
        return e;
      }
      class D0 extends ut {
        constructor(e, t, n) {
          const i = new Li(t, 4, 2),
            r = new Ct({ wireframe: !0, fog: !1, toneMapped: !1 });
          super(i, r),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.color = n),
            (this.type = "PointLightHelper"),
            (this.matrix = this.light.matrixWorld),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          this.color !== void 0
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        }
      }
      const F0 = new S(),
        Eu = new ne(),
        Au = new ne();
      class B0 extends Ne {
        constructor(e, t, n) {
          super(),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n);
          const i = new Ri(t);
          i.rotateY(Math.PI * 0.5),
            (this.material = new Ct({
              wireframe: !0,
              fog: !1,
              toneMapped: !1,
            })),
            this.color === void 0 && (this.material.vertexColors = !0);
          const r = i.getAttribute("position"),
            s = new Float32Array(r.count * 3);
          i.setAttribute("color", new Ue(s, 3)),
            this.add(new ut(i, this.material)),
            this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }
        update() {
          const e = this.children[0];
          if (this.color !== void 0) this.material.color.set(this.color);
          else {
            const t = e.geometry.getAttribute("color");
            Eu.copy(this.light.color), Au.copy(this.light.groundColor);
            for (let n = 0, i = t.count; n < i; n++) {
              const r = n < i / 2 ? Eu : Au;
              t.setXYZ(n, r.r, r.g, r.b);
            }
            t.needsUpdate = !0;
          }
          e.lookAt(F0.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class Vd extends Rt {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new ne(n)), (i = new ne(i));
          const r = t / 2,
            s = e / t,
            a = e / 2,
            l = [],
            c = [];
          for (let d = 0, f = 0, g = -a; d <= t; d++, g += s) {
            l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
            const m = d === r ? n : i;
            m.toArray(c, f),
              (f += 3),
              m.toArray(c, f),
              (f += 3),
              m.toArray(c, f),
              (f += 3),
              m.toArray(c, f),
              (f += 3);
          }
          const u = new _e();
          u.setAttribute("position", new pe(l, 3)),
            u.setAttribute("color", new pe(c, 3));
          const h = new gt({ vertexColors: !0, toneMapped: !1 });
          super(u, h), (this.type = "GridHelper");
        }
      }
      class N0 extends Rt {
        constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
          (r = new ne(r)), (s = new ne(s));
          const a = [],
            l = [];
          for (let h = 0; h <= t; h++) {
            const d = (h / t) * (Math.PI * 2),
              f = Math.sin(d) * e,
              g = Math.cos(d) * e;
            a.push(0, 0, 0), a.push(f, 0, g);
            const m = h & 1 ? r : s;
            l.push(m.r, m.g, m.b), l.push(m.r, m.g, m.b);
          }
          for (let h = 0; h <= n; h++) {
            const d = h & 1 ? r : s,
              f = e - (e / n) * h;
            for (let g = 0; g < i; g++) {
              let m = (g / i) * (Math.PI * 2),
                p = Math.sin(m) * f,
                x = Math.cos(m) * f;
              a.push(p, 0, x),
                l.push(d.r, d.g, d.b),
                (m = ((g + 1) / i) * (Math.PI * 2)),
                (p = Math.sin(m) * f),
                (x = Math.cos(m) * f),
                a.push(p, 0, x),
                l.push(d.r, d.g, d.b);
            }
          }
          const c = new _e();
          c.setAttribute("position", new pe(a, 3)),
            c.setAttribute("color", new pe(l, 3));
          const u = new gt({ vertexColors: !0, toneMapped: !1 });
          super(c, u), (this.type = "PolarGridHelper");
        }
      }
      const Ru = new S(),
        co = new S(),
        Cu = new S();
      class O0 extends Ne {
        constructor(e, t, n) {
          super(),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n),
            t === void 0 && (t = 1);
          let i = new _e();
          i.setAttribute(
            "position",
            new pe([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
          );
          const r = new gt({ fog: !1, toneMapped: !1 });
          (this.lightPlane = new ln(i, r)),
            this.add(this.lightPlane),
            (i = new _e()),
            i.setAttribute("position", new pe([0, 0, 0, 0, 0, 1], 3)),
            (this.targetLine = new ln(i, r)),
            this.add(this.targetLine),
            this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }
        update() {
          Ru.setFromMatrixPosition(this.light.matrixWorld),
            co.setFromMatrixPosition(this.light.target.matrixWorld),
            Cu.subVectors(co, Ru),
            this.lightPlane.lookAt(co),
            this.color !== void 0
              ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color))
              : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(co),
            (this.targetLine.scale.z = Cu.length());
        }
      }
      const uo = new S(),
        rt = new fs();
      class U0 extends Rt {
        constructor(e) {
          const t = new _e(),
            n = new gt({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
            i = [],
            r = [],
            s = {},
            a = new ne(16755200),
            l = new ne(16711680),
            c = new ne(43775),
            u = new ne(16777215),
            h = new ne(3355443);
          d("n1", "n2", a),
            d("n2", "n4", a),
            d("n4", "n3", a),
            d("n3", "n1", a),
            d("f1", "f2", a),
            d("f2", "f4", a),
            d("f4", "f3", a),
            d("f3", "f1", a),
            d("n1", "f1", a),
            d("n2", "f2", a),
            d("n3", "f3", a),
            d("n4", "f4", a),
            d("p", "n1", l),
            d("p", "n2", l),
            d("p", "n3", l),
            d("p", "n4", l),
            d("u1", "u2", c),
            d("u2", "u3", c),
            d("u3", "u1", c),
            d("c", "t", u),
            d("p", "c", h),
            d("cn1", "cn2", h),
            d("cn3", "cn4", h),
            d("cf1", "cf2", h),
            d("cf3", "cf4", h);
          function d(g, m, p) {
            f(g, p), f(m, p);
          }
          function f(g, m) {
            i.push(0, 0, 0),
              r.push(m.r, m.g, m.b),
              s[g] === void 0 && (s[g] = []),
              s[g].push(i.length / 3 - 1);
          }
          t.setAttribute("position", new pe(i, 3)),
            t.setAttribute("color", new pe(r, 3)),
            super(t, n),
            (this.type = "CameraHelper"),
            (this.camera = e),
            this.camera.updateProjectionMatrix &&
              this.camera.updateProjectionMatrix(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.pointMap = s),
            this.update();
        }
        update() {
          const e = this.geometry,
            t = this.pointMap,
            n = 1,
            i = 1;
          rt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            ot("c", t, e, rt, 0, 0, -1),
            ot("t", t, e, rt, 0, 0, 1),
            ot("n1", t, e, rt, -n, -i, -1),
            ot("n2", t, e, rt, n, -i, -1),
            ot("n3", t, e, rt, -n, i, -1),
            ot("n4", t, e, rt, n, i, -1),
            ot("f1", t, e, rt, -n, -i, 1),
            ot("f2", t, e, rt, n, -i, 1),
            ot("f3", t, e, rt, -n, i, 1),
            ot("f4", t, e, rt, n, i, 1),
            ot("u1", t, e, rt, n * 0.7, i * 1.1, -1),
            ot("u2", t, e, rt, -n * 0.7, i * 1.1, -1),
            ot("u3", t, e, rt, 0, i * 2, -1),
            ot("cf1", t, e, rt, -n, 0, 1),
            ot("cf2", t, e, rt, n, 0, 1),
            ot("cf3", t, e, rt, 0, -i, 1),
            ot("cf4", t, e, rt, 0, i, 1),
            ot("cn1", t, e, rt, -n, 0, -1),
            ot("cn2", t, e, rt, n, 0, -1),
            ot("cn3", t, e, rt, 0, -i, -1),
            ot("cn4", t, e, rt, 0, i, -1),
            (e.getAttribute("position").needsUpdate = !0);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      function ot(o, e, t, n, i, r, s) {
        uo.set(i, r, s).unproject(n);
        const a = e[o];
        if (a !== void 0) {
          const l = t.getAttribute("position");
          for (let c = 0, u = a.length; c < u; c++)
            l.setXYZ(a[c], uo.x, uo.y, uo.z);
        }
      }
      const ho = new Lt();
      class Wd extends Rt {
        constructor(e, t = 16776960) {
          const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            i = new Float32Array(8 * 3),
            r = new _e();
          r.setIndex(new Ue(n, 1)),
            r.setAttribute("position", new Ue(i, 3)),
            super(r, new gt({ color: t, toneMapped: !1 })),
            (this.object = e),
            (this.type = "BoxHelper"),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        update(e) {
          if (
            (e !== void 0 &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            this.object !== void 0 && ho.setFromObject(this.object),
            ho.isEmpty())
          )
            return;
          const t = ho.min,
            n = ho.max,
            i = this.geometry.attributes.position,
            r = i.array;
          (r[0] = n.x),
            (r[1] = n.y),
            (r[2] = n.z),
            (r[3] = t.x),
            (r[4] = n.y),
            (r[5] = n.z),
            (r[6] = t.x),
            (r[7] = t.y),
            (r[8] = n.z),
            (r[9] = n.x),
            (r[10] = t.y),
            (r[11] = n.z),
            (r[12] = n.x),
            (r[13] = n.y),
            (r[14] = t.z),
            (r[15] = t.x),
            (r[16] = n.y),
            (r[17] = t.z),
            (r[18] = t.x),
            (r[19] = t.y),
            (r[20] = t.z),
            (r[21] = n.x),
            (r[22] = t.y),
            (r[23] = t.z),
            (i.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
        setFromObject(e) {
          return (this.object = e), this.update(), this;
        }
        copy(e) {
          return (
            Rt.prototype.copy.call(this, e), (this.object = e.object), this
          );
        }
      }
      class z0 extends Rt {
        constructor(e, t = 16776960) {
          const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            i = [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
              -1, -1, 1, -1, -1,
            ],
            r = new _e();
          r.setIndex(new Ue(n, 1)),
            r.setAttribute("position", new pe(i, 3)),
            super(r, new gt({ color: t, toneMapped: !1 })),
            (this.box = e),
            (this.type = "Box3Helper"),
            this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(e) {
          const t = this.box;
          t.isEmpty() ||
            (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            super.updateMatrixWorld(e));
        }
      }
      class H0 extends ln {
        constructor(e, t = 1, n = 16776960) {
          const i = n,
            r = [
              1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
              -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
            ],
            s = new _e();
          s.setAttribute("position", new pe(r, 3)),
            s.computeBoundingSphere(),
            super(s, new gt({ color: i, toneMapped: !1 })),
            (this.type = "PlaneHelper"),
            (this.plane = e),
            (this.size = t);
          const a = [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1,
            ],
            l = new _e();
          l.setAttribute("position", new pe(a, 3)),
            l.computeBoundingSphere(),
            this.add(
              new ut(
                l,
                new Ct({
                  color: i,
                  opacity: 0.2,
                  transparent: !0,
                  depthWrite: !1,
                  toneMapped: !1,
                })
              )
            );
        }
        updateMatrixWorld(e) {
          let t = -this.plane.constant;
          Math.abs(t) < 1e-8 && (t = 1e-8),
            this.scale.set(0.5 * this.size, 0.5 * this.size, t),
            (this.children[0].material.side = t < 0 ? Ft : Gn),
            this.lookAt(this.plane.normal),
            super.updateMatrixWorld(e);
        }
      }
      const Lu = new S();
      let fo, Pa;
      class G0 extends Ne {
        constructor(
          e = new S(0, 0, 1),
          t = new S(0, 0, 0),
          n = 1,
          i = 16776960,
          r = n * 0.2,
          s = r * 0.2
        ) {
          super(),
            (this.type = "ArrowHelper"),
            fo === void 0 &&
              ((fo = new _e()),
              fo.setAttribute("position", new pe([0, 0, 0, 0, 1, 0], 3)),
              (Pa = new Jn(0, 0.5, 1, 5, 1)),
              Pa.translate(0, -0.5, 0)),
            this.position.copy(t),
            (this.line = new ln(fo, new gt({ color: i, toneMapped: !1 }))),
            (this.line.matrixAutoUpdate = !1),
            this.add(this.line),
            (this.cone = new ut(Pa, new Ct({ color: i, toneMapped: !1 }))),
            (this.cone.matrixAutoUpdate = !1),
            this.add(this.cone),
            this.setDirection(e),
            this.setLength(n, r, s);
        }
        setDirection(e) {
          if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
          else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
          else {
            Lu.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(Lu, t);
          }
        }
        setLength(e, t = e * 0.2, n = t * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, t, n),
            (this.cone.position.y = e),
            this.cone.updateMatrix();
        }
        setColor(e) {
          this.line.material.color.set(e), this.cone.material.color.set(e);
        }
        copy(e) {
          return (
            super.copy(e, !1),
            this.line.copy(e.line),
            this.cone.copy(e.cone),
            this
          );
        }
      }
      class qd extends Rt {
        constructor(e = 1) {
          const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            i = new _e();
          i.setAttribute("position", new pe(t, 3)),
            i.setAttribute("color", new pe(n, 3));
          const r = new gt({ vertexColors: !0, toneMapped: !1 });
          super(i, r), (this.type = "AxesHelper");
        }
        setColors(e, t, n) {
          const i = new ne(),
            r = this.geometry.attributes.color.array;
          return (
            i.set(e),
            i.toArray(r, 0),
            i.toArray(r, 3),
            i.set(t),
            i.toArray(r, 6),
            i.toArray(r, 9),
            i.set(n),
            i.toArray(r, 12),
            i.toArray(r, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
          );
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      class k0 {
        constructor() {
          (this.type = "ShapePath"),
            (this.color = new ne()),
            (this.subPaths = []),
            (this.currentPath = null);
        }
        moveTo(e, t) {
          return (
            (this.currentPath = new pr()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t),
            this
          );
        }
        lineTo(e, t) {
          return this.currentPath.lineTo(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          return this.currentPath.quadraticCurveTo(e, t, n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, s) {
          return this.currentPath.bezierCurveTo(e, t, n, i, r, s), this;
        }
        splineThru(e) {
          return this.currentPath.splineThru(e), this;
        }
        toShapes(e, t) {
          function n(y) {
            const v = [];
            for (let M = 0, b = y.length; M < b; M++) {
              const T = y[M],
                C = new on();
              (C.curves = T.curves), v.push(C);
            }
            return v;
          }
          function i(y, v) {
            const M = v.length;
            let b = !1;
            for (let T = M - 1, C = 0; C < M; T = C++) {
              let _ = v[T],
                R = v[C],
                P = R.x - _.x,
                D = R.y - _.y;
              if (Math.abs(D) > Number.EPSILON) {
                if (
                  (D < 0 && ((_ = v[C]), (P = -P), (R = v[T]), (D = -D)),
                  y.y < _.y || y.y > R.y)
                )
                  continue;
                if (y.y === _.y) {
                  if (y.x === _.x) return !0;
                } else {
                  const Z = D * (y.x - _.x) - P * (y.y - _.y);
                  if (Z === 0) return !0;
                  if (Z < 0) continue;
                  b = !b;
                }
              } else {
                if (y.y !== _.y) continue;
                if ((R.x <= y.x && y.x <= _.x) || (_.x <= y.x && y.x <= R.x))
                  return !0;
              }
            }
            return b;
          }
          const r = an.isClockWise,
            s = this.subPaths;
          if (s.length === 0) return [];
          if (t === !0) return n(s);
          let a, l, c;
          const u = [];
          if (s.length === 1)
            return (
              (l = s[0]), (c = new on()), (c.curves = l.curves), u.push(c), u
            );
          let h = !r(s[0].getPoints());
          h = e ? !h : h;
          const d = [],
            f = [];
          let g = [],
            m = 0,
            p;
          (f[m] = void 0), (g[m] = []);
          for (let y = 0, v = s.length; y < v; y++)
            (l = s[y]),
              (p = l.getPoints()),
              (a = r(p)),
              (a = e ? !a : a),
              a
                ? (!h && f[m] && m++,
                  (f[m] = { s: new on(), p }),
                  (f[m].s.curves = l.curves),
                  h && m++,
                  (g[m] = []))
                : g[m].push({ h: l, p: p[0] });
          if (!f[0]) return n(s);
          if (f.length > 1) {
            let y = !1,
              v = 0;
            for (let M = 0, b = f.length; M < b; M++) d[M] = [];
            for (let M = 0, b = f.length; M < b; M++) {
              const T = g[M];
              for (let C = 0; C < T.length; C++) {
                const _ = T[C];
                let R = !0;
                for (let P = 0; P < f.length; P++)
                  i(_.p, f[P].p) &&
                    (M !== P && v++, R ? ((R = !1), d[P].push(_)) : (y = !0));
                R && d[M].push(_);
              }
            }
            v > 0 && y === !1 && (g = d);
          }
          let x;
          for (let y = 0, v = f.length; y < v; y++) {
            (c = f[y].s), u.push(c), (x = g[y]);
            for (let M = 0, b = x.length; M < b; M++) c.holes.push(x[M].h);
          }
          return u;
        }
      }
      class V0 {
        static toHalfFloat(e) {
          Math.abs(e) > 65504 &&
            console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            (e = lt(e, -65504, 65504)),
            (Pu[0] = e);
          const t = Iu[0],
            n = (t >> 23) & 511;
          return Wt[n] + ((t & 8388607) >> qt[n]);
        }
        static fromHalfFloat(e) {
          const t = e >> 10;
          return (Iu[0] = ac[Jd[t] + (e & 1023)] + Br[t]), Pu[0];
        }
      }
      const Xd = new ArrayBuffer(4),
        Pu = new Float32Array(Xd),
        Iu = new Uint32Array(Xd),
        Wt = new Uint32Array(512),
        qt = new Uint32Array(512);
      for (let o = 0; o < 256; ++o) {
        const e = o - 127;
        e < -27
          ? ((Wt[o] = 0),
            (Wt[o | 256] = 32768),
            (qt[o] = 24),
            (qt[o | 256] = 24))
          : e < -14
          ? ((Wt[o] = 1024 >> (-e - 14)),
            (Wt[o | 256] = (1024 >> (-e - 14)) | 32768),
            (qt[o] = -e - 1),
            (qt[o | 256] = -e - 1))
          : e <= 15
          ? ((Wt[o] = (e + 15) << 10),
            (Wt[o | 256] = ((e + 15) << 10) | 32768),
            (qt[o] = 13),
            (qt[o | 256] = 13))
          : e < 128
          ? ((Wt[o] = 31744),
            (Wt[o | 256] = 64512),
            (qt[o] = 24),
            (qt[o | 256] = 24))
          : ((Wt[o] = 31744),
            (Wt[o | 256] = 64512),
            (qt[o] = 13),
            (qt[o | 256] = 13));
      }
      const ac = new Uint32Array(2048),
        Br = new Uint32Array(64),
        Jd = new Uint32Array(64);
      for (let o = 1; o < 1024; ++o) {
        let e = o << 13,
          t = 0;
        for (; (e & 8388608) === 0; ) (e <<= 1), (t -= 8388608);
        (e &= -8388609), (t += 947912704), (ac[o] = e | t);
      }
      for (let o = 1024; o < 2048; ++o) ac[o] = 939524096 + ((o - 1024) << 13);
      for (let o = 1; o < 31; ++o) Br[o] = o << 23;
      Br[31] = 1199570944;
      Br[32] = 2147483648;
      for (let o = 33; o < 63; ++o) Br[o] = 2147483648 + ((o - 32) << 23);
      Br[63] = 3347054592;
      for (let o = 1; o < 64; ++o) o !== 32 && (Jd[o] = 1024);
      const W0 = 0,
        q0 = 1,
        X0 = 0,
        J0 = 1,
        Y0 = 2;
      function j0(o) {
        return (
          console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
          ),
          o
        );
      }
      function K0(o = []) {
        return (
          console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
          ),
          (o.isMultiMaterial = !0),
          (o.materials = o),
          (o.clone = function () {
            return o.slice();
          }),
          o
        );
      }
      class Z0 extends Dr {
        constructor(e, t) {
          console.warn("THREE.PointCloud has been renamed to THREE.Points."),
            super(e, t);
        }
      }
      class $0 extends Oo {
        constructor(e) {
          console.warn("THREE.Particle has been renamed to THREE.Sprite."),
            super(e);
        }
      }
      class Q0 extends Dr {
        constructor(e, t) {
          console.warn(
            "THREE.ParticleSystem has been renamed to THREE.Points."
          ),
            super(e, t);
        }
      }
      class e_ extends ni {
        constructor(e) {
          console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
          ),
            super(e);
        }
      }
      class t_ extends ni {
        constructor(e) {
          console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
          ),
            super(e);
        }
      }
      class n_ extends ni {
        constructor(e) {
          console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
          ),
            super(e);
        }
      }
      class i_ extends S {
        constructor(e, t, n) {
          console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
          ),
            super(e, t, n);
        }
      }
      class r_ extends Ue {
        constructor(e, t) {
          console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
          ),
            super(e, t),
            this.setUsage(dr);
        }
      }
      class s_ extends qh {
        constructor(e, t) {
          console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class o_ extends Xh {
        constructor(e, t) {
          console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class a_ extends Jh {
        constructor(e, t) {
          console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class l_ extends Yh {
        constructor(e, t) {
          console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class c_ extends Co {
        constructor(e, t) {
          console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class u_ extends jh {
        constructor(e, t) {
          console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class h_ extends Lo {
        constructor(e, t) {
          console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class d_ extends pe {
        constructor(e, t) {
          console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      class f_ extends Zh {
        constructor(e, t) {
          console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
          ),
            super(e, t);
        }
      }
      Nt.create = function (o, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (o.prototype = Object.create(Nt.prototype)),
          (o.prototype.constructor = o),
          (o.prototype.getPoint = e),
          o
        );
      };
      pr.prototype.fromPoints = function (o) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(o)
        );
      };
      class p_ extends qd {
        constructor(e) {
          console.warn(
            "THREE.AxisHelper has been renamed to THREE.AxesHelper."
          ),
            super(e);
        }
      }
      class m_ extends Wd {
        constructor(e, t) {
          console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
          ),
            super(e, t);
        }
      }
      class g_ extends Rt {
        constructor(e, t) {
          console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
          ),
            super(
              new Ol(e.geometry),
              new gt({ color: t !== void 0 ? t : 16777215 })
            );
        }
      }
      Vd.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      };
      Gd.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      };
      class x_ extends Rt {
        constructor(e, t) {
          console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
          ),
            super(
              new Ul(e.geometry),
              new gt({ color: t !== void 0 ? t : 16777215 })
            );
        }
      }
      bt.prototype.extractUrlBase = function (o) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Jt.extractUrlBase(o)
        );
      };
      bt.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      };
      class y_ extends Ht {
        constructor(e) {
          console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
            super(e);
        }
      }
      class __ extends Sd {
        constructor(e) {
          console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
          ),
            super(e);
        }
      }
      Fr.prototype.center = function (o) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(o)
        );
      };
      Fr.prototype.empty = function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      Fr.prototype.isIntersectionBox = function (o) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(o)
        );
      };
      Fr.prototype.size = function (o) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(o)
        );
      };
      Lt.prototype.center = function (o) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(o)
        );
      };
      Lt.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      Lt.prototype.isIntersectionBox = function (o) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(o)
        );
      };
      Lt.prototype.isIntersectionSphere = function (o) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(o)
        );
      };
      Lt.prototype.size = function (o) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(o)
        );
      };
      ei.prototype.toVector3 = function () {
        console.error(
          "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
        );
      };
      Tn.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      };
      ps.prototype.setFromMatrix = function (o) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(o)
        );
      };
      Hd.prototype.center = function (o) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(o)
        );
      };
      mt.prototype.flattenToArrayOffset = function (o, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(o, e)
        );
      };
      mt.prototype.multiplyVector3 = function (o) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          o.applyMatrix3(this)
        );
      };
      mt.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      };
      mt.prototype.applyToBufferAttribute = function (o) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          o.applyMatrix3(this)
        );
      };
      mt.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      };
      mt.prototype.getInverse = function (o) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(o).invert()
        );
      };
      fe.prototype.extractPosition = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(o)
        );
      };
      fe.prototype.flattenToArrayOffset = function (o, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(o, e)
        );
      };
      fe.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new S().setFromMatrixColumn(this, 3)
        );
      };
      fe.prototype.setRotationFromQuaternion = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(o)
        );
      };
      fe.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      fe.prototype.multiplyVector3 = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          o.applyMatrix4(this)
        );
      };
      fe.prototype.multiplyVector4 = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          o.applyMatrix4(this)
        );
      };
      fe.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      };
      fe.prototype.rotateAxis = function (o) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          o.transformDirection(this);
      };
      fe.prototype.crossVector = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          o.applyMatrix4(this)
        );
      };
      fe.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      fe.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      fe.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      fe.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      fe.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      fe.prototype.applyToBufferAttribute = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          o.applyMatrix4(this)
        );
      };
      fe.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      };
      fe.prototype.makeFrustum = function (o, e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(o, e, n, t, i, r)
        );
      };
      fe.prototype.getInverse = function (o) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(o).invert()
        );
      };
      nn.prototype.isIntersectionLine = function (o) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(o)
        );
      };
      yt.prototype.multiplyVector3 = function (o) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          o.applyQuaternion(this)
        );
      };
      yt.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      };
      Qn.prototype.isIntersectionBox = function (o) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(o)
        );
      };
      Qn.prototype.isIntersectionPlane = function (o) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(o)
        );
      };
      Qn.prototype.isIntersectionSphere = function (o) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(o)
        );
      };
      ct.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      };
      ct.prototype.barycoordFromPoint = function (o, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(o, e)
        );
      };
      ct.prototype.midpoint = function (o) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(o)
        );
      };
      ct.prototypenormal = function (o) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(o)
        );
      };
      ct.prototype.plane = function (o) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(o)
        );
      };
      ct.barycoordFromPoint = function (o, e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          ct.getBarycoord(o, e, t, n, i)
        );
      };
      ct.normal = function (o, e, t, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          ct.getNormal(o, e, t, n)
        );
      };
      on.prototype.extractAllPoints = function (o) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(o)
        );
      };
      on.prototype.extrude = function (o) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new un(this, o)
        );
      };
      on.prototype.makeGeometry = function (o) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new Ci(this, o)
        );
      };
      W.prototype.fromAttribute = function (o, e, t) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(o, e, t)
        );
      };
      W.prototype.distanceToManhattan = function (o) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(o)
        );
      };
      W.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      S.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      };
      S.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      };
      S.prototype.getPositionFromMatrix = function (o) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(o)
        );
      };
      S.prototype.getScaleFromMatrix = function (o) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(o)
        );
      };
      S.prototype.getColumnFromMatrix = function (o, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, o)
        );
      };
      S.prototype.applyProjection = function (o) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(o)
        );
      };
      S.prototype.fromAttribute = function (o, e, t) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(o, e, t)
        );
      };
      S.prototype.distanceToManhattan = function (o) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(o)
        );
      };
      S.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Je.prototype.fromAttribute = function (o, e, t) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(o, e, t)
        );
      };
      Je.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Ne.prototype.getChildByName = function (o) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(o)
        );
      };
      Ne.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      };
      Ne.prototype.translate = function (o, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, o)
        );
      };
      Ne.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      };
      Ne.prototype.applyMatrix = function (o) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(o)
        );
      };
      Object.defineProperties(Ne.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (o) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = o);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      ut.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      };
      Object.defineProperties(ut.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              Dh
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      });
      ys.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      pt.prototype.setLens = function (o, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          e !== void 0 && (this.filmGauge = e),
          this.setFocalLength(o);
      };
      Object.defineProperties(Yt.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = o);
          },
        },
        shadowCameraLeft: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = o);
          },
        },
        shadowCameraRight: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = o);
          },
        },
        shadowCameraTop: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = o);
          },
        },
        shadowCameraBottom: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = o);
          },
        },
        shadowCameraNear: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = o);
          },
        },
        shadowCameraFar: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = o);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (o) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = o);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = o);
          },
        },
        shadowMapHeight: {
          set: function (o) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = o);
          },
        },
      });
      Object.defineProperties(Ue.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === dr
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(dr);
          },
        },
      });
      Ue.prototype.setDynamic = function (o) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(o === !0 ? dr : hr),
          this
        );
      };
      (Ue.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
        (Ue.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        });
      _e.prototype.addIndex = function (o) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(o);
      };
      _e.prototype.addAttribute = function (o, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(o, new Ue(arguments[1], arguments[2])))
            : o === "index"
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(o, e)
        );
      };
      _e.prototype.addDrawCall = function (o, e, t) {
        t !== void 0 &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(o, e);
      };
      _e.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      };
      _e.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      };
      _e.prototype.removeAttribute = function (o) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(o)
        );
      };
      _e.prototype.applyMatrix = function (o) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(o)
        );
      };
      Object.defineProperties(_e.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      });
      ti.prototype.setDynamic = function (o) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(o === !0 ? dr : hr),
          this
        );
      };
      ti.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      };
      un.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      un.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      };
      un.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      xs.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Jo.prototype.onUpdate = function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      };
      Object.defineProperties(et.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new ne()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (o) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = o === Ml);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (o) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = o);
          },
        },
        vertexTangents: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
          set: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
        },
      });
      Object.defineProperties(zt.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (o) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = o);
          },
        },
      });
      Ke.prototype.clearTarget = function (o, e, t, n) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(o),
          this.clear(e, t, n);
      };
      Ke.prototype.animate = function (o) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(o);
      };
      Ke.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      };
      Ke.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      };
      Ke.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      };
      Ke.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      };
      Ke.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      };
      Ke.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      };
      Ke.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      };
      Ke.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      };
      Ke.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      };
      Ke.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      };
      Ke.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      };
      Ke.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      };
      Ke.prototype.enableScissorTest = function (o) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(o);
      };
      Ke.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      Ke.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      Ke.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      Ke.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      };
      Ke.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      };
      Ke.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      };
      Ke.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      Ke.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      Ke.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      };
      Ke.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      };
      Object.defineProperties(Ke.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = o);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = o);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = o === !0 ? We : Mn);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
        gammaFactor: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              ),
              2
            );
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          },
        },
      });
      Object.defineProperties(od.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      });
      class v_ extends Io {
        constructor(e, t, n) {
          console.warn(
            "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
          ),
            super(e, n);
        }
      }
      Object.defineProperties(Tt.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = o);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = o);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = o);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = o);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = o);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = o);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = o);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = o);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = o);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (o) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = o);
          },
        },
      });
      rc.prototype.load = function (o) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new Ld().load(o, function (n) {
            e.setBuffer(n);
          }),
          this
        );
      };
      Fd.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      };
      Po.prototype.updateCubeMap = function (o, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(o, e)
        );
      };
      Po.prototype.clear = function (o, e, t, n) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(o, e, t, n)
        );
      };
      $n.crossOrigin = void 0;
      $n.loadTexture = function (o, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new Kl();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(o, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      $n.loadTextureCube = function (o, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new wd();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(o, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      $n.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      };
      $n.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      };
      function M_() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function b_() {
        console.error("THREE.JSONLoader has been removed.");
      }
      const w_ = {
        createMultiMaterialObject: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        detach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        attach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
      };
      function S_() {
        console.error(
          "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
        );
      }
      class T_ extends _e {
        constructor() {
          console.error(
            "THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"
          ),
            super();
        }
      }
      class E_ extends _e {
        constructor() {
          console.error(
            "THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"
          ),
            super();
        }
      }
      function A_() {
        console.error(
          "THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js"
        );
      }
      function R_() {
        console.error(
          "THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js"
        );
      }
      function C_() {
        console.error("THREE.ImmediateRenderObject has been removed.");
      }
      class L_ extends Tt {
        constructor(e, t, n) {
          console.error(
            'THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'
          ),
            super(e, t, n),
            (this.samples = 4);
        }
      }
      class P_ extends Cr {
        constructor(e, t, n, i) {
          console.warn(
            "THREE.DataTexture2DArray has been renamed to DataArrayTexture."
          ),
            super(e, t, n, i);
        }
      }
      class I_ extends ds {
        constructor(e, t, n, i) {
          console.warn(
            "THREE.DataTexture3D has been renamed to Data3DTexture."
          ),
            super(e, t, n, i);
        }
      }
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: So } })
        );
      typeof window != "undefined" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = So));
      var D_ = Object.freeze(
        Object.defineProperty(
          {
            __proto__: null,
            ACESFilmicToneMapping: fh,
            AddEquation: pi,
            AddOperation: ch,
            AdditiveAnimationBlendMode: Sl,
            AdditiveBlending: Na,
            AlphaFormat: vh,
            AlwaysDepth: nh,
            AlwaysStencilFunc: Uh,
            AmbientLight: Xo,
            AmbientLightProbe: Id,
            AnimationClip: Ar,
            AnimationLoader: u0,
            AnimationMixer: Od,
            AnimationObjectGroup: Nd,
            AnimationUtils: Qe,
            ArcCurve: Il,
            ArrayCamera: Rl,
            ArrowHelper: G0,
            Audio: rc,
            AudioAnalyser: Fd,
            AudioContext: ic,
            AudioListener: g0,
            AudioLoader: Ld,
            AxesHelper: qd,
            AxisHelper: p_,
            BackSide: Ft,
            BasicDepthPacking: Bh,
            BasicShadowMap: of,
            BinaryTextureLoader: __,
            Bone: _s,
            BooleanKeyframeTrack: Fi,
            BoundingBoxHelper: m_,
            Box2: Fr,
            Box3: Lt,
            Box3Helper: z0,
            BoxBufferGeometry: bn,
            BoxGeometry: bn,
            BoxHelper: Wd,
            BufferAttribute: Ue,
            BufferGeometry: _e,
            BufferGeometryLoader: Cd,
            ByteType: mh,
            Cache: Pi,
            Camera: fs,
            CameraHelper: U0,
            CanvasRenderer: M_,
            CanvasTexture: fd,
            CapsuleBufferGeometry: mr,
            CapsuleGeometry: mr,
            CatmullRomCurve3: Fl,
            CineonToneMapping: dh,
            CircleBufferGeometry: gr,
            CircleGeometry: gr,
            ClampToEdgeWrapping: Mt,
            Clock: Dd,
            Color: ne,
            ColorKeyframeTrack: Yl,
            ColorManagement: Ut,
            CompressedTexture: Pl,
            CompressedTextureLoader: h0,
            ConeBufferGeometry: xr,
            ConeGeometry: xr,
            CubeCamera: Po,
            CubeReflectionMapping: Vn,
            CubeRefractionMapping: Wn,
            CubeTexture: Lr,
            CubeTextureLoader: wd,
            CubeUVReflectionMapping: Rr,
            CubicBezierCurve: zo,
            CubicBezierCurve3: Bl,
            CubicInterpolant: _d,
            CullFaceBack: Ba,
            CullFaceFront: Gu,
            CullFaceFrontBack: sf,
            CullFaceNone: Hu,
            Curve: Nt,
            CurvePath: md,
            CustomBlending: Vu,
            CustomToneMapping: ph,
            CylinderBufferGeometry: Jn,
            CylinderGeometry: Jn,
            Cylindrical: P0,
            Data3DTexture: ds,
            DataArrayTexture: Cr,
            DataTexture: bi,
            DataTexture2DArray: P_,
            DataTexture3D: I_,
            DataTextureLoader: Sd,
            DataUtils: V0,
            DecrementStencilOp: gf,
            DecrementWrapStencilOp: yf,
            DefaultLoadingManager: bd,
            DepthFormat: zn,
            DepthStencilFormat: wi,
            DepthTexture: Cl,
            DirectionalLight: ws,
            DirectionalLightHelper: O0,
            DiscreteInterpolant: vd,
            DodecahedronBufferGeometry: yr,
            DodecahedronGeometry: yr,
            DoubleSide: kn,
            DstAlphaFactor: Ku,
            DstColorFactor: $u,
            DynamicBufferAttribute: r_,
            DynamicCopyUsage: If,
            DynamicDrawUsage: dr,
            DynamicReadUsage: Cf,
            EdgesGeometry: Ol,
            EdgesHelper: g_,
            EllipseCurve: Ms,
            EqualDepth: rh,
            EqualStencilFunc: bf,
            EquirectangularReflectionMapping: Qr,
            EquirectangularRefractionMapping: es,
            Euler: ei,
            EventDispatcher: Zn,
            ExtrudeBufferGeometry: un,
            ExtrudeGeometry: un,
            FaceColors: J0,
            FileLoader: Ht,
            FlatShading: Ml,
            Float16BufferAttribute: Kh,
            Float32Attribute: d_,
            Float32BufferAttribute: pe,
            Float64Attribute: f_,
            Float64BufferAttribute: Zh,
            FloatType: _n,
            Fog: gs,
            FogExp2: ms,
            Font: R_,
            FontLoader: A_,
            FramebufferTexture: dd,
            FrontSide: Gn,
            Frustum: ps,
            GLBufferAttribute: zd,
            GLSL1: Ff,
            GLSL3: ll,
            GreaterDepth: oh,
            GreaterEqualDepth: sh,
            GreaterEqualStencilFunc: Ef,
            GreaterStencilFunc: Sf,
            GridHelper: Vd,
            Group: rn,
            HalfFloatType: cr,
            HemisphereLight: Zl,
            HemisphereLightHelper: B0,
            HemisphereLightProbe: Pd,
            IcosahedronBufferGeometry: _r,
            IcosahedronGeometry: _r,
            ImageBitmapLoader: nc,
            ImageLoader: cs,
            ImageUtils: $n,
            ImmediateRenderObject: C_,
            IncrementStencilOp: mf,
            IncrementWrapStencilOp: xf,
            InstancedBufferAttribute: Ei,
            InstancedBufferGeometry: tc,
            InstancedInterleavedBuffer: Ud,
            InstancedMesh: Ll,
            Int16Attribute: l_,
            Int16BufferAttribute: Yh,
            Int32Attribute: u_,
            Int32BufferAttribute: jh,
            Int8Attribute: s_,
            Int8BufferAttribute: qh,
            IntType: xh,
            InterleavedBuffer: ti,
            InterleavedBufferAttribute: wn,
            Interpolant: hn,
            InterpolateDiscrete: ur,
            InterpolateLinear: Si,
            InterpolateSmooth: yo,
            InvertStencilOp: _f,
            JSONLoader: b_,
            KeepStencilOp: _o,
            KeyframeTrack: jt,
            LOD: ud,
            LatheBufferGeometry: Ai,
            LatheGeometry: Ai,
            Layers: Ro,
            LensFlare: S_,
            LessDepth: ih,
            LessEqualDepth: Mo,
            LessEqualStencilFunc: wf,
            LessStencilFunc: Mf,
            Light: Yt,
            LightProbe: Ss,
            Line: ln,
            Line3: Hd,
            LineBasicMaterial: gt,
            LineCurve: bs,
            LineCurve3: pd,
            LineDashedMaterial: Xl,
            LineLoop: Uo,
            LinePieces: q0,
            LineSegments: Rt,
            LineStrip: W0,
            LinearEncoding: Mn,
            LinearFilter: tt,
            LinearInterpolant: Jl,
            LinearMipMapLinearFilter: hf,
            LinearMipMapNearestFilter: uf,
            LinearMipmapLinearFilter: Sn,
            LinearMipmapNearestFilter: Eo,
            LinearSRGBColorSpace: On,
            LinearToneMapping: uh,
            Loader: bt,
            LoaderUtils: Jt,
            LoadingManager: jl,
            LoopOnce: Lh,
            LoopPingPong: Ih,
            LoopRepeat: Ph,
            LuminanceAlphaFormat: wh,
            LuminanceFormat: bh,
            MOUSE: nf,
            Material: et,
            MaterialLoader: Rd,
            Math: ul,
            MathUtils: ul,
            Matrix3: mt,
            Matrix4: fe,
            MaxEquation: Ha,
            Mesh: ut,
            MeshBasicMaterial: Ct,
            MeshDepthMaterial: Fo,
            MeshDistanceMaterial: Bo,
            MeshFaceMaterial: j0,
            MeshLambertMaterial: Wl,
            MeshMatcapMaterial: ql,
            MeshNormalMaterial: Vl,
            MeshPhongMaterial: Gl,
            MeshPhysicalMaterial: En,
            MeshStandardMaterial: Di,
            MeshToonMaterial: kl,
            MinEquation: za,
            MirroredRepeatWrapping: ar,
            MixOperation: lh,
            MultiMaterial: K0,
            MultiplyBlending: Ua,
            MultiplyOperation: hs,
            NearestFilter: at,
            NearestMipMapLinearFilter: cf,
            NearestMipMapNearestFilter: lf,
            NearestMipmapLinearFilter: ns,
            NearestMipmapNearestFilter: ts,
            NeverDepth: th,
            NeverStencilFunc: vf,
            NoBlending: vn,
            NoColorSpace: df,
            NoColors: X0,
            NoToneMapping: sn,
            NormalAnimationBlendMode: Ao,
            NormalBlending: yi,
            NotEqualDepth: ah,
            NotEqualStencilFunc: Tf,
            NumberKeyframeTrack: Tr,
            Object3D: Ne,
            ObjectLoader: d0,
            ObjectSpaceNormalMap: Oh,
            OctahedronBufferGeometry: Ri,
            OctahedronGeometry: Ri,
            OneFactor: Ju,
            OneMinusDstAlphaFactor: Zu,
            OneMinusDstColorFactor: Qu,
            OneMinusSrcAlphaFactor: wl,
            OneMinusSrcColorFactor: ju,
            OrthographicCamera: Pr,
            PCFShadowMap: vl,
            PCFSoftShadowMap: ku,
            PMREMGenerator: hl,
            ParametricGeometry: T_,
            Particle: $0,
            ParticleBasicMaterial: t_,
            ParticleSystem: Q0,
            ParticleSystemMaterial: n_,
            Path: pr,
            PerspectiveCamera: pt,
            Plane: nn,
            PlaneBufferGeometry: Ti,
            PlaneGeometry: Ti,
            PlaneHelper: H0,
            PointCloud: Z0,
            PointCloudMaterial: e_,
            PointLight: qo,
            PointLightHelper: D0,
            Points: Dr,
            PointsMaterial: ni,
            PolarGridHelper: N0,
            PolyhedronBufferGeometry: cn,
            PolyhedronGeometry: cn,
            PositionalAudio: y0,
            PropertyBinding: Ge,
            PropertyMixer: Bd,
            QuadraticBezierCurve: Ho,
            QuadraticBezierCurve3: Go,
            Quaternion: yt,
            QuaternionKeyframeTrack: jn,
            QuaternionLinearInterpolant: Md,
            REVISION: So,
            RGBADepthPacking: Nh,
            RGBAFormat: Dt,
            RGBAIntegerFormat: Rh,
            RGBA_ASTC_10x10_Format: rl,
            RGBA_ASTC_10x5_Format: tl,
            RGBA_ASTC_10x6_Format: nl,
            RGBA_ASTC_10x8_Format: il,
            RGBA_ASTC_12x10_Format: sl,
            RGBA_ASTC_12x12_Format: ol,
            RGBA_ASTC_4x4_Format: Ja,
            RGBA_ASTC_5x4_Format: Ya,
            RGBA_ASTC_5x5_Format: ja,
            RGBA_ASTC_6x5_Format: Ka,
            RGBA_ASTC_6x6_Format: Za,
            RGBA_ASTC_8x5_Format: $a,
            RGBA_ASTC_8x6_Format: Qa,
            RGBA_ASTC_8x8_Format: el,
            RGBA_BPTC_Format: al,
            RGBA_ETC2_EAC_Format: Xa,
            RGBA_PVRTC_2BPPV1_Format: Wa,
            RGBA_PVRTC_4BPPV1_Format: Va,
            RGBA_S3TC_DXT1_Format: mo,
            RGBA_S3TC_DXT3_Format: go,
            RGBA_S3TC_DXT5_Format: xo,
            RGBFormat: Mh,
            RGB_ETC1_Format: Ch,
            RGB_ETC2_Format: qa,
            RGB_PVRTC_2BPPV1_Format: ka,
            RGB_PVRTC_4BPPV1_Format: Ga,
            RGB_S3TC_DXT1_Format: po,
            RGFormat: Eh,
            RGIntegerFormat: Ah,
            RawShaderMaterial: Hl,
            Ray: Qn,
            Raycaster: C0,
            RectAreaLight: Ql,
            RedFormat: Sh,
            RedIntegerFormat: Th,
            ReinhardToneMapping: hh,
            RepeatWrapping: qn,
            ReplaceStencilOp: pf,
            ReverseSubtractEquation: qu,
            RingBufferGeometry: vr,
            RingGeometry: vr,
            SRGBColorSpace: tn,
            Scene: xs,
            SceneUtils: w_,
            ShaderChunk: Be,
            ShaderLib: Xt,
            ShaderMaterial: zt,
            ShadowMaterial: zl,
            Shape: on,
            ShapeBufferGeometry: Ci,
            ShapeGeometry: Ci,
            ShapePath: k0,
            ShapeUtils: an,
            ShortType: gh,
            Skeleton: vs,
            SkeletonHelper: Gd,
            SkinnedMesh: ys,
            SmoothShading: af,
            Source: Un,
            Sphere: Tn,
            SphereBufferGeometry: Li,
            SphereGeometry: Li,
            Spherical: L0,
            SphericalHarmonics3: ec,
            SplineCurve: ko,
            SpotLight: Wo,
            SpotLightHelper: I0,
            Sprite: Oo,
            SpriteMaterial: No,
            SrcAlphaFactor: bl,
            SrcAlphaSaturateFactor: eh,
            SrcColorFactor: Yu,
            StaticCopyUsage: Pf,
            StaticDrawUsage: hr,
            StaticReadUsage: Rf,
            StereoCamera: p0,
            StreamCopyUsage: Df,
            StreamDrawUsage: Af,
            StreamReadUsage: Lf,
            StringKeyframeTrack: Bi,
            SubtractEquation: Wu,
            SubtractiveBlending: Oa,
            TOUCH: rf,
            TangentSpaceNormalMap: Kn,
            TetrahedronBufferGeometry: Mr,
            TetrahedronGeometry: Mr,
            TextGeometry: E_,
            Texture: st,
            TextureLoader: Kl,
            TorusBufferGeometry: br,
            TorusGeometry: br,
            TorusKnotBufferGeometry: wr,
            TorusKnotGeometry: wr,
            Triangle: ct,
            TriangleFanDrawMode: Tl,
            TriangleStripDrawMode: Fh,
            TrianglesDrawMode: Dh,
            TubeBufferGeometry: Sr,
            TubeGeometry: Sr,
            UVMapping: To,
            Uint16Attribute: c_,
            Uint16BufferAttribute: Co,
            Uint32Attribute: h_,
            Uint32BufferAttribute: Lo,
            Uint8Attribute: o_,
            Uint8BufferAttribute: Xh,
            Uint8ClampedAttribute: a_,
            Uint8ClampedBufferAttribute: Jh,
            Uniform: Jo,
            UniformsLib: ae,
            UniformsUtils: $h,
            UnsignedByteType: Xn,
            UnsignedInt248Type: _i,
            UnsignedIntType: jr,
            UnsignedShort4444Type: yh,
            UnsignedShort5551Type: _h,
            UnsignedShortType: lr,
            VSMShadowMap: ir,
            Vector2: W,
            Vector3: S,
            Vector4: Je,
            VectorKeyframeTrack: Er,
            Vertex: i_,
            VertexColors: Y0,
            VideoTexture: hd,
            WebGL1Renderer: ld,
            WebGL3DRenderTarget: Vh,
            WebGLArrayRenderTarget: kh,
            WebGLCubeRenderTarget: Io,
            WebGLMultipleRenderTargets: Wh,
            WebGLMultisampleRenderTarget: L_,
            WebGLRenderTarget: Tt,
            WebGLRenderTargetCube: v_,
            WebGLRenderer: Ke,
            WebGLUtils: ad,
            WireframeGeometry: Ul,
            WireframeHelper: x_,
            WrapAroundEnding: is,
            XHRLoader: y_,
            ZeroCurvatureEnding: gi,
            ZeroFactor: Xu,
            ZeroSlopeEnding: xi,
            ZeroStencilOp: ff,
            _SRGBAFormat: bo,
            sRGBEncoding: We,
          },
          Symbol.toStringTag,
          { value: "Module" }
        )
      );
      class F_ extends bt {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new z_(t);
            }),
            this.register(function (t) {
              return new q_(t);
            }),
            this.register(function (t) {
              return new X_(t);
            }),
            this.register(function (t) {
              return new H_(t);
            }),
            this.register(function (t) {
              return new G_(t);
            }),
            this.register(function (t) {
              return new k_(t);
            }),
            this.register(function (t) {
              return new V_(t);
            }),
            this.register(function (t) {
              return new U_(t);
            }),
            this.register(function (t) {
              return new W_(t);
            }),
            this.register(function (t) {
              return new N_(t);
            }),
            this.register(function (t) {
              return new J_(t);
            });
        }
        load(e, t, n, i) {
          const r = this;
          let s;
          this.resourcePath !== ""
            ? (s = this.resourcePath)
            : this.path !== ""
            ? (s = this.path)
            : (s = Jt.extractUrlBase(e)),
            this.manager.itemStart(e);
          const a = function (c) {
              i ? i(c) : console.error(c),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            },
            l = new Ht(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
              e,
              function (c) {
                try {
                  r.parse(
                    c,
                    s,
                    function (u) {
                      t(u), r.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (u) {
                  a(u);
                }
              },
              n,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            this.pluginCallbacks.indexOf(e) === -1 &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            this.pluginCallbacks.indexOf(e) !== -1 &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let r;
          const s = {},
            a = {};
          if (typeof e == "string") r = e;
          else if (Jt.decodeText(new Uint8Array(e, 0, 4)) === Yd) {
            try {
              s[Oe.KHR_BINARY_GLTF] = new Y_(e);
            } catch (h) {
              i && i(h);
              return;
            }
            r = s[Oe.KHR_BINARY_GLTF].content;
          } else r = Jt.decodeText(new Uint8Array(e));
          const l = JSON.parse(r);
          if (l.asset === void 0 || l.asset.version[0] < 2) {
            i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              );
            return;
          }
          const c = new av(l, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const h = this.pluginCallbacks[u](c);
            (a[h.name] = h), (s[h.name] = !0);
          }
          if (l.extensionsUsed)
            for (let u = 0; u < l.extensionsUsed.length; ++u) {
              const h = l.extensionsUsed[u],
                d = l.extensionsRequired || [];
              switch (h) {
                case Oe.KHR_MATERIALS_UNLIT:
                  s[h] = new O_();
                  break;
                case Oe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  s[h] = new Z_();
                  break;
                case Oe.KHR_DRACO_MESH_COMPRESSION:
                  s[h] = new j_(l, this.dracoLoader);
                  break;
                case Oe.KHR_TEXTURE_TRANSFORM:
                  s[h] = new K_();
                  break;
                case Oe.KHR_MESH_QUANTIZATION:
                  s[h] = new $_();
                  break;
                default:
                  d.indexOf(h) >= 0 &&
                    a[h] === void 0 &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + h + '".'
                    );
              }
            }
          c.setExtensions(s), c.setPlugins(a), c.parse(n, i);
        }
        parseAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.parse(e, t, i, r);
          });
        }
      }
      function B_() {
        let o = {};
        return {
          get: function (e) {
            return o[e];
          },
          add: function (e, t) {
            o[e] = t;
          },
          remove: function (e) {
            delete o[e];
          },
          removeAll: function () {
            o = {};
          },
        };
      }
      const Oe = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      };
      class N_ {
        constructor(e) {
          (this.parser = e),
            (this.name = Oe.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            r.extensions &&
              r.extensions[this.name] &&
              r.extensions[this.name].light !== void 0 &&
              e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let i = t.cache.get(n);
          if (i) return i;
          const r = t.json,
            l = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[e];
          let c;
          const u = new ne(16777215);
          l.color !== void 0 && u.fromArray(l.color);
          const h = l.range !== void 0 ? l.range : 0;
          switch (l.type) {
            case "directional":
              (c = new ws(u)), c.target.position.set(0, 0, -1), c.add(c.target);
              break;
            case "point":
              (c = new qo(u)), (c.distance = h);
              break;
            case "spot":
              (c = new Wo(u)),
                (c.distance = h),
                (l.spot = l.spot || {}),
                (l.spot.innerConeAngle =
                  l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
                (l.spot.outerConeAngle =
                  l.spot.outerConeAngle !== void 0
                    ? l.spot.outerConeAngle
                    : Math.PI / 4),
                (c.angle = l.spot.outerConeAngle),
                (c.penumbra =
                  1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
                c.target.position.set(0, 0, -1),
                c.add(c.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + l.type
              );
          }
          return (
            c.position.set(0, 0, 0),
            (c.decay = 2),
            l.intensity !== void 0 && (c.intensity = l.intensity),
            (c.name = t.createUniqueName(l.name || "light_" + e)),
            (i = Promise.resolve(c)),
            t.cache.add(n, i),
            i
          );
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            a = ((r.extensions && r.extensions[this.name]) || {}).light;
          return a === void 0
            ? null
            : this._loadLight(a).then(function (l) {
                return n._getNodeRef(t.cache, a, l);
              });
        }
      }
      class O_ {
        constructor() {
          this.name = Oe.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return Ct;
        }
        extendParams(e, t, n) {
          const i = [];
          (e.color = new ne(1, 1, 1)), (e.opacity = 1);
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const s = r.baseColorFactor;
              e.color.fromArray(s), (e.opacity = s[3]);
            }
            r.baseColorTexture !== void 0 &&
              i.push(n.assignTexture(e, "map", r.baseColorTexture, We));
          }
          return Promise.all(i);
        }
      }
      class U_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_EMISSIVE_STRENGTH);
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = i.extensions[this.name].emissiveStrength;
          return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
        }
      }
      class z_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          if (
            (s.clearcoatFactor !== void 0 && (t.clearcoat = s.clearcoatFactor),
            s.clearcoatTexture !== void 0 &&
              r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
            s.clearcoatRoughnessFactor !== void 0 &&
              (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
            s.clearcoatRoughnessTexture !== void 0 &&
              r.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  s.clearcoatRoughnessTexture
                )
              ),
            s.clearcoatNormalTexture !== void 0 &&
              (r.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  s.clearcoatNormalTexture
                )
              ),
              s.clearcoatNormalTexture.scale !== void 0))
          ) {
            const a = s.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new W(a, a);
          }
          return Promise.all(r);
        }
      }
      class H_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_SHEEN);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [];
          (t.sheenColor = new ne(0, 0, 0)),
            (t.sheenRoughness = 0),
            (t.sheen = 1);
          const s = i.extensions[this.name];
          return (
            s.sheenColorFactor !== void 0 &&
              t.sheenColor.fromArray(s.sheenColorFactor),
            s.sheenRoughnessFactor !== void 0 &&
              (t.sheenRoughness = s.sheenRoughnessFactor),
            s.sheenColorTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, We)
              ),
            s.sheenRoughnessTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class G_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            s.transmissionFactor !== void 0 &&
              (t.transmission = s.transmissionFactor),
            s.transmissionTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "transmissionMap", s.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class k_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_VOLUME);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          (t.thickness = s.thicknessFactor !== void 0 ? s.thicknessFactor : 0),
            s.thicknessTexture !== void 0 &&
              r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)),
            (t.attenuationDistance = s.attenuationDistance || 0);
          const a = s.attenuationColor || [1, 1, 1];
          return (
            (t.attenuationColor = new ne(a[0], a[1], a[2])), Promise.all(r)
          );
        }
      }
      class V_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_IOR);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = i.extensions[this.name];
          return (t.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
        }
      }
      class W_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_MATERIALS_SPECULAR);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          (t.specularIntensity =
            s.specularFactor !== void 0 ? s.specularFactor : 1),
            s.specularTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "specularIntensityMap", s.specularTexture)
              );
          const a = s.specularColorFactor || [1, 1, 1];
          return (
            (t.specularColor = new ne(a[0], a[1], a[2])),
            s.specularColorTexture !== void 0 &&
              r.push(
                n.assignTexture(
                  t,
                  "specularColorMap",
                  s.specularColorTexture,
                  We
                )
              ),
            Promise.all(r)
          );
        }
      }
      class q_ {
        constructor(e) {
          (this.parser = e), (this.name = Oe.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            s = t.options.ktx2Loader;
          if (!s) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, r.source, s);
        }
      }
      class X_ {
        constructor(e) {
          (this.parser = e),
            (this.name = Oe.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const s = r.extensions[t],
            a = i.images[s.source];
          let l = n.textureLoader;
          if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c);
          }
          return this.detectSupport().then(function (c) {
            if (c) return n.loadTextureImage(e, s.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(t.height === 1);
                    });
              })),
            this.isSupported
          );
        }
      }
      class J_ {
        constructor(e) {
          (this.name = Oe.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
              r = this.parser.getDependency("buffer", i.buffer),
              s = this.parser.options.meshoptDecoder;
            if (!s || !s.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return Promise.all([r, s.ready]).then(function (a) {
              const l = i.byteOffset || 0,
                c = i.byteLength || 0,
                u = i.count,
                h = i.byteStride,
                d = new ArrayBuffer(u * h),
                f = new Uint8Array(a[0], l, c);
              return (
                s.decodeGltfBuffer(
                  new Uint8Array(d),
                  u,
                  h,
                  f,
                  i.mode,
                  i.filter
                ),
                d
              );
            });
          } else return null;
        }
      }
      const Yd = "glTF",
        Xr = 12,
        Du = { JSON: 1313821514, BIN: 5130562 };
      class Y_ {
        constructor(e) {
          (this.name = Oe.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, Xr);
          if (
            ((this.header = {
              magic: Jt.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== Yd)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - Xr,
            i = new DataView(e, Xr);
          let r = 0;
          for (; r < n; ) {
            const s = i.getUint32(r, !0);
            r += 4;
            const a = i.getUint32(r, !0);
            if (((r += 4), a === Du.JSON)) {
              const l = new Uint8Array(e, Xr + r, s);
              this.content = Jt.decodeText(l);
            } else if (a === Du.BIN) {
              const l = Xr + r;
              this.body = e.slice(l, l + s);
            }
            r += s;
          }
          if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class j_ {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = Oe.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            i = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            s = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
          for (const u in s) {
            const h = yl[u] || u.toLowerCase();
            a[h] = s[u];
          }
          for (const u in e.attributes) {
            const h = yl[u] || u.toLowerCase();
            if (s[u] !== void 0) {
              const d = n.accessors[e.attributes[u]],
                f = us[d.componentType];
              (c[h] = f), (l[h] = d.normalized === !0);
            }
          }
          return t.getDependency("bufferView", r).then(function (u) {
            return new Promise(function (h) {
              i.decodeDracoFile(
                u,
                function (d) {
                  for (const f in d.attributes) {
                    const g = d.attributes[f],
                      m = l[f];
                    m !== void 0 && (g.normalized = m);
                  }
                  h(d);
                },
                a,
                c
              );
            });
          });
        }
      }
      class K_ {
        constructor() {
          this.name = Oe.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            t.texCoord !== void 0 &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.'
              ),
            (t.offset === void 0 &&
              t.rotation === void 0 &&
              t.scale === void 0) ||
              ((e = e.clone()),
              t.offset !== void 0 && e.offset.fromArray(t.offset),
              t.rotation !== void 0 && (e.rotation = t.rotation),
              t.scale !== void 0 && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class xl extends Di {
        constructor(e) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0);
          const t = [
              "#ifdef USE_SPECULARMAP",
              "	uniform sampler2D specularMap;",
              "#endif",
            ].join(`
`),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "	uniform sampler2D glossinessMap;",
              "#endif",
            ].join(`
`),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "	vec4 texelSpecular = texture2D( specularMap, vUv );",
              "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	specularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join(`
`),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	glossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join(`
`),
            s = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.roughness += geometryRoughness;",
              "material.roughness = min( material.roughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join(`
`),
            a = {
              specular: { value: new ne().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = a),
            (this.onBeforeCompile = function (l) {
              for (const c in a) l.uniforms[c] = a[c];
              l.fragmentShader = l.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", t)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", r)
                .replace("#include <lights_physical_fragment>", s);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return a.specular.value;
                },
                set: function (l) {
                  a.specular.value = l;
                },
              },
              specularMap: {
                get: function () {
                  return a.specularMap.value;
                },
                set: function (l) {
                  (a.specularMap.value = l),
                    l
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return a.glossiness.value;
                },
                set: function (l) {
                  a.glossiness.value = l;
                },
              },
              glossinessMap: {
                get: function () {
                  return a.glossinessMap.value;
                },
                set: function (l) {
                  (a.glossinessMap.value = l),
                    l
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.specularMap = e.specularMap),
            this.specular.copy(e.specular),
            (this.glossinessMap = e.glossinessMap),
            (this.glossiness = e.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          );
        }
      }
      class Z_ {
        constructor() {
          (this.name = Oe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
            ]);
        }
        getMaterialType() {
          return xl;
        }
        extendParams(e, t, n) {
          const i = t.extensions[this.name];
          (e.color = new ne(1, 1, 1)), (e.opacity = 1);
          const r = [];
          if (Array.isArray(i.diffuseFactor)) {
            const s = i.diffuseFactor;
            e.color.fromArray(s), (e.opacity = s[3]);
          }
          if (
            (i.diffuseTexture !== void 0 &&
              r.push(n.assignTexture(e, "map", i.diffuseTexture, We)),
            (e.emissive = new ne(0, 0, 0)),
            (e.glossiness =
              i.glossinessFactor !== void 0 ? i.glossinessFactor : 1),
            (e.specular = new ne(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              e.specular.fromArray(i.specularFactor),
            i.specularGlossinessTexture !== void 0)
          ) {
            const s = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", s)),
              r.push(n.assignTexture(e, "specularMap", s, We));
          }
          return Promise.all(r);
        }
        createMaterial(e) {
          const t = new xl(e);
          return (
            (t.fog = !0),
            (t.color = e.color),
            (t.map = e.map === void 0 ? null : e.map),
            (t.lightMap = null),
            (t.lightMapIntensity = 1),
            (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
            (t.aoMapIntensity = 1),
            (t.emissive = e.emissive),
            (t.emissiveIntensity =
              e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity),
            (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
            (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
            (t.bumpScale = 1),
            (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
            (t.normalMapType = Kn),
            e.normalScale && (t.normalScale = e.normalScale),
            (t.displacementMap = null),
            (t.displacementScale = 1),
            (t.displacementBias = 0),
            (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
            (t.specular = e.specular),
            (t.glossinessMap =
              e.glossinessMap === void 0 ? null : e.glossinessMap),
            (t.glossiness = e.glossiness),
            (t.alphaMap = null),
            (t.envMap = e.envMap === void 0 ? null : e.envMap),
            (t.envMapIntensity = 1),
            t
          );
        }
      }
      class $_ {
        constructor() {
          this.name = Oe.KHR_MESH_QUANTIZATION;
        }
      }
      class Ii extends hn {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i;
          for (let s = 0; s !== i; s++) t[s] = n[r + s];
          return t;
        }
      }
      Ii.prototype.beforeStart_ = Ii.prototype.copySampleValue_;
      Ii.prototype.afterEnd_ = Ii.prototype.copySampleValue_;
      Ii.prototype.interpolate_ = function (o, e, t, n) {
        const i = this.resultBuffer,
          r = this.sampleValues,
          s = this.valueSize,
          a = s * 2,
          l = s * 3,
          c = n - e,
          u = (t - e) / c,
          h = u * u,
          d = h * u,
          f = o * l,
          g = f - l,
          m = -2 * d + 3 * h,
          p = d - h,
          x = 1 - m,
          y = p - h + u;
        for (let v = 0; v !== s; v++) {
          const M = r[g + v + s],
            b = r[g + v + a] * c,
            T = r[f + v + s],
            C = r[f + v] * c;
          i[v] = x * M + y * b + m * T + p * C;
        }
        return i;
      };
      const Q_ = new yt();
      class ev extends Ii {
        interpolate_(e, t, n, i) {
          const r = super.interpolate_(e, t, n, i);
          return Q_.fromArray(r).normalize().toArray(r), r;
        }
      }
      const yn = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        us = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        Fu = { 9728: at, 9729: tt, 9984: ts, 9985: Eo, 9986: ns, 9987: Sn },
        Bu = { 33071: Mt, 33648: ar, 10497: qn },
        Nu = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        yl = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        Nn = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        tv = { CUBICSPLINE: void 0, LINEAR: Si, STEP: ur },
        Ia = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
      function nv(o) {
        return (
          o.DefaultMaterial === void 0 &&
            (o.DefaultMaterial = new Di({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: Gn,
            })),
          o.DefaultMaterial
        );
      }
      function Jr(o, e, t) {
        for (const n in t.extensions)
          o[n] === void 0 &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[n] = t.extensions[n]));
      }
      function fi(o, e) {
        e.extras !== void 0 &&
          (typeof e.extras == "object"
            ? Object.assign(o.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function iv(o, e, t) {
        let n = !1,
          i = !1,
          r = !1;
        for (let c = 0, u = e.length; c < u; c++) {
          const h = e[c];
          if (
            (h.POSITION !== void 0 && (n = !0),
            h.NORMAL !== void 0 && (i = !0),
            h.COLOR_0 !== void 0 && (r = !0),
            n && i && r)
          )
            break;
        }
        if (!n && !i && !r) return Promise.resolve(o);
        const s = [],
          a = [],
          l = [];
        for (let c = 0, u = e.length; c < u; c++) {
          const h = e[c];
          if (n) {
            const d =
              h.POSITION !== void 0
                ? t.getDependency("accessor", h.POSITION)
                : o.attributes.position;
            s.push(d);
          }
          if (i) {
            const d =
              h.NORMAL !== void 0
                ? t.getDependency("accessor", h.NORMAL)
                : o.attributes.normal;
            a.push(d);
          }
          if (r) {
            const d =
              h.COLOR_0 !== void 0
                ? t.getDependency("accessor", h.COLOR_0)
                : o.attributes.color;
            l.push(d);
          }
        }
        return Promise.all([
          Promise.all(s),
          Promise.all(a),
          Promise.all(l),
        ]).then(function (c) {
          const u = c[0],
            h = c[1],
            d = c[2];
          return (
            n && (o.morphAttributes.position = u),
            i && (o.morphAttributes.normal = h),
            r && (o.morphAttributes.color = d),
            (o.morphTargetsRelative = !0),
            o
          );
        });
      }
      function rv(o, e) {
        if ((o.updateMorphTargets(), e.weights !== void 0))
          for (let t = 0, n = e.weights.length; t < n; t++)
            o.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (o.morphTargetInfluences.length === t.length) {
            o.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
              o.morphTargetDictionary[t[n]] = n;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function sv(o) {
        const e = o.extensions && o.extensions[Oe.KHR_DRACO_MESH_COMPRESSION];
        let t;
        return (
          e
            ? (t =
                "draco:" +
                e.bufferView +
                ":" +
                e.indices +
                ":" +
                Ou(e.attributes))
            : (t = o.indices + ":" + Ou(o.attributes) + ":" + o.mode),
          t
        );
      }
      function Ou(o) {
        let e = "";
        const t = Object.keys(o).sort();
        for (let n = 0, i = t.length; n < i; n++)
          e += t[n] + ":" + o[t[n]] + ";";
        return e;
      }
      function _l(o) {
        switch (o) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      function ov(o) {
        return o.search(/\.jpe?g($|\?)/i) > 0 ||
          o.search(/^data\:image\/jpeg/) === 0
          ? "image/jpeg"
          : o.search(/\.webp($|\?)/i) > 0 ||
            o.search(/^data\:image\/webp/) === 0
          ? "image/webp"
          : "image/png";
      }
      class av {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new B_()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.sourceCache = {}),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {});
          const n =
              /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
            i = navigator.userAgent.indexOf("Firefox") > -1,
            r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
          typeof createImageBitmap == "undefined" || n || (i && r < 98)
            ? (this.textureLoader = new Kl(this.options.manager))
            : (this.textureLoader = new nc(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new Ht(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            this.options.crossOrigin === "use-credentials" &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            this._invokeAll(function (s) {
              return s._markDefs && s._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (s) {
                return s.beforeRoot && s.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (s) {
                const a = {
                  scene: s[0][i.scene || 0],
                  scenes: s[0],
                  animations: s[1],
                  cameras: s[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                Jr(r, a, i),
                  fi(a, i),
                  Promise.all(
                    n._invokeAll(function (l) {
                      return l.afterRoot && l.afterRoot(a);
                    })
                  ).then(function () {
                    e(a);
                  });
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i].joints;
            for (let a = 0, l = s.length; a < l; a++) e[s[a]].isBone = !0;
          }
          for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            s.mesh !== void 0 &&
              (this._addNodeRef(this.meshCache, s.mesh),
              s.skin !== void 0 && (n[s.mesh].isSkinnedMesh = !0)),
              s.camera !== void 0 &&
                this._addNodeRef(this.cameraCache, s.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 &&
            (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone(),
            r = (s, a) => {
              const l = this.associations.get(s);
              l != null && this.associations.set(a, l);
              for (const [c, u] of s.children.entries()) r(u, a.children[c]);
            };
          return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this.loadNode(t);
                break;
              case "mesh":
                i = this._invokeOne(function (r) {
                  return r.loadMesh && r.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (r) {
                  return r.loadBufferView && r.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (r) {
                  return r.loadMaterial && r.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (r) {
                  return r.loadTexture && r.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this._invokeOne(function (r) {
                  return r.loadAnimation && r.loadAnimation(t);
                });
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (r, s) {
                return n.getDependency(e, s);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && t.type !== "arraybuffer")
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Oe.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (r, s) {
            n.load(Jt.resolveURL(t.uri, i.path), r, void 0, function () {
              s(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (n) {
            const i = t.byteLength || 0,
              r = t.byteOffset || 0;
            return n.slice(r, r + i);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            i = this.json.accessors[e];
          if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
          const r = [];
          return (
            i.bufferView !== void 0
              ? r.push(this.getDependency("bufferView", i.bufferView))
              : r.push(null),
            i.sparse !== void 0 &&
              (r.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              r.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(r).then(function (s) {
              const a = s[0],
                l = Nu[i.type],
                c = us[i.componentType],
                u = c.BYTES_PER_ELEMENT,
                h = u * l,
                d = i.byteOffset || 0,
                f =
                  i.bufferView !== void 0
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                g = i.normalized === !0;
              let m, p;
              if (f && f !== h) {
                const x = Math.floor(d / f),
                  y =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    x +
                    ":" +
                    i.count;
                let v = t.cache.get(y);
                v ||
                  ((m = new c(a, x * f, (i.count * f) / u)),
                  (v = new ti(m, f / u)),
                  t.cache.add(y, v)),
                  (p = new wn(v, l, (d % f) / u, g));
              } else a === null ? (m = new c(i.count * l)) : (m = new c(a, d, i.count * l)), (p = new Ue(m, l, g));
              if (i.sparse !== void 0) {
                const x = Nu.SCALAR,
                  y = us[i.sparse.indices.componentType],
                  v = i.sparse.indices.byteOffset || 0,
                  M = i.sparse.values.byteOffset || 0,
                  b = new y(s[1], v, i.sparse.count * x),
                  T = new c(s[2], M, i.sparse.count * l);
                a !== null &&
                  (p = new Ue(p.array.slice(), p.itemSize, p.normalized));
                for (let C = 0, _ = b.length; C < _; C++) {
                  const R = b[C];
                  if (
                    (p.setX(R, T[C * l]),
                    l >= 2 && p.setY(R, T[C * l + 1]),
                    l >= 3 && p.setZ(R, T[C * l + 2]),
                    l >= 4 && p.setW(R, T[C * l + 3]),
                    l >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return p;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            r = t.textures[e].source,
            s = t.images[r];
          let a = this.textureLoader;
          if (s.uri) {
            const l = n.manager.getHandler(s.uri);
            l !== null && (a = l);
          }
          return this.loadTextureImage(e, r, a);
        }
        loadTextureImage(e, t, n) {
          const i = this,
            r = this.json,
            s = r.textures[e],
            a = r.images[t],
            l = (a.uri || a.bufferView) + ":" + s.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = this.loadImageSource(t, n)
            .then(function (u) {
              (u.flipY = !1), s.name && (u.name = s.name);
              const d = (r.samplers || {})[s.sampler] || {};
              return (
                (u.magFilter = Fu[d.magFilter] || tt),
                (u.minFilter = Fu[d.minFilter] || Sn),
                (u.wrapS = Bu[d.wrapS] || qn),
                (u.wrapT = Bu[d.wrapT] || qn),
                i.associations.set(u, { textures: e }),
                u
              );
            })
            .catch(function () {
              return null;
            });
          return (this.textureCache[l] = c), c;
        }
        loadImageSource(e, t) {
          const n = this,
            i = this.json,
            r = this.options;
          if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then((h) => h.clone());
          const s = i.images[e],
            a = self.URL || self.webkitURL;
          let l = s.uri || "",
            c = !1;
          if (s.bufferView !== void 0)
            l = n.getDependency("bufferView", s.bufferView).then(function (h) {
              c = !0;
              const d = new Blob([h], { type: s.mimeType });
              return (l = a.createObjectURL(d)), l;
            });
          else if (s.uri === void 0)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const u = Promise.resolve(l)
            .then(function (h) {
              return new Promise(function (d, f) {
                let g = d;
                t.isImageBitmapLoader === !0 &&
                  (g = function (m) {
                    const p = new st(m);
                    (p.needsUpdate = !0), d(p);
                  }),
                  t.load(Jt.resolveURL(h, r.path), g, void 0, f);
              });
            })
            .then(function (h) {
              return (
                c === !0 && a.revokeObjectURL(l),
                (h.userData.mimeType = s.mimeType || ov(s.uri)),
                h
              );
            })
            .catch(function (h) {
              throw (
                (console.error("THREE.GLTFLoader: Couldn't load texture", l), h)
              );
            });
          return (this.sourceCache[e] = u), u;
        }
        assignTexture(e, t, n, i) {
          const r = this;
          return this.getDependency("texture", n.index).then(function (s) {
            if (
              (n.texCoord !== void 0 &&
                n.texCoord != 0 &&
                !(t === "aoMap" && n.texCoord == 1) &&
                console.warn(
                  "THREE.GLTFLoader: Custom UV set " +
                    n.texCoord +
                    " for texture " +
                    t +
                    " not yet supported."
                ),
              r.extensions[Oe.KHR_TEXTURE_TRANSFORM])
            ) {
              const a =
                n.extensions !== void 0
                  ? n.extensions[Oe.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (a) {
                const l = r.associations.get(s);
                (s = r.extensions[Oe.KHR_TEXTURE_TRANSFORM].extendTexture(
                  s,
                  a
                )),
                  r.associations.set(s, l);
              }
            }
            return i !== void 0 && (s.encoding = i), (e[t] = s), s;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const i = t.attributes.tangent === void 0,
            r = t.attributes.color !== void 0,
            s = t.attributes.normal === void 0;
          if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l ||
              ((l = new ni()),
              et.prototype.copy.call(l, n),
              l.color.copy(n.color),
              (l.map = n.map),
              (l.sizeAttenuation = !1),
              this.cache.add(a, l)),
              (n = l);
          } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l ||
              ((l = new gt()),
              et.prototype.copy.call(l, n),
              l.color.copy(n.color),
              this.cache.add(a, l)),
              (n = l);
          }
          if (i || r || s) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
              i && (a += "derivative-tangents:"),
              r && (a += "vertex-colors:"),
              s && (a += "flat-shading:");
            let l = this.cache.get(a);
            l ||
              ((l = n.clone()),
              r && (l.vertexColors = !0),
              s && (l.flatShading = !0),
              i &&
                (l.normalScale && (l.normalScale.y *= -1),
                l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
              this.cache.add(a, l),
              this.associations.set(l, this.associations.get(n))),
              (n = l);
          }
          n.aoMap &&
            t.attributes.uv2 === void 0 &&
            t.attributes.uv !== void 0 &&
            t.setAttribute("uv2", t.attributes.uv),
            (e.material = n);
        }
        getMaterialType() {
          return Di;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[e];
          let s;
          const a = {},
            l = r.extensions || {},
            c = [];
          if (l[Oe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const h = i[Oe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            (s = h.getMaterialType()), c.push(h.extendParams(a, r, t));
          } else if (l[Oe.KHR_MATERIALS_UNLIT]) {
            const h = i[Oe.KHR_MATERIALS_UNLIT];
            (s = h.getMaterialType()), c.push(h.extendParams(a, r, t));
          } else {
            const h = r.pbrMetallicRoughness || {};
            if (
              ((a.color = new ne(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(h.baseColorFactor))
            ) {
              const d = h.baseColorFactor;
              a.color.fromArray(d), (a.opacity = d[3]);
            }
            h.baseColorTexture !== void 0 &&
              c.push(t.assignTexture(a, "map", h.baseColorTexture, We)),
              (a.metalness =
                h.metallicFactor !== void 0 ? h.metallicFactor : 1),
              (a.roughness =
                h.roughnessFactor !== void 0 ? h.roughnessFactor : 1),
              h.metallicRoughnessTexture !== void 0 &&
                (c.push(
                  t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)
                ),
                c.push(
                  t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture)
                )),
              (s = this._invokeOne(function (d) {
                return d.getMaterialType && d.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (d) {
                    return (
                      d.extendMaterialParams && d.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          r.doubleSided === !0 && (a.side = kn);
          const u = r.alphaMode || Ia.OPAQUE;
          if (
            (u === Ia.BLEND
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                u === Ia.MASK &&
                  (a.alphaTest =
                    r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
            r.normalTexture !== void 0 &&
              s !== Ct &&
              (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
              (a.normalScale = new W(1, 1)),
              r.normalTexture.scale !== void 0))
          ) {
            const h = r.normalTexture.scale;
            a.normalScale.set(h, h);
          }
          return (
            r.occlusionTexture !== void 0 &&
              s !== Ct &&
              (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
              r.occlusionTexture.strength !== void 0 &&
                (a.aoMapIntensity = r.occlusionTexture.strength)),
            r.emissiveFactor !== void 0 &&
              s !== Ct &&
              (a.emissive = new ne().fromArray(r.emissiveFactor)),
            r.emissiveTexture !== void 0 &&
              s !== Ct &&
              c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, We)),
            Promise.all(c).then(function () {
              let h;
              return (
                s === xl
                  ? (h =
                      i[
                        Oe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(a))
                  : (h = new s(a)),
                r.name && (h.name = r.name),
                fi(h, r),
                t.associations.set(h, { materials: e }),
                r.extensions && Jr(i, h, r),
                h
              );
            })
          );
        }
        createUniqueName(e) {
          const t = Ge.sanitizeNodeName(e || "");
          let n = t;
          for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
          return (this.nodeNamesUsed[n] = !0), n;
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            i = this.primitiveCache;
          function r(a) {
            return n[Oe.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(a, t)
              .then(function (l) {
                return Uu(l, a, t);
              });
          }
          const s = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              u = sv(c),
              h = i[u];
            if (h) s.push(h.promise);
            else {
              let d;
              c.extensions && c.extensions[Oe.KHR_DRACO_MESH_COMPRESSION]
                ? (d = r(c))
                : (d = Uu(new _e(), c, t)),
                (i[u] = { primitive: c, promise: d }),
                s.push(d);
            }
          }
          return Promise.all(s);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[e],
            s = r.primitives,
            a = [];
          for (let l = 0, c = s.length; l < c; l++) {
            const u =
              s[l].material === void 0
                ? nv(this.cache)
                : this.getDependency("material", s[l].material);
            a.push(u);
          }
          return (
            a.push(t.loadGeometries(s)),
            Promise.all(a).then(function (l) {
              const c = l.slice(0, l.length - 1),
                u = l[l.length - 1],
                h = [];
              for (let f = 0, g = u.length; f < g; f++) {
                const m = u[f],
                  p = s[f];
                let x;
                const y = c[f];
                if (
                  p.mode === yn.TRIANGLES ||
                  p.mode === yn.TRIANGLE_STRIP ||
                  p.mode === yn.TRIANGLE_FAN ||
                  p.mode === void 0
                )
                  (x = r.isSkinnedMesh === !0 ? new ys(m, y) : new ut(m, y)),
                    x.isSkinnedMesh === !0 &&
                      !x.geometry.attributes.skinWeight.normalized &&
                      x.normalizeSkinWeights(),
                    p.mode === yn.TRIANGLE_STRIP
                      ? (x.geometry = zu(x.geometry, Fh))
                      : p.mode === yn.TRIANGLE_FAN &&
                        (x.geometry = zu(x.geometry, Tl));
                else if (p.mode === yn.LINES) x = new Rt(m, y);
                else if (p.mode === yn.LINE_STRIP) x = new ln(m, y);
                else if (p.mode === yn.LINE_LOOP) x = new Uo(m, y);
                else if (p.mode === yn.POINTS) x = new Dr(m, y);
                else
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + p.mode
                  );
                Object.keys(x.geometry.morphAttributes).length > 0 && rv(x, r),
                  (x.name = t.createUniqueName(r.name || "mesh_" + e)),
                  fi(x, r),
                  p.extensions && Jr(i, x, p),
                  t.assignFinalMaterial(x),
                  h.push(x);
              }
              for (let f = 0, g = h.length; f < g; f++)
                t.associations.set(h[f], { meshes: e, primitives: f });
              if (h.length === 1) return h[0];
              const d = new rn();
              t.associations.set(d, { meshes: e });
              for (let f = 0, g = h.length; f < g; f++) d.add(h[f]);
              return d;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            i = n[n.type];
          if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return (
            n.type === "perspective"
              ? (t = new pt(
                  ul.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : n.type === "orthographic" &&
                (t = new Pr(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            fi(t, n),
            Promise.resolve(t)
          );
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = { joints: t.joints };
          return t.inverseBindMatrices === void 0
            ? Promise.resolve(n)
            : this.getDependency("accessor", t.inverseBindMatrices).then(
                function (i) {
                  return (n.inverseBindMatrices = i), n;
                }
              );
        }
        loadAnimation(e) {
          const n = this.json.animations[e],
            i = [],
            r = [],
            s = [],
            a = [],
            l = [];
          for (let c = 0, u = n.channels.length; c < u; c++) {
            const h = n.channels[c],
              d = n.samplers[h.sampler],
              f = h.target,
              g = f.node !== void 0 ? f.node : f.id,
              m = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
              p = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
            i.push(this.getDependency("node", g)),
              r.push(this.getDependency("accessor", m)),
              s.push(this.getDependency("accessor", p)),
              a.push(d),
              l.push(f);
          }
          return Promise.all([
            Promise.all(i),
            Promise.all(r),
            Promise.all(s),
            Promise.all(a),
            Promise.all(l),
          ]).then(function (c) {
            const u = c[0],
              h = c[1],
              d = c[2],
              f = c[3],
              g = c[4],
              m = [];
            for (let x = 0, y = u.length; x < y; x++) {
              const v = u[x],
                M = h[x],
                b = d[x],
                T = f[x],
                C = g[x];
              if (v === void 0) continue;
              v.updateMatrix(), (v.matrixAutoUpdate = !0);
              let _;
              switch (Nn[C.path]) {
                case Nn.weights:
                  _ = Tr;
                  break;
                case Nn.rotation:
                  _ = jn;
                  break;
                case Nn.position:
                case Nn.scale:
                default:
                  _ = Er;
                  break;
              }
              const R = v.name ? v.name : v.uuid,
                P = T.interpolation !== void 0 ? tv[T.interpolation] : Si,
                D = [];
              Nn[C.path] === Nn.weights
                ? v.traverse(function (j) {
                    j.morphTargetInfluences && D.push(j.name ? j.name : j.uuid);
                  })
                : D.push(R);
              let Z = b.array;
              if (b.normalized) {
                const j = _l(Z.constructor),
                  I = new Float32Array(Z.length);
                for (let U = 0, N = Z.length; U < N; U++) I[U] = Z[U] * j;
                Z = I;
              }
              for (let j = 0, I = D.length; j < I; j++) {
                const U = new _(D[j] + "." + Nn[C.path], M.array, Z, P);
                T.interpolation === "CUBICSPLINE" &&
                  ((U.createInterpolant = function (V) {
                    const J = this instanceof jn ? ev : Ii;
                    return new J(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      V
                    );
                  }),
                  (U.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  m.push(U);
              }
            }
            const p = n.name ? n.name : "animation_" + e;
            return new Ar(p, void 0, m);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return i.mesh === void 0
            ? null
            : n.getDependency("mesh", i.mesh).then(function (r) {
                const s = n._getNodeRef(n.meshCache, i.mesh, r);
                return (
                  i.weights !== void 0 &&
                    s.traverse(function (a) {
                      if (!!a.isMesh)
                        for (let l = 0, c = i.weights.length; l < c; l++)
                          a.morphTargetInfluences[l] = i.weights[l];
                    }),
                  s
                );
              });
        }
        loadNode(e) {
          const t = this.json,
            n = this.extensions,
            i = this,
            r = t.nodes[e],
            s = r.name ? i.createUniqueName(r.name) : "";
          return (function () {
            const a = [],
              l = i._invokeOne(function (c) {
                return c.createNodeMesh && c.createNodeMesh(e);
              });
            return (
              l && a.push(l),
              r.camera !== void 0 &&
                a.push(
                  i.getDependency("camera", r.camera).then(function (c) {
                    return i._getNodeRef(i.cameraCache, r.camera, c);
                  })
                ),
              i
                ._invokeAll(function (c) {
                  return c.createNodeAttachment && c.createNodeAttachment(e);
                })
                .forEach(function (c) {
                  a.push(c);
                }),
              Promise.all(a)
            );
          })().then(function (a) {
            let l;
            if (
              (r.isBone === !0
                ? (l = new _s())
                : a.length > 1
                ? (l = new rn())
                : a.length === 1
                ? (l = a[0])
                : (l = new Ne()),
              l !== a[0])
            )
              for (let c = 0, u = a.length; c < u; c++) l.add(a[c]);
            if (
              (r.name && ((l.userData.name = r.name), (l.name = s)),
              fi(l, r),
              r.extensions && Jr(n, l, r),
              r.matrix !== void 0)
            ) {
              const c = new fe();
              c.fromArray(r.matrix), l.applyMatrix4(c);
            } else r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
            return (
              i.associations.has(l) || i.associations.set(l, {}),
              (i.associations.get(l).nodes = e),
              l
            );
          });
        }
        loadScene(e) {
          const t = this.json,
            n = this.extensions,
            i = this.json.scenes[e],
            r = this,
            s = new rn();
          i.name && (s.name = r.createUniqueName(i.name)),
            fi(s, i),
            i.extensions && Jr(n, s, i);
          const a = i.nodes || [],
            l = [];
          for (let c = 0, u = a.length; c < u; c++) l.push(jd(a[c], s, t, r));
          return Promise.all(l).then(function () {
            const c = (u) => {
              const h = new Map();
              for (const [d, f] of r.associations)
                (d instanceof et || d instanceof st) && h.set(d, f);
              return (
                u.traverse((d) => {
                  const f = r.associations.get(d);
                  f != null && h.set(d, f);
                }),
                h
              );
            };
            return (r.associations = c(s)), s;
          });
        }
      }
      function jd(o, e, t, n) {
        const i = t.nodes[o];
        return n
          .getDependency("node", o)
          .then(function (r) {
            if (i.skin === void 0) return r;
            let s;
            return n
              .getDependency("skin", i.skin)
              .then(function (a) {
                s = a;
                const l = [];
                for (let c = 0, u = s.joints.length; c < u; c++)
                  l.push(n.getDependency("node", s.joints[c]));
                return Promise.all(l);
              })
              .then(function (a) {
                return (
                  r.traverse(function (l) {
                    if (!l.isMesh) return;
                    const c = [],
                      u = [];
                    for (let h = 0, d = a.length; h < d; h++) {
                      const f = a[h];
                      if (f) {
                        c.push(f);
                        const g = new fe();
                        s.inverseBindMatrices !== void 0 &&
                          g.fromArray(s.inverseBindMatrices.array, h * 16),
                          u.push(g);
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          s.joints[h]
                        );
                    }
                    l.bind(new vs(c, u), l.matrixWorld);
                  }),
                  r
                );
              });
          })
          .then(function (r) {
            e.add(r);
            const s = [];
            if (i.children) {
              const a = i.children;
              for (let l = 0, c = a.length; l < c; l++) {
                const u = a[l];
                s.push(jd(u, r, t, n));
              }
            }
            return Promise.all(s);
          });
      }
      function lv(o, e, t) {
        const n = e.attributes,
          i = new Lt();
        if (n.POSITION !== void 0) {
          const a = t.json.accessors[n.POSITION],
            l = a.min,
            c = a.max;
          if (l !== void 0 && c !== void 0) {
            if (
              (i.set(new S(l[0], l[1], l[2]), new S(c[0], c[1], c[2])),
              a.normalized)
            ) {
              const u = _l(us[a.componentType]);
              i.min.multiplyScalar(u), i.max.multiplyScalar(u);
            }
          } else {
            console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
            return;
          }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
          const a = new S(),
            l = new S();
          for (let c = 0, u = r.length; c < u; c++) {
            const h = r[c];
            if (h.POSITION !== void 0) {
              const d = t.json.accessors[h.POSITION],
                f = d.min,
                g = d.max;
              if (f !== void 0 && g !== void 0) {
                if (
                  (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))),
                  l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))),
                  l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))),
                  d.normalized)
                ) {
                  const m = _l(us[d.componentType]);
                  l.multiplyScalar(m);
                }
                a.max(l);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          i.expandByVector(a);
        }
        o.boundingBox = i;
        const s = new Tn();
        i.getCenter(s.center),
          (s.radius = i.min.distanceTo(i.max) / 2),
          (o.boundingSphere = s);
      }
      function Uu(o, e, t) {
        const n = e.attributes,
          i = [];
        function r(s, a) {
          return t.getDependency("accessor", s).then(function (l) {
            o.setAttribute(a, l);
          });
        }
        for (const s in n) {
          const a = yl[s] || s.toLowerCase();
          a in o.attributes || i.push(r(n[s], a));
        }
        if (e.indices !== void 0 && !o.index) {
          const s = t.getDependency("accessor", e.indices).then(function (a) {
            o.setIndex(a);
          });
          i.push(s);
        }
        return (
          fi(o, e),
          lv(o, e, t),
          Promise.all(i).then(function () {
            return e.targets !== void 0 ? iv(o, e.targets, t) : o;
          })
        );
      }
      function zu(o, e) {
        let t = o.getIndex();
        if (t === null) {
          const s = [],
            a = o.getAttribute("position");
          if (a !== void 0) {
            for (let l = 0; l < a.count; l++) s.push(l);
            o.setIndex(s), (t = o.getIndex());
          } else
            return (
              console.error(
                "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
              ),
              o
            );
        }
        const n = t.count - 2,
          i = [];
        if (e === Tl)
          for (let s = 1; s <= n; s++)
            i.push(t.getX(0)), i.push(t.getX(s)), i.push(t.getX(s + 1));
        else
          for (let s = 0; s < n; s++)
            s % 2 === 0
              ? (i.push(t.getX(s)),
                i.push(t.getX(s + 1)),
                i.push(t.getX(s + 2)))
              : (i.push(t.getX(s + 2)),
                i.push(t.getX(s + 1)),
                i.push(t.getX(s)));
        i.length / 3 !== n &&
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
          );
        const r = o.clone();
        return r.setIndex(i), r;
      }
      class cv {
        constructor({
          anchor: e = { lat: 0, lng: 0, altitude: 0 },
          rotation: t = new Float32Array([0, 0, 0]),
          scale: n = new Float32Array([1, 1, 1]),
          scene: i,
          THREE: r,
          map: s,
        }) {
          (this.overlay = new google.maps.WebGLOverlayView()),
            (this.renderer = null),
            (this.camera = null),
            (this.anchor = e),
            (this.rotation = t),
            (this.scale = n),
            (this.THREE = r),
            (this.scene = i != null ? i : new this.THREE.Scene()),
            (this.scene.rotation.x = Math.PI / 2),
            (this.overlay.onAdd = this.onAdd.bind(this)),
            (this.overlay.onRemove = this.onRemove.bind(this)),
            (this.overlay.onContextLost = this.onContextLost.bind(this)),
            (this.overlay.onContextRestored =
              this.onContextRestored.bind(this)),
            (this.overlay.onDraw = this.onDraw.bind(this)),
            (this.camera = new this.THREE.PerspectiveCamera()),
            s && this.setMap(s);
        }
        onStateUpdate(e) {
          this.overlay.onStateUpdate(e);
        }
        requestStateUpdate() {
          this.overlay.requestStateUpdate();
        }
        onAdd() {}
        onRemove() {}
        getMap() {
          return this.overlay.getMap();
        }
        requestRedraw() {
          this.overlay.requestRedraw();
        }
        setMap(e) {
          this.overlay.setMap(e);
        }
        addListener(e, t) {
          return this.overlay.addListener(e, t);
        }
        bindTo(e, t, n, i) {
          this.overlay.bindTo(e, t, n, i);
        }
        get(e) {
          return this.overlay.get(e);
        }
        notify(e) {
          this.overlay.notify(e);
        }
        set(e, t) {
          this.overlay.set(e, t);
        }
        setValues(e) {
          this.overlay.setValues(e);
        }
        unbind(e) {
          this.overlay.unbind(e);
        }
        unbindAll() {
          this.overlay.unbindAll();
        }
        onContextRestored({ gl: e }) {
          (this.renderer = new this.THREE.WebGLRenderer(
            Object.assign(
              { canvas: e.canvas, context: e },
              e.getContextAttributes()
            )
          )),
            (this.renderer.autoClear = !1),
            (this.renderer.autoClearDepth = !1),
            (this.renderer.shadowMap.enabled = !0),
            (this.renderer.shadowMap.type = this.THREE.PCFSoftShadowMap),
            (this.renderer.outputEncoding = this.THREE.sRGBEncoding);
          const { width: t, height: n, clientWidth: i } = e.canvas;
          this.renderer.setPixelRatio(t / i), this.renderer.setSize(t, n, !1);
        }
        onContextLost() {
          !this.renderer || (this.renderer.dispose(), (this.renderer = null));
        }
        onDraw({ gl: e, transformer: t }) {
          this.camera.projectionMatrix.fromArray(
            t.fromLatLngAltitude(this.anchor, this.rotation, this.scale)
          ),
            e.disable(e.SCISSOR_TEST),
            this.requestRedraw(),
            this.renderer.render(this.scene, this.camera),
            this.renderer.resetState();
        }
      }
      let Da;
      const Fa = {
        tilt: 0,
        heading: 0,
        zoom: 18,
        center: { lat: 35.6594945, lng: 139.6999859 },
        mapId: "15431d2b469f209e",
        disableDefaultUI: !0,
        gestureHandling: "none",
        keyboardShortcuts: !1,
      };
      function uv() {
        const o = document.getElementById("map");
        Da = new google.maps.Map(o, Fa);
        const e = new xs(),
          t = new Xo(16777215, 0.75);
        e.add(t);
        const n = new ws(16777215, 0.25);
        n.position.set(0, 10, 50), e.add(n);
        const i = new F_(),
          r =
            "https://raw.githubusercontent.com/googlemaps/js-samples/main/assets/pin.gltf";
        i.load(r, (s) => {
          s.scene.scale.set(10, 10, 10),
            (s.scene.rotation.x = Math.PI / 2),
            e.add(s.scene);
          let { tilt: a, heading: l, zoom: c } = Fa;
          const u = () => {
            if (a < 67.5) a += 0.5;
            else if (l <= 360) (l += 0.2), (c -= 5e-4);
            else return;
            Da.moveCamera({ tilt: a, heading: l, zoom: c }),
              requestAnimationFrame(u);
          };
          requestAnimationFrame(u);
        }),
          new cv({
            map: Da,
            scene: e,
            anchor: { ...Fa.center, altitude: 100 },
            THREE: D_,
          });
      }
      window.initMap = uv;
    </script>
    <style>
      #map,
      body,
      html {
        height: 100%;
      }
      body,
      html {
        margin: 0;
        padding: 0;
      }
      #map {
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="map" class="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=beta"
      defer
    ></script>
  </body>
</html>
