<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Simple ThreeJS Overlay View</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://unpkg.com/three@0.129.0/build/three.min.js"></script>

    <script type="module" crossorigin>
      const Xg = function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
          n(i);
        new MutationObserver((i) => {
          for (const r of i)
            if (r.type === "childList")
              for (const o of r.addedNodes)
                o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(i) {
          const r = {};
          return (
            i.integrity && (r.integrity = i.integrity),
            i.referrerpolicy && (r.referrerPolicy = i.referrerpolicy),
            i.crossorigin === "use-credentials"
              ? (r.credentials = "include")
              : i.crossorigin === "anonymous"
              ? (r.credentials = "omit")
              : (r.credentials = "same-origin"),
            r
          );
        }
        function n(i) {
          if (i.ep) return;
          i.ep = !0;
          const r = t(i);
          fetch(i.href, r);
        }
      };
      Xg();
      /**
       * @license
       * Copyright 2010-2021 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const Wp = "129",
        jg = 0,
        Hu = 1,
        Yg = 2,
        $p = 1,
        Zg = 2,
        lo = 3,
        So = 0,
        Rt = 1,
        ko = 2,
        qp = 1,
        po = 0,
        mo = 1,
        Gu = 2,
        Vu = 3,
        ku = 4,
        Jg = 5,
        jr = 100,
        Kg = 101,
        Qg = 102,
        Wu = 103,
        $u = 104,
        ex = 200,
        tx = 201,
        nx = 202,
        ix = 203,
        Xp = 204,
        jp = 205,
        rx = 206,
        sx = 207,
        ox = 208,
        ax = 209,
        lx = 210,
        cx = 0,
        hx = 1,
        ux = 2,
        ph = 3,
        dx = 4,
        fx = 5,
        px = 6,
        mx = 7,
        yl = 0,
        gx = 1,
        xx = 2,
        go = 0,
        _x = 1,
        vx = 2,
        yx = 3,
        Mx = 4,
        bx = 5,
        Yp = 300,
        Gh = 301,
        Vh = 302,
        qu = 303,
        Xu = 304,
        kh = 306,
        Wh = 307,
        ls = 1e3,
        rn = 1001,
        ll = 1002,
        zt = 1003,
        mh = 1004,
        gh = 1005,
        sn = 1006,
        Zp = 1007,
        ys = 1008,
        $h = 1009,
        wx = 1010,
        Sx = 1011,
        cl = 1012,
        Tx = 1013,
        sl = 1014,
        Pi = 1015,
        hl = 1016,
        Ex = 1017,
        Ax = 1018,
        Lx = 1019,
        xo = 1020,
        Rx = 1021,
        Ni = 1022,
        In = 1023,
        Cx = 1024,
        Px = 1025,
        is = 1026,
        To = 1027,
        Dx = 1028,
        Ix = 1029,
        Nx = 1030,
        Fx = 1031,
        Bx = 1032,
        zx = 1033,
        ju = 33776,
        Yu = 33777,
        Zu = 33778,
        Ju = 33779,
        Ku = 35840,
        Qu = 35841,
        ed = 35842,
        td = 35843,
        Ox = 36196,
        nd = 37492,
        id = 37496,
        Ux = 37808,
        Hx = 37809,
        Gx = 37810,
        Vx = 37811,
        kx = 37812,
        Wx = 37813,
        $x = 37814,
        qx = 37815,
        Xx = 37816,
        jx = 37817,
        Yx = 37818,
        Zx = 37819,
        Jx = 37820,
        Kx = 37821,
        Qx = 36492,
        e_ = 37840,
        t_ = 37841,
        n_ = 37842,
        i_ = 37843,
        r_ = 37844,
        s_ = 37845,
        o_ = 37846,
        a_ = 37847,
        l_ = 37848,
        c_ = 37849,
        h_ = 37850,
        u_ = 37851,
        d_ = 37852,
        f_ = 37853,
        p_ = 2200,
        m_ = 2201,
        g_ = 2202,
        Eo = 2300,
        cs = 2301,
        Wl = 2302,
        Zr = 2400,
        Jr = 2401,
        ul = 2402,
        qh = 2500,
        Jp = 2501,
        x_ = 0,
        __ = 1,
        Kp = 2,
        Wo = 3e3,
        dl = 3001,
        v_ = 3007,
        y_ = 3002,
        M_ = 3003,
        b_ = 3004,
        w_ = 3005,
        S_ = 3006,
        T_ = 3200,
        E_ = 3201,
        sr = 0,
        A_ = 1,
        $l = 7680,
        L_ = 519,
        Ao = 35044,
        fl = 35048,
        rd = "300 es";
      class or {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e];
          if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e.type];
          if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
            e.target = null;
          }
        }
      }
      const Ft = [];
      for (let s = 0; s < 256; s++)
        Ft[s] = (s < 16 ? "0" : "") + s.toString(16);
      let Jo = 1234567;
      const _o = Math.PI / 180,
        Lo = 180 / Math.PI;
      function _n() {
        const s = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          Ft[s & 255] +
          Ft[(s >> 8) & 255] +
          Ft[(s >> 16) & 255] +
          Ft[(s >> 24) & 255] +
          "-" +
          Ft[e & 255] +
          Ft[(e >> 8) & 255] +
          "-" +
          Ft[((e >> 16) & 15) | 64] +
          Ft[(e >> 24) & 255] +
          "-" +
          Ft[(t & 63) | 128] +
          Ft[(t >> 8) & 255] +
          "-" +
          Ft[(t >> 16) & 255] +
          Ft[(t >> 24) & 255] +
          Ft[n & 255] +
          Ft[(n >> 8) & 255] +
          Ft[(n >> 16) & 255] +
          Ft[(n >> 24) & 255]
        ).toUpperCase();
      }
      function en(s, e, t) {
        return Math.max(e, Math.min(t, s));
      }
      function Xh(s, e) {
        return ((s % e) + e) % e;
      }
      function R_(s, e, t, n, i) {
        return n + ((s - e) * (i - n)) / (t - e);
      }
      function C_(s, e, t) {
        return s !== e ? (t - s) / (e - s) : 0;
      }
      function vo(s, e, t) {
        return (1 - t) * s + t * e;
      }
      function P_(s, e, t, n) {
        return vo(s, e, 1 - Math.exp(-t * n));
      }
      function D_(s, e = 1) {
        return e - Math.abs(Xh(s, e * 2) - e);
      }
      function I_(s, e, t) {
        return s <= e
          ? 0
          : s >= t
          ? 1
          : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
      }
      function N_(s, e, t) {
        return s <= e
          ? 0
          : s >= t
          ? 1
          : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
      }
      function F_(s, e) {
        return s + Math.floor(Math.random() * (e - s + 1));
      }
      function B_(s, e) {
        return s + Math.random() * (e - s);
      }
      function z_(s) {
        return s * (0.5 - Math.random());
      }
      function O_(s) {
        return (
          s !== void 0 && (Jo = s % 2147483647),
          (Jo = (Jo * 16807) % 2147483647),
          (Jo - 1) / 2147483646
        );
      }
      function U_(s) {
        return s * _o;
      }
      function H_(s) {
        return s * Lo;
      }
      function xh(s) {
        return (s & (s - 1)) === 0 && s !== 0;
      }
      function Qp(s) {
        return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
      }
      function em(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      function G_(s, e, t, n, i) {
        const r = Math.cos,
          o = Math.sin,
          a = r(t / 2),
          l = o(t / 2),
          c = r((e + n) / 2),
          h = o((e + n) / 2),
          u = r((e - n) / 2),
          d = o((e - n) / 2),
          f = r((n - e) / 2),
          m = o((n - e) / 2);
        switch (i) {
          case "XYX":
            s.set(a * h, l * u, l * d, a * c);
            break;
          case "YZY":
            s.set(l * d, a * h, l * u, a * c);
            break;
          case "ZXZ":
            s.set(l * u, l * d, a * h, a * c);
            break;
          case "XZX":
            s.set(a * h, l * m, l * f, a * c);
            break;
          case "YXY":
            s.set(l * f, a * h, l * m, a * c);
            break;
          case "ZYZ":
            s.set(l * m, l * f, a * h, a * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
            );
        }
      }
      var V_ = Object.freeze({
        __proto__: null,
        DEG2RAD: _o,
        RAD2DEG: Lo,
        generateUUID: _n,
        clamp: en,
        euclideanModulo: Xh,
        mapLinear: R_,
        inverseLerp: C_,
        lerp: vo,
        damp: P_,
        pingpong: D_,
        smoothstep: I_,
        smootherstep: N_,
        randInt: F_,
        randFloat: B_,
        randFloatSpread: z_,
        seededRandom: O_,
        degToRad: U_,
        radToDeg: H_,
        isPowerOfTwo: xh,
        ceilPowerOfTwo: Qp,
        floorPowerOfTwo: em,
        setQuaternionFromProperEuler: G_,
      });
      class Se {
        constructor(e = 0, t = 0) {
          (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
      }
      Se.prototype.isVector2 = !0;
      class Ot {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, l, c) {
          const h = this.elements;
          return (
            (h[0] = e),
            (h[1] = i),
            (h[2] = a),
            (h[3] = t),
            (h[4] = r),
            (h[5] = l),
            (h[6] = n),
            (h[7] = o),
            (h[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            u = n[7],
            d = n[2],
            f = n[5],
            m = n[8],
            p = i[0],
            g = i[3],
            x = i[6],
            _ = i[1],
            M = i[4],
            S = i[7],
            v = i[2],
            y = i[5],
            C = i[8];
          return (
            (r[0] = o * p + a * _ + l * v),
            (r[3] = o * g + a * M + l * y),
            (r[6] = o * x + a * S + l * C),
            (r[1] = c * p + h * _ + u * v),
            (r[4] = c * g + h * M + u * y),
            (r[7] = c * x + h * S + u * C),
            (r[2] = d * p + f * _ + m * v),
            (r[5] = d * g + f * M + m * y),
            (r[8] = d * x + f * S + m * C),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8];
          return (
            t * o * h -
            t * a * c -
            n * r * h +
            n * a * l +
            i * r * c -
            i * o * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = h * o - a * c,
            d = a * l - h * r,
            f = c * r - o * l,
            m = t * u + n * d + i * f;
          if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const p = 1 / m;
          return (
            (e[0] = u * p),
            (e[1] = (i * c - h * n) * p),
            (e[2] = (a * n - i * o) * p),
            (e[3] = d * p),
            (e[4] = (h * t - i * l) * p),
            (e[5] = (i * r - a * t) * p),
            (e[6] = f * p),
            (e[7] = (n * l - c * t) * p),
            (e[8] = (o * t - n * r) * p),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, o, a) {
          const l = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * l,
              n * c,
              -n * (l * o + c * a) + o + e,
              -i * c,
              i * l,
              -i * (-c * o + l * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            o = i[3],
            a = i[6],
            l = i[1],
            c = i[4],
            h = i[7];
          return (
            (i[0] = t * r + n * l),
            (i[3] = t * o + n * c),
            (i[6] = t * a + n * h),
            (i[1] = -n * r + t * l),
            (i[4] = -n * o + t * c),
            (i[7] = -n * a + t * h),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      Ot.prototype.isMatrix3 = !0;
      let fr;
      class Ms {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            fr === void 0 &&
              (fr = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (fr.width = e.width),
              (fr.height = e.height);
            const n = fr.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = fr);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
      }
      let k_ = 0;
      class Ht extends or {
        constructor(
          e = Ht.DEFAULT_IMAGE,
          t = Ht.DEFAULT_MAPPING,
          n = rn,
          i = rn,
          r = sn,
          o = ys,
          a = In,
          l = $h,
          c = 1,
          h = Wo
        ) {
          super(),
            Object.defineProperty(this, "id", { value: k_++ }),
            (this.uuid = _n()),
            (this.name = ""),
            (this.image = e),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = o),
            (this.anisotropy = c),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = l),
            (this.offset = new Se(0, 0)),
            (this.repeat = new Se(1, 1)),
            (this.center = new Se(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Ot()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = h),
            (this.version = 0),
            (this.onUpdate = null);
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.image = e.image),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            this
          );
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (this.image !== void 0) {
            const i = this.image;
            if (
              (i.uuid === void 0 && (i.uuid = _n()),
              !t && e.images[i.uuid] === void 0)
            ) {
              let r;
              if (Array.isArray(i)) {
                r = [];
                for (let o = 0, a = i.length; o < a; o++)
                  i[o].isDataTexture
                    ? r.push(ql(i[o].image))
                    : r.push(ql(i[o]));
              } else r = ql(i);
              e.images[i.uuid] = { uuid: i.uuid, url: r };
            }
            n.image = i.uuid;
          }
          return t || (e.textures[this.uuid] = n), n;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== Yp) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case ls:
                e.x = e.x - Math.floor(e.x);
                break;
              case rn:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case ll:
                Math.abs(Math.floor(e.x) % 2) === 1
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case ls:
                e.y = e.y - Math.floor(e.y);
                break;
              case rn:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case ll:
                Math.abs(Math.floor(e.y) % 2) === 1
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      Ht.DEFAULT_IMAGE = void 0;
      Ht.DEFAULT_MAPPING = Yp;
      Ht.prototype.isTexture = !0;
      function ql(s) {
        return (typeof HTMLImageElement != "undefined" &&
          s instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            s instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && s instanceof ImageBitmap)
          ? Ms.getDataURL(s)
          : s.data
          ? {
              data: Array.prototype.slice.call(s.data),
              width: s.width,
              height: s.height,
              type: s.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      class rt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.x = e), (this.y = t), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const l = e.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            m = l[9],
            p = l[2],
            g = l[6],
            x = l[10];
          if (
            Math.abs(h - d) < 0.01 &&
            Math.abs(u - p) < 0.01 &&
            Math.abs(m - g) < 0.01
          ) {
            if (
              Math.abs(h + d) < 0.1 &&
              Math.abs(u + p) < 0.1 &&
              Math.abs(m + g) < 0.1 &&
              Math.abs(c + f + x - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const M = (c + 1) / 2,
              S = (f + 1) / 2,
              v = (x + 1) / 2,
              y = (h + d) / 4,
              C = (u + p) / 4,
              U = (m + g) / 4;
            return (
              M > S && M > v
                ? M < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(M)), (i = y / n), (r = C / n))
                : S > v
                ? S < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(S)), (n = y / i), (r = U / i))
                : v < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = C / r), (i = U / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let _ = Math.sqrt(
            (g - m) * (g - m) + (u - p) * (u - p) + (d - h) * (d - h)
          );
          return (
            Math.abs(_) < 0.001 && (_ = 1),
            (this.x = (g - m) / _),
            (this.y = (u - p) / _),
            (this.z = (d - h) / _),
            (this.w = Math.acos((c + f + x - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
      }
      rt.prototype.isVector4 = !0;
      class ai extends or {
        constructor(e, t, n) {
          super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new rt(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new rt(0, 0, e, t)),
            (n = n || {}),
            (this.texture = new Ht(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding
            )),
            (this.texture.image = {}),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = 1),
            (this.texture.generateMipmaps =
              n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.minFilter =
              n.minFilter !== void 0 ? n.minFilter : sn),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
              n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
              n.depthTexture !== void 0 ? n.depthTexture : null);
        }
        setTexture(e) {
          (e.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = e);
        }
        setSize(e, t, n = 1) {
          (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      ai.prototype.isWebGLRenderTarget = !0;
      class W_ extends ai {
        constructor(e, t, n) {
          super(e, t);
          const i = this.texture;
          this.texture = [];
          for (let r = 0; r < n; r++) this.texture[r] = i.clone();
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = e),
                (this.texture[i].image.height = t),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
          );
        }
        copy(e) {
          this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            (this.texture.length = 0);
          for (let t = 0, n = e.texture.length; t < n; t++)
            this.texture[t] = e.texture[t].clone();
          return this;
        }
      }
      W_.prototype.isWebGLMultipleRenderTargets = !0;
      class $_ extends ai {
        constructor(e, t, n) {
          super(e, t, n), (this.samples = 4);
        }
        copy(e) {
          return super.copy.call(this, e), (this.samples = e.samples), this;
        }
      }
      $_.prototype.isWebGLMultisampleRenderTarget = !0;
      class Zt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this._x = e), (this._y = t), (this._z = n), (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, r, o, a) {
          let l = n[i + 0],
            c = n[i + 1],
            h = n[i + 2],
            u = n[i + 3];
          const d = r[o + 0],
            f = r[o + 1],
            m = r[o + 2],
            p = r[o + 3];
          if (a === 0) {
            (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
            return;
          }
          if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = m), (e[t + 3] = p);
            return;
          }
          if (u !== p || l !== d || c !== f || h !== m) {
            let g = 1 - a;
            const x = l * d + c * f + h * m + u * p,
              _ = x >= 0 ? 1 : -1,
              M = 1 - x * x;
            if (M > Number.EPSILON) {
              const v = Math.sqrt(M),
                y = Math.atan2(v, x * _);
              (g = Math.sin(g * y) / v), (a = Math.sin(a * y) / v);
            }
            const S = a * _;
            if (
              ((l = l * g + d * S),
              (c = c * g + f * S),
              (h = h * g + m * S),
              (u = u * g + p * S),
              g === 1 - a)
            ) {
              const v = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
              (l *= v), (c *= v), (h *= v), (u *= v);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, o) {
          const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            u = r[o],
            d = r[o + 1],
            f = r[o + 2],
            m = r[o + 3];
          return (
            (e[t] = a * m + h * u + l * f - c * d),
            (e[t + 1] = l * m + h * d + c * u - a * f),
            (e[t + 2] = c * m + h * f + a * d - l * u),
            (e[t + 3] = h * m - a * u - l * d - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!(e && e.isEuler))
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            h = a(i / 2),
            u = a(r / 2),
            d = l(n / 2),
            f = l(i / 2),
            m = l(r / 2);
          switch (o) {
            case "XYZ":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "YXZ":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            case "ZXY":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "ZYX":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            case "YZX":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "XZY":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return t !== !1 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            h = t[6],
            u = t[10],
            d = n + a + u;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
              (this._x = (h - l) * f),
              (this._y = (r - c) * f),
              (this._z = (o - i) * f);
          } else if (n > a && n > u) {
            const f = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (h - l) / f),
              (this._x = 0.25 * f),
              (this._y = (i + o) / f),
              (this._z = (r + c) / f);
          } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (r - c) / f),
              (this._x = (i + o) / f),
              (this._y = 0.25 * f),
              (this._z = (l + h) / f);
          } else {
            const f = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (o - i) / f),
              (this._x = (r + c) / f),
              (this._y = (l + h) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(en(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (n === 0) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            h = t._w;
          return (
            (this._x = n * h + o * a + i * c - r * l),
            (this._y = i * h + o * l + r * a - n * c),
            (this._z = r * h + o * c + n * l - i * a),
            (this._w = o * h - n * a - i * l - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            o = this._w;
          let a = o * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * n + t * this._x),
              (this._y = f * i + t * this._y),
              (this._z = f * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            h = Math.atan2(c, a),
            u = Math.sin((1 - t) * h) / c,
            d = Math.sin(t * h) / c;
          return (
            (this._w = o * u + this._w * d),
            (this._x = n * u + this._x * d),
            (this._y = i * u + this._y * d),
            (this._z = r * u + this._z * d),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          this.copy(e).slerp(t, n);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      Zt.prototype.isQuaternion = !0;
      class G {
        constructor(e = 0, t = 0, n = 0) {
          (this.x = e), (this.y = t), (this.z = n);
        }
        set(e, t, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(sd.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(sd.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * i - a * n,
            h = l * n + a * t - r * i,
            u = l * i + r * n - o * t,
            d = -r * t - o * n - a * i;
          return (
            (this.x = c * l + d * -r + h * -a - u * -o),
            (this.y = h * l + d * -o + u * -r - c * -a),
            (this.z = u * l + d * -a + c * -o - h * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = i * l - r * a),
            (this.y = r * o - n * l),
            (this.z = n * a - i * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return Xl.copy(this).projectOnVector(e), this.sub(Xl);
        }
        reflect(e) {
          return this.sub(Xl.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(en(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
      }
      G.prototype.isVector3 = !0;
      const Xl = new G(),
        sd = new Zt();
      class pn {
        constructor(
          e = new G(1 / 0, 1 / 0, 1 / 0),
          t = new G(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.length; l < c; l += 3) {
            const h = e[l],
              u = e[l + 1],
              d = e[l + 2];
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > r && (r = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.count; l < c; l++) {
            const h = e.getX(l),
              u = e.getY(l),
              d = e.getZ(l);
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > r && (r = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Vs.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e) {
          return this.makeEmpty(), this.expandByObject(e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box3: .getCenter() target is now required"),
              (e = new G())),
            this.isEmpty()
              ? e.set(0, 0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        }
        getSize(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
              (e = new G())),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
          );
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e) {
          e.updateWorldMatrix(!1, !1);
          const t = e.geometry;
          t !== void 0 &&
            (t.boundingBox === null && t.computeBoundingBox(),
            jl.copy(t.boundingBox),
            jl.applyMatrix4(e.matrixWorld),
            this.union(jl));
          const n = e.children;
          for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
              (t = new G())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y),
              (e.z - this.min.z) / (this.max.z - this.min.z)
            )
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, Vs),
            Vs.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(ks),
            Ko.subVectors(this.max, ks),
            pr.subVectors(e.a, ks),
            mr.subVectors(e.b, ks),
            gr.subVectors(e.c, ks),
            pi.subVectors(mr, pr),
            mi.subVectors(gr, mr),
            $i.subVectors(pr, gr);
          let t = [
            0,
            -pi.z,
            pi.y,
            0,
            -mi.z,
            mi.y,
            0,
            -$i.z,
            $i.y,
            pi.z,
            0,
            -pi.x,
            mi.z,
            0,
            -mi.x,
            $i.z,
            0,
            -$i.x,
            -pi.y,
            pi.x,
            0,
            -mi.y,
            mi.x,
            0,
            -$i.y,
            $i.x,
            0,
          ];
          return !Yl(t, pr, mr, gr, Ko) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Yl(t, pr, mr, gr, Ko))
            ? !1
            : (Qo.crossVectors(pi, mi),
              (t = [Qo.x, Qo.y, Qo.z]),
              Yl(t, pr, mr, gr, Ko));
        }
        clampPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Box3: .clampPoint() target is now required"),
              (t = new G())),
            t.copy(e).clamp(this.min, this.max)
          );
        }
        distanceToPoint(e) {
          return Vs.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            e === void 0 &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              ),
            this.getCenter(e.center),
            (e.radius = this.getSize(Vs).length() * 0.5),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (Xn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Xn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Xn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Xn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Xn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Xn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Xn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Xn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Xn),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      pn.prototype.isBox3 = !0;
      const Xn = [
          new G(),
          new G(),
          new G(),
          new G(),
          new G(),
          new G(),
          new G(),
          new G(),
        ],
        Vs = new G(),
        jl = new pn(),
        pr = new G(),
        mr = new G(),
        gr = new G(),
        pi = new G(),
        mi = new G(),
        $i = new G(),
        ks = new G(),
        Ko = new G(),
        Qo = new G(),
        qi = new G();
      function Yl(s, e, t, n, i) {
        for (let r = 0, o = s.length - 3; r <= o; r += 3) {
          qi.fromArray(s, r);
          const a =
              i.x * Math.abs(qi.x) +
              i.y * Math.abs(qi.y) +
              i.z * Math.abs(qi.z),
            l = e.dot(qi),
            c = t.dot(qi),
            h = n.dot(qi);
          if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
        }
        return !0;
      }
      const q_ = new pn(),
        od = new G(),
        Zl = new G(),
        Jl = new G();
      class ar {
        constructor(e = new G(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          t !== void 0 ? n.copy(t) : q_.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let r = 0, o = e.length; r < o; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
              (t = new G())),
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
              (e = new pn())),
            this.isEmpty()
              ? (e.makeEmpty(), e)
              : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
          );
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          Jl.subVectors(e, this.center);
          const t = Jl.lengthSq();
          if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
              i = (n - this.radius) * 0.5;
            this.center.add(Jl.multiplyScalar(i / n)), (this.radius += i);
          }
          return this;
        }
        union(e) {
          return (
            Zl.subVectors(e.center, this.center)
              .normalize()
              .multiplyScalar(e.radius),
            this.expandByPoint(od.copy(e.center).add(Zl)),
            this.expandByPoint(od.copy(e.center).sub(Zl)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const jn = new G(),
        Kl = new G(),
        ea = new G(),
        gi = new G(),
        Ql = new G(),
        ta = new G(),
        ec = new G();
      class bs {
        constructor(e = new G(), t = new G(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (t = new G())),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
          );
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, jn)), this;
        }
        closestPointToPoint(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Ray: .closestPointToPoint() target is now required"
            ),
            (t = new G())),
            t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = jn.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (jn.copy(this.direction).multiplyScalar(t).add(this.origin),
              jn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          Kl.copy(e).add(t).multiplyScalar(0.5),
            ea.copy(t).sub(e).normalize(),
            gi.copy(this.origin).sub(Kl);
          const r = e.distanceTo(t) * 0.5,
            o = -this.direction.dot(ea),
            a = gi.dot(this.direction),
            l = -gi.dot(ea),
            c = gi.lengthSq(),
            h = Math.abs(1 - o * o);
          let u, d, f, m;
          if (h > 0)
            if (((u = o * l - a), (d = o * a - l), (m = r * h), u >= 0))
              if (d >= -m)
                if (d <= m) {
                  const p = 1 / h;
                  (u *= p),
                    (d *= p),
                    (f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c);
                } else
                  (d = r),
                    (u = Math.max(0, -(o * d + a))),
                    (f = -u * u + d * (d + 2 * l) + c);
              else
                (d = -r),
                  (u = Math.max(0, -(o * d + a))),
                  (f = -u * u + d * (d + 2 * l) + c);
            else
              d <= -m
                ? ((u = Math.max(0, -(-o * r + a))),
                  (d = u > 0 ? -r : Math.min(Math.max(-r, -l), r)),
                  (f = -u * u + d * (d + 2 * l) + c))
                : d <= m
                ? ((u = 0),
                  (d = Math.min(Math.max(-r, -l), r)),
                  (f = d * (d + 2 * l) + c))
                : ((u = Math.max(0, -(o * r + a))),
                  (d = u > 0 ? r : Math.min(Math.max(-r, -l), r)),
                  (f = -u * u + d * (d + 2 * l) + c));
          else
            (d = o > 0 ? -r : r),
              (u = Math.max(0, -(o * d + a))),
              (f = -u * u + d * (d + 2 * l) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(ea).multiplyScalar(d).add(Kl),
            f
          );
        }
        intersectSphere(e, t) {
          jn.subVectors(e.center, this.origin);
          const n = jn.dot(this.direction),
            i = jn.dot(jn) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const o = Math.sqrt(r - i),
            a = n - o,
            l = n + o;
          return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, o, a, l;
          const c = 1 / this.direction.x,
            h = 1 / this.direction.y,
            u = 1 / this.direction.z,
            d = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
              : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
            h >= 0
              ? ((r = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h))
              : ((r = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
            n > o ||
            r > i ||
            ((r > n || n !== n) && (n = r),
            (o < i || i !== i) && (i = o),
            u >= 0
              ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
              : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
            n > l || a > i) ||
            ((a > n || n !== n) && (n = a),
            (l < i || i !== i) && (i = l),
            i < 0)
              ? null
              : this.at(n >= 0 ? n : i, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, jn) !== null;
        }
        intersectTriangle(e, t, n, i, r) {
          Ql.subVectors(t, e), ta.subVectors(n, e), ec.crossVectors(Ql, ta);
          let o = this.direction.dot(ec),
            a;
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else if (o < 0) (a = -1), (o = -o);
          else return null;
          gi.subVectors(this.origin, e);
          const l = a * this.direction.dot(ta.crossVectors(gi, ta));
          if (l < 0) return null;
          const c = a * this.direction.dot(Ql.cross(gi));
          if (c < 0 || l + c > o) return null;
          const h = -a * gi.dot(ec);
          return h < 0 ? null : this.at(h / o, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Ge {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, l, c, h, u, d, f, m, p, g) {
          const x = this.elements;
          return (
            (x[0] = e),
            (x[4] = t),
            (x[8] = n),
            (x[12] = i),
            (x[1] = r),
            (x[5] = o),
            (x[9] = a),
            (x[13] = l),
            (x[2] = c),
            (x[6] = h),
            (x[10] = u),
            (x[14] = d),
            (x[3] = f),
            (x[7] = m),
            (x[11] = p),
            (x[15] = g),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Ge().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / xr.setFromMatrixColumn(e, 0).length(),
            r = 1 / xr.setFromMatrixColumn(e, 1).length(),
            o = 1 / xr.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * o),
            (t[9] = n[9] * o),
            (t[10] = n[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            h = Math.cos(r),
            u = Math.sin(r);
          if (e.order === "XYZ") {
            const d = o * h,
              f = o * u,
              m = a * h,
              p = a * u;
            (t[0] = l * h),
              (t[4] = -l * u),
              (t[8] = c),
              (t[1] = f + m * c),
              (t[5] = d - p * c),
              (t[9] = -a * l),
              (t[2] = p - d * c),
              (t[6] = m + f * c),
              (t[10] = o * l);
          } else if (e.order === "YXZ") {
            const d = l * h,
              f = l * u,
              m = c * h,
              p = c * u;
            (t[0] = d + p * a),
              (t[4] = m * a - f),
              (t[8] = o * c),
              (t[1] = o * u),
              (t[5] = o * h),
              (t[9] = -a),
              (t[2] = f * a - m),
              (t[6] = p + d * a),
              (t[10] = o * l);
          } else if (e.order === "ZXY") {
            const d = l * h,
              f = l * u,
              m = c * h,
              p = c * u;
            (t[0] = d - p * a),
              (t[4] = -o * u),
              (t[8] = m + f * a),
              (t[1] = f + m * a),
              (t[5] = o * h),
              (t[9] = p - d * a),
              (t[2] = -o * c),
              (t[6] = a),
              (t[10] = o * l);
          } else if (e.order === "ZYX") {
            const d = o * h,
              f = o * u,
              m = a * h,
              p = a * u;
            (t[0] = l * h),
              (t[4] = m * c - f),
              (t[8] = d * c + p),
              (t[1] = l * u),
              (t[5] = p * c + d),
              (t[9] = f * c - m),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = o * l);
          } else if (e.order === "YZX") {
            const d = o * l,
              f = o * c,
              m = a * l,
              p = a * c;
            (t[0] = l * h),
              (t[4] = p - d * u),
              (t[8] = m * u + f),
              (t[1] = u),
              (t[5] = o * h),
              (t[9] = -a * h),
              (t[2] = -c * h),
              (t[6] = f * u + m),
              (t[10] = d - p * u);
          } else if (e.order === "XZY") {
            const d = o * l,
              f = o * c,
              m = a * l,
              p = a * c;
            (t[0] = l * h),
              (t[4] = -u),
              (t[8] = c * h),
              (t[1] = d * u + p),
              (t[5] = o * h),
              (t[9] = f * u - m),
              (t[2] = m * u - f),
              (t[6] = a * h),
              (t[10] = p * u + d);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(X_, e, j_);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            cn.subVectors(e, t),
            cn.lengthSq() === 0 && (cn.z = 1),
            cn.normalize(),
            xi.crossVectors(n, cn),
            xi.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (cn.x += 1e-4) : (cn.z += 1e-4),
              cn.normalize(),
              xi.crossVectors(n, cn)),
            xi.normalize(),
            na.crossVectors(cn, xi),
            (i[0] = xi.x),
            (i[4] = na.x),
            (i[8] = cn.x),
            (i[1] = xi.y),
            (i[5] = na.y),
            (i[9] = cn.y),
            (i[2] = xi.z),
            (i[6] = na.z),
            (i[10] = cn.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            u = n[5],
            d = n[9],
            f = n[13],
            m = n[2],
            p = n[6],
            g = n[10],
            x = n[14],
            _ = n[3],
            M = n[7],
            S = n[11],
            v = n[15],
            y = i[0],
            C = i[4],
            U = i[8],
            K = i[12],
            X = i[1],
            b = i[5],
            D = i[9],
            I = i[13],
            L = i[2],
            B = i[6],
            R = i[10],
            V = i[14],
            H = i[3],
            J = i[7],
            ie = i[11],
            ne = i[15];
          return (
            (r[0] = o * y + a * X + l * L + c * H),
            (r[4] = o * C + a * b + l * B + c * J),
            (r[8] = o * U + a * D + l * R + c * ie),
            (r[12] = o * K + a * I + l * V + c * ne),
            (r[1] = h * y + u * X + d * L + f * H),
            (r[5] = h * C + u * b + d * B + f * J),
            (r[9] = h * U + u * D + d * R + f * ie),
            (r[13] = h * K + u * I + d * V + f * ne),
            (r[2] = m * y + p * X + g * L + x * H),
            (r[6] = m * C + p * b + g * B + x * J),
            (r[10] = m * U + p * D + g * R + x * ie),
            (r[14] = m * K + p * I + g * V + x * ne),
            (r[3] = _ * y + M * X + S * L + v * H),
            (r[7] = _ * C + M * b + S * B + v * J),
            (r[11] = _ * U + M * D + S * R + v * ie),
            (r[15] = _ * K + M * I + S * V + v * ne),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            h = e[2],
            u = e[6],
            d = e[10],
            f = e[14],
            m = e[3],
            p = e[7],
            g = e[11],
            x = e[15];
          return (
            m *
              (+r * l * u -
                i * c * u -
                r * a * d +
                n * c * d +
                i * a * f -
                n * l * f) +
            p *
              (+t * l * f -
                t * c * d +
                r * o * d -
                i * o * f +
                i * c * h -
                r * l * h) +
            g *
              (+t * c * u -
                t * a * f -
                r * o * u +
                n * o * f +
                r * a * h -
                n * c * h) +
            x *
              (-i * a * h -
                t * l * u +
                t * a * d +
                i * o * u -
                n * o * d +
                n * l * h)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = e[9],
            d = e[10],
            f = e[11],
            m = e[12],
            p = e[13],
            g = e[14],
            x = e[15],
            _ =
              u * g * c -
              p * d * c +
              p * l * f -
              a * g * f -
              u * l * x +
              a * d * x,
            M =
              m * d * c -
              h * g * c -
              m * l * f +
              o * g * f +
              h * l * x -
              o * d * x,
            S =
              h * p * c -
              m * u * c +
              m * a * f -
              o * p * f -
              h * a * x +
              o * u * x,
            v =
              m * u * l -
              h * p * l -
              m * a * d +
              o * p * d +
              h * a * g -
              o * u * g,
            y = t * _ + n * M + i * S + r * v;
          if (y === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const C = 1 / y;
          return (
            (e[0] = _ * C),
            (e[1] =
              (p * d * r -
                u * g * r -
                p * i * f +
                n * g * f +
                u * i * x -
                n * d * x) *
              C),
            (e[2] =
              (a * g * r -
                p * l * r +
                p * i * c -
                n * g * c -
                a * i * x +
                n * l * x) *
              C),
            (e[3] =
              (u * l * r -
                a * d * r -
                u * i * c +
                n * d * c +
                a * i * f -
                n * l * f) *
              C),
            (e[4] = M * C),
            (e[5] =
              (h * g * r -
                m * d * r +
                m * i * f -
                t * g * f -
                h * i * x +
                t * d * x) *
              C),
            (e[6] =
              (m * l * r -
                o * g * r -
                m * i * c +
                t * g * c +
                o * i * x -
                t * l * x) *
              C),
            (e[7] =
              (o * d * r -
                h * l * r +
                h * i * c -
                t * d * c -
                o * i * f +
                t * l * f) *
              C),
            (e[8] = S * C),
            (e[9] =
              (m * u * r -
                h * p * r -
                m * n * f +
                t * p * f +
                h * n * x -
                t * u * x) *
              C),
            (e[10] =
              (o * p * r -
                m * a * r +
                m * n * c -
                t * p * c -
                o * n * x +
                t * a * x) *
              C),
            (e[11] =
              (h * a * r -
                o * u * r -
                h * n * c +
                t * u * c +
                o * n * f -
                t * a * f) *
              C),
            (e[12] = v * C),
            (e[13] =
              (h * p * i -
                m * u * i +
                m * n * d -
                t * p * d -
                h * n * g +
                t * u * g) *
              C),
            (e[14] =
              (m * a * i -
                o * p * i -
                m * n * l +
                t * p * l +
                o * n * g -
                t * a * g) *
              C),
            (e[15] =
              (o * u * i -
                h * a * i +
                h * n * l -
                t * u * l -
                o * n * d +
                t * a * d) *
              C),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            o = e.x,
            a = e.y,
            l = e.z,
            c = r * o,
            h = r * a;
          return (
            this.set(
              c * o + n,
              c * a - i * l,
              c * l + i * a,
              0,
              c * a + i * l,
              h * a + n,
              h * l - i * o,
              0,
              c * l - i * a,
              h * l + i * o,
              r * l * l + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, o) {
          return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = r + r,
            h = o + o,
            u = a + a,
            d = r * c,
            f = r * h,
            m = r * u,
            p = o * h,
            g = o * u,
            x = a * u,
            _ = l * c,
            M = l * h,
            S = l * u,
            v = n.x,
            y = n.y,
            C = n.z;
          return (
            (i[0] = (1 - (p + x)) * v),
            (i[1] = (f + S) * v),
            (i[2] = (m - M) * v),
            (i[3] = 0),
            (i[4] = (f - S) * y),
            (i[5] = (1 - (d + x)) * y),
            (i[6] = (g + _) * y),
            (i[7] = 0),
            (i[8] = (m + M) * C),
            (i[9] = (g - _) * C),
            (i[10] = (1 - (d + p)) * C),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = xr.set(i[0], i[1], i[2]).length();
          const o = xr.set(i[4], i[5], i[6]).length(),
            a = xr.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            wn.copy(this);
          const c = 1 / r,
            h = 1 / o,
            u = 1 / a;
          return (
            (wn.elements[0] *= c),
            (wn.elements[1] *= c),
            (wn.elements[2] *= c),
            (wn.elements[4] *= h),
            (wn.elements[5] *= h),
            (wn.elements[6] *= h),
            (wn.elements[8] *= u),
            (wn.elements[9] *= u),
            (wn.elements[10] *= u),
            t.setFromRotationMatrix(wn),
            (n.x = r),
            (n.y = o),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, o) {
          o === void 0 &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            l = (2 * r) / (t - e),
            c = (2 * r) / (n - i),
            h = (t + e) / (t - e),
            u = (n + i) / (n - i),
            d = -(o + r) / (o - r),
            f = (-2 * o * r) / (o - r);
          return (
            (a[0] = l),
            (a[4] = 0),
            (a[8] = h),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = u),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, o) {
          const a = this.elements,
            l = 1 / (t - e),
            c = 1 / (n - i),
            h = 1 / (o - r),
            u = (t + e) * l,
            d = (n + i) * c,
            f = (o + r) * h;
          return (
            (a[0] = 2 * l),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -u),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * h),
            (a[14] = -f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      Ge.prototype.isMatrix4 = !0;
      const xr = new G(),
        wn = new Ge(),
        X_ = new G(0, 0, 0),
        j_ = new G(1, 1, 1),
        xi = new G(),
        na = new G(),
        cn = new G(),
        ad = new Ge(),
        ld = new Zt();
      class ws {
        constructor(e = 0, t = 0, n = 0, i = ws.DefaultOrder) {
          (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i || this._order),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t, n) {
          const i = e.elements,
            r = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            h = i[9],
            u = i[2],
            d = i[6],
            f = i[10];
          switch (((t = t || this._order), t)) {
            case "XYZ":
              (this._y = Math.asin(en(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-o, r)))
                  : ((this._x = Math.atan2(d, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-en(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(en(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-u, f)),
                    (this._z = Math.atan2(-o, c)))
                  : ((this._y = 0), (this._z = Math.atan2(l, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-en(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, c)));
              break;
            case "YZX":
              (this._z = Math.asin(en(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-h, c)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-en(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-h, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), n !== !1 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            ad.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(ad, t, n)
          );
        }
        setFromVector3(e, t) {
          return this.set(e.x, e.y, e.z, t || this._order);
        }
        reorder(e) {
          return ld.setFromEuler(this), this.setFromQuaternion(ld, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        toVector3(e) {
          return e
            ? e.set(this._x, this._y, this._z)
            : new G(this._x, this._y, this._z);
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      ws.prototype.isEuler = !0;
      ws.DefaultOrder = "XYZ";
      ws.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Y_ {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e) | 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
      }
      let Z_ = 0;
      const cd = new G(),
        _r = new Zt(),
        Yn = new Ge(),
        ia = new G(),
        Ws = new G(),
        J_ = new G(),
        K_ = new Zt(),
        hd = new G(1, 0, 0),
        ud = new G(0, 1, 0),
        dd = new G(0, 0, 1),
        Q_ = { type: "added" },
        fd = { type: "removed" };
      class Ke extends or {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: Z_++ }),
            (this.uuid = _n()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Ke.DefaultUp.clone());
          const e = new G(),
            t = new ws(),
            n = new Zt(),
            i = new G(1, 1, 1);
          function r() {
            n.setFromEuler(t, !1);
          }
          function o() {
            t.setFromQuaternion(n, void 0, !1);
          }
          t._onChange(r),
            n._onChange(o),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new Ge() },
              normalMatrix: { value: new Ot() },
            }),
            (this.matrix = new Ge()),
            (this.matrixWorld = new Ge()),
            (this.matrixAutoUpdate = Ke.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Y_()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return _r.setFromAxisAngle(e, t), this.quaternion.multiply(_r), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            _r.setFromAxisAngle(e, t), this.quaternion.premultiply(_r), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(hd, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(ud, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(dd, e);
        }
        translateOnAxis(e, t) {
          return (
            cd.copy(e).applyQuaternion(this.quaternion),
            this.position.add(cd.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(hd, e);
        }
        translateY(e) {
          return this.translateOnAxis(ud, e);
        }
        translateZ(e) {
          return this.translateOnAxis(dd, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(Yn.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? ia.copy(e) : ia.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            Ws.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Yn.lookAt(Ws, ia, this.up)
              : Yn.lookAt(ia, Ws, this.up),
            this.quaternion.setFromRotationMatrix(Yn),
            i &&
              (Yn.extractRotation(i.matrixWorld),
              _r.setFromRotationMatrix(Yn),
              this.quaternion.premultiply(_r.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.parent !== null && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(Q_))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(fd)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(fd);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            Yn.copy(this.matrixWorld).invert(),
            e.parent !== null &&
              (e.parent.updateWorldMatrix(!0, !1),
              Yn.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Yn),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0) return o;
          }
        }
        getWorldPosition(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (e = new G())),
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (e = new Zt())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ws, e, J_),
            e
          );
        }
        getWorldScale(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (e = new G())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ws, K_, e),
            e
          );
        }
        getWorldDirection(e) {
          e === void 0 &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required"
            ),
            (e = new G())),
            this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            t === !0)
          ) {
            const i = this.children;
            for (let r = 0, o = i.length; r < o; r++)
              i[r].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            JSON.stringify(this.userData) !== "{}" &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (i.instanceColor = this.instanceColor.toJSON()));
          function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
          }
          if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const l = a.shapes;
              if (Array.isArray(l))
                for (let c = 0, h = l.length; c < h; c++) {
                  const u = l[c];
                  r(e.shapes, u);
                }
              else r(e.shapes, l);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const a = [];
              for (let l = 0, c = this.material.length; l < c; l++)
                a.push(r(e.materials, this.material[l]));
              i.material = a;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
              i.children.push(this.children[a].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const l = this.animations[a];
              i.animations.push(r(e.animations, l));
            }
          }
          if (t) {
            const a = o(e.geometries),
              l = o(e.materials),
              c = o(e.textures),
              h = o(e.images),
              u = o(e.shapes),
              d = o(e.skeletons),
              f = o(e.animations);
            a.length > 0 && (n.geometries = a),
              l.length > 0 && (n.materials = l),
              c.length > 0 && (n.textures = c),
              h.length > 0 && (n.images = h),
              u.length > 0 && (n.shapes = u),
              d.length > 0 && (n.skeletons = d),
              f.length > 0 && (n.animations = f);
          }
          return (n.object = i), n;
          function o(a) {
            const l = [];
            for (const c in a) {
              const h = a[c];
              delete h.metadata, l.push(h);
            }
            return l;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let n = 0; n < e.children.length; n++) {
              const i = e.children[n];
              this.add(i.clone());
            }
          return this;
        }
      }
      Ke.DefaultUp = new G(0, 1, 0);
      Ke.DefaultMatrixAutoUpdate = !0;
      Ke.prototype.isObject3D = !0;
      const tc = new G(),
        ev = new G(),
        tv = new Ot();
      class Un {
        constructor(e = new G(1, 0, 0), t = 0) {
          (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = tc.subVectors(n, t).cross(ev.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
              (t = new G())),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
          );
        }
        intersectLine(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Plane: .intersectLine() target is now required"
            ),
            (t = new G()));
          const n = e.delta(tc),
            i = this.normal.dot(n);
          if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
              (e = new G())),
            e.copy(this.normal).multiplyScalar(-this.constant)
          );
        }
        applyMatrix4(e, t) {
          const n = t || tv.getNormalMatrix(e),
            i = this.coplanarPoint(tc).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Un.prototype.isPlane = !0;
      const Sn = new G(),
        Zn = new G(),
        nc = new G(),
        Jn = new G(),
        vr = new G(),
        yr = new G(),
        pd = new G(),
        ic = new G(),
        rc = new G(),
        sc = new G();
      class yt {
        constructor(e = new G(), t = new G(), n = new G()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i === void 0 &&
            (console.warn(
              "THREE.Triangle: .getNormal() target is now required"
            ),
            (i = new G())),
            i.subVectors(n, t),
            Sn.subVectors(e, t),
            i.cross(Sn);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          Sn.subVectors(i, t), Zn.subVectors(n, t), nc.subVectors(e, t);
          const o = Sn.dot(Sn),
            a = Sn.dot(Zn),
            l = Sn.dot(nc),
            c = Zn.dot(Zn),
            h = Zn.dot(nc),
            u = o * c - a * a;
          if (
            (r === void 0 &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required"
              ),
              (r = new G())),
            u === 0)
          )
            return r.set(-2, -1, -1);
          const d = 1 / u,
            f = (c * l - a * h) * d,
            m = (o * h - a * l) * d;
          return r.set(1 - f - m, m, f);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, Jn),
            Jn.x >= 0 && Jn.y >= 0 && Jn.x + Jn.y <= 1
          );
        }
        static getUV(e, t, n, i, r, o, a, l) {
          return (
            this.getBarycoord(e, t, n, i, Jn),
            l.set(0, 0),
            l.addScaledVector(r, Jn.x),
            l.addScaledVector(o, Jn.y),
            l.addScaledVector(a, Jn.z),
            l
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            Sn.subVectors(n, t), Zn.subVectors(e, t), Sn.cross(Zn).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            Sn.subVectors(this.c, this.b),
            Zn.subVectors(this.a, this.b),
            Sn.cross(Zn).length() * 0.5
          );
        }
        getMidpoint(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (e = new G())),
            e
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        }
        getNormal(e) {
          return yt.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (e = new Un())),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        }
        getBarycoord(e, t) {
          return yt.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return yt.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return yt.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return yt.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (t = new G()));
          const n = this.a,
            i = this.b,
            r = this.c;
          let o, a;
          vr.subVectors(i, n), yr.subVectors(r, n), ic.subVectors(e, n);
          const l = vr.dot(ic),
            c = yr.dot(ic);
          if (l <= 0 && c <= 0) return t.copy(n);
          rc.subVectors(e, i);
          const h = vr.dot(rc),
            u = yr.dot(rc);
          if (h >= 0 && u <= h) return t.copy(i);
          const d = l * u - h * c;
          if (d <= 0 && l >= 0 && h <= 0)
            return (o = l / (l - h)), t.copy(n).addScaledVector(vr, o);
          sc.subVectors(e, r);
          const f = vr.dot(sc),
            m = yr.dot(sc);
          if (m >= 0 && f <= m) return t.copy(r);
          const p = f * c - l * m;
          if (p <= 0 && c >= 0 && m <= 0)
            return (a = c / (c - m)), t.copy(n).addScaledVector(yr, a);
          const g = h * m - f * u;
          if (g <= 0 && u - h >= 0 && f - m >= 0)
            return (
              pd.subVectors(r, i),
              (a = (u - h) / (u - h + (f - m))),
              t.copy(i).addScaledVector(pd, a)
            );
          const x = 1 / (g + p + d);
          return (
            (o = p * x),
            (a = d * x),
            t.copy(n).addScaledVector(vr, o).addScaledVector(yr, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let nv = 0;
      class It extends or {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: nv++ }),
            (this.uuid = _n()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = mo),
            (this.side = So),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = Xp),
            (this.blendDst = jp),
            (this.blendEquation = jr),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = ph),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = L_),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = $l),
            (this.stencilZFail = $l),
            (this.stencilZPass = $l),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0);
        }
        onBuild() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const n = e[t];
              if (n === void 0) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if (t === "shading") {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === qp);
                continue;
              }
              const i = this[t];
              if (i === void 0) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
                continue;
              }
              i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== mo && (n.blending = this.blending),
            this.side !== So && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 &&
              (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.morphTargets === !0 && (n.morphTargets = !0),
            this.morphNormals === !0 && (n.morphNormals = !0),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData);
          function i(r) {
            const o = [];
            for (const a in r) {
              const l = r[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (t) {
            const r = i(e.textures),
              o = i(e.images);
            r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      It.prototype.isMaterial = !0;
      const tm = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Tn = { h: 0, s: 0, l: 0 },
        ra = { h: 0, s: 0, l: 0 };
      function oc(s, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? s + (e - s) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? s + (e - s) * 6 * (2 / 3 - t)
            : s
        );
      }
      function ac(s) {
        return s < 0.04045
          ? s * 0.0773993808
          : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function lc(s) {
        return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      class Ue {
        constructor(e, t, n) {
          return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : typeof e == "number"
              ? this.setHex(e)
              : typeof e == "string" && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            this
          );
        }
        setRGB(e, t, n) {
          return (this.r = e), (this.g = t), (this.b = n), this;
        }
        setHSL(e, t, n) {
          if (((e = Xh(e, 1)), (t = en(t, 0, 1)), (n = en(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = oc(r, i, e + 1 / 3)),
              (this.g = oc(r, i, e)),
              (this.b = oc(r, i, e - 1 / 3));
          }
          return this;
        }
        setStyle(e) {
          function t(i) {
            i !== void 0 &&
              parseFloat(i) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let n;
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let i;
            const r = n[1],
              o = n[2];
            switch (r) {
              case "rgb":
              case "rgba":
                if (
                  (i =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                    t(i[4]),
                    this
                  );
                if (
                  (i =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                    t(i[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (i =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                ) {
                  const a = parseFloat(i[1]) / 360,
                    l = parseInt(i[2], 10) / 100,
                    c = parseInt(i[3], 10) / 100;
                  return t(i[4]), this.setHSL(a, l, c);
                }
                break;
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const i = n[1],
              r = i.length;
            if (r === 3)
              return (
                (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
                (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
                (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
                this
              );
            if (r === 6)
              return (
                (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
                (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
                (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e) : this;
        }
        setColorName(e) {
          const t = tm[e.toLowerCase()];
          return (
            t !== void 0
              ? this.setHex(t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copyGammaToLinear(e, t = 2) {
          return (
            (this.r = Math.pow(e.r, t)),
            (this.g = Math.pow(e.g, t)),
            (this.b = Math.pow(e.b, t)),
            this
          );
        }
        copyLinearToGamma(e, t = 2) {
          const n = t > 0 ? 1 / t : 1;
          return (
            (this.r = Math.pow(e.r, n)),
            (this.g = Math.pow(e.g, n)),
            (this.b = Math.pow(e.b, n)),
            this
          );
        }
        convertGammaToLinear(e) {
          return this.copyGammaToLinear(this, e), this;
        }
        convertLinearToGamma(e) {
          return this.copyLinearToGamma(this, e), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = ac(e.r)), (this.g = ac(e.g)), (this.b = ac(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = lc(e.r)), (this.g = lc(e.g)), (this.b = lc(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((this.r * 255) << 16) ^
            ((this.g * 255) << 8) ^
            ((this.b * 255) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(e) {
          e === void 0 &&
            (console.warn("THREE.Color: .getHSL() target is now required"),
            (e = { h: 0, s: 0, l: 0 }));
          const t = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(t, n, i),
            o = Math.min(t, n, i);
          let a, l;
          const c = (o + r) / 2;
          if (o === r) (a = 0), (l = 0);
          else {
            const h = r - o;
            switch (((l = c <= 0.5 ? h / (r + o) : h / (2 - r - o)), r)) {
              case t:
                a = (n - i) / h + (n < i ? 6 : 0);
                break;
              case n:
                a = (i - t) / h + 2;
                break;
              case i:
                a = (t - n) / h + 4;
                break;
            }
            a /= 6;
          }
          return (e.h = a), (e.s = l), (e.l = c), e;
        }
        getStyle() {
          return (
            "rgb(" +
            ((this.r * 255) | 0) +
            "," +
            ((this.g * 255) | 0) +
            "," +
            ((this.b * 255) | 0) +
            ")"
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(Tn),
            (Tn.h += e),
            (Tn.s += t),
            (Tn.l += n),
            this.setHSL(Tn.h, Tn.s, Tn.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(Tn), e.getHSL(ra);
          const n = vo(Tn.h, ra.h, t),
            i = vo(Tn.s, ra.s, t),
            r = vo(Tn.l, ra.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      Ue.NAMES = tm;
      Ue.prototype.isColor = !0;
      Ue.prototype.r = 1;
      Ue.prototype.g = 1;
      Ue.prototype.b = 1;
      class Di extends It {
        constructor(e) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = yl),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      Di.prototype.isMeshBasicMaterial = !0;
      const lt = new G(),
        sa = new Se();
      class bt {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n === !0),
            (this.usage = Ao),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (o = new Ue())),
              (t[n++] = o.r),
              (t[n++] = o.g),
              (t[n++] = o.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (o = new Se())),
              (t[n++] = o.x),
              (t[n++] = o.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (o = new G())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (o = new rt())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z),
              (t[n++] = o.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
              sa.fromBufferAttribute(this, t),
                sa.applyMatrix3(e),
                this.setXY(t, sa.x, sa.y);
          else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
              lt.fromBufferAttribute(this, t),
                lt.applyMatrix3(e),
                this.setXYZ(t, lt.x, lt.y, lt.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (lt.x = this.getX(t)),
              (lt.y = this.getY(t)),
              (lt.z = this.getZ(t)),
              lt.applyMatrix4(e),
              this.setXYZ(t, lt.x, lt.y, lt.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (lt.x = this.getX(t)),
              (lt.y = this.getY(t)),
              (lt.z = this.getZ(t)),
              lt.applyNormalMatrix(e),
              this.setXYZ(t, lt.x, lt.y, lt.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (lt.x = this.getX(t)),
              (lt.y = this.getY(t)),
              (lt.z = this.getZ(t)),
              lt.transformDirection(e),
              this.setXYZ(t, lt.x, lt.y, lt.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (e.name = this.name),
            this.usage !== Ao && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      bt.prototype.isBufferAttribute = !0;
      class nm extends bt {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class im extends bt {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class iv extends bt {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      iv.prototype.isFloat16BufferAttribute = !0;
      class Pt extends bt {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      function rm(s) {
        if (s.length === 0) return -1 / 0;
        let e = s[0];
        for (let t = 1, n = s.length; t < n; ++t) s[t] > e && (e = s[t]);
        return e;
      }
      let rv = 0;
      const gn = new Ge(),
        cc = new Ke(),
        Mr = new G(),
        hn = new pn(),
        $s = new pn(),
        At = new G();
      class ut extends or {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: rv++ }),
            (this.uuid = _n()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (rm(e) > 65535 ? im : nm)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const r = new Ot().getNormalMatrix(e);
            n.applyNormalMatrix(r), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return gn.makeRotationFromQuaternion(e), this.applyMatrix4(gn), this;
        }
        rotateX(e) {
          return gn.makeRotationX(e), this.applyMatrix4(gn), this;
        }
        rotateY(e) {
          return gn.makeRotationY(e), this.applyMatrix4(gn), this;
        }
        rotateZ(e) {
          return gn.makeRotationZ(e), this.applyMatrix4(gn), this;
        }
        translate(e, t, n) {
          return gn.makeTranslation(e, t, n), this.applyMatrix4(gn), this;
        }
        scale(e, t, n) {
          return gn.makeScale(e, t, n), this.applyMatrix4(gn), this;
        }
        lookAt(e) {
          return (
            cc.lookAt(e), cc.updateMatrix(), this.applyMatrix4(cc.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Mr).negate(),
            this.translate(Mr.x, Mr.y, Mr.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0);
          }
          return this.setAttribute("position", new Pt(t, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new pn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingBox.set(
                new G(-1 / 0, -1 / 0, -1 / 0),
                new G(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let n = 0, i = t.length; n < i; n++) {
                const r = t[n];
                hn.setFromBufferAttribute(r),
                  this.morphTargetsRelative
                    ? (At.addVectors(this.boundingBox.min, hn.min),
                      this.boundingBox.expandByPoint(At),
                      At.addVectors(this.boundingBox.max, hn.max),
                      this.boundingBox.expandByPoint(At))
                    : (this.boundingBox.expandByPoint(hn.min),
                      this.boundingBox.expandByPoint(hn.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new ar());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingSphere.set(new G(), 1 / 0);
            return;
          }
          if (e) {
            const n = this.boundingSphere.center;
            if ((hn.setFromBufferAttribute(e), t))
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r];
                $s.setFromBufferAttribute(a),
                  this.morphTargetsRelative
                    ? (At.addVectors(hn.min, $s.min),
                      hn.expandByPoint(At),
                      At.addVectors(hn.max, $s.max),
                      hn.expandByPoint(At))
                    : (hn.expandByPoint($s.min), hn.expandByPoint($s.max));
              }
            hn.getCenter(n);
            let i = 0;
            for (let r = 0, o = e.count; r < o; r++)
              At.fromBufferAttribute(e, r),
                (i = Math.max(i, n.distanceToSquared(At)));
            if (t)
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r],
                  l = this.morphTargetsRelative;
                for (let c = 0, h = a.count; c < h; c++)
                  At.fromBufferAttribute(a, c),
                    l && (Mr.fromBufferAttribute(e, c), At.add(Mr)),
                    (i = Math.max(i, n.distanceToSquared(At)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeFaceNormals() {}
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            o = t.uv.array,
            a = i.length / 3;
          t.tangent === void 0 &&
            this.setAttribute("tangent", new bt(new Float32Array(4 * a), 4));
          const l = t.tangent.array,
            c = [],
            h = [];
          for (let X = 0; X < a; X++) (c[X] = new G()), (h[X] = new G());
          const u = new G(),
            d = new G(),
            f = new G(),
            m = new Se(),
            p = new Se(),
            g = new Se(),
            x = new G(),
            _ = new G();
          function M(X, b, D) {
            u.fromArray(i, X * 3),
              d.fromArray(i, b * 3),
              f.fromArray(i, D * 3),
              m.fromArray(o, X * 2),
              p.fromArray(o, b * 2),
              g.fromArray(o, D * 2),
              d.sub(u),
              f.sub(u),
              p.sub(m),
              g.sub(m);
            const I = 1 / (p.x * g.y - g.x * p.y);
            !isFinite(I) ||
              (x
                .copy(d)
                .multiplyScalar(g.y)
                .addScaledVector(f, -p.y)
                .multiplyScalar(I),
              _.copy(f)
                .multiplyScalar(p.x)
                .addScaledVector(d, -g.x)
                .multiplyScalar(I),
              c[X].add(x),
              c[b].add(x),
              c[D].add(x),
              h[X].add(_),
              h[b].add(_),
              h[D].add(_));
          }
          let S = this.groups;
          S.length === 0 && (S = [{ start: 0, count: n.length }]);
          for (let X = 0, b = S.length; X < b; ++X) {
            const D = S[X],
              I = D.start,
              L = D.count;
            for (let B = I, R = I + L; B < R; B += 3)
              M(n[B + 0], n[B + 1], n[B + 2]);
          }
          const v = new G(),
            y = new G(),
            C = new G(),
            U = new G();
          function K(X) {
            C.fromArray(r, X * 3), U.copy(C);
            const b = c[X];
            v.copy(b),
              v.sub(C.multiplyScalar(C.dot(b))).normalize(),
              y.crossVectors(U, b);
            const I = y.dot(h[X]) < 0 ? -1 : 1;
            (l[X * 4] = v.x),
              (l[X * 4 + 1] = v.y),
              (l[X * 4 + 2] = v.z),
              (l[X * 4 + 3] = I);
          }
          for (let X = 0, b = S.length; X < b; ++X) {
            const D = S[X],
              I = D.start,
              L = D.count;
            for (let B = I, R = I + L; B < R; B += 3)
              K(n[B + 0]), K(n[B + 1]), K(n[B + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new bt(new Float32Array(t.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const i = new G(),
              r = new G(),
              o = new G(),
              a = new G(),
              l = new G(),
              c = new G(),
              h = new G(),
              u = new G();
            if (e)
              for (let d = 0, f = e.count; d < f; d += 3) {
                const m = e.getX(d + 0),
                  p = e.getX(d + 1),
                  g = e.getX(d + 2);
                i.fromBufferAttribute(t, m),
                  r.fromBufferAttribute(t, p),
                  o.fromBufferAttribute(t, g),
                  h.subVectors(o, r),
                  u.subVectors(i, r),
                  h.cross(u),
                  a.fromBufferAttribute(n, m),
                  l.fromBufferAttribute(n, p),
                  c.fromBufferAttribute(n, g),
                  a.add(h),
                  l.add(h),
                  c.add(h),
                  n.setXYZ(m, a.x, a.y, a.z),
                  n.setXYZ(p, l.x, l.y, l.z),
                  n.setXYZ(g, c.x, c.y, c.z);
              }
            else
              for (let d = 0, f = t.count; d < f; d += 3)
                i.fromBufferAttribute(t, d + 0),
                  r.fromBufferAttribute(t, d + 1),
                  o.fromBufferAttribute(t, d + 2),
                  h.subVectors(o, r),
                  u.subVectors(i, r),
                  h.cross(u),
                  n.setXYZ(d + 0, h.x, h.y, h.z),
                  n.setXYZ(d + 1, h.x, h.y, h.z),
                  n.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!(e && e.isBufferGeometry)) {
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
            return;
          }
          t === void 0 &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (e.attributes[i] === void 0) continue;
            const o = n[i].array,
              a = e.attributes[i],
              l = a.array,
              c = a.itemSize * t,
              h = Math.min(l.length, o.length - c);
            for (let u = 0, d = c; u < h; u++, d++) o[d] = l[u];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            At.fromBufferAttribute(e, t),
              At.normalize(),
              e.setXYZ(t, At.x, At.y, At.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              h = a.itemSize,
              u = a.normalized,
              d = new c.constructor(l.length * h);
            let f = 0,
              m = 0;
            for (let p = 0, g = l.length; p < g; p++) {
              f = l[p] * h;
              for (let x = 0; x < h; x++) d[m++] = c[f++];
            }
            return new bt(d, h, u);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new ut(),
            n = this.index.array,
            i = this.attributes;
          for (const a in i) {
            const l = i[a],
              c = e(l, n);
            t.setAttribute(a, c);
          }
          const r = this.morphAttributes;
          for (const a in r) {
            const l = [],
              c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
              const d = c[h],
                f = e(d, n);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              h = [];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = c[u];
              h.push(f.toJSON(e.data));
            }
            h.length > 0 && ((i[l] = h), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            a !== null &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new ut().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          n !== null && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const c in i) {
            const h = i[c];
            this.setAttribute(c, h.clone(t));
          }
          const r = e.morphAttributes;
          for (const c in r) {
            const h = [],
              u = r[c];
            for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
            this.morphAttributes[c] = h;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          const a = e.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            l !== null && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      ut.prototype.isBufferGeometry = !0;
      const md = new Ge(),
        br = new bs(),
        hc = new ar(),
        _i = new G(),
        vi = new G(),
        yi = new G(),
        uc = new G(),
        dc = new G(),
        fc = new G(),
        oa = new G(),
        aa = new G(),
        la = new G(),
        ca = new Se(),
        ha = new Se(),
        ua = new Se(),
        pc = new G(),
        da = new G();
      class vn extends Ke {
        constructor(e = new ut(), t = new Di()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            e.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (
            i === void 0 ||
            (n.boundingSphere === null && n.computeBoundingSphere(),
            hc.copy(n.boundingSphere),
            hc.applyMatrix4(r),
            e.ray.intersectsSphere(hc) === !1) ||
            (md.copy(r).invert(),
            br.copy(e.ray).applyMatrix4(md),
            n.boundingBox !== null && br.intersectsBox(n.boundingBox) === !1)
          )
            return;
          let o;
          if (n.isBufferGeometry) {
            const a = n.index,
              l = n.attributes.position,
              c = n.morphAttributes.position,
              h = n.morphTargetsRelative,
              u = n.attributes.uv,
              d = n.attributes.uv2,
              f = n.groups,
              m = n.drawRange;
            if (a !== null)
              if (Array.isArray(i))
                for (let p = 0, g = f.length; p < g; p++) {
                  const x = f[p],
                    _ = i[x.materialIndex],
                    M = Math.max(x.start, m.start),
                    S = Math.min(x.start + x.count, m.start + m.count);
                  for (let v = M, y = S; v < y; v += 3) {
                    const C = a.getX(v),
                      U = a.getX(v + 1),
                      K = a.getX(v + 2);
                    (o = fa(this, _, e, br, l, c, h, u, d, C, U, K)),
                      o &&
                        ((o.faceIndex = Math.floor(v / 3)),
                        (o.face.materialIndex = x.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const p = Math.max(0, m.start),
                  g = Math.min(a.count, m.start + m.count);
                for (let x = p, _ = g; x < _; x += 3) {
                  const M = a.getX(x),
                    S = a.getX(x + 1),
                    v = a.getX(x + 2);
                  (o = fa(this, i, e, br, l, c, h, u, d, M, S, v)),
                    o && ((o.faceIndex = Math.floor(x / 3)), t.push(o));
                }
              }
            else if (l !== void 0)
              if (Array.isArray(i))
                for (let p = 0, g = f.length; p < g; p++) {
                  const x = f[p],
                    _ = i[x.materialIndex],
                    M = Math.max(x.start, m.start),
                    S = Math.min(x.start + x.count, m.start + m.count);
                  for (let v = M, y = S; v < y; v += 3) {
                    const C = v,
                      U = v + 1,
                      K = v + 2;
                    (o = fa(this, _, e, br, l, c, h, u, d, C, U, K)),
                      o &&
                        ((o.faceIndex = Math.floor(v / 3)),
                        (o.face.materialIndex = x.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const p = Math.max(0, m.start),
                  g = Math.min(l.count, m.start + m.count);
                for (let x = p, _ = g; x < _; x += 3) {
                  const M = x,
                    S = x + 1,
                    v = x + 2;
                  (o = fa(this, i, e, br, l, c, h, u, d, M, S, v)),
                    o && ((o.faceIndex = Math.floor(x / 3)), t.push(o));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      vn.prototype.isMesh = !0;
      function sv(s, e, t, n, i, r, o, a) {
        let l;
        if (
          (e.side === Rt
            ? (l = n.intersectTriangle(o, r, i, !0, a))
            : (l = n.intersectTriangle(i, r, o, e.side !== ko, a)),
          l === null)
        )
          return null;
        da.copy(a), da.applyMatrix4(s.matrixWorld);
        const c = t.ray.origin.distanceTo(da);
        return c < t.near || c > t.far
          ? null
          : { distance: c, point: da.clone(), object: s };
      }
      function fa(s, e, t, n, i, r, o, a, l, c, h, u) {
        _i.fromBufferAttribute(i, c),
          vi.fromBufferAttribute(i, h),
          yi.fromBufferAttribute(i, u);
        const d = s.morphTargetInfluences;
        if (e.morphTargets && r && d) {
          oa.set(0, 0, 0), aa.set(0, 0, 0), la.set(0, 0, 0);
          for (let m = 0, p = r.length; m < p; m++) {
            const g = d[m],
              x = r[m];
            g !== 0 &&
              (uc.fromBufferAttribute(x, c),
              dc.fromBufferAttribute(x, h),
              fc.fromBufferAttribute(x, u),
              o
                ? (oa.addScaledVector(uc, g),
                  aa.addScaledVector(dc, g),
                  la.addScaledVector(fc, g))
                : (oa.addScaledVector(uc.sub(_i), g),
                  aa.addScaledVector(dc.sub(vi), g),
                  la.addScaledVector(fc.sub(yi), g)));
          }
          _i.add(oa), vi.add(aa), yi.add(la);
        }
        s.isSkinnedMesh &&
          (s.boneTransform(c, _i),
          s.boneTransform(h, vi),
          s.boneTransform(u, yi));
        const f = sv(s, e, t, n, _i, vi, yi, pc);
        if (f) {
          a &&
            (ca.fromBufferAttribute(a, c),
            ha.fromBufferAttribute(a, h),
            ua.fromBufferAttribute(a, u),
            (f.uv = yt.getUV(pc, _i, vi, yi, ca, ha, ua, new Se()))),
            l &&
              (ca.fromBufferAttribute(l, c),
              ha.fromBufferAttribute(l, h),
              ua.fromBufferAttribute(l, u),
              (f.uv2 = yt.getUV(pc, _i, vi, yi, ca, ha, ua, new Se())));
          const m = { a: c, b: h, c: u, normal: new G(), materialIndex: 0 };
          yt.getNormal(_i, vi, yi, m.normal), (f.face = m);
        }
        return f;
      }
      class jh extends ut {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: o,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
          const l = [],
            c = [],
            h = [],
            u = [];
          let d = 0,
            f = 0;
          m("z", "y", "x", -1, -1, n, t, e, o, r, 0),
            m("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
            m("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            m("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            m("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            m("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(l),
            this.setAttribute("position", new Pt(c, 3)),
            this.setAttribute("normal", new Pt(h, 3)),
            this.setAttribute("uv", new Pt(u, 2));
          function m(p, g, x, _, M, S, v, y, C, U, K) {
            const X = S / C,
              b = v / U,
              D = S / 2,
              I = v / 2,
              L = y / 2,
              B = C + 1,
              R = U + 1;
            let V = 0,
              H = 0;
            const J = new G();
            for (let ie = 0; ie < R; ie++) {
              const ne = ie * b - I;
              for (let ae = 0; ae < B; ae++) {
                const fe = ae * X - D;
                (J[p] = fe * _),
                  (J[g] = ne * M),
                  (J[x] = L),
                  c.push(J.x, J.y, J.z),
                  (J[p] = 0),
                  (J[g] = 0),
                  (J[x] = y > 0 ? 1 : -1),
                  h.push(J.x, J.y, J.z),
                  u.push(ae / C),
                  u.push(1 - ie / U),
                  (V += 1);
              }
            }
            for (let ie = 0; ie < U; ie++)
              for (let ne = 0; ne < C; ne++) {
                const ae = d + ne + B * ie,
                  fe = d + ne + B * (ie + 1),
                  Fe = d + (ne + 1) + B * (ie + 1),
                  Ee = d + (ne + 1) + B * ie;
                l.push(ae, fe, Ee), l.push(fe, Fe, Ee), (H += 6);
              }
            a.addGroup(f, H, K), (f += H), (d += V);
          }
        }
      }
      function hs(s) {
        const e = {};
        for (const t in s) {
          e[t] = {};
          for (const n in s[t]) {
            const i = s[t][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (e[t][n] = i.clone())
              : Array.isArray(i)
              ? (e[t][n] = i.slice())
              : (e[t][n] = i);
          }
        }
        return e;
      }
      function kt(s) {
        const e = {};
        for (let t = 0; t < s.length; t++) {
          const n = hs(s[t]);
          for (const i in n) e[i] = n[i];
        }
        return e;
      }
      const ov = { clone: hs, merge: kt };
      var av = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        lv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class ir extends It {
        constructor(e) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = av),
            (this.fragmentShader = lv),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 &&
              (e.attributes !== void 0 &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = hs(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture
              ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
              : o && o.isColor
              ? (t.uniforms[i] = { type: "c", value: o.getHex() })
              : o && o.isVector2
              ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
              : o && o.isVector3
              ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
              ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
              : o && o.isMatrix3
              ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
              : o && o.isMatrix4
              ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
              : (t.uniforms[i] = { value: o });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      ir.prototype.isShaderMaterial = !0;
      class Yh extends Ke {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Ge()),
            (this.projectionMatrix = new Ge()),
            (this.projectionMatrixInverse = new Ge());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          e === void 0 &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required"
            ),
            (e = new G())),
            this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Yh.prototype.isCamera = !0;
      class tn extends Yh {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = Lo * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(_o * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return Lo * 2 * Math.atan(Math.tan(_o * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, r, o) {
          (this.aspect = e / t),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(_o * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const o = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
              c = o.fullHeight;
            (r += (o.offsetX * i) / l),
              (t -= (o.offsetY * n) / c),
              (i *= o.width / l),
              (n *= o.height / c);
          }
          const a = this.filmOffset;
          a !== 0 && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      tn.prototype.isPerspectiveCamera = !0;
      const wr = 90,
        Sr = 1;
      class Zh extends Ke {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            n.isWebGLCubeRenderTarget !== !0)
          ) {
            console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
            return;
          }
          this.renderTarget = n;
          const i = new tn(wr, Sr, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new G(1, 0, 0)),
            this.add(i);
          const r = new tn(wr, Sr, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new G(-1, 0, 0)),
            this.add(r);
          const o = new tn(wr, Sr, e, t);
          (o.layers = this.layers),
            o.up.set(0, 0, 1),
            o.lookAt(new G(0, 1, 0)),
            this.add(o);
          const a = new tn(wr, Sr, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new G(0, -1, 0)),
            this.add(a);
          const l = new tn(wr, Sr, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new G(0, 0, 1)),
            this.add(l);
          const c = new tn(wr, Sr, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new G(0, 0, -1)),
            this.add(c);
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, o, a, l, c] = this.children,
            h = e.xr.enabled,
            u = e.getRenderTarget();
          e.xr.enabled = !1;
          const d = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, r),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            (n.texture.generateMipmaps = d),
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            (e.xr.enabled = h);
        }
      }
      class Ml extends Ht {
        constructor(e, t, n, i, r, o, a, l, c, h) {
          (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : Gh),
            (a = a !== void 0 ? a : Ni),
            super(e, t, n, i, r, o, a, l, c, h),
            (this._needsFlipEnvMap = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      Ml.prototype.isCubeTexture = !0;
      class sm extends ai {
        constructor(e, t, n) {
          Number.isInteger(t) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (t = n)),
            super(e, e, t),
            (t = t || {}),
            (this.texture = new Ml(
              void 0,
              t.mapping,
              t.wrapS,
              t.wrapT,
              t.magFilter,
              t.minFilter,
              t.format,
              t.type,
              t.anisotropy,
              t.encoding
            )),
            (this.texture.generateMipmaps =
              t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
              t.minFilter !== void 0 ? t.minFilter : sn),
            (this.texture._needsFlipEnvMap = !1);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.format = In),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new jh(5, 5, 5),
            r = new ir({
              name: "CubemapFromEquirect",
              uniforms: hs(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: Rt,
              blending: po,
            });
          r.uniforms.tEquirect.value = t;
          const o = new vn(i, r),
            a = t.minFilter;
          return (
            t.minFilter === ys && (t.minFilter = sn),
            new Zh(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      sm.prototype.isWebGLCubeRenderTarget = !0;
      const Tr = new ar(),
        pa = new G();
      class bl {
        constructor(
          e = new Un(),
          t = new Un(),
          n = new Un(),
          i = new Un(),
          r = new Un(),
          o = new Un()
        ) {
          this.planes = [e, t, n, i, r, o];
        }
        set(e, t, n, i, r, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            o = n[2],
            a = n[3],
            l = n[4],
            c = n[5],
            h = n[6],
            u = n[7],
            d = n[8],
            f = n[9],
            m = n[10],
            p = n[11],
            g = n[12],
            x = n[13],
            _ = n[14],
            M = n[15];
          return (
            t[0].setComponents(a - i, u - l, p - d, M - g).normalize(),
            t[1].setComponents(a + i, u + l, p + d, M + g).normalize(),
            t[2].setComponents(a + r, u + c, p + f, M + x).normalize(),
            t[3].setComponents(a - r, u - c, p - f, M - x).normalize(),
            t[4].setComponents(a - o, u - h, p - m, M - _).normalize(),
            t[5].setComponents(a + o, u + h, p + m, M + _).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            t.boundingSphere === null && t.computeBoundingSphere(),
            Tr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Tr)
          );
        }
        intersectsSprite(e) {
          return (
            Tr.center.set(0, 0, 0),
            (Tr.radius = 0.7071067811865476),
            Tr.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Tr)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((pa.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (pa.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (pa.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(pa) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function om() {
        let s = null,
          e = !1,
          t = null,
          n = null;
        function i(r, o) {
          t(r, o), (n = s.requestAnimationFrame(i));
        }
        return {
          start: function () {
            e !== !0 &&
              t !== null &&
              ((n = s.requestAnimationFrame(i)), (e = !0));
          },
          stop: function () {
            s.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (r) {
            t = r;
          },
          setContext: function (r) {
            s = r;
          },
        };
      }
      function cv(s, e) {
        const t = e.isWebGL2,
          n = new WeakMap();
        function i(c, h) {
          const u = c.array,
            d = c.usage,
            f = s.createBuffer();
          s.bindBuffer(h, f), s.bufferData(h, u, d), c.onUploadCallback();
          let m = 5126;
          return (
            u instanceof Float32Array
              ? (m = 5126)
              : u instanceof Float64Array
              ? console.warn(
                  "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                )
              : u instanceof Uint16Array
              ? c.isFloat16BufferAttribute
                ? t
                  ? (m = 5131)
                  : console.warn(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    )
                : (m = 5123)
              : u instanceof Int16Array
              ? (m = 5122)
              : u instanceof Uint32Array
              ? (m = 5125)
              : u instanceof Int32Array
              ? (m = 5124)
              : u instanceof Int8Array
              ? (m = 5120)
              : (u instanceof Uint8Array || u instanceof Uint8ClampedArray) &&
                (m = 5121),
            {
              buffer: f,
              type: m,
              bytesPerElement: u.BYTES_PER_ELEMENT,
              version: c.version,
            }
          );
        }
        function r(c, h, u) {
          const d = h.array,
            f = h.updateRange;
          s.bindBuffer(u, c),
            f.count === -1
              ? s.bufferSubData(u, 0, d)
              : (t
                  ? s.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d,
                      f.offset,
                      f.count
                    )
                  : s.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d.subarray(f.offset, f.offset + f.count)
                    ),
                (f.count = -1));
        }
        function o(c) {
          return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
        }
        function a(c) {
          c.isInterleavedBufferAttribute && (c = c.data);
          const h = n.get(c);
          h && (s.deleteBuffer(h.buffer), n.delete(c));
        }
        function l(c, h) {
          if (c.isGLBufferAttribute) {
            const d = n.get(c);
            (!d || d.version < c.version) &&
              n.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version,
              });
            return;
          }
          c.isInterleavedBufferAttribute && (c = c.data);
          const u = n.get(c);
          u === void 0
            ? n.set(c, i(c, h))
            : u.version < c.version &&
              (r(u.buffer, c, h), (u.version = c.version));
        }
        return { get: o, remove: a, update: l };
      }
      class hv extends ut {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            o = t / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            h = l + 1,
            u = e / a,
            d = t / l,
            f = [],
            m = [],
            p = [],
            g = [];
          for (let x = 0; x < h; x++) {
            const _ = x * d - o;
            for (let M = 0; M < c; M++) {
              const S = M * u - r;
              m.push(S, -_, 0),
                p.push(0, 0, 1),
                g.push(M / a),
                g.push(1 - x / l);
            }
          }
          for (let x = 0; x < l; x++)
            for (let _ = 0; _ < a; _++) {
              const M = _ + c * x,
                S = _ + c * (x + 1),
                v = _ + 1 + c * (x + 1),
                y = _ + 1 + c * x;
              f.push(M, S, y), f.push(S, v, y);
            }
          this.setIndex(f),
            this.setAttribute("position", new Pt(m, 3)),
            this.setAttribute("normal", new Pt(p, 3)),
            this.setAttribute("uv", new Pt(g, 2));
        }
      }
      var uv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
        dv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        fv = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,
        pv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,
        mv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        gv = "vec3 transformed = vec3( position );",
        xv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        _v = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,
        vv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        yv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
        Mv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        bv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        wv = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        Sv = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        Tv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        Ev = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
        Av = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
        Lv = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
        Rv = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        Cv = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Pv = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        Dv = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
        Iv = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        Nv = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        Fv = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        Bv = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
        zv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        Ov = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        Uv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        Hv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        Gv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        Vv = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,
        kv = `#ifdef USE_FOG
	varying float fogDepth;
#endif`,
        Wv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        $v = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        qv = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
        Xv = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,
        jv = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        Yv = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
        Zv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,
        Jv = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,
        Kv = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        Qv = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
        ey = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        ty = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
        ny = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,
        iy = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        ry = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        sy = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,
        oy = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
        ay = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        ly = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        cy = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
        hy = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
        uy = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
        dy = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        fy = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        py = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        my = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        gy = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        xy = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,
        _y = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
        vy = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,
        yy = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
        My = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        by = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
        wy = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
        Sy = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
        Ty = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
        Ey = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
        Ay = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        Ly = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        Ry = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        Cy = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        Py = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        Dy = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        Iy = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
        Ny = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        Fy = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
        By = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        zy = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        Oy = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
        Uy = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        Hy = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        Gy = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        Vy = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        ky = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        Wy = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        $y = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		totalTransmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSNMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	vec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );
	vec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );
	vec3 f90 = vec3( 1.0 );
	vec3 f_transmission = totalTransmission * getIBLVolumeRefraction(
		normal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance);
	diffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );
#endif`,
        qy = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec4 vWorldPosition;
	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));
		return normalize(refractionVector) * thickness * modelScale;
	}
	float applyIorToRoughness(float roughness, float ior) {
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}
	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}
	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;
		}
	}
	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);
		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);
		float NdotV = saturate(dot(n, viewDir));
		vec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);
		vec3 specularColor = f0 * brdf.x + f90 * brdf.y;
		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif`,
        Xy = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
        jy = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
        Yy = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
        Zy = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
        Jy = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
        Ky = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
        Qy = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
        e0 = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        t0 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        n0 = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        i0 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        r0 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
        s0 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        o0 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        a0 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        l0 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        c0 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        h0 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        u0 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        d0 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        f0 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        p0 = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        m0 = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        g0 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        x0 = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        _0 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        v0 = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        y0 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        M0 = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        b0 = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform vec3 attenuationColor;
	uniform float attenuationDistance;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef USE_TRANSMISSION
		float totalTransmission = transmission;
		float thicknessFactor = thickness;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	vec3 rawDiffuseColor = diffuseColor.rgb;
	#include <transmission_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        w0 = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#ifdef USE_TRANSMISSION
	varying vec4 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition;
#endif
}`,
        S0 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
        T0 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        E0 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        A0 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        L0 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        R0 = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        C0 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        P0 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
      const je = {
          alphamap_fragment: uv,
          alphamap_pars_fragment: dv,
          alphatest_fragment: fv,
          aomap_fragment: pv,
          aomap_pars_fragment: mv,
          begin_vertex: gv,
          beginnormal_vertex: xv,
          bsdfs: _v,
          bumpmap_pars_fragment: vv,
          clipping_planes_fragment: yv,
          clipping_planes_pars_fragment: Mv,
          clipping_planes_pars_vertex: bv,
          clipping_planes_vertex: wv,
          color_fragment: Sv,
          color_pars_fragment: Tv,
          color_pars_vertex: Ev,
          color_vertex: Av,
          common: Lv,
          cube_uv_reflection_fragment: Rv,
          defaultnormal_vertex: Cv,
          displacementmap_pars_vertex: Pv,
          displacementmap_vertex: Dv,
          emissivemap_fragment: Iv,
          emissivemap_pars_fragment: Nv,
          encodings_fragment: Fv,
          encodings_pars_fragment: Bv,
          envmap_fragment: zv,
          envmap_common_pars_fragment: Ov,
          envmap_pars_fragment: Uv,
          envmap_pars_vertex: Hv,
          envmap_physical_pars_fragment: Jv,
          envmap_vertex: Gv,
          fog_vertex: Vv,
          fog_pars_vertex: kv,
          fog_fragment: Wv,
          fog_pars_fragment: $v,
          gradientmap_pars_fragment: qv,
          lightmap_fragment: Xv,
          lightmap_pars_fragment: jv,
          lights_lambert_vertex: Yv,
          lights_pars_begin: Zv,
          lights_toon_fragment: Kv,
          lights_toon_pars_fragment: Qv,
          lights_phong_fragment: ey,
          lights_phong_pars_fragment: ty,
          lights_physical_fragment: ny,
          lights_physical_pars_fragment: iy,
          lights_fragment_begin: ry,
          lights_fragment_maps: sy,
          lights_fragment_end: oy,
          logdepthbuf_fragment: ay,
          logdepthbuf_pars_fragment: ly,
          logdepthbuf_pars_vertex: cy,
          logdepthbuf_vertex: hy,
          map_fragment: uy,
          map_pars_fragment: dy,
          map_particle_fragment: fy,
          map_particle_pars_fragment: py,
          metalnessmap_fragment: my,
          metalnessmap_pars_fragment: gy,
          morphnormal_vertex: xy,
          morphtarget_pars_vertex: _y,
          morphtarget_vertex: vy,
          normal_fragment_begin: yy,
          normal_fragment_maps: My,
          normalmap_pars_fragment: by,
          clearcoat_normal_fragment_begin: wy,
          clearcoat_normal_fragment_maps: Sy,
          clearcoat_pars_fragment: Ty,
          packing: Ey,
          premultiplied_alpha_fragment: Ay,
          project_vertex: Ly,
          dithering_fragment: Ry,
          dithering_pars_fragment: Cy,
          roughnessmap_fragment: Py,
          roughnessmap_pars_fragment: Dy,
          shadowmap_pars_fragment: Iy,
          shadowmap_pars_vertex: Ny,
          shadowmap_vertex: Fy,
          shadowmask_pars_fragment: By,
          skinbase_vertex: zy,
          skinning_pars_vertex: Oy,
          skinning_vertex: Uy,
          skinnormal_vertex: Hy,
          specularmap_fragment: Gy,
          specularmap_pars_fragment: Vy,
          tonemapping_fragment: ky,
          tonemapping_pars_fragment: Wy,
          transmission_fragment: $y,
          transmission_pars_fragment: qy,
          uv_pars_fragment: Xy,
          uv_pars_vertex: jy,
          uv_vertex: Yy,
          uv2_pars_fragment: Zy,
          uv2_pars_vertex: Jy,
          uv2_vertex: Ky,
          worldpos_vertex: Qy,
          background_frag: e0,
          background_vert: t0,
          cube_frag: n0,
          cube_vert: i0,
          depth_frag: r0,
          depth_vert: s0,
          distanceRGBA_frag: o0,
          distanceRGBA_vert: a0,
          equirect_frag: l0,
          equirect_vert: c0,
          linedashed_frag: h0,
          linedashed_vert: u0,
          meshbasic_frag: d0,
          meshbasic_vert: f0,
          meshlambert_frag: p0,
          meshlambert_vert: m0,
          meshmatcap_frag: g0,
          meshmatcap_vert: x0,
          meshtoon_frag: _0,
          meshtoon_vert: v0,
          meshphong_frag: y0,
          meshphong_vert: M0,
          meshphysical_frag: b0,
          meshphysical_vert: w0,
          normal_frag: S0,
          normal_vert: T0,
          points_frag: E0,
          points_vert: A0,
          shadow_frag: L0,
          shadow_vert: R0,
          sprite_frag: C0,
          sprite_vert: P0,
        },
        Pe = {
          common: {
            diffuse: { value: new Ue(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Ot() },
            uv2Transform: { value: new Ot() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new Se(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Ue(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ue(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new Ot() },
          },
          sprite: {
            diffuse: { value: new Ue(16777215) },
            opacity: { value: 1 },
            center: { value: new Se(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new Ot() },
          },
        },
        Hn = {
          basic: {
            uniforms: kt([
              Pe.common,
              Pe.specularmap,
              Pe.envmap,
              Pe.aomap,
              Pe.lightmap,
              Pe.fog,
            ]),
            vertexShader: je.meshbasic_vert,
            fragmentShader: je.meshbasic_frag,
          },
          lambert: {
            uniforms: kt([
              Pe.common,
              Pe.specularmap,
              Pe.envmap,
              Pe.aomap,
              Pe.lightmap,
              Pe.emissivemap,
              Pe.fog,
              Pe.lights,
              { emissive: { value: new Ue(0) } },
            ]),
            vertexShader: je.meshlambert_vert,
            fragmentShader: je.meshlambert_frag,
          },
          phong: {
            uniforms: kt([
              Pe.common,
              Pe.specularmap,
              Pe.envmap,
              Pe.aomap,
              Pe.lightmap,
              Pe.emissivemap,
              Pe.bumpmap,
              Pe.normalmap,
              Pe.displacementmap,
              Pe.fog,
              Pe.lights,
              {
                emissive: { value: new Ue(0) },
                specular: { value: new Ue(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: je.meshphong_vert,
            fragmentShader: je.meshphong_frag,
          },
          standard: {
            uniforms: kt([
              Pe.common,
              Pe.envmap,
              Pe.aomap,
              Pe.lightmap,
              Pe.emissivemap,
              Pe.bumpmap,
              Pe.normalmap,
              Pe.displacementmap,
              Pe.roughnessmap,
              Pe.metalnessmap,
              Pe.fog,
              Pe.lights,
              {
                emissive: { value: new Ue(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: je.meshphysical_vert,
            fragmentShader: je.meshphysical_frag,
          },
          toon: {
            uniforms: kt([
              Pe.common,
              Pe.aomap,
              Pe.lightmap,
              Pe.emissivemap,
              Pe.bumpmap,
              Pe.normalmap,
              Pe.displacementmap,
              Pe.gradientmap,
              Pe.fog,
              Pe.lights,
              { emissive: { value: new Ue(0) } },
            ]),
            vertexShader: je.meshtoon_vert,
            fragmentShader: je.meshtoon_frag,
          },
          matcap: {
            uniforms: kt([
              Pe.common,
              Pe.bumpmap,
              Pe.normalmap,
              Pe.displacementmap,
              Pe.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: je.meshmatcap_vert,
            fragmentShader: je.meshmatcap_frag,
          },
          points: {
            uniforms: kt([Pe.points, Pe.fog]),
            vertexShader: je.points_vert,
            fragmentShader: je.points_frag,
          },
          dashed: {
            uniforms: kt([
              Pe.common,
              Pe.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: je.linedashed_vert,
            fragmentShader: je.linedashed_frag,
          },
          depth: {
            uniforms: kt([Pe.common, Pe.displacementmap]),
            vertexShader: je.depth_vert,
            fragmentShader: je.depth_frag,
          },
          normal: {
            uniforms: kt([
              Pe.common,
              Pe.bumpmap,
              Pe.normalmap,
              Pe.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: je.normal_vert,
            fragmentShader: je.normal_frag,
          },
          sprite: {
            uniforms: kt([Pe.sprite, Pe.fog]),
            vertexShader: je.sprite_vert,
            fragmentShader: je.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new Ot() },
              t2D: { value: null },
            },
            vertexShader: je.background_vert,
            fragmentShader: je.background_frag,
          },
          cube: {
            uniforms: kt([Pe.envmap, { opacity: { value: 1 } }]),
            vertexShader: je.cube_vert,
            fragmentShader: je.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: je.equirect_vert,
            fragmentShader: je.equirect_frag,
          },
          distanceRGBA: {
            uniforms: kt([
              Pe.common,
              Pe.displacementmap,
              {
                referencePosition: { value: new G() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: je.distanceRGBA_vert,
            fragmentShader: je.distanceRGBA_frag,
          },
          shadow: {
            uniforms: kt([
              Pe.lights,
              Pe.fog,
              { color: { value: new Ue(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: je.shadow_vert,
            fragmentShader: je.shadow_frag,
          },
        };
      Hn.physical = {
        uniforms: kt([
          Hn.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Se(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new Ue(0) },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new Se() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Ue(0) },
          },
        ]),
        vertexShader: je.meshphysical_vert,
        fragmentShader: je.meshphysical_frag,
      };
      function D0(s, e, t, n, i) {
        const r = new Ue(0);
        let o = 0,
          a,
          l,
          c = null,
          h = 0,
          u = null;
        function d(m, p) {
          let g = !1,
            x = p.isScene === !0 ? p.background : null;
          x && x.isTexture && (x = e.get(x));
          const _ = s.xr,
            M = _.getSession && _.getSession();
          M && M.environmentBlendMode === "additive" && (x = null),
            x === null ? f(r, o) : x && x.isColor && (f(x, 1), (g = !0)),
            (s.autoClear || g) &&
              s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
            x && (x.isCubeTexture || x.mapping === kh)
              ? (l === void 0 &&
                  ((l = new vn(
                    new jh(1, 1, 1),
                    new ir({
                      name: "BackgroundCubeMaterial",
                      uniforms: hs(Hn.cube.uniforms),
                      vertexShader: Hn.cube.vertexShader,
                      fragmentShader: Hn.cube.fragmentShader,
                      side: Rt,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  l.geometry.deleteAttribute("uv"),
                  (l.onBeforeRender = function (S, v, y) {
                    this.matrixWorld.copyPosition(y.matrixWorld);
                  }),
                  Object.defineProperty(l.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(l)),
                (l.material.uniforms.envMap.value = x),
                (l.material.uniforms.flipEnvMap.value =
                  x.isCubeTexture && x._needsFlipEnvMap ? -1 : 1),
                (c !== x || h !== x.version || u !== s.toneMapping) &&
                  ((l.material.needsUpdate = !0),
                  (c = x),
                  (h = x.version),
                  (u = s.toneMapping)),
                m.unshift(l, l.geometry, l.material, 0, 0, null))
              : x &&
                x.isTexture &&
                (a === void 0 &&
                  ((a = new vn(
                    new hv(2, 2),
                    new ir({
                      name: "BackgroundMaterial",
                      uniforms: hs(Hn.background.uniforms),
                      vertexShader: Hn.background.vertexShader,
                      fragmentShader: Hn.background.fragmentShader,
                      side: So,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(a)),
                (a.material.uniforms.t2D.value = x),
                x.matrixAutoUpdate === !0 && x.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(x.matrix),
                (c !== x || h !== x.version || u !== s.toneMapping) &&
                  ((a.material.needsUpdate = !0),
                  (c = x),
                  (h = x.version),
                  (u = s.toneMapping)),
                m.unshift(a, a.geometry, a.material, 0, 0, null));
        }
        function f(m, p) {
          t.buffers.color.setClear(m.r, m.g, m.b, p, i);
        }
        return {
          getClearColor: function () {
            return r;
          },
          setClearColor: function (m, p = 1) {
            r.set(m), (o = p), f(r, o);
          },
          getClearAlpha: function () {
            return o;
          },
          setClearAlpha: function (m) {
            (o = m), f(r, o);
          },
          render: d,
        };
      }
      function I0(s, e, t, n) {
        const i = s.getParameter(34921),
          r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = n.isWebGL2 || r !== null,
          a = {},
          l = p(null);
        let c = l;
        function h(I, L, B, R, V) {
          let H = !1;
          if (o) {
            const J = m(R, B, L);
            c !== J && ((c = J), d(c.object)), (H = g(R, V)), H && x(R, V);
          } else {
            const J = L.wireframe === !0;
            (c.geometry !== R.id || c.program !== B.id || c.wireframe !== J) &&
              ((c.geometry = R.id),
              (c.program = B.id),
              (c.wireframe = J),
              (H = !0));
          }
          I.isInstancedMesh === !0 && (H = !0),
            V !== null && t.update(V, 34963),
            H &&
              (C(I, L, B, R),
              V !== null && s.bindBuffer(34963, t.get(V).buffer));
        }
        function u() {
          return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
        }
        function d(I) {
          return n.isWebGL2 ? s.bindVertexArray(I) : r.bindVertexArrayOES(I);
        }
        function f(I) {
          return n.isWebGL2
            ? s.deleteVertexArray(I)
            : r.deleteVertexArrayOES(I);
        }
        function m(I, L, B) {
          const R = B.wireframe === !0;
          let V = a[I.id];
          V === void 0 && ((V = {}), (a[I.id] = V));
          let H = V[L.id];
          H === void 0 && ((H = {}), (V[L.id] = H));
          let J = H[R];
          return J === void 0 && ((J = p(u())), (H[R] = J)), J;
        }
        function p(I) {
          const L = [],
            B = [],
            R = [];
          for (let V = 0; V < i; V++) (L[V] = 0), (B[V] = 0), (R[V] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: L,
            enabledAttributes: B,
            attributeDivisors: R,
            object: I,
            attributes: {},
            index: null,
          };
        }
        function g(I, L) {
          const B = c.attributes,
            R = I.attributes;
          let V = 0;
          for (const H in R) {
            const J = B[H],
              ie = R[H];
            if (J === void 0 || J.attribute !== ie || J.data !== ie.data)
              return !0;
            V++;
          }
          return c.attributesNum !== V || c.index !== L;
        }
        function x(I, L) {
          const B = {},
            R = I.attributes;
          let V = 0;
          for (const H in R) {
            const J = R[H],
              ie = {};
            (ie.attribute = J), J.data && (ie.data = J.data), (B[H] = ie), V++;
          }
          (c.attributes = B), (c.attributesNum = V), (c.index = L);
        }
        function _() {
          const I = c.newAttributes;
          for (let L = 0, B = I.length; L < B; L++) I[L] = 0;
        }
        function M(I) {
          S(I, 0);
        }
        function S(I, L) {
          const B = c.newAttributes,
            R = c.enabledAttributes,
            V = c.attributeDivisors;
          (B[I] = 1),
            R[I] === 0 && (s.enableVertexAttribArray(I), (R[I] = 1)),
            V[I] !== L &&
              ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](I, L),
              (V[I] = L));
        }
        function v() {
          const I = c.newAttributes,
            L = c.enabledAttributes;
          for (let B = 0, R = L.length; B < R; B++)
            L[B] !== I[B] && (s.disableVertexAttribArray(B), (L[B] = 0));
        }
        function y(I, L, B, R, V, H) {
          n.isWebGL2 === !0 && (B === 5124 || B === 5125)
            ? s.vertexAttribIPointer(I, L, B, V, H)
            : s.vertexAttribPointer(I, L, B, R, V, H);
        }
        function C(I, L, B, R) {
          if (
            n.isWebGL2 === !1 &&
            (I.isInstancedMesh || R.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
          )
            return;
          _();
          const V = R.attributes,
            H = B.getAttributes(),
            J = L.defaultAttributeValues;
          for (const ie in H) {
            const ne = H[ie];
            if (ne >= 0) {
              const ae = V[ie];
              if (ae !== void 0) {
                const fe = ae.normalized,
                  Fe = ae.itemSize,
                  Ee = t.get(ae);
                if (Ee === void 0) continue;
                const $ = Ee.buffer,
                  ke = Ee.type,
                  Re = Ee.bytesPerElement;
                if (ae.isInterleavedBufferAttribute) {
                  const Te = ae.data,
                    ce = Te.stride,
                    Ie = ae.offset;
                  Te && Te.isInstancedInterleavedBuffer
                    ? (S(ne, Te.meshPerAttribute),
                      R._maxInstanceCount === void 0 &&
                        (R._maxInstanceCount = Te.meshPerAttribute * Te.count))
                    : M(ne),
                    s.bindBuffer(34962, $),
                    y(ne, Fe, ke, fe, ce * Re, Ie * Re);
                } else
                  ae.isInstancedBufferAttribute
                    ? (S(ne, ae.meshPerAttribute),
                      R._maxInstanceCount === void 0 &&
                        (R._maxInstanceCount = ae.meshPerAttribute * ae.count))
                    : M(ne),
                    s.bindBuffer(34962, $),
                    y(ne, Fe, ke, fe, 0, 0);
              } else if (ie === "instanceMatrix") {
                const fe = t.get(I.instanceMatrix);
                if (fe === void 0) continue;
                const Fe = fe.buffer,
                  Ee = fe.type;
                S(ne + 0, 1),
                  S(ne + 1, 1),
                  S(ne + 2, 1),
                  S(ne + 3, 1),
                  s.bindBuffer(34962, Fe),
                  s.vertexAttribPointer(ne + 0, 4, Ee, !1, 64, 0),
                  s.vertexAttribPointer(ne + 1, 4, Ee, !1, 64, 16),
                  s.vertexAttribPointer(ne + 2, 4, Ee, !1, 64, 32),
                  s.vertexAttribPointer(ne + 3, 4, Ee, !1, 64, 48);
              } else if (ie === "instanceColor") {
                const fe = t.get(I.instanceColor);
                if (fe === void 0) continue;
                const Fe = fe.buffer,
                  Ee = fe.type;
                S(ne, 1),
                  s.bindBuffer(34962, Fe),
                  s.vertexAttribPointer(ne, 3, Ee, !1, 12, 0);
              } else if (J !== void 0) {
                const fe = J[ie];
                if (fe !== void 0)
                  switch (fe.length) {
                    case 2:
                      s.vertexAttrib2fv(ne, fe);
                      break;
                    case 3:
                      s.vertexAttrib3fv(ne, fe);
                      break;
                    case 4:
                      s.vertexAttrib4fv(ne, fe);
                      break;
                    default:
                      s.vertexAttrib1fv(ne, fe);
                  }
              }
            }
          }
          v();
        }
        function U() {
          b();
          for (const I in a) {
            const L = a[I];
            for (const B in L) {
              const R = L[B];
              for (const V in R) f(R[V].object), delete R[V];
              delete L[B];
            }
            delete a[I];
          }
        }
        function K(I) {
          if (a[I.id] === void 0) return;
          const L = a[I.id];
          for (const B in L) {
            const R = L[B];
            for (const V in R) f(R[V].object), delete R[V];
            delete L[B];
          }
          delete a[I.id];
        }
        function X(I) {
          for (const L in a) {
            const B = a[L];
            if (B[I.id] === void 0) continue;
            const R = B[I.id];
            for (const V in R) f(R[V].object), delete R[V];
            delete B[I.id];
          }
        }
        function b() {
          D(), c !== l && ((c = l), d(c.object));
        }
        function D() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: h,
          reset: b,
          resetDefaultState: D,
          dispose: U,
          releaseStatesOfGeometry: K,
          releaseStatesOfProgram: X,
          initAttributes: _,
          enableAttribute: M,
          disableUnusedAttributes: v,
        };
      }
      function N0(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(c) {
          r = c;
        }
        function a(c, h) {
          s.drawArrays(r, c, h), t.update(h, r, 1);
        }
        function l(c, h, u) {
          if (u === 0) return;
          let d, f;
          if (i) (d = s), (f = "drawArraysInstanced");
          else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
          ) {
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          d[f](r, c, h, u), t.update(h, r, u);
        }
        (this.setMode = o), (this.render = a), (this.renderInstances = l);
      }
      function F0(s, e, t) {
        let n;
        function i() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            n = s.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function r(C) {
          if (C === "highp") {
            if (
              s.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              s.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            C = "mediump";
          }
          return C === "mediump" &&
            s.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            s.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          (typeof WebGL2RenderingContext != "undefined" &&
            s instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext != "undefined" &&
            s instanceof WebGL2ComputeRenderingContext);
        let a = t.precision !== void 0 ? t.precision : "highp";
        const l = r(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
          ),
          (a = l));
        const c = o || e.has("WEBGL_draw_buffers"),
          h = t.logarithmicDepthBuffer === !0,
          u = s.getParameter(34930),
          d = s.getParameter(35660),
          f = s.getParameter(3379),
          m = s.getParameter(34076),
          p = s.getParameter(34921),
          g = s.getParameter(36347),
          x = s.getParameter(36348),
          _ = s.getParameter(36349),
          M = d > 0,
          S = o || e.has("OES_texture_float"),
          v = M && S,
          y = o ? s.getParameter(36183) : 0;
        return {
          isWebGL2: o,
          drawBuffers: c,
          getMaxAnisotropy: i,
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: h,
          maxTextures: u,
          maxVertexTextures: d,
          maxTextureSize: f,
          maxCubemapSize: m,
          maxAttributes: p,
          maxVertexUniforms: g,
          maxVaryings: x,
          maxFragmentUniforms: _,
          vertexTextures: M,
          floatFragmentTextures: S,
          floatVertexTextures: v,
          maxSamples: y,
        };
      }
      function B0(s) {
        const e = this;
        let t = null,
          n = 0,
          i = !1,
          r = !1;
        const o = new Un(),
          a = new Ot(),
          l = { value: null, needsUpdate: !1 };
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (u, d, f) {
            const m = u.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = h(u, f, 0)), (n = u.length), m;
          }),
          (this.beginShadows = function () {
            (r = !0), h(null);
          }),
          (this.endShadows = function () {
            (r = !1), c();
          }),
          (this.setState = function (u, d, f) {
            const m = u.clippingPlanes,
              p = u.clipIntersection,
              g = u.clipShadows,
              x = s.get(u);
            if (!i || m === null || m.length === 0 || (r && !g))
              r ? h(null) : c();
            else {
              const _ = r ? 0 : n,
                M = _ * 4;
              let S = x.clippingState || null;
              (l.value = S), (S = h(m, d, M, f));
              for (let v = 0; v !== M; ++v) S[v] = t[v];
              (x.clippingState = S),
                (this.numIntersection = p ? this.numPlanes : 0),
                (this.numPlanes += _);
            }
          });
        function c() {
          l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function h(u, d, f, m) {
          const p = u !== null ? u.length : 0;
          let g = null;
          if (p !== 0) {
            if (((g = l.value), m !== !0 || g === null)) {
              const x = f + p * 4,
                _ = d.matrixWorldInverse;
              a.getNormalMatrix(_),
                (g === null || g.length < x) && (g = new Float32Array(x));
              for (let M = 0, S = f; M !== p; ++M, S += 4)
                o.copy(u[M]).applyMatrix4(_, a),
                  o.normal.toArray(g, S),
                  (g[S + 3] = o.constant);
            }
            (l.value = g), (l.needsUpdate = !0);
          }
          return (e.numPlanes = p), (e.numIntersection = 0), g;
        }
      }
      function z0(s) {
        let e = new WeakMap();
        function t(o, a) {
          return a === qu ? (o.mapping = Gh) : a === Xu && (o.mapping = Vh), o;
        }
        function n(o) {
          if (o && o.isTexture) {
            const a = o.mapping;
            if (a === qu || a === Xu)
              if (e.has(o)) {
                const l = e.get(o).texture;
                return t(l, o.mapping);
              } else {
                const l = o.image;
                if (l && l.height > 0) {
                  const c = s.getRenderTarget(),
                    h = new sm(l.height / 2);
                  return (
                    h.fromEquirectangularTexture(s, o),
                    e.set(o, h),
                    s.setRenderTarget(c),
                    o.addEventListener("dispose", i),
                    t(h.texture, o.mapping)
                  );
                } else return null;
              }
          }
          return o;
        }
        function i(o) {
          const a = o.target;
          a.removeEventListener("dispose", i);
          const l = e.get(a);
          l !== void 0 && (e.delete(a), l.dispose());
        }
        function r() {
          e = new WeakMap();
        }
        return { get: n, dispose: r };
      }
      function O0(s) {
        const e = {};
        function t(n) {
          if (e[n] !== void 0) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                s.getExtension("WEBGL_depth_texture") ||
                s.getExtension("MOZ_WEBGL_depth_texture") ||
                s.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                s.getExtension("EXT_texture_filter_anisotropic") ||
                s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                s.getExtension("WEBGL_compressed_texture_s3tc") ||
                s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                s.getExtension("WEBGL_compressed_texture_pvrtc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = s.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (n) {
            return t(n) !== null;
          },
          init: function (n) {
            n.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float");
          },
          get: function (n) {
            const i = t(n);
            return (
              i === null &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              i
            );
          },
        };
      }
      function U0(s, e, t, n) {
        const i = {},
          r = new WeakMap();
        function o(u) {
          const d = u.target;
          d.index !== null && e.remove(d.index);
          for (const m in d.attributes) e.remove(d.attributes[m]);
          d.removeEventListener("dispose", o), delete i[d.id];
          const f = r.get(d);
          f && (e.remove(f), r.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
        }
        function a(u, d) {
          return (
            i[d.id] === !0 ||
              (d.addEventListener("dispose", o),
              (i[d.id] = !0),
              t.memory.geometries++),
            d
          );
        }
        function l(u) {
          const d = u.attributes;
          for (const m in d) e.update(d[m], 34962);
          const f = u.morphAttributes;
          for (const m in f) {
            const p = f[m];
            for (let g = 0, x = p.length; g < x; g++) e.update(p[g], 34962);
          }
        }
        function c(u) {
          const d = [],
            f = u.index,
            m = u.attributes.position;
          let p = 0;
          if (f !== null) {
            const _ = f.array;
            p = f.version;
            for (let M = 0, S = _.length; M < S; M += 3) {
              const v = _[M + 0],
                y = _[M + 1],
                C = _[M + 2];
              d.push(v, y, y, C, C, v);
            }
          } else {
            const _ = m.array;
            p = m.version;
            for (let M = 0, S = _.length / 3 - 1; M < S; M += 3) {
              const v = M + 0,
                y = M + 1,
                C = M + 2;
              d.push(v, y, y, C, C, v);
            }
          }
          const g = new (rm(d) > 65535 ? im : nm)(d, 1);
          g.version = p;
          const x = r.get(u);
          x && e.remove(x), r.set(u, g);
        }
        function h(u) {
          const d = r.get(u);
          if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u);
          } else c(u);
          return r.get(u);
        }
        return { get: a, update: l, getWireframeAttribute: h };
      }
      function H0(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(d) {
          r = d;
        }
        let a, l;
        function c(d) {
          (a = d.type), (l = d.bytesPerElement);
        }
        function h(d, f) {
          s.drawElements(r, f, a, d * l), t.update(f, r, 1);
        }
        function u(d, f, m) {
          if (m === 0) return;
          let p, g;
          if (i) (p = s), (g = "drawElementsInstanced");
          else if (
            ((p = e.get("ANGLE_instanced_arrays")),
            (g = "drawElementsInstancedANGLE"),
            p === null)
          ) {
            console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          p[g](r, f, a, d * l, m), t.update(f, r, m);
        }
        (this.setMode = o),
          (this.setIndex = c),
          (this.render = h),
          (this.renderInstances = u);
      }
      function G0(s) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(r, o, a) {
          switch ((t.calls++, o)) {
            case 4:
              t.triangles += a * (r / 3);
              break;
            case 1:
              t.lines += a * (r / 2);
              break;
            case 3:
              t.lines += a * (r - 1);
              break;
            case 2:
              t.lines += a * r;
              break;
            case 0:
              t.points += a * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", o);
              break;
          }
        }
        function i() {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: !0,
          reset: i,
          update: n,
        };
      }
      function V0(s, e) {
        return s[0] - e[0];
      }
      function k0(s, e) {
        return Math.abs(e[1]) - Math.abs(s[1]);
      }
      function W0(s) {
        const e = {},
          t = new Float32Array(8),
          n = [];
        for (let r = 0; r < 8; r++) n[r] = [r, 0];
        function i(r, o, a, l) {
          const c = r.morphTargetInfluences,
            h = c === void 0 ? 0 : c.length;
          let u = e[o.id];
          if (u === void 0) {
            u = [];
            for (let g = 0; g < h; g++) u[g] = [g, 0];
            e[o.id] = u;
          }
          for (let g = 0; g < h; g++) {
            const x = u[g];
            (x[0] = g), (x[1] = c[g]);
          }
          u.sort(k0);
          for (let g = 0; g < 8; g++)
            g < h && u[g][1]
              ? ((n[g][0] = u[g][0]), (n[g][1] = u[g][1]))
              : ((n[g][0] = Number.MAX_SAFE_INTEGER), (n[g][1] = 0));
          n.sort(V0);
          const d = a.morphTargets && o.morphAttributes.position,
            f = a.morphNormals && o.morphAttributes.normal;
          let m = 0;
          for (let g = 0; g < 8; g++) {
            const x = n[g],
              _ = x[0],
              M = x[1];
            _ !== Number.MAX_SAFE_INTEGER && M
              ? (d &&
                  o.getAttribute("morphTarget" + g) !== d[_] &&
                  o.setAttribute("morphTarget" + g, d[_]),
                f &&
                  o.getAttribute("morphNormal" + g) !== f[_] &&
                  o.setAttribute("morphNormal" + g, f[_]),
                (t[g] = M),
                (m += M))
              : (d &&
                  o.hasAttribute("morphTarget" + g) === !0 &&
                  o.deleteAttribute("morphTarget" + g),
                f &&
                  o.hasAttribute("morphNormal" + g) === !0 &&
                  o.deleteAttribute("morphNormal" + g),
                (t[g] = 0));
          }
          const p = o.morphTargetsRelative ? 1 : 1 - m;
          l.getUniforms().setValue(s, "morphTargetBaseInfluence", p),
            l.getUniforms().setValue(s, "morphTargetInfluences", t);
        }
        return { update: i };
      }
      function $0(s, e, t, n) {
        let i = new WeakMap();
        function r(l) {
          const c = n.render.frame,
            h = l.geometry,
            u = e.get(l, h);
          return (
            i.get(u) !== c && (e.update(u), i.set(u, c)),
            l.isInstancedMesh &&
              (l.hasEventListener("dispose", a) === !1 &&
                l.addEventListener("dispose", a),
              t.update(l.instanceMatrix, 34962),
              l.instanceColor !== null && t.update(l.instanceColor, 34962)),
            u
          );
        }
        function o() {
          i = new WeakMap();
        }
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return { update: r, dispose: o };
      }
      class am extends Ht {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = zt),
            (this.minFilter = zt),
            (this.wrapR = rn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      am.prototype.isDataTexture2DArray = !0;
      class lm extends Ht {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = zt),
            (this.minFilter = zt),
            (this.wrapR = rn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      lm.prototype.isDataTexture3D = !0;
      const cm = new Ht(),
        q0 = new am(),
        X0 = new lm(),
        hm = new Ml(),
        gd = [],
        xd = [],
        _d = new Float32Array(16),
        vd = new Float32Array(9),
        yd = new Float32Array(4);
      function Ss(s, e, t) {
        const n = s[0];
        if (n <= 0 || n > 0) return s;
        const i = e * t;
        let r = gd[i];
        if (
          (r === void 0 && ((r = new Float32Array(i)), (gd[i] = r)), e !== 0)
        ) {
          n.toArray(r, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), s[o].toArray(r, a);
        }
        return r;
      }
      function Jt(s, e) {
        if (s.length !== e.length) return !1;
        for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
        return !0;
      }
      function qt(s, e) {
        for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
      }
      function um(s, e) {
        let t = xd[e];
        t === void 0 && ((t = new Int32Array(e)), (xd[e] = t));
        for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
        return t;
      }
      function j0(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
      }
      function Y0(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y) &&
            (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (Jt(t, e)) return;
          s.uniform2fv(this.addr, e), qt(t, e);
        }
      }
      function Z0(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (s.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (s.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (Jt(t, e)) return;
          s.uniform3fv(this.addr, e), qt(t, e);
        }
      }
      function J0(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (Jt(t, e)) return;
          s.uniform4fv(this.addr, e), qt(t, e);
        }
      }
      function K0(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Jt(t, e)) return;
          s.uniformMatrix2fv(this.addr, !1, e), qt(t, e);
        } else {
          if (Jt(t, n)) return;
          yd.set(n), s.uniformMatrix2fv(this.addr, !1, yd), qt(t, n);
        }
      }
      function Q0(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Jt(t, e)) return;
          s.uniformMatrix3fv(this.addr, !1, e), qt(t, e);
        } else {
          if (Jt(t, n)) return;
          vd.set(n), s.uniformMatrix3fv(this.addr, !1, vd), qt(t, n);
        }
      }
      function eM(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Jt(t, e)) return;
          s.uniformMatrix4fv(this.addr, !1, e), qt(t, e);
        } else {
          if (Jt(t, n)) return;
          _d.set(n), s.uniformMatrix4fv(this.addr, !1, _d), qt(t, n);
        }
      }
      function tM(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
      }
      function nM(s, e) {
        const t = this.cache;
        Jt(t, e) || (s.uniform2iv(this.addr, e), qt(t, e));
      }
      function iM(s, e) {
        const t = this.cache;
        Jt(t, e) || (s.uniform3iv(this.addr, e), qt(t, e));
      }
      function rM(s, e) {
        const t = this.cache;
        Jt(t, e) || (s.uniform4iv(this.addr, e), qt(t, e));
      }
      function sM(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
      }
      function oM(s, e) {
        const t = this.cache;
        Jt(t, e) || (s.uniform2uiv(this.addr, e), qt(t, e));
      }
      function aM(s, e) {
        const t = this.cache;
        Jt(t, e) || (s.uniform3uiv(this.addr, e), qt(t, e));
      }
      function lM(s, e) {
        const t = this.cache;
        Jt(t, e) || (s.uniform4uiv(this.addr, e), qt(t, e));
      }
      function cM(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.safeSetTexture2D(e || cm, i);
      }
      function hM(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture3D(e || X0, i);
      }
      function uM(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.safeSetTextureCube(e || hm, i);
      }
      function dM(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2DArray(e || q0, i);
      }
      function fM(s) {
        switch (s) {
          case 5126:
            return j0;
          case 35664:
            return Y0;
          case 35665:
            return Z0;
          case 35666:
            return J0;
          case 35674:
            return K0;
          case 35675:
            return Q0;
          case 35676:
            return eM;
          case 5124:
          case 35670:
            return tM;
          case 35667:
          case 35671:
            return nM;
          case 35668:
          case 35672:
            return iM;
          case 35669:
          case 35673:
            return rM;
          case 5125:
            return sM;
          case 36294:
            return oM;
          case 36295:
            return aM;
          case 36296:
            return lM;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return cM;
          case 35679:
          case 36299:
          case 36307:
            return hM;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return uM;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return dM;
        }
      }
      function pM(s, e) {
        s.uniform1fv(this.addr, e);
      }
      function mM(s, e) {
        const t = Ss(e, this.size, 2);
        s.uniform2fv(this.addr, t);
      }
      function gM(s, e) {
        const t = Ss(e, this.size, 3);
        s.uniform3fv(this.addr, t);
      }
      function xM(s, e) {
        const t = Ss(e, this.size, 4);
        s.uniform4fv(this.addr, t);
      }
      function _M(s, e) {
        const t = Ss(e, this.size, 4);
        s.uniformMatrix2fv(this.addr, !1, t);
      }
      function vM(s, e) {
        const t = Ss(e, this.size, 9);
        s.uniformMatrix3fv(this.addr, !1, t);
      }
      function yM(s, e) {
        const t = Ss(e, this.size, 16);
        s.uniformMatrix4fv(this.addr, !1, t);
      }
      function MM(s, e) {
        s.uniform1iv(this.addr, e);
      }
      function bM(s, e) {
        s.uniform2iv(this.addr, e);
      }
      function wM(s, e) {
        s.uniform3iv(this.addr, e);
      }
      function SM(s, e) {
        s.uniform4iv(this.addr, e);
      }
      function TM(s, e) {
        s.uniform1uiv(this.addr, e);
      }
      function EM(s, e) {
        s.uniform2uiv(this.addr, e);
      }
      function AM(s, e) {
        s.uniform3uiv(this.addr, e);
      }
      function LM(s, e) {
        s.uniform4uiv(this.addr, e);
      }
      function RM(s, e, t) {
        const n = e.length,
          i = um(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.safeSetTexture2D(e[r] || cm, i[r]);
      }
      function CM(s, e, t) {
        const n = e.length,
          i = um(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.safeSetTextureCube(e[r] || hm, i[r]);
      }
      function PM(s) {
        switch (s) {
          case 5126:
            return pM;
          case 35664:
            return mM;
          case 35665:
            return gM;
          case 35666:
            return xM;
          case 35674:
            return _M;
          case 35675:
            return vM;
          case 35676:
            return yM;
          case 5124:
          case 35670:
            return MM;
          case 35667:
          case 35671:
            return bM;
          case 35668:
          case 35672:
            return wM;
          case 35669:
          case 35673:
            return SM;
          case 5125:
            return TM;
          case 36294:
            return EM;
          case 36295:
            return AM;
          case 36296:
            return LM;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return RM;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return CM;
        }
      }
      function DM(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.setValue = fM(e.type));
      }
      function dm(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = PM(e.type));
      }
      dm.prototype.updateCache = function (s) {
        const e = this.cache;
        s instanceof Float32Array &&
          e.length !== s.length &&
          (this.cache = new Float32Array(s.length)),
          qt(e, s);
      };
      function fm(s) {
        (this.id = s), (this.seq = []), (this.map = {});
      }
      fm.prototype.setValue = function (s, e, t) {
        const n = this.seq;
        for (let i = 0, r = n.length; i !== r; ++i) {
          const o = n[i];
          o.setValue(s, e[o.id], t);
        }
      };
      const mc = /(\w+)(\])?(\[|\.)?/g;
      function Md(s, e) {
        s.seq.push(e), (s.map[e.id] = e);
      }
      function IM(s, e, t) {
        const n = s.name,
          i = n.length;
        for (mc.lastIndex = 0; ; ) {
          const r = mc.exec(n),
            o = mc.lastIndex;
          let a = r[1];
          const l = r[2] === "]",
            c = r[3];
          if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
            Md(t, c === void 0 ? new DM(a, s, e) : new dm(a, s, e));
            break;
          } else {
            let u = t.map[a];
            u === void 0 && ((u = new fm(a)), Md(t, u)), (t = u);
          }
        }
      }
      function Fi(s, e) {
        (this.seq = []), (this.map = {});
        const t = s.getProgramParameter(e, 35718);
        for (let n = 0; n < t; ++n) {
          const i = s.getActiveUniform(e, n),
            r = s.getUniformLocation(e, i.name);
          IM(i, r, this);
        }
      }
      Fi.prototype.setValue = function (s, e, t, n) {
        const i = this.map[e];
        i !== void 0 && i.setValue(s, t, n);
      };
      Fi.prototype.setOptional = function (s, e, t) {
        const n = e[t];
        n !== void 0 && this.setValue(s, t, n);
      };
      Fi.upload = function (s, e, t, n) {
        for (let i = 0, r = e.length; i !== r; ++i) {
          const o = e[i],
            a = t[o.id];
          a.needsUpdate !== !1 && o.setValue(s, a.value, n);
        }
      };
      Fi.seqWithValue = function (s, e) {
        const t = [];
        for (let n = 0, i = s.length; n !== i; ++n) {
          const r = s[n];
          r.id in e && t.push(r);
        }
        return t;
      };
      function bd(s, e, t) {
        const n = s.createShader(e);
        return s.shaderSource(n, t), s.compileShader(n), n;
      }
      let NM = 0;
      function FM(s) {
        const e = s.split(`
`);
        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join(`
`);
      }
      function pm(s) {
        switch (s) {
          case Wo:
            return ["Linear", "( value )"];
          case dl:
            return ["sRGB", "( value )"];
          case y_:
            return ["RGBE", "( value )"];
          case b_:
            return ["RGBM", "( value, 7.0 )"];
          case w_:
            return ["RGBM", "( value, 16.0 )"];
          case S_:
            return ["RGBD", "( value, 256.0 )"];
          case v_:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case M_:
            return ["LogLuv", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", s),
              ["Linear", "( value )"]
            );
        }
      }
      function wd(s, e, t) {
        const n = s.getShaderParameter(e, 35713),
          i = s.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const r = s.getShaderSource(e);
        return (
          "THREE.WebGLShader: gl.getShaderInfoLog() " +
          t +
          `
` +
          i +
          FM(r)
        );
      }
      function qs(s, e) {
        const t = pm(e);
        return (
          "vec4 " +
          s +
          "( vec4 value ) { return " +
          t[0] +
          "ToLinear" +
          t[1] +
          "; }"
        );
      }
      function BM(s, e) {
        const t = pm(e);
        return (
          "vec4 " + s + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function zM(s, e) {
        let t;
        switch (e) {
          case _x:
            t = "Linear";
            break;
          case vx:
            t = "Reinhard";
            break;
          case yx:
            t = "OptimizedCineon";
            break;
          case Mx:
            t = "ACESFilmic";
            break;
          case bx:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          s +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function OM(s) {
        return [
          s.extensionDerivatives ||
          s.envMapCubeUV ||
          s.bumpMap ||
          s.tangentSpaceNormalMap ||
          s.clearcoatNormalMap ||
          s.flatShading ||
          s.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
          s.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (s.extensionShaderTextureLOD || s.envMap || s.transmission > 0) &&
          s.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ].filter(co).join(`
`);
      }
      function UM(s) {
        const e = [];
        for (const t in s) {
          const n = s[t];
          n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
      }
      function HM(s, e) {
        const t = {},
          n = s.getProgramParameter(e, 35721);
        for (let i = 0; i < n; i++) {
          const o = s.getActiveAttrib(e, i).name;
          t[o] = s.getAttribLocation(e, o);
        }
        return t;
      }
      function co(s) {
        return s !== "";
      }
      function Sd(s, e) {
        return s
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Td(s, e) {
        return s
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const GM = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function _h(s) {
        return s.replace(GM, VM);
      }
      function VM(s, e) {
        const t = je[e];
        if (t === void 0)
          throw new Error("Can not resolve #include <" + e + ">");
        return _h(t);
      }
      const kM =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        WM =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Ed(s) {
        return s.replace(WM, mm).replace(kM, $M);
      }
      function $M(s, e, t, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          mm(s, e, t, n)
        );
      }
      function mm(s, e, t, n) {
        let i = "";
        for (let r = parseInt(e); r < parseInt(t); r++)
          i += n
            .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, r);
        return i;
      }
      function Ad(s) {
        let e =
          "precision " +
          s.precision +
          ` float;
precision ` +
          s.precision +
          " int;";
        return (
          s.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : s.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : s.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function qM(s) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          s.shadowMapType === $p
            ? (e = "SHADOWMAP_TYPE_PCF")
            : s.shadowMapType === Zg
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : s.shadowMapType === lo && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function XM(s) {
        let e = "ENVMAP_TYPE_CUBE";
        if (s.envMap)
          switch (s.envMapMode) {
            case Gh:
            case Vh:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case kh:
            case Wh:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function jM(s) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (s.envMap)
          switch (s.envMapMode) {
            case Vh:
            case Wh:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function YM(s) {
        let e = "ENVMAP_BLENDING_NONE";
        if (s.envMap)
          switch (s.combine) {
            case yl:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case gx:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case xx:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function ZM(s, e, t, n) {
        const i = s.getContext(),
          r = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const l = qM(t),
          c = XM(t),
          h = jM(t),
          u = YM(t),
          d = s.gammaFactor > 0 ? s.gammaFactor : 1,
          f = t.isWebGL2 ? "" : OM(t),
          m = UM(r),
          p = i.createProgram();
        let g,
          x,
          _ = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((g = [m].filter(co).join(`
`)),
            g.length > 0 &&
              (g += `
`),
            (x = [f, m].filter(co).join(`
`)),
            x.length > 0 &&
              (x += `
`))
          : ((g = [
              Ad(t),
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + d,
              "#define MAX_BONES " + t.maxBones,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + h : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.useVertexTexture ? "#define BONE_TEXTURE" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(co).join(`
`)),
            (x = [
              f,
              Ad(t),
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.alphaTest
                ? "#define ALPHATEST " +
                  t.alphaTest +
                  (t.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + d,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + h : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (t.extensionShaderTextureLOD || t.envMap) &&
              t.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== go ? "#define TONE_MAPPING" : "",
              t.toneMapping !== go ? je.tonemapping_pars_fragment : "",
              t.toneMapping !== go ? zM("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              je.encodings_pars_fragment,
              t.map ? qs("mapTexelToLinear", t.mapEncoding) : "",
              t.matcap ? qs("matcapTexelToLinear", t.matcapEncoding) : "",
              t.envMap ? qs("envMapTexelToLinear", t.envMapEncoding) : "",
              t.emissiveMap
                ? qs("emissiveMapTexelToLinear", t.emissiveMapEncoding)
                : "",
              t.lightMap ? qs("lightMapTexelToLinear", t.lightMapEncoding) : "",
              BM("linearToOutputTexel", t.outputEncoding),
              t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
              `
`,
            ].filter(co).join(`
`))),
          (o = _h(o)),
          (o = Sd(o, t)),
          (o = Td(o, t)),
          (a = _h(a)),
          (a = Sd(a, t)),
          (a = Td(a, t)),
          (o = Ed(o)),
          (a = Ed(a)),
          t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((_ = `#version 300 es
`),
            (g =
              [
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              g),
            (x =
              [
                "#define varying in",
                t.glslVersion === rd ? "" : "out highp vec4 pc_fragColor;",
                t.glslVersion === rd ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              x));
        const M = _ + g + o,
          S = _ + x + a,
          v = bd(i, 35633, M),
          y = bd(i, 35632, S);
        if (
          (i.attachShader(p, v),
          i.attachShader(p, y),
          t.index0AttributeName !== void 0
            ? i.bindAttribLocation(p, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(p, 0, "position"),
          i.linkProgram(p),
          s.debug.checkShaderErrors)
        ) {
          const K = i.getProgramInfoLog(p).trim(),
            X = i.getShaderInfoLog(v).trim(),
            b = i.getShaderInfoLog(y).trim();
          let D = !0,
            I = !0;
          if (i.getProgramParameter(p, 35714) === !1) {
            D = !1;
            const L = wd(i, v, "vertex"),
              B = wd(i, y, "fragment");
            console.error(
              "THREE.WebGLProgram: shader error: ",
              i.getError(),
              "35715",
              i.getProgramParameter(p, 35715),
              "gl.getProgramInfoLog",
              K,
              L,
              B
            );
          } else
            K !== ""
              ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", K)
              : (X === "" || b === "") && (I = !1);
          I &&
            (this.diagnostics = {
              runnable: D,
              programLog: K,
              vertexShader: { log: X, prefix: g },
              fragmentShader: { log: b, prefix: x },
            });
        }
        i.deleteShader(v), i.deleteShader(y);
        let C;
        this.getUniforms = function () {
          return C === void 0 && (C = new Fi(i, p)), C;
        };
        let U;
        return (
          (this.getAttributes = function () {
            return U === void 0 && (U = HM(i, p)), U;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              i.deleteProgram(p),
              (this.program = void 0);
          }),
          (this.name = t.shaderName),
          (this.id = NM++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = p),
          (this.vertexShader = v),
          (this.fragmentShader = y),
          this
        );
      }
      function JM(s, e, t, n, i, r) {
        const o = [],
          a = n.isWebGL2,
          l = n.logarithmicDepthBuffer,
          c = n.floatVertexTextures,
          h = n.maxVertexUniforms,
          u = n.vertexTextures;
        let d = n.precision;
        const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
          m = [
            "precision",
            "isWebGL2",
            "supportsVertexTextures",
            "outputEncoding",
            "instancing",
            "instancingColor",
            "map",
            "mapEncoding",
            "matcap",
            "matcapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "envMapCubeUV",
            "lightMap",
            "lightMapEncoding",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "tangentSpaceNormalMap",
            "clearcoatMap",
            "clearcoatRoughnessMap",
            "clearcoatNormalMap",
            "displacementMap",
            "specularMap",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "vertexAlphas",
            "vertexTangents",
            "vertexUvs",
            "uvsVertexOnly",
            "fog",
            "useFog",
            "fogExp2",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "numDirLightShadows",
            "numPointLightShadows",
            "numSpotLightShadows",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
            "sheen",
            "transmission",
            "transmissionMap",
            "thicknessMap",
          ];
        function p(y) {
          const U = y.skeleton.bones;
          if (c) return 1024;
          {
            const X = Math.floor((h - 20) / 4),
              b = Math.min(X, U.length);
            return b < U.length
              ? (console.warn(
                  "THREE.WebGLRenderer: Skeleton has " +
                    U.length +
                    " bones. This GPU supports " +
                    b +
                    "."
                ),
                0)
              : b;
          }
        }
        function g(y) {
          let C;
          return (
            y && y.isTexture
              ? (C = y.encoding)
              : y && y.isWebGLRenderTarget
              ? (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (C = y.texture.encoding))
              : (C = Wo),
            C
          );
        }
        function x(y, C, U, K, X) {
          const b = K.fog,
            D = y.isMeshStandardMaterial ? K.environment : null,
            I = e.get(y.envMap || D),
            L = f[y.type],
            B = X.isSkinnedMesh ? p(X) : 0;
          y.precision !== null &&
            ((d = n.getMaxPrecision(y.precision)),
            d !== y.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                y.precision,
                "not supported, using",
                d,
                "instead."
              ));
          let R, V;
          if (L) {
            const ie = Hn[L];
            (R = ie.vertexShader), (V = ie.fragmentShader);
          } else (R = y.vertexShader), (V = y.fragmentShader);
          const H = s.getRenderTarget();
          return {
            isWebGL2: a,
            shaderID: L,
            shaderName: y.type,
            vertexShader: R,
            fragmentShader: V,
            defines: y.defines,
            isRawShaderMaterial: y.isRawShaderMaterial === !0,
            glslVersion: y.glslVersion,
            precision: d,
            instancing: X.isInstancedMesh === !0,
            instancingColor:
              X.isInstancedMesh === !0 && X.instanceColor !== null,
            supportsVertexTextures: u,
            outputEncoding: H !== null ? g(H.texture) : s.outputEncoding,
            map: !!y.map,
            mapEncoding: g(y.map),
            matcap: !!y.matcap,
            matcapEncoding: g(y.matcap),
            envMap: !!I,
            envMapMode: I && I.mapping,
            envMapEncoding: g(I),
            envMapCubeUV: !!I && (I.mapping === kh || I.mapping === Wh),
            lightMap: !!y.lightMap,
            lightMapEncoding: g(y.lightMap),
            aoMap: !!y.aoMap,
            emissiveMap: !!y.emissiveMap,
            emissiveMapEncoding: g(y.emissiveMap),
            bumpMap: !!y.bumpMap,
            normalMap: !!y.normalMap,
            objectSpaceNormalMap: y.normalMapType === A_,
            tangentSpaceNormalMap: y.normalMapType === sr,
            clearcoatMap: !!y.clearcoatMap,
            clearcoatRoughnessMap: !!y.clearcoatRoughnessMap,
            clearcoatNormalMap: !!y.clearcoatNormalMap,
            displacementMap: !!y.displacementMap,
            roughnessMap: !!y.roughnessMap,
            metalnessMap: !!y.metalnessMap,
            specularMap: !!y.specularMap,
            alphaMap: !!y.alphaMap,
            gradientMap: !!y.gradientMap,
            sheen: !!y.sheen,
            transmission: !!y.transmission,
            transmissionMap: !!y.transmissionMap,
            thicknessMap: !!y.thicknessMap,
            combine: y.combine,
            vertexTangents: y.normalMap && y.vertexTangents,
            vertexColors: y.vertexColors,
            vertexAlphas:
              y.vertexColors === !0 &&
              X.geometry &&
              X.geometry.attributes.color &&
              X.geometry.attributes.color.itemSize === 4,
            vertexUvs:
              !!y.map ||
              !!y.bumpMap ||
              !!y.normalMap ||
              !!y.specularMap ||
              !!y.alphaMap ||
              !!y.emissiveMap ||
              !!y.roughnessMap ||
              !!y.metalnessMap ||
              !!y.clearcoatMap ||
              !!y.clearcoatRoughnessMap ||
              !!y.clearcoatNormalMap ||
              !!y.displacementMap ||
              !!y.transmission ||
              !!y.transmissionMap ||
              !!y.thicknessMap,
            uvsVertexOnly:
              !(
                !!y.map ||
                !!y.bumpMap ||
                !!y.normalMap ||
                !!y.specularMap ||
                !!y.alphaMap ||
                !!y.emissiveMap ||
                !!y.roughnessMap ||
                !!y.metalnessMap ||
                !!y.clearcoatNormalMap ||
                !!y.transmission ||
                !!y.transmissionMap ||
                !!y.thicknessMap
              ) && !!y.displacementMap,
            fog: !!b,
            useFog: y.fog,
            fogExp2: b && b.isFogExp2,
            flatShading: !!y.flatShading,
            sizeAttenuation: y.sizeAttenuation,
            logarithmicDepthBuffer: l,
            skinning: X.isSkinnedMesh === !0 && B > 0,
            maxBones: B,
            useVertexTexture: c,
            morphTargets: y.morphTargets,
            morphNormals: y.morphNormals,
            numDirLights: C.directional.length,
            numPointLights: C.point.length,
            numSpotLights: C.spot.length,
            numRectAreaLights: C.rectArea.length,
            numHemiLights: C.hemi.length,
            numDirLightShadows: C.directionalShadowMap.length,
            numPointLightShadows: C.pointShadowMap.length,
            numSpotLightShadows: C.spotShadowMap.length,
            numClippingPlanes: r.numPlanes,
            numClipIntersection: r.numIntersection,
            dithering: y.dithering,
            shadowMapEnabled: s.shadowMap.enabled && U.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: y.toneMapped ? s.toneMapping : go,
            physicallyCorrectLights: s.physicallyCorrectLights,
            premultipliedAlpha: y.premultipliedAlpha,
            alphaTest: y.alphaTest,
            doubleSided: y.side === ko,
            flipSided: y.side === Rt,
            depthPacking: y.depthPacking !== void 0 ? y.depthPacking : !1,
            index0AttributeName: y.index0AttributeName,
            extensionDerivatives: y.extensions && y.extensions.derivatives,
            extensionFragDepth: y.extensions && y.extensions.fragDepth,
            extensionDrawBuffers: y.extensions && y.extensions.drawBuffers,
            extensionShaderTextureLOD:
              y.extensions && y.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: a || t.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: a || t.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              a || t.has("EXT_shader_texture_lod"),
            customProgramCacheKey: y.customProgramCacheKey(),
          };
        }
        function _(y) {
          const C = [];
          if (
            (y.shaderID
              ? C.push(y.shaderID)
              : (C.push(y.fragmentShader), C.push(y.vertexShader)),
            y.defines !== void 0)
          )
            for (const U in y.defines) C.push(U), C.push(y.defines[U]);
          if (y.isRawShaderMaterial === !1) {
            for (let U = 0; U < m.length; U++) C.push(y[m[U]]);
            C.push(s.outputEncoding), C.push(s.gammaFactor);
          }
          return C.push(y.customProgramCacheKey), C.join();
        }
        function M(y) {
          const C = f[y.type];
          let U;
          if (C) {
            const K = Hn[C];
            U = ov.clone(K.uniforms);
          } else U = y.uniforms;
          return U;
        }
        function S(y, C) {
          let U;
          for (let K = 0, X = o.length; K < X; K++) {
            const b = o[K];
            if (b.cacheKey === C) {
              (U = b), ++U.usedTimes;
              break;
            }
          }
          return U === void 0 && ((U = new ZM(s, C, y, i)), o.push(U)), U;
        }
        function v(y) {
          if (--y.usedTimes === 0) {
            const C = o.indexOf(y);
            (o[C] = o[o.length - 1]), o.pop(), y.destroy();
          }
        }
        return {
          getParameters: x,
          getProgramCacheKey: _,
          getUniforms: M,
          acquireProgram: S,
          releaseProgram: v,
          programs: o,
        };
      }
      function KM() {
        let s = new WeakMap();
        function e(r) {
          let o = s.get(r);
          return o === void 0 && ((o = {}), s.set(r, o)), o;
        }
        function t(r) {
          s.delete(r);
        }
        function n(r, o, a) {
          s.get(r)[o] = a;
        }
        function i() {
          s = new WeakMap();
        }
        return { get: e, remove: t, update: n, dispose: i };
      }
      function QM(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.program !== e.program
          ? s.program.id - e.program.id
          : s.material.id !== e.material.id
          ? s.material.id - e.material.id
          : s.z !== e.z
          ? s.z - e.z
          : s.id - e.id;
      }
      function Ld(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.z !== e.z
          ? e.z - s.z
          : s.id - e.id;
      }
      function Rd(s) {
        const e = [];
        let t = 0;
        const n = [],
          i = [],
          r = [],
          o = { id: -1 };
        function a() {
          (t = 0), (n.length = 0), (i.length = 0), (r.length = 0);
        }
        function l(f, m, p, g, x, _) {
          let M = e[t];
          const S = s.get(p);
          return (
            M === void 0
              ? ((M = {
                  id: f.id,
                  object: f,
                  geometry: m,
                  material: p,
                  program: S.program || o,
                  groupOrder: g,
                  renderOrder: f.renderOrder,
                  z: x,
                  group: _,
                }),
                (e[t] = M))
              : ((M.id = f.id),
                (M.object = f),
                (M.geometry = m),
                (M.material = p),
                (M.program = S.program || o),
                (M.groupOrder = g),
                (M.renderOrder = f.renderOrder),
                (M.z = x),
                (M.group = _)),
            t++,
            M
          );
        }
        function c(f, m, p, g, x, _) {
          const M = l(f, m, p, g, x, _);
          p.transmission > 0
            ? i.push(M)
            : p.transparent === !0
            ? r.push(M)
            : n.push(M);
        }
        function h(f, m, p, g, x, _) {
          const M = l(f, m, p, g, x, _);
          p.transmission > 0
            ? i.unshift(M)
            : p.transparent === !0
            ? r.unshift(M)
            : n.unshift(M);
        }
        function u(f, m) {
          n.length > 1 && n.sort(f || QM),
            i.length > 1 && i.sort(m || Ld),
            r.length > 1 && r.sort(m || Ld);
        }
        function d() {
          for (let f = t, m = e.length; f < m; f++) {
            const p = e[f];
            if (p.id === null) break;
            (p.id = null),
              (p.object = null),
              (p.geometry = null),
              (p.material = null),
              (p.program = null),
              (p.group = null);
          }
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: a,
          push: c,
          unshift: h,
          finish: d,
          sort: u,
        };
      }
      function eb(s) {
        let e = new WeakMap();
        function t(i, r) {
          let o;
          return (
            e.has(i) === !1
              ? ((o = new Rd(s)), e.set(i, [o]))
              : r >= e.get(i).length
              ? ((o = new Rd(s)), e.get(i).push(o))
              : (o = e.get(i)[r]),
            o
          );
        }
        function n() {
          e = new WeakMap();
        }
        return { get: t, dispose: n };
      }
      function tb() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new G(), color: new Ue() };
                break;
              case "SpotLight":
                t = {
                  position: new G(),
                  direction: new G(),
                  color: new Ue(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new G(),
                  color: new Ue(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new G(),
                  skyColor: new Ue(),
                  groundColor: new Ue(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new Ue(),
                  position: new G(),
                  halfWidth: new G(),
                  halfHeight: new G(),
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      function nb() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Se(),
                };
                break;
              case "SpotLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Se(),
                };
                break;
              case "PointLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Se(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      let ib = 0;
      function rb(s, e) {
        return (e.castShadow ? 1 : 0) - (s.castShadow ? 1 : 0);
      }
      function sb(s, e) {
        const t = new tb(),
          n = nb(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let h = 0; h < 9; h++) i.probe.push(new G());
        const r = new G(),
          o = new Ge(),
          a = new Ge();
        function l(h) {
          let u = 0,
            d = 0,
            f = 0;
          for (let C = 0; C < 9; C++) i.probe[C].set(0, 0, 0);
          let m = 0,
            p = 0,
            g = 0,
            x = 0,
            _ = 0,
            M = 0,
            S = 0,
            v = 0;
          h.sort(rb);
          for (let C = 0, U = h.length; C < U; C++) {
            const K = h[C],
              X = K.color,
              b = K.intensity,
              D = K.distance,
              I = K.shadow && K.shadow.map ? K.shadow.map.texture : null;
            if (K.isAmbientLight)
              (u += X.r * b), (d += X.g * b), (f += X.b * b);
            else if (K.isLightProbe)
              for (let L = 0; L < 9; L++)
                i.probe[L].addScaledVector(K.sh.coefficients[L], b);
            else if (K.isDirectionalLight) {
              const L = t.get(K);
              if (
                (L.color.copy(K.color).multiplyScalar(K.intensity),
                K.castShadow)
              ) {
                const B = K.shadow,
                  R = n.get(K);
                (R.shadowBias = B.bias),
                  (R.shadowNormalBias = B.normalBias),
                  (R.shadowRadius = B.radius),
                  (R.shadowMapSize = B.mapSize),
                  (i.directionalShadow[m] = R),
                  (i.directionalShadowMap[m] = I),
                  (i.directionalShadowMatrix[m] = K.shadow.matrix),
                  M++;
              }
              (i.directional[m] = L), m++;
            } else if (K.isSpotLight) {
              const L = t.get(K);
              if (
                (L.position.setFromMatrixPosition(K.matrixWorld),
                L.color.copy(X).multiplyScalar(b),
                (L.distance = D),
                (L.coneCos = Math.cos(K.angle)),
                (L.penumbraCos = Math.cos(K.angle * (1 - K.penumbra))),
                (L.decay = K.decay),
                K.castShadow)
              ) {
                const B = K.shadow,
                  R = n.get(K);
                (R.shadowBias = B.bias),
                  (R.shadowNormalBias = B.normalBias),
                  (R.shadowRadius = B.radius),
                  (R.shadowMapSize = B.mapSize),
                  (i.spotShadow[g] = R),
                  (i.spotShadowMap[g] = I),
                  (i.spotShadowMatrix[g] = K.shadow.matrix),
                  v++;
              }
              (i.spot[g] = L), g++;
            } else if (K.isRectAreaLight) {
              const L = t.get(K);
              L.color.copy(X).multiplyScalar(b),
                L.halfWidth.set(K.width * 0.5, 0, 0),
                L.halfHeight.set(0, K.height * 0.5, 0),
                (i.rectArea[x] = L),
                x++;
            } else if (K.isPointLight) {
              const L = t.get(K);
              if (
                (L.color.copy(K.color).multiplyScalar(K.intensity),
                (L.distance = K.distance),
                (L.decay = K.decay),
                K.castShadow)
              ) {
                const B = K.shadow,
                  R = n.get(K);
                (R.shadowBias = B.bias),
                  (R.shadowNormalBias = B.normalBias),
                  (R.shadowRadius = B.radius),
                  (R.shadowMapSize = B.mapSize),
                  (R.shadowCameraNear = B.camera.near),
                  (R.shadowCameraFar = B.camera.far),
                  (i.pointShadow[p] = R),
                  (i.pointShadowMap[p] = I),
                  (i.pointShadowMatrix[p] = K.shadow.matrix),
                  S++;
              }
              (i.point[p] = L), p++;
            } else if (K.isHemisphereLight) {
              const L = t.get(K);
              L.skyColor.copy(K.color).multiplyScalar(b),
                L.groundColor.copy(K.groundColor).multiplyScalar(b),
                (i.hemi[_] = L),
                _++;
            }
          }
          x > 0 &&
            (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = Pe.LTC_FLOAT_1),
                (i.rectAreaLTC2 = Pe.LTC_FLOAT_2))
              : s.has("OES_texture_half_float_linear") === !0
              ? ((i.rectAreaLTC1 = Pe.LTC_HALF_1),
                (i.rectAreaLTC2 = Pe.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = u),
            (i.ambient[1] = d),
            (i.ambient[2] = f);
          const y = i.hash;
          (y.directionalLength !== m ||
            y.pointLength !== p ||
            y.spotLength !== g ||
            y.rectAreaLength !== x ||
            y.hemiLength !== _ ||
            y.numDirectionalShadows !== M ||
            y.numPointShadows !== S ||
            y.numSpotShadows !== v) &&
            ((i.directional.length = m),
            (i.spot.length = g),
            (i.rectArea.length = x),
            (i.point.length = p),
            (i.hemi.length = _),
            (i.directionalShadow.length = M),
            (i.directionalShadowMap.length = M),
            (i.pointShadow.length = S),
            (i.pointShadowMap.length = S),
            (i.spotShadow.length = v),
            (i.spotShadowMap.length = v),
            (i.directionalShadowMatrix.length = M),
            (i.pointShadowMatrix.length = S),
            (i.spotShadowMatrix.length = v),
            (y.directionalLength = m),
            (y.pointLength = p),
            (y.spotLength = g),
            (y.rectAreaLength = x),
            (y.hemiLength = _),
            (y.numDirectionalShadows = M),
            (y.numPointShadows = S),
            (y.numSpotShadows = v),
            (i.version = ib++));
        }
        function c(h, u) {
          let d = 0,
            f = 0,
            m = 0,
            p = 0,
            g = 0;
          const x = u.matrixWorldInverse;
          for (let _ = 0, M = h.length; _ < M; _++) {
            const S = h[_];
            if (S.isDirectionalLight) {
              const v = i.directional[d];
              v.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                v.direction.sub(r),
                v.direction.transformDirection(x),
                d++;
            } else if (S.isSpotLight) {
              const v = i.spot[m];
              v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(x),
                v.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                v.direction.sub(r),
                v.direction.transformDirection(x),
                m++;
            } else if (S.isRectAreaLight) {
              const v = i.rectArea[p];
              v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(x),
                a.identity(),
                o.copy(S.matrixWorld),
                o.premultiply(x),
                a.extractRotation(o),
                v.halfWidth.set(S.width * 0.5, 0, 0),
                v.halfHeight.set(0, S.height * 0.5, 0),
                v.halfWidth.applyMatrix4(a),
                v.halfHeight.applyMatrix4(a),
                p++;
            } else if (S.isPointLight) {
              const v = i.point[f];
              v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(x),
                f++;
            } else if (S.isHemisphereLight) {
              const v = i.hemi[g];
              v.direction.setFromMatrixPosition(S.matrixWorld),
                v.direction.transformDirection(x),
                v.direction.normalize(),
                g++;
            }
          }
        }
        return { setup: l, setupView: c, state: i };
      }
      function Cd(s, e) {
        const t = new sb(s, e),
          n = [],
          i = [];
        function r() {
          (n.length = 0), (i.length = 0);
        }
        function o(u) {
          n.push(u);
        }
        function a(u) {
          i.push(u);
        }
        function l() {
          t.setup(n);
        }
        function c(u) {
          t.setupView(n, u);
        }
        return {
          init: r,
          state: { lightsArray: n, shadowsArray: i, lights: t },
          setupLights: l,
          setupLightsView: c,
          pushLight: o,
          pushShadow: a,
        };
      }
      function ob(s, e) {
        let t = new WeakMap();
        function n(r, o = 0) {
          let a;
          return (
            t.has(r) === !1
              ? ((a = new Cd(s, e)), t.set(r, [a]))
              : o >= t.get(r).length
              ? ((a = new Cd(s, e)), t.get(r).push(a))
              : (a = t.get(r)[o]),
            a
          );
        }
        function i() {
          t = new WeakMap();
        }
        return { get: n, dispose: i };
      }
      class gm extends It {
        constructor(e) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = T_),
            (this.morphTargets = !1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      gm.prototype.isMeshDepthMaterial = !0;
      class xm extends It {
        constructor(e) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new G()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.morphTargets = !1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      xm.prototype.isMeshDistanceMaterial = !0;
      var ab = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,
        lb = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
      function _m(s, e, t) {
        let n = new bl();
        const i = new Se(),
          r = new Se(),
          o = new rt(),
          a = [],
          l = [],
          c = {},
          h = t.maxTextureSize,
          u = { 0: Rt, 1: So, 2: ko },
          d = new ir({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Se() },
              radius: { value: 4 },
            },
            vertexShader: lb,
            fragmentShader: ab,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const m = new ut();
        m.setAttribute(
          "position",
          new bt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const p = new vn(m, d),
          g = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = $p),
          (this.render = function (y, C, U) {
            if (
              g.enabled === !1 ||
              (g.autoUpdate === !1 && g.needsUpdate === !1) ||
              y.length === 0
            )
              return;
            const K = s.getRenderTarget(),
              X = s.getActiveCubeFace(),
              b = s.getActiveMipmapLevel(),
              D = s.state;
            D.setBlending(po),
              D.buffers.color.setClear(1, 1, 1, 1),
              D.buffers.depth.setTest(!0),
              D.setScissorTest(!1);
            for (let I = 0, L = y.length; I < L; I++) {
              const B = y[I],
                R = B.shadow;
              if (R === void 0) {
                console.warn("THREE.WebGLShadowMap:", B, "has no shadow.");
                continue;
              }
              if (R.autoUpdate === !1 && R.needsUpdate === !1) continue;
              i.copy(R.mapSize);
              const V = R.getFrameExtents();
              if (
                (i.multiply(V),
                r.copy(R.mapSize),
                (i.x > h || i.y > h) &&
                  (i.x > h &&
                    ((r.x = Math.floor(h / V.x)),
                    (i.x = r.x * V.x),
                    (R.mapSize.x = r.x)),
                  i.y > h &&
                    ((r.y = Math.floor(h / V.y)),
                    (i.y = r.y * V.y),
                    (R.mapSize.y = r.y))),
                R.map === null && !R.isPointLightShadow && this.type === lo)
              ) {
                const J = { minFilter: sn, magFilter: sn, format: In };
                (R.map = new ai(i.x, i.y, J)),
                  (R.map.texture.name = B.name + ".shadowMap"),
                  (R.mapPass = new ai(i.x, i.y, J)),
                  R.camera.updateProjectionMatrix();
              }
              if (R.map === null) {
                const J = { minFilter: zt, magFilter: zt, format: In };
                (R.map = new ai(i.x, i.y, J)),
                  (R.map.texture.name = B.name + ".shadowMap"),
                  R.camera.updateProjectionMatrix();
              }
              s.setRenderTarget(R.map), s.clear();
              const H = R.getViewportCount();
              for (let J = 0; J < H; J++) {
                const ie = R.getViewport(J);
                o.set(r.x * ie.x, r.y * ie.y, r.x * ie.z, r.y * ie.w),
                  D.viewport(o),
                  R.updateMatrices(B, J),
                  (n = R.getFrustum()),
                  v(C, U, R.camera, B, this.type);
              }
              !R.isPointLightShadow && this.type === lo && x(R, U),
                (R.needsUpdate = !1);
            }
            (g.needsUpdate = !1), s.setRenderTarget(K, X, b);
          });
        function x(y, C) {
          const U = e.update(p);
          (d.uniforms.shadow_pass.value = y.map.texture),
            (d.uniforms.resolution.value = y.mapSize),
            (d.uniforms.radius.value = y.radius),
            s.setRenderTarget(y.mapPass),
            s.clear(),
            s.renderBufferDirect(C, null, U, d, p, null),
            (f.uniforms.shadow_pass.value = y.mapPass.texture),
            (f.uniforms.resolution.value = y.mapSize),
            (f.uniforms.radius.value = y.radius),
            s.setRenderTarget(y.map),
            s.clear(),
            s.renderBufferDirect(C, null, U, f, p, null);
        }
        function _(y) {
          const C = y << 0;
          let U = a[C];
          return (
            U === void 0 &&
              ((U = new gm({ depthPacking: E_, morphTargets: y })), (a[C] = U)),
            U
          );
        }
        function M(y) {
          const C = y << 0;
          let U = l[C];
          return (
            U === void 0 && ((U = new xm({ morphTargets: y })), (l[C] = U)), U
          );
        }
        function S(y, C, U, K, X, b, D) {
          let I = null,
            L = _,
            B = y.customDepthMaterial;
          if (
            (K.isPointLight === !0 && ((L = M), (B = y.customDistanceMaterial)),
            B === void 0)
          ) {
            let R = !1;
            U.morphTargets === !0 &&
              (R =
                C.morphAttributes &&
                C.morphAttributes.position &&
                C.morphAttributes.position.length > 0),
              (I = L(R));
          } else I = B;
          if (
            s.localClippingEnabled &&
            U.clipShadows === !0 &&
            U.clippingPlanes.length !== 0
          ) {
            const R = I.uuid,
              V = U.uuid;
            let H = c[R];
            H === void 0 && ((H = {}), (c[R] = H));
            let J = H[V];
            J === void 0 && ((J = I.clone()), (H[V] = J)), (I = J);
          }
          return (
            (I.visible = U.visible),
            (I.wireframe = U.wireframe),
            D === lo
              ? (I.side = U.shadowSide !== null ? U.shadowSide : U.side)
              : (I.side = U.shadowSide !== null ? U.shadowSide : u[U.side]),
            (I.clipShadows = U.clipShadows),
            (I.clippingPlanes = U.clippingPlanes),
            (I.clipIntersection = U.clipIntersection),
            (I.wireframeLinewidth = U.wireframeLinewidth),
            (I.linewidth = U.linewidth),
            K.isPointLight === !0 &&
              I.isMeshDistanceMaterial === !0 &&
              (I.referencePosition.setFromMatrixPosition(K.matrixWorld),
              (I.nearDistance = X),
              (I.farDistance = b)),
            I
          );
        }
        function v(y, C, U, K, X) {
          if (y.visible === !1) return;
          if (
            y.layers.test(C.layers) &&
            (y.isMesh || y.isLine || y.isPoints) &&
            (y.castShadow || (y.receiveShadow && X === lo)) &&
            (!y.frustumCulled || n.intersectsObject(y))
          ) {
            y.modelViewMatrix.multiplyMatrices(
              U.matrixWorldInverse,
              y.matrixWorld
            );
            const I = e.update(y),
              L = y.material;
            if (Array.isArray(L)) {
              const B = I.groups;
              for (let R = 0, V = B.length; R < V; R++) {
                const H = B[R],
                  J = L[H.materialIndex];
                if (J && J.visible) {
                  const ie = S(y, I, J, K, U.near, U.far, X);
                  s.renderBufferDirect(U, null, I, ie, y, H);
                }
              }
            } else if (L.visible) {
              const B = S(y, I, L, K, U.near, U.far, X);
              s.renderBufferDirect(U, null, I, B, y, null);
            }
          }
          const D = y.children;
          for (let I = 0, L = D.length; I < L; I++) v(D[I], C, U, K, X);
        }
      }
      function cb(s, e, t) {
        const n = t.isWebGL2;
        function i() {
          let O = !1;
          const le = new rt();
          let k = null;
          const ge = new rt(0, 0, 0, 0);
          return {
            setMask: function (pe) {
              k !== pe && !O && (s.colorMask(pe, pe, pe, pe), (k = pe));
            },
            setLocked: function (pe) {
              O = pe;
            },
            setClear: function (pe, be, Y, _e, we) {
              we === !0 && ((pe *= _e), (be *= _e), (Y *= _e)),
                le.set(pe, be, Y, _e),
                ge.equals(le) === !1 &&
                  (s.clearColor(pe, be, Y, _e), ge.copy(le));
            },
            reset: function () {
              (O = !1), (k = null), ge.set(-1, 0, 0, 0);
            },
          };
        }
        function r() {
          let O = !1,
            le = null,
            k = null,
            ge = null;
          return {
            setTest: function (pe) {
              pe ? Fe(2929) : Ee(2929);
            },
            setMask: function (pe) {
              le !== pe && !O && (s.depthMask(pe), (le = pe));
            },
            setFunc: function (pe) {
              if (k !== pe) {
                if (pe)
                  switch (pe) {
                    case cx:
                      s.depthFunc(512);
                      break;
                    case hx:
                      s.depthFunc(519);
                      break;
                    case ux:
                      s.depthFunc(513);
                      break;
                    case ph:
                      s.depthFunc(515);
                      break;
                    case dx:
                      s.depthFunc(514);
                      break;
                    case fx:
                      s.depthFunc(518);
                      break;
                    case px:
                      s.depthFunc(516);
                      break;
                    case mx:
                      s.depthFunc(517);
                      break;
                    default:
                      s.depthFunc(515);
                  }
                else s.depthFunc(515);
                k = pe;
              }
            },
            setLocked: function (pe) {
              O = pe;
            },
            setClear: function (pe) {
              ge !== pe && (s.clearDepth(pe), (ge = pe));
            },
            reset: function () {
              (O = !1), (le = null), (k = null), (ge = null);
            },
          };
        }
        function o() {
          let O = !1,
            le = null,
            k = null,
            ge = null,
            pe = null,
            be = null,
            Y = null,
            _e = null,
            we = null;
          return {
            setTest: function (Be) {
              O || (Be ? Fe(2960) : Ee(2960));
            },
            setMask: function (Be) {
              le !== Be && !O && (s.stencilMask(Be), (le = Be));
            },
            setFunc: function (Be, Ne, He) {
              (k !== Be || ge !== Ne || pe !== He) &&
                (s.stencilFunc(Be, Ne, He), (k = Be), (ge = Ne), (pe = He));
            },
            setOp: function (Be, Ne, He) {
              (be !== Be || Y !== Ne || _e !== He) &&
                (s.stencilOp(Be, Ne, He), (be = Be), (Y = Ne), (_e = He));
            },
            setLocked: function (Be) {
              O = Be;
            },
            setClear: function (Be) {
              we !== Be && (s.clearStencil(Be), (we = Be));
            },
            reset: function () {
              (O = !1),
                (le = null),
                (k = null),
                (ge = null),
                (pe = null),
                (be = null),
                (Y = null),
                (_e = null),
                (we = null);
            },
          };
        }
        const a = new i(),
          l = new r(),
          c = new o();
        let h = {},
          u = null,
          d = {},
          f = null,
          m = !1,
          p = null,
          g = null,
          x = null,
          _ = null,
          M = null,
          S = null,
          v = null,
          y = !1,
          C = null,
          U = null,
          K = null,
          X = null,
          b = null;
        const D = s.getParameter(35661);
        let I = !1,
          L = 0;
        const B = s.getParameter(7938);
        B.indexOf("WebGL") !== -1
          ? ((L = parseFloat(/^WebGL (\d)/.exec(B)[1])), (I = L >= 1))
          : B.indexOf("OpenGL ES") !== -1 &&
            ((L = parseFloat(/^OpenGL ES (\d)/.exec(B)[1])), (I = L >= 2));
        let R = null,
          V = {};
        const H = s.getParameter(3088),
          J = s.getParameter(2978),
          ie = new rt().fromArray(H),
          ne = new rt().fromArray(J);
        function ae(O, le, k) {
          const ge = new Uint8Array(4),
            pe = s.createTexture();
          s.bindTexture(O, pe),
            s.texParameteri(O, 10241, 9728),
            s.texParameteri(O, 10240, 9728);
          for (let be = 0; be < k; be++)
            s.texImage2D(le + be, 0, 6408, 1, 1, 0, 6408, 5121, ge);
          return pe;
        }
        const fe = {};
        (fe[3553] = ae(3553, 3553, 1)),
          (fe[34067] = ae(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          Fe(2929),
          l.setFunc(ph),
          Z(!1),
          te(Hu),
          Fe(2884),
          Ie(po);
        function Fe(O) {
          h[O] !== !0 && (s.enable(O), (h[O] = !0));
        }
        function Ee(O) {
          h[O] !== !1 && (s.disable(O), (h[O] = !1));
        }
        function $(O) {
          O !== u && (s.bindFramebuffer(36160, O), (u = O));
        }
        function ke(O, le) {
          return (
            le === null && u !== null && (le = u),
            d[O] !== le
              ? (s.bindFramebuffer(O, le),
                (d[O] = le),
                n &&
                  (O === 36009 && (d[36160] = le),
                  O === 36160 && (d[36009] = le)),
                !0)
              : !1
          );
        }
        function Re(O) {
          return f !== O ? (s.useProgram(O), (f = O), !0) : !1;
        }
        const Te = { [jr]: 32774, [Kg]: 32778, [Qg]: 32779 };
        if (n) (Te[Wu] = 32775), (Te[$u] = 32776);
        else {
          const O = e.get("EXT_blend_minmax");
          O !== null && ((Te[Wu] = O.MIN_EXT), (Te[$u] = O.MAX_EXT));
        }
        const ce = {
          [ex]: 0,
          [tx]: 1,
          [nx]: 768,
          [Xp]: 770,
          [lx]: 776,
          [ox]: 774,
          [rx]: 772,
          [ix]: 769,
          [jp]: 771,
          [ax]: 775,
          [sx]: 773,
        };
        function Ie(O, le, k, ge, pe, be, Y, _e) {
          if (O === po) {
            m === !0 && (Ee(3042), (m = !1));
            return;
          }
          if ((m === !1 && (Fe(3042), (m = !0)), O !== Jg)) {
            if (O !== p || _e !== y) {
              if (
                ((g !== jr || M !== jr) &&
                  (s.blendEquation(32774), (g = jr), (M = jr)),
                _e)
              )
                switch (O) {
                  case mo:
                    s.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case Gu:
                    s.blendFunc(1, 1);
                    break;
                  case Vu:
                    s.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case ku:
                    s.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", O);
                    break;
                }
              else
                switch (O) {
                  case mo:
                    s.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case Gu:
                    s.blendFunc(770, 1);
                    break;
                  case Vu:
                    s.blendFunc(0, 769);
                    break;
                  case ku:
                    s.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", O);
                    break;
                }
              (x = null), (_ = null), (S = null), (v = null), (p = O), (y = _e);
            }
            return;
          }
          (pe = pe || le),
            (be = be || k),
            (Y = Y || ge),
            (le !== g || pe !== M) &&
              (s.blendEquationSeparate(Te[le], Te[pe]), (g = le), (M = pe)),
            (k !== x || ge !== _ || be !== S || Y !== v) &&
              (s.blendFuncSeparate(ce[k], ce[ge], ce[be], ce[Y]),
              (x = k),
              (_ = ge),
              (S = be),
              (v = Y)),
            (p = O),
            (y = null);
        }
        function j(O, le) {
          O.side === ko ? Ee(2884) : Fe(2884);
          let k = O.side === Rt;
          le && (k = !k),
            Z(k),
            O.blending === mo && O.transparent === !1
              ? Ie(po)
              : Ie(
                  O.blending,
                  O.blendEquation,
                  O.blendSrc,
                  O.blendDst,
                  O.blendEquationAlpha,
                  O.blendSrcAlpha,
                  O.blendDstAlpha,
                  O.premultipliedAlpha
                ),
            l.setFunc(O.depthFunc),
            l.setTest(O.depthTest),
            l.setMask(O.depthWrite),
            a.setMask(O.colorWrite);
          const ge = O.stencilWrite;
          c.setTest(ge),
            ge &&
              (c.setMask(O.stencilWriteMask),
              c.setFunc(O.stencilFunc, O.stencilRef, O.stencilFuncMask),
              c.setOp(O.stencilFail, O.stencilZFail, O.stencilZPass)),
            se(O.polygonOffset, O.polygonOffsetFactor, O.polygonOffsetUnits),
            O.alphaToCoverage === !0 ? Fe(32926) : Ee(32926);
        }
        function Z(O) {
          C !== O && (O ? s.frontFace(2304) : s.frontFace(2305), (C = O));
        }
        function te(O) {
          O !== jg
            ? (Fe(2884),
              O !== U &&
                (O === Hu
                  ? s.cullFace(1029)
                  : O === Yg
                  ? s.cullFace(1028)
                  : s.cullFace(1032)))
            : Ee(2884),
            (U = O);
        }
        function de(O) {
          O !== K && (I && s.lineWidth(O), (K = O));
        }
        function se(O, le, k) {
          O
            ? (Fe(32823),
              (X !== le || b !== k) &&
                (s.polygonOffset(le, k), (X = le), (b = k)))
            : Ee(32823);
        }
        function N(O) {
          O ? Fe(3089) : Ee(3089);
        }
        function E(O) {
          O === void 0 && (O = 33984 + D - 1),
            R !== O && (s.activeTexture(O), (R = O));
        }
        function ee(O, le) {
          R === null && E();
          let k = V[R];
          k === void 0 && ((k = { type: void 0, texture: void 0 }), (V[R] = k)),
            (k.type !== O || k.texture !== le) &&
              (s.bindTexture(O, le || fe[O]), (k.type = O), (k.texture = le));
        }
        function ue() {
          const O = V[R];
          O !== void 0 &&
            O.type !== void 0 &&
            (s.bindTexture(O.type, null),
            (O.type = void 0),
            (O.texture = void 0));
        }
        function me() {
          try {
            s.compressedTexImage2D.apply(s, arguments);
          } catch (O) {
            console.error("THREE.WebGLState:", O);
          }
        }
        function A() {
          try {
            s.texImage2D.apply(s, arguments);
          } catch (O) {
            console.error("THREE.WebGLState:", O);
          }
        }
        function T() {
          try {
            s.texImage3D.apply(s, arguments);
          } catch (O) {
            console.error("THREE.WebGLState:", O);
          }
        }
        function Q(O) {
          ie.equals(O) === !1 && (s.scissor(O.x, O.y, O.z, O.w), ie.copy(O));
        }
        function oe(O) {
          ne.equals(O) === !1 && (s.viewport(O.x, O.y, O.z, O.w), ne.copy(O));
        }
        function he() {
          s.disable(3042),
            s.disable(2884),
            s.disable(2929),
            s.disable(32823),
            s.disable(3089),
            s.disable(2960),
            s.disable(32926),
            s.blendEquation(32774),
            s.blendFunc(1, 0),
            s.blendFuncSeparate(1, 0, 1, 0),
            s.colorMask(!0, !0, !0, !0),
            s.clearColor(0, 0, 0, 0),
            s.depthMask(!0),
            s.depthFunc(513),
            s.clearDepth(1),
            s.stencilMask(4294967295),
            s.stencilFunc(519, 0, 4294967295),
            s.stencilOp(7680, 7680, 7680),
            s.clearStencil(0),
            s.cullFace(1029),
            s.frontFace(2305),
            s.polygonOffset(0, 0),
            s.activeTexture(33984),
            s.bindFramebuffer(36160, null),
            n === !0 &&
              (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)),
            s.useProgram(null),
            s.lineWidth(1),
            s.scissor(0, 0, s.canvas.width, s.canvas.height),
            s.viewport(0, 0, s.canvas.width, s.canvas.height),
            (h = {}),
            (R = null),
            (V = {}),
            (u = null),
            (d = {}),
            (f = null),
            (m = !1),
            (p = null),
            (g = null),
            (x = null),
            (_ = null),
            (M = null),
            (S = null),
            (v = null),
            (y = !1),
            (C = null),
            (U = null),
            (K = null),
            (X = null),
            (b = null),
            ie.set(0, 0, s.canvas.width, s.canvas.height),
            ne.set(0, 0, s.canvas.width, s.canvas.height),
            a.reset(),
            l.reset(),
            c.reset();
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: Fe,
          disable: Ee,
          bindFramebuffer: ke,
          bindXRFramebuffer: $,
          useProgram: Re,
          setBlending: Ie,
          setMaterial: j,
          setFlipSided: Z,
          setCullFace: te,
          setLineWidth: de,
          setPolygonOffset: se,
          setScissorTest: N,
          activeTexture: E,
          bindTexture: ee,
          unbindTexture: ue,
          compressedTexImage2D: me,
          texImage2D: A,
          texImage3D: T,
          scissor: Q,
          viewport: oe,
          reset: he,
        };
      }
      function hb(s, e, t, n, i, r, o) {
        const a = i.isWebGL2,
          l = i.maxTextures,
          c = i.maxCubemapSize,
          h = i.maxTextureSize,
          u = i.maxSamples,
          d = new WeakMap();
        let f,
          m = !1;
        try {
          m =
            typeof OffscreenCanvas != "undefined" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function p(N, E) {
          return m
            ? new OffscreenCanvas(N, E)
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
        }
        function g(N, E, ee, ue) {
          let me = 1;
          if (
            ((N.width > ue || N.height > ue) &&
              (me = ue / Math.max(N.width, N.height)),
            me < 1 || E === !0)
          )
            if (
              (typeof HTMLImageElement != "undefined" &&
                N instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement != "undefined" &&
                N instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap != "undefined" && N instanceof ImageBitmap)
            ) {
              const A = E ? em : Math.floor,
                T = A(me * N.width),
                Q = A(me * N.height);
              f === void 0 && (f = p(T, Q));
              const oe = ee ? p(T, Q) : f;
              return (
                (oe.width = T),
                (oe.height = Q),
                oe.getContext("2d").drawImage(N, 0, 0, T, Q),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    N.width +
                    "x" +
                    N.height +
                    ") to (" +
                    T +
                    "x" +
                    Q +
                    ")."
                ),
                oe
              );
            } else
              return (
                "data" in N &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      N.width +
                      "x" +
                      N.height +
                      ")."
                  ),
                N
              );
          return N;
        }
        function x(N) {
          return xh(N.width) && xh(N.height);
        }
        function _(N) {
          return a
            ? !1
            : N.wrapS !== rn ||
                N.wrapT !== rn ||
                (N.minFilter !== zt && N.minFilter !== sn);
        }
        function M(N, E) {
          return (
            N.generateMipmaps && E && N.minFilter !== zt && N.minFilter !== sn
          );
        }
        function S(N, E, ee, ue) {
          s.generateMipmap(N);
          const me = n.get(E);
          me.__maxMipLevel = Math.log2(Math.max(ee, ue));
        }
        function v(N, E, ee) {
          if (a === !1) return E;
          if (N !== null) {
            if (s[N] !== void 0) return s[N];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                N +
                "'"
            );
          }
          let ue = E;
          return (
            E === 6403 &&
              (ee === 5126 && (ue = 33326),
              ee === 5131 && (ue = 33325),
              ee === 5121 && (ue = 33321)),
            E === 6407 &&
              (ee === 5126 && (ue = 34837),
              ee === 5131 && (ue = 34843),
              ee === 5121 && (ue = 32849)),
            E === 6408 &&
              (ee === 5126 && (ue = 34836),
              ee === 5131 && (ue = 34842),
              ee === 5121 && (ue = 32856)),
            (ue === 33325 || ue === 33326 || ue === 34842 || ue === 34836) &&
              e.get("EXT_color_buffer_float"),
            ue
          );
        }
        function y(N) {
          return N === zt || N === mh || N === gh ? 9728 : 9729;
        }
        function C(N) {
          const E = N.target;
          E.removeEventListener("dispose", C),
            K(E),
            E.isVideoTexture && d.delete(E),
            o.memory.textures--;
        }
        function U(N) {
          const E = N.target;
          E.removeEventListener("dispose", U), X(E);
        }
        function K(N) {
          const E = n.get(N);
          E.__webglInit !== void 0 &&
            (s.deleteTexture(E.__webglTexture), n.remove(N));
        }
        function X(N) {
          const E = N.texture,
            ee = n.get(N),
            ue = n.get(E);
          if (!!N) {
            if (
              (ue.__webglTexture !== void 0 &&
                (s.deleteTexture(ue.__webglTexture), o.memory.textures--),
              N.depthTexture && N.depthTexture.dispose(),
              N.isWebGLCubeRenderTarget)
            )
              for (let me = 0; me < 6; me++)
                s.deleteFramebuffer(ee.__webglFramebuffer[me]),
                  ee.__webglDepthbuffer &&
                    s.deleteRenderbuffer(ee.__webglDepthbuffer[me]);
            else
              s.deleteFramebuffer(ee.__webglFramebuffer),
                ee.__webglDepthbuffer &&
                  s.deleteRenderbuffer(ee.__webglDepthbuffer),
                ee.__webglMultisampledFramebuffer &&
                  s.deleteFramebuffer(ee.__webglMultisampledFramebuffer),
                ee.__webglColorRenderbuffer &&
                  s.deleteRenderbuffer(ee.__webglColorRenderbuffer),
                ee.__webglDepthRenderbuffer &&
                  s.deleteRenderbuffer(ee.__webglDepthRenderbuffer);
            if (N.isWebGLMultipleRenderTargets)
              for (let me = 0, A = E.length; me < A; me++) {
                const T = n.get(E[me]);
                T.__webglTexture &&
                  (s.deleteTexture(T.__webglTexture), o.memory.textures--),
                  n.remove(E[me]);
              }
            n.remove(E), n.remove(N);
          }
        }
        let b = 0;
        function D() {
          b = 0;
        }
        function I() {
          const N = b;
          return (
            N >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  N +
                  " texture units while this GPU supports only " +
                  l
              ),
            (b += 1),
            N
          );
        }
        function L(N, E) {
          const ee = n.get(N);
          if (
            (N.isVideoTexture && j(N),
            N.version > 0 && ee.__version !== N.version)
          ) {
            const ue = N.image;
            if (ue === void 0)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else if (ue.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              ae(ee, N, E);
              return;
            }
          }
          t.activeTexture(33984 + E), t.bindTexture(3553, ee.__webglTexture);
        }
        function B(N, E) {
          const ee = n.get(N);
          if (N.version > 0 && ee.__version !== N.version) {
            ae(ee, N, E);
            return;
          }
          t.activeTexture(33984 + E), t.bindTexture(35866, ee.__webglTexture);
        }
        function R(N, E) {
          const ee = n.get(N);
          if (N.version > 0 && ee.__version !== N.version) {
            ae(ee, N, E);
            return;
          }
          t.activeTexture(33984 + E), t.bindTexture(32879, ee.__webglTexture);
        }
        function V(N, E) {
          const ee = n.get(N);
          if (N.version > 0 && ee.__version !== N.version) {
            fe(ee, N, E);
            return;
          }
          t.activeTexture(33984 + E), t.bindTexture(34067, ee.__webglTexture);
        }
        const H = { [ls]: 10497, [rn]: 33071, [ll]: 33648 },
          J = {
            [zt]: 9728,
            [mh]: 9984,
            [gh]: 9986,
            [sn]: 9729,
            [Zp]: 9985,
            [ys]: 9987,
          };
        function ie(N, E, ee) {
          if (
            (ee
              ? (s.texParameteri(N, 10242, H[E.wrapS]),
                s.texParameteri(N, 10243, H[E.wrapT]),
                (N === 32879 || N === 35866) &&
                  s.texParameteri(N, 32882, H[E.wrapR]),
                s.texParameteri(N, 10240, J[E.magFilter]),
                s.texParameteri(N, 10241, J[E.minFilter]))
              : (s.texParameteri(N, 10242, 33071),
                s.texParameteri(N, 10243, 33071),
                (N === 32879 || N === 35866) &&
                  s.texParameteri(N, 32882, 33071),
                (E.wrapS !== rn || E.wrapT !== rn) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                s.texParameteri(N, 10240, y(E.magFilter)),
                s.texParameteri(N, 10241, y(E.minFilter)),
                E.minFilter !== zt &&
                  E.minFilter !== sn &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            const ue = e.get("EXT_texture_filter_anisotropic");
            if (
              (E.type === Pi && e.has("OES_texture_float_linear") === !1) ||
              (a === !1 &&
                E.type === hl &&
                e.has("OES_texture_half_float_linear") === !1)
            )
              return;
            (E.anisotropy > 1 || n.get(E).__currentAnisotropy) &&
              (s.texParameterf(
                N,
                ue.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(E.anisotropy, i.getMaxAnisotropy())
              ),
              (n.get(E).__currentAnisotropy = E.anisotropy));
          }
        }
        function ne(N, E) {
          N.__webglInit === void 0 &&
            ((N.__webglInit = !0),
            E.addEventListener("dispose", C),
            (N.__webglTexture = s.createTexture()),
            o.memory.textures++);
        }
        function ae(N, E, ee) {
          let ue = 3553;
          E.isDataTexture2DArray && (ue = 35866),
            E.isDataTexture3D && (ue = 32879),
            ne(N, E),
            t.activeTexture(33984 + ee),
            t.bindTexture(ue, N.__webglTexture),
            s.pixelStorei(37440, E.flipY),
            s.pixelStorei(37441, E.premultiplyAlpha),
            s.pixelStorei(3317, E.unpackAlignment),
            s.pixelStorei(37443, 0);
          const me = _(E) && x(E.image) === !1,
            A = g(E.image, me, !1, h),
            T = x(A) || a,
            Q = r.convert(E.format);
          let oe = r.convert(E.type),
            he = v(E.internalFormat, Q, oe);
          ie(ue, E, T);
          let O;
          const le = E.mipmaps;
          if (E.isDepthTexture)
            (he = 6402),
              a
                ? E.type === Pi
                  ? (he = 36012)
                  : E.type === sl
                  ? (he = 33190)
                  : E.type === xo
                  ? (he = 35056)
                  : (he = 33189)
                : E.type === Pi &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              E.format === is &&
                he === 6402 &&
                E.type !== cl &&
                E.type !== sl &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (E.type = cl),
                (oe = r.convert(E.type))),
              E.format === To &&
                he === 6402 &&
                ((he = 34041),
                E.type !== xo &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (E.type = xo),
                  (oe = r.convert(E.type)))),
              t.texImage2D(3553, 0, he, A.width, A.height, 0, Q, oe, null);
          else if (E.isDataTexture)
            if (le.length > 0 && T) {
              for (let k = 0, ge = le.length; k < ge; k++)
                (O = le[k]),
                  t.texImage2D(
                    3553,
                    k,
                    he,
                    O.width,
                    O.height,
                    0,
                    Q,
                    oe,
                    O.data
                  );
              (E.generateMipmaps = !1), (N.__maxMipLevel = le.length - 1);
            } else
              t.texImage2D(3553, 0, he, A.width, A.height, 0, Q, oe, A.data),
                (N.__maxMipLevel = 0);
          else if (E.isCompressedTexture) {
            for (let k = 0, ge = le.length; k < ge; k++)
              (O = le[k]),
                E.format !== In && E.format !== Ni
                  ? Q !== null
                    ? t.compressedTexImage2D(
                        3553,
                        k,
                        he,
                        O.width,
                        O.height,
                        0,
                        O.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : t.texImage2D(
                      3553,
                      k,
                      he,
                      O.width,
                      O.height,
                      0,
                      Q,
                      oe,
                      O.data
                    );
            N.__maxMipLevel = le.length - 1;
          } else if (E.isDataTexture2DArray)
            t.texImage3D(
              35866,
              0,
              he,
              A.width,
              A.height,
              A.depth,
              0,
              Q,
              oe,
              A.data
            ),
              (N.__maxMipLevel = 0);
          else if (E.isDataTexture3D)
            t.texImage3D(
              32879,
              0,
              he,
              A.width,
              A.height,
              A.depth,
              0,
              Q,
              oe,
              A.data
            ),
              (N.__maxMipLevel = 0);
          else if (le.length > 0 && T) {
            for (let k = 0, ge = le.length; k < ge; k++)
              (O = le[k]), t.texImage2D(3553, k, he, Q, oe, O);
            (E.generateMipmaps = !1), (N.__maxMipLevel = le.length - 1);
          } else t.texImage2D(3553, 0, he, Q, oe, A), (N.__maxMipLevel = 0);
          M(E, T) && S(ue, E, A.width, A.height),
            (N.__version = E.version),
            E.onUpdate && E.onUpdate(E);
        }
        function fe(N, E, ee) {
          if (E.image.length !== 6) return;
          ne(N, E),
            t.activeTexture(33984 + ee),
            t.bindTexture(34067, N.__webglTexture),
            s.pixelStorei(37440, E.flipY),
            s.pixelStorei(37441, E.premultiplyAlpha),
            s.pixelStorei(3317, E.unpackAlignment),
            s.pixelStorei(37443, 0);
          const ue =
              E && (E.isCompressedTexture || E.image[0].isCompressedTexture),
            me = E.image[0] && E.image[0].isDataTexture,
            A = [];
          for (let k = 0; k < 6; k++)
            !ue && !me
              ? (A[k] = g(E.image[k], !1, !0, c))
              : (A[k] = me ? E.image[k].image : E.image[k]);
          const T = A[0],
            Q = x(T) || a,
            oe = r.convert(E.format),
            he = r.convert(E.type),
            O = v(E.internalFormat, oe, he);
          ie(34067, E, Q);
          let le;
          if (ue) {
            for (let k = 0; k < 6; k++) {
              le = A[k].mipmaps;
              for (let ge = 0; ge < le.length; ge++) {
                const pe = le[ge];
                E.format !== In && E.format !== Ni
                  ? oe !== null
                    ? t.compressedTexImage2D(
                        34069 + k,
                        ge,
                        O,
                        pe.width,
                        pe.height,
                        0,
                        pe.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                      )
                  : t.texImage2D(
                      34069 + k,
                      ge,
                      O,
                      pe.width,
                      pe.height,
                      0,
                      oe,
                      he,
                      pe.data
                    );
              }
            }
            N.__maxMipLevel = le.length - 1;
          } else {
            le = E.mipmaps;
            for (let k = 0; k < 6; k++)
              if (me) {
                t.texImage2D(
                  34069 + k,
                  0,
                  O,
                  A[k].width,
                  A[k].height,
                  0,
                  oe,
                  he,
                  A[k].data
                );
                for (let ge = 0; ge < le.length; ge++) {
                  const be = le[ge].image[k].image;
                  t.texImage2D(
                    34069 + k,
                    ge + 1,
                    O,
                    be.width,
                    be.height,
                    0,
                    oe,
                    he,
                    be.data
                  );
                }
              } else {
                t.texImage2D(34069 + k, 0, O, oe, he, A[k]);
                for (let ge = 0; ge < le.length; ge++) {
                  const pe = le[ge];
                  t.texImage2D(34069 + k, ge + 1, O, oe, he, pe.image[k]);
                }
              }
            N.__maxMipLevel = le.length;
          }
          M(E, Q) && S(34067, E, T.width, T.height),
            (N.__version = E.version),
            E.onUpdate && E.onUpdate(E);
        }
        function Fe(N, E, ee, ue, me) {
          const A = r.convert(ee.format),
            T = r.convert(ee.type),
            Q = v(ee.internalFormat, A, T);
          me === 32879 || me === 35866
            ? t.texImage3D(me, 0, Q, E.width, E.height, E.depth, 0, A, T, null)
            : t.texImage2D(me, 0, Q, E.width, E.height, 0, A, T, null),
            t.bindFramebuffer(36160, N),
            s.framebufferTexture2D(36160, ue, me, n.get(ee).__webglTexture, 0),
            t.bindFramebuffer(36160, null);
        }
        function Ee(N, E, ee) {
          if (
            (s.bindRenderbuffer(36161, N), E.depthBuffer && !E.stencilBuffer)
          ) {
            let ue = 33189;
            if (ee) {
              const me = E.depthTexture;
              me &&
                me.isDepthTexture &&
                (me.type === Pi
                  ? (ue = 36012)
                  : me.type === sl && (ue = 33190));
              const A = Ie(E);
              s.renderbufferStorageMultisample(36161, A, ue, E.width, E.height);
            } else s.renderbufferStorage(36161, ue, E.width, E.height);
            s.framebufferRenderbuffer(36160, 36096, 36161, N);
          } else if (E.depthBuffer && E.stencilBuffer) {
            if (ee) {
              const ue = Ie(E);
              s.renderbufferStorageMultisample(
                36161,
                ue,
                35056,
                E.width,
                E.height
              );
            } else s.renderbufferStorage(36161, 34041, E.width, E.height);
            s.framebufferRenderbuffer(36160, 33306, 36161, N);
          } else {
            const ue =
                E.isWebGLMultipleRenderTargets === !0
                  ? E.texture[0]
                  : E.texture,
              me = r.convert(ue.format),
              A = r.convert(ue.type),
              T = v(ue.internalFormat, me, A);
            if (ee) {
              const Q = Ie(E);
              s.renderbufferStorageMultisample(36161, Q, T, E.width, E.height);
            } else s.renderbufferStorage(36161, T, E.width, E.height);
          }
          s.bindRenderbuffer(36161, null);
        }
        function $(N, E) {
          if (E && E.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(36160, N),
            !(E.depthTexture && E.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(E.depthTexture).__webglTexture ||
            E.depthTexture.image.width !== E.width ||
            E.depthTexture.image.height !== E.height) &&
            ((E.depthTexture.image.width = E.width),
            (E.depthTexture.image.height = E.height),
            (E.depthTexture.needsUpdate = !0)),
            L(E.depthTexture, 0);
          const ue = n.get(E.depthTexture).__webglTexture;
          if (E.depthTexture.format === is)
            s.framebufferTexture2D(36160, 36096, 3553, ue, 0);
          else if (E.depthTexture.format === To)
            s.framebufferTexture2D(36160, 33306, 3553, ue, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function ke(N) {
          const E = n.get(N),
            ee = N.isWebGLCubeRenderTarget === !0;
          if (N.depthTexture) {
            if (ee)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            $(E.__webglFramebuffer, N);
          } else if (ee) {
            E.__webglDepthbuffer = [];
            for (let ue = 0; ue < 6; ue++)
              t.bindFramebuffer(36160, E.__webglFramebuffer[ue]),
                (E.__webglDepthbuffer[ue] = s.createRenderbuffer()),
                Ee(E.__webglDepthbuffer[ue], N, !1);
          } else
            t.bindFramebuffer(36160, E.__webglFramebuffer),
              (E.__webglDepthbuffer = s.createRenderbuffer()),
              Ee(E.__webglDepthbuffer, N, !1);
          t.bindFramebuffer(36160, null);
        }
        function Re(N) {
          const E = N.texture,
            ee = n.get(N),
            ue = n.get(E);
          N.addEventListener("dispose", U),
            N.isWebGLMultipleRenderTargets !== !0 &&
              ((ue.__webglTexture = s.createTexture()),
              (ue.__version = E.version),
              o.memory.textures++);
          const me = N.isWebGLCubeRenderTarget === !0,
            A = N.isWebGLMultipleRenderTargets === !0,
            T = N.isWebGLMultisampleRenderTarget === !0,
            Q = E.isDataTexture3D || E.isDataTexture2DArray,
            oe = x(N) || a;
          if (
            (a &&
              E.format === Ni &&
              (E.type === Pi || E.type === hl) &&
              ((E.format = In),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            me)
          ) {
            ee.__webglFramebuffer = [];
            for (let he = 0; he < 6; he++)
              ee.__webglFramebuffer[he] = s.createFramebuffer();
          } else if (((ee.__webglFramebuffer = s.createFramebuffer()), A))
            if (i.drawBuffers) {
              const he = N.texture;
              for (let O = 0, le = he.length; O < le; O++) {
                const k = n.get(he[O]);
                k.__webglTexture === void 0 &&
                  ((k.__webglTexture = s.createTexture()), o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (T)
            if (a) {
              (ee.__webglMultisampledFramebuffer = s.createFramebuffer()),
                (ee.__webglColorRenderbuffer = s.createRenderbuffer()),
                s.bindRenderbuffer(36161, ee.__webglColorRenderbuffer);
              const he = r.convert(E.format),
                O = r.convert(E.type),
                le = v(E.internalFormat, he, O),
                k = Ie(N);
              s.renderbufferStorageMultisample(36161, k, le, N.width, N.height),
                t.bindFramebuffer(36160, ee.__webglMultisampledFramebuffer),
                s.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  ee.__webglColorRenderbuffer
                ),
                s.bindRenderbuffer(36161, null),
                N.depthBuffer &&
                  ((ee.__webglDepthRenderbuffer = s.createRenderbuffer()),
                  Ee(ee.__webglDepthRenderbuffer, N, !0)),
                t.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (me) {
            t.bindTexture(34067, ue.__webglTexture), ie(34067, E, oe);
            for (let he = 0; he < 6; he++)
              Fe(ee.__webglFramebuffer[he], N, E, 36064, 34069 + he);
            M(E, oe) && S(34067, E, N.width, N.height),
              t.bindTexture(34067, null);
          } else if (A) {
            const he = N.texture;
            for (let O = 0, le = he.length; O < le; O++) {
              const k = he[O],
                ge = n.get(k);
              t.bindTexture(3553, ge.__webglTexture),
                ie(3553, k, oe),
                Fe(ee.__webglFramebuffer, N, k, 36064 + O, 3553),
                M(k, oe) && S(3553, k, N.width, N.height);
            }
            t.bindTexture(3553, null);
          } else {
            let he = 3553;
            Q &&
              (a
                ? (he = E.isDataTexture3D ? 32879 : 35866)
                : console.warn(
                    "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                  )),
              t.bindTexture(he, ue.__webglTexture),
              ie(he, E, oe),
              Fe(ee.__webglFramebuffer, N, E, 36064, he),
              M(E, oe) && S(3553, E, N.width, N.height),
              t.bindTexture(3553, null);
          }
          N.depthBuffer && ke(N);
        }
        function Te(N) {
          const E = x(N) || a,
            ee =
              N.isWebGLMultipleRenderTargets === !0 ? N.texture : [N.texture];
          for (let ue = 0, me = ee.length; ue < me; ue++) {
            const A = ee[ue];
            if (M(A, E)) {
              const T = N.isWebGLCubeRenderTarget ? 34067 : 3553,
                Q = n.get(A).__webglTexture;
              t.bindTexture(T, Q),
                S(T, A, N.width, N.height),
                t.bindTexture(T, null);
            }
          }
        }
        function ce(N) {
          if (N.isWebGLMultisampleRenderTarget)
            if (a) {
              const E = N.width,
                ee = N.height;
              let ue = 16384;
              N.depthBuffer && (ue |= 256), N.stencilBuffer && (ue |= 1024);
              const me = n.get(N);
              t.bindFramebuffer(36008, me.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, me.__webglFramebuffer),
                s.blitFramebuffer(0, 0, E, ee, 0, 0, E, ee, ue, 9728),
                t.bindFramebuffer(36008, null),
                t.bindFramebuffer(36009, me.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }
        function Ie(N) {
          return a && N.isWebGLMultisampleRenderTarget
            ? Math.min(u, N.samples)
            : 0;
        }
        function j(N) {
          const E = o.render.frame;
          d.get(N) !== E && (d.set(N, E), N.update());
        }
        let Z = !1,
          te = !1;
        function de(N, E) {
          N &&
            N.isWebGLRenderTarget &&
            (Z === !1 &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (Z = !0)),
            (N = N.texture)),
            L(N, E);
        }
        function se(N, E) {
          N &&
            N.isWebGLCubeRenderTarget &&
            (te === !1 &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (te = !0)),
            (N = N.texture)),
            V(N, E);
        }
        (this.allocateTextureUnit = I),
          (this.resetTextureUnits = D),
          (this.setTexture2D = L),
          (this.setTexture2DArray = B),
          (this.setTexture3D = R),
          (this.setTextureCube = V),
          (this.setupRenderTarget = Re),
          (this.updateRenderTargetMipmap = Te),
          (this.updateMultisampleRenderTarget = ce),
          (this.safeSetTexture2D = de),
          (this.safeSetTextureCube = se);
      }
      function ub(s, e, t) {
        const n = t.isWebGL2;
        function i(r) {
          let o;
          if (r === $h) return 5121;
          if (r === Ex) return 32819;
          if (r === Ax) return 32820;
          if (r === Lx) return 33635;
          if (r === wx) return 5120;
          if (r === Sx) return 5122;
          if (r === cl) return 5123;
          if (r === Tx) return 5124;
          if (r === sl) return 5125;
          if (r === Pi) return 5126;
          if (r === hl)
            return n
              ? 5131
              : ((o = e.get("OES_texture_half_float")),
                o !== null ? o.HALF_FLOAT_OES : null);
          if (r === Rx) return 6406;
          if (r === Ni) return 6407;
          if (r === In) return 6408;
          if (r === Cx) return 6409;
          if (r === Px) return 6410;
          if (r === is) return 6402;
          if (r === To) return 34041;
          if (r === Dx) return 6403;
          if (r === Ix) return 36244;
          if (r === Nx) return 33319;
          if (r === Fx) return 33320;
          if (r === Bx) return 36248;
          if (r === zx) return 36249;
          if (r === ju || r === Yu || r === Zu || r === Ju)
            if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
              if (r === ju) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (r === Yu) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (r === Zu) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (r === Ju) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (r === Ku || r === Qu || r === ed || r === td)
            if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
              if (r === Ku) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (r === Qu) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (r === ed) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (r === td) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (r === Ox)
            return (
              (o = e.get("WEBGL_compressed_texture_etc1")),
              o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (r === nd || r === id) &&
            ((o = e.get("WEBGL_compressed_texture_etc")), o !== null)
          ) {
            if (r === nd) return o.COMPRESSED_RGB8_ETC2;
            if (r === id) return o.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            r === Ux ||
            r === Hx ||
            r === Gx ||
            r === Vx ||
            r === kx ||
            r === Wx ||
            r === $x ||
            r === qx ||
            r === Xx ||
            r === jx ||
            r === Yx ||
            r === Zx ||
            r === Jx ||
            r === Kx ||
            r === e_ ||
            r === t_ ||
            r === n_ ||
            r === i_ ||
            r === r_ ||
            r === s_ ||
            r === o_ ||
            r === a_ ||
            r === l_ ||
            r === c_ ||
            r === h_ ||
            r === u_ ||
            r === d_ ||
            r === f_
          )
            return (
              (o = e.get("WEBGL_compressed_texture_astc")),
              o !== null ? r : null
            );
          if (r === Qx)
            return (
              (o = e.get("EXT_texture_compression_bptc")), o !== null ? r : null
            );
          if (r === xo)
            return n
              ? 34042
              : ((o = e.get("WEBGL_depth_texture")),
                o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
        }
        return { convert: i };
      }
      class vm extends tn {
        constructor(e = []) {
          super(), (this.cameras = e);
        }
      }
      vm.prototype.isArrayCamera = !0;
      class Ii extends Ke {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      Ii.prototype.isGroup = !0;
      const db = { type: "move" };
      class gc {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new Ii()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new Ii()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new G()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new G())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new Ii()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new G()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new G())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            o = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred")
            if (
              (a !== null &&
                ((i = t.getPose(e.targetRaySpace, n)),
                i !== null &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(db))),
              c && e.hand)
            ) {
              o = !0;
              for (const p of e.hand.values()) {
                const g = t.getJointPose(p, n);
                if (c.joints[p.jointName] === void 0) {
                  const _ = new Ii();
                  (_.matrixAutoUpdate = !1),
                    (_.visible = !1),
                    (c.joints[p.jointName] = _),
                    c.add(_);
                }
                const x = c.joints[p.jointName];
                g !== null &&
                  (x.matrix.fromArray(g.transform.matrix),
                  x.matrix.decompose(x.position, x.rotation, x.scale),
                  (x.jointRadius = g.radius)),
                  (x.visible = g !== null);
              }
              const h = c.joints["index-finger-tip"],
                u = c.joints["thumb-tip"],
                d = h.position.distanceTo(u.position),
                f = 0.02,
                m = 0.005;
              c.inputState.pinching && d > f + m
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  d <= f - m &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              l !== null &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                r !== null &&
                  (l.matrix.fromArray(r.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  r.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(r.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(r.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
          return (
            a !== null && (a.visible = i !== null),
            l !== null && (l.visible = r !== null),
            c !== null && (c.visible = o !== null),
            this
          );
        }
      }
      class fb extends or {
        constructor(e, t) {
          super();
          const n = this,
            i = e.state;
          let r = null,
            o = 1,
            a = null,
            l = "local-floor",
            c = null;
          const h = [],
            u = new Map(),
            d = new tn();
          d.layers.enable(1), (d.viewport = new rt());
          const f = new tn();
          f.layers.enable(2), (f.viewport = new rt());
          const m = [d, f],
            p = new vm();
          p.layers.enable(1), p.layers.enable(2);
          let g = null,
            x = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (D) {
              let I = h[D];
              return (
                I === void 0 && ((I = new gc()), (h[D] = I)),
                I.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (D) {
              let I = h[D];
              return (
                I === void 0 && ((I = new gc()), (h[D] = I)), I.getGripSpace()
              );
            }),
            (this.getHand = function (D) {
              let I = h[D];
              return (
                I === void 0 && ((I = new gc()), (h[D] = I)), I.getHandSpace()
              );
            });
          function _(D) {
            const I = u.get(D.inputSource);
            I && I.dispatchEvent({ type: D.type, data: D.inputSource });
          }
          function M() {
            u.forEach(function (D, I) {
              D.disconnect(I);
            }),
              u.clear(),
              (g = null),
              (x = null),
              i.bindXRFramebuffer(null),
              e.setRenderTarget(e.getRenderTarget()),
              b.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (D) {
            (o = D),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (D) {
              (l = D),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return a;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = async function (D) {
              if (((r = D), r !== null)) {
                r.addEventListener("select", _),
                  r.addEventListener("selectstart", _),
                  r.addEventListener("selectend", _),
                  r.addEventListener("squeeze", _),
                  r.addEventListener("squeezestart", _),
                  r.addEventListener("squeezeend", _),
                  r.addEventListener("end", M),
                  r.addEventListener("inputsourceschange", S);
                const I = t.getContextAttributes();
                I.xrCompatible !== !0 && (await t.makeXRCompatible());
                const L = {
                    antialias: I.antialias,
                    alpha: I.alpha,
                    depth: I.depth,
                    stencil: I.stencil,
                    framebufferScaleFactor: o,
                  },
                  B = new XRWebGLLayer(r, t, L);
                r.updateRenderState({ baseLayer: B }),
                  (a = await r.requestReferenceSpace(l)),
                  b.setContext(r),
                  b.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          function S(D) {
            const I = r.inputSources;
            for (let L = 0; L < h.length; L++) u.set(I[L], h[L]);
            for (let L = 0; L < D.removed.length; L++) {
              const B = D.removed[L],
                R = u.get(B);
              R &&
                (R.dispatchEvent({ type: "disconnected", data: B }),
                u.delete(B));
            }
            for (let L = 0; L < D.added.length; L++) {
              const B = D.added[L],
                R = u.get(B);
              R && R.dispatchEvent({ type: "connected", data: B });
            }
          }
          const v = new G(),
            y = new G();
          function C(D, I, L) {
            v.setFromMatrixPosition(I.matrixWorld),
              y.setFromMatrixPosition(L.matrixWorld);
            const B = v.distanceTo(y),
              R = I.projectionMatrix.elements,
              V = L.projectionMatrix.elements,
              H = R[14] / (R[10] - 1),
              J = R[14] / (R[10] + 1),
              ie = (R[9] + 1) / R[5],
              ne = (R[9] - 1) / R[5],
              ae = (R[8] - 1) / R[0],
              fe = (V[8] + 1) / V[0],
              Fe = H * ae,
              Ee = H * fe,
              $ = B / (-ae + fe),
              ke = $ * -ae;
            I.matrixWorld.decompose(D.position, D.quaternion, D.scale),
              D.translateX(ke),
              D.translateZ($),
              D.matrixWorld.compose(D.position, D.quaternion, D.scale),
              D.matrixWorldInverse.copy(D.matrixWorld).invert();
            const Re = H + $,
              Te = J + $,
              ce = Fe - ke,
              Ie = Ee + (B - ke),
              j = ((ie * J) / Te) * Re,
              Z = ((ne * J) / Te) * Re;
            D.projectionMatrix.makePerspective(ce, Ie, j, Z, Re, Te);
          }
          function U(D, I) {
            I === null
              ? D.matrixWorld.copy(D.matrix)
              : D.matrixWorld.multiplyMatrices(I.matrixWorld, D.matrix),
              D.matrixWorldInverse.copy(D.matrixWorld).invert();
          }
          (this.updateCamera = function (D) {
            if (r === null) return;
            (p.near = f.near = d.near = D.near),
              (p.far = f.far = d.far = D.far),
              (g !== p.near || x !== p.far) &&
                (r.updateRenderState({ depthNear: p.near, depthFar: p.far }),
                (g = p.near),
                (x = p.far));
            const I = D.parent,
              L = p.cameras;
            U(p, I);
            for (let R = 0; R < L.length; R++) U(L[R], I);
            D.matrixWorld.copy(p.matrixWorld),
              D.matrix.copy(p.matrix),
              D.matrix.decompose(D.position, D.quaternion, D.scale);
            const B = D.children;
            for (let R = 0, V = B.length; R < V; R++)
              B[R].updateMatrixWorld(!0);
            L.length === 2
              ? C(p, d, f)
              : p.projectionMatrix.copy(d.projectionMatrix);
          }),
            (this.getCamera = function () {
              return p;
            });
          let K = null;
          function X(D, I) {
            if (((c = I.getViewerPose(a)), c !== null)) {
              const B = c.views,
                R = r.renderState.baseLayer;
              i.bindXRFramebuffer(R.framebuffer);
              let V = !1;
              B.length !== p.cameras.length &&
                ((p.cameras.length = 0), (V = !0));
              for (let H = 0; H < B.length; H++) {
                const J = B[H],
                  ie = R.getViewport(J),
                  ne = m[H];
                ne.matrix.fromArray(J.transform.matrix),
                  ne.projectionMatrix.fromArray(J.projectionMatrix),
                  ne.viewport.set(ie.x, ie.y, ie.width, ie.height),
                  H === 0 && p.matrix.copy(ne.matrix),
                  V === !0 && p.cameras.push(ne);
              }
            }
            const L = r.inputSources;
            for (let B = 0; B < h.length; B++) {
              const R = h[B],
                V = L[B];
              R.update(V, I, a);
            }
            K && K(D, I);
          }
          const b = new om();
          b.setAnimationLoop(X),
            (this.setAnimationLoop = function (D) {
              K = D;
            }),
            (this.dispose = function () {});
        }
      }
      function pb(s) {
        function e(x, _) {
          x.fogColor.value.copy(_.color),
            _.isFog
              ? ((x.fogNear.value = _.near), (x.fogFar.value = _.far))
              : _.isFogExp2 && (x.fogDensity.value = _.density);
        }
        function t(x, _, M, S, v) {
          _.isMeshBasicMaterial
            ? n(x, _)
            : _.isMeshLambertMaterial
            ? (n(x, _), l(x, _))
            : _.isMeshToonMaterial
            ? (n(x, _), h(x, _))
            : _.isMeshPhongMaterial
            ? (n(x, _), c(x, _))
            : _.isMeshStandardMaterial
            ? (n(x, _), _.isMeshPhysicalMaterial ? d(x, _, v) : u(x, _))
            : _.isMeshMatcapMaterial
            ? (n(x, _), f(x, _))
            : _.isMeshDepthMaterial
            ? (n(x, _), m(x, _))
            : _.isMeshDistanceMaterial
            ? (n(x, _), p(x, _))
            : _.isMeshNormalMaterial
            ? (n(x, _), g(x, _))
            : _.isLineBasicMaterial
            ? (i(x, _), _.isLineDashedMaterial && r(x, _))
            : _.isPointsMaterial
            ? o(x, _, M, S)
            : _.isSpriteMaterial
            ? a(x, _)
            : _.isShadowMaterial
            ? (x.color.value.copy(_.color), (x.opacity.value = _.opacity))
            : _.isShaderMaterial && (_.uniformsNeedUpdate = !1);
        }
        function n(x, _) {
          (x.opacity.value = _.opacity),
            _.color && x.diffuse.value.copy(_.color),
            _.emissive &&
              x.emissive.value
                .copy(_.emissive)
                .multiplyScalar(_.emissiveIntensity),
            _.map && (x.map.value = _.map),
            _.alphaMap && (x.alphaMap.value = _.alphaMap),
            _.specularMap && (x.specularMap.value = _.specularMap);
          const M = s.get(_).envMap;
          if (M) {
            (x.envMap.value = M),
              (x.flipEnvMap.value =
                M.isCubeTexture && M._needsFlipEnvMap ? -1 : 1),
              (x.reflectivity.value = _.reflectivity),
              (x.refractionRatio.value = _.refractionRatio);
            const y = s.get(M).__maxMipLevel;
            y !== void 0 && (x.maxMipLevel.value = y);
          }
          _.lightMap &&
            ((x.lightMap.value = _.lightMap),
            (x.lightMapIntensity.value = _.lightMapIntensity)),
            _.aoMap &&
              ((x.aoMap.value = _.aoMap),
              (x.aoMapIntensity.value = _.aoMapIntensity));
          let S;
          _.map
            ? (S = _.map)
            : _.specularMap
            ? (S = _.specularMap)
            : _.displacementMap
            ? (S = _.displacementMap)
            : _.normalMap
            ? (S = _.normalMap)
            : _.bumpMap
            ? (S = _.bumpMap)
            : _.roughnessMap
            ? (S = _.roughnessMap)
            : _.metalnessMap
            ? (S = _.metalnessMap)
            : _.alphaMap
            ? (S = _.alphaMap)
            : _.emissiveMap
            ? (S = _.emissiveMap)
            : _.clearcoatMap
            ? (S = _.clearcoatMap)
            : _.clearcoatNormalMap
            ? (S = _.clearcoatNormalMap)
            : _.clearcoatRoughnessMap && (S = _.clearcoatRoughnessMap),
            S !== void 0 &&
              (S.isWebGLRenderTarget && (S = S.texture),
              S.matrixAutoUpdate === !0 && S.updateMatrix(),
              x.uvTransform.value.copy(S.matrix));
          let v;
          _.aoMap ? (v = _.aoMap) : _.lightMap && (v = _.lightMap),
            v !== void 0 &&
              (v.isWebGLRenderTarget && (v = v.texture),
              v.matrixAutoUpdate === !0 && v.updateMatrix(),
              x.uv2Transform.value.copy(v.matrix));
        }
        function i(x, _) {
          x.diffuse.value.copy(_.color), (x.opacity.value = _.opacity);
        }
        function r(x, _) {
          (x.dashSize.value = _.dashSize),
            (x.totalSize.value = _.dashSize + _.gapSize),
            (x.scale.value = _.scale);
        }
        function o(x, _, M, S) {
          x.diffuse.value.copy(_.color),
            (x.opacity.value = _.opacity),
            (x.size.value = _.size * M),
            (x.scale.value = S * 0.5),
            _.map && (x.map.value = _.map),
            _.alphaMap && (x.alphaMap.value = _.alphaMap);
          let v;
          _.map ? (v = _.map) : _.alphaMap && (v = _.alphaMap),
            v !== void 0 &&
              (v.matrixAutoUpdate === !0 && v.updateMatrix(),
              x.uvTransform.value.copy(v.matrix));
        }
        function a(x, _) {
          x.diffuse.value.copy(_.color),
            (x.opacity.value = _.opacity),
            (x.rotation.value = _.rotation),
            _.map && (x.map.value = _.map),
            _.alphaMap && (x.alphaMap.value = _.alphaMap);
          let M;
          _.map ? (M = _.map) : _.alphaMap && (M = _.alphaMap),
            M !== void 0 &&
              (M.matrixAutoUpdate === !0 && M.updateMatrix(),
              x.uvTransform.value.copy(M.matrix));
        }
        function l(x, _) {
          _.emissiveMap && (x.emissiveMap.value = _.emissiveMap);
        }
        function c(x, _) {
          x.specular.value.copy(_.specular),
            (x.shininess.value = Math.max(_.shininess, 1e-4)),
            _.emissiveMap && (x.emissiveMap.value = _.emissiveMap),
            _.bumpMap &&
              ((x.bumpMap.value = _.bumpMap),
              (x.bumpScale.value = _.bumpScale),
              _.side === Rt && (x.bumpScale.value *= -1)),
            _.normalMap &&
              ((x.normalMap.value = _.normalMap),
              x.normalScale.value.copy(_.normalScale),
              _.side === Rt && x.normalScale.value.negate()),
            _.displacementMap &&
              ((x.displacementMap.value = _.displacementMap),
              (x.displacementScale.value = _.displacementScale),
              (x.displacementBias.value = _.displacementBias));
        }
        function h(x, _) {
          _.gradientMap && (x.gradientMap.value = _.gradientMap),
            _.emissiveMap && (x.emissiveMap.value = _.emissiveMap),
            _.bumpMap &&
              ((x.bumpMap.value = _.bumpMap),
              (x.bumpScale.value = _.bumpScale),
              _.side === Rt && (x.bumpScale.value *= -1)),
            _.normalMap &&
              ((x.normalMap.value = _.normalMap),
              x.normalScale.value.copy(_.normalScale),
              _.side === Rt && x.normalScale.value.negate()),
            _.displacementMap &&
              ((x.displacementMap.value = _.displacementMap),
              (x.displacementScale.value = _.displacementScale),
              (x.displacementBias.value = _.displacementBias));
        }
        function u(x, _) {
          (x.roughness.value = _.roughness),
            (x.metalness.value = _.metalness),
            _.roughnessMap && (x.roughnessMap.value = _.roughnessMap),
            _.metalnessMap && (x.metalnessMap.value = _.metalnessMap),
            _.emissiveMap && (x.emissiveMap.value = _.emissiveMap),
            _.bumpMap &&
              ((x.bumpMap.value = _.bumpMap),
              (x.bumpScale.value = _.bumpScale),
              _.side === Rt && (x.bumpScale.value *= -1)),
            _.normalMap &&
              ((x.normalMap.value = _.normalMap),
              x.normalScale.value.copy(_.normalScale),
              _.side === Rt && x.normalScale.value.negate()),
            _.displacementMap &&
              ((x.displacementMap.value = _.displacementMap),
              (x.displacementScale.value = _.displacementScale),
              (x.displacementBias.value = _.displacementBias)),
            s.get(_).envMap && (x.envMapIntensity.value = _.envMapIntensity);
        }
        function d(x, _, M) {
          u(x, _),
            (x.reflectivity.value = _.reflectivity),
            (x.clearcoat.value = _.clearcoat),
            (x.clearcoatRoughness.value = _.clearcoatRoughness),
            _.sheen && x.sheen.value.copy(_.sheen),
            _.clearcoatMap && (x.clearcoatMap.value = _.clearcoatMap),
            _.clearcoatRoughnessMap &&
              (x.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap),
            _.clearcoatNormalMap &&
              (x.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),
              (x.clearcoatNormalMap.value = _.clearcoatNormalMap),
              _.side === Rt && x.clearcoatNormalScale.value.negate()),
            (x.transmission.value = _.transmission),
            _.transmissionMap && (x.transmissionMap.value = _.transmissionMap),
            _.transmission > 0 &&
              ((x.transmissionSamplerMap.value = M.texture),
              x.transmissionSamplerSize.value.set(M.width, M.height)),
            (x.thickness.value = _.thickness),
            _.thicknessMap && (x.thicknessMap.value = _.thicknessMap),
            (x.attenuationDistance.value = _.attenuationDistance),
            x.attenuationColor.value.copy(_.attenuationColor);
        }
        function f(x, _) {
          _.matcap && (x.matcap.value = _.matcap),
            _.bumpMap &&
              ((x.bumpMap.value = _.bumpMap),
              (x.bumpScale.value = _.bumpScale),
              _.side === Rt && (x.bumpScale.value *= -1)),
            _.normalMap &&
              ((x.normalMap.value = _.normalMap),
              x.normalScale.value.copy(_.normalScale),
              _.side === Rt && x.normalScale.value.negate()),
            _.displacementMap &&
              ((x.displacementMap.value = _.displacementMap),
              (x.displacementScale.value = _.displacementScale),
              (x.displacementBias.value = _.displacementBias));
        }
        function m(x, _) {
          _.displacementMap &&
            ((x.displacementMap.value = _.displacementMap),
            (x.displacementScale.value = _.displacementScale),
            (x.displacementBias.value = _.displacementBias));
        }
        function p(x, _) {
          _.displacementMap &&
            ((x.displacementMap.value = _.displacementMap),
            (x.displacementScale.value = _.displacementScale),
            (x.displacementBias.value = _.displacementBias)),
            x.referencePosition.value.copy(_.referencePosition),
            (x.nearDistance.value = _.nearDistance),
            (x.farDistance.value = _.farDistance);
        }
        function g(x, _) {
          _.bumpMap &&
            ((x.bumpMap.value = _.bumpMap),
            (x.bumpScale.value = _.bumpScale),
            _.side === Rt && (x.bumpScale.value *= -1)),
            _.normalMap &&
              ((x.normalMap.value = _.normalMap),
              x.normalScale.value.copy(_.normalScale),
              _.side === Rt && x.normalScale.value.negate()),
            _.displacementMap &&
              ((x.displacementMap.value = _.displacementMap),
              (x.displacementScale.value = _.displacementScale),
              (x.displacementBias.value = _.displacementBias));
        }
        return { refreshFogUniforms: e, refreshMaterialUniforms: t };
      }
      function mb() {
        const s = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return (s.style.display = "block"), s;
      }
      function ot(s) {
        s = s || {};
        const e = s.canvas !== void 0 ? s.canvas : mb(),
          t = s.context !== void 0 ? s.context : null,
          n = s.alpha !== void 0 ? s.alpha : !1,
          i = s.depth !== void 0 ? s.depth : !0,
          r = s.stencil !== void 0 ? s.stencil : !0,
          o = s.antialias !== void 0 ? s.antialias : !1,
          a = s.premultipliedAlpha !== void 0 ? s.premultipliedAlpha : !0,
          l = s.preserveDrawingBuffer !== void 0 ? s.preserveDrawingBuffer : !1,
          c = s.powerPreference !== void 0 ? s.powerPreference : "default",
          h =
            s.failIfMajorPerformanceCaveat !== void 0
              ? s.failIfMajorPerformanceCaveat
              : !1;
        let u = null,
          d = null;
        const f = [],
          m = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = Wo),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = go),
          (this.toneMappingExposure = 1);
        const p = this;
        let g = !1,
          x = 0,
          _ = 0,
          M = null,
          S = -1,
          v = null;
        const y = new rt(),
          C = new rt();
        let U = null,
          K = e.width,
          X = e.height,
          b = 1,
          D = null,
          I = null;
        const L = new rt(0, 0, K, X),
          B = new rt(0, 0, K, X);
        let R = !1;
        const V = [],
          H = new bl();
        let J = !1,
          ie = !1,
          ne = null;
        const ae = new Ge(),
          fe = new G(),
          Fe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Ee() {
          return M === null ? b : 1;
        }
        let $ = t;
        function ke(F, w) {
          for (let P = 0; P < F.length; P++) {
            const z = F[P],
              q = e.getContext(z, w);
            if (q !== null) return q;
          }
          return null;
        }
        try {
          const F = {
            alpha: n,
            depth: i,
            stencil: r,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: h,
          };
          if (
            (e.addEventListener("webglcontextlost", be, !1),
            e.addEventListener("webglcontextrestored", Y, !1),
            $ === null)
          ) {
            const w = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (p.isWebGL1Renderer === !0 && w.shift(),
              ($ = ke(w, F)),
              $ === null)
            )
              throw ke(w)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          $.getShaderPrecisionFormat === void 0 &&
            ($.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (F) {
          throw (console.error("THREE.WebGLRenderer: " + F.message), F);
        }
        let Re,
          Te,
          ce,
          Ie,
          j,
          Z,
          te,
          de,
          se,
          N,
          E,
          ee,
          ue,
          me,
          A,
          T,
          Q,
          oe,
          he,
          O,
          le,
          k;
        function ge() {
          (Re = new O0($)),
            (Te = new F0($, Re, s)),
            Re.init(Te),
            (le = new ub($, Re, Te)),
            (ce = new cb($, Re, Te)),
            (V[0] = 1029),
            (Ie = new G0($)),
            (j = new KM()),
            (Z = new hb($, Re, ce, j, Te, le, Ie)),
            (te = new z0(p)),
            (de = new cv($, Te)),
            (k = new I0($, Re, de, Te)),
            (se = new U0($, de, Ie, k)),
            (N = new $0($, se, de, Ie)),
            (oe = new W0($)),
            (A = new B0(j)),
            (E = new JM(p, te, Re, Te, k, A)),
            (ee = new pb(j)),
            (ue = new eb(j)),
            (me = new ob(Re, Te)),
            (Q = new D0(p, te, ce, N, a)),
            (T = new _m(p, N, Te)),
            (he = new N0($, Re, Ie, Te)),
            (O = new H0($, Re, Ie, Te)),
            (Ie.programs = E.programs),
            (p.capabilities = Te),
            (p.extensions = Re),
            (p.properties = j),
            (p.renderLists = ue),
            (p.shadowMap = T),
            (p.state = ce),
            (p.info = Ie);
        }
        ge();
        const pe = new fb(p, $);
        (this.xr = pe),
          (this.getContext = function () {
            return $;
          }),
          (this.getContextAttributes = function () {
            return $.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const F = Re.get("WEBGL_lose_context");
            F && F.loseContext();
          }),
          (this.forceContextRestore = function () {
            const F = Re.get("WEBGL_lose_context");
            F && F.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return b;
          }),
          (this.setPixelRatio = function (F) {
            F !== void 0 && ((b = F), this.setSize(K, X, !1));
          }),
          (this.getSize = function (F) {
            return (
              F === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                ),
                (F = new Se())),
              F.set(K, X)
            );
          }),
          (this.setSize = function (F, w, P) {
            if (pe.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (K = F),
              (X = w),
              (e.width = Math.floor(F * b)),
              (e.height = Math.floor(w * b)),
              P !== !1 &&
                ((e.style.width = F + "px"), (e.style.height = w + "px")),
              this.setViewport(0, 0, F, w);
          }),
          (this.getDrawingBufferSize = function (F) {
            return (
              F === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                ),
                (F = new Se())),
              F.set(K * b, X * b).floor()
            );
          }),
          (this.setDrawingBufferSize = function (F, w, P) {
            (K = F),
              (X = w),
              (b = P),
              (e.width = Math.floor(F * P)),
              (e.height = Math.floor(w * P)),
              this.setViewport(0, 0, F, w);
          }),
          (this.getCurrentViewport = function (F) {
            return (
              F === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                ),
                (F = new rt())),
              F.copy(y)
            );
          }),
          (this.getViewport = function (F) {
            return F.copy(L);
          }),
          (this.setViewport = function (F, w, P, z) {
            F.isVector4 ? L.set(F.x, F.y, F.z, F.w) : L.set(F, w, P, z),
              ce.viewport(y.copy(L).multiplyScalar(b).floor());
          }),
          (this.getScissor = function (F) {
            return F.copy(B);
          }),
          (this.setScissor = function (F, w, P, z) {
            F.isVector4 ? B.set(F.x, F.y, F.z, F.w) : B.set(F, w, P, z),
              ce.scissor(C.copy(B).multiplyScalar(b).floor());
          }),
          (this.getScissorTest = function () {
            return R;
          }),
          (this.setScissorTest = function (F) {
            ce.setScissorTest((R = F));
          }),
          (this.setOpaqueSort = function (F) {
            D = F;
          }),
          (this.setTransparentSort = function (F) {
            I = F;
          }),
          (this.getClearColor = function (F) {
            return (
              F === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getClearColor() now requires a Color as an argument"
                ),
                (F = new Ue())),
              F.copy(Q.getClearColor())
            );
          }),
          (this.setClearColor = function () {
            Q.setClearColor.apply(Q, arguments);
          }),
          (this.getClearAlpha = function () {
            return Q.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            Q.setClearAlpha.apply(Q, arguments);
          }),
          (this.clear = function (F, w, P) {
            let z = 0;
            (F === void 0 || F) && (z |= 16384),
              (w === void 0 || w) && (z |= 256),
              (P === void 0 || P) && (z |= 1024),
              $.clear(z);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", be, !1),
              e.removeEventListener("webglcontextrestored", Y, !1),
              ue.dispose(),
              me.dispose(),
              j.dispose(),
              te.dispose(),
              N.dispose(),
              k.dispose(),
              pe.dispose(),
              pe.removeEventListener("sessionstart", qe),
              pe.removeEventListener("sessionend", it),
              ne && (ne.dispose(), (ne = null)),
              Xe.stop();
          });
        function be(F) {
          F.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (g = !0);
        }
        function Y() {
          console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
          const F = Ie.autoReset,
            w = T.enabled,
            P = T.autoUpdate,
            z = T.needsUpdate,
            q = T.type;
          ge(),
            (Ie.autoReset = F),
            (T.enabled = w),
            (T.autoUpdate = P),
            (T.needsUpdate = z),
            (T.type = q);
        }
        function _e(F) {
          const w = F.target;
          w.removeEventListener("dispose", _e), we(w);
        }
        function we(F) {
          Be(F), j.remove(F);
        }
        function Be(F) {
          const w = j.get(F).programs;
          w !== void 0 &&
            w.forEach(function (P) {
              E.releaseProgram(P);
            });
        }
        function Ne(F, w) {
          F.render(function (P) {
            p.renderBufferImmediate(P, w);
          });
        }
        (this.renderBufferImmediate = function (F, w) {
          k.initAttributes();
          const P = j.get(F);
          F.hasPositions && !P.position && (P.position = $.createBuffer()),
            F.hasNormals && !P.normal && (P.normal = $.createBuffer()),
            F.hasUvs && !P.uv && (P.uv = $.createBuffer()),
            F.hasColors && !P.color && (P.color = $.createBuffer());
          const z = w.getAttributes();
          F.hasPositions &&
            ($.bindBuffer(34962, P.position),
            $.bufferData(34962, F.positionArray, 35048),
            k.enableAttribute(z.position),
            $.vertexAttribPointer(z.position, 3, 5126, !1, 0, 0)),
            F.hasNormals &&
              ($.bindBuffer(34962, P.normal),
              $.bufferData(34962, F.normalArray, 35048),
              k.enableAttribute(z.normal),
              $.vertexAttribPointer(z.normal, 3, 5126, !1, 0, 0)),
            F.hasUvs &&
              ($.bindBuffer(34962, P.uv),
              $.bufferData(34962, F.uvArray, 35048),
              k.enableAttribute(z.uv),
              $.vertexAttribPointer(z.uv, 2, 5126, !1, 0, 0)),
            F.hasColors &&
              ($.bindBuffer(34962, P.color),
              $.bufferData(34962, F.colorArray, 35048),
              k.enableAttribute(z.color),
              $.vertexAttribPointer(z.color, 3, 5126, !1, 0, 0)),
            k.disableUnusedAttributes(),
            $.drawArrays(4, 0, F.count),
            (F.count = 0);
        }),
          (this.renderBufferDirect = function (F, w, P, z, q, re) {
            w === null && (w = Fe);
            const Me = q.isMesh && q.matrixWorld.determinant() < 0,
              xe = Us(F, w, z, q);
            ce.setMaterial(z, Me);
            let Ce = P.index;
            const ve = P.attributes.position;
            if (Ce === null) {
              if (ve === void 0 || ve.count === 0) return;
            } else if (Ce.count === 0) return;
            let ze = 1;
            z.wireframe === !0 &&
              ((Ce = se.getWireframeAttribute(P)), (ze = 2)),
              (z.morphTargets || z.morphNormals) && oe.update(q, P, z, xe),
              k.setup(q, z, xe, P, Ce);
            let Ae,
              Oe = he;
            Ce !== null && ((Ae = de.get(Ce)), (Oe = O), Oe.setIndex(Ae));
            const Ze = Ce !== null ? Ce.count : ve.count,
              mt = P.drawRange.start * ze,
              Qt = P.drawRange.count * ze,
              at = re !== null ? re.start * ze : 0,
              Et = re !== null ? re.count * ze : 1 / 0,
              $e = Math.max(mt, at),
              di = Math.min(Ze, mt + Qt, at + Et) - 1,
              ct = Math.max(0, di - $e + 1);
            if (ct !== 0) {
              if (q.isMesh)
                z.wireframe === !0
                  ? (ce.setLineWidth(z.wireframeLinewidth * Ee()),
                    Oe.setMode(1))
                  : Oe.setMode(4);
              else if (q.isLine) {
                let Gt = z.linewidth;
                Gt === void 0 && (Gt = 1),
                  ce.setLineWidth(Gt * Ee()),
                  q.isLineSegments
                    ? Oe.setMode(1)
                    : q.isLineLoop
                    ? Oe.setMode(2)
                    : Oe.setMode(3);
              } else q.isPoints ? Oe.setMode(0) : q.isSprite && Oe.setMode(4);
              if (q.isInstancedMesh) Oe.renderInstances($e, ct, q.count);
              else if (P.isInstancedBufferGeometry) {
                const Gt = Math.min(P.instanceCount, P._maxInstanceCount);
                Oe.renderInstances($e, ct, Gt);
              } else Oe.render($e, ct);
            }
          }),
          (this.compile = function (F, w) {
            (d = me.get(F)),
              d.init(),
              F.traverseVisible(function (P) {
                P.isLight &&
                  P.layers.test(w.layers) &&
                  (d.pushLight(P), P.castShadow && d.pushShadow(P));
              }),
              d.setupLights(),
              F.traverse(function (P) {
                const z = P.material;
                if (z)
                  if (Array.isArray(z))
                    for (let q = 0; q < z.length; q++) {
                      const re = z[q];
                      Os(re, F, P);
                    }
                  else Os(z, F, P);
              });
          });
        let He = null;
        function Le(F) {
          He && He(F);
        }
        function qe() {
          Xe.stop();
        }
        function it() {
          Xe.start();
        }
        const Xe = new om();
        Xe.setAnimationLoop(Le),
          typeof window != "undefined" && Xe.setContext(window),
          (this.setAnimationLoop = function (F) {
            (He = F),
              pe.setAnimationLoop(F),
              F === null ? Xe.stop() : Xe.start();
          }),
          pe.addEventListener("sessionstart", qe),
          pe.addEventListener("sessionend", it),
          (this.render = function (F, w) {
            if (w !== void 0 && w.isCamera !== !0) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (g === !0) return;
            F.autoUpdate === !0 && F.updateMatrixWorld(),
              w.parent === null && w.updateMatrixWorld(),
              pe.enabled === !0 &&
                pe.isPresenting === !0 &&
                (pe.cameraAutoUpdate === !0 && pe.updateCamera(w),
                (w = pe.getCamera())),
              F.isScene === !0 && F.onBeforeRender(p, F, w, M),
              (d = me.get(F, m.length)),
              d.init(),
              m.push(d),
              ae.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse),
              H.setFromProjectionMatrix(ae),
              (ie = this.localClippingEnabled),
              (J = A.init(this.clippingPlanes, ie, w)),
              (u = ue.get(F, f.length)),
              u.init(),
              f.push(u),
              ln(F, w, 0, p.sortObjects),
              u.finish(),
              p.sortObjects === !0 && u.sort(D, I),
              J === !0 && A.beginShadows();
            const P = d.state.shadowsArray;
            T.render(P, F, w),
              d.setupLights(),
              d.setupLightsView(w),
              J === !0 && A.endShadows(),
              this.info.autoReset === !0 && this.info.reset(),
              Q.render(u, F);
            const z = u.opaque,
              q = u.transmissive,
              re = u.transparent;
            z.length > 0 && ur(z, F, w),
              q.length > 0 && mn(z, q, F, w),
              re.length > 0 && ur(re, F, w),
              M !== null &&
                (Z.updateRenderTargetMipmap(M),
                Z.updateMultisampleRenderTarget(M)),
              F.isScene === !0 && F.onAfterRender(p, F, w),
              ce.buffers.depth.setTest(!0),
              ce.buffers.depth.setMask(!0),
              ce.buffers.color.setMask(!0),
              ce.setPolygonOffset(!1),
              k.resetDefaultState(),
              (S = -1),
              (v = null),
              m.pop(),
              m.length > 0 ? (d = m[m.length - 1]) : (d = null),
              f.pop(),
              f.length > 0 ? (u = f[f.length - 1]) : (u = null);
          });
        function ln(F, w, P, z) {
          if (F.visible === !1) return;
          if (F.layers.test(w.layers)) {
            if (F.isGroup) P = F.renderOrder;
            else if (F.isLOD) F.autoUpdate === !0 && F.update(w);
            else if (F.isLight) d.pushLight(F), F.castShadow && d.pushShadow(F);
            else if (F.isSprite) {
              if (!F.frustumCulled || H.intersectsSprite(F)) {
                z && fe.setFromMatrixPosition(F.matrixWorld).applyMatrix4(ae);
                const Me = N.update(F),
                  xe = F.material;
                xe.visible && u.push(F, Me, xe, P, fe.z, null);
              }
            } else if (F.isImmediateRenderObject)
              z && fe.setFromMatrixPosition(F.matrixWorld).applyMatrix4(ae),
                u.push(F, null, F.material, P, fe.z, null);
            else if (
              (F.isMesh || F.isLine || F.isPoints) &&
              (F.isSkinnedMesh &&
                F.skeleton.frame !== Ie.render.frame &&
                (F.skeleton.update(), (F.skeleton.frame = Ie.render.frame)),
              !F.frustumCulled || H.intersectsObject(F))
            ) {
              z && fe.setFromMatrixPosition(F.matrixWorld).applyMatrix4(ae);
              const Me = N.update(F),
                xe = F.material;
              if (Array.isArray(xe)) {
                const Ce = Me.groups;
                for (let ve = 0, ze = Ce.length; ve < ze; ve++) {
                  const Ae = Ce[ve],
                    Oe = xe[Ae.materialIndex];
                  Oe && Oe.visible && u.push(F, Me, Oe, P, fe.z, Ae);
                }
              } else xe.visible && u.push(F, Me, xe, P, fe.z, null);
            }
          }
          const re = F.children;
          for (let Me = 0, xe = re.length; Me < xe; Me++) ln(re[Me], w, P, z);
        }
        function mn(F, w, P, z) {
          ne === null &&
            (ne = new ai(1024, 1024, {
              generateMipmaps: !0,
              minFilter: ys,
              magFilter: zt,
              wrapS: rn,
              wrapT: rn,
            }));
          const q = p.getRenderTarget();
          p.setRenderTarget(ne),
            p.clear(),
            ur(F, P, z),
            Z.updateRenderTargetMipmap(ne),
            p.setRenderTarget(q),
            ur(w, P, z);
        }
        function ur(F, w, P) {
          const z = w.isScene === !0 ? w.overrideMaterial : null;
          for (let q = 0, re = F.length; q < re; q++) {
            const Me = F[q],
              xe = Me.object,
              Ce = Me.geometry,
              ve = z === null ? Me.material : z,
              ze = Me.group;
            if (P.isArrayCamera) {
              const Ae = P.cameras;
              for (let Oe = 0, Ze = Ae.length; Oe < Ze; Oe++) {
                const mt = Ae[Oe];
                xe.layers.test(mt.layers) &&
                  (ce.viewport(y.copy(mt.viewport)),
                  d.setupLightsView(mt),
                  Wi(xe, w, mt, Ce, ve, ze));
              }
            } else Wi(xe, w, P, Ce, ve, ze);
          }
        }
        function Wi(F, w, P, z, q, re) {
          if (
            (F.onBeforeRender(p, w, P, z, q, re),
            F.modelViewMatrix.multiplyMatrices(
              P.matrixWorldInverse,
              F.matrixWorld
            ),
            F.normalMatrix.getNormalMatrix(F.modelViewMatrix),
            F.isImmediateRenderObject)
          ) {
            const Me = Us(P, w, q, F);
            ce.setMaterial(q), k.reset(), Ne(F, Me);
          } else p.renderBufferDirect(P, w, z, q, F, re);
          F.onAfterRender(p, w, P, z, q, re);
        }
        function Os(F, w, P) {
          w.isScene !== !0 && (w = Fe);
          const z = j.get(F),
            q = d.state.lights,
            re = d.state.shadowsArray,
            Me = q.state.version,
            xe = E.getParameters(F, q.state, re, w, P),
            Ce = E.getProgramCacheKey(xe);
          let ve = z.programs;
          (z.environment = F.isMeshStandardMaterial ? w.environment : null),
            (z.fog = w.fog),
            (z.envMap = te.get(F.envMap || z.environment)),
            ve === void 0 &&
              (F.addEventListener("dispose", _e),
              (ve = new Map()),
              (z.programs = ve));
          let ze = ve.get(Ce);
          if (ze !== void 0) {
            if (z.currentProgram === ze && z.lightsStateVersion === Me)
              return dr(F, xe), ze;
          } else
            (xe.uniforms = E.getUniforms(F)),
              F.onBuild(xe, p),
              F.onBeforeCompile(xe, p),
              (ze = E.acquireProgram(xe, Ce)),
              ve.set(Ce, ze),
              (z.uniforms = xe.uniforms);
          const Ae = z.uniforms;
          ((!F.isShaderMaterial && !F.isRawShaderMaterial) ||
            F.clipping === !0) &&
            (Ae.clippingPlanes = A.uniform),
            dr(F, xe),
            (z.needsLights = Gl(F)),
            (z.lightsStateVersion = Me),
            z.needsLights &&
              ((Ae.ambientLightColor.value = q.state.ambient),
              (Ae.lightProbe.value = q.state.probe),
              (Ae.directionalLights.value = q.state.directional),
              (Ae.directionalLightShadows.value = q.state.directionalShadow),
              (Ae.spotLights.value = q.state.spot),
              (Ae.spotLightShadows.value = q.state.spotShadow),
              (Ae.rectAreaLights.value = q.state.rectArea),
              (Ae.ltc_1.value = q.state.rectAreaLTC1),
              (Ae.ltc_2.value = q.state.rectAreaLTC2),
              (Ae.pointLights.value = q.state.point),
              (Ae.pointLightShadows.value = q.state.pointShadow),
              (Ae.hemisphereLights.value = q.state.hemi),
              (Ae.directionalShadowMap.value = q.state.directionalShadowMap),
              (Ae.directionalShadowMatrix.value =
                q.state.directionalShadowMatrix),
              (Ae.spotShadowMap.value = q.state.spotShadowMap),
              (Ae.spotShadowMatrix.value = q.state.spotShadowMatrix),
              (Ae.pointShadowMap.value = q.state.pointShadowMap),
              (Ae.pointShadowMatrix.value = q.state.pointShadowMatrix));
          const Oe = ze.getUniforms(),
            Ze = Fi.seqWithValue(Oe.seq, Ae);
          return (z.currentProgram = ze), (z.uniformsList = Ze), ze;
        }
        function dr(F, w) {
          const P = j.get(F);
          (P.outputEncoding = w.outputEncoding),
            (P.instancing = w.instancing),
            (P.skinning = w.skinning),
            (P.numClippingPlanes = w.numClippingPlanes),
            (P.numIntersection = w.numClipIntersection),
            (P.vertexAlphas = w.vertexAlphas);
        }
        function Us(F, w, P, z) {
          w.isScene !== !0 && (w = Fe), Z.resetTextureUnits();
          const q = w.fog,
            re = P.isMeshStandardMaterial ? w.environment : null,
            Me = M === null ? p.outputEncoding : M.texture.encoding,
            xe = te.get(P.envMap || re),
            Ce =
              P.vertexColors === !0 &&
              z.geometry &&
              z.geometry.attributes.color &&
              z.geometry.attributes.color.itemSize === 4,
            ve = j.get(P),
            ze = d.state.lights;
          if (J === !0 && (ie === !0 || F !== v)) {
            const $e = F === v && P.id === S;
            A.setState(P, F, $e);
          }
          let Ae = !1;
          P.version === ve.__version
            ? ((ve.needsLights && ve.lightsStateVersion !== ze.state.version) ||
                ve.outputEncoding !== Me ||
                (z.isInstancedMesh && ve.instancing === !1) ||
                (!z.isInstancedMesh && ve.instancing === !0) ||
                (z.isSkinnedMesh && ve.skinning === !1) ||
                (!z.isSkinnedMesh && ve.skinning === !0) ||
                ve.envMap !== xe ||
                (P.fog && ve.fog !== q) ||
                (ve.numClippingPlanes !== void 0 &&
                  (ve.numClippingPlanes !== A.numPlanes ||
                    ve.numIntersection !== A.numIntersection)) ||
                ve.vertexAlphas !== Ce) &&
              (Ae = !0)
            : ((Ae = !0), (ve.__version = P.version));
          let Oe = ve.currentProgram;
          Ae === !0 && (Oe = Os(P, w, z));
          let Ze = !1,
            mt = !1,
            Qt = !1;
          const at = Oe.getUniforms(),
            Et = ve.uniforms;
          if (
            (ce.useProgram(Oe.program) && ((Ze = !0), (mt = !0), (Qt = !0)),
            P.id !== S && ((S = P.id), (mt = !0)),
            Ze || v !== F)
          ) {
            if (
              (at.setValue($, "projectionMatrix", F.projectionMatrix),
              Te.logarithmicDepthBuffer &&
                at.setValue(
                  $,
                  "logDepthBufFC",
                  2 / (Math.log(F.far + 1) / Math.LN2)
                ),
              v !== F && ((v = F), (mt = !0), (Qt = !0)),
              P.isShaderMaterial ||
                P.isMeshPhongMaterial ||
                P.isMeshToonMaterial ||
                P.isMeshStandardMaterial ||
                P.envMap)
            ) {
              const $e = at.map.cameraPosition;
              $e !== void 0 &&
                $e.setValue($, fe.setFromMatrixPosition(F.matrixWorld));
            }
            (P.isMeshPhongMaterial ||
              P.isMeshToonMaterial ||
              P.isMeshLambertMaterial ||
              P.isMeshBasicMaterial ||
              P.isMeshStandardMaterial ||
              P.isShaderMaterial) &&
              at.setValue($, "isOrthographic", F.isOrthographicCamera === !0),
              (P.isMeshPhongMaterial ||
                P.isMeshToonMaterial ||
                P.isMeshLambertMaterial ||
                P.isMeshBasicMaterial ||
                P.isMeshStandardMaterial ||
                P.isShaderMaterial ||
                P.isShadowMaterial ||
                z.isSkinnedMesh) &&
                at.setValue($, "viewMatrix", F.matrixWorldInverse);
          }
          if (z.isSkinnedMesh) {
            at.setOptional($, z, "bindMatrix"),
              at.setOptional($, z, "bindMatrixInverse");
            const $e = z.skeleton;
            $e &&
              (Te.floatVertexTextures
                ? ($e.boneTexture === null && $e.computeBoneTexture(),
                  at.setValue($, "boneTexture", $e.boneTexture, Z),
                  at.setValue($, "boneTextureSize", $e.boneTextureSize))
                : at.setOptional($, $e, "boneMatrices"));
          }
          return (
            (mt || ve.receiveShadow !== z.receiveShadow) &&
              ((ve.receiveShadow = z.receiveShadow),
              at.setValue($, "receiveShadow", z.receiveShadow)),
            mt &&
              (at.setValue($, "toneMappingExposure", p.toneMappingExposure),
              ve.needsLights && Hl(Et, Qt),
              q && P.fog && ee.refreshFogUniforms(Et, q),
              ee.refreshMaterialUniforms(Et, P, b, X, ne),
              Fi.upload($, ve.uniformsList, Et, Z)),
            P.isShaderMaterial &&
              P.uniformsNeedUpdate === !0 &&
              (Fi.upload($, ve.uniformsList, Et, Z),
              (P.uniformsNeedUpdate = !1)),
            P.isSpriteMaterial && at.setValue($, "center", z.center),
            at.setValue($, "modelViewMatrix", z.modelViewMatrix),
            at.setValue($, "normalMatrix", z.normalMatrix),
            at.setValue($, "modelMatrix", z.matrixWorld),
            Oe
          );
        }
        function Hl(F, w) {
          (F.ambientLightColor.needsUpdate = w),
            (F.lightProbe.needsUpdate = w),
            (F.directionalLights.needsUpdate = w),
            (F.directionalLightShadows.needsUpdate = w),
            (F.pointLights.needsUpdate = w),
            (F.pointLightShadows.needsUpdate = w),
            (F.spotLights.needsUpdate = w),
            (F.spotLightShadows.needsUpdate = w),
            (F.rectAreaLights.needsUpdate = w),
            (F.hemisphereLights.needsUpdate = w);
        }
        function Gl(F) {
          return (
            F.isMeshLambertMaterial ||
            F.isMeshToonMaterial ||
            F.isMeshPhongMaterial ||
            F.isMeshStandardMaterial ||
            F.isShadowMaterial ||
            (F.isShaderMaterial && F.lights === !0)
          );
        }
        (this.getActiveCubeFace = function () {
          return x;
        }),
          (this.getActiveMipmapLevel = function () {
            return _;
          }),
          (this.getRenderTarget = function () {
            return M;
          }),
          (this.setRenderTarget = function (F, w = 0, P = 0) {
            (M = F),
              (x = w),
              (_ = P),
              F &&
                j.get(F).__webglFramebuffer === void 0 &&
                Z.setupRenderTarget(F);
            let z = null,
              q = !1,
              re = !1;
            if (F) {
              const xe = F.texture;
              (xe.isDataTexture3D || xe.isDataTexture2DArray) && (re = !0);
              const Ce = j.get(F).__webglFramebuffer;
              F.isWebGLCubeRenderTarget
                ? ((z = Ce[w]), (q = !0))
                : F.isWebGLMultisampleRenderTarget
                ? (z = j.get(F).__webglMultisampledFramebuffer)
                : (z = Ce),
                y.copy(F.viewport),
                C.copy(F.scissor),
                (U = F.scissorTest);
            } else
              y.copy(L).multiplyScalar(b).floor(),
                C.copy(B).multiplyScalar(b).floor(),
                (U = R);
            if (ce.bindFramebuffer(36160, z) && Te.drawBuffers) {
              let xe = !1;
              if (F)
                if (F.isWebGLMultipleRenderTargets) {
                  const Ce = F.texture;
                  if (V.length !== Ce.length || V[0] !== 36064) {
                    for (let ve = 0, ze = Ce.length; ve < ze; ve++)
                      V[ve] = 36064 + ve;
                    (V.length = Ce.length), (xe = !0);
                  }
                } else
                  (V.length !== 1 || V[0] !== 36064) &&
                    ((V[0] = 36064), (V.length = 1), (xe = !0));
              else
                (V.length !== 1 || V[0] !== 1029) &&
                  ((V[0] = 1029), (V.length = 1), (xe = !0));
              xe &&
                (Te.isWebGL2
                  ? $.drawBuffers(V)
                  : Re.get("WEBGL_draw_buffers").drawBuffersWEBGL(V));
            }
            if ((ce.viewport(y), ce.scissor(C), ce.setScissorTest(U), q)) {
              const xe = j.get(F.texture);
              $.framebufferTexture2D(
                36160,
                36064,
                34069 + w,
                xe.__webglTexture,
                P
              );
            } else if (re) {
              const xe = j.get(F.texture),
                Ce = w || 0;
              $.framebufferTextureLayer(
                36160,
                36064,
                xe.__webglTexture,
                P || 0,
                Ce
              );
            }
          }),
          (this.readRenderTargetPixels = function (F, w, P, z, q, re, Me) {
            if (!(F && F.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let xe = j.get(F).__webglFramebuffer;
            if (
              (F.isWebGLCubeRenderTarget && Me !== void 0 && (xe = xe[Me]), xe)
            ) {
              ce.bindFramebuffer(36160, xe);
              try {
                const Ce = F.texture,
                  ve = Ce.format,
                  ze = Ce.type;
                if (ve !== In && le.convert(ve) !== $.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                const Ae =
                  ze === hl &&
                  (Re.has("EXT_color_buffer_half_float") ||
                    (Te.isWebGL2 && Re.has("EXT_color_buffer_float")));
                if (
                  ze !== $h &&
                  le.convert(ze) !== $.getParameter(35738) &&
                  !(
                    ze === Pi &&
                    (Te.isWebGL2 ||
                      Re.has("OES_texture_float") ||
                      Re.has("WEBGL_color_buffer_float"))
                  ) &&
                  !Ae
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                $.checkFramebufferStatus(36160) === 36053
                  ? w >= 0 &&
                    w <= F.width - z &&
                    P >= 0 &&
                    P <= F.height - q &&
                    $.readPixels(w, P, z, q, le.convert(ve), le.convert(ze), re)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                const Ce = M !== null ? j.get(M).__webglFramebuffer : null;
                ce.bindFramebuffer(36160, Ce);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (F, w, P = 0) {
            const z = Math.pow(2, -P),
              q = Math.floor(w.image.width * z),
              re = Math.floor(w.image.height * z);
            let Me = le.convert(w.format);
            Te.isWebGL2 &&
              (Me === 6407 && (Me = 32849), Me === 6408 && (Me = 32856)),
              Z.setTexture2D(w, 0),
              $.copyTexImage2D(3553, P, Me, F.x, F.y, q, re, 0),
              ce.unbindTexture();
          }),
          (this.copyTextureToTexture = function (F, w, P, z = 0) {
            const q = w.image.width,
              re = w.image.height,
              Me = le.convert(P.format),
              xe = le.convert(P.type);
            Z.setTexture2D(P, 0),
              $.pixelStorei(37440, P.flipY),
              $.pixelStorei(37441, P.premultiplyAlpha),
              $.pixelStorei(3317, P.unpackAlignment),
              w.isDataTexture
                ? $.texSubImage2D(
                    3553,
                    z,
                    F.x,
                    F.y,
                    q,
                    re,
                    Me,
                    xe,
                    w.image.data
                  )
                : w.isCompressedTexture
                ? $.compressedTexSubImage2D(
                    3553,
                    z,
                    F.x,
                    F.y,
                    w.mipmaps[0].width,
                    w.mipmaps[0].height,
                    Me,
                    w.mipmaps[0].data
                  )
                : $.texSubImage2D(3553, z, F.x, F.y, Me, xe, w.image),
              z === 0 && P.generateMipmaps && $.generateMipmap(3553),
              ce.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (F, w, P, z, q = 0) {
            if (p.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            const { width: re, height: Me, data: xe } = P.image,
              Ce = le.convert(z.format),
              ve = le.convert(z.type);
            let ze;
            if (z.isDataTexture3D) Z.setTexture3D(z, 0), (ze = 32879);
            else if (z.isDataTexture2DArray)
              Z.setTexture2DArray(z, 0), (ze = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            $.pixelStorei(37440, z.flipY),
              $.pixelStorei(37441, z.premultiplyAlpha),
              $.pixelStorei(3317, z.unpackAlignment);
            const Ae = $.getParameter(3314),
              Oe = $.getParameter(32878),
              Ze = $.getParameter(3316),
              mt = $.getParameter(3315),
              Qt = $.getParameter(32877);
            $.pixelStorei(3314, re),
              $.pixelStorei(32878, Me),
              $.pixelStorei(3316, F.min.x),
              $.pixelStorei(3315, F.min.y),
              $.pixelStorei(32877, F.min.z),
              $.texSubImage3D(
                ze,
                q,
                w.x,
                w.y,
                w.z,
                F.max.x - F.min.x + 1,
                F.max.y - F.min.y + 1,
                F.max.z - F.min.z + 1,
                Ce,
                ve,
                xe
              ),
              $.pixelStorei(3314, Ae),
              $.pixelStorei(32878, Oe),
              $.pixelStorei(3316, Ze),
              $.pixelStorei(3315, mt),
              $.pixelStorei(32877, Qt),
              q === 0 && z.generateMipmaps && $.generateMipmap(ze),
              ce.unbindTexture();
          }),
          (this.initTexture = function (F) {
            Z.setTexture2D(F, 0), ce.unbindTexture();
          }),
          (this.resetState = function () {
            (x = 0), (_ = 0), (M = null), ce.reset(), k.reset();
          }),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      class gb extends ot {}
      gb.prototype.isWebGL1Renderer = !0;
      class Jh extends Ke {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ != "undefined" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
              (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            this.background !== null &&
              (t.object.background = this.background.toJSON(e)),
            this.environment !== null &&
              (t.object.environment = this.environment.toJSON(e)),
            this.fog !== null && (t.object.fog = this.fog.toJSON()),
            t
          );
        }
      }
      Jh.prototype.isScene = !0;
      class Ts {
        constructor(e, t) {
          (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = Ao),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = _n());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = _n()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = _n()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Ts.prototype.isInterleavedBuffer = !0;
      const _t = new G();
      class us {
        constructor(e, t, n, i) {
          (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i === !0);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            (_t.x = this.getX(t)),
              (_t.y = this.getY(t)),
              (_t.z = this.getZ(t)),
              _t.applyMatrix4(e),
              this.setXYZ(t, _t.x, _t.y, _t.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (_t.x = this.getX(t)),
              (_t.y = this.getY(t)),
              (_t.z = this.getZ(t)),
              _t.applyNormalMatrix(e),
              this.setXYZ(t, _t.x, _t.y, _t.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (_t.x = this.getX(t)),
              (_t.y = this.getY(t)),
              (_t.z = this.getZ(t)),
              _t.transformDirection(e),
              this.setXYZ(t, _t.x, _t.y, _t.z);
          return this;
        }
        setX(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset] = t), this
          );
        }
        setY(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 1] = t), this
          );
        }
        setZ(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 2] = t), this
          );
        }
        setW(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 3] = t), this
          );
        }
        getX(e) {
          return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
          return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
          return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
          return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return new bt(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new us(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
        }
      }
      us.prototype.isInterleavedBufferAttribute = !0;
      class ym extends It {
        constructor(e) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        }
      }
      ym.prototype.isSpriteMaterial = !0;
      let Er;
      const Xs = new G(),
        Ar = new G(),
        Lr = new G(),
        Rr = new Se(),
        js = new Se(),
        Mm = new Ge(),
        ma = new G(),
        Ys = new G(),
        ga = new G(),
        Pd = new Se(),
        xc = new Se(),
        Dd = new Se();
      class xb extends Ke {
        constructor(e) {
          if ((super(), (this.type = "Sprite"), Er === void 0)) {
            Er = new ut();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              n = new Ts(t, 5);
            Er.setIndex([0, 1, 2, 0, 2, 3]),
              Er.setAttribute("position", new us(n, 3, 0, !1)),
              Er.setAttribute("uv", new us(n, 2, 3, !1));
          }
          (this.geometry = Er),
            (this.material = e !== void 0 ? e : new ym()),
            (this.center = new Se(0.5, 0.5));
        }
        raycast(e, t) {
          e.camera === null &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Ar.setFromMatrixScale(this.matrixWorld),
            Mm.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            Lr.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              this.material.sizeAttenuation === !1 &&
              Ar.multiplyScalar(-Lr.z);
          const n = this.material.rotation;
          let i, r;
          n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
          const o = this.center;
          xa(ma.set(-0.5, -0.5, 0), Lr, o, Ar, i, r),
            xa(Ys.set(0.5, -0.5, 0), Lr, o, Ar, i, r),
            xa(ga.set(0.5, 0.5, 0), Lr, o, Ar, i, r),
            Pd.set(0, 0),
            xc.set(1, 0),
            Dd.set(1, 1);
          let a = e.ray.intersectTriangle(ma, Ys, ga, !1, Xs);
          if (
            a === null &&
            (xa(Ys.set(-0.5, 0.5, 0), Lr, o, Ar, i, r),
            xc.set(0, 1),
            (a = e.ray.intersectTriangle(ma, ga, Ys, !1, Xs)),
            a === null)
          )
            return;
          const l = e.ray.origin.distanceTo(Xs);
          l < e.near ||
            l > e.far ||
            t.push({
              distance: l,
              point: Xs.clone(),
              uv: yt.getUV(Xs, ma, Ys, ga, Pd, xc, Dd, new Se()),
              face: null,
              object: this,
            });
        }
        copy(e) {
          return (
            super.copy(e),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        }
      }
      xb.prototype.isSprite = !0;
      function xa(s, e, t, n, i, r) {
        Rr.subVectors(s, t).addScalar(0.5).multiply(n),
          i !== void 0
            ? ((js.x = r * Rr.x - i * Rr.y), (js.y = i * Rr.x + r * Rr.y))
            : js.copy(Rr),
          s.copy(e),
          (s.x += js.x),
          (s.y += js.y),
          s.applyMatrix4(Mm);
      }
      const Id = new G(),
        Nd = new rt(),
        Fd = new rt(),
        _b = new G(),
        Bd = new Ge();
      class Kh extends vn {
        constructor(e, t) {
          super(e, t),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new Ge()),
            (this.bindMatrixInverse = new Ge());
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new rt(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            (e.x = t.getX(n)),
              (e.y = t.getY(n)),
              (e.z = t.getZ(n)),
              (e.w = t.getW(n));
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === "attached"
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === "detached"
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          Nd.fromBufferAttribute(i.attributes.skinIndex, e),
            Fd.fromBufferAttribute(i.attributes.skinWeight, e),
            Id.fromBufferAttribute(i.attributes.position, e).applyMatrix4(
              this.bindMatrix
            ),
            t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const o = Fd.getComponent(r);
            if (o !== 0) {
              const a = Nd.getComponent(r);
              Bd.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(_b.copy(Id).applyMatrix4(Bd), o);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      Kh.prototype.isSkinnedMesh = !0;
      class Qh extends Ke {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      Qh.prototype.isBone = !0;
      class bm extends Ht {
        constructor(e, t, n, i, r, o, a, l, c, h, u, d) {
          super(null, o, a, l, c, h, i, r, u, d),
            (this.image = { data: e || null, width: t || 1, height: n || 1 }),
            (this.magFilter = c !== void 0 ? c : zt),
            (this.minFilter = h !== void 0 ? h : zt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      bm.prototype.isDataTexture = !0;
      const zd = new Ge(),
        vb = new Ge();
      class eu {
        constructor(e = [], t = []) {
          (this.uuid = _n()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(e.length * 16)),
            t.length === 0)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let n = 0, i = this.bones.length; n < i; n++)
              this.boneInverses.push(new Ge());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new Ge();
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(n);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n &&
              (n.parent && n.parent.isBone
                ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                  n.matrix.multiply(n.matrixWorld))
                : n.matrix.copy(n.matrixWorld),
              n.matrix.decompose(n.position, n.quaternion, n.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let r = 0, o = e.length; r < o; r++) {
            const a = e[r] ? e[r].matrixWorld : vb;
            zd.multiplyMatrices(a, t[r]), zd.toArray(n, r * 16);
          }
          i !== null && (i.needsUpdate = !0);
        }
        clone() {
          return new eu(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          (e = Qp(e)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new bm(t, e, e, In, Pi);
          return (
            (this.boneMatrices = t),
            (this.boneTexture = n),
            (this.boneTextureSize = e),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e) return i;
          }
        }
        dispose() {
          this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const r = e.bones[n];
            let o = t[r];
            o === void 0 &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", r),
              (o = new Qh())),
              this.bones.push(o),
              this.boneInverses.push(new Ge().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray());
          }
          return e;
        }
      }
      const Od = new Ge(),
        Ud = new Ge(),
        _a = [],
        Zs = new vn();
      class yb extends vn {
        constructor(e, t, n) {
          super(e, t),
            (this.instanceMatrix = new bt(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(e) {
          return (
            super.copy(e),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((Zs.geometry = this.geometry),
            (Zs.material = this.material),
            Zs.material !== void 0)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, Od),
                Ud.multiplyMatrices(n, Od),
                (Zs.matrixWorld = Ud),
                Zs.raycast(e, _a);
              for (let o = 0, a = _a.length; o < a; o++) {
                const l = _a[o];
                (l.instanceId = r), (l.object = this), t.push(l);
              }
              _a.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null &&
            (this.instanceColor = new bt(new Float32Array(this.count * 3), 3)),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      yb.prototype.isInstancedMesh = !0;
      class Es extends It {
        constructor(e) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new Ue(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      Es.prototype.isLineBasicMaterial = !0;
      const Hd = new G(),
        Gd = new G(),
        Vd = new Ge(),
        _c = new bs(),
        va = new ar();
      class wl extends Ke {
        constructor(e = new ut(), t = new Es()) {
          super(),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [0];
              for (let i = 1, r = t.count; i < r; i++)
                Hd.fromBufferAttribute(t, i - 1),
                  Gd.fromBufferAttribute(t, i),
                  (n[i] = n[i - 1]),
                  (n[i] += Hd.distanceTo(Gd));
              e.setAttribute("lineDistance", new Pt(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            va.copy(n.boundingSphere),
            va.applyMatrix4(i),
            (va.radius += r),
            e.ray.intersectsSphere(va) === !1)
          )
            return;
          Vd.copy(i).invert(), _c.copy(e.ray).applyMatrix4(Vd);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new G(),
            h = new G(),
            u = new G(),
            d = new G(),
            f = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const m = n.index,
              g = n.attributes.position;
            if (m !== null) {
              const x = Math.max(0, o.start),
                _ = Math.min(m.count, o.start + o.count);
              for (let M = x, S = _ - 1; M < S; M += f) {
                const v = m.getX(M),
                  y = m.getX(M + 1);
                if (
                  (c.fromBufferAttribute(g, v),
                  h.fromBufferAttribute(g, y),
                  _c.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const U = e.ray.origin.distanceTo(d);
                U < e.near ||
                  U > e.far ||
                  t.push({
                    distance: U,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const x = Math.max(0, o.start),
                _ = Math.min(g.count, o.start + o.count);
              for (let M = x, S = _ - 1; M < S; M += f) {
                if (
                  (c.fromBufferAttribute(g, M),
                  h.fromBufferAttribute(g, M + 1),
                  _c.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const y = e.ray.origin.distanceTo(d);
                y < e.near ||
                  y > e.far ||
                  t.push({
                    distance: y,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      wl.prototype.isLine = !0;
      const kd = new G(),
        Wd = new G();
      class Sl extends wl {
        constructor(e, t) {
          super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [];
              for (let i = 0, r = t.count; i < r; i += 2)
                kd.fromBufferAttribute(t, i),
                  Wd.fromBufferAttribute(t, i + 1),
                  (n[i] = i === 0 ? 0 : n[i - 1]),
                  (n[i + 1] = n[i] + kd.distanceTo(Wd));
              e.setAttribute("lineDistance", new Pt(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      Sl.prototype.isLineSegments = !0;
      class wm extends wl {
        constructor(e, t) {
          super(e, t), (this.type = "LineLoop");
        }
      }
      wm.prototype.isLineLoop = !0;
      class tu extends It {
        constructor(e) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      tu.prototype.isPointsMaterial = !0;
      const $d = new Ge(),
        vh = new bs(),
        ya = new ar(),
        Ma = new G();
      class Sm extends Ke {
        constructor(e = new ut(), t = new tu()) {
          super(),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            ya.copy(n.boundingSphere),
            ya.applyMatrix4(i),
            (ya.radius += r),
            e.ray.intersectsSphere(ya) === !1)
          )
            return;
          $d.copy(i).invert(), vh.copy(e.ray).applyMatrix4($d);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a;
          if (n.isBufferGeometry) {
            const c = n.index,
              u = n.attributes.position;
            if (c !== null) {
              const d = Math.max(0, o.start),
                f = Math.min(c.count, o.start + o.count);
              for (let m = d, p = f; m < p; m++) {
                const g = c.getX(m);
                Ma.fromBufferAttribute(u, g), qd(Ma, g, l, i, e, t, this);
              }
            } else {
              const d = Math.max(0, o.start),
                f = Math.min(u.count, o.start + o.count);
              for (let m = d, p = f; m < p; m++)
                Ma.fromBufferAttribute(u, m), qd(Ma, m, l, i, e, t, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Sm.prototype.isPoints = !0;
      function qd(s, e, t, n, i, r, o) {
        const a = vh.distanceSqToPoint(s);
        if (a < t) {
          const l = new G();
          vh.closestPointToPoint(s, l), l.applyMatrix4(n);
          const c = i.ray.origin.distanceTo(l);
          if (c < i.near || c > i.far) return;
          r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      class Mb extends Ht {
        constructor(e, t, n, i, r, o, a, l, c) {
          super(e, t, n, i, r, o, a, l, c),
            (this.format = a !== void 0 ? a : Ni),
            (this.minFilter = o !== void 0 ? o : sn),
            (this.magFilter = r !== void 0 ? r : sn),
            (this.generateMipmaps = !1);
          const h = this;
          function u() {
            (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
          }
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      Mb.prototype.isVideoTexture = !0;
      class bb extends Ht {
        constructor(e, t, n, i, r, o, a, l, c, h, u, d) {
          super(null, o, a, l, c, h, i, r, u, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      bb.prototype.isCompressedTexture = !0;
      class Tm extends Ht {
        constructor(e, t, n, i, r, o, a, l, c) {
          super(e, t, n, i, r, o, a, l, c), (this.needsUpdate = !0);
        }
      }
      Tm.prototype.isCanvasTexture = !0;
      class wb extends Ht {
        constructor(e, t, n, i, r, o, a, l, c, h) {
          if (((h = h !== void 0 ? h : is), h !== is && h !== To))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && h === is && (n = cl),
            n === void 0 && h === To && (n = xo),
            super(null, i, r, o, a, l, h, n, c),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : zt),
            (this.minFilter = l !== void 0 ? l : zt),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      wb.prototype.isDepthTexture = !0;
      new G();
      new G();
      new G();
      new yt();
      const Sb = {
        triangulate: function (s, e, t) {
          t = t || 2;
          const n = e && e.length,
            i = n ? e[0] * t : s.length;
          let r = Em(s, 0, i, t, !0);
          const o = [];
          if (!r || r.next === r.prev) return o;
          let a, l, c, h, u, d, f;
          if ((n && (r = Rb(s, e, r, t)), s.length > 80 * t)) {
            (a = c = s[0]), (l = h = s[1]);
            for (let m = t; m < i; m += t)
              (u = s[m]),
                (d = s[m + 1]),
                u < a && (a = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            (f = Math.max(c - a, h - l)), (f = f !== 0 ? 1 / f : 0);
          }
          return Ro(r, o, t, a, l, f), o;
        },
      };
      function Em(s, e, t, n, i) {
        let r, o;
        if (i === Hb(s, e, t, n) > 0)
          for (r = e; r < t; r += n) o = Xd(r, s[r], s[r + 1], o);
        else for (r = t - n; r >= e; r -= n) o = Xd(r, s[r], s[r + 1], o);
        return o && Tl(o, o.next) && (Po(o), (o = o.next)), o;
      }
      function Hi(s, e) {
        if (!s) return s;
        e || (e = s);
        let t = s,
          n;
        do
          if (
            ((n = !1),
            !t.steiner && (Tl(t, t.next) || gt(t.prev, t, t.next) === 0))
          ) {
            if ((Po(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
          } else t = t.next;
        while (n || t !== e);
        return e;
      }
      function Ro(s, e, t, n, i, r, o) {
        if (!s) return;
        !o && r && Nb(s, n, i, r);
        let a = s,
          l,
          c;
        for (; s.prev !== s.next; ) {
          if (((l = s.prev), (c = s.next), r ? Eb(s, n, i, r) : Tb(s))) {
            e.push(l.i / t),
              e.push(s.i / t),
              e.push(c.i / t),
              Po(s),
              (s = c.next),
              (a = c.next);
            continue;
          }
          if (((s = c), s === a)) {
            o
              ? o === 1
                ? ((s = Ab(Hi(s), e, t)), Ro(s, e, t, n, i, r, 2))
                : o === 2 && Lb(s, e, t, n, i, r)
              : Ro(Hi(s), e, t, n, i, r, 1);
            break;
          }
        }
      }
      function Tb(s) {
        const e = s.prev,
          t = s,
          n = s.next;
        if (gt(e, t, n) >= 0) return !1;
        let i = s.next.next;
        for (; i !== s.prev; ) {
          if (
            Kr(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            gt(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function Eb(s, e, t, n) {
        const i = s.prev,
          r = s,
          o = s.next;
        if (gt(i, r, o) >= 0) return !1;
        const a = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
          l = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
          c = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
          h = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
          u = yh(a, l, e, t, n),
          d = yh(c, h, e, t, n);
        let f = s.prevZ,
          m = s.nextZ;
        for (; f && f.z >= u && m && m.z <= d; ) {
          if (
            (f !== s.prev &&
              f !== s.next &&
              Kr(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
              gt(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            m !== s.prev &&
              m !== s.next &&
              Kr(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
              gt(m.prev, m, m.next) >= 0)
          )
            return !1;
          m = m.nextZ;
        }
        for (; f && f.z >= u; ) {
          if (
            f !== s.prev &&
            f !== s.next &&
            Kr(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
            gt(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; m && m.z <= d; ) {
          if (
            m !== s.prev &&
            m !== s.next &&
            Kr(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
            gt(m.prev, m, m.next) >= 0
          )
            return !1;
          m = m.nextZ;
        }
        return !0;
      }
      function Ab(s, e, t) {
        let n = s;
        do {
          const i = n.prev,
            r = n.next.next;
          !Tl(i, r) &&
            Am(i, n, n.next, r) &&
            Co(i, r) &&
            Co(r, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(r.i / t),
            Po(n),
            Po(n.next),
            (n = s = r)),
            (n = n.next);
        } while (n !== s);
        return Hi(n);
      }
      function Lb(s, e, t, n, i, r) {
        let o = s;
        do {
          let a = o.next.next;
          for (; a !== o.prev; ) {
            if (o.i !== a.i && zb(o, a)) {
              let l = Lm(o, a);
              (o = Hi(o, o.next)),
                (l = Hi(l, l.next)),
                Ro(o, e, t, n, i, r),
                Ro(l, e, t, n, i, r);
              return;
            }
            a = a.next;
          }
          o = o.next;
        } while (o !== s);
      }
      function Rb(s, e, t, n) {
        const i = [];
        let r, o, a, l, c;
        for (r = 0, o = e.length; r < o; r++)
          (a = e[r] * n),
            (l = r < o - 1 ? e[r + 1] * n : s.length),
            (c = Em(s, a, l, n, !1)),
            c === c.next && (c.steiner = !0),
            i.push(Bb(c));
        for (i.sort(Cb), r = 0; r < i.length; r++)
          Pb(i[r], t), (t = Hi(t, t.next));
        return t;
      }
      function Cb(s, e) {
        return s.x - e.x;
      }
      function Pb(s, e) {
        if (((e = Db(s, e)), e)) {
          const t = Lm(e, s);
          Hi(e, e.next), Hi(t, t.next);
        }
      }
      function Db(s, e) {
        let t = e;
        const n = s.x,
          i = s.y;
        let r = -1 / 0,
          o;
        do {
          if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > r) {
              if (((r = d), d === n)) {
                if (i === t.y) return t;
                if (i === t.next.y) return t.next;
              }
              o = t.x < t.next.x ? t : t.next;
            }
          }
          t = t.next;
        } while (t !== e);
        if (!o) return null;
        if (n === r) return o;
        const a = o,
          l = o.x,
          c = o.y;
        let h = 1 / 0,
          u;
        t = o;
        do
          n >= t.x &&
            t.x >= l &&
            n !== t.x &&
            Kr(i < c ? n : r, i, l, c, i < c ? r : n, i, t.x, t.y) &&
            ((u = Math.abs(i - t.y) / (n - t.x)),
            Co(t, s) &&
              (u < h ||
                (u === h && (t.x > o.x || (t.x === o.x && Ib(o, t))))) &&
              ((o = t), (h = u))),
            (t = t.next);
        while (t !== a);
        return o;
      }
      function Ib(s, e) {
        return gt(s.prev, s, e.prev) < 0 && gt(e.next, s, s.next) < 0;
      }
      function Nb(s, e, t, n) {
        let i = s;
        do
          i.z === null && (i.z = yh(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
        while (i !== s);
        (i.prevZ.nextZ = null), (i.prevZ = null), Fb(i);
      }
      function Fb(s) {
        let e,
          t,
          n,
          i,
          r,
          o,
          a,
          l,
          c = 1;
        do {
          for (t = s, s = null, r = null, o = 0; t; ) {
            for (
              o++, n = t, a = 0, e = 0;
              e < c && (a++, (n = n.nextZ), !!n);
              e++
            );
            for (l = c; a > 0 || (l > 0 && n); )
              a !== 0 && (l === 0 || !n || t.z <= n.z)
                ? ((i = t), (t = t.nextZ), a--)
                : ((i = n), (n = n.nextZ), l--),
                r ? (r.nextZ = i) : (s = i),
                (i.prevZ = r),
                (r = i);
            t = n;
          }
          (r.nextZ = null), (c *= 2);
        } while (o > 1);
        return s;
      }
      function yh(s, e, t, n, i) {
        return (
          (s = 32767 * (s - t) * i),
          (e = 32767 * (e - n) * i),
          (s = (s | (s << 8)) & 16711935),
          (s = (s | (s << 4)) & 252645135),
          (s = (s | (s << 2)) & 858993459),
          (s = (s | (s << 1)) & 1431655765),
          (e = (e | (e << 8)) & 16711935),
          (e = (e | (e << 4)) & 252645135),
          (e = (e | (e << 2)) & 858993459),
          (e = (e | (e << 1)) & 1431655765),
          s | (e << 1)
        );
      }
      function Bb(s) {
        let e = s,
          t = s;
        do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
        while (e !== s);
        return t;
      }
      function Kr(s, e, t, n, i, r, o, a) {
        return (
          (i - o) * (e - a) - (s - o) * (r - a) >= 0 &&
          (s - o) * (n - a) - (t - o) * (e - a) >= 0 &&
          (t - o) * (r - a) - (i - o) * (n - a) >= 0
        );
      }
      function zb(s, e) {
        return (
          s.next.i !== e.i &&
          s.prev.i !== e.i &&
          !Ob(s, e) &&
          ((Co(s, e) &&
            Co(e, s) &&
            Ub(s, e) &&
            (gt(s.prev, s, e.prev) || gt(s, e.prev, e))) ||
            (Tl(s, e) &&
              gt(s.prev, s, s.next) > 0 &&
              gt(e.prev, e, e.next) > 0))
        );
      }
      function gt(s, e, t) {
        return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
      }
      function Tl(s, e) {
        return s.x === e.x && s.y === e.y;
      }
      function Am(s, e, t, n) {
        const i = wa(gt(s, e, t)),
          r = wa(gt(s, e, n)),
          o = wa(gt(t, n, s)),
          a = wa(gt(t, n, e));
        return !!(
          (i !== r && o !== a) ||
          (i === 0 && ba(s, t, e)) ||
          (r === 0 && ba(s, n, e)) ||
          (o === 0 && ba(t, s, n)) ||
          (a === 0 && ba(t, e, n))
        );
      }
      function ba(s, e, t) {
        return (
          e.x <= Math.max(s.x, t.x) &&
          e.x >= Math.min(s.x, t.x) &&
          e.y <= Math.max(s.y, t.y) &&
          e.y >= Math.min(s.y, t.y)
        );
      }
      function wa(s) {
        return s > 0 ? 1 : s < 0 ? -1 : 0;
      }
      function Ob(s, e) {
        let t = s;
        do {
          if (
            t.i !== s.i &&
            t.next.i !== s.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            Am(t, t.next, s, e)
          )
            return !0;
          t = t.next;
        } while (t !== s);
        return !1;
      }
      function Co(s, e) {
        return gt(s.prev, s, s.next) < 0
          ? gt(s, e, s.next) >= 0 && gt(s, s.prev, e) >= 0
          : gt(s, e, s.prev) < 0 || gt(s, s.next, e) < 0;
      }
      function Ub(s, e) {
        let t = s,
          n = !1;
        const i = (s.x + e.x) / 2,
          r = (s.y + e.y) / 2;
        do
          t.y > r != t.next.y > r &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
        while (t !== s);
        return n;
      }
      function Lm(s, e) {
        const t = new Mh(s.i, s.x, s.y),
          n = new Mh(e.i, e.x, e.y),
          i = s.next,
          r = e.prev;
        return (
          (s.next = e),
          (e.prev = s),
          (t.next = i),
          (i.prev = t),
          (n.next = t),
          (t.prev = n),
          (r.next = n),
          (n.prev = r),
          n
        );
      }
      function Xd(s, e, t, n) {
        const i = new Mh(s, e, t);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function Po(s) {
        (s.next.prev = s.prev),
          (s.prev.next = s.next),
          s.prevZ && (s.prevZ.nextZ = s.nextZ),
          s.nextZ && (s.nextZ.prevZ = s.prevZ);
      }
      function Mh(s, e, t) {
        (this.i = s),
          (this.x = e),
          (this.y = t),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function Hb(s, e, t, n) {
        let i = 0;
        for (let r = e, o = t - n; r < t; r += n)
          (i += (s[o] - s[r]) * (s[r + 1] + s[o + 1])), (o = r);
        return i;
      }
      class Bi {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return n * 0.5;
        }
        static isClockWise(e) {
          return Bi.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          jd(e), Yd(n, e);
          let o = e.length;
          t.forEach(jd);
          for (let l = 0; l < t.length; l++)
            i.push(o), (o += t[l].length), Yd(n, t[l]);
          const a = Sb.triangulate(n, i);
          for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
          return r;
        }
      }
      function jd(s) {
        const e = s.length;
        e > 2 && s[e - 1].equals(s[0]) && s.pop();
      }
      function Yd(s, e) {
        for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
      }
      class El extends ut {
        constructor(e, t) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            r = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c);
          }
          this.setAttribute("position", new Pt(i, 3)),
            this.setAttribute("uv", new Pt(r, 2)),
            this.computeVertexNormals();
          function o(a) {
            const l = [],
              c = t.curveSegments !== void 0 ? t.curveSegments : 12,
              h = t.steps !== void 0 ? t.steps : 1;
            let u = t.depth !== void 0 ? t.depth : 100,
              d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
              f = t.bevelThickness !== void 0 ? t.bevelThickness : 6,
              m = t.bevelSize !== void 0 ? t.bevelSize : f - 2,
              p = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
              g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const x = t.extrudePath,
              _ = t.UVGenerator !== void 0 ? t.UVGenerator : Gb;
            t.amount !== void 0 &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (u = t.amount));
            let M,
              S = !1,
              v,
              y,
              C,
              U;
            x &&
              ((M = x.getSpacedPoints(h)),
              (S = !0),
              (d = !1),
              (v = x.computeFrenetFrames(h, !1)),
              (y = new G()),
              (C = new G()),
              (U = new G())),
              d || ((g = 0), (f = 0), (m = 0), (p = 0));
            const K = a.extractPoints(c);
            let X = K.shape;
            const b = K.holes;
            if (!Bi.isClockWise(X)) {
              X = X.reverse();
              for (let j = 0, Z = b.length; j < Z; j++) {
                const te = b[j];
                Bi.isClockWise(te) && (b[j] = te.reverse());
              }
            }
            const I = Bi.triangulateShape(X, b),
              L = X;
            for (let j = 0, Z = b.length; j < Z; j++) {
              const te = b[j];
              X = X.concat(te);
            }
            function B(j, Z, te) {
              return (
                Z || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Z.clone().multiplyScalar(te).add(j)
              );
            }
            const R = X.length,
              V = I.length;
            function H(j, Z, te) {
              let de, se, N;
              const E = j.x - Z.x,
                ee = j.y - Z.y,
                ue = te.x - j.x,
                me = te.y - j.y,
                A = E * E + ee * ee,
                T = E * me - ee * ue;
              if (Math.abs(T) > Number.EPSILON) {
                const Q = Math.sqrt(A),
                  oe = Math.sqrt(ue * ue + me * me),
                  he = Z.x - ee / Q,
                  O = Z.y + E / Q,
                  le = te.x - me / oe,
                  k = te.y + ue / oe,
                  ge = ((le - he) * me - (k - O) * ue) / (E * me - ee * ue);
                (de = he + E * ge - j.x), (se = O + ee * ge - j.y);
                const pe = de * de + se * se;
                if (pe <= 2) return new Se(de, se);
                N = Math.sqrt(pe / 2);
              } else {
                let Q = !1;
                E > Number.EPSILON
                  ? ue > Number.EPSILON && (Q = !0)
                  : E < -Number.EPSILON
                  ? ue < -Number.EPSILON && (Q = !0)
                  : Math.sign(ee) === Math.sign(me) && (Q = !0),
                  Q
                    ? ((de = -ee), (se = E), (N = Math.sqrt(A)))
                    : ((de = E), (se = ee), (N = Math.sqrt(A / 2)));
              }
              return new Se(de / N, se / N);
            }
            const J = [];
            for (
              let j = 0, Z = L.length, te = Z - 1, de = j + 1;
              j < Z;
              j++, te++, de++
            )
              te === Z && (te = 0),
                de === Z && (de = 0),
                (J[j] = H(L[j], L[te], L[de]));
            const ie = [];
            let ne,
              ae = J.concat();
            for (let j = 0, Z = b.length; j < Z; j++) {
              const te = b[j];
              ne = [];
              for (
                let de = 0, se = te.length, N = se - 1, E = de + 1;
                de < se;
                de++, N++, E++
              )
                N === se && (N = 0),
                  E === se && (E = 0),
                  (ne[de] = H(te[de], te[N], te[E]));
              ie.push(ne), (ae = ae.concat(ne));
            }
            for (let j = 0; j < g; j++) {
              const Z = j / g,
                te = f * Math.cos((Z * Math.PI) / 2),
                de = m * Math.sin((Z * Math.PI) / 2) + p;
              for (let se = 0, N = L.length; se < N; se++) {
                const E = B(L[se], J[se], de);
                ke(E.x, E.y, -te);
              }
              for (let se = 0, N = b.length; se < N; se++) {
                const E = b[se];
                ne = ie[se];
                for (let ee = 0, ue = E.length; ee < ue; ee++) {
                  const me = B(E[ee], ne[ee], de);
                  ke(me.x, me.y, -te);
                }
              }
            }
            const fe = m + p;
            for (let j = 0; j < R; j++) {
              const Z = d ? B(X[j], ae[j], fe) : X[j];
              S
                ? (C.copy(v.normals[0]).multiplyScalar(Z.x),
                  y.copy(v.binormals[0]).multiplyScalar(Z.y),
                  U.copy(M[0]).add(C).add(y),
                  ke(U.x, U.y, U.z))
                : ke(Z.x, Z.y, 0);
            }
            for (let j = 1; j <= h; j++)
              for (let Z = 0; Z < R; Z++) {
                const te = d ? B(X[Z], ae[Z], fe) : X[Z];
                S
                  ? (C.copy(v.normals[j]).multiplyScalar(te.x),
                    y.copy(v.binormals[j]).multiplyScalar(te.y),
                    U.copy(M[j]).add(C).add(y),
                    ke(U.x, U.y, U.z))
                  : ke(te.x, te.y, (u / h) * j);
              }
            for (let j = g - 1; j >= 0; j--) {
              const Z = j / g,
                te = f * Math.cos((Z * Math.PI) / 2),
                de = m * Math.sin((Z * Math.PI) / 2) + p;
              for (let se = 0, N = L.length; se < N; se++) {
                const E = B(L[se], J[se], de);
                ke(E.x, E.y, u + te);
              }
              for (let se = 0, N = b.length; se < N; se++) {
                const E = b[se];
                ne = ie[se];
                for (let ee = 0, ue = E.length; ee < ue; ee++) {
                  const me = B(E[ee], ne[ee], de);
                  S
                    ? ke(me.x, me.y + M[h - 1].y, M[h - 1].x + te)
                    : ke(me.x, me.y, u + te);
                }
              }
            }
            Fe(), Ee();
            function Fe() {
              const j = i.length / 3;
              if (d) {
                let Z = 0,
                  te = R * Z;
                for (let de = 0; de < V; de++) {
                  const se = I[de];
                  Re(se[2] + te, se[1] + te, se[0] + te);
                }
                (Z = h + g * 2), (te = R * Z);
                for (let de = 0; de < V; de++) {
                  const se = I[de];
                  Re(se[0] + te, se[1] + te, se[2] + te);
                }
              } else {
                for (let Z = 0; Z < V; Z++) {
                  const te = I[Z];
                  Re(te[2], te[1], te[0]);
                }
                for (let Z = 0; Z < V; Z++) {
                  const te = I[Z];
                  Re(te[0] + R * h, te[1] + R * h, te[2] + R * h);
                }
              }
              n.addGroup(j, i.length / 3 - j, 0);
            }
            function Ee() {
              const j = i.length / 3;
              let Z = 0;
              $(L, Z), (Z += L.length);
              for (let te = 0, de = b.length; te < de; te++) {
                const se = b[te];
                $(se, Z), (Z += se.length);
              }
              n.addGroup(j, i.length / 3 - j, 1);
            }
            function $(j, Z) {
              let te = j.length;
              for (; --te >= 0; ) {
                const de = te;
                let se = te - 1;
                se < 0 && (se = j.length - 1);
                for (let N = 0, E = h + g * 2; N < E; N++) {
                  const ee = R * N,
                    ue = R * (N + 1),
                    me = Z + de + ee,
                    A = Z + se + ee,
                    T = Z + se + ue,
                    Q = Z + de + ue;
                  Te(me, A, T, Q);
                }
              }
            }
            function ke(j, Z, te) {
              l.push(j), l.push(Z), l.push(te);
            }
            function Re(j, Z, te) {
              ce(j), ce(Z), ce(te);
              const de = i.length / 3,
                se = _.generateTopUV(n, i, de - 3, de - 2, de - 1);
              Ie(se[0]), Ie(se[1]), Ie(se[2]);
            }
            function Te(j, Z, te, de) {
              ce(j), ce(Z), ce(de), ce(Z), ce(te), ce(de);
              const se = i.length / 3,
                N = _.generateSideWallUV(n, i, se - 6, se - 3, se - 2, se - 1);
              Ie(N[0]), Ie(N[1]), Ie(N[3]), Ie(N[1]), Ie(N[2]), Ie(N[3]);
            }
            function ce(j) {
              i.push(l[j * 3 + 0]), i.push(l[j * 3 + 1]), i.push(l[j * 3 + 2]);
            }
            function Ie(j) {
              r.push(j.x), r.push(j.y);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
          return Vb(t, n, e);
        }
      }
      const Gb = {
        generateTopUV: function (s, e, t, n, i) {
          const r = e[t * 3],
            o = e[t * 3 + 1],
            a = e[n * 3],
            l = e[n * 3 + 1],
            c = e[i * 3],
            h = e[i * 3 + 1];
          return [new Se(r, o), new Se(a, l), new Se(c, h)];
        },
        generateSideWallUV: function (s, e, t, n, i, r) {
          const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[n * 3],
            h = e[n * 3 + 1],
            u = e[n * 3 + 2],
            d = e[i * 3],
            f = e[i * 3 + 1],
            m = e[i * 3 + 2],
            p = e[r * 3],
            g = e[r * 3 + 1],
            x = e[r * 3 + 2];
          return Math.abs(a - h) < Math.abs(o - c)
            ? [
                new Se(o, 1 - l),
                new Se(c, 1 - u),
                new Se(d, 1 - m),
                new Se(p, 1 - x),
              ]
            : [
                new Se(a, 1 - l),
                new Se(h, 1 - u),
                new Se(f, 1 - m),
                new Se(g, 1 - x),
              ];
        },
      };
      function Vb(s, e, t) {
        if (((t.shapes = []), Array.isArray(s)))
          for (let n = 0, i = s.length; n < i; n++) {
            const r = s[n];
            t.shapes.push(r.uuid);
          }
        else t.shapes.push(s.uuid);
        return (
          e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
          t
        );
      }
      class kb extends ut {
        constructor(e, t = 12) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            r = [],
            o = [];
          let a = 0,
            l = 0;
          if (Array.isArray(e) === !1) c(e);
          else
            for (let h = 0; h < e.length; h++)
              c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
          this.setIndex(n),
            this.setAttribute("position", new Pt(i, 3)),
            this.setAttribute("normal", new Pt(r, 3)),
            this.setAttribute("uv", new Pt(o, 2));
          function c(h) {
            const u = i.length / 3,
              d = h.extractPoints(t);
            let f = d.shape;
            const m = d.holes;
            Bi.isClockWise(f) === !1 && (f = f.reverse());
            for (let g = 0, x = m.length; g < x; g++) {
              const _ = m[g];
              Bi.isClockWise(_) === !0 && (m[g] = _.reverse());
            }
            const p = Bi.triangulateShape(f, m);
            for (let g = 0, x = m.length; g < x; g++) {
              const _ = m[g];
              f = f.concat(_);
            }
            for (let g = 0, x = f.length; g < x; g++) {
              const _ = f[g];
              i.push(_.x, _.y, 0), r.push(0, 0, 1), o.push(_.x, _.y);
            }
            for (let g = 0, x = p.length; g < x; g++) {
              const _ = p[g],
                M = _[0] + u,
                S = _[1] + u,
                v = _[2] + u;
              n.push(M, S, v), (l += 3);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes;
          return Wb(t, e);
        }
      }
      function Wb(s, e) {
        if (((e.shapes = []), Array.isArray(s)))
          for (let t = 0, n = s.length; t < n; t++) {
            const i = s[t];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(s.uuid);
        return e;
      }
      class $b extends It {
        constructor(e) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new Ue(0)),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this;
        }
      }
      $b.prototype.isShadowMaterial = !0;
      class qb extends ir {
        constructor(e) {
          super(e), (this.type = "RawShaderMaterial");
        }
      }
      qb.prototype.isRawShaderMaterial = !0;
      class $o extends It {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new Ue(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ue(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sr),
            (this.normalScale = new Se(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            (this.vertexTangents = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            (this.vertexTangents = e.vertexTangents),
            this
          );
        }
      }
      $o.prototype.isMeshStandardMaterial = !0;
      class nu extends $o {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Se(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, "ior", {
              get: function () {
                return (
                  (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
                );
              },
              set: function (t) {
                this.reflectivity = en((2.5 * (t - 1)) / (t + 1), 0, 1);
              },
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            (this.thickness = 0.01),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new Ue(1, 1, 1)),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.reflectivity = e.reflectivity),
            e.sheen
              ? (this.sheen = (this.sheen || new Ue()).copy(e.sheen))
              : (this.sheen = null),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            this
          );
        }
      }
      nu.prototype.isMeshPhysicalMaterial = !0;
      class Xb extends It {
        constructor(e) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new Ue(16777215)),
            (this.specular = new Ue(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ue(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sr),
            (this.normalScale = new Se(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = yl),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Xb.prototype.isMeshPhongMaterial = !0;
      class jb extends It {
        constructor(e) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ue(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sr),
            (this.normalScale = new Se(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }
      }
      jb.prototype.isMeshToonMaterial = !0;
      class Yb extends It {
        constructor(e) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sr),
            (this.normalScale = new Se(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Yb.prototype.isMeshNormalMaterial = !0;
      class Zb extends It {
        constructor(e) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ue(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = yl),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }
      }
      Zb.prototype.isMeshLambertMaterial = !0;
      class Jb extends It {
        constructor(e) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new Ue(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sr),
            (this.normalScale = new Se(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Jb.prototype.isMeshMatcapMaterial = !0;
      class Kb extends Es {
        constructor(e) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        }
      }
      Kb.prototype.isLineDashedMaterial = !0;
      const dt = {
        arraySlice: function (s, e, t) {
          return dt.isTypedArray(s)
            ? new s.constructor(s.subarray(e, t !== void 0 ? t : s.length))
            : s.slice(e, t);
        },
        convertArray: function (s, e, t) {
          return !s || (!t && s.constructor === e)
            ? s
            : typeof e.BYTES_PER_ELEMENT == "number"
            ? new e(s)
            : Array.prototype.slice.call(s);
        },
        isTypedArray: function (s) {
          return ArrayBuffer.isView(s) && !(s instanceof DataView);
        },
        getKeyframeOrder: function (s) {
          function e(i, r) {
            return s[i] - s[r];
          }
          const t = s.length,
            n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = i;
          return n.sort(e), n;
        },
        sortedArray: function (s, e, t) {
          const n = s.length,
            i = new s.constructor(n);
          for (let r = 0, o = 0; o !== n; ++r) {
            const a = t[r] * e;
            for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
          }
          return i;
        },
        flattenJSON: function (s, e, t, n) {
          let i = 1,
            r = s[0];
          for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
          if (r === void 0) return;
          let o = r[n];
          if (o !== void 0)
            if (Array.isArray(o))
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push.apply(t, o)),
                  (r = s[i++]);
              while (r !== void 0);
            else if (o.toArray !== void 0)
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), o.toArray(t, t.length)),
                  (r = s[i++]);
              while (r !== void 0);
            else
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push(o)),
                  (r = s[i++]);
              while (r !== void 0);
        },
        subclip: function (s, e, t, n, i = 30) {
          const r = s.clone();
          r.name = e;
          const o = [];
          for (let l = 0; l < r.tracks.length; ++l) {
            const c = r.tracks[l],
              h = c.getValueSize(),
              u = [],
              d = [];
            for (let f = 0; f < c.times.length; ++f) {
              const m = c.times[f] * i;
              if (!(m < t || m >= n)) {
                u.push(c.times[f]);
                for (let p = 0; p < h; ++p) d.push(c.values[f * h + p]);
              }
            }
            u.length !== 0 &&
              ((c.times = dt.convertArray(u, c.times.constructor)),
              (c.values = dt.convertArray(d, c.values.constructor)),
              o.push(c));
          }
          r.tracks = o;
          let a = 1 / 0;
          for (let l = 0; l < r.tracks.length; ++l)
            a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
          for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
          return r.resetDuration(), r;
        },
        makeClipAdditive: function (s, e = 0, t = s, n = 30) {
          n <= 0 && (n = 30);
          const i = t.tracks.length,
            r = e / n;
          for (let o = 0; o < i; ++o) {
            const a = t.tracks[o],
              l = a.ValueTypeName;
            if (l === "bool" || l === "string") continue;
            const c = s.tracks.find(function (x) {
              return x.name === a.name && x.ValueTypeName === l;
            });
            if (c === void 0) continue;
            let h = 0;
            const u = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (h = u / 3);
            let d = 0;
            const f = c.getValueSize();
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (d = f / 3);
            const m = a.times.length - 1;
            let p;
            if (r <= a.times[0]) {
              const x = h,
                _ = u - h;
              p = dt.arraySlice(a.values, x, _);
            } else if (r >= a.times[m]) {
              const x = m * u + h,
                _ = x + u - h;
              p = dt.arraySlice(a.values, x, _);
            } else {
              const x = a.createInterpolant(),
                _ = h,
                M = u - h;
              x.evaluate(r), (p = dt.arraySlice(x.resultBuffer, _, M));
            }
            l === "quaternion" &&
              new Zt().fromArray(p).normalize().conjugate().toArray(p);
            const g = c.times.length;
            for (let x = 0; x < g; ++x) {
              const _ = x * f + d;
              if (l === "quaternion")
                Zt.multiplyQuaternionsFlat(c.values, _, p, 0, c.values, _);
              else {
                const M = f - d * 2;
                for (let S = 0; S < M; ++S) c.values[_ + S] -= p[S];
              }
            }
          }
          return (s.blendMode = Jp), s;
        },
      };
      class ci {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (i === void 0) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (!(e >= r)) {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let l = n - 2; ; ) {
                    if (r === void 0)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === l) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (o = n), (n = 0);
                  break n;
                }
                break e;
              }
              for (; n < o; ) {
                const a = (n + o) >>> 1;
                e < t[a] ? (o = a) : (n = a + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), r === void 0))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (i === void 0)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let o = 0; o !== i; ++o) t[o] = n[r + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      ci.prototype.beforeStart_ = ci.prototype.copySampleValue_;
      ci.prototype.afterEnd_ = ci.prototype.copySampleValue_;
      class Qb extends ci {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Zr, endingEnd: Zr });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            o = e + 1,
            a = i[r],
            l = i[o];
          if (a === void 0)
            switch (this.getSettings_().endingStart) {
              case Jr:
                (r = e), (a = 2 * t - n);
                break;
              case ul:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (l === void 0)
            switch (this.getSettings_().endingEnd) {
              case Jr:
                (o = e), (l = 2 * n - t);
                break;
              case ul:
                (o = 1), (l = n + i[1] - i[0]);
                break;
              default:
                (o = e - 1), (l = t);
            }
          const c = (n - t) * 0.5,
            h = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - n)),
            (this._offsetPrev = r * h),
            (this._offsetNext = o * h);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = this._offsetPrev,
            u = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            m = (n - t) / (i - t),
            p = m * m,
            g = p * m,
            x = -d * g + 2 * d * p - d * m,
            _ = (1 + d) * g + (-1.5 - 2 * d) * p + (-0.5 + d) * m + 1,
            M = (-1 - f) * g + (1.5 + f) * p + 0.5 * m,
            S = f * g - f * p;
          for (let v = 0; v !== a; ++v)
            r[v] = x * o[h + v] + _ * o[c + v] + M * o[l + v] + S * o[u + v];
          return r;
        }
      }
      class Rm extends ci {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = (n - t) / (i - t),
            u = 1 - h;
          for (let d = 0; d !== a; ++d) r[d] = o[c + d] * u + o[l + d] * h;
          return r;
        }
      }
      class ew extends ci {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class $n {
        constructor(e, t, n, i) {
          if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = dt.convertArray(t, this.TimeBufferType)),
            (this.values = dt.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: dt.convertArray(e.times, Array),
              values: dt.convertArray(e.values, Array),
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new ew(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new Rm(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new Qb(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Eo:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case cs:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Wl:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Eo;
            case this.InterpolantFactoryMethodLinear:
              return cs;
            case this.InterpolantFactoryMethodSmooth:
              return Wl;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            o = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; o !== -1 && n[o] > t; ) --o;
          if ((++o, r !== 0 || o !== i)) {
            r >= o && ((o = Math.max(o, 1)), (r = o - 1));
            const a = this.getValueSize();
            (this.times = dt.arraySlice(n, r, o)),
              (this.values = dt.arraySlice(this.values, r * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          r === 0 &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l
              ),
                (e = !1);
              break;
            }
            if (o !== null && o > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                o
              ),
                (e = !1);
              break;
            }
            o = l;
          }
          if (i !== void 0 && dt.isTypedArray(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
              const c = i[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = dt.arraySlice(this.times),
            t = dt.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === Wl,
            r = e.length - 1;
          let o = 1;
          for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a],
              h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0]))
              if (i) l = !0;
              else {
                const u = a * n,
                  d = u - n,
                  f = u + n;
                for (let m = 0; m !== n; ++m) {
                  const p = t[u + m];
                  if (p !== t[d + m] || p !== t[f + m]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== o) {
                e[o] = e[a];
                const u = a * n,
                  d = o * n;
                for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
              }
              ++o;
            }
          }
          if (r > 0) {
            e[o] = e[r];
            for (let a = r * n, l = o * n, c = 0; c !== n; ++c)
              t[l + c] = t[a + c];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = dt.arraySlice(e, 0, o)),
                (this.values = dt.arraySlice(t, 0, o * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = dt.arraySlice(this.times, 0),
            t = dt.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, e, t);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      $n.prototype.TimeBufferType = Float32Array;
      $n.prototype.ValueBufferType = Float32Array;
      $n.prototype.DefaultInterpolation = cs;
      class As extends $n {}
      As.prototype.ValueTypeName = "bool";
      As.prototype.ValueBufferType = Array;
      As.prototype.DefaultInterpolation = Eo;
      As.prototype.InterpolantFactoryMethodLinear = void 0;
      As.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Cm extends $n {}
      Cm.prototype.ValueTypeName = "color";
      class Do extends $n {}
      Do.prototype.ValueTypeName = "number";
      class tw extends ci {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (n - t) / (i - t);
          let c = e * a;
          for (let h = c + a; c !== h; c += 4)
            Zt.slerpFlat(r, 0, o, c - a, o, c, l);
          return r;
        }
      }
      class Ls extends $n {
        InterpolantFactoryMethodLinear(e) {
          return new tw(this.times, this.values, this.getValueSize(), e);
        }
      }
      Ls.prototype.ValueTypeName = "quaternion";
      Ls.prototype.DefaultInterpolation = cs;
      Ls.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Rs extends $n {}
      Rs.prototype.ValueTypeName = "string";
      Rs.prototype.ValueBufferType = Array;
      Rs.prototype.DefaultInterpolation = Eo;
      Rs.prototype.InterpolantFactoryMethodLinear = void 0;
      Rs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Io extends $n {}
      Io.prototype.ValueTypeName = "vector";
      class bh {
        constructor(e, t = -1, n, i = qh) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = _n()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let o = 0, a = n.length; o !== a; ++o) t.push(iw(n[o]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let r = 0, o = n.length; r !== o; ++r) t.push($n.toJSON(n[r]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            o = [];
          for (let a = 0; a < r; a++) {
            let l = [],
              c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            const h = dt.getKeyframeOrder(l);
            (l = dt.sortedArray(l, 1, h)),
              (c = dt.sortedArray(c, 1, h)),
              !i && l[0] === 0 && (l.push(r), c.push(c[0])),
              o.push(
                new Do(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, o);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = c.name.match(r);
            if (h && h.length > 1) {
              const u = h[1];
              let d = i[u];
              d || (i[u] = d = []), d.push(c);
            }
          }
          const o = [];
          for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
          return o;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (u, d, f, m, p) {
              if (f.length !== 0) {
                const g = [],
                  x = [];
                dt.flattenJSON(f, g, x, m),
                  g.length !== 0 && p.push(new u(d, g, x));
              }
            },
            i = [],
            r = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0))
              if (d[0].morphTargets) {
                const f = {};
                let m;
                for (m = 0; m < d.length; m++)
                  if (d[m].morphTargets)
                    for (let p = 0; p < d[m].morphTargets.length; p++)
                      f[d[m].morphTargets[p]] = -1;
                for (const p in f) {
                  const g = [],
                    x = [];
                  for (let _ = 0; _ !== d[m].morphTargets.length; ++_) {
                    const M = d[m];
                    g.push(M.time), x.push(M.morphTarget === p ? 1 : 0);
                  }
                  i.push(new Do(".morphTargetInfluence[" + p + "]", g, x));
                }
                l = f.length * (o || 1);
              } else {
                const f = ".bones[" + t[u].name + "]";
                n(Io, f + ".position", d, "pos", i),
                  n(Ls, f + ".quaternion", d, "rot", i),
                  n(Io, f + ".scale", d, "scl", i);
              }
          }
          return i.length === 0 ? null : new this(r, l, i, a);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function nw(s) {
        switch (s.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Do;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Io;
          case "color":
            return Cm;
          case "quaternion":
            return Ls;
          case "bool":
          case "boolean":
            return As;
          case "string":
            return Rs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
      }
      function iw(s) {
        if (s.type === void 0)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = nw(s.type);
        if (s.times === void 0) {
          const t = [],
            n = [];
          dt.flattenJSON(s.keys, t, n, "value"), (s.times = t), (s.values = n);
        }
        return e.parse !== void 0
          ? e.parse(s)
          : new e(s.name, s.times, s.values, s.interpolation);
      }
      const ds = {
        enabled: !1,
        files: {},
        add: function (s, e) {
          this.enabled !== !1 && (this.files[s] = e);
        },
        get: function (s) {
          if (this.enabled !== !1) return this.files[s];
        },
        remove: function (s) {
          delete this.files[s];
        },
        clear: function () {
          this.files = {};
        },
      };
      class rw {
        constructor(e, t, n) {
          const i = this;
          let r = !1,
            o = 0,
            a = 0,
            l;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (h) {
              a++,
                r === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
                (r = !0);
            }),
            (this.itemEnd = function (h) {
              o++,
                i.onProgress !== void 0 && i.onProgress(h, o, a),
                o === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
            }),
            (this.itemError = function (h) {
              i.onError !== void 0 && i.onError(h);
            }),
            (this.resolveURL = function (h) {
              return l ? l(h) : h;
            }),
            (this.setURLModifier = function (h) {
              return (l = h), this;
            }),
            (this.addHandler = function (h, u) {
              return c.push(h, u), this;
            }),
            (this.removeHandler = function (h) {
              const u = c.indexOf(h);
              return u !== -1 && c.splice(u, 2), this;
            }),
            (this.getHandler = function (h) {
              for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u],
                  m = c[u + 1];
                if ((f.global && (f.lastIndex = 0), f.test(h))) return m;
              }
              return null;
            });
        }
      }
      const sw = new rw();
      class ui {
        constructor(e) {
          (this.manager = e !== void 0 ? e : sw),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      const En = {};
      class iu extends ui {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = ds.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          if (En[e] !== void 0) {
            En[e].push({ onLoad: t, onProgress: n, onError: i });
            return;
          }
          const a = /^data:(.*?)(;base64)?,(.*)$/,
            l = e.match(a);
          let c;
          if (l) {
            const h = l[1],
              u = !!l[2];
            let d = l[3];
            (d = decodeURIComponent(d)), u && (d = atob(d));
            try {
              let f;
              const m = (this.responseType || "").toLowerCase();
              switch (m) {
                case "arraybuffer":
                case "blob":
                  const p = new Uint8Array(d.length);
                  for (let x = 0; x < d.length; x++) p[x] = d.charCodeAt(x);
                  m === "blob"
                    ? (f = new Blob([p.buffer], { type: h }))
                    : (f = p.buffer);
                  break;
                case "document":
                  f = new DOMParser().parseFromString(d, h);
                  break;
                case "json":
                  f = JSON.parse(d);
                  break;
                default:
                  f = d;
                  break;
              }
              setTimeout(function () {
                t && t(f), r.manager.itemEnd(e);
              }, 0);
            } catch (f) {
              setTimeout(function () {
                i && i(f), r.manager.itemError(e), r.manager.itemEnd(e);
              }, 0);
            }
          } else {
            (En[e] = []),
              En[e].push({ onLoad: t, onProgress: n, onError: i }),
              (c = new XMLHttpRequest()),
              c.open("GET", e, !0),
              c.addEventListener(
                "load",
                function (h) {
                  const u = this.response,
                    d = En[e];
                  if (
                    (delete En[e], this.status === 200 || this.status === 0)
                  ) {
                    this.status === 0 &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                      ds.add(e, u);
                    for (let f = 0, m = d.length; f < m; f++) {
                      const p = d[f];
                      p.onLoad && p.onLoad(u);
                    }
                    r.manager.itemEnd(e);
                  } else {
                    for (let f = 0, m = d.length; f < m; f++) {
                      const p = d[f];
                      p.onError && p.onError(h);
                    }
                    r.manager.itemError(e), r.manager.itemEnd(e);
                  }
                },
                !1
              ),
              c.addEventListener(
                "progress",
                function (h) {
                  const u = En[e];
                  for (let d = 0, f = u.length; d < f; d++) {
                    const m = u[d];
                    m.onProgress && m.onProgress(h);
                  }
                },
                !1
              ),
              c.addEventListener(
                "error",
                function (h) {
                  const u = En[e];
                  delete En[e];
                  for (let d = 0, f = u.length; d < f; d++) {
                    const m = u[d];
                    m.onError && m.onError(h);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              c.addEventListener(
                "abort",
                function (h) {
                  const u = En[e];
                  delete En[e];
                  for (let d = 0, f = u.length; d < f; d++) {
                    const m = u[d];
                    m.onError && m.onError(h);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              this.responseType !== void 0 &&
                (c.responseType = this.responseType),
              this.withCredentials !== void 0 &&
                (c.withCredentials = this.withCredentials),
              c.overrideMimeType &&
                c.overrideMimeType(
                  this.mimeType !== void 0 ? this.mimeType : "text/plain"
                );
            for (const h in this.requestHeader)
              c.setRequestHeader(h, this.requestHeader[h]);
            c.send(null);
          }
          return r.manager.itemStart(e), c;
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class Pm extends ui {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = ds.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function l() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1),
              ds.add(e, this),
              t && t(this),
              r.manager.itemEnd(e);
          }
          function c(h) {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1),
              i && i(h),
              r.manager.itemError(e),
              r.manager.itemEnd(e);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            e.substr(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class ow extends ui {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Ml(),
            o = new Pm(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let a = 0;
          function l(c) {
            o.load(
              e[c],
              function (h) {
                (r.images[c] = h),
                  a++,
                  a === 6 && ((r.needsUpdate = !0), t && t(r));
              },
              void 0,
              i
            );
          }
          for (let c = 0; c < e.length; ++c) l(c);
          return r;
        }
      }
      class Dm extends ui {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Ht(),
            o = new Pm(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                r.image = a;
                const l =
                  e.search(/\.jpe?g($|\?)/i) > 0 ||
                  e.search(/^data\:image\/jpeg/) === 0;
                (r.format = l ? Ni : In),
                  (r.needsUpdate = !0),
                  t !== void 0 && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class yn {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let o = 1; o <= e; o++)
            (n = this.getPoint(o / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let o;
          t ? (o = t) : (o = e * n[r - 1]);
          let a = 0,
            l = r - 1,
            c;
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - o), c < 0))
              a = i + 1;
            else if (c > 0) l = i - 1;
            else {
              l = i;
              break;
            }
          if (((i = l), n[i] === o)) return i / (r - 1);
          const h = n[i],
            d = n[i + 1] - h,
            f = (o - h) / d;
          return (i + f) / (r - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4,
            r = e + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const o = this.getPoint(i),
            a = this.getPoint(r),
            l = t || (o.isVector2 ? new Se() : new G());
          return l.copy(a).sub(o).normalize(), l;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new G(),
            i = [],
            r = [],
            o = [],
            a = new G(),
            l = new Ge();
          for (let f = 0; f <= e; f++) {
            const m = f / e;
            (i[f] = this.getTangentAt(m, new G())), i[f].normalize();
          }
          (r[0] = new G()), (o[0] = new G());
          let c = Number.MAX_VALUE;
          const h = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
          h <= c && ((c = h), n.set(1, 0, 0)),
            u <= c && ((c = u), n.set(0, 1, 0)),
            d <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], r[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((r[f] = r[f - 1].clone()),
              (o[f] = o[f - 1].clone()),
              a.crossVectors(i[f - 1], i[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const m = Math.acos(en(i[f - 1].dot(i[f]), -1, 1));
              r[f].applyMatrix4(l.makeRotationAxis(a, m));
            }
            o[f].crossVectors(i[f], r[f]);
          }
          if (t === !0) {
            let f = Math.acos(en(r[0].dot(r[e]), -1, 1));
            (f /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let m = 1; m <= e; m++)
              r[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)),
                o[m].crossVectors(i[m], r[m]);
          }
          return { tangents: i, normals: r, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class Al extends yn {
        constructor(
          e = 0,
          t = 0,
          n = 1,
          i = 1,
          r = 0,
          o = Math.PI * 2,
          a = !1,
          l = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = o),
            (this.aClockwise = a),
            (this.aRotation = l);
        }
        getPoint(e, t) {
          const n = t || new Se(),
            i = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const o = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (o ? (r = 0) : (r = i)),
            this.aClockwise === !0 && !o && (r === i ? (r = -i) : (r = r - i));
          const a = this.aStartAngle + e * r;
          let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
          if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation),
              u = Math.sin(this.aRotation),
              d = l - this.aX,
              f = c - this.aY;
            (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
          }
          return n.set(l, c);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
      }
      Al.prototype.isEllipseCurve = !0;
      class Im extends Al {
        constructor(e, t, n, i, r, o) {
          super(e, t, n, n, i, r, o), (this.type = "ArcCurve");
        }
      }
      Im.prototype.isArcCurve = !0;
      function ru() {
        let s = 0,
          e = 0,
          t = 0,
          n = 0;
        function i(r, o, a, l) {
          (s = r),
            (e = a),
            (t = -3 * r + 3 * o - 2 * a - l),
            (n = 2 * r - 2 * o + a + l);
        }
        return {
          initCatmullRom: function (r, o, a, l, c) {
            i(o, a, c * (a - r), c * (l - o));
          },
          initNonuniformCatmullRom: function (r, o, a, l, c, h, u) {
            let d = (o - r) / c - (a - r) / (c + h) + (a - o) / h,
              f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            (d *= h), (f *= h), i(o, a, d, f);
          },
          calc: function (r) {
            const o = r * r,
              a = o * r;
            return s + e * r + t * o + n * a;
          },
        };
      }
      const Sa = new G(),
        vc = new ru(),
        yc = new ru(),
        Mc = new ru();
      class Nm extends yn {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(e, t = new G()) {
          const n = t,
            i = this.points,
            r = i.length,
            o = (r - (this.closed ? 0 : 1)) * e;
          let a = Math.floor(o),
            l = o - a;
          this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r)
            : l === 0 && a === r - 1 && ((a = r - 2), (l = 1));
          let c, h;
          this.closed || a > 0
            ? (c = i[(a - 1) % r])
            : (Sa.subVectors(i[0], i[1]).add(i[0]), (c = Sa));
          const u = i[a % r],
            d = i[(a + 1) % r];
          if (
            (this.closed || a + 2 < r
              ? (h = i[(a + 2) % r])
              : (Sa.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (h = Sa)),
            this.curveType === "centripetal" || this.curveType === "chordal")
          ) {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let m = Math.pow(c.distanceToSquared(u), f),
              p = Math.pow(u.distanceToSquared(d), f),
              g = Math.pow(d.distanceToSquared(h), f);
            p < 1e-4 && (p = 1),
              m < 1e-4 && (m = p),
              g < 1e-4 && (g = p),
              vc.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, p, g),
              yc.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, p, g),
              Mc.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, p, g);
          } else
            this.curveType === "catmullrom" &&
              (vc.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
              yc.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
              Mc.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
          return n.set(vc.calc(l), yc.calc(l), Mc.calc(l)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new G().fromArray(i));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
      }
      Nm.prototype.isCatmullRomCurve3 = !0;
      function Zd(s, e, t, n, i) {
        const r = (n - e) * 0.5,
          o = (i - t) * 0.5,
          a = s * s,
          l = s * a;
        return (
          (2 * t - 2 * n + r + o) * l +
          (-3 * t + 3 * n - 2 * r - o) * a +
          r * s +
          t
        );
      }
      function aw(s, e) {
        const t = 1 - s;
        return t * t * e;
      }
      function lw(s, e) {
        return 2 * (1 - s) * s * e;
      }
      function cw(s, e) {
        return s * s * e;
      }
      function yo(s, e, t, n) {
        return aw(s, e) + lw(s, t) + cw(s, n);
      }
      function hw(s, e) {
        const t = 1 - s;
        return t * t * t * e;
      }
      function uw(s, e) {
        const t = 1 - s;
        return 3 * t * t * s * e;
      }
      function dw(s, e) {
        return 3 * (1 - s) * s * s * e;
      }
      function fw(s, e) {
        return s * s * s * e;
      }
      function Mo(s, e, t, n, i) {
        return hw(s, e) + uw(s, t) + dw(s, n) + fw(s, i);
      }
      class su extends yn {
        constructor(e = new Se(), t = new Se(), n = new Se(), i = new Se()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new Se()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return n.set(Mo(e, i.x, r.x, o.x, a.x), Mo(e, i.y, r.y, o.y, a.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      su.prototype.isCubicBezierCurve = !0;
      class Fm extends yn {
        constructor(e = new G(), t = new G(), n = new G(), i = new G()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new G()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return (
            n.set(
              Mo(e, i.x, r.x, o.x, a.x),
              Mo(e, i.y, r.y, o.y, a.y),
              Mo(e, i.z, r.z, o.z, a.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      Fm.prototype.isCubicBezierCurve3 = !0;
      class Ll extends yn {
        constructor(e = new Se(), t = new Se()) {
          super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new Se()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const n = t || new Se();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Ll.prototype.isLineCurve = !0;
      class pw extends yn {
        constructor(e = new G(), t = new G()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new G()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      class ou extends yn {
        constructor(e = new Se(), t = new Se(), n = new Se()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new Se()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return n.set(yo(e, i.x, r.x, o.x), yo(e, i.y, r.y, o.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      ou.prototype.isQuadraticBezierCurve = !0;
      class Bm extends yn {
        constructor(e = new G(), t = new G(), n = new G()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new G()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return (
            n.set(
              yo(e, i.x, r.x, o.x),
              yo(e, i.y, r.y, o.y),
              yo(e, i.z, r.z, o.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Bm.prototype.isQuadraticBezierCurve3 = !0;
      class au extends yn {
        constructor(e = []) {
          super(), (this.type = "SplineCurve"), (this.points = e);
        }
        getPoint(e, t = new Se()) {
          const n = t,
            i = this.points,
            r = (i.length - 1) * e,
            o = Math.floor(r),
            a = r - o,
            l = i[o === 0 ? o : o - 1],
            c = i[o],
            h = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
          return n.set(Zd(a, l.x, c.x, h.x, u.x), Zd(a, l.y, c.y, h.y, u.y)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new Se().fromArray(i));
          }
          return this;
        }
      }
      au.prototype.isSplineCurve = !0;
      var mw = Object.freeze({
        __proto__: null,
        ArcCurve: Im,
        CatmullRomCurve3: Nm,
        CubicBezierCurve: su,
        CubicBezierCurve3: Fm,
        EllipseCurve: Al,
        LineCurve: Ll,
        LineCurve3: pw,
        QuadraticBezierCurve: ou,
        QuadraticBezierCurve3: Bm,
        SplineCurve: au,
      });
      class gw extends yn {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new Ll(t, e));
        }
        getPoint(e) {
          const t = e * this.getLength(),
            n = this.getCurveLengths();
          let i = 0;
          for (; i < n.length; ) {
            if (n[i] >= t) {
              const r = n[i] - t,
                o = this.curves[i],
                a = o.getLength(),
                l = a === 0 ? 0 : 1 - r / a;
              return o.getPointAt(l);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const o = r[i],
              a =
                o && o.isEllipseCurve
                  ? e * 2
                  : o && (o.isLineCurve || o.isLineCurve3)
                  ? 1
                  : o && o.isSplineCurve
                  ? e * o.points.length
                  : e,
              l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
              const h = l[c];
              (n && n.equals(h)) || (t.push(h), (n = h));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        }
        copy(e) {
          super.copy(e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone());
          }
          return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new mw[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class wh extends gw {
        constructor(e) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new Se()),
            e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const n = new Ll(this.currentPoint.clone(), new Se(e, t));
          return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          const r = new ou(
            this.currentPoint.clone(),
            new Se(e, t),
            new Se(n, i)
          );
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, o) {
          const a = new su(
            this.currentPoint.clone(),
            new Se(e, t),
            new Se(n, i),
            new Se(r, o)
          );
          return this.curves.push(a), this.currentPoint.set(r, o), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            n = new au(t);
          return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
          );
        }
        arc(e, t, n, i, r, o) {
          const a = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absarc(e + a, t + l, n, i, r, o), this;
        }
        absarc(e, t, n, i, r, o) {
          return this.absellipse(e, t, n, n, i, r, o), this;
        }
        ellipse(e, t, n, i, r, o, a, l) {
          const c = this.currentPoint.x,
            h = this.currentPoint.y;
          return this.absellipse(e + c, t + h, n, i, r, o, a, l), this;
        }
        absellipse(e, t, n, i, r, o, a, l) {
          const c = new Al(e, t, n, i, r, o, a, l);
          if (this.curves.length > 0) {
            const u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
          }
          this.curves.push(c);
          const h = c.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
          );
        }
      }
      class lu extends wh {
        constructor(e) {
          super(e),
            (this.uuid = _n()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(e) {
          const t = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
          super.copy(e), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.uuid = this.uuid), (e.holes = []);
          for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new wh().fromJSON(i));
          }
          return this;
        }
      }
      class kn extends Ke {
        constructor(e, t = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new Ue(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      kn.prototype.isLight = !0;
      class xw extends kn {
        constructor(e, t, n) {
          super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Ke.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new Ue(t));
        }
        copy(e) {
          return (
            kn.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
          );
        }
      }
      xw.prototype.isHemisphereLight = !0;
      const Jd = new Ge(),
        Kd = new G(),
        Qd = new G();
      class cu {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.mapSize = new Se(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Ge()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new bl()),
            (this._frameExtents = new Se(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new rt(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          Kd.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(Kd),
            Qd.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Qd),
            t.updateMatrixWorld(),
            Jd.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Jd),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class zm extends cu {
        constructor() {
          super(new tn(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = Lo * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n !== t.fov || i !== t.aspect || r !== t.far) &&
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      zm.prototype.isSpotLightShadow = !0;
      class Om extends kn {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 1) {
          super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(Ke.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ke()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = o),
            (this.shadow = new zm());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Om.prototype.isSpotLight = !0;
      const ef = new Ge(),
        Js = new G(),
        bc = new G();
      class Um extends cu {
        constructor() {
          super(new tn(90, 1, 0.5, 500)),
            (this._frameExtents = new Se(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new rt(2, 1, 1, 1),
              new rt(0, 1, 1, 1),
              new rt(3, 1, 1, 1),
              new rt(1, 1, 1, 1),
              new rt(3, 0, 1, 1),
              new rt(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new G(1, 0, 0),
              new G(-1, 0, 0),
              new G(0, 0, 1),
              new G(0, 0, -1),
              new G(0, 1, 0),
              new G(0, -1, 0),
            ]),
            (this._cubeUps = [
              new G(0, 1, 0),
              new G(0, 1, 0),
              new G(0, 1, 0),
              new G(0, 1, 0),
              new G(0, 0, 1),
              new G(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            Js.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(Js),
            bc.copy(n.position),
            bc.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(bc),
            n.updateMatrixWorld(),
            i.makeTranslation(-Js.x, -Js.y, -Js.z),
            ef.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(ef);
        }
      }
      Um.prototype.isPointLightShadow = !0;
      class Hm extends kn {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Um());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Hm.prototype.isPointLight = !0;
      class hu extends Yh {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, o) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            o = n + e,
            a = i + t,
            l = i - t;
          if (this.view !== null && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += c * this.view.offsetX),
              (o = r + c * this.view.width),
              (a -= h * this.view.offsetY),
              (l = a - h * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            a,
            l,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      hu.prototype.isOrthographicCamera = !0;
      class Gm extends cu {
        constructor() {
          super(new hu(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Gm.prototype.isDirectionalLightShadow = !0;
      class uu extends kn {
        constructor(e, t) {
          super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(Ke.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ke()),
            (this.shadow = new Gm());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      uu.prototype.isDirectionalLight = !0;
      class Vm extends kn {
        constructor(e, t) {
          super(e, t), (this.type = "AmbientLight");
        }
      }
      Vm.prototype.isAmbientLight = !0;
      class _w extends kn {
        constructor(e, t, n = 10, i = 10) {
          super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.width = this.width), (t.object.height = this.height), t
          );
        }
      }
      _w.prototype.isRectAreaLight = !0;
      class km {
        constructor() {
          this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new G());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * i),
            t.addScaledVector(o[2], 0.488603 * r),
            t.addScaledVector(o[3], 0.488603 * n),
            t.addScaledVector(o[4], 1.092548 * (n * i)),
            t.addScaledVector(o[5], 1.092548 * (i * r)),
            t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
            t.addScaledVector(o[7], 1.092548 * (n * r)),
            t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * i),
            t.addScaledVector(o[2], 2 * 0.511664 * r),
            t.addScaledVector(o[3], 2 * 0.511664 * n),
            t.addScaledVector(o[4], 2 * 0.429043 * n * i),
            t.addScaledVector(o[5], 2 * 0.429043 * i * r),
            t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * n * r),
            t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * r),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * r),
            (t[6] = 0.315392 * (3 * r * r - 1)),
            (t[7] = 1.092548 * n * r),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      km.prototype.isSphericalHarmonics3 = !0;
      class du extends kn {
        constructor(e = new km(), t = 1) {
          super(void 0, t), (this.sh = e);
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (t.object.sh = this.sh.toArray()), t;
        }
      }
      du.prototype.isLightProbe = !0;
      class rs {
        static decodeText(e) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.substr(0, t + 1);
        }
      }
      class vw extends ut {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(e) {
          return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        }
      }
      vw.prototype.isInstancedBufferGeometry = !0;
      class yw extends bt {
        constructor(e, t, n, i) {
          typeof n == "number" &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(e, t, n),
            (this.meshPerAttribute = i || 1);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      yw.prototype.isInstancedBufferAttribute = !0;
      class Wm extends ui {
        constructor(e) {
          super(e),
            typeof createImageBitmap == "undefined" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch == "undefined" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = ds.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = {};
          (a.credentials =
            this.crossOrigin === "anonymous" ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (l) {
                return l.blob();
              })
              .then(function (l) {
                return createImageBitmap(
                  l,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (l) {
                ds.add(e, l), t && t(l), r.manager.itemEnd(e);
              })
              .catch(function (l) {
                i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
              }),
            r.manager.itemStart(e);
        }
      }
      Wm.prototype.isImageBitmapLoader = !0;
      let Ta;
      const Mw = {
        getContext: function () {
          return (
            Ta === void 0 &&
              (Ta = new (window.AudioContext || window.webkitAudioContext)()),
            Ta
          );
        },
        setContext: function (s) {
          Ta = s;
        },
      };
      class bw extends ui {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new iu(this.manager);
          o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  const l = a.slice(0);
                  Mw.getContext().decodeAudioData(l, function (h) {
                    t(h);
                  });
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
      }
      class ww extends du {
        constructor(e, t, n = 1) {
          super(void 0, n);
          const i = new Ue().set(e),
            r = new Ue().set(t),
            o = new G(i.r, i.g, i.b),
            a = new G(r.r, r.g, r.b),
            l = Math.sqrt(Math.PI),
            c = l * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
            this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
        }
      }
      ww.prototype.isHemisphereLightProbe = !0;
      class Sw extends du {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new Ue().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Sw.prototype.isAmbientLightProbe = !0;
      class Tw extends Ke {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            this.isPlaying === !0 &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.loop === !0 &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            this._connected === !0
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), this.source.detune !== void 0))
            return (
              this.isPlaying === !0 &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return this.hasPlaybackControl === !1
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }
      class Ew {
        constructor(e, t, n) {
          (this.binding = e), (this.valueSize = n);
          let i, r, o;
          switch (t) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(n * 6)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(n * 5));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(n * 5));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let o = this.cumulativeWeight;
          if (o === 0) {
            for (let a = 0; a !== i; ++a) n[r + a] = n[a];
            o = t;
          } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, r, 0, a, i);
          }
          this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const l = t * this._origIndex;
            this._mixBufferRegion(n, i, l, 1 - r, t);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let l = t, c = t + t; l !== c; ++l)
            if (n[l] !== n[l + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let r = n, o = i; r !== o; ++r) t[r] = t[i + (r % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
        }
        _slerp(e, t, n, i) {
          Zt.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const o = this._workIndex * r;
          Zt.multiplyQuaternionsFlat(e, o, e, t, e, n),
            Zt.slerpFlat(e, t, e, t, e, o, i);
        }
        _lerp(e, t, n, i, r) {
          const o = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let o = 0; o !== r; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i;
          }
        }
      }
      const fu = "\\[\\]\\.:\\/",
        Aw = new RegExp("[" + fu + "]", "g"),
        pu = "[^" + fu + "]",
        Lw = "[^" + fu.replace("\\.", "") + "]",
        Rw = /((?:WC+[\/:])*)/.source.replace("WC", pu),
        Cw = /(WCOD+)?/.source.replace("WCOD", Lw),
        Pw = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pu),
        Dw = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pu),
        Iw = new RegExp("^" + Rw + Cw + Pw + Dw + "$"),
        Nw = ["material", "materials", "bones"];
      class Fw {
        constructor(e, t, n) {
          const i = n || Qe.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }
      class Qe {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || Qe.parseTrackName(t)),
            (this.node = Qe.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new Qe.Composite(e, t, n)
            : new Qe(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(Aw, "");
        }
        static parseTrackName(e) {
          const t = Iw.exec(e);
          if (!t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            Nw.indexOf(r) !== -1 &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
          }
          if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            !t ||
            t === "" ||
            t === "." ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
          }
          if (e.children) {
            const n = function (r) {
                for (let o = 0; o < r.length; o++) {
                  const a = r[o];
                  if (a.name === t || a.uuid === t) return a;
                  const l = n(a.children);
                  if (l) return l;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.node[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = Qe.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
            return;
          }
          if (n) {
            let c = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!e.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                  if (e[h].name === c) {
                    c = h;
                    break;
                  }
                break;
              default:
                if (e[n] === void 0) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                e = e[n];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
                return;
              }
              e = e[c];
            }
          }
          const o = e[i];
          if (o === void 0) {
            const c = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                c +
                "." +
                i +
                " but it wasn't found.",
              e
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            e.needsUpdate !== void 0
              ? (a = this.Versioning.NeedsUpdate)
              : e.matrixWorldNeedsUpdate !== void 0 &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let l = this.BindingType.Direct;
          if (r !== void 0) {
            if (i === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (e.geometry.isBufferGeometry) {
                if (!e.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                e.morphTargetDictionary[r] !== void 0 &&
                  (r = e.morphTargetDictionary[r]);
              } else {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
                return;
              }
            }
            (l = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = r);
          } else
            o.fromArray !== void 0 && o.toArray !== void 0
              ? ((l = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((l = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[l]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      Qe.Composite = Fw;
      Qe.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      };
      Qe.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      };
      Qe.prototype.GetterByBindingType = [
        Qe.prototype._getValue_direct,
        Qe.prototype._getValue_array,
        Qe.prototype._getValue_arrayElement,
        Qe.prototype._getValue_toArray,
      ];
      Qe.prototype.SetterByBindingTypeAndVersioning = [
        [
          Qe.prototype._setValue_direct,
          Qe.prototype._setValue_direct_setNeedsUpdate,
          Qe.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          Qe.prototype._setValue_array,
          Qe.prototype._setValue_array_setNeedsUpdate,
          Qe.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          Qe.prototype._setValue_arrayElement,
          Qe.prototype._setValue_arrayElement_setNeedsUpdate,
          Qe.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          Qe.prototype._setValue_fromArray,
          Qe.prototype._setValue_fromArray_setNeedsUpdate,
          Qe.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ];
      class Bw {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            o = r.length,
            a = new Array(o),
            l = { endingStart: Zr, endingEnd: Zr };
          for (let c = 0; c !== o; ++c) {
            const h = r[c].createInterpolant(null);
            (a[c] = h), (h.settings = l);
          }
          (this._interpolantSettings = l),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = m_),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const i = this._clip.duration,
              r = e._clip.duration,
              o = r / i,
              a = i / r;
            e.warp(1, o, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            e !== null &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            o = this.timeScale;
          let a = this._timeScaleInterpolant;
          a === null &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const l = a.parameterPositions,
            c = a.sampleValues;
          return (
            (l[0] = r), (l[1] = r + n), (c[0] = e / o), (c[1] = t / o), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            e !== null &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const l = (e - r) * n;
            if (l < 0 || n === 0) return;
            (this._startTime = null), (t = n * l);
          }
          t *= this._updateTimeScale(e);
          const o = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const l = this._interpolants,
              c = this._propertyBindings;
            switch (this.blendMode) {
              case Jp:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulateAdditive(a);
                break;
              case qh:
              default:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulate(i, a);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), i === 0 && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            n !== null &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                t === 0 ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const o = n === g_;
          if (e === 0) return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
          if (n === p_) {
            r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else if (i < 0) i = 0;
              else {
                this.time = i;
                break e;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (r === -1 &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o))
                  : this._setEndings(this.repetitions === 0, !0, o)),
              i >= t || i < 0)
            ) {
              const a = Math.floor(i / t);
              (i -= t * a), (r += Math.abs(a));
              const l = this.repetitions - r;
              if (l <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (l === 1) {
                  const c = e < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = i;
            if (o && (r & 1) === 1) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = Jr), (i.endingEnd = Jr))
            : (e
                ? (i.endingStart = this.zeroSlopeAtStart ? Jr : Zr)
                : (i.endingStart = ul),
              t
                ? (i.endingEnd = this.zeroSlopeAtEnd ? Jr : Zr)
                : (i.endingEnd = ul));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let o = this._weightInterpolant;
          o === null &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const a = o.parameterPositions,
            l = o.sampleValues;
          return (a[0] = r), (l[0] = t), (a[1] = r + e), (l[1] = n), this;
        }
      }
      class zw extends or {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = n.uuid,
            c = this._bindingsByRootAndName;
          let h = c[l];
          h === void 0 && ((h = {}), (c[l] = h));
          for (let u = 0; u !== r; ++u) {
            const d = i[u],
              f = d.name;
            let m = h[f];
            if (m !== void 0) o[u] = m;
            else {
              if (((m = o[u]), m !== void 0)) {
                m._cacheIndex === null &&
                  (++m.referenceCount, this._addInactiveBinding(m, l, f));
                continue;
              }
              const p = t && t._propertyBindings[u].binding.parsedPath;
              (m = new Ew(
                Qe.create(n, f, p),
                d.ValueTypeName,
                d.getValueSize()
              )),
                ++m.referenceCount,
                this._addInactiveBinding(m, l, f),
                (o[u] = m);
            }
            a[u].resultBuffer = m.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const n = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                r = this._actionsByClip[i];
              this._bindAction(e, r && r.knownActions[0]),
                this._addInactiveAction(e, i, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              r.useCount++ === 0 &&
                (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              --r.useCount === 0 &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let o = r[t];
          if (o === void 0)
            (o = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = o);
          else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            o = this._actionsByClip,
            a = o[r],
            l = a.knownActions,
            c = l[l.length - 1],
            h = e._byClipCacheIndex;
          (c._byClipCacheIndex = h),
            (l[h] = c),
            l.pop(),
            (e._byClipCacheIndex = null);
          const u = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
          delete u[d],
            l.length === 0 && delete o[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const r = t[n];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let o = i[t];
          o === void 0 && ((o = {}), (i[t] = o)),
            (o[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = t[t.length - 1],
            c = e._cacheIndex;
          (l._cacheIndex = c),
            (t[c] = l),
            t.pop(),
            delete a[r],
            Object.keys(a).length === 0 && delete o[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            n === void 0 &&
              ((n = new Rm(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let o = typeof e == "string" ? bh.findByName(i, e) : e;
          const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
          let c = null;
          if (
            (n === void 0 && (o !== null ? (n = o.blendMode) : (n = qh)),
            l !== void 0)
          ) {
            const u = l.actionByRoot[r];
            if (u !== void 0 && u.blendMode === n) return u;
            (c = l.knownActions[0]), o === null && (o = c._clip);
          }
          if (o === null) return null;
          const h = new Bw(this, o, t, n);
          return this._bindAction(h, c), this._addInactiveAction(h, a, r), h;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = typeof e == "string" ? bh.findByName(n, e) : e,
            o = r ? r.uuid : e,
            a = this._actionsByClip[o];
          return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions,
            t = this._nActiveActions;
          for (let n = t - 1; n >= 0; --n) e[n].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            o = (this._accuIndex ^= 1);
          for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, o);
          const a = this._bindings,
            l = this._nActiveBindings;
          for (let c = 0; c !== l; ++c) a[c].apply(o);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (r !== void 0) {
            const o = r.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
              const c = o[a];
              this._deactivateAction(c);
              const h = c._cacheIndex,
                u = t[t.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (u._cacheIndex = h),
                (t[h] = u),
                t.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const o in n) {
            const a = n[o].actionByRoot,
              l = a[t];
            l !== void 0 &&
              (this._deactivateAction(l), this._removeInactiveAction(l));
          }
          const i = this._bindingsByRootAndName,
            r = i[t];
          if (r !== void 0)
            for (const o in r) {
              const a = r[o];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      zw.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Ow extends Ts {
        constructor(e, t, n = 1) {
          super(e, t), (this.meshPerAttribute = n || 1);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        clone(e) {
          const t = super.clone(e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        }
      }
      Ow.prototype.isInstancedInterleavedBuffer = !0;
      class Uw extends Ke {
        constructor(e) {
          super(),
            (this.material = e),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0);
        }
      }
      Uw.prototype.isImmediateRenderObject = !0;
      const Mi = new G(),
        Ea = new Ge(),
        wc = new Ge();
      class Hw extends Sl {
        constructor(e) {
          const t = $m(e),
            n = new ut(),
            i = [],
            r = [],
            o = new Ue(0, 0, 1),
            a = new Ue(0, 1, 0);
          for (let c = 0; c < t.length; c++) {
            const h = t[c];
            h.parent &&
              h.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(o.r, o.g, o.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new Pt(i, 3)),
            n.setAttribute("color", new Pt(r, 3));
          const l = new Es({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, l),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          wc.copy(this.root.matrixWorld).invert();
          for (let r = 0, o = 0; r < t.length; r++) {
            const a = t[r];
            a.parent &&
              a.parent.isBone &&
              (Ea.multiplyMatrices(wc, a.matrixWorld),
              Mi.setFromMatrixPosition(Ea),
              i.setXYZ(o, Mi.x, Mi.y, Mi.z),
              Ea.multiplyMatrices(wc, a.parent.matrixWorld),
              Mi.setFromMatrixPosition(Ea),
              i.setXYZ(o + 1, Mi.x, Mi.y, Mi.z),
              (o += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }
      function $m(s) {
        const e = [];
        s && s.isBone && e.push(s);
        for (let t = 0; t < s.children.length; t++)
          e.push.apply(e, $m(s.children[t]));
        return e;
      }
      class Gw extends Sl {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new Ue(n)), (i = new Ue(i));
          const r = t / 2,
            o = e / t,
            a = e / 2,
            l = [],
            c = [];
          for (let d = 0, f = 0, m = -a; d <= t; d++, m += o) {
            l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
            const p = d === r ? n : i;
            p.toArray(c, f),
              (f += 3),
              p.toArray(c, f),
              (f += 3),
              p.toArray(c, f),
              (f += 3),
              p.toArray(c, f),
              (f += 3);
          }
          const h = new ut();
          h.setAttribute("position", new Pt(l, 3)),
            h.setAttribute("color", new Pt(c, 3));
          const u = new Es({ vertexColors: !0, toneMapped: !1 });
          super(h, u), (this.type = "GridHelper");
        }
      }
      const Vw = new Float32Array(1);
      new Int32Array(Vw.buffer);
      const kw = new Di({ side: Rt, depthWrite: !1, depthTest: !1 });
      new vn(new jh(), kw);
      yn.create = function (s, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (s.prototype = Object.create(yn.prototype)),
          (s.prototype.constructor = s),
          (s.prototype.getPoint = e),
          s
        );
      };
      wh.prototype.fromPoints = function (s) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(s)
        );
      };
      Gw.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      };
      Hw.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      };
      ui.prototype.extractUrlBase = function (s) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          rs.extractUrlBase(s)
        );
      };
      ui.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      };
      pn.prototype.center = function (s) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(s)
        );
      };
      pn.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      pn.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      pn.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      pn.prototype.size = function (s) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(s)
        );
      };
      ar.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      };
      bl.prototype.setFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(s)
        );
      };
      Ot.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      Ot.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      Ot.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      };
      Ot.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      Ot.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      };
      Ot.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      Ge.prototype.extractPosition = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(s)
        );
      };
      Ge.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      Ge.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new G().setFromMatrixColumn(this, 3)
        );
      };
      Ge.prototype.setRotationFromQuaternion = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(s)
        );
      };
      Ge.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      Ge.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      Ge.prototype.multiplyVector4 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      Ge.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      };
      Ge.prototype.rotateAxis = function (s) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          s.transformDirection(this);
      };
      Ge.prototype.crossVector = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      Ge.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      Ge.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      Ge.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      Ge.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      Ge.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      Ge.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      Ge.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      };
      Ge.prototype.makeFrustum = function (s, e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(s, e, n, t, i, r)
        );
      };
      Ge.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      Un.prototype.isIntersectionLine = function (s) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(s)
        );
      };
      Zt.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          s.applyQuaternion(this)
        );
      };
      Zt.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      };
      bs.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      bs.prototype.isIntersectionPlane = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(s)
        );
      };
      bs.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      yt.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      };
      yt.prototype.barycoordFromPoint = function (s, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(s, e)
        );
      };
      yt.prototype.midpoint = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(s)
        );
      };
      yt.prototypenormal = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(s)
        );
      };
      yt.prototype.plane = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(s)
        );
      };
      yt.barycoordFromPoint = function (s, e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          yt.getBarycoord(s, e, t, n, i)
        );
      };
      yt.normal = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          yt.getNormal(s, e, t, n)
        );
      };
      lu.prototype.extractAllPoints = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(s)
        );
      };
      lu.prototype.extrude = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new El(this, s)
        );
      };
      lu.prototype.makeGeometry = function (s) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new kb(this, s)
        );
      };
      Se.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      Se.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      Se.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      G.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      };
      G.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      };
      G.prototype.getPositionFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(s)
        );
      };
      G.prototype.getScaleFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(s)
        );
      };
      G.prototype.getColumnFromMatrix = function (s, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, s)
        );
      };
      G.prototype.applyProjection = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(s)
        );
      };
      G.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      G.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      G.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      rt.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      rt.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Ke.prototype.getChildByName = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(s)
        );
      };
      Ke.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      };
      Ke.prototype.translate = function (s, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, s)
        );
      };
      Ke.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      };
      Ke.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(Ke.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (s) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = s);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      vn.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      };
      Object.defineProperties(vn.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              x_
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      });
      Kh.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      tn.prototype.setLens = function (s, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          e !== void 0 && (this.filmGauge = e),
          this.setFocalLength(s);
      };
      Object.defineProperties(kn.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = s);
          },
        },
        shadowCameraLeft: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = s);
          },
        },
        shadowCameraRight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = s);
          },
        },
        shadowCameraTop: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = s);
          },
        },
        shadowCameraBottom: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = s);
          },
        },
        shadowCameraNear: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = s);
          },
        },
        shadowCameraFar: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = s);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (s) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = s);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = s);
          },
        },
        shadowMapHeight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = s);
          },
        },
      });
      Object.defineProperties(bt.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === fl
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(fl);
          },
        },
      });
      bt.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? fl : Ao),
          this
        );
      };
      (bt.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
        (bt.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        });
      ut.prototype.addIndex = function (s) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(s);
      };
      ut.prototype.addAttribute = function (s, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(s, new bt(arguments[1], arguments[2])))
            : s === "index"
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(s, e)
        );
      };
      ut.prototype.addDrawCall = function (s, e, t) {
        t !== void 0 &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(s, e);
      };
      ut.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      };
      ut.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      };
      ut.prototype.removeAttribute = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(s)
        );
      };
      ut.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(ut.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      });
      Ts.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? fl : Ao),
          this
        );
      };
      Ts.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      };
      El.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      El.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      };
      El.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Jh.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Object.defineProperties(It.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new Ue()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = s === qp);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = s);
          },
        },
      });
      Object.defineProperties(ir.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (s) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = s);
          },
        },
      });
      ot.prototype.clearTarget = function (s, e, t, n) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(s),
          this.clear(e, t, n);
      };
      ot.prototype.animate = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(s);
      };
      ot.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      };
      ot.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      };
      ot.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      };
      ot.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      };
      ot.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      };
      ot.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      };
      ot.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      };
      ot.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      };
      ot.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      };
      ot.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      };
      ot.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      };
      ot.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      };
      ot.prototype.enableScissorTest = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(s);
      };
      ot.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      ot.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      ot.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      ot.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      };
      ot.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      };
      ot.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      };
      ot.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      ot.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      ot.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      };
      ot.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      };
      Object.defineProperties(ot.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = s);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = s);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = s === !0 ? dl : Wo);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      });
      Object.defineProperties(_m.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      });
      Object.defineProperties(ai.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = s);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = s);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = s);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = s);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = s);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = s);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = s);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = s);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = s);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = s);
          },
        },
      });
      Tw.prototype.load = function (s) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new bw().load(s, function (n) {
            e.setBuffer(n);
          }),
          this
        );
      };
      Zh.prototype.updateCubeMap = function (s, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(s, e)
        );
      };
      Zh.prototype.clear = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(s, e, t, n)
        );
      };
      Ms.crossOrigin = void 0;
      Ms.loadTexture = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new Dm();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      Ms.loadTextureCube = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new ow();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      Ms.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      };
      Ms.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      };
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: Wp } })
        );
      typeof window != "undefined" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = Wp));
      class Ww extends ui {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new jw(t);
            }),
            this.register(function (t) {
              return new Zw(t);
            }),
            this.register(function (t) {
              return new Jw(t);
            }),
            this.register(function (t) {
              return new Yw(t);
            }),
            this.register(function (t) {
              return new qw(t);
            }),
            this.register(function (t) {
              return new Kw(t);
            });
        }
        load(e, t, n, i) {
          const r = this;
          let o;
          this.resourcePath !== ""
            ? (o = this.resourcePath)
            : this.path !== ""
            ? (o = this.path)
            : (o = rs.extractUrlBase(e)),
            this.manager.itemStart(e);
          const a = function (c) {
              i ? i(c) : console.error(c),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            },
            l = new iu(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
              e,
              function (c) {
                try {
                  r.parse(
                    c,
                    o,
                    function (h) {
                      t(h), r.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (h) {
                  a(h);
                }
              },
              n,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            this.pluginCallbacks.indexOf(e) === -1 &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            this.pluginCallbacks.indexOf(e) !== -1 &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let r;
          const o = {},
            a = {};
          if (typeof e == "string") r = e;
          else if (rs.decodeText(new Uint8Array(e, 0, 4)) === qm) {
            try {
              o[Je.KHR_BINARY_GLTF] = new Qw(e);
            } catch (u) {
              i && i(u);
              return;
            }
            r = o[Je.KHR_BINARY_GLTF].content;
          } else r = rs.decodeText(new Uint8Array(e));
          const l = JSON.parse(r);
          if (l.asset === void 0 || l.asset.version[0] < 2) {
            i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              );
            return;
          }
          const c = new cS(l, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const u = this.pluginCallbacks[h](c);
            (a[u.name] = u), (o[u.name] = !0);
          }
          if (l.extensionsUsed)
            for (let h = 0; h < l.extensionsUsed.length; ++h) {
              const u = l.extensionsUsed[h],
                d = l.extensionsRequired || [];
              switch (u) {
                case Je.KHR_MATERIALS_UNLIT:
                  o[u] = new Xw();
                  break;
                case Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  o[u] = new nS();
                  break;
                case Je.KHR_DRACO_MESH_COMPRESSION:
                  o[u] = new eS(l, this.dracoLoader);
                  break;
                case Je.KHR_TEXTURE_TRANSFORM:
                  o[u] = new tS();
                  break;
                case Je.KHR_MESH_QUANTIZATION:
                  o[u] = new iS();
                  break;
                default:
                  d.indexOf(u) >= 0 &&
                    a[u] === void 0 &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + u + '".'
                    );
              }
            }
          c.setExtensions(o), c.setPlugins(a), c.parse(n, i);
        }
      }
      function $w() {
        let s = {};
        return {
          get: function (e) {
            return s[e];
          },
          add: function (e, t) {
            s[e] = t;
          },
          remove: function (e) {
            delete s[e];
          },
          removeAll: function () {
            s = {};
          },
        };
      }
      const Je = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      };
      class qw {
        constructor(e) {
          (this.parser = e),
            (this.name = Je.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            r.extensions &&
              r.extensions[this.name] &&
              r.extensions[this.name].light !== void 0 &&
              e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let i = t.cache.get(n);
          if (i) return i;
          const r = t.json,
            l = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[e];
          let c;
          const h = new Ue(16777215);
          l.color !== void 0 && h.fromArray(l.color);
          const u = l.range !== void 0 ? l.range : 0;
          switch (l.type) {
            case "directional":
              (c = new uu(h)), c.target.position.set(0, 0, -1), c.add(c.target);
              break;
            case "point":
              (c = new Hm(h)), (c.distance = u);
              break;
            case "spot":
              (c = new Om(h)),
                (c.distance = u),
                (l.spot = l.spot || {}),
                (l.spot.innerConeAngle =
                  l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
                (l.spot.outerConeAngle =
                  l.spot.outerConeAngle !== void 0
                    ? l.spot.outerConeAngle
                    : Math.PI / 4),
                (c.angle = l.spot.outerConeAngle),
                (c.penumbra =
                  1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
                c.target.position.set(0, 0, -1),
                c.add(c.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + l.type
              );
          }
          return (
            c.position.set(0, 0, 0),
            (c.decay = 2),
            l.intensity !== void 0 && (c.intensity = l.intensity),
            (c.name = t.createUniqueName(l.name || "light_" + e)),
            (i = Promise.resolve(c)),
            t.cache.add(n, i),
            i
          );
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            a = ((r.extensions && r.extensions[this.name]) || {}).light;
          return a === void 0
            ? null
            : this._loadLight(a).then(function (l) {
                return n._getNodeRef(t.cache, a, l);
              });
        }
      }
      class Xw {
        constructor() {
          this.name = Je.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return Di;
        }
        extendParams(e, t, n) {
          const i = [];
          (e.color = new Ue(1, 1, 1)), (e.opacity = 1);
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const o = r.baseColorFactor;
              e.color.fromArray(o), (e.opacity = o[3]);
            }
            r.baseColorTexture !== void 0 &&
              i.push(n.assignTexture(e, "map", r.baseColorTexture));
          }
          return Promise.all(i);
        }
      }
      class jw {
        constructor(e) {
          (this.parser = e), (this.name = Je.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : nu;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          if (
            (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
            o.clearcoatTexture !== void 0 &&
              r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
            o.clearcoatRoughnessFactor !== void 0 &&
              (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
            o.clearcoatRoughnessTexture !== void 0 &&
              r.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  o.clearcoatRoughnessTexture
                )
              ),
            o.clearcoatNormalTexture !== void 0 &&
              (r.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  o.clearcoatNormalTexture
                )
              ),
              o.clearcoatNormalTexture.scale !== void 0))
          ) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Se(a, -a);
          }
          return Promise.all(r);
        }
      }
      class Yw {
        constructor(e) {
          (this.parser = e), (this.name = Je.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : nu;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          return (
            o.transmissionFactor !== void 0 &&
              (t.transmission = o.transmissionFactor),
            o.transmissionTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "transmissionMap", o.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class Zw {
        constructor(e) {
          (this.parser = e), (this.name = Je.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            o = n.images[r.source],
            a = t.options.ktx2Loader;
          if (!a) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, o, a);
        }
      }
      class Jw {
        constructor(e) {
          (this.parser = e),
            (this.name = Je.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const o = r.extensions[t],
            a = i.images[o.source];
          let l = n.textureLoader;
          if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c);
          }
          return this.detectSupport().then(function (c) {
            if (c) return n.loadTextureImage(e, a, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(t.height === 1);
                    });
              })),
            this.isSupported
          );
        }
      }
      class Kw {
        constructor(e) {
          (this.name = Je.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
              r = this.parser.getDependency("buffer", i.buffer),
              o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return Promise.all([r, o.ready]).then(function (a) {
              const l = i.byteOffset || 0,
                c = i.byteLength || 0,
                h = i.count,
                u = i.byteStride,
                d = new ArrayBuffer(h * u),
                f = new Uint8Array(a[0], l, c);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(d),
                  h,
                  u,
                  f,
                  i.mode,
                  i.filter
                ),
                d
              );
            });
          } else return null;
        }
      }
      const qm = "glTF",
        Ks = 12,
        tf = { JSON: 1313821514, BIN: 5130562 };
      class Qw {
        constructor(e) {
          (this.name = Je.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, Ks);
          if (
            ((this.header = {
              magic: rs.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== qm)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - Ks,
            i = new DataView(e, Ks);
          let r = 0;
          for (; r < n; ) {
            const o = i.getUint32(r, !0);
            r += 4;
            const a = i.getUint32(r, !0);
            if (((r += 4), a === tf.JSON)) {
              const l = new Uint8Array(e, Ks + r, o);
              this.content = rs.decodeText(l);
            } else if (a === tf.BIN) {
              const l = Ks + r;
              this.body = e.slice(l, l + o);
            }
            r += o;
          }
          if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class eS {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = Je.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            i = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
          for (const h in o) {
            const u = Th[h] || h.toLowerCase();
            a[u] = o[h];
          }
          for (const h in e.attributes) {
            const u = Th[h] || h.toLowerCase();
            if (o[h] !== void 0) {
              const d = n.accessors[e.attributes[h]],
                f = No[d.componentType];
              (c[u] = f), (l[u] = d.normalized === !0);
            }
          }
          return t.getDependency("bufferView", r).then(function (h) {
            return new Promise(function (u) {
              i.decodeDracoFile(
                h,
                function (d) {
                  for (const f in d.attributes) {
                    const m = d.attributes[f],
                      p = l[f];
                    p !== void 0 && (m.normalized = p);
                  }
                  u(d);
                },
                a,
                c
              );
            });
          });
        }
      }
      class tS {
        constructor() {
          this.name = Je.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            t.texCoord !== void 0 &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.'
              ),
            (t.offset === void 0 &&
              t.rotation === void 0 &&
              t.scale === void 0) ||
              ((e = e.clone()),
              t.offset !== void 0 && e.offset.fromArray(t.offset),
              t.rotation !== void 0 && (e.rotation = t.rotation),
              t.scale !== void 0 && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class Sh extends $o {
        constructor(e) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0);
          const t = [
              "#ifdef USE_SPECULARMAP",
              "	uniform sampler2D specularMap;",
              "#endif",
            ].join(`
`),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "	uniform sampler2D glossinessMap;",
              "#endif",
            ].join(`
`),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "	vec4 texelSpecular = texture2D( specularMap, vUv );",
              "	texelSpecular = sRGBToLinear( texelSpecular );",
              "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	specularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join(`
`),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	glossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join(`
`),
            o = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.specularRoughness += geometryRoughness;",
              "material.specularRoughness = min( material.specularRoughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join(`
`),
            a = {
              specular: { value: new Ue().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = a),
            (this.onBeforeCompile = function (l) {
              for (const c in a) l.uniforms[c] = a[c];
              l.fragmentShader = l.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", t)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", r)
                .replace("#include <lights_physical_fragment>", o);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return a.specular.value;
                },
                set: function (l) {
                  a.specular.value = l;
                },
              },
              specularMap: {
                get: function () {
                  return a.specularMap.value;
                },
                set: function (l) {
                  (a.specularMap.value = l),
                    l
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return a.glossiness.value;
                },
                set: function (l) {
                  a.glossiness.value = l;
                },
              },
              glossinessMap: {
                get: function () {
                  return a.glossinessMap.value;
                },
                set: function (l) {
                  (a.glossinessMap.value = l),
                    l
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.specularMap = e.specularMap),
            this.specular.copy(e.specular),
            (this.glossinessMap = e.glossinessMap),
            (this.glossiness = e.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          );
        }
      }
      class nS {
        constructor() {
          (this.name = Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
              "refractionRatio",
            ]);
        }
        getMaterialType() {
          return Sh;
        }
        extendParams(e, t, n) {
          const i = t.extensions[this.name];
          (e.color = new Ue(1, 1, 1)), (e.opacity = 1);
          const r = [];
          if (Array.isArray(i.diffuseFactor)) {
            const o = i.diffuseFactor;
            e.color.fromArray(o), (e.opacity = o[3]);
          }
          if (
            (i.diffuseTexture !== void 0 &&
              r.push(n.assignTexture(e, "map", i.diffuseTexture)),
            (e.emissive = new Ue(0, 0, 0)),
            (e.glossiness =
              i.glossinessFactor !== void 0 ? i.glossinessFactor : 1),
            (e.specular = new Ue(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              e.specular.fromArray(i.specularFactor),
            i.specularGlossinessTexture !== void 0)
          ) {
            const o = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", o)),
              r.push(n.assignTexture(e, "specularMap", o));
          }
          return Promise.all(r);
        }
        createMaterial(e) {
          const t = new Sh(e);
          return (
            (t.fog = !0),
            (t.color = e.color),
            (t.map = e.map === void 0 ? null : e.map),
            (t.lightMap = null),
            (t.lightMapIntensity = 1),
            (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
            (t.aoMapIntensity = 1),
            (t.emissive = e.emissive),
            (t.emissiveIntensity = 1),
            (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
            (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
            (t.bumpScale = 1),
            (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
            (t.normalMapType = sr),
            e.normalScale && (t.normalScale = e.normalScale),
            (t.displacementMap = null),
            (t.displacementScale = 1),
            (t.displacementBias = 0),
            (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
            (t.specular = e.specular),
            (t.glossinessMap =
              e.glossinessMap === void 0 ? null : e.glossinessMap),
            (t.glossiness = e.glossiness),
            (t.alphaMap = null),
            (t.envMap = e.envMap === void 0 ? null : e.envMap),
            (t.envMapIntensity = 1),
            (t.refractionRatio = 0.98),
            t
          );
        }
      }
      class iS {
        constructor() {
          this.name = Je.KHR_MESH_QUANTIZATION;
        }
      }
      class fs extends ci {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i;
          for (let o = 0; o !== i; o++) t[o] = n[r + o];
          return t;
        }
      }
      fs.prototype.beforeStart_ = fs.prototype.copySampleValue_;
      fs.prototype.afterEnd_ = fs.prototype.copySampleValue_;
      fs.prototype.interpolate_ = function (s, e, t, n) {
        const i = this.resultBuffer,
          r = this.sampleValues,
          o = this.valueSize,
          a = o * 2,
          l = o * 3,
          c = n - e,
          h = (t - e) / c,
          u = h * h,
          d = u * h,
          f = s * l,
          m = f - l,
          p = -2 * d + 3 * u,
          g = d - u,
          x = 1 - p,
          _ = g - u + h;
        for (let M = 0; M !== o; M++) {
          const S = r[m + M + o],
            v = r[m + M + a] * c,
            y = r[f + M + o],
            C = r[f + M] * c;
          i[M] = x * S + _ * v + p * y + g * C;
        }
        return i;
      };
      const Kn = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        No = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        nf = { 9728: zt, 9729: sn, 9984: mh, 9985: Zp, 9986: gh, 9987: ys },
        rf = { 33071: rn, 33648: ll, 10497: ls },
        sf = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        Th = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        bi = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        rS = { CUBICSPLINE: void 0, LINEAR: cs, STEP: Eo },
        Sc = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
      function of(s, e) {
        return typeof s != "string" || s === ""
          ? ""
          : (/^https?:\/\//i.test(e) &&
              /^\//.test(s) &&
              (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(s) ||
            /^data:.*,.*$/i.test(s) ||
            /^blob:.*$/i.test(s)
              ? s
              : e + s);
      }
      function sS(s) {
        return (
          s.DefaultMaterial === void 0 &&
            (s.DefaultMaterial = new $o({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: So,
            })),
          s.DefaultMaterial
        );
      }
      function Qs(s, e, t) {
        for (const n in t.extensions)
          s[n] === void 0 &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[n] = t.extensions[n]));
      }
      function Zi(s, e) {
        e.extras !== void 0 &&
          (typeof e.extras == "object"
            ? Object.assign(s.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function oS(s, e, t) {
        let n = !1,
          i = !1;
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          if (
            (c.POSITION !== void 0 && (n = !0),
            c.NORMAL !== void 0 && (i = !0),
            n && i)
          )
            break;
        }
        if (!n && !i) return Promise.resolve(s);
        const r = [],
          o = [];
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          if (n) {
            const h =
              c.POSITION !== void 0
                ? t.getDependency("accessor", c.POSITION)
                : s.attributes.position;
            r.push(h);
          }
          if (i) {
            const h =
              c.NORMAL !== void 0
                ? t.getDependency("accessor", c.NORMAL)
                : s.attributes.normal;
            o.push(h);
          }
        }
        return Promise.all([Promise.all(r), Promise.all(o)]).then(function (a) {
          const l = a[0],
            c = a[1];
          return (
            n && (s.morphAttributes.position = l),
            i && (s.morphAttributes.normal = c),
            (s.morphTargetsRelative = !0),
            s
          );
        });
      }
      function aS(s, e) {
        if ((s.updateMorphTargets(), e.weights !== void 0))
          for (let t = 0, n = e.weights.length; t < n; t++)
            s.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (s.morphTargetInfluences.length === t.length) {
            s.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
              s.morphTargetDictionary[t[n]] = n;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function lS(s) {
        const e = s.extensions && s.extensions[Je.KHR_DRACO_MESH_COMPRESSION];
        let t;
        return (
          e
            ? (t =
                "draco:" +
                e.bufferView +
                ":" +
                e.indices +
                ":" +
                af(e.attributes))
            : (t = s.indices + ":" + af(s.attributes) + ":" + s.mode),
          t
        );
      }
      function af(s) {
        let e = "";
        const t = Object.keys(s).sort();
        for (let n = 0, i = t.length; n < i; n++)
          e += t[n] + ":" + s[t[n]] + ";";
        return e;
      }
      function Eh(s) {
        switch (s) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      class cS {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new $w()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {}),
            typeof createImageBitmap != "undefined" &&
            /Firefox/.test(navigator.userAgent) === !1
              ? (this.textureLoader = new Wm(this.options.manager))
              : (this.textureLoader = new Dm(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new iu(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            this.options.crossOrigin === "use-credentials" &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            this._invokeAll(function (o) {
              return o._markDefs && o._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (o) {
                return o.beforeRoot && o.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (o) {
                const a = {
                  scene: o[0][i.scene || 0],
                  scenes: o[0],
                  animations: o[1],
                  cameras: o[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                Qs(r, a, i),
                  Zi(a, i),
                  Promise.all(
                    n._invokeAll(function (l) {
                      return l.afterRoot && l.afterRoot(a);
                    })
                  ).then(function () {
                    e(a);
                  });
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
          }
          for (let i = 0, r = e.length; i < r; i++) {
            const o = e[i];
            o.mesh !== void 0 &&
              (this._addNodeRef(this.meshCache, o.mesh),
              o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
              o.camera !== void 0 &&
                this._addNodeRef(this.cameraCache, o.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 &&
            (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone();
          return (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this.loadNode(t);
                break;
              case "mesh":
                i = this._invokeOne(function (r) {
                  return r.loadMesh && r.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (r) {
                  return r.loadBufferView && r.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (r) {
                  return r.loadMaterial && r.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (r) {
                  return r.loadTexture && r.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this.loadAnimation(t);
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (r, o) {
                return n.getDependency(e, o);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && t.type !== "arraybuffer")
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Je.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (r, o) {
            n.load(of(t.uri, i.path), r, void 0, function () {
              o(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (n) {
            const i = t.byteLength || 0,
              r = t.byteOffset || 0;
            return n.slice(r, r + i);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            i = this.json.accessors[e];
          if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
          const r = [];
          return (
            i.bufferView !== void 0
              ? r.push(this.getDependency("bufferView", i.bufferView))
              : r.push(null),
            i.sparse !== void 0 &&
              (r.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              r.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(r).then(function (o) {
              const a = o[0],
                l = sf[i.type],
                c = No[i.componentType],
                h = c.BYTES_PER_ELEMENT,
                u = h * l,
                d = i.byteOffset || 0,
                f =
                  i.bufferView !== void 0
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                m = i.normalized === !0;
              let p, g;
              if (f && f !== u) {
                const x = Math.floor(d / f),
                  _ =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    x +
                    ":" +
                    i.count;
                let M = t.cache.get(_);
                M ||
                  ((p = new c(a, x * f, (i.count * f) / h)),
                  (M = new Ts(p, f / h)),
                  t.cache.add(_, M)),
                  (g = new us(M, l, (d % f) / h, m));
              } else a === null ? (p = new c(i.count * l)) : (p = new c(a, d, i.count * l)), (g = new bt(p, l, m));
              if (i.sparse !== void 0) {
                const x = sf.SCALAR,
                  _ = No[i.sparse.indices.componentType],
                  M = i.sparse.indices.byteOffset || 0,
                  S = i.sparse.values.byteOffset || 0,
                  v = new _(o[1], M, i.sparse.count * x),
                  y = new c(o[2], S, i.sparse.count * l);
                a !== null &&
                  (g = new bt(g.array.slice(), g.itemSize, g.normalized));
                for (let C = 0, U = v.length; C < U; C++) {
                  const K = v[C];
                  if (
                    (g.setX(K, y[C * l]),
                    l >= 2 && g.setY(K, y[C * l + 1]),
                    l >= 3 && g.setZ(K, y[C * l + 2]),
                    l >= 4 && g.setW(K, y[C * l + 3]),
                    l >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return g;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            i = t.textures[e],
            r = t.images[i.source];
          let o = this.textureLoader;
          if (r.uri) {
            const a = n.manager.getHandler(r.uri);
            a !== null && (o = a);
          }
          return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, n) {
          const i = this,
            r = this.json,
            o = this.options,
            a = r.textures[e],
            l = (t.uri || t.bufferView) + ":" + a.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = self.URL || self.webkitURL;
          let h = t.uri || "",
            u = !1,
            d = !0;
          const f =
            h.search(/\.jpe?g($|\?)/i) > 0 ||
            h.search(/^data\:image\/jpeg/) === 0;
          if (
            ((t.mimeType === "image/jpeg" || f) && (d = !1),
            t.bufferView !== void 0)
          )
            h = i.getDependency("bufferView", t.bufferView).then(function (p) {
              if (t.mimeType === "image/png") {
                const x = new DataView(p, 25, 1).getUint8(0, !1);
                d = x === 6 || x === 4 || x === 3;
              }
              u = !0;
              const g = new Blob([p], { type: t.mimeType });
              return (h = c.createObjectURL(g)), h;
            });
          else if (t.uri === void 0)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const m = Promise.resolve(h)
            .then(function (p) {
              return new Promise(function (g, x) {
                let _ = g;
                n.isImageBitmapLoader === !0 &&
                  (_ = function (M) {
                    g(new Tm(M));
                  }),
                  n.load(of(p, o.path), _, void 0, x);
              });
            })
            .then(function (p) {
              u === !0 && c.revokeObjectURL(h),
                (p.flipY = !1),
                a.name && (p.name = a.name),
                d || (p.format = Ni);
              const x = (r.samplers || {})[a.sampler] || {};
              return (
                (p.magFilter = nf[x.magFilter] || sn),
                (p.minFilter = nf[x.minFilter] || ys),
                (p.wrapS = rf[x.wrapS] || ls),
                (p.wrapT = rf[x.wrapT] || ls),
                i.associations.set(p, { type: "textures", index: e }),
                p
              );
            });
          return (this.textureCache[l] = m), m;
        }
        assignTexture(e, t, n) {
          const i = this;
          return this.getDependency("texture", n.index).then(function (r) {
            if (
              (n.texCoord !== void 0 &&
                n.texCoord != 0 &&
                !(t === "aoMap" && n.texCoord == 1) &&
                console.warn(
                  "THREE.GLTFLoader: Custom UV set " +
                    n.texCoord +
                    " for texture " +
                    t +
                    " not yet supported."
                ),
              i.extensions[Je.KHR_TEXTURE_TRANSFORM])
            ) {
              const o =
                n.extensions !== void 0
                  ? n.extensions[Je.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (o) {
                const a = i.associations.get(r);
                (r = i.extensions[Je.KHR_TEXTURE_TRANSFORM].extendTexture(
                  r,
                  o
                )),
                  i.associations.set(r, a);
              }
            }
            e[t] = r;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const i = t.attributes.tangent !== void 0,
            r = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0,
            a = Object.keys(t.morphAttributes).length > 0,
            l = a && t.morphAttributes.normal !== void 0;
          if (e.isPoints) {
            const c = "PointsMaterial:" + n.uuid;
            let h = this.cache.get(c);
            h ||
              ((h = new tu()),
              It.prototype.copy.call(h, n),
              h.color.copy(n.color),
              (h.map = n.map),
              (h.sizeAttenuation = !1),
              this.cache.add(c, h)),
              (n = h);
          } else if (e.isLine) {
            const c = "LineBasicMaterial:" + n.uuid;
            let h = this.cache.get(c);
            h ||
              ((h = new Es()),
              It.prototype.copy.call(h, n),
              h.color.copy(n.color),
              this.cache.add(c, h)),
              (n = h);
          }
          if (i || r || o || a) {
            let c = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"),
              i && (c += "vertex-tangents:"),
              r && (c += "vertex-colors:"),
              o && (c += "flat-shading:"),
              a && (c += "morph-targets:"),
              l && (c += "morph-normals:");
            let h = this.cache.get(c);
            h ||
              ((h = n.clone()),
              r && (h.vertexColors = !0),
              o && (h.flatShading = !0),
              a && (h.morphTargets = !0),
              l && (h.morphNormals = !0),
              i &&
                ((h.vertexTangents = !0),
                h.normalScale && (h.normalScale.y *= -1),
                h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)),
              this.cache.add(c, h),
              this.associations.set(h, this.associations.get(n))),
              (n = h);
          }
          n.aoMap &&
            t.attributes.uv2 === void 0 &&
            t.attributes.uv !== void 0 &&
            t.setAttribute("uv2", t.attributes.uv),
            (e.material = n);
        }
        getMaterialType() {
          return $o;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[e];
          let o;
          const a = {},
            l = r.extensions || {},
            c = [];
          if (l[Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const u = i[Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
          } else if (l[Je.KHR_MATERIALS_UNLIT]) {
            const u = i[Je.KHR_MATERIALS_UNLIT];
            (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
          } else {
            const u = r.pbrMetallicRoughness || {};
            if (
              ((a.color = new Ue(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(u.baseColorFactor))
            ) {
              const d = u.baseColorFactor;
              a.color.fromArray(d), (a.opacity = d[3]);
            }
            u.baseColorTexture !== void 0 &&
              c.push(t.assignTexture(a, "map", u.baseColorTexture)),
              (a.metalness =
                u.metallicFactor !== void 0 ? u.metallicFactor : 1),
              (a.roughness =
                u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
              u.metallicRoughnessTexture !== void 0 &&
                (c.push(
                  t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)
                ),
                c.push(
                  t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture)
                )),
              (o = this._invokeOne(function (d) {
                return d.getMaterialType && d.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (d) {
                    return (
                      d.extendMaterialParams && d.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          r.doubleSided === !0 && (a.side = ko);
          const h = r.alphaMode || Sc.OPAQUE;
          return (
            h === Sc.BLEND
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                h === Sc.MASK &&
                  (a.alphaTest =
                    r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
            r.normalTexture !== void 0 &&
              o !== Di &&
              (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
              (a.normalScale = new Se(1, -1)),
              r.normalTexture.scale !== void 0 &&
                a.normalScale.set(
                  r.normalTexture.scale,
                  -r.normalTexture.scale
                )),
            r.occlusionTexture !== void 0 &&
              o !== Di &&
              (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
              r.occlusionTexture.strength !== void 0 &&
                (a.aoMapIntensity = r.occlusionTexture.strength)),
            r.emissiveFactor !== void 0 &&
              o !== Di &&
              (a.emissive = new Ue().fromArray(r.emissiveFactor)),
            r.emissiveTexture !== void 0 &&
              o !== Di &&
              c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
            Promise.all(c).then(function () {
              let u;
              return (
                o === Sh
                  ? (u =
                      i[
                        Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(a))
                  : (u = new o(a)),
                r.name && (u.name = r.name),
                u.map && (u.map.encoding = dl),
                u.emissiveMap && (u.emissiveMap.encoding = dl),
                Zi(u, r),
                t.associations.set(u, { type: "materials", index: e }),
                r.extensions && Qs(i, u, r),
                u
              );
            })
          );
        }
        createUniqueName(e) {
          const t = Qe.sanitizeNodeName(e || "");
          let n = t;
          for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
          return (this.nodeNamesUsed[n] = !0), n;
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            i = this.primitiveCache;
          function r(a) {
            return n[Je.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(a, t)
              .then(function (l) {
                return lf(l, a, t);
              });
          }
          const o = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = lS(c),
              u = i[h];
            if (u) o.push(u.promise);
            else {
              let d;
              c.extensions && c.extensions[Je.KHR_DRACO_MESH_COMPRESSION]
                ? (d = r(c))
                : (d = lf(new ut(), c, t)),
                (i[h] = { primitive: c, promise: d }),
                o.push(d);
            }
          }
          return Promise.all(o);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[e],
            o = r.primitives,
            a = [];
          for (let l = 0, c = o.length; l < c; l++) {
            const h =
              o[l].material === void 0
                ? sS(this.cache)
                : this.getDependency("material", o[l].material);
            a.push(h);
          }
          return (
            a.push(t.loadGeometries(o)),
            Promise.all(a).then(function (l) {
              const c = l.slice(0, l.length - 1),
                h = l[l.length - 1],
                u = [];
              for (let f = 0, m = h.length; f < m; f++) {
                const p = h[f],
                  g = o[f];
                let x;
                const _ = c[f];
                if (
                  g.mode === Kn.TRIANGLES ||
                  g.mode === Kn.TRIANGLE_STRIP ||
                  g.mode === Kn.TRIANGLE_FAN ||
                  g.mode === void 0
                )
                  (x = r.isSkinnedMesh === !0 ? new Kh(p, _) : new vn(p, _)),
                    x.isSkinnedMesh === !0 &&
                      !x.geometry.attributes.skinWeight.normalized &&
                      x.normalizeSkinWeights(),
                    g.mode === Kn.TRIANGLE_STRIP
                      ? (x.geometry = cf(x.geometry, __))
                      : g.mode === Kn.TRIANGLE_FAN &&
                        (x.geometry = cf(x.geometry, Kp));
                else if (g.mode === Kn.LINES) x = new Sl(p, _);
                else if (g.mode === Kn.LINE_STRIP) x = new wl(p, _);
                else if (g.mode === Kn.LINE_LOOP) x = new wm(p, _);
                else if (g.mode === Kn.POINTS) x = new Sm(p, _);
                else
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + g.mode
                  );
                Object.keys(x.geometry.morphAttributes).length > 0 && aS(x, r),
                  (x.name = t.createUniqueName(r.name || "mesh_" + e)),
                  Zi(x, r),
                  g.extensions && Qs(i, x, g),
                  t.assignFinalMaterial(x),
                  u.push(x);
              }
              if (u.length === 1) return u[0];
              const d = new Ii();
              for (let f = 0, m = u.length; f < m; f++) d.add(u[f]);
              return d;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            i = n[n.type];
          if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return (
            n.type === "perspective"
              ? (t = new tn(
                  V_.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : n.type === "orthographic" &&
                (t = new hu(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            Zi(t, n),
            Promise.resolve(t)
          );
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = { joints: t.joints };
          return t.inverseBindMatrices === void 0
            ? Promise.resolve(n)
            : this.getDependency("accessor", t.inverseBindMatrices).then(
                function (i) {
                  return (n.inverseBindMatrices = i), n;
                }
              );
        }
        loadAnimation(e) {
          const n = this.json.animations[e],
            i = [],
            r = [],
            o = [],
            a = [],
            l = [];
          for (let c = 0, h = n.channels.length; c < h; c++) {
            const u = n.channels[c],
              d = n.samplers[u.sampler],
              f = u.target,
              m = f.node !== void 0 ? f.node : f.id,
              p = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
              g = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
            i.push(this.getDependency("node", m)),
              r.push(this.getDependency("accessor", p)),
              o.push(this.getDependency("accessor", g)),
              a.push(d),
              l.push(f);
          }
          return Promise.all([
            Promise.all(i),
            Promise.all(r),
            Promise.all(o),
            Promise.all(a),
            Promise.all(l),
          ]).then(function (c) {
            const h = c[0],
              u = c[1],
              d = c[2],
              f = c[3],
              m = c[4],
              p = [];
            for (let x = 0, _ = h.length; x < _; x++) {
              const M = h[x],
                S = u[x],
                v = d[x],
                y = f[x],
                C = m[x];
              if (M === void 0) continue;
              M.updateMatrix(), (M.matrixAutoUpdate = !0);
              let U;
              switch (bi[C.path]) {
                case bi.weights:
                  U = Do;
                  break;
                case bi.rotation:
                  U = Ls;
                  break;
                case bi.position:
                case bi.scale:
                default:
                  U = Io;
                  break;
              }
              const K = M.name ? M.name : M.uuid,
                X = y.interpolation !== void 0 ? rS[y.interpolation] : cs,
                b = [];
              bi[C.path] === bi.weights
                ? M.traverse(function (I) {
                    I.isMesh === !0 &&
                      I.morphTargetInfluences &&
                      b.push(I.name ? I.name : I.uuid);
                  })
                : b.push(K);
              let D = v.array;
              if (v.normalized) {
                const I = Eh(D.constructor),
                  L = new Float32Array(D.length);
                for (let B = 0, R = D.length; B < R; B++) L[B] = D[B] * I;
                D = L;
              }
              for (let I = 0, L = b.length; I < L; I++) {
                const B = new U(b[I] + "." + bi[C.path], S.array, D, X);
                y.interpolation === "CUBICSPLINE" &&
                  ((B.createInterpolant = function (V) {
                    return new fs(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      V
                    );
                  }),
                  (B.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  p.push(B);
              }
            }
            const g = n.name ? n.name : "animation_" + e;
            return new bh(g, void 0, p);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return i.mesh === void 0
            ? null
            : n.getDependency("mesh", i.mesh).then(function (r) {
                const o = n._getNodeRef(n.meshCache, i.mesh, r);
                return (
                  i.weights !== void 0 &&
                    o.traverse(function (a) {
                      if (!!a.isMesh)
                        for (let l = 0, c = i.weights.length; l < c; l++)
                          a.morphTargetInfluences[l] = i.weights[l];
                    }),
                  o
                );
              });
        }
        loadNode(e) {
          const t = this.json,
            n = this.extensions,
            i = this,
            r = t.nodes[e],
            o = r.name ? i.createUniqueName(r.name) : "";
          return (function () {
            const a = [],
              l = i._invokeOne(function (c) {
                return c.createNodeMesh && c.createNodeMesh(e);
              });
            return (
              l && a.push(l),
              r.camera !== void 0 &&
                a.push(
                  i.getDependency("camera", r.camera).then(function (c) {
                    return i._getNodeRef(i.cameraCache, r.camera, c);
                  })
                ),
              i
                ._invokeAll(function (c) {
                  return c.createNodeAttachment && c.createNodeAttachment(e);
                })
                .forEach(function (c) {
                  a.push(c);
                }),
              Promise.all(a)
            );
          })().then(function (a) {
            let l;
            if (
              (r.isBone === !0
                ? (l = new Qh())
                : a.length > 1
                ? (l = new Ii())
                : a.length === 1
                ? (l = a[0])
                : (l = new Ke()),
              l !== a[0])
            )
              for (let c = 0, h = a.length; c < h; c++) l.add(a[c]);
            if (
              (r.name && ((l.userData.name = r.name), (l.name = o)),
              Zi(l, r),
              r.extensions && Qs(n, l, r),
              r.matrix !== void 0)
            ) {
              const c = new Ge();
              c.fromArray(r.matrix), l.applyMatrix4(c);
            } else r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
            return i.associations.set(l, { type: "nodes", index: e }), l;
          });
        }
        loadScene(e) {
          const t = this.json,
            n = this.extensions,
            i = this.json.scenes[e],
            r = this,
            o = new Ii();
          i.name && (o.name = r.createUniqueName(i.name)),
            Zi(o, i),
            i.extensions && Qs(n, o, i);
          const a = i.nodes || [],
            l = [];
          for (let c = 0, h = a.length; c < h; c++) l.push(Xm(a[c], o, t, r));
          return Promise.all(l).then(function () {
            return o;
          });
        }
      }
      function Xm(s, e, t, n) {
        const i = t.nodes[s];
        return n
          .getDependency("node", s)
          .then(function (r) {
            if (i.skin === void 0) return r;
            let o;
            return n
              .getDependency("skin", i.skin)
              .then(function (a) {
                o = a;
                const l = [];
                for (let c = 0, h = o.joints.length; c < h; c++)
                  l.push(n.getDependency("node", o.joints[c]));
                return Promise.all(l);
              })
              .then(function (a) {
                return (
                  r.traverse(function (l) {
                    if (!l.isMesh) return;
                    const c = [],
                      h = [];
                    for (let u = 0, d = a.length; u < d; u++) {
                      const f = a[u];
                      if (f) {
                        c.push(f);
                        const m = new Ge();
                        o.inverseBindMatrices !== void 0 &&
                          m.fromArray(o.inverseBindMatrices.array, u * 16),
                          h.push(m);
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          o.joints[u]
                        );
                    }
                    l.bind(new eu(c, h), l.matrixWorld);
                  }),
                  r
                );
              });
          })
          .then(function (r) {
            e.add(r);
            const o = [];
            if (i.children) {
              const a = i.children;
              for (let l = 0, c = a.length; l < c; l++) {
                const h = a[l];
                o.push(Xm(h, r, t, n));
              }
            }
            return Promise.all(o);
          });
      }
      function hS(s, e, t) {
        const n = e.attributes,
          i = new pn();
        if (n.POSITION !== void 0) {
          const a = t.json.accessors[n.POSITION],
            l = a.min,
            c = a.max;
          if (l !== void 0 && c !== void 0) {
            if (
              (i.set(new G(l[0], l[1], l[2]), new G(c[0], c[1], c[2])),
              a.normalized)
            ) {
              const h = Eh(No[a.componentType]);
              i.min.multiplyScalar(h), i.max.multiplyScalar(h);
            }
          } else {
            console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
            return;
          }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
          const a = new G(),
            l = new G();
          for (let c = 0, h = r.length; c < h; c++) {
            const u = r[c];
            if (u.POSITION !== void 0) {
              const d = t.json.accessors[u.POSITION],
                f = d.min,
                m = d.max;
              if (f !== void 0 && m !== void 0) {
                if (
                  (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))),
                  l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))),
                  l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))),
                  d.normalized)
                ) {
                  const p = Eh(No[d.componentType]);
                  l.multiplyScalar(p);
                }
                a.max(l);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          i.expandByVector(a);
        }
        s.boundingBox = i;
        const o = new ar();
        i.getCenter(o.center),
          (o.radius = i.min.distanceTo(i.max) / 2),
          (s.boundingSphere = o);
      }
      function lf(s, e, t) {
        const n = e.attributes,
          i = [];
        function r(o, a) {
          return t.getDependency("accessor", o).then(function (l) {
            s.setAttribute(a, l);
          });
        }
        for (const o in n) {
          const a = Th[o] || o.toLowerCase();
          a in s.attributes || i.push(r(n[o], a));
        }
        if (e.indices !== void 0 && !s.index) {
          const o = t.getDependency("accessor", e.indices).then(function (a) {
            s.setIndex(a);
          });
          i.push(o);
        }
        return (
          Zi(s, e),
          hS(s, e, t),
          Promise.all(i).then(function () {
            return e.targets !== void 0 ? oS(s, e.targets, t) : s;
          })
        );
      }
      function cf(s, e) {
        let t = s.getIndex();
        if (t === null) {
          const o = [],
            a = s.getAttribute("position");
          if (a !== void 0) {
            for (let l = 0; l < a.count; l++) o.push(l);
            s.setIndex(o), (t = s.getIndex());
          } else
            return (
              console.error(
                "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
              ),
              s
            );
        }
        const n = t.count - 2,
          i = [];
        if (e === Kp)
          for (let o = 1; o <= n; o++)
            i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
        else
          for (let o = 0; o < n; o++)
            o % 2 === 0
              ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2)))
              : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n &&
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
          );
        const r = s.clone();
        return r.setIndex(i), r;
      }
      /**
       * @license
       * Copyright 2010-2022 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const mu = "139",
        uS = 0,
        hf = 1,
        dS = 2,
        jm = 1,
        Ym = 2,
        ho = 3,
        Fo = 0,
        Nn = 1,
        ps = 2,
        Zm = 1,
        zi = 0,
        ss = 1,
        uf = 2,
        df = 3,
        ff = 4,
        fS = 5,
        Yr = 100,
        pS = 101,
        mS = 102,
        pf = 103,
        mf = 104,
        gS = 200,
        xS = 201,
        _S = 202,
        vS = 203,
        Jm = 204,
        Km = 205,
        yS = 206,
        MS = 207,
        bS = 208,
        wS = 209,
        SS = 210,
        TS = 0,
        ES = 1,
        AS = 2,
        Ah = 3,
        LS = 4,
        RS = 5,
        CS = 6,
        PS = 7,
        Rl = 0,
        DS = 1,
        IS = 2,
        li = 0,
        NS = 1,
        FS = 2,
        BS = 3,
        zS = 4,
        OS = 5,
        Qm = 300,
        ms = 301,
        gs = 302,
        Lh = 303,
        Rh = 304,
        Cl = 306,
        Ch = 1e3,
        Pn = 1001,
        Ph = 1002,
        Ct = 1003,
        gf = 1004,
        xf = 1005,
        nn = 1006,
        US = 1007,
        Pl = 1008,
        rr = 1009,
        HS = 1010,
        GS = 1011,
        Bo = 1012,
        VS = 1013,
        ol = 1014,
        Qi = 1015,
        os = 1016,
        kS = 1017,
        WS = 1018,
        as = 1020,
        $S = 1021,
        qS = 1022,
        Dn = 1023,
        XS = 1024,
        jS = 1025,
        tr = 1026,
        xs = 1027,
        YS = 1028,
        ZS = 1029,
        JS = 1030,
        KS = 1031,
        QS = 1033,
        Tc = 33776,
        Ec = 33777,
        Ac = 33778,
        Lc = 33779,
        _f = 35840,
        vf = 35841,
        yf = 35842,
        Mf = 35843,
        e1 = 36196,
        bf = 37492,
        wf = 37496,
        Sf = 37808,
        Tf = 37809,
        Ef = 37810,
        Af = 37811,
        Lf = 37812,
        Rf = 37813,
        Cf = 37814,
        Pf = 37815,
        Df = 37816,
        If = 37817,
        Nf = 37818,
        Ff = 37819,
        Bf = 37820,
        zf = 37821,
        Of = 36492,
        t1 = 2200,
        n1 = 2201,
        i1 = 2202,
        pl = 2300,
        ml = 2301,
        Rc = 2302,
        Qr = 2400,
        es = 2401,
        gl = 2402,
        gu = 2500,
        eg = 2501,
        r1 = 0,
        hi = 3e3,
        ht = 3001,
        s1 = 3200,
        o1 = 3201,
        Cs = 0,
        a1 = 1,
        si = "srgb",
        er = "srgb-linear",
        Cc = 7680,
        l1 = 519,
        zo = 35044,
        xl = 35048,
        Uf = "300 es",
        Dh = 1035;
      class lr {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e];
          if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e.type];
          if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
            e.target = null;
          }
        }
      }
      const Bt = [];
      for (let s = 0; s < 256; s++)
        Bt[s] = (s < 16 ? "0" : "") + s.toString(16);
      const Pc = Math.PI / 180,
        Ih = 180 / Math.PI;
      function Vn() {
        const s = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          Bt[s & 255] +
          Bt[(s >> 8) & 255] +
          Bt[(s >> 16) & 255] +
          Bt[(s >> 24) & 255] +
          "-" +
          Bt[e & 255] +
          Bt[(e >> 8) & 255] +
          "-" +
          Bt[((e >> 16) & 15) | 64] +
          Bt[(e >> 24) & 255] +
          "-" +
          Bt[(t & 63) | 128] +
          Bt[(t >> 8) & 255] +
          "-" +
          Bt[(t >> 16) & 255] +
          Bt[(t >> 24) & 255] +
          Bt[n & 255] +
          Bt[(n >> 8) & 255] +
          Bt[(n >> 16) & 255] +
          Bt[(n >> 24) & 255]
        ).toLowerCase();
      }
      function $t(s, e, t) {
        return Math.max(e, Math.min(t, s));
      }
      function c1(s, e) {
        return ((s % e) + e) % e;
      }
      function Dc(s, e, t) {
        return (1 - t) * s + t * e;
      }
      function Hf(s) {
        return (s & (s - 1)) === 0 && s !== 0;
      }
      function Nh(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      class ye {
        constructor(e = 0, t = 0) {
          (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      ye.prototype.isVector2 = !0;
      class Ut {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, l, c) {
          const h = this.elements;
          return (
            (h[0] = e),
            (h[1] = i),
            (h[2] = a),
            (h[3] = t),
            (h[4] = r),
            (h[5] = l),
            (h[6] = n),
            (h[7] = o),
            (h[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            u = n[7],
            d = n[2],
            f = n[5],
            m = n[8],
            p = i[0],
            g = i[3],
            x = i[6],
            _ = i[1],
            M = i[4],
            S = i[7],
            v = i[2],
            y = i[5],
            C = i[8];
          return (
            (r[0] = o * p + a * _ + l * v),
            (r[3] = o * g + a * M + l * y),
            (r[6] = o * x + a * S + l * C),
            (r[1] = c * p + h * _ + u * v),
            (r[4] = c * g + h * M + u * y),
            (r[7] = c * x + h * S + u * C),
            (r[2] = d * p + f * _ + m * v),
            (r[5] = d * g + f * M + m * y),
            (r[8] = d * x + f * S + m * C),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8];
          return (
            t * o * h -
            t * a * c -
            n * r * h +
            n * a * l +
            i * r * c -
            i * o * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = h * o - a * c,
            d = a * l - h * r,
            f = c * r - o * l,
            m = t * u + n * d + i * f;
          if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const p = 1 / m;
          return (
            (e[0] = u * p),
            (e[1] = (i * c - h * n) * p),
            (e[2] = (a * n - i * o) * p),
            (e[3] = d * p),
            (e[4] = (h * t - i * l) * p),
            (e[5] = (i * r - a * t) * p),
            (e[6] = f * p),
            (e[7] = (n * l - c * t) * p),
            (e[8] = (o * t - n * r) * p),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, o, a) {
          const l = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * l,
              n * c,
              -n * (l * o + c * a) + o + e,
              -i * c,
              i * l,
              -i * (-c * o + l * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            o = i[3],
            a = i[6],
            l = i[1],
            c = i[4],
            h = i[7];
          return (
            (i[0] = t * r + n * l),
            (i[3] = t * o + n * c),
            (i[6] = t * a + n * h),
            (i[1] = -n * r + t * l),
            (i[4] = -n * o + t * c),
            (i[7] = -n * a + t * h),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      Ut.prototype.isMatrix3 = !0;
      function tg(s) {
        for (let e = s.length - 1; e >= 0; --e) if (s[e] > 65535) return !0;
        return !1;
      }
      function Oo(s) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", s);
      }
      function nr(s) {
        return s < 0.04045
          ? s * 0.0773993808
          : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function al(s) {
        return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      const Ic = { [si]: { [er]: nr }, [er]: { [si]: al } },
        An = {
          legacyMode: !0,
          get workingColorSpace() {
            return er;
          },
          set workingColorSpace(s) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function (s, e, t) {
            if (this.legacyMode || e === t || !e || !t) return s;
            if (Ic[e] && Ic[e][t] !== void 0) {
              const n = Ic[e][t];
              return (s.r = n(s.r)), (s.g = n(s.g)), (s.b = n(s.b)), s;
            }
            throw new Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (s, e) {
            return this.convert(s, this.workingColorSpace, e);
          },
          toWorkingColorSpace: function (s, e) {
            return this.convert(s, e, this.workingColorSpace);
          },
        },
        ng = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        wt = { r: 0, g: 0, b: 0 },
        Ln = { h: 0, s: 0, l: 0 },
        Aa = { h: 0, s: 0, l: 0 };
      function Nc(s, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? s + (e - s) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? s + (e - s) * 6 * (2 / 3 - t)
            : s
        );
      }
      function La(s, e) {
        return (e.r = s.r), (e.g = s.g), (e.b = s.b), e;
      }
      class Ve {
        constructor(e, t, n) {
          return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : typeof e == "number"
              ? this.setHex(e)
              : typeof e == "string" && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = si) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            An.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, n, i = er) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            An.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(e, t, n, i = er) {
          if (((e = c1(e, 1)), (t = $t(t, 0, 1)), (n = $t(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
          else {
            const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              o = 2 * n - r;
            (this.r = Nc(o, r, e + 1 / 3)),
              (this.g = Nc(o, r, e)),
              (this.b = Nc(o, r, e - 1 / 3));
          }
          return An.toWorkingColorSpace(this, i), this;
        }
        setStyle(e, t = si) {
          function n(r) {
            r !== void 0 &&
              parseFloat(r) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let i;
          if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let r;
            const o = i[1],
              a = i[2];
            switch (o) {
              case "rgb":
              case "rgba":
                if (
                  (r =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                    An.toWorkingColorSpace(this, t),
                    n(r[4]),
                    this
                  );
                if (
                  (r =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                    An.toWorkingColorSpace(this, t),
                    n(r[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                ) {
                  const l = parseFloat(r[1]) / 360,
                    c = parseInt(r[2], 10) / 100,
                    h = parseInt(r[3], 10) / 100;
                  return n(r[4]), this.setHSL(l, c, h, t);
                }
                break;
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const r = i[1],
              o = r.length;
            if (o === 3)
              return (
                (this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255),
                (this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255),
                (this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255),
                An.toWorkingColorSpace(this, t),
                this
              );
            if (o === 6)
              return (
                (this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255),
                (this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255),
                (this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255),
                An.toWorkingColorSpace(this, t),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e, t) : this;
        }
        setColorName(e, t = si) {
          const n = ng[e.toLowerCase()];
          return (
            n !== void 0
              ? this.setHex(n, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = nr(e.r)), (this.g = nr(e.g)), (this.b = nr(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = al(e.r)), (this.g = al(e.g)), (this.b = al(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = si) {
          return (
            An.fromWorkingColorSpace(La(this, wt), e),
            ($t(wt.r * 255, 0, 255) << 16) ^
              ($t(wt.g * 255, 0, 255) << 8) ^
              ($t(wt.b * 255, 0, 255) << 0)
          );
        }
        getHexString(e = si) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = er) {
          An.fromWorkingColorSpace(La(this, wt), t);
          const n = wt.r,
            i = wt.g,
            r = wt.b,
            o = Math.max(n, i, r),
            a = Math.min(n, i, r);
          let l, c;
          const h = (a + o) / 2;
          if (a === o) (l = 0), (c = 0);
          else {
            const u = o - a;
            switch (((c = h <= 0.5 ? u / (o + a) : u / (2 - o - a)), o)) {
              case n:
                l = (i - r) / u + (i < r ? 6 : 0);
                break;
              case i:
                l = (r - n) / u + 2;
                break;
              case r:
                l = (n - i) / u + 4;
                break;
            }
            l /= 6;
          }
          return (e.h = l), (e.s = c), (e.l = h), e;
        }
        getRGB(e, t = er) {
          return (
            An.fromWorkingColorSpace(La(this, wt), t),
            (e.r = wt.r),
            (e.g = wt.g),
            (e.b = wt.b),
            e
          );
        }
        getStyle(e = si) {
          return (
            An.fromWorkingColorSpace(La(this, wt), e),
            e !== si
              ? `color(${e} ${wt.r} ${wt.g} ${wt.b})`
              : `rgb(${(wt.r * 255) | 0},${(wt.g * 255) | 0},${
                  (wt.b * 255) | 0
                })`
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(Ln),
            (Ln.h += e),
            (Ln.s += t),
            (Ln.l += n),
            this.setHSL(Ln.h, Ln.s, Ln.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(Ln), e.getHSL(Aa);
          const n = Dc(Ln.h, Aa.h, t),
            i = Dc(Ln.s, Aa.s, t),
            r = Dc(Ln.l, Aa.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      Ve.NAMES = ng;
      Ve.prototype.isColor = !0;
      Ve.prototype.r = 1;
      Ve.prototype.g = 1;
      Ve.prototype.b = 1;
      let Cr;
      class cr {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            Cr === void 0 && (Cr = Oo("canvas")),
              (Cr.width = e.width),
              (Cr.height = e.height);
            const n = Cr.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = Cr);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            (typeof HTMLImageElement != "undefined" &&
              e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement != "undefined" &&
              e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
          ) {
            const t = Oo("canvas");
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
              r = i.data;
            for (let o = 0; o < r.length; o++) r[o] = nr(r[o] / 255) * 255;
            return n.putImageData(i, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray
                ? (t[n] = Math.floor(nr(t[n] / 255) * 255))
                : (t[n] = nr(t[n]));
            return { data: t, width: e.width, height: e.height };
          } else
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              e
            );
        }
      }
      class ig {
        constructor(e = null) {
          (this.uuid = Vn()), (this.data = e), (this.version = 0);
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            i = this.data;
          if (i !== null) {
            let r;
            if (Array.isArray(i)) {
              r = [];
              for (let o = 0, a = i.length; o < a; o++)
                i[o].isDataTexture ? r.push(Fc(i[o].image)) : r.push(Fc(i[o]));
            } else r = Fc(i);
            n.url = r;
          }
          return t || (e.images[this.uuid] = n), n;
        }
      }
      function Fc(s) {
        return (typeof HTMLImageElement != "undefined" &&
          s instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            s instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && s instanceof ImageBitmap)
          ? cr.getDataURL(s)
          : s.data
          ? {
              data: Array.prototype.slice.call(s.data),
              width: s.width,
              height: s.height,
              type: s.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      ig.prototype.isSource = !0;
      let h1 = 0;
      class Nt extends lr {
        constructor(
          e = Nt.DEFAULT_IMAGE,
          t = Nt.DEFAULT_MAPPING,
          n = Pn,
          i = Pn,
          r = nn,
          o = Pl,
          a = Dn,
          l = rr,
          c = 1,
          h = hi
        ) {
          super(),
            Object.defineProperty(this, "id", { value: h1++ }),
            (this.uuid = Vn()),
            (this.name = ""),
            (this.source = new ig(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = o),
            (this.anisotropy = c),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = l),
            (this.offset = new ye(0, 0)),
            (this.repeat = new ye(1, 1)),
            (this.center = new ye(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Ut()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = h),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        get image() {
          return this.source.data;
        }
        set image(e) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== Qm) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case Ch:
                e.x = e.x - Math.floor(e.x);
                break;
              case Pn:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case Ph:
                Math.abs(Math.floor(e.x) % 2) === 1
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case Ch:
                e.y = e.y - Math.floor(e.y);
                break;
              case Pn:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case Ph:
                Math.abs(Math.floor(e.y) % 2) === 1
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && (this.version++, (this.source.needsUpdate = !0));
        }
      }
      Nt.DEFAULT_IMAGE = null;
      Nt.DEFAULT_MAPPING = Qm;
      Nt.prototype.isTexture = !0;
      class st {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.x = e), (this.y = t), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const l = e.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            m = l[9],
            p = l[2],
            g = l[6],
            x = l[10];
          if (
            Math.abs(h - d) < 0.01 &&
            Math.abs(u - p) < 0.01 &&
            Math.abs(m - g) < 0.01
          ) {
            if (
              Math.abs(h + d) < 0.1 &&
              Math.abs(u + p) < 0.1 &&
              Math.abs(m + g) < 0.1 &&
              Math.abs(c + f + x - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const M = (c + 1) / 2,
              S = (f + 1) / 2,
              v = (x + 1) / 2,
              y = (h + d) / 4,
              C = (u + p) / 4,
              U = (m + g) / 4;
            return (
              M > S && M > v
                ? M < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(M)), (i = y / n), (r = C / n))
                : S > v
                ? S < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(S)), (n = y / i), (r = U / i))
                : v < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = C / r), (i = U / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let _ = Math.sqrt(
            (g - m) * (g - m) + (u - p) * (u - p) + (d - h) * (d - h)
          );
          return (
            Math.abs(_) < 0.001 && (_ = 1),
            (this.x = (g - m) / _),
            (this.y = (u - p) / _),
            (this.z = (d - h) / _),
            (this.w = Math.acos((c + f + x - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      st.prototype.isVector4 = !0;
      class fn extends lr {
        constructor(e, t, n = {}) {
          super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new st(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new st(0, 0, e, t));
          const i = { width: e, height: t, depth: 1 };
          (this.texture = new Nt(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps =
              n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.internalFormat =
              n.internalFormat !== void 0 ? n.internalFormat : null),
            (this.texture.minFilter =
              n.minFilter !== void 0 ? n.minFilter : nn),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
              n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
              n.depthTexture !== void 0 ? n.depthTexture : null),
            (this.samples = n.samples !== void 0 ? n.samples : 0);
        }
        setSize(e, t, n = 1) {
          (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = Object.assign({}, e.texture.image)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            e.depthTexture !== null &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      fn.prototype.isWebGLRenderTarget = !0;
      class Dl extends Nt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = Ct),
            (this.minFilter = Ct),
            (this.wrapR = Pn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      Dl.prototype.isDataArrayTexture = !0;
      class u1 extends fn {
        constructor(e, t, n) {
          super(e, t),
            (this.depth = n),
            (this.texture = new Dl(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
        }
      }
      u1.prototype.isWebGLArrayRenderTarget = !0;
      class xu extends Nt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = Ct),
            (this.minFilter = Ct),
            (this.wrapR = Pn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      xu.prototype.isData3DTexture = !0;
      class d1 extends fn {
        constructor(e, t, n) {
          super(e, t),
            (this.depth = n),
            (this.texture = new xu(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
        }
      }
      d1.prototype.isWebGL3DRenderTarget = !0;
      class f1 extends fn {
        constructor(e, t, n, i = {}) {
          super(e, t, i);
          const r = this.texture;
          this.texture = [];
          for (let o = 0; o < n; o++)
            (this.texture[o] = r.clone()),
              (this.texture[o].isRenderTargetTexture = !0);
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = e),
                (this.texture[i].image.height = t),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
          );
        }
        copy(e) {
          this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            (this.texture.length = 0);
          for (let t = 0, n = e.texture.length; t < n; t++)
            this.texture[t] = e.texture[t].clone();
          return this;
        }
      }
      f1.prototype.isWebGLMultipleRenderTargets = !0;
      class an {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this._x = e), (this._y = t), (this._z = n), (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, r, o, a) {
          let l = n[i + 0],
            c = n[i + 1],
            h = n[i + 2],
            u = n[i + 3];
          const d = r[o + 0],
            f = r[o + 1],
            m = r[o + 2],
            p = r[o + 3];
          if (a === 0) {
            (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
            return;
          }
          if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = m), (e[t + 3] = p);
            return;
          }
          if (u !== p || l !== d || c !== f || h !== m) {
            let g = 1 - a;
            const x = l * d + c * f + h * m + u * p,
              _ = x >= 0 ? 1 : -1,
              M = 1 - x * x;
            if (M > Number.EPSILON) {
              const v = Math.sqrt(M),
                y = Math.atan2(v, x * _);
              (g = Math.sin(g * y) / v), (a = Math.sin(a * y) / v);
            }
            const S = a * _;
            if (
              ((l = l * g + d * S),
              (c = c * g + f * S),
              (h = h * g + m * S),
              (u = u * g + p * S),
              g === 1 - a)
            ) {
              const v = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
              (l *= v), (c *= v), (h *= v), (u *= v);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, o) {
          const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            u = r[o],
            d = r[o + 1],
            f = r[o + 2],
            m = r[o + 3];
          return (
            (e[t] = a * m + h * u + l * f - c * d),
            (e[t + 1] = l * m + h * d + c * u - a * f),
            (e[t + 2] = c * m + h * f + a * d - l * u),
            (e[t + 3] = h * m - a * u - l * d - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!(e && e.isEuler))
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            h = a(i / 2),
            u = a(r / 2),
            d = l(n / 2),
            f = l(i / 2),
            m = l(r / 2);
          switch (o) {
            case "XYZ":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "YXZ":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            case "ZXY":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "ZYX":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            case "YZX":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "XZY":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return t !== !1 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            h = t[6],
            u = t[10],
            d = n + a + u;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
              (this._x = (h - l) * f),
              (this._y = (r - c) * f),
              (this._z = (o - i) * f);
          } else if (n > a && n > u) {
            const f = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (h - l) / f),
              (this._x = 0.25 * f),
              (this._y = (i + o) / f),
              (this._z = (r + c) / f);
          } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (r - c) / f),
              (this._x = (i + o) / f),
              (this._y = 0.25 * f),
              (this._z = (l + h) / f);
          } else {
            const f = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (o - i) / f),
              (this._x = (r + c) / f),
              (this._y = (l + h) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs($t(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (n === 0) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            h = t._w;
          return (
            (this._x = n * h + o * a + i * c - r * l),
            (this._y = i * h + o * l + r * a - n * c),
            (this._z = r * h + o * c + n * l - i * a),
            (this._w = o * h - n * a - i * l - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            o = this._w;
          let a = o * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * n + t * this._x),
              (this._y = f * i + t * this._y),
              (this._z = f * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            h = Math.atan2(c, a),
            u = Math.sin((1 - t) * h) / c,
            d = Math.sin(t * h) / c;
          return (
            (this._w = o * u + this._w * d),
            (this._x = n * u + this._x * d),
            (this._y = i * u + this._y * d),
            (this._z = r * u + this._z * d),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          return this.copy(e).slerp(t, n);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            n = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
          return this.set(
            t * Math.cos(i),
            n * Math.sin(r),
            n * Math.cos(r),
            t * Math.sin(i)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      an.prototype.isQuaternion = !0;
      class W {
        constructor(e = 0, t = 0, n = 0) {
          (this.x = e), (this.y = t), (this.z = n);
        }
        set(e, t, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(Gf.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(Gf.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * i - a * n,
            h = l * n + a * t - r * i,
            u = l * i + r * n - o * t,
            d = -r * t - o * n - a * i;
          return (
            (this.x = c * l + d * -r + h * -a - u * -o),
            (this.y = h * l + d * -o + u * -r - c * -a),
            (this.z = u * l + d * -a + c * -o - h * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = i * l - r * a),
            (this.y = r * o - n * l),
            (this.z = n * a - i * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return Bc.copy(this).projectOnVector(e), this.sub(Bc);
        }
        reflect(e) {
          return this.sub(Bc.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos($t(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = (Math.random() - 0.5) * 2,
            t = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - e ** 2);
          return (
            (this.x = n * Math.cos(t)),
            (this.y = n * Math.sin(t)),
            (this.z = e),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      W.prototype.isVector3 = !0;
      const Bc = new W(),
        Gf = new an();
      class Bn {
        constructor(
          e = new W(1 / 0, 1 / 0, 1 / 0),
          t = new W(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.length; l < c; l += 3) {
            const h = e[l],
              u = e[l + 1],
              d = e[l + 2];
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > r && (r = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.count; l < c; l++) {
            const h = e.getX(l),
              u = e.getY(l),
              d = e.getZ(l);
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > r && (r = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Xi.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const n = e.geometry;
          if (n !== void 0)
            if (t && n.attributes != null && n.attributes.position !== void 0) {
              const r = n.attributes.position;
              for (let o = 0, a = r.count; o < a; o++)
                Xi.fromBufferAttribute(r, o).applyMatrix4(e.matrixWorld),
                  this.expandByPoint(Xi);
            } else
              n.boundingBox === null && n.computeBoundingBox(),
                zc.copy(n.boundingBox),
                zc.applyMatrix4(e.matrixWorld),
                this.union(zc);
          const i = e.children;
          for (let r = 0, o = i.length; r < o; r++)
            this.expandByObject(i[r], t);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, Xi),
            Xi.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(eo),
            Ra.subVectors(this.max, eo),
            Pr.subVectors(e.a, eo),
            Dr.subVectors(e.b, eo),
            Ir.subVectors(e.c, eo),
            wi.subVectors(Dr, Pr),
            Si.subVectors(Ir, Dr),
            ji.subVectors(Pr, Ir);
          let t = [
            0,
            -wi.z,
            wi.y,
            0,
            -Si.z,
            Si.y,
            0,
            -ji.z,
            ji.y,
            wi.z,
            0,
            -wi.x,
            Si.z,
            0,
            -Si.x,
            ji.z,
            0,
            -ji.x,
            -wi.y,
            wi.x,
            0,
            -Si.y,
            Si.x,
            0,
            -ji.y,
            ji.x,
            0,
          ];
          return !Oc(t, Pr, Dr, Ir, Ra) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Oc(t, Pr, Dr, Ir, Ra))
            ? !1
            : (Ca.crossVectors(wi, Si),
              (t = [Ca.x, Ca.y, Ca.z]),
              Oc(t, Pr, Dr, Ir, Ra));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return Xi.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            this.getCenter(e.center),
            (e.radius = this.getSize(Xi).length() * 0.5),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (Qn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Qn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Qn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Qn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Qn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Qn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Qn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Qn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Qn),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      Bn.prototype.isBox3 = !0;
      const Qn = [
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
          new W(),
        ],
        Xi = new W(),
        zc = new Bn(),
        Pr = new W(),
        Dr = new W(),
        Ir = new W(),
        wi = new W(),
        Si = new W(),
        ji = new W(),
        eo = new W(),
        Ra = new W(),
        Ca = new W(),
        Yi = new W();
      function Oc(s, e, t, n, i) {
        for (let r = 0, o = s.length - 3; r <= o; r += 3) {
          Yi.fromArray(s, r);
          const a =
              i.x * Math.abs(Yi.x) +
              i.y * Math.abs(Yi.y) +
              i.z * Math.abs(Yi.z),
            l = e.dot(Yi),
            c = t.dot(Yi),
            h = n.dot(Yi);
          if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
        }
        return !0;
      }
      const p1 = new Bn(),
        Vf = new W(),
        Pa = new W(),
        Uc = new W();
      class Ps {
        constructor(e = new W(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          t !== void 0 ? n.copy(t) : p1.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let r = 0, o = e.length; r < o; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          Uc.subVectors(e, this.center);
          const t = Uc.lengthSq();
          if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
              i = (n - this.radius) * 0.5;
            this.center.add(Uc.multiplyScalar(i / n)), (this.radius += i);
          }
          return this;
        }
        union(e) {
          return (
            this.center.equals(e.center) === !0
              ? Pa.set(0, 0, 1).multiplyScalar(e.radius)
              : Pa.subVectors(e.center, this.center)
                  .normalize()
                  .multiplyScalar(e.radius),
            this.expandByPoint(Vf.copy(e.center).add(Pa)),
            this.expandByPoint(Vf.copy(e.center).sub(Pa)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ei = new W(),
        Hc = new W(),
        Da = new W(),
        Ti = new W(),
        Gc = new W(),
        Ia = new W(),
        Vc = new W();
      class Ds {
        constructor(e = new W(), t = new W(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, ei)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = ei.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (ei.copy(this.direction).multiplyScalar(t).add(this.origin),
              ei.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          Hc.copy(e).add(t).multiplyScalar(0.5),
            Da.copy(t).sub(e).normalize(),
            Ti.copy(this.origin).sub(Hc);
          const r = e.distanceTo(t) * 0.5,
            o = -this.direction.dot(Da),
            a = Ti.dot(this.direction),
            l = -Ti.dot(Da),
            c = Ti.lengthSq(),
            h = Math.abs(1 - o * o);
          let u, d, f, m;
          if (h > 0)
            if (((u = o * l - a), (d = o * a - l), (m = r * h), u >= 0))
              if (d >= -m)
                if (d <= m) {
                  const p = 1 / h;
                  (u *= p),
                    (d *= p),
                    (f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c);
                } else
                  (d = r),
                    (u = Math.max(0, -(o * d + a))),
                    (f = -u * u + d * (d + 2 * l) + c);
              else
                (d = -r),
                  (u = Math.max(0, -(o * d + a))),
                  (f = -u * u + d * (d + 2 * l) + c);
            else
              d <= -m
                ? ((u = Math.max(0, -(-o * r + a))),
                  (d = u > 0 ? -r : Math.min(Math.max(-r, -l), r)),
                  (f = -u * u + d * (d + 2 * l) + c))
                : d <= m
                ? ((u = 0),
                  (d = Math.min(Math.max(-r, -l), r)),
                  (f = d * (d + 2 * l) + c))
                : ((u = Math.max(0, -(o * r + a))),
                  (d = u > 0 ? r : Math.min(Math.max(-r, -l), r)),
                  (f = -u * u + d * (d + 2 * l) + c));
          else
            (d = o > 0 ? -r : r),
              (u = Math.max(0, -(o * d + a))),
              (f = -u * u + d * (d + 2 * l) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(Da).multiplyScalar(d).add(Hc),
            f
          );
        }
        intersectSphere(e, t) {
          ei.subVectors(e.center, this.origin);
          const n = ei.dot(this.direction),
            i = ei.dot(ei) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const o = Math.sqrt(r - i),
            a = n - o,
            l = n + o;
          return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, o, a, l;
          const c = 1 / this.direction.x,
            h = 1 / this.direction.y,
            u = 1 / this.direction.z,
            d = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
              : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
            h >= 0
              ? ((r = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h))
              : ((r = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
            n > o ||
            r > i ||
            ((r > n || n !== n) && (n = r),
            (o < i || i !== i) && (i = o),
            u >= 0
              ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
              : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
            n > l || a > i) ||
            ((a > n || n !== n) && (n = a),
            (l < i || i !== i) && (i = l),
            i < 0)
              ? null
              : this.at(n >= 0 ? n : i, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, ei) !== null;
        }
        intersectTriangle(e, t, n, i, r) {
          Gc.subVectors(t, e), Ia.subVectors(n, e), Vc.crossVectors(Gc, Ia);
          let o = this.direction.dot(Vc),
            a;
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else if (o < 0) (a = -1), (o = -o);
          else return null;
          Ti.subVectors(this.origin, e);
          const l = a * this.direction.dot(Ia.crossVectors(Ti, Ia));
          if (l < 0) return null;
          const c = a * this.direction.dot(Gc.cross(Ti));
          if (c < 0 || l + c > o) return null;
          const h = -a * Ti.dot(Vc);
          return h < 0 ? null : this.at(h / o, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class We {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, l, c, h, u, d, f, m, p, g) {
          const x = this.elements;
          return (
            (x[0] = e),
            (x[4] = t),
            (x[8] = n),
            (x[12] = i),
            (x[1] = r),
            (x[5] = o),
            (x[9] = a),
            (x[13] = l),
            (x[2] = c),
            (x[6] = h),
            (x[10] = u),
            (x[14] = d),
            (x[3] = f),
            (x[7] = m),
            (x[11] = p),
            (x[15] = g),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new We().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / Nr.setFromMatrixColumn(e, 0).length(),
            r = 1 / Nr.setFromMatrixColumn(e, 1).length(),
            o = 1 / Nr.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * o),
            (t[9] = n[9] * o),
            (t[10] = n[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            h = Math.cos(r),
            u = Math.sin(r);
          if (e.order === "XYZ") {
            const d = o * h,
              f = o * u,
              m = a * h,
              p = a * u;
            (t[0] = l * h),
              (t[4] = -l * u),
              (t[8] = c),
              (t[1] = f + m * c),
              (t[5] = d - p * c),
              (t[9] = -a * l),
              (t[2] = p - d * c),
              (t[6] = m + f * c),
              (t[10] = o * l);
          } else if (e.order === "YXZ") {
            const d = l * h,
              f = l * u,
              m = c * h,
              p = c * u;
            (t[0] = d + p * a),
              (t[4] = m * a - f),
              (t[8] = o * c),
              (t[1] = o * u),
              (t[5] = o * h),
              (t[9] = -a),
              (t[2] = f * a - m),
              (t[6] = p + d * a),
              (t[10] = o * l);
          } else if (e.order === "ZXY") {
            const d = l * h,
              f = l * u,
              m = c * h,
              p = c * u;
            (t[0] = d - p * a),
              (t[4] = -o * u),
              (t[8] = m + f * a),
              (t[1] = f + m * a),
              (t[5] = o * h),
              (t[9] = p - d * a),
              (t[2] = -o * c),
              (t[6] = a),
              (t[10] = o * l);
          } else if (e.order === "ZYX") {
            const d = o * h,
              f = o * u,
              m = a * h,
              p = a * u;
            (t[0] = l * h),
              (t[4] = m * c - f),
              (t[8] = d * c + p),
              (t[1] = l * u),
              (t[5] = p * c + d),
              (t[9] = f * c - m),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = o * l);
          } else if (e.order === "YZX") {
            const d = o * l,
              f = o * c,
              m = a * l,
              p = a * c;
            (t[0] = l * h),
              (t[4] = p - d * u),
              (t[8] = m * u + f),
              (t[1] = u),
              (t[5] = o * h),
              (t[9] = -a * h),
              (t[2] = -c * h),
              (t[6] = f * u + m),
              (t[10] = d - p * u);
          } else if (e.order === "XZY") {
            const d = o * l,
              f = o * c,
              m = a * l,
              p = a * c;
            (t[0] = l * h),
              (t[4] = -u),
              (t[8] = c * h),
              (t[1] = d * u + p),
              (t[5] = o * h),
              (t[9] = f * u - m),
              (t[2] = m * u - f),
              (t[6] = a * h),
              (t[10] = p * u + d);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(m1, e, g1);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            un.subVectors(e, t),
            un.lengthSq() === 0 && (un.z = 1),
            un.normalize(),
            Ei.crossVectors(n, un),
            Ei.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (un.x += 1e-4) : (un.z += 1e-4),
              un.normalize(),
              Ei.crossVectors(n, un)),
            Ei.normalize(),
            Na.crossVectors(un, Ei),
            (i[0] = Ei.x),
            (i[4] = Na.x),
            (i[8] = un.x),
            (i[1] = Ei.y),
            (i[5] = Na.y),
            (i[9] = un.y),
            (i[2] = Ei.z),
            (i[6] = Na.z),
            (i[10] = un.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            u = n[5],
            d = n[9],
            f = n[13],
            m = n[2],
            p = n[6],
            g = n[10],
            x = n[14],
            _ = n[3],
            M = n[7],
            S = n[11],
            v = n[15],
            y = i[0],
            C = i[4],
            U = i[8],
            K = i[12],
            X = i[1],
            b = i[5],
            D = i[9],
            I = i[13],
            L = i[2],
            B = i[6],
            R = i[10],
            V = i[14],
            H = i[3],
            J = i[7],
            ie = i[11],
            ne = i[15];
          return (
            (r[0] = o * y + a * X + l * L + c * H),
            (r[4] = o * C + a * b + l * B + c * J),
            (r[8] = o * U + a * D + l * R + c * ie),
            (r[12] = o * K + a * I + l * V + c * ne),
            (r[1] = h * y + u * X + d * L + f * H),
            (r[5] = h * C + u * b + d * B + f * J),
            (r[9] = h * U + u * D + d * R + f * ie),
            (r[13] = h * K + u * I + d * V + f * ne),
            (r[2] = m * y + p * X + g * L + x * H),
            (r[6] = m * C + p * b + g * B + x * J),
            (r[10] = m * U + p * D + g * R + x * ie),
            (r[14] = m * K + p * I + g * V + x * ne),
            (r[3] = _ * y + M * X + S * L + v * H),
            (r[7] = _ * C + M * b + S * B + v * J),
            (r[11] = _ * U + M * D + S * R + v * ie),
            (r[15] = _ * K + M * I + S * V + v * ne),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            h = e[2],
            u = e[6],
            d = e[10],
            f = e[14],
            m = e[3],
            p = e[7],
            g = e[11],
            x = e[15];
          return (
            m *
              (+r * l * u -
                i * c * u -
                r * a * d +
                n * c * d +
                i * a * f -
                n * l * f) +
            p *
              (+t * l * f -
                t * c * d +
                r * o * d -
                i * o * f +
                i * c * h -
                r * l * h) +
            g *
              (+t * c * u -
                t * a * f -
                r * o * u +
                n * o * f +
                r * a * h -
                n * c * h) +
            x *
              (-i * a * h -
                t * l * u +
                t * a * d +
                i * o * u -
                n * o * d +
                n * l * h)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = e[9],
            d = e[10],
            f = e[11],
            m = e[12],
            p = e[13],
            g = e[14],
            x = e[15],
            _ =
              u * g * c -
              p * d * c +
              p * l * f -
              a * g * f -
              u * l * x +
              a * d * x,
            M =
              m * d * c -
              h * g * c -
              m * l * f +
              o * g * f +
              h * l * x -
              o * d * x,
            S =
              h * p * c -
              m * u * c +
              m * a * f -
              o * p * f -
              h * a * x +
              o * u * x,
            v =
              m * u * l -
              h * p * l -
              m * a * d +
              o * p * d +
              h * a * g -
              o * u * g,
            y = t * _ + n * M + i * S + r * v;
          if (y === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const C = 1 / y;
          return (
            (e[0] = _ * C),
            (e[1] =
              (p * d * r -
                u * g * r -
                p * i * f +
                n * g * f +
                u * i * x -
                n * d * x) *
              C),
            (e[2] =
              (a * g * r -
                p * l * r +
                p * i * c -
                n * g * c -
                a * i * x +
                n * l * x) *
              C),
            (e[3] =
              (u * l * r -
                a * d * r -
                u * i * c +
                n * d * c +
                a * i * f -
                n * l * f) *
              C),
            (e[4] = M * C),
            (e[5] =
              (h * g * r -
                m * d * r +
                m * i * f -
                t * g * f -
                h * i * x +
                t * d * x) *
              C),
            (e[6] =
              (m * l * r -
                o * g * r -
                m * i * c +
                t * g * c +
                o * i * x -
                t * l * x) *
              C),
            (e[7] =
              (o * d * r -
                h * l * r +
                h * i * c -
                t * d * c -
                o * i * f +
                t * l * f) *
              C),
            (e[8] = S * C),
            (e[9] =
              (m * u * r -
                h * p * r -
                m * n * f +
                t * p * f +
                h * n * x -
                t * u * x) *
              C),
            (e[10] =
              (o * p * r -
                m * a * r +
                m * n * c -
                t * p * c -
                o * n * x +
                t * a * x) *
              C),
            (e[11] =
              (h * a * r -
                o * u * r -
                h * n * c +
                t * u * c +
                o * n * f -
                t * a * f) *
              C),
            (e[12] = v * C),
            (e[13] =
              (h * p * i -
                m * u * i +
                m * n * d -
                t * p * d -
                h * n * g +
                t * u * g) *
              C),
            (e[14] =
              (m * a * i -
                o * p * i -
                m * n * l +
                t * p * l +
                o * n * g -
                t * a * g) *
              C),
            (e[15] =
              (o * u * i -
                h * a * i +
                h * n * l -
                t * u * l -
                o * n * d +
                t * a * d) *
              C),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            o = e.x,
            a = e.y,
            l = e.z,
            c = r * o,
            h = r * a;
          return (
            this.set(
              c * o + n,
              c * a - i * l,
              c * l + i * a,
              0,
              c * a + i * l,
              h * a + n,
              h * l - i * o,
              0,
              c * l - i * a,
              h * l + i * o,
              r * l * l + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, o) {
          return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = r + r,
            h = o + o,
            u = a + a,
            d = r * c,
            f = r * h,
            m = r * u,
            p = o * h,
            g = o * u,
            x = a * u,
            _ = l * c,
            M = l * h,
            S = l * u,
            v = n.x,
            y = n.y,
            C = n.z;
          return (
            (i[0] = (1 - (p + x)) * v),
            (i[1] = (f + S) * v),
            (i[2] = (m - M) * v),
            (i[3] = 0),
            (i[4] = (f - S) * y),
            (i[5] = (1 - (d + x)) * y),
            (i[6] = (g + _) * y),
            (i[7] = 0),
            (i[8] = (m + M) * C),
            (i[9] = (g - _) * C),
            (i[10] = (1 - (d + p)) * C),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = Nr.set(i[0], i[1], i[2]).length();
          const o = Nr.set(i[4], i[5], i[6]).length(),
            a = Nr.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            Rn.copy(this);
          const c = 1 / r,
            h = 1 / o,
            u = 1 / a;
          return (
            (Rn.elements[0] *= c),
            (Rn.elements[1] *= c),
            (Rn.elements[2] *= c),
            (Rn.elements[4] *= h),
            (Rn.elements[5] *= h),
            (Rn.elements[6] *= h),
            (Rn.elements[8] *= u),
            (Rn.elements[9] *= u),
            (Rn.elements[10] *= u),
            t.setFromRotationMatrix(Rn),
            (n.x = r),
            (n.y = o),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, o) {
          o === void 0 &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            l = (2 * r) / (t - e),
            c = (2 * r) / (n - i),
            h = (t + e) / (t - e),
            u = (n + i) / (n - i),
            d = -(o + r) / (o - r),
            f = (-2 * o * r) / (o - r);
          return (
            (a[0] = l),
            (a[4] = 0),
            (a[8] = h),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = u),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, o) {
          const a = this.elements,
            l = 1 / (t - e),
            c = 1 / (n - i),
            h = 1 / (o - r),
            u = (t + e) * l,
            d = (n + i) * c,
            f = (o + r) * h;
          return (
            (a[0] = 2 * l),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -u),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * h),
            (a[14] = -f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      We.prototype.isMatrix4 = !0;
      const Nr = new W(),
        Rn = new We(),
        m1 = new W(0, 0, 0),
        g1 = new W(1, 1, 1),
        Ei = new W(),
        Na = new W(),
        un = new W(),
        kf = new We(),
        Wf = new an();
      class hr {
        constructor(e = 0, t = 0, n = 0, i = hr.DefaultOrder) {
          (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
          const i = e.elements,
            r = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            h = i[9],
            u = i[2],
            d = i[6],
            f = i[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin($t(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-o, r)))
                  : ((this._x = Math.atan2(d, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-$t(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin($t(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-u, f)),
                    (this._z = Math.atan2(-o, c)))
                  : ((this._y = 0), (this._z = Math.atan2(l, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-$t(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, c)));
              break;
            case "YZX":
              (this._z = Math.asin($t(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-h, c)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-$t(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-h, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            kf.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(kf, t, n)
          );
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return Wf.setFromEuler(this), this.setFromQuaternion(Wf, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      hr.prototype.isEuler = !0;
      hr.DefaultOrder = "XYZ";
      hr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class rg {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & ((1 << e) | 0)) !== 0;
        }
      }
      let x1 = 0;
      const $f = new W(),
        Fr = new an(),
        ti = new We(),
        Fa = new W(),
        to = new W(),
        _1 = new W(),
        v1 = new an(),
        qf = new W(1, 0, 0),
        Xf = new W(0, 1, 0),
        jf = new W(0, 0, 1),
        y1 = { type: "added" },
        Yf = { type: "removed" };
      class tt extends lr {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: x1++ }),
            (this.uuid = Vn()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = tt.DefaultUp.clone());
          const e = new W(),
            t = new hr(),
            n = new an(),
            i = new W(1, 1, 1);
          function r() {
            n.setFromEuler(t, !1);
          }
          function o() {
            t.setFromQuaternion(n, void 0, !1);
          }
          t._onChange(r),
            n._onChange(o),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new We() },
              normalMatrix: { value: new Ut() },
            }),
            (this.matrix = new We()),
            (this.matrixWorld = new We()),
            (this.matrixAutoUpdate = tt.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new rg()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return Fr.setFromAxisAngle(e, t), this.quaternion.multiply(Fr), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            Fr.setFromAxisAngle(e, t), this.quaternion.premultiply(Fr), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(qf, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(Xf, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(jf, e);
        }
        translateOnAxis(e, t) {
          return (
            $f.copy(e).applyQuaternion(this.quaternion),
            this.position.add($f.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(qf, e);
        }
        translateY(e) {
          return this.translateOnAxis(Xf, e);
        }
        translateZ(e) {
          return this.translateOnAxis(jf, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(ti.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? Fa.copy(e) : Fa.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            to.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? ti.lookAt(to, Fa, this.up)
              : ti.lookAt(Fa, to, this.up),
            this.quaternion.setFromRotationMatrix(ti),
            i &&
              (ti.extractRotation(i.matrixWorld),
              Fr.setFromRotationMatrix(ti),
              this.quaternion.premultiply(Fr.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.parent !== null && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(y1))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(Yf)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(Yf);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            ti.copy(this.matrixWorld).invert(),
            e.parent !== null &&
              (e.parent.updateWorldMatrix(!0, !1),
              ti.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(ti),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0) return o;
          }
        }
        getWorldPosition(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(to, e, _1),
            e
          );
        }
        getWorldScale(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(to, v1, e),
            e
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            t === !0)
          ) {
            const i = this.children;
            for (let r = 0, o = i.length; r < o; r++)
              i[r].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            JSON.stringify(this.userData) !== "{}" &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (i.instanceColor = this.instanceColor.toJSON()));
          function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
          }
          if (this.isScene)
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const l = a.shapes;
              if (Array.isArray(l))
                for (let c = 0, h = l.length; c < h; c++) {
                  const u = l[c];
                  r(e.shapes, u);
                }
              else r(e.shapes, l);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const a = [];
              for (let l = 0, c = this.material.length; l < c; l++)
                a.push(r(e.materials, this.material[l]));
              i.material = a;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
              i.children.push(this.children[a].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const l = this.animations[a];
              i.animations.push(r(e.animations, l));
            }
          }
          if (t) {
            const a = o(e.geometries),
              l = o(e.materials),
              c = o(e.textures),
              h = o(e.images),
              u = o(e.shapes),
              d = o(e.skeletons),
              f = o(e.animations),
              m = o(e.nodes);
            a.length > 0 && (n.geometries = a),
              l.length > 0 && (n.materials = l),
              c.length > 0 && (n.textures = c),
              h.length > 0 && (n.images = h),
              u.length > 0 && (n.shapes = u),
              d.length > 0 && (n.skeletons = d),
              f.length > 0 && (n.animations = f),
              m.length > 0 && (n.nodes = m);
          }
          return (n.object = i), n;
          function o(a) {
            const l = [];
            for (const c in a) {
              const h = a[c];
              delete h.metadata, l.push(h);
            }
            return l;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let n = 0; n < e.children.length; n++) {
              const i = e.children[n];
              this.add(i.clone());
            }
          return this;
        }
      }
      tt.DefaultUp = new W(0, 1, 0);
      tt.DefaultMatrixAutoUpdate = !0;
      tt.prototype.isObject3D = !0;
      const Cn = new W(),
        ni = new W(),
        kc = new W(),
        ii = new W(),
        Br = new W(),
        zr = new W(),
        Zf = new W(),
        Wc = new W(),
        $c = new W(),
        qc = new W();
      class Mt {
        constructor(e = new W(), t = new W(), n = new W()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i.subVectors(n, t), Cn.subVectors(e, t), i.cross(Cn);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          Cn.subVectors(i, t), ni.subVectors(n, t), kc.subVectors(e, t);
          const o = Cn.dot(Cn),
            a = Cn.dot(ni),
            l = Cn.dot(kc),
            c = ni.dot(ni),
            h = ni.dot(kc),
            u = o * c - a * a;
          if (u === 0) return r.set(-2, -1, -1);
          const d = 1 / u,
            f = (c * l - a * h) * d,
            m = (o * h - a * l) * d;
          return r.set(1 - f - m, m, f);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, ii),
            ii.x >= 0 && ii.y >= 0 && ii.x + ii.y <= 1
          );
        }
        static getUV(e, t, n, i, r, o, a, l) {
          return (
            this.getBarycoord(e, t, n, i, ii),
            l.set(0, 0),
            l.addScaledVector(r, ii.x),
            l.addScaledVector(o, ii.y),
            l.addScaledVector(a, ii.z),
            l
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            Cn.subVectors(n, t), ni.subVectors(e, t), Cn.cross(ni).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            Cn.subVectors(this.c, this.b),
            ni.subVectors(this.a, this.b),
            Cn.cross(ni).length() * 0.5
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return Mt.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return Mt.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return Mt.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return Mt.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return Mt.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let o, a;
          Br.subVectors(i, n), zr.subVectors(r, n), Wc.subVectors(e, n);
          const l = Br.dot(Wc),
            c = zr.dot(Wc);
          if (l <= 0 && c <= 0) return t.copy(n);
          $c.subVectors(e, i);
          const h = Br.dot($c),
            u = zr.dot($c);
          if (h >= 0 && u <= h) return t.copy(i);
          const d = l * u - h * c;
          if (d <= 0 && l >= 0 && h <= 0)
            return (o = l / (l - h)), t.copy(n).addScaledVector(Br, o);
          qc.subVectors(e, r);
          const f = Br.dot(qc),
            m = zr.dot(qc);
          if (m >= 0 && f <= m) return t.copy(r);
          const p = f * c - l * m;
          if (p <= 0 && c >= 0 && m <= 0)
            return (a = c / (c - m)), t.copy(n).addScaledVector(zr, a);
          const g = h * m - f * u;
          if (g <= 0 && u - h >= 0 && f - m >= 0)
            return (
              Zf.subVectors(r, i),
              (a = (u - h) / (u - h + (f - m))),
              t.copy(i).addScaledVector(Zf, a)
            );
          const x = 1 / (g + p + d);
          return (
            (o = p * x),
            (a = d * x),
            t.copy(n).addScaledVector(Br, o).addScaledVector(zr, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let M1 = 0;
      class Tt extends lr {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: M1++ }),
            (this.uuid = Vn()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = ss),
            (this.side = Fo),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = Jm),
            (this.blendDst = Km),
            (this.blendEquation = Yr),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = Ah),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = l1),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Cc),
            (this.stencilZFail = Cc),
            (this.stencilZPass = Cc),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const n = e[t];
              if (n === void 0) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if (t === "shading") {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === Zm);
                continue;
              }
              const i = this[t];
              if (i === void 0) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
                continue;
              }
              i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen !== void 0 && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== ss && (n.blending = this.blending),
            this.side !== Fo && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation !== void 0 &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 &&
              (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData);
          function i(r) {
            const o = [];
            for (const a in r) {
              const l = r[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (t) {
            const r = i(e.textures),
              o = i(e.images);
            r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      Tt.prototype.isMaterial = !0;
      Tt.fromType = function () {
        return null;
      };
      class Il extends Tt {
        constructor(e) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Ve(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Rl),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            this
          );
        }
      }
      Il.prototype.isMeshBasicMaterial = !0;
      const vt = new W(),
        Ba = new ye();
      class St {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n === !0),
            (this.usage = zo),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (o = new Ve())),
              (t[n++] = o.r),
              (t[n++] = o.g),
              (t[n++] = o.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (o = new ye())),
              (t[n++] = o.x),
              (t[n++] = o.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (o = new W())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (o = new st())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z),
              (t[n++] = o.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
              Ba.fromBufferAttribute(this, t),
                Ba.applyMatrix3(e),
                this.setXY(t, Ba.x, Ba.y);
          else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
              vt.fromBufferAttribute(this, t),
                vt.applyMatrix3(e),
                this.setXYZ(t, vt.x, vt.y, vt.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            vt.fromBufferAttribute(this, t),
              vt.applyMatrix4(e),
              this.setXYZ(t, vt.x, vt.y, vt.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            vt.fromBufferAttribute(this, t),
              vt.applyNormalMatrix(e),
              this.setXYZ(t, vt.x, vt.y, vt.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            vt.fromBufferAttribute(this, t),
              vt.transformDirection(e),
              this.setXYZ(t, vt.x, vt.y, vt.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (e.name = this.name),
            this.usage !== zo && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      St.prototype.isBufferAttribute = !0;
      class sg extends St {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class og extends St {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class b1 extends St {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      b1.prototype.isFloat16BufferAttribute = !0;
      class Dt extends St {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      let w1 = 0;
      const xn = new We(),
        Xc = new tt(),
        Or = new W(),
        dn = new Bn(),
        no = new Bn(),
        Lt = new W();
      class pt extends lr {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: w1++ }),
            (this.uuid = Vn()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (tg(e) ? og : sg)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const r = new Ut().getNormalMatrix(e);
            n.applyNormalMatrix(r), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return xn.makeRotationFromQuaternion(e), this.applyMatrix4(xn), this;
        }
        rotateX(e) {
          return xn.makeRotationX(e), this.applyMatrix4(xn), this;
        }
        rotateY(e) {
          return xn.makeRotationY(e), this.applyMatrix4(xn), this;
        }
        rotateZ(e) {
          return xn.makeRotationZ(e), this.applyMatrix4(xn), this;
        }
        translate(e, t, n) {
          return xn.makeTranslation(e, t, n), this.applyMatrix4(xn), this;
        }
        scale(e, t, n) {
          return xn.makeScale(e, t, n), this.applyMatrix4(xn), this;
        }
        lookAt(e) {
          return (
            Xc.lookAt(e), Xc.updateMatrix(), this.applyMatrix4(Xc.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Or).negate(),
            this.translate(Or.x, Or.y, Or.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0);
          }
          return this.setAttribute("position", new Dt(t, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new Bn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingBox.set(
                new W(-1 / 0, -1 / 0, -1 / 0),
                new W(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let n = 0, i = t.length; n < i; n++) {
                const r = t[n];
                dn.setFromBufferAttribute(r),
                  this.morphTargetsRelative
                    ? (Lt.addVectors(this.boundingBox.min, dn.min),
                      this.boundingBox.expandByPoint(Lt),
                      Lt.addVectors(this.boundingBox.max, dn.max),
                      this.boundingBox.expandByPoint(Lt))
                    : (this.boundingBox.expandByPoint(dn.min),
                      this.boundingBox.expandByPoint(dn.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new Ps());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingSphere.set(new W(), 1 / 0);
            return;
          }
          if (e) {
            const n = this.boundingSphere.center;
            if ((dn.setFromBufferAttribute(e), t))
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r];
                no.setFromBufferAttribute(a),
                  this.morphTargetsRelative
                    ? (Lt.addVectors(dn.min, no.min),
                      dn.expandByPoint(Lt),
                      Lt.addVectors(dn.max, no.max),
                      dn.expandByPoint(Lt))
                    : (dn.expandByPoint(no.min), dn.expandByPoint(no.max));
              }
            dn.getCenter(n);
            let i = 0;
            for (let r = 0, o = e.count; r < o; r++)
              Lt.fromBufferAttribute(e, r),
                (i = Math.max(i, n.distanceToSquared(Lt)));
            if (t)
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r],
                  l = this.morphTargetsRelative;
                for (let c = 0, h = a.count; c < h; c++)
                  Lt.fromBufferAttribute(a, c),
                    l && (Or.fromBufferAttribute(e, c), Lt.add(Or)),
                    (i = Math.max(i, n.distanceToSquared(Lt)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            o = t.uv.array,
            a = i.length / 3;
          this.hasAttribute("tangent") === !1 &&
            this.setAttribute("tangent", new St(new Float32Array(4 * a), 4));
          const l = this.getAttribute("tangent").array,
            c = [],
            h = [];
          for (let X = 0; X < a; X++) (c[X] = new W()), (h[X] = new W());
          const u = new W(),
            d = new W(),
            f = new W(),
            m = new ye(),
            p = new ye(),
            g = new ye(),
            x = new W(),
            _ = new W();
          function M(X, b, D) {
            u.fromArray(i, X * 3),
              d.fromArray(i, b * 3),
              f.fromArray(i, D * 3),
              m.fromArray(o, X * 2),
              p.fromArray(o, b * 2),
              g.fromArray(o, D * 2),
              d.sub(u),
              f.sub(u),
              p.sub(m),
              g.sub(m);
            const I = 1 / (p.x * g.y - g.x * p.y);
            !isFinite(I) ||
              (x
                .copy(d)
                .multiplyScalar(g.y)
                .addScaledVector(f, -p.y)
                .multiplyScalar(I),
              _.copy(f)
                .multiplyScalar(p.x)
                .addScaledVector(d, -g.x)
                .multiplyScalar(I),
              c[X].add(x),
              c[b].add(x),
              c[D].add(x),
              h[X].add(_),
              h[b].add(_),
              h[D].add(_));
          }
          let S = this.groups;
          S.length === 0 && (S = [{ start: 0, count: n.length }]);
          for (let X = 0, b = S.length; X < b; ++X) {
            const D = S[X],
              I = D.start,
              L = D.count;
            for (let B = I, R = I + L; B < R; B += 3)
              M(n[B + 0], n[B + 1], n[B + 2]);
          }
          const v = new W(),
            y = new W(),
            C = new W(),
            U = new W();
          function K(X) {
            C.fromArray(r, X * 3), U.copy(C);
            const b = c[X];
            v.copy(b),
              v.sub(C.multiplyScalar(C.dot(b))).normalize(),
              y.crossVectors(U, b);
            const I = y.dot(h[X]) < 0 ? -1 : 1;
            (l[X * 4] = v.x),
              (l[X * 4 + 1] = v.y),
              (l[X * 4 + 2] = v.z),
              (l[X * 4 + 3] = I);
          }
          for (let X = 0, b = S.length; X < b; ++X) {
            const D = S[X],
              I = D.start,
              L = D.count;
            for (let B = I, R = I + L; B < R; B += 3)
              K(n[B + 0]), K(n[B + 1]), K(n[B + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new St(new Float32Array(t.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const i = new W(),
              r = new W(),
              o = new W(),
              a = new W(),
              l = new W(),
              c = new W(),
              h = new W(),
              u = new W();
            if (e)
              for (let d = 0, f = e.count; d < f; d += 3) {
                const m = e.getX(d + 0),
                  p = e.getX(d + 1),
                  g = e.getX(d + 2);
                i.fromBufferAttribute(t, m),
                  r.fromBufferAttribute(t, p),
                  o.fromBufferAttribute(t, g),
                  h.subVectors(o, r),
                  u.subVectors(i, r),
                  h.cross(u),
                  a.fromBufferAttribute(n, m),
                  l.fromBufferAttribute(n, p),
                  c.fromBufferAttribute(n, g),
                  a.add(h),
                  l.add(h),
                  c.add(h),
                  n.setXYZ(m, a.x, a.y, a.z),
                  n.setXYZ(p, l.x, l.y, l.z),
                  n.setXYZ(g, c.x, c.y, c.z);
              }
            else
              for (let d = 0, f = t.count; d < f; d += 3)
                i.fromBufferAttribute(t, d + 0),
                  r.fromBufferAttribute(t, d + 1),
                  o.fromBufferAttribute(t, d + 2),
                  h.subVectors(o, r),
                  u.subVectors(i, r),
                  h.cross(u),
                  n.setXYZ(d + 0, h.x, h.y, h.z),
                  n.setXYZ(d + 1, h.x, h.y, h.z),
                  n.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!(e && e.isBufferGeometry)) {
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
            return;
          }
          t === void 0 &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (e.attributes[i] === void 0) continue;
            const o = n[i].array,
              a = e.attributes[i],
              l = a.array,
              c = a.itemSize * t,
              h = Math.min(l.length, o.length - c);
            for (let u = 0, d = c; u < h; u++, d++) o[d] = l[u];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            Lt.fromBufferAttribute(e, t),
              Lt.normalize(),
              e.setXYZ(t, Lt.x, Lt.y, Lt.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              h = a.itemSize,
              u = a.normalized,
              d = new c.constructor(l.length * h);
            let f = 0,
              m = 0;
            for (let p = 0, g = l.length; p < g; p++) {
              a.isInterleavedBufferAttribute
                ? (f = l[p] * a.data.stride + a.offset)
                : (f = l[p] * h);
              for (let x = 0; x < h; x++) d[m++] = c[f++];
            }
            return new St(d, h, u);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new pt(),
            n = this.index.array,
            i = this.attributes;
          for (const a in i) {
            const l = i[a],
              c = e(l, n);
            t.setAttribute(a, c);
          }
          const r = this.morphAttributes;
          for (const a in r) {
            const l = [],
              c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
              const d = c[h],
                f = e(d, n);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              h = [];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = c[u];
              h.push(f.toJSON(e.data));
            }
            h.length > 0 && ((i[l] = h), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            a !== null &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          n !== null && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const c in i) {
            const h = i[c];
            this.setAttribute(c, h.clone(t));
          }
          const r = e.morphAttributes;
          for (const c in r) {
            const h = [],
              u = r[c];
            for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
            this.morphAttributes[c] = h;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          const a = e.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            l !== null && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            e.parameters !== void 0 &&
              (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      pt.prototype.isBufferGeometry = !0;
      const Jf = new We(),
        Ur = new Ds(),
        jc = new Ps(),
        Ai = new W(),
        Li = new W(),
        Ri = new W(),
        Yc = new W(),
        Zc = new W(),
        Jc = new W(),
        za = new W(),
        Oa = new W(),
        Ua = new W(),
        Ha = new ye(),
        Ga = new ye(),
        Va = new ye(),
        Kc = new W(),
        ka = new W();
      class on extends tt {
        constructor(e = new pt(), t = new Il()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            e.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (
            i === void 0 ||
            (n.boundingSphere === null && n.computeBoundingSphere(),
            jc.copy(n.boundingSphere),
            jc.applyMatrix4(r),
            e.ray.intersectsSphere(jc) === !1) ||
            (Jf.copy(r).invert(),
            Ur.copy(e.ray).applyMatrix4(Jf),
            n.boundingBox !== null && Ur.intersectsBox(n.boundingBox) === !1)
          )
            return;
          let o;
          if (n.isBufferGeometry) {
            const a = n.index,
              l = n.attributes.position,
              c = n.morphAttributes.position,
              h = n.morphTargetsRelative,
              u = n.attributes.uv,
              d = n.attributes.uv2,
              f = n.groups,
              m = n.drawRange;
            if (a !== null)
              if (Array.isArray(i))
                for (let p = 0, g = f.length; p < g; p++) {
                  const x = f[p],
                    _ = i[x.materialIndex],
                    M = Math.max(x.start, m.start),
                    S = Math.min(
                      a.count,
                      Math.min(x.start + x.count, m.start + m.count)
                    );
                  for (let v = M, y = S; v < y; v += 3) {
                    const C = a.getX(v),
                      U = a.getX(v + 1),
                      K = a.getX(v + 2);
                    (o = Wa(this, _, e, Ur, l, c, h, u, d, C, U, K)),
                      o &&
                        ((o.faceIndex = Math.floor(v / 3)),
                        (o.face.materialIndex = x.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const p = Math.max(0, m.start),
                  g = Math.min(a.count, m.start + m.count);
                for (let x = p, _ = g; x < _; x += 3) {
                  const M = a.getX(x),
                    S = a.getX(x + 1),
                    v = a.getX(x + 2);
                  (o = Wa(this, i, e, Ur, l, c, h, u, d, M, S, v)),
                    o && ((o.faceIndex = Math.floor(x / 3)), t.push(o));
                }
              }
            else if (l !== void 0)
              if (Array.isArray(i))
                for (let p = 0, g = f.length; p < g; p++) {
                  const x = f[p],
                    _ = i[x.materialIndex],
                    M = Math.max(x.start, m.start),
                    S = Math.min(
                      l.count,
                      Math.min(x.start + x.count, m.start + m.count)
                    );
                  for (let v = M, y = S; v < y; v += 3) {
                    const C = v,
                      U = v + 1,
                      K = v + 2;
                    (o = Wa(this, _, e, Ur, l, c, h, u, d, C, U, K)),
                      o &&
                        ((o.faceIndex = Math.floor(v / 3)),
                        (o.face.materialIndex = x.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const p = Math.max(0, m.start),
                  g = Math.min(l.count, m.start + m.count);
                for (let x = p, _ = g; x < _; x += 3) {
                  const M = x,
                    S = x + 1,
                    v = x + 2;
                  (o = Wa(this, i, e, Ur, l, c, h, u, d, M, S, v)),
                    o && ((o.faceIndex = Math.floor(x / 3)), t.push(o));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      on.prototype.isMesh = !0;
      function S1(s, e, t, n, i, r, o, a) {
        let l;
        if (
          (e.side === Nn
            ? (l = n.intersectTriangle(o, r, i, !0, a))
            : (l = n.intersectTriangle(i, r, o, e.side !== ps, a)),
          l === null)
        )
          return null;
        ka.copy(a), ka.applyMatrix4(s.matrixWorld);
        const c = t.ray.origin.distanceTo(ka);
        return c < t.near || c > t.far
          ? null
          : { distance: c, point: ka.clone(), object: s };
      }
      function Wa(s, e, t, n, i, r, o, a, l, c, h, u) {
        Ai.fromBufferAttribute(i, c),
          Li.fromBufferAttribute(i, h),
          Ri.fromBufferAttribute(i, u);
        const d = s.morphTargetInfluences;
        if (r && d) {
          za.set(0, 0, 0), Oa.set(0, 0, 0), Ua.set(0, 0, 0);
          for (let m = 0, p = r.length; m < p; m++) {
            const g = d[m],
              x = r[m];
            g !== 0 &&
              (Yc.fromBufferAttribute(x, c),
              Zc.fromBufferAttribute(x, h),
              Jc.fromBufferAttribute(x, u),
              o
                ? (za.addScaledVector(Yc, g),
                  Oa.addScaledVector(Zc, g),
                  Ua.addScaledVector(Jc, g))
                : (za.addScaledVector(Yc.sub(Ai), g),
                  Oa.addScaledVector(Zc.sub(Li), g),
                  Ua.addScaledVector(Jc.sub(Ri), g)));
          }
          Ai.add(za), Li.add(Oa), Ri.add(Ua);
        }
        s.isSkinnedMesh &&
          (s.boneTransform(c, Ai),
          s.boneTransform(h, Li),
          s.boneTransform(u, Ri));
        const f = S1(s, e, t, n, Ai, Li, Ri, Kc);
        if (f) {
          a &&
            (Ha.fromBufferAttribute(a, c),
            Ga.fromBufferAttribute(a, h),
            Va.fromBufferAttribute(a, u),
            (f.uv = Mt.getUV(Kc, Ai, Li, Ri, Ha, Ga, Va, new ye()))),
            l &&
              (Ha.fromBufferAttribute(l, c),
              Ga.fromBufferAttribute(l, h),
              Va.fromBufferAttribute(l, u),
              (f.uv2 = Mt.getUV(Kc, Ai, Li, Ri, Ha, Ga, Va, new ye())));
          const m = { a: c, b: h, c: u, normal: new W(), materialIndex: 0 };
          Mt.getNormal(Ai, Li, Ri, m.normal), (f.face = m);
        }
        return f;
      }
      class qo extends pt {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: o,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
          const l = [],
            c = [],
            h = [],
            u = [];
          let d = 0,
            f = 0;
          m("z", "y", "x", -1, -1, n, t, e, o, r, 0),
            m("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
            m("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            m("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            m("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            m("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(l),
            this.setAttribute("position", new Dt(c, 3)),
            this.setAttribute("normal", new Dt(h, 3)),
            this.setAttribute("uv", new Dt(u, 2));
          function m(p, g, x, _, M, S, v, y, C, U, K) {
            const X = S / C,
              b = v / U,
              D = S / 2,
              I = v / 2,
              L = y / 2,
              B = C + 1,
              R = U + 1;
            let V = 0,
              H = 0;
            const J = new W();
            for (let ie = 0; ie < R; ie++) {
              const ne = ie * b - I;
              for (let ae = 0; ae < B; ae++) {
                const fe = ae * X - D;
                (J[p] = fe * _),
                  (J[g] = ne * M),
                  (J[x] = L),
                  c.push(J.x, J.y, J.z),
                  (J[p] = 0),
                  (J[g] = 0),
                  (J[x] = y > 0 ? 1 : -1),
                  h.push(J.x, J.y, J.z),
                  u.push(ae / C),
                  u.push(1 - ie / U),
                  (V += 1);
              }
            }
            for (let ie = 0; ie < U; ie++)
              for (let ne = 0; ne < C; ne++) {
                const ae = d + ne + B * ie,
                  fe = d + ne + B * (ie + 1),
                  Fe = d + (ne + 1) + B * (ie + 1),
                  Ee = d + (ne + 1) + B * ie;
                l.push(ae, fe, Ee), l.push(fe, Fe, Ee), (H += 6);
              }
            a.addGroup(f, H, K), (f += H), (d += V);
          }
        }
        static fromJSON(e) {
          return new qo(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function _s(s) {
        const e = {};
        for (const t in s) {
          e[t] = {};
          for (const n in s[t]) {
            const i = s[t][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (e[t][n] = i.clone())
              : Array.isArray(i)
              ? (e[t][n] = i.slice())
              : (e[t][n] = i);
          }
        }
        return e;
      }
      function Wt(s) {
        const e = {};
        for (let t = 0; t < s.length; t++) {
          const n = _s(s[t]);
          for (const i in n) e[i] = n[i];
        }
        return e;
      }
      const T1 = { clone: _s, merge: Wt };
      var E1 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        A1 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class Fn extends Tt {
        constructor(e) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = E1),
            (this.fragmentShader = A1),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 &&
              (e.attributes !== void 0 &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = _s(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture
              ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
              : o && o.isColor
              ? (t.uniforms[i] = { type: "c", value: o.getHex() })
              : o && o.isVector2
              ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
              : o && o.isVector3
              ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
              ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
              : o && o.isMatrix3
              ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
              : o && o.isMatrix4
              ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
              : (t.uniforms[i] = { value: o });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      Fn.prototype.isShaderMaterial = !0;
      class _u extends tt {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new We()),
            (this.projectionMatrix = new We()),
            (this.projectionMatrixInverse = new We());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      _u.prototype.isCamera = !0;
      class Yt extends _u {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = Ih * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(Pc * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return Ih * 2 * Math.atan(Math.tan(Pc * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, r, o) {
          (this.aspect = e / t),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(Pc * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const o = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
              c = o.fullHeight;
            (r += (o.offsetX * i) / l),
              (t -= (o.offsetY * n) / c),
              (i *= o.width / l),
              (n *= o.height / c);
          }
          const a = this.filmOffset;
          a !== 0 && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      Yt.prototype.isPerspectiveCamera = !0;
      const Hr = 90,
        Gr = 1;
      class vu extends tt {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            n.isWebGLCubeRenderTarget !== !0)
          ) {
            console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
            return;
          }
          this.renderTarget = n;
          const i = new Yt(Hr, Gr, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new W(1, 0, 0)),
            this.add(i);
          const r = new Yt(Hr, Gr, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new W(-1, 0, 0)),
            this.add(r);
          const o = new Yt(Hr, Gr, e, t);
          (o.layers = this.layers),
            o.up.set(0, 0, 1),
            o.lookAt(new W(0, 1, 0)),
            this.add(o);
          const a = new Yt(Hr, Gr, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new W(0, -1, 0)),
            this.add(a);
          const l = new Yt(Hr, Gr, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new W(0, 0, 1)),
            this.add(l);
          const c = new Yt(Hr, Gr, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new W(0, 0, -1)),
            this.add(c);
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, o, a, l, c] = this.children,
            h = e.getRenderTarget(),
            u = e.outputEncoding,
            d = e.toneMapping,
            f = e.xr.enabled;
          (e.outputEncoding = hi), (e.toneMapping = li), (e.xr.enabled = !1);
          const m = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, r),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            (n.texture.generateMipmaps = m),
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(h),
            (e.outputEncoding = u),
            (e.toneMapping = d),
            (e.xr.enabled = f),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class Nl extends Nt {
        constructor(e, t, n, i, r, o, a, l, c, h) {
          (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : ms),
            super(e, t, n, i, r, o, a, l, c, h),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      Nl.prototype.isCubeTexture = !0;
      class ag extends fn {
        constructor(e, t = {}) {
          super(e, e, t);
          const n = { width: e, height: e, depth: 1 },
            i = [n, n, n, n, n, n];
          (this.texture = new Nl(
            i,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
              t.minFilter !== void 0 ? t.minFilter : nn);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new qo(5, 5, 5),
            r = new Fn({
              name: "CubemapFromEquirect",
              uniforms: _s(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: Nn,
              blending: zi,
            });
          r.uniforms.tEquirect.value = t;
          const o = new on(i, r),
            a = t.minFilter;
          return (
            t.minFilter === Pl && (t.minFilter = nn),
            new vu(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      ag.prototype.isWebGLCubeRenderTarget = !0;
      const Qc = new W(),
        L1 = new W(),
        R1 = new Ut();
      class oi {
        constructor(e = new W(1, 0, 0), t = 0) {
          (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = Qc.subVectors(n, t).cross(L1.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(e))
            .add(e);
        }
        intersectLine(e, t) {
          const n = e.delta(Qc),
            i = this.normal.dot(n);
          if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const n = t || R1.getNormalMatrix(e),
            i = this.coplanarPoint(Qc).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      oi.prototype.isPlane = !0;
      const Vr = new Ps(),
        $a = new W();
      class Fl {
        constructor(
          e = new oi(),
          t = new oi(),
          n = new oi(),
          i = new oi(),
          r = new oi(),
          o = new oi()
        ) {
          this.planes = [e, t, n, i, r, o];
        }
        set(e, t, n, i, r, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            o = n[2],
            a = n[3],
            l = n[4],
            c = n[5],
            h = n[6],
            u = n[7],
            d = n[8],
            f = n[9],
            m = n[10],
            p = n[11],
            g = n[12],
            x = n[13],
            _ = n[14],
            M = n[15];
          return (
            t[0].setComponents(a - i, u - l, p - d, M - g).normalize(),
            t[1].setComponents(a + i, u + l, p + d, M + g).normalize(),
            t[2].setComponents(a + r, u + c, p + f, M + x).normalize(),
            t[3].setComponents(a - r, u - c, p - f, M - x).normalize(),
            t[4].setComponents(a - o, u - h, p - m, M - _).normalize(),
            t[5].setComponents(a + o, u + h, p + m, M + _).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            t.boundingSphere === null && t.computeBoundingSphere(),
            Vr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Vr)
          );
        }
        intersectsSprite(e) {
          return (
            Vr.center.set(0, 0, 0),
            (Vr.radius = 0.7071067811865476),
            Vr.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Vr)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              (($a.x = i.normal.x > 0 ? e.max.x : e.min.x),
              ($a.y = i.normal.y > 0 ? e.max.y : e.min.y),
              ($a.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint($a) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function lg() {
        let s = null,
          e = !1,
          t = null,
          n = null;
        function i(r, o) {
          t(r, o), (n = s.requestAnimationFrame(i));
        }
        return {
          start: function () {
            e !== !0 &&
              t !== null &&
              ((n = s.requestAnimationFrame(i)), (e = !0));
          },
          stop: function () {
            s.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (r) {
            t = r;
          },
          setContext: function (r) {
            s = r;
          },
        };
      }
      function C1(s, e) {
        const t = e.isWebGL2,
          n = new WeakMap();
        function i(c, h) {
          const u = c.array,
            d = c.usage,
            f = s.createBuffer();
          s.bindBuffer(h, f), s.bufferData(h, u, d), c.onUploadCallback();
          let m;
          if (u instanceof Float32Array) m = 5126;
          else if (u instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
              if (t) m = 5131;
              else
                throw new Error(
                  "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                );
            else m = 5123;
          else if (u instanceof Int16Array) m = 5122;
          else if (u instanceof Uint32Array) m = 5125;
          else if (u instanceof Int32Array) m = 5124;
          else if (u instanceof Int8Array) m = 5120;
          else if (u instanceof Uint8Array) m = 5121;
          else if (u instanceof Uint8ClampedArray) m = 5121;
          else
            throw new Error(
              "THREE.WebGLAttributes: Unsupported buffer data format: " + u
            );
          return {
            buffer: f,
            type: m,
            bytesPerElement: u.BYTES_PER_ELEMENT,
            version: c.version,
          };
        }
        function r(c, h, u) {
          const d = h.array,
            f = h.updateRange;
          s.bindBuffer(u, c),
            f.count === -1
              ? s.bufferSubData(u, 0, d)
              : (t
                  ? s.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d,
                      f.offset,
                      f.count
                    )
                  : s.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d.subarray(f.offset, f.offset + f.count)
                    ),
                (f.count = -1));
        }
        function o(c) {
          return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
        }
        function a(c) {
          c.isInterleavedBufferAttribute && (c = c.data);
          const h = n.get(c);
          h && (s.deleteBuffer(h.buffer), n.delete(c));
        }
        function l(c, h) {
          if (c.isGLBufferAttribute) {
            const d = n.get(c);
            (!d || d.version < c.version) &&
              n.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version,
              });
            return;
          }
          c.isInterleavedBufferAttribute && (c = c.data);
          const u = n.get(c);
          u === void 0
            ? n.set(c, i(c, h))
            : u.version < c.version &&
              (r(u.buffer, c, h), (u.version = c.version));
        }
        return { get: o, remove: a, update: l };
      }
      class yu extends pt {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            o = t / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            h = l + 1,
            u = e / a,
            d = t / l,
            f = [],
            m = [],
            p = [],
            g = [];
          for (let x = 0; x < h; x++) {
            const _ = x * d - o;
            for (let M = 0; M < c; M++) {
              const S = M * u - r;
              m.push(S, -_, 0),
                p.push(0, 0, 1),
                g.push(M / a),
                g.push(1 - x / l);
            }
          }
          for (let x = 0; x < l; x++)
            for (let _ = 0; _ < a; _++) {
              const M = _ + c * x,
                S = _ + c * (x + 1),
                v = _ + 1 + c * (x + 1),
                y = _ + 1 + c * x;
              f.push(M, S, y), f.push(S, v, y);
            }
          this.setIndex(f),
            this.setAttribute("position", new Dt(m, 3)),
            this.setAttribute("normal", new Dt(p, 3)),
            this.setAttribute("uv", new Dt(g, 2));
        }
        static fromJSON(e) {
          return new yu(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      var P1 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
        D1 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        I1 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
        N1 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        F1 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        B1 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        z1 = "vec3 transformed = vec3( position );",
        O1 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        U1 = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
        H1 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        G1 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
        V1 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        k1 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        W1 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        $1 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        q1 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        X1 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
        j1 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
        Y1 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
        Z1 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        J1 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        K1 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        Q1 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
        eT = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        tT = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        nT = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        iT = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        rT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        sT = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        oT = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        aT = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        lT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        cT = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        hT = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        uT = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        dT = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        fT = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
        pT = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
        mT = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        gT = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
        xT = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        _T = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
        vT = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        yT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
        MT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        bT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
        wT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
        ST = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        TT = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        ET = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        AT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
        LT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        RT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        CT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
        PT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
        DT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        IT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        NT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        FT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        BT = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        zT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        OT = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        UT = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
        HT = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
        GT = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
        VT = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
        kT = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        WT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        $T = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        qT = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        XT = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
        jT = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
        YT = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
        ZT = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
        JT = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        KT = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
        QT = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        eE = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        tE = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        nE = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        iE = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        rE = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        sE = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
        oE = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        aE = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
        lE = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        cE = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        hE = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
        uE = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        dE = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        fE = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        pE = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        mE = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        gE = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        xE = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
        _E = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
        vE = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
        yE = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
        ME = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
        bE = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
        wE = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
        SE = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
        TE = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const EE = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        AE = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        LE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        RE = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        CE = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        PE = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
        DE = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        IE = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        NE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        FE = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        BE = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        zE = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        OE = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        UE = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        HE = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        GE = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        VE = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        kE = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        WE = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        $E = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
        qE = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        XE = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        jE = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
        YE = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        ZE = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        JE = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        KE = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        QE = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        eA = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        tA = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        nA = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        iA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Ye = {
          alphamap_fragment: P1,
          alphamap_pars_fragment: D1,
          alphatest_fragment: I1,
          alphatest_pars_fragment: N1,
          aomap_fragment: F1,
          aomap_pars_fragment: B1,
          begin_vertex: z1,
          beginnormal_vertex: O1,
          bsdfs: U1,
          bumpmap_pars_fragment: H1,
          clipping_planes_fragment: G1,
          clipping_planes_pars_fragment: V1,
          clipping_planes_pars_vertex: k1,
          clipping_planes_vertex: W1,
          color_fragment: $1,
          color_pars_fragment: q1,
          color_pars_vertex: X1,
          color_vertex: j1,
          common: Y1,
          cube_uv_reflection_fragment: Z1,
          defaultnormal_vertex: J1,
          displacementmap_pars_vertex: K1,
          displacementmap_vertex: Q1,
          emissivemap_fragment: eT,
          emissivemap_pars_fragment: tT,
          encodings_fragment: nT,
          encodings_pars_fragment: iT,
          envmap_fragment: rT,
          envmap_common_pars_fragment: sT,
          envmap_pars_fragment: oT,
          envmap_pars_vertex: aT,
          envmap_physical_pars_fragment: _T,
          envmap_vertex: lT,
          fog_vertex: cT,
          fog_pars_vertex: hT,
          fog_fragment: uT,
          fog_pars_fragment: dT,
          gradientmap_pars_fragment: fT,
          lightmap_fragment: pT,
          lightmap_pars_fragment: mT,
          lights_lambert_vertex: gT,
          lights_pars_begin: xT,
          lights_toon_fragment: vT,
          lights_toon_pars_fragment: yT,
          lights_phong_fragment: MT,
          lights_phong_pars_fragment: bT,
          lights_physical_fragment: wT,
          lights_physical_pars_fragment: ST,
          lights_fragment_begin: TT,
          lights_fragment_maps: ET,
          lights_fragment_end: AT,
          logdepthbuf_fragment: LT,
          logdepthbuf_pars_fragment: RT,
          logdepthbuf_pars_vertex: CT,
          logdepthbuf_vertex: PT,
          map_fragment: DT,
          map_pars_fragment: IT,
          map_particle_fragment: NT,
          map_particle_pars_fragment: FT,
          metalnessmap_fragment: BT,
          metalnessmap_pars_fragment: zT,
          morphcolor_vertex: OT,
          morphnormal_vertex: UT,
          morphtarget_pars_vertex: HT,
          morphtarget_vertex: GT,
          normal_fragment_begin: VT,
          normal_fragment_maps: kT,
          normal_pars_fragment: WT,
          normal_pars_vertex: $T,
          normal_vertex: qT,
          normalmap_pars_fragment: XT,
          clearcoat_normal_fragment_begin: jT,
          clearcoat_normal_fragment_maps: YT,
          clearcoat_pars_fragment: ZT,
          output_fragment: JT,
          packing: KT,
          premultiplied_alpha_fragment: QT,
          project_vertex: eE,
          dithering_fragment: tE,
          dithering_pars_fragment: nE,
          roughnessmap_fragment: iE,
          roughnessmap_pars_fragment: rE,
          shadowmap_pars_fragment: sE,
          shadowmap_pars_vertex: oE,
          shadowmap_vertex: aE,
          shadowmask_pars_fragment: lE,
          skinbase_vertex: cE,
          skinning_pars_vertex: hE,
          skinning_vertex: uE,
          skinnormal_vertex: dE,
          specularmap_fragment: fE,
          specularmap_pars_fragment: pE,
          tonemapping_fragment: mE,
          tonemapping_pars_fragment: gE,
          transmission_fragment: xE,
          transmission_pars_fragment: _E,
          uv_pars_fragment: vE,
          uv_pars_vertex: yE,
          uv_vertex: ME,
          uv2_pars_fragment: bE,
          uv2_pars_vertex: wE,
          uv2_vertex: SE,
          worldpos_vertex: TE,
          background_vert: EE,
          background_frag: AE,
          cube_vert: LE,
          cube_frag: RE,
          depth_vert: CE,
          depth_frag: PE,
          distanceRGBA_vert: DE,
          distanceRGBA_frag: IE,
          equirect_vert: NE,
          equirect_frag: FE,
          linedashed_vert: BE,
          linedashed_frag: zE,
          meshbasic_vert: OE,
          meshbasic_frag: UE,
          meshlambert_vert: HE,
          meshlambert_frag: GE,
          meshmatcap_vert: VE,
          meshmatcap_frag: kE,
          meshnormal_vert: WE,
          meshnormal_frag: $E,
          meshphong_vert: qE,
          meshphong_frag: XE,
          meshphysical_vert: jE,
          meshphysical_frag: YE,
          meshtoon_vert: ZE,
          meshtoon_frag: JE,
          points_vert: KE,
          points_frag: QE,
          shadow_vert: eA,
          shadow_frag: tA,
          sprite_vert: nA,
          sprite_frag: iA,
        },
        De = {
          common: {
            diffuse: { value: new Ve(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Ut() },
            uv2Transform: { value: new Ut() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new ye(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Ve(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ve(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new Ut() },
          },
          sprite: {
            diffuse: { value: new Ve(16777215) },
            opacity: { value: 1 },
            center: { value: new ye(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new Ut() },
          },
        },
        Gn = {
          basic: {
            uniforms: Wt([
              De.common,
              De.specularmap,
              De.envmap,
              De.aomap,
              De.lightmap,
              De.fog,
            ]),
            vertexShader: Ye.meshbasic_vert,
            fragmentShader: Ye.meshbasic_frag,
          },
          lambert: {
            uniforms: Wt([
              De.common,
              De.specularmap,
              De.envmap,
              De.aomap,
              De.lightmap,
              De.emissivemap,
              De.fog,
              De.lights,
              { emissive: { value: new Ve(0) } },
            ]),
            vertexShader: Ye.meshlambert_vert,
            fragmentShader: Ye.meshlambert_frag,
          },
          phong: {
            uniforms: Wt([
              De.common,
              De.specularmap,
              De.envmap,
              De.aomap,
              De.lightmap,
              De.emissivemap,
              De.bumpmap,
              De.normalmap,
              De.displacementmap,
              De.fog,
              De.lights,
              {
                emissive: { value: new Ve(0) },
                specular: { value: new Ve(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Ye.meshphong_vert,
            fragmentShader: Ye.meshphong_frag,
          },
          standard: {
            uniforms: Wt([
              De.common,
              De.envmap,
              De.aomap,
              De.lightmap,
              De.emissivemap,
              De.bumpmap,
              De.normalmap,
              De.displacementmap,
              De.roughnessmap,
              De.metalnessmap,
              De.fog,
              De.lights,
              {
                emissive: { value: new Ve(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Ye.meshphysical_vert,
            fragmentShader: Ye.meshphysical_frag,
          },
          toon: {
            uniforms: Wt([
              De.common,
              De.aomap,
              De.lightmap,
              De.emissivemap,
              De.bumpmap,
              De.normalmap,
              De.displacementmap,
              De.gradientmap,
              De.fog,
              De.lights,
              { emissive: { value: new Ve(0) } },
            ]),
            vertexShader: Ye.meshtoon_vert,
            fragmentShader: Ye.meshtoon_frag,
          },
          matcap: {
            uniforms: Wt([
              De.common,
              De.bumpmap,
              De.normalmap,
              De.displacementmap,
              De.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Ye.meshmatcap_vert,
            fragmentShader: Ye.meshmatcap_frag,
          },
          points: {
            uniforms: Wt([De.points, De.fog]),
            vertexShader: Ye.points_vert,
            fragmentShader: Ye.points_frag,
          },
          dashed: {
            uniforms: Wt([
              De.common,
              De.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Ye.linedashed_vert,
            fragmentShader: Ye.linedashed_frag,
          },
          depth: {
            uniforms: Wt([De.common, De.displacementmap]),
            vertexShader: Ye.depth_vert,
            fragmentShader: Ye.depth_frag,
          },
          normal: {
            uniforms: Wt([
              De.common,
              De.bumpmap,
              De.normalmap,
              De.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Ye.meshnormal_vert,
            fragmentShader: Ye.meshnormal_frag,
          },
          sprite: {
            uniforms: Wt([De.sprite, De.fog]),
            vertexShader: Ye.sprite_vert,
            fragmentShader: Ye.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new Ut() },
              t2D: { value: null },
            },
            vertexShader: Ye.background_vert,
            fragmentShader: Ye.background_frag,
          },
          cube: {
            uniforms: Wt([De.envmap, { opacity: { value: 1 } }]),
            vertexShader: Ye.cube_vert,
            fragmentShader: Ye.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Ye.equirect_vert,
            fragmentShader: Ye.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Wt([
              De.common,
              De.displacementmap,
              {
                referencePosition: { value: new W() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Ye.distanceRGBA_vert,
            fragmentShader: Ye.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Wt([
              De.lights,
              De.fog,
              { color: { value: new Ve(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Ye.shadow_vert,
            fragmentShader: Ye.shadow_frag,
          },
        };
      Gn.physical = {
        uniforms: Wt([
          Gn.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new ye(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new Ve(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new ye() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Ve(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new Ve(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: Ye.meshphysical_vert,
        fragmentShader: Ye.meshphysical_frag,
      };
      function rA(s, e, t, n, i, r) {
        const o = new Ve(0);
        let a = i === !0 ? 0 : 1,
          l,
          c,
          h = null,
          u = 0,
          d = null;
        function f(p, g) {
          let x = !1,
            _ = g.isScene === !0 ? g.background : null;
          _ && _.isTexture && (_ = e.get(_));
          const M = s.xr,
            S = M.getSession && M.getSession();
          S && S.environmentBlendMode === "additive" && (_ = null),
            _ === null ? m(o, a) : _ && _.isColor && (m(_, 1), (x = !0)),
            (s.autoClear || x) &&
              s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
            _ && (_.isCubeTexture || _.mapping === Cl)
              ? (c === void 0 &&
                  ((c = new on(
                    new qo(1, 1, 1),
                    new Fn({
                      name: "BackgroundCubeMaterial",
                      uniforms: _s(Gn.cube.uniforms),
                      vertexShader: Gn.cube.vertexShader,
                      fragmentShader: Gn.cube.fragmentShader,
                      side: Nn,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  c.geometry.deleteAttribute("uv"),
                  (c.onBeforeRender = function (v, y, C) {
                    this.matrixWorld.copyPosition(C.matrixWorld);
                  }),
                  Object.defineProperty(c.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(c)),
                (c.material.uniforms.envMap.value = _),
                (c.material.uniforms.flipEnvMap.value =
                  _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
                (h !== _ || u !== _.version || d !== s.toneMapping) &&
                  ((c.material.needsUpdate = !0),
                  (h = _),
                  (u = _.version),
                  (d = s.toneMapping)),
                p.unshift(c, c.geometry, c.material, 0, 0, null))
              : _ &&
                _.isTexture &&
                (l === void 0 &&
                  ((l = new on(
                    new yu(2, 2),
                    new Fn({
                      name: "BackgroundMaterial",
                      uniforms: _s(Gn.background.uniforms),
                      vertexShader: Gn.background.vertexShader,
                      fragmentShader: Gn.background.fragmentShader,
                      side: Fo,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  Object.defineProperty(l.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(l)),
                (l.material.uniforms.t2D.value = _),
                _.matrixAutoUpdate === !0 && _.updateMatrix(),
                l.material.uniforms.uvTransform.value.copy(_.matrix),
                (h !== _ || u !== _.version || d !== s.toneMapping) &&
                  ((l.material.needsUpdate = !0),
                  (h = _),
                  (u = _.version),
                  (d = s.toneMapping)),
                p.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function m(p, g) {
          t.buffers.color.setClear(p.r, p.g, p.b, g, r);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (p, g = 1) {
            o.set(p), (a = g), m(o, a);
          },
          getClearAlpha: function () {
            return a;
          },
          setClearAlpha: function (p) {
            (a = p), m(o, a);
          },
          render: f,
        };
      }
      function sA(s, e, t, n) {
        const i = s.getParameter(34921),
          r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = n.isWebGL2 || r !== null,
          a = {},
          l = g(null);
        let c = l,
          h = !1;
        function u(L, B, R, V, H) {
          let J = !1;
          if (o) {
            const ie = p(V, R, B);
            c !== ie && ((c = ie), f(c.object)), (J = x(V, H)), J && _(V, H);
          } else {
            const ie = B.wireframe === !0;
            (c.geometry !== V.id || c.program !== R.id || c.wireframe !== ie) &&
              ((c.geometry = V.id),
              (c.program = R.id),
              (c.wireframe = ie),
              (J = !0));
          }
          L.isInstancedMesh === !0 && (J = !0),
            H !== null && t.update(H, 34963),
            (J || h) &&
              ((h = !1),
              U(L, B, R, V),
              H !== null && s.bindBuffer(34963, t.get(H).buffer));
        }
        function d() {
          return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
        }
        function f(L) {
          return n.isWebGL2 ? s.bindVertexArray(L) : r.bindVertexArrayOES(L);
        }
        function m(L) {
          return n.isWebGL2
            ? s.deleteVertexArray(L)
            : r.deleteVertexArrayOES(L);
        }
        function p(L, B, R) {
          const V = R.wireframe === !0;
          let H = a[L.id];
          H === void 0 && ((H = {}), (a[L.id] = H));
          let J = H[B.id];
          J === void 0 && ((J = {}), (H[B.id] = J));
          let ie = J[V];
          return ie === void 0 && ((ie = g(d())), (J[V] = ie)), ie;
        }
        function g(L) {
          const B = [],
            R = [],
            V = [];
          for (let H = 0; H < i; H++) (B[H] = 0), (R[H] = 0), (V[H] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: B,
            enabledAttributes: R,
            attributeDivisors: V,
            object: L,
            attributes: {},
            index: null,
          };
        }
        function x(L, B) {
          const R = c.attributes,
            V = L.attributes;
          let H = 0;
          for (const J in V) {
            const ie = R[J],
              ne = V[J];
            if (ie === void 0 || ie.attribute !== ne || ie.data !== ne.data)
              return !0;
            H++;
          }
          return c.attributesNum !== H || c.index !== B;
        }
        function _(L, B) {
          const R = {},
            V = L.attributes;
          let H = 0;
          for (const J in V) {
            const ie = V[J],
              ne = {};
            (ne.attribute = ie),
              ie.data && (ne.data = ie.data),
              (R[J] = ne),
              H++;
          }
          (c.attributes = R), (c.attributesNum = H), (c.index = B);
        }
        function M() {
          const L = c.newAttributes;
          for (let B = 0, R = L.length; B < R; B++) L[B] = 0;
        }
        function S(L) {
          v(L, 0);
        }
        function v(L, B) {
          const R = c.newAttributes,
            V = c.enabledAttributes,
            H = c.attributeDivisors;
          (R[L] = 1),
            V[L] === 0 && (s.enableVertexAttribArray(L), (V[L] = 1)),
            H[L] !== B &&
              ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](L, B),
              (H[L] = B));
        }
        function y() {
          const L = c.newAttributes,
            B = c.enabledAttributes;
          for (let R = 0, V = B.length; R < V; R++)
            B[R] !== L[R] && (s.disableVertexAttribArray(R), (B[R] = 0));
        }
        function C(L, B, R, V, H, J) {
          n.isWebGL2 === !0 && (R === 5124 || R === 5125)
            ? s.vertexAttribIPointer(L, B, R, H, J)
            : s.vertexAttribPointer(L, B, R, V, H, J);
        }
        function U(L, B, R, V) {
          if (
            n.isWebGL2 === !1 &&
            (L.isInstancedMesh || V.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
          )
            return;
          M();
          const H = V.attributes,
            J = R.getAttributes(),
            ie = B.defaultAttributeValues;
          for (const ne in J) {
            const ae = J[ne];
            if (ae.location >= 0) {
              let fe = H[ne];
              if (
                (fe === void 0 &&
                  (ne === "instanceMatrix" &&
                    L.instanceMatrix &&
                    (fe = L.instanceMatrix),
                  ne === "instanceColor" &&
                    L.instanceColor &&
                    (fe = L.instanceColor)),
                fe !== void 0)
              ) {
                const Fe = fe.normalized,
                  Ee = fe.itemSize,
                  $ = t.get(fe);
                if ($ === void 0) continue;
                const ke = $.buffer,
                  Re = $.type,
                  Te = $.bytesPerElement;
                if (fe.isInterleavedBufferAttribute) {
                  const ce = fe.data,
                    Ie = ce.stride,
                    j = fe.offset;
                  if (ce.isInstancedInterleavedBuffer) {
                    for (let Z = 0; Z < ae.locationSize; Z++)
                      v(ae.location + Z, ce.meshPerAttribute);
                    L.isInstancedMesh !== !0 &&
                      V._maxInstanceCount === void 0 &&
                      (V._maxInstanceCount = ce.meshPerAttribute * ce.count);
                  } else
                    for (let Z = 0; Z < ae.locationSize; Z++)
                      S(ae.location + Z);
                  s.bindBuffer(34962, ke);
                  for (let Z = 0; Z < ae.locationSize; Z++)
                    C(
                      ae.location + Z,
                      Ee / ae.locationSize,
                      Re,
                      Fe,
                      Ie * Te,
                      (j + (Ee / ae.locationSize) * Z) * Te
                    );
                } else {
                  if (fe.isInstancedBufferAttribute) {
                    for (let ce = 0; ce < ae.locationSize; ce++)
                      v(ae.location + ce, fe.meshPerAttribute);
                    L.isInstancedMesh !== !0 &&
                      V._maxInstanceCount === void 0 &&
                      (V._maxInstanceCount = fe.meshPerAttribute * fe.count);
                  } else
                    for (let ce = 0; ce < ae.locationSize; ce++)
                      S(ae.location + ce);
                  s.bindBuffer(34962, ke);
                  for (let ce = 0; ce < ae.locationSize; ce++)
                    C(
                      ae.location + ce,
                      Ee / ae.locationSize,
                      Re,
                      Fe,
                      Ee * Te,
                      (Ee / ae.locationSize) * ce * Te
                    );
                }
              } else if (ie !== void 0) {
                const Fe = ie[ne];
                if (Fe !== void 0)
                  switch (Fe.length) {
                    case 2:
                      s.vertexAttrib2fv(ae.location, Fe);
                      break;
                    case 3:
                      s.vertexAttrib3fv(ae.location, Fe);
                      break;
                    case 4:
                      s.vertexAttrib4fv(ae.location, Fe);
                      break;
                    default:
                      s.vertexAttrib1fv(ae.location, Fe);
                  }
              }
            }
          }
          y();
        }
        function K() {
          D();
          for (const L in a) {
            const B = a[L];
            for (const R in B) {
              const V = B[R];
              for (const H in V) m(V[H].object), delete V[H];
              delete B[R];
            }
            delete a[L];
          }
        }
        function X(L) {
          if (a[L.id] === void 0) return;
          const B = a[L.id];
          for (const R in B) {
            const V = B[R];
            for (const H in V) m(V[H].object), delete V[H];
            delete B[R];
          }
          delete a[L.id];
        }
        function b(L) {
          for (const B in a) {
            const R = a[B];
            if (R[L.id] === void 0) continue;
            const V = R[L.id];
            for (const H in V) m(V[H].object), delete V[H];
            delete R[L.id];
          }
        }
        function D() {
          I(), (h = !0), c !== l && ((c = l), f(c.object));
        }
        function I() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: u,
          reset: D,
          resetDefaultState: I,
          dispose: K,
          releaseStatesOfGeometry: X,
          releaseStatesOfProgram: b,
          initAttributes: M,
          enableAttribute: S,
          disableUnusedAttributes: y,
        };
      }
      function oA(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(c) {
          r = c;
        }
        function a(c, h) {
          s.drawArrays(r, c, h), t.update(h, r, 1);
        }
        function l(c, h, u) {
          if (u === 0) return;
          let d, f;
          if (i) (d = s), (f = "drawArraysInstanced");
          else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
          ) {
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          d[f](r, c, h, u), t.update(h, r, u);
        }
        (this.setMode = o), (this.render = a), (this.renderInstances = l);
      }
      function aA(s, e, t) {
        let n;
        function i() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            n = s.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function r(C) {
          if (C === "highp") {
            if (
              s.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              s.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            C = "mediump";
          }
          return C === "mediump" &&
            s.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            s.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          (typeof WebGL2RenderingContext != "undefined" &&
            s instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext != "undefined" &&
            s instanceof WebGL2ComputeRenderingContext);
        let a = t.precision !== void 0 ? t.precision : "highp";
        const l = r(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
          ),
          (a = l));
        const c = o || e.has("WEBGL_draw_buffers"),
          h = t.logarithmicDepthBuffer === !0,
          u = s.getParameter(34930),
          d = s.getParameter(35660),
          f = s.getParameter(3379),
          m = s.getParameter(34076),
          p = s.getParameter(34921),
          g = s.getParameter(36347),
          x = s.getParameter(36348),
          _ = s.getParameter(36349),
          M = d > 0,
          S = o || e.has("OES_texture_float"),
          v = M && S,
          y = o ? s.getParameter(36183) : 0;
        return {
          isWebGL2: o,
          drawBuffers: c,
          getMaxAnisotropy: i,
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: h,
          maxTextures: u,
          maxVertexTextures: d,
          maxTextureSize: f,
          maxCubemapSize: m,
          maxAttributes: p,
          maxVertexUniforms: g,
          maxVaryings: x,
          maxFragmentUniforms: _,
          vertexTextures: M,
          floatFragmentTextures: S,
          floatVertexTextures: v,
          maxSamples: y,
        };
      }
      function lA(s) {
        const e = this;
        let t = null,
          n = 0,
          i = !1,
          r = !1;
        const o = new oi(),
          a = new Ut(),
          l = { value: null, needsUpdate: !1 };
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (u, d, f) {
            const m = u.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = h(u, f, 0)), (n = u.length), m;
          }),
          (this.beginShadows = function () {
            (r = !0), h(null);
          }),
          (this.endShadows = function () {
            (r = !1), c();
          }),
          (this.setState = function (u, d, f) {
            const m = u.clippingPlanes,
              p = u.clipIntersection,
              g = u.clipShadows,
              x = s.get(u);
            if (!i || m === null || m.length === 0 || (r && !g))
              r ? h(null) : c();
            else {
              const _ = r ? 0 : n,
                M = _ * 4;
              let S = x.clippingState || null;
              (l.value = S), (S = h(m, d, M, f));
              for (let v = 0; v !== M; ++v) S[v] = t[v];
              (x.clippingState = S),
                (this.numIntersection = p ? this.numPlanes : 0),
                (this.numPlanes += _);
            }
          });
        function c() {
          l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function h(u, d, f, m) {
          const p = u !== null ? u.length : 0;
          let g = null;
          if (p !== 0) {
            if (((g = l.value), m !== !0 || g === null)) {
              const x = f + p * 4,
                _ = d.matrixWorldInverse;
              a.getNormalMatrix(_),
                (g === null || g.length < x) && (g = new Float32Array(x));
              for (let M = 0, S = f; M !== p; ++M, S += 4)
                o.copy(u[M]).applyMatrix4(_, a),
                  o.normal.toArray(g, S),
                  (g[S + 3] = o.constant);
            }
            (l.value = g), (l.needsUpdate = !0);
          }
          return (e.numPlanes = p), (e.numIntersection = 0), g;
        }
      }
      function cA(s) {
        let e = new WeakMap();
        function t(o, a) {
          return a === Lh ? (o.mapping = ms) : a === Rh && (o.mapping = gs), o;
        }
        function n(o) {
          if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === Lh || a === Rh)
              if (e.has(o)) {
                const l = e.get(o).texture;
                return t(l, o.mapping);
              } else {
                const l = o.image;
                if (l && l.height > 0) {
                  const c = new ag(l.height / 2);
                  return (
                    c.fromEquirectangularTexture(s, o),
                    e.set(o, c),
                    o.addEventListener("dispose", i),
                    t(c.texture, o.mapping)
                  );
                } else return null;
              }
          }
          return o;
        }
        function i(o) {
          const a = o.target;
          a.removeEventListener("dispose", i);
          const l = e.get(a);
          l !== void 0 && (e.delete(a), l.dispose());
        }
        function r() {
          e = new WeakMap();
        }
        return { get: n, dispose: r };
      }
      class Mu extends _u {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, o) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            o = n + e,
            a = i + t,
            l = i - t;
          if (this.view !== null && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += c * this.view.offsetX),
              (o = r + c * this.view.width),
              (a -= h * this.view.offsetY),
              (l = a - h * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            a,
            l,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      Mu.prototype.isOrthographicCamera = !0;
      const ts = 4,
        Kf = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Ki = 20,
        eh = new Mu(),
        Qf = new Ve();
      let th = null;
      const Ji = (1 + Math.sqrt(5)) / 2,
        kr = 1 / Ji,
        ep = [
          new W(1, 1, 1),
          new W(-1, 1, 1),
          new W(1, 1, -1),
          new W(-1, 1, -1),
          new W(0, Ji, kr),
          new W(0, Ji, -kr),
          new W(kr, 0, Ji),
          new W(-kr, 0, Ji),
          new W(Ji, kr, 0),
          new W(-Ji, kr, 0),
        ];
      class tp {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          (th = this._renderer.getRenderTarget()), this._setSize(256);
          const r = this._allocateTargets();
          return (
            (r.depthBuffer = !0),
            this._sceneToCubeUV(e, n, i, r),
            t > 0 && this._blur(r, 0, 0, t),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null &&
            ((this._cubemapMaterial = rp()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null &&
            ((this._equirectMaterial = ip()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(th),
            (e.scissorTest = !1),
            qa(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === ms || e.mapping === gs
            ? this._setSize(
                e.image.length === 0
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            (th = this._renderer.getRenderTarget());
          const n = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize - 32,
            n = {
              magFilter: nn,
              minFilter: nn,
              generateMipmaps: !1,
              type: os,
              format: Dn,
              encoding: hi,
              depthBuffer: !1,
            },
            i = np(e, t, n);
          if (
            this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== e
          ) {
            this._pingPongRenderTarget !== null && this._dispose(),
              (this._pingPongRenderTarget = np(e, t, n));
            const { _lodMax: r } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = hA(r)),
              (this._blurMaterial = uA(r, e, t));
          }
          return i;
        }
        _compileMaterial(e) {
          const t = new on(this._lodPlanes[0], e);
          this._renderer.compile(t, eh);
        }
        _sceneToCubeUV(e, t, n, i) {
          const a = new Yt(90, 1, t, n),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            h = this._renderer,
            u = h.autoClear,
            d = h.toneMapping;
          h.getClearColor(Qf), (h.toneMapping = li), (h.autoClear = !1);
          const f = new Il({
              name: "PMREM.Background",
              side: Nn,
              depthWrite: !1,
              depthTest: !1,
            }),
            m = new on(new qo(), f);
          let p = !1;
          const g = e.background;
          g
            ? g.isColor && (f.color.copy(g), (e.background = null), (p = !0))
            : (f.color.copy(Qf), (p = !0));
          for (let x = 0; x < 6; x++) {
            const _ = x % 3;
            _ === 0
              ? (a.up.set(0, l[x], 0), a.lookAt(c[x], 0, 0))
              : _ === 1
              ? (a.up.set(0, 0, l[x]), a.lookAt(0, c[x], 0))
              : (a.up.set(0, l[x], 0), a.lookAt(0, 0, c[x]));
            const M = this._cubeSize;
            qa(i, _ * M, x > 2 ? M : 0, M, M),
              h.setRenderTarget(i),
              p && h.render(m, a),
              h.render(e, a);
          }
          m.geometry.dispose(),
            m.material.dispose(),
            (h.toneMapping = d),
            (h.autoClear = u),
            (e.background = g);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer,
            i = e.mapping === ms || e.mapping === gs;
          i
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = rp()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                e.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null &&
              (this._equirectMaterial = ip());
          const r = i ? this._cubemapMaterial : this._equirectMaterial,
            o = new on(this._lodPlanes[0], r),
            a = r.uniforms;
          a.envMap.value = e;
          const l = this._cubeSize;
          qa(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, eh);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          for (let i = 1; i < this._lodPlanes.length; i++) {
            const r = Math.sqrt(
                this._sigmas[i] * this._sigmas[i] -
                  this._sigmas[i - 1] * this._sigmas[i - 1]
              ),
              o = ep[(i - 1) % ep.length];
            this._blur(e, i - 1, i, r, o);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, r) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(e, o, t, n, i, "latitudinal", r),
            this._halfBlur(o, e, n, n, i, "longitudinal", r);
        }
        _halfBlur(e, t, n, i, r, o, a) {
          const l = this._renderer,
            c = this._blurMaterial;
          o !== "latitudinal" &&
            o !== "longitudinal" &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const h = 3,
            u = new on(this._lodPlanes[i], c),
            d = c.uniforms,
            f = this._sizeLods[n] - 1,
            m = isFinite(r) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * Ki - 1),
            p = r / m,
            g = isFinite(r) ? 1 + Math.floor(h * p) : Ki;
          g > Ki &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Ki}`
            );
          const x = [];
          let _ = 0;
          for (let C = 0; C < Ki; ++C) {
            const U = C / p,
              K = Math.exp((-U * U) / 2);
            x.push(K), C === 0 ? (_ += K) : C < g && (_ += 2 * K);
          }
          for (let C = 0; C < x.length; C++) x[C] = x[C] / _;
          (d.envMap.value = e.texture),
            (d.samples.value = g),
            (d.weights.value = x),
            (d.latitudinal.value = o === "latitudinal"),
            a && (d.poleAxis.value = a);
          const { _lodMax: M } = this;
          (d.dTheta.value = m), (d.mipInt.value = M - n);
          const S = this._sizeLods[i],
            v = 3 * S * (i > M - ts ? i - M + ts : 0),
            y = 4 * (this._cubeSize - S);
          qa(t, v, y, 3 * S, 2 * S), l.setRenderTarget(t), l.render(u, eh);
        }
      }
      function hA(s) {
        const e = [],
          t = [],
          n = [];
        let i = s;
        const r = s - ts + 1 + Kf.length;
        for (let o = 0; o < r; o++) {
          const a = Math.pow(2, i);
          t.push(a);
          let l = 1 / a;
          o > s - ts ? (l = Kf[o - s + ts - 1]) : o === 0 && (l = 0), n.push(l);
          const c = 1 / (a - 1),
            h = -c / 2,
            u = 1 + c / 2,
            d = [h, h, u, h, u, u, h, h, u, u, h, u],
            f = 6,
            m = 6,
            p = 3,
            g = 2,
            x = 1,
            _ = new Float32Array(p * m * f),
            M = new Float32Array(g * m * f),
            S = new Float32Array(x * m * f);
          for (let y = 0; y < f; y++) {
            const C = ((y % 3) * 2) / 3 - 1,
              U = y > 2 ? 0 : -1,
              K = [
                C,
                U,
                0,
                C + 2 / 3,
                U,
                0,
                C + 2 / 3,
                U + 1,
                0,
                C,
                U,
                0,
                C + 2 / 3,
                U + 1,
                0,
                C,
                U + 1,
                0,
              ];
            _.set(K, p * m * y), M.set(d, g * m * y);
            const X = [y, y, y, y, y, y];
            S.set(X, x * m * y);
          }
          const v = new pt();
          v.setAttribute("position", new St(_, p)),
            v.setAttribute("uv", new St(M, g)),
            v.setAttribute("faceIndex", new St(S, x)),
            e.push(v),
            i > ts && i--;
        }
        return { lodPlanes: e, sizeLods: t, sigmas: n };
      }
      function np(s, e, t) {
        const n = new fn(s, e, t);
        return (
          (n.texture.mapping = Cl),
          (n.texture.name = "PMREM.cubeUv"),
          (n.scissorTest = !0),
          n
        );
      }
      function qa(s, e, t, n, i) {
        s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
      }
      function uA(s, e, t) {
        const n = new Float32Array(Ki),
          i = new W(0, 1, 0);
        return new Fn({
          name: "SphericalGaussianBlur",
          defines: {
            n: Ki,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${s}.0`,
          },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: n },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: i },
          },
          vertexShader: bu(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: zi,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ip() {
        return new Fn({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: bu(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: zi,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function rp() {
        return new Fn({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: bu(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: zi,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function bu() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function dA(s) {
        let e = new WeakMap(),
          t = null;
        function n(a) {
          if (a && a.isTexture) {
            const l = a.mapping,
              c = l === Lh || l === Rh,
              h = l === ms || l === gs;
            if (c || h)
              if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                a.needsPMREMUpdate = !1;
                let u = e.get(a);
                return (
                  t === null && (t = new tp(s)),
                  (u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u)),
                  e.set(a, u),
                  u.texture
                );
              } else {
                if (e.has(a)) return e.get(a).texture;
                {
                  const u = a.image;
                  if ((c && u && u.height > 0) || (h && u && i(u))) {
                    t === null && (t = new tp(s));
                    const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                    return (
                      e.set(a, d), a.addEventListener("dispose", r), d.texture
                    );
                  } else return null;
                }
              }
          }
          return a;
        }
        function i(a) {
          let l = 0;
          const c = 6;
          for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
          return l === c;
        }
        function r(a) {
          const l = a.target;
          l.removeEventListener("dispose", r);
          const c = e.get(l);
          c !== void 0 && (e.delete(l), c.dispose());
        }
        function o() {
          (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
        }
        return { get: n, dispose: o };
      }
      function fA(s) {
        const e = {};
        function t(n) {
          if (e[n] !== void 0) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                s.getExtension("WEBGL_depth_texture") ||
                s.getExtension("MOZ_WEBGL_depth_texture") ||
                s.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                s.getExtension("EXT_texture_filter_anisotropic") ||
                s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                s.getExtension("WEBGL_compressed_texture_s3tc") ||
                s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                s.getExtension("WEBGL_compressed_texture_pvrtc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = s.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (n) {
            return t(n) !== null;
          },
          init: function (n) {
            n.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float"),
              t("WEBGL_multisampled_render_to_texture");
          },
          get: function (n) {
            const i = t(n);
            return (
              i === null &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              i
            );
          },
        };
      }
      function pA(s, e, t, n) {
        const i = {},
          r = new WeakMap();
        function o(u) {
          const d = u.target;
          d.index !== null && e.remove(d.index);
          for (const m in d.attributes) e.remove(d.attributes[m]);
          d.removeEventListener("dispose", o), delete i[d.id];
          const f = r.get(d);
          f && (e.remove(f), r.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
        }
        function a(u, d) {
          return (
            i[d.id] === !0 ||
              (d.addEventListener("dispose", o),
              (i[d.id] = !0),
              t.memory.geometries++),
            d
          );
        }
        function l(u) {
          const d = u.attributes;
          for (const m in d) e.update(d[m], 34962);
          const f = u.morphAttributes;
          for (const m in f) {
            const p = f[m];
            for (let g = 0, x = p.length; g < x; g++) e.update(p[g], 34962);
          }
        }
        function c(u) {
          const d = [],
            f = u.index,
            m = u.attributes.position;
          let p = 0;
          if (f !== null) {
            const _ = f.array;
            p = f.version;
            for (let M = 0, S = _.length; M < S; M += 3) {
              const v = _[M + 0],
                y = _[M + 1],
                C = _[M + 2];
              d.push(v, y, y, C, C, v);
            }
          } else {
            const _ = m.array;
            p = m.version;
            for (let M = 0, S = _.length / 3 - 1; M < S; M += 3) {
              const v = M + 0,
                y = M + 1,
                C = M + 2;
              d.push(v, y, y, C, C, v);
            }
          }
          const g = new (tg(d) ? og : sg)(d, 1);
          g.version = p;
          const x = r.get(u);
          x && e.remove(x), r.set(u, g);
        }
        function h(u) {
          const d = r.get(u);
          if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u);
          } else c(u);
          return r.get(u);
        }
        return { get: a, update: l, getWireframeAttribute: h };
      }
      function mA(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(d) {
          r = d;
        }
        let a, l;
        function c(d) {
          (a = d.type), (l = d.bytesPerElement);
        }
        function h(d, f) {
          s.drawElements(r, f, a, d * l), t.update(f, r, 1);
        }
        function u(d, f, m) {
          if (m === 0) return;
          let p, g;
          if (i) (p = s), (g = "drawElementsInstanced");
          else if (
            ((p = e.get("ANGLE_instanced_arrays")),
            (g = "drawElementsInstancedANGLE"),
            p === null)
          ) {
            console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          p[g](r, f, a, d * l, m), t.update(f, r, m);
        }
        (this.setMode = o),
          (this.setIndex = c),
          (this.render = h),
          (this.renderInstances = u);
      }
      function gA(s) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(r, o, a) {
          switch ((t.calls++, o)) {
            case 4:
              t.triangles += a * (r / 3);
              break;
            case 1:
              t.lines += a * (r / 2);
              break;
            case 3:
              t.lines += a * (r - 1);
              break;
            case 2:
              t.lines += a * r;
              break;
            case 0:
              t.points += a * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", o);
              break;
          }
        }
        function i() {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: !0,
          reset: i,
          update: n,
        };
      }
      function xA(s, e) {
        return s[0] - e[0];
      }
      function _A(s, e) {
        return Math.abs(e[1]) - Math.abs(s[1]);
      }
      function nh(s, e) {
        let t = 1;
        const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
        n instanceof Int8Array
          ? (t = 127)
          : n instanceof Int16Array
          ? (t = 32767)
          : n instanceof Int32Array
          ? (t = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              n
            ),
          s.divideScalar(t);
      }
      function vA(s, e, t) {
        const n = {},
          i = new Float32Array(8),
          r = new WeakMap(),
          o = new st(),
          a = [];
        for (let c = 0; c < 8; c++) a[c] = [c, 0];
        function l(c, h, u, d) {
          const f = c.morphTargetInfluences;
          if (e.isWebGL2 === !0) {
            const p =
                h.morphAttributes.position ||
                h.morphAttributes.normal ||
                h.morphAttributes.color,
              g = p !== void 0 ? p.length : 0;
            let x = r.get(h);
            if (x === void 0 || x.count !== g) {
              let R = function () {
                L.dispose(), r.delete(h), h.removeEventListener("dispose", R);
              };
              var m = R;
              x !== void 0 && x.texture.dispose();
              const S = h.morphAttributes.position !== void 0,
                v = h.morphAttributes.normal !== void 0,
                y = h.morphAttributes.color !== void 0,
                C = h.morphAttributes.position || [],
                U = h.morphAttributes.normal || [],
                K = h.morphAttributes.color || [];
              let X = 0;
              S === !0 && (X = 1), v === !0 && (X = 2), y === !0 && (X = 3);
              let b = h.attributes.position.count * X,
                D = 1;
              b > e.maxTextureSize &&
                ((D = Math.ceil(b / e.maxTextureSize)), (b = e.maxTextureSize));
              const I = new Float32Array(b * D * 4 * g),
                L = new Dl(I, b, D, g);
              (L.type = Qi), (L.needsUpdate = !0);
              const B = X * 4;
              for (let V = 0; V < g; V++) {
                const H = C[V],
                  J = U[V],
                  ie = K[V],
                  ne = b * D * 4 * V;
                for (let ae = 0; ae < H.count; ae++) {
                  const fe = ae * B;
                  S === !0 &&
                    (o.fromBufferAttribute(H, ae),
                    H.normalized === !0 && nh(o, H),
                    (I[ne + fe + 0] = o.x),
                    (I[ne + fe + 1] = o.y),
                    (I[ne + fe + 2] = o.z),
                    (I[ne + fe + 3] = 0)),
                    v === !0 &&
                      (o.fromBufferAttribute(J, ae),
                      J.normalized === !0 && nh(o, J),
                      (I[ne + fe + 4] = o.x),
                      (I[ne + fe + 5] = o.y),
                      (I[ne + fe + 6] = o.z),
                      (I[ne + fe + 7] = 0)),
                    y === !0 &&
                      (o.fromBufferAttribute(ie, ae),
                      ie.normalized === !0 && nh(o, ie),
                      (I[ne + fe + 8] = o.x),
                      (I[ne + fe + 9] = o.y),
                      (I[ne + fe + 10] = o.z),
                      (I[ne + fe + 11] = ie.itemSize === 4 ? o.w : 1));
                }
              }
              (x = { count: g, texture: L, size: new ye(b, D) }),
                r.set(h, x),
                h.addEventListener("dispose", R);
            }
            let _ = 0;
            for (let S = 0; S < f.length; S++) _ += f[S];
            const M = h.morphTargetsRelative ? 1 : 1 - _;
            d.getUniforms().setValue(s, "morphTargetBaseInfluence", M),
              d.getUniforms().setValue(s, "morphTargetInfluences", f),
              d.getUniforms().setValue(s, "morphTargetsTexture", x.texture, t),
              d.getUniforms().setValue(s, "morphTargetsTextureSize", x.size);
          } else {
            const p = f === void 0 ? 0 : f.length;
            let g = n[h.id];
            if (g === void 0 || g.length !== p) {
              g = [];
              for (let v = 0; v < p; v++) g[v] = [v, 0];
              n[h.id] = g;
            }
            for (let v = 0; v < p; v++) {
              const y = g[v];
              (y[0] = v), (y[1] = f[v]);
            }
            g.sort(_A);
            for (let v = 0; v < 8; v++)
              v < p && g[v][1]
                ? ((a[v][0] = g[v][0]), (a[v][1] = g[v][1]))
                : ((a[v][0] = Number.MAX_SAFE_INTEGER), (a[v][1] = 0));
            a.sort(xA);
            const x = h.morphAttributes.position,
              _ = h.morphAttributes.normal;
            let M = 0;
            for (let v = 0; v < 8; v++) {
              const y = a[v],
                C = y[0],
                U = y[1];
              C !== Number.MAX_SAFE_INTEGER && U
                ? (x &&
                    h.getAttribute("morphTarget" + v) !== x[C] &&
                    h.setAttribute("morphTarget" + v, x[C]),
                  _ &&
                    h.getAttribute("morphNormal" + v) !== _[C] &&
                    h.setAttribute("morphNormal" + v, _[C]),
                  (i[v] = U),
                  (M += U))
                : (x &&
                    h.hasAttribute("morphTarget" + v) === !0 &&
                    h.deleteAttribute("morphTarget" + v),
                  _ &&
                    h.hasAttribute("morphNormal" + v) === !0 &&
                    h.deleteAttribute("morphNormal" + v),
                  (i[v] = 0));
            }
            const S = h.morphTargetsRelative ? 1 : 1 - M;
            d.getUniforms().setValue(s, "morphTargetBaseInfluence", S),
              d.getUniforms().setValue(s, "morphTargetInfluences", i);
          }
        }
        return { update: l };
      }
      function yA(s, e, t, n) {
        let i = new WeakMap();
        function r(l) {
          const c = n.render.frame,
            h = l.geometry,
            u = e.get(l, h);
          return (
            i.get(u) !== c && (e.update(u), i.set(u, c)),
            l.isInstancedMesh &&
              (l.hasEventListener("dispose", a) === !1 &&
                l.addEventListener("dispose", a),
              t.update(l.instanceMatrix, 34962),
              l.instanceColor !== null && t.update(l.instanceColor, 34962)),
            u
          );
        }
        function o() {
          i = new WeakMap();
        }
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return { update: r, dispose: o };
      }
      const cg = new Nt(),
        hg = new Dl(),
        ug = new xu(),
        dg = new Nl(),
        sp = [],
        op = [],
        ap = new Float32Array(16),
        lp = new Float32Array(9),
        cp = new Float32Array(4);
      function Is(s, e, t) {
        const n = s[0];
        if (n <= 0 || n > 0) return s;
        const i = e * t;
        let r = sp[i];
        if (
          (r === void 0 && ((r = new Float32Array(i)), (sp[i] = r)), e !== 0)
        ) {
          n.toArray(r, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), s[o].toArray(r, a);
        }
        return r;
      }
      function Kt(s, e) {
        if (s.length !== e.length) return !1;
        for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
        return !0;
      }
      function Xt(s, e) {
        for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
      }
      function Bl(s, e) {
        let t = op[e];
        t === void 0 && ((t = new Int32Array(e)), (op[e] = t));
        for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
        return t;
      }
      function MA(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
      }
      function bA(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y) &&
            (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (Kt(t, e)) return;
          s.uniform2fv(this.addr, e), Xt(t, e);
        }
      }
      function wA(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (s.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (s.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (Kt(t, e)) return;
          s.uniform3fv(this.addr, e), Xt(t, e);
        }
      }
      function SA(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (Kt(t, e)) return;
          s.uniform4fv(this.addr, e), Xt(t, e);
        }
      }
      function TA(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Kt(t, e)) return;
          s.uniformMatrix2fv(this.addr, !1, e), Xt(t, e);
        } else {
          if (Kt(t, n)) return;
          cp.set(n), s.uniformMatrix2fv(this.addr, !1, cp), Xt(t, n);
        }
      }
      function EA(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Kt(t, e)) return;
          s.uniformMatrix3fv(this.addr, !1, e), Xt(t, e);
        } else {
          if (Kt(t, n)) return;
          lp.set(n), s.uniformMatrix3fv(this.addr, !1, lp), Xt(t, n);
        }
      }
      function AA(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (Kt(t, e)) return;
          s.uniformMatrix4fv(this.addr, !1, e), Xt(t, e);
        } else {
          if (Kt(t, n)) return;
          ap.set(n), s.uniformMatrix4fv(this.addr, !1, ap), Xt(t, n);
        }
      }
      function LA(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
      }
      function RA(s, e) {
        const t = this.cache;
        Kt(t, e) || (s.uniform2iv(this.addr, e), Xt(t, e));
      }
      function CA(s, e) {
        const t = this.cache;
        Kt(t, e) || (s.uniform3iv(this.addr, e), Xt(t, e));
      }
      function PA(s, e) {
        const t = this.cache;
        Kt(t, e) || (s.uniform4iv(this.addr, e), Xt(t, e));
      }
      function DA(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
      }
      function IA(s, e) {
        const t = this.cache;
        Kt(t, e) || (s.uniform2uiv(this.addr, e), Xt(t, e));
      }
      function NA(s, e) {
        const t = this.cache;
        Kt(t, e) || (s.uniform3uiv(this.addr, e), Xt(t, e));
      }
      function FA(s, e) {
        const t = this.cache;
        Kt(t, e) || (s.uniform4uiv(this.addr, e), Xt(t, e));
      }
      function BA(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2D(e || cg, i);
      }
      function zA(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture3D(e || ug, i);
      }
      function OA(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTextureCube(e || dg, i);
      }
      function UA(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2DArray(e || hg, i);
      }
      function HA(s) {
        switch (s) {
          case 5126:
            return MA;
          case 35664:
            return bA;
          case 35665:
            return wA;
          case 35666:
            return SA;
          case 35674:
            return TA;
          case 35675:
            return EA;
          case 35676:
            return AA;
          case 5124:
          case 35670:
            return LA;
          case 35667:
          case 35671:
            return RA;
          case 35668:
          case 35672:
            return CA;
          case 35669:
          case 35673:
            return PA;
          case 5125:
            return DA;
          case 36294:
            return IA;
          case 36295:
            return NA;
          case 36296:
            return FA;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return BA;
          case 35679:
          case 36299:
          case 36307:
            return zA;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return OA;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return UA;
        }
      }
      function GA(s, e) {
        s.uniform1fv(this.addr, e);
      }
      function VA(s, e) {
        const t = Is(e, this.size, 2);
        s.uniform2fv(this.addr, t);
      }
      function kA(s, e) {
        const t = Is(e, this.size, 3);
        s.uniform3fv(this.addr, t);
      }
      function WA(s, e) {
        const t = Is(e, this.size, 4);
        s.uniform4fv(this.addr, t);
      }
      function $A(s, e) {
        const t = Is(e, this.size, 4);
        s.uniformMatrix2fv(this.addr, !1, t);
      }
      function qA(s, e) {
        const t = Is(e, this.size, 9);
        s.uniformMatrix3fv(this.addr, !1, t);
      }
      function XA(s, e) {
        const t = Is(e, this.size, 16);
        s.uniformMatrix4fv(this.addr, !1, t);
      }
      function jA(s, e) {
        s.uniform1iv(this.addr, e);
      }
      function YA(s, e) {
        s.uniform2iv(this.addr, e);
      }
      function ZA(s, e) {
        s.uniform3iv(this.addr, e);
      }
      function JA(s, e) {
        s.uniform4iv(this.addr, e);
      }
      function KA(s, e) {
        s.uniform1uiv(this.addr, e);
      }
      function QA(s, e) {
        s.uniform2uiv(this.addr, e);
      }
      function eL(s, e) {
        s.uniform3uiv(this.addr, e);
      }
      function tL(s, e) {
        s.uniform4uiv(this.addr, e);
      }
      function nL(s, e, t) {
        const n = e.length,
          i = Bl(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTexture2D(e[r] || cg, i[r]);
      }
      function iL(s, e, t) {
        const n = e.length,
          i = Bl(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTexture3D(e[r] || ug, i[r]);
      }
      function rL(s, e, t) {
        const n = e.length,
          i = Bl(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTextureCube(e[r] || dg, i[r]);
      }
      function sL(s, e, t) {
        const n = e.length,
          i = Bl(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.setTexture2DArray(e[r] || hg, i[r]);
      }
      function oL(s) {
        switch (s) {
          case 5126:
            return GA;
          case 35664:
            return VA;
          case 35665:
            return kA;
          case 35666:
            return WA;
          case 35674:
            return $A;
          case 35675:
            return qA;
          case 35676:
            return XA;
          case 5124:
          case 35670:
            return jA;
          case 35667:
          case 35671:
            return YA;
          case 35668:
          case 35672:
            return ZA;
          case 35669:
          case 35673:
            return JA;
          case 5125:
            return KA;
          case 36294:
            return QA;
          case 36295:
            return eL;
          case 36296:
            return tL;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return nL;
          case 35679:
          case 36299:
          case 36307:
            return iL;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return rL;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return sL;
        }
      }
      function aL(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.setValue = HA(e.type));
      }
      function fg(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = oL(e.type));
      }
      fg.prototype.updateCache = function (s) {
        const e = this.cache;
        s instanceof Float32Array &&
          e.length !== s.length &&
          (this.cache = new Float32Array(s.length)),
          Xt(e, s);
      };
      function pg(s) {
        (this.id = s), (this.seq = []), (this.map = {});
      }
      pg.prototype.setValue = function (s, e, t) {
        const n = this.seq;
        for (let i = 0, r = n.length; i !== r; ++i) {
          const o = n[i];
          o.setValue(s, e[o.id], t);
        }
      };
      const ih = /(\w+)(\])?(\[|\.)?/g;
      function hp(s, e) {
        s.seq.push(e), (s.map[e.id] = e);
      }
      function lL(s, e, t) {
        const n = s.name,
          i = n.length;
        for (ih.lastIndex = 0; ; ) {
          const r = ih.exec(n),
            o = ih.lastIndex;
          let a = r[1];
          const l = r[2] === "]",
            c = r[3];
          if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
            hp(t, c === void 0 ? new aL(a, s, e) : new fg(a, s, e));
            break;
          } else {
            let u = t.map[a];
            u === void 0 && ((u = new pg(a)), hp(t, u)), (t = u);
          }
        }
      }
      function Oi(s, e) {
        (this.seq = []), (this.map = {});
        const t = s.getProgramParameter(e, 35718);
        for (let n = 0; n < t; ++n) {
          const i = s.getActiveUniform(e, n),
            r = s.getUniformLocation(e, i.name);
          lL(i, r, this);
        }
      }
      Oi.prototype.setValue = function (s, e, t, n) {
        const i = this.map[e];
        i !== void 0 && i.setValue(s, t, n);
      };
      Oi.prototype.setOptional = function (s, e, t) {
        const n = e[t];
        n !== void 0 && this.setValue(s, t, n);
      };
      Oi.upload = function (s, e, t, n) {
        for (let i = 0, r = e.length; i !== r; ++i) {
          const o = e[i],
            a = t[o.id];
          a.needsUpdate !== !1 && o.setValue(s, a.value, n);
        }
      };
      Oi.seqWithValue = function (s, e) {
        const t = [];
        for (let n = 0, i = s.length; n !== i; ++n) {
          const r = s[n];
          r.id in e && t.push(r);
        }
        return t;
      };
      function up(s, e, t) {
        const n = s.createShader(e);
        return s.shaderSource(n, t), s.compileShader(n), n;
      }
      let cL = 0;
      function hL(s, e) {
        const t = s.split(`
`),
          n = [],
          i = Math.max(e - 6, 0),
          r = Math.min(e + 6, t.length);
        for (let o = i; o < r; o++) n.push(o + 1 + ": " + t[o]);
        return n.join(`
`);
      }
      function uL(s) {
        switch (s) {
          case hi:
            return ["Linear", "( value )"];
          case ht:
            return ["sRGB", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", s),
              ["Linear", "( value )"]
            );
        }
      }
      function dp(s, e, t) {
        const n = s.getShaderParameter(e, 35713),
          i = s.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const r = parseInt(/ERROR: 0:(\d+)/.exec(i)[1]);
        return (
          t.toUpperCase() +
          `

` +
          i +
          `

` +
          hL(s.getShaderSource(e), r)
        );
      }
      function dL(s, e) {
        const t = uL(e);
        return (
          "vec4 " + s + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function fL(s, e) {
        let t;
        switch (e) {
          case NS:
            t = "Linear";
            break;
          case FS:
            t = "Reinhard";
            break;
          case BS:
            t = "OptimizedCineon";
            break;
          case zS:
            t = "ACESFilmic";
            break;
          case OS:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          s +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function pL(s) {
        return [
          s.extensionDerivatives ||
          !!s.envMapCubeUVHeight ||
          s.bumpMap ||
          s.tangentSpaceNormalMap ||
          s.clearcoatNormalMap ||
          s.flatShading ||
          s.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
          s.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (s.extensionShaderTextureLOD || s.envMap || s.transmission) &&
          s.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ].filter(uo).join(`
`);
      }
      function mL(s) {
        const e = [];
        for (const t in s) {
          const n = s[t];
          n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
      }
      function gL(s, e) {
        const t = {},
          n = s.getProgramParameter(e, 35721);
        for (let i = 0; i < n; i++) {
          const r = s.getActiveAttrib(e, i),
            o = r.name;
          let a = 1;
          r.type === 35674 && (a = 2),
            r.type === 35675 && (a = 3),
            r.type === 35676 && (a = 4),
            (t[o] = {
              type: r.type,
              location: s.getAttribLocation(e, o),
              locationSize: a,
            });
        }
        return t;
      }
      function uo(s) {
        return s !== "";
      }
      function fp(s, e) {
        return s
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function pp(s, e) {
        return s
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const xL = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Fh(s) {
        return s.replace(xL, _L);
      }
      function _L(s, e) {
        const t = Ye[e];
        if (t === void 0)
          throw new Error("Can not resolve #include <" + e + ">");
        return Fh(t);
      }
      const vL =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        yL =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function mp(s) {
        return s.replace(yL, mg).replace(vL, ML);
      }
      function ML(s, e, t, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          mg(s, e, t, n)
        );
      }
      function mg(s, e, t, n) {
        let i = "";
        for (let r = parseInt(e); r < parseInt(t); r++)
          i += n
            .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, r);
        return i;
      }
      function gp(s) {
        let e =
          "precision " +
          s.precision +
          ` float;
precision ` +
          s.precision +
          " int;";
        return (
          s.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : s.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : s.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function bL(s) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          s.shadowMapType === jm
            ? (e = "SHADOWMAP_TYPE_PCF")
            : s.shadowMapType === Ym
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : s.shadowMapType === ho && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function wL(s) {
        let e = "ENVMAP_TYPE_CUBE";
        if (s.envMap)
          switch (s.envMapMode) {
            case ms:
            case gs:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case Cl:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function SL(s) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (s.envMap)
          switch (s.envMapMode) {
            case gs:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function TL(s) {
        let e = "ENVMAP_BLENDING_NONE";
        if (s.envMap)
          switch (s.combine) {
            case Rl:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case DS:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case IS:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function EL(s) {
        const e = s.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e / 32 + 1) + 3,
          n = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
          texelHeight: n,
          maxMip: t,
        };
      }
      function AL(s, e, t, n) {
        const i = s.getContext(),
          r = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const l = bL(t),
          c = wL(t),
          h = SL(t),
          u = TL(t),
          d = EL(t),
          f = t.isWebGL2 ? "" : pL(t),
          m = mL(r),
          p = i.createProgram();
        let g,
          x,
          _ = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((g = [m].filter(uo).join(`
`)),
            g.length > 0 &&
              (g += `
`),
            (x = [f, m].filter(uo).join(`
`)),
            x.length > 0 &&
              (x += `
`))
          : ((g = [
              gp(t),
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define MAX_BONES " + t.maxBones,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + h : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.useVertexTexture ? "#define BONE_TEXTURE" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(uo).join(`
`)),
            (x = [
              f,
              gp(t),
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + h : "",
              t.envMap ? "#define " + u : "",
              d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
              d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
              d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== li ? "#define TONE_MAPPING" : "",
              t.toneMapping !== li ? Ye.tonemapping_pars_fragment : "",
              t.toneMapping !== li ? fL("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.opaque ? "#define OPAQUE" : "",
              Ye.encodings_pars_fragment,
              dL("linearToOutputTexel", t.outputEncoding),
              t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
              `
`,
            ].filter(uo).join(`
`))),
          (o = Fh(o)),
          (o = fp(o, t)),
          (o = pp(o, t)),
          (a = Fh(a)),
          (a = fp(a, t)),
          (a = pp(a, t)),
          (o = mp(o)),
          (a = mp(a)),
          t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((_ = `#version 300 es
`),
            (g =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              g),
            (x =
              [
                "#define varying in",
                t.glslVersion === Uf
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                t.glslVersion === Uf ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              x));
        const M = _ + g + o,
          S = _ + x + a,
          v = up(i, 35633, M),
          y = up(i, 35632, S);
        if (
          (i.attachShader(p, v),
          i.attachShader(p, y),
          t.index0AttributeName !== void 0
            ? i.bindAttribLocation(p, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(p, 0, "position"),
          i.linkProgram(p),
          s.debug.checkShaderErrors)
        ) {
          const K = i.getProgramInfoLog(p).trim(),
            X = i.getShaderInfoLog(v).trim(),
            b = i.getShaderInfoLog(y).trim();
          let D = !0,
            I = !0;
          if (i.getProgramParameter(p, 35714) === !1) {
            D = !1;
            const L = dp(i, v, "vertex"),
              B = dp(i, y, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                i.getError() +
                " - VALIDATE_STATUS " +
                i.getProgramParameter(p, 35715) +
                `

Program Info Log: ` +
                K +
                `
` +
                L +
                `
` +
                B
            );
          } else
            K !== ""
              ? console.warn("THREE.WebGLProgram: Program Info Log:", K)
              : (X === "" || b === "") && (I = !1);
          I &&
            (this.diagnostics = {
              runnable: D,
              programLog: K,
              vertexShader: { log: X, prefix: g },
              fragmentShader: { log: b, prefix: x },
            });
        }
        i.deleteShader(v), i.deleteShader(y);
        let C;
        this.getUniforms = function () {
          return C === void 0 && (C = new Oi(i, p)), C;
        };
        let U;
        return (
          (this.getAttributes = function () {
            return U === void 0 && (U = gL(i, p)), U;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              i.deleteProgram(p),
              (this.program = void 0);
          }),
          (this.name = t.shaderName),
          (this.id = cL++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = p),
          (this.vertexShader = v),
          (this.fragmentShader = y),
          this
        );
      }
      let LL = 0;
      class RL {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            r = this._getShaderStage(n),
            o = this._getShaderCacheForMaterial(e);
          return (
            o.has(i) === !1 && (o.add(i), i.usedTimes++),
            o.has(r) === !1 && (o.add(r), r.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const n of t)
            n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          if (t.has(e) === !1) {
            const n = new CL(e);
            t.set(e, n);
          }
          return t.get(e);
        }
      }
      class CL {
        constructor(e) {
          (this.id = LL++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function PL(s, e, t, n, i, r, o) {
        const a = new rg(),
          l = new RL(),
          c = [],
          h = i.isWebGL2,
          u = i.logarithmicDepthBuffer,
          d = i.floatVertexTextures,
          f = i.maxVertexUniforms,
          m = i.vertexTextures;
        let p = i.precision;
        const g = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function x(b) {
          const I = b.skeleton.bones;
          if (d) return 1024;
          {
            const B = Math.floor((f - 20) / 4),
              R = Math.min(B, I.length);
            return R < I.length
              ? (console.warn(
                  "THREE.WebGLRenderer: Skeleton has " +
                    I.length +
                    " bones. This GPU supports " +
                    R +
                    "."
                ),
                0)
              : R;
          }
        }
        function _(b, D, I, L, B) {
          const R = L.fog,
            V = B.geometry,
            H = b.isMeshStandardMaterial ? L.environment : null,
            J = (b.isMeshStandardMaterial ? t : e).get(b.envMap || H),
            ie = !!J && J.mapping === Cl ? J.image.height : null,
            ne = g[b.type],
            ae = B.isSkinnedMesh ? x(B) : 0;
          b.precision !== null &&
            ((p = i.getMaxPrecision(b.precision)),
            p !== b.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                b.precision,
                "not supported, using",
                p,
                "instead."
              ));
          const fe =
              V.morphAttributes.position ||
              V.morphAttributes.normal ||
              V.morphAttributes.color,
            Fe = fe !== void 0 ? fe.length : 0;
          let Ee = 0;
          V.morphAttributes.position !== void 0 && (Ee = 1),
            V.morphAttributes.normal !== void 0 && (Ee = 2),
            V.morphAttributes.color !== void 0 && (Ee = 3);
          let $, ke, Re, Te;
          if (ne) {
            const te = Gn[ne];
            ($ = te.vertexShader), (ke = te.fragmentShader);
          } else
            ($ = b.vertexShader),
              (ke = b.fragmentShader),
              l.update(b),
              (Re = l.getVertexShaderID(b)),
              (Te = l.getFragmentShaderID(b));
          const ce = s.getRenderTarget(),
            Ie = b.alphaTest > 0,
            j = b.clearcoat > 0;
          return {
            isWebGL2: h,
            shaderID: ne,
            shaderName: b.type,
            vertexShader: $,
            fragmentShader: ke,
            defines: b.defines,
            customVertexShaderID: Re,
            customFragmentShaderID: Te,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: p,
            instancing: B.isInstancedMesh === !0,
            instancingColor:
              B.isInstancedMesh === !0 && B.instanceColor !== null,
            supportsVertexTextures: m,
            outputEncoding:
              ce === null
                ? s.outputEncoding
                : ce.isXRRenderTarget === !0
                ? ce.texture.encoding
                : hi,
            map: !!b.map,
            matcap: !!b.matcap,
            envMap: !!J,
            envMapMode: J && J.mapping,
            envMapCubeUVHeight: ie,
            lightMap: !!b.lightMap,
            aoMap: !!b.aoMap,
            emissiveMap: !!b.emissiveMap,
            bumpMap: !!b.bumpMap,
            normalMap: !!b.normalMap,
            objectSpaceNormalMap: b.normalMapType === a1,
            tangentSpaceNormalMap: b.normalMapType === Cs,
            decodeVideoTexture:
              !!b.map && b.map.isVideoTexture === !0 && b.map.encoding === ht,
            clearcoat: j,
            clearcoatMap: j && !!b.clearcoatMap,
            clearcoatRoughnessMap: j && !!b.clearcoatRoughnessMap,
            clearcoatNormalMap: j && !!b.clearcoatNormalMap,
            displacementMap: !!b.displacementMap,
            roughnessMap: !!b.roughnessMap,
            metalnessMap: !!b.metalnessMap,
            specularMap: !!b.specularMap,
            specularIntensityMap: !!b.specularIntensityMap,
            specularColorMap: !!b.specularColorMap,
            opaque: b.transparent === !1 && b.blending === ss,
            alphaMap: !!b.alphaMap,
            alphaTest: Ie,
            gradientMap: !!b.gradientMap,
            sheen: b.sheen > 0,
            sheenColorMap: !!b.sheenColorMap,
            sheenRoughnessMap: !!b.sheenRoughnessMap,
            transmission: b.transmission > 0,
            transmissionMap: !!b.transmissionMap,
            thicknessMap: !!b.thicknessMap,
            combine: b.combine,
            vertexTangents: !!b.normalMap && !!V.attributes.tangent,
            vertexColors: b.vertexColors,
            vertexAlphas:
              b.vertexColors === !0 &&
              !!V.attributes.color &&
              V.attributes.color.itemSize === 4,
            vertexUvs:
              !!b.map ||
              !!b.bumpMap ||
              !!b.normalMap ||
              !!b.specularMap ||
              !!b.alphaMap ||
              !!b.emissiveMap ||
              !!b.roughnessMap ||
              !!b.metalnessMap ||
              !!b.clearcoatMap ||
              !!b.clearcoatRoughnessMap ||
              !!b.clearcoatNormalMap ||
              !!b.displacementMap ||
              !!b.transmissionMap ||
              !!b.thicknessMap ||
              !!b.specularIntensityMap ||
              !!b.specularColorMap ||
              !!b.sheenColorMap ||
              !!b.sheenRoughnessMap,
            uvsVertexOnly:
              !(
                !!b.map ||
                !!b.bumpMap ||
                !!b.normalMap ||
                !!b.specularMap ||
                !!b.alphaMap ||
                !!b.emissiveMap ||
                !!b.roughnessMap ||
                !!b.metalnessMap ||
                !!b.clearcoatNormalMap ||
                b.transmission > 0 ||
                !!b.transmissionMap ||
                !!b.thicknessMap ||
                !!b.specularIntensityMap ||
                !!b.specularColorMap ||
                b.sheen > 0 ||
                !!b.sheenColorMap ||
                !!b.sheenRoughnessMap
              ) && !!b.displacementMap,
            fog: !!R,
            useFog: b.fog,
            fogExp2: R && R.isFogExp2,
            flatShading: !!b.flatShading,
            sizeAttenuation: b.sizeAttenuation,
            logarithmicDepthBuffer: u,
            skinning: B.isSkinnedMesh === !0 && ae > 0,
            maxBones: ae,
            useVertexTexture: d,
            morphTargets: V.morphAttributes.position !== void 0,
            morphNormals: V.morphAttributes.normal !== void 0,
            morphColors: V.morphAttributes.color !== void 0,
            morphTargetsCount: Fe,
            morphTextureStride: Ee,
            numDirLights: D.directional.length,
            numPointLights: D.point.length,
            numSpotLights: D.spot.length,
            numRectAreaLights: D.rectArea.length,
            numHemiLights: D.hemi.length,
            numDirLightShadows: D.directionalShadowMap.length,
            numPointLightShadows: D.pointShadowMap.length,
            numSpotLightShadows: D.spotShadowMap.length,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: s.shadowMap.enabled && I.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: b.toneMapped ? s.toneMapping : li,
            physicallyCorrectLights: s.physicallyCorrectLights,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === ps,
            flipSided: b.side === Nn,
            depthPacking: b.depthPacking !== void 0 ? b.depthPacking : !1,
            index0AttributeName: b.index0AttributeName,
            extensionDerivatives: b.extensions && b.extensions.derivatives,
            extensionFragDepth: b.extensions && b.extensions.fragDepth,
            extensionDrawBuffers: b.extensions && b.extensions.drawBuffers,
            extensionShaderTextureLOD:
              b.extensions && b.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              h || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: b.customProgramCacheKey(),
          };
        }
        function M(b) {
          const D = [];
          if (
            (b.shaderID
              ? D.push(b.shaderID)
              : (D.push(b.customVertexShaderID),
                D.push(b.customFragmentShaderID)),
            b.defines !== void 0)
          )
            for (const I in b.defines) D.push(I), D.push(b.defines[I]);
          return (
            b.isRawShaderMaterial === !1 &&
              (S(D, b), v(D, b), D.push(s.outputEncoding)),
            D.push(b.customProgramCacheKey),
            D.join()
          );
        }
        function S(b, D) {
          b.push(D.precision),
            b.push(D.outputEncoding),
            b.push(D.envMapMode),
            b.push(D.envMapCubeUVHeight),
            b.push(D.combine),
            b.push(D.vertexUvs),
            b.push(D.fogExp2),
            b.push(D.sizeAttenuation),
            b.push(D.maxBones),
            b.push(D.morphTargetsCount),
            b.push(D.morphAttributeCount),
            b.push(D.numDirLights),
            b.push(D.numPointLights),
            b.push(D.numSpotLights),
            b.push(D.numHemiLights),
            b.push(D.numRectAreaLights),
            b.push(D.numDirLightShadows),
            b.push(D.numPointLightShadows),
            b.push(D.numSpotLightShadows),
            b.push(D.shadowMapType),
            b.push(D.toneMapping),
            b.push(D.numClippingPlanes),
            b.push(D.numClipIntersection);
        }
        function v(b, D) {
          a.disableAll(),
            D.isWebGL2 && a.enable(0),
            D.supportsVertexTextures && a.enable(1),
            D.instancing && a.enable(2),
            D.instancingColor && a.enable(3),
            D.map && a.enable(4),
            D.matcap && a.enable(5),
            D.envMap && a.enable(6),
            D.lightMap && a.enable(7),
            D.aoMap && a.enable(8),
            D.emissiveMap && a.enable(9),
            D.bumpMap && a.enable(10),
            D.normalMap && a.enable(11),
            D.objectSpaceNormalMap && a.enable(12),
            D.tangentSpaceNormalMap && a.enable(13),
            D.clearcoat && a.enable(14),
            D.clearcoatMap && a.enable(15),
            D.clearcoatRoughnessMap && a.enable(16),
            D.clearcoatNormalMap && a.enable(17),
            D.displacementMap && a.enable(18),
            D.specularMap && a.enable(19),
            D.roughnessMap && a.enable(20),
            D.metalnessMap && a.enable(21),
            D.gradientMap && a.enable(22),
            D.alphaMap && a.enable(23),
            D.alphaTest && a.enable(24),
            D.vertexColors && a.enable(25),
            D.vertexAlphas && a.enable(26),
            D.vertexUvs && a.enable(27),
            D.vertexTangents && a.enable(28),
            D.uvsVertexOnly && a.enable(29),
            D.fog && a.enable(30),
            b.push(a.mask),
            a.disableAll(),
            D.useFog && a.enable(0),
            D.flatShading && a.enable(1),
            D.logarithmicDepthBuffer && a.enable(2),
            D.skinning && a.enable(3),
            D.useVertexTexture && a.enable(4),
            D.morphTargets && a.enable(5),
            D.morphNormals && a.enable(6),
            D.morphColors && a.enable(7),
            D.premultipliedAlpha && a.enable(8),
            D.shadowMapEnabled && a.enable(9),
            D.physicallyCorrectLights && a.enable(10),
            D.doubleSided && a.enable(11),
            D.flipSided && a.enable(12),
            D.depthPacking && a.enable(13),
            D.dithering && a.enable(14),
            D.specularIntensityMap && a.enable(15),
            D.specularColorMap && a.enable(16),
            D.transmission && a.enable(17),
            D.transmissionMap && a.enable(18),
            D.thicknessMap && a.enable(19),
            D.sheen && a.enable(20),
            D.sheenColorMap && a.enable(21),
            D.sheenRoughnessMap && a.enable(22),
            D.decodeVideoTexture && a.enable(23),
            D.opaque && a.enable(24),
            b.push(a.mask);
        }
        function y(b) {
          const D = g[b.type];
          let I;
          if (D) {
            const L = Gn[D];
            I = T1.clone(L.uniforms);
          } else I = b.uniforms;
          return I;
        }
        function C(b, D) {
          let I;
          for (let L = 0, B = c.length; L < B; L++) {
            const R = c[L];
            if (R.cacheKey === D) {
              (I = R), ++I.usedTimes;
              break;
            }
          }
          return I === void 0 && ((I = new AL(s, D, b, r)), c.push(I)), I;
        }
        function U(b) {
          if (--b.usedTimes === 0) {
            const D = c.indexOf(b);
            (c[D] = c[c.length - 1]), c.pop(), b.destroy();
          }
        }
        function K(b) {
          l.remove(b);
        }
        function X() {
          l.dispose();
        }
        return {
          getParameters: _,
          getProgramCacheKey: M,
          getUniforms: y,
          acquireProgram: C,
          releaseProgram: U,
          releaseShaderCache: K,
          programs: c,
          dispose: X,
        };
      }
      function DL() {
        let s = new WeakMap();
        function e(r) {
          let o = s.get(r);
          return o === void 0 && ((o = {}), s.set(r, o)), o;
        }
        function t(r) {
          s.delete(r);
        }
        function n(r, o, a) {
          s.get(r)[o] = a;
        }
        function i() {
          s = new WeakMap();
        }
        return { get: e, remove: t, update: n, dispose: i };
      }
      function IL(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.material.id !== e.material.id
          ? s.material.id - e.material.id
          : s.z !== e.z
          ? s.z - e.z
          : s.id - e.id;
      }
      function xp(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.z !== e.z
          ? e.z - s.z
          : s.id - e.id;
      }
      function _p() {
        const s = [];
        let e = 0;
        const t = [],
          n = [],
          i = [];
        function r() {
          (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
        }
        function o(u, d, f, m, p, g) {
          let x = s[e];
          return (
            x === void 0
              ? ((x = {
                  id: u.id,
                  object: u,
                  geometry: d,
                  material: f,
                  groupOrder: m,
                  renderOrder: u.renderOrder,
                  z: p,
                  group: g,
                }),
                (s[e] = x))
              : ((x.id = u.id),
                (x.object = u),
                (x.geometry = d),
                (x.material = f),
                (x.groupOrder = m),
                (x.renderOrder = u.renderOrder),
                (x.z = p),
                (x.group = g)),
            e++,
            x
          );
        }
        function a(u, d, f, m, p, g) {
          const x = o(u, d, f, m, p, g);
          f.transmission > 0
            ? n.push(x)
            : f.transparent === !0
            ? i.push(x)
            : t.push(x);
        }
        function l(u, d, f, m, p, g) {
          const x = o(u, d, f, m, p, g);
          f.transmission > 0
            ? n.unshift(x)
            : f.transparent === !0
            ? i.unshift(x)
            : t.unshift(x);
        }
        function c(u, d) {
          t.length > 1 && t.sort(u || IL),
            n.length > 1 && n.sort(d || xp),
            i.length > 1 && i.sort(d || xp);
        }
        function h() {
          for (let u = e, d = s.length; u < d; u++) {
            const f = s[u];
            if (f.id === null) break;
            (f.id = null),
              (f.object = null),
              (f.geometry = null),
              (f.material = null),
              (f.group = null);
          }
        }
        return {
          opaque: t,
          transmissive: n,
          transparent: i,
          init: r,
          push: a,
          unshift: l,
          finish: h,
          sort: c,
        };
      }
      function NL() {
        let s = new WeakMap();
        function e(n, i) {
          let r;
          return (
            s.has(n) === !1
              ? ((r = new _p()), s.set(n, [r]))
              : i >= s.get(n).length
              ? ((r = new _p()), s.get(n).push(r))
              : (r = s.get(n)[i]),
            r
          );
        }
        function t() {
          s = new WeakMap();
        }
        return { get: e, dispose: t };
      }
      function FL() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new W(), color: new Ve() };
                break;
              case "SpotLight":
                t = {
                  position: new W(),
                  direction: new W(),
                  color: new Ve(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new W(),
                  color: new Ve(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new W(),
                  skyColor: new Ve(),
                  groundColor: new Ve(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new Ve(),
                  position: new W(),
                  halfWidth: new W(),
                  halfHeight: new W(),
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      function BL() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new ye(),
                };
                break;
              case "SpotLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new ye(),
                };
                break;
              case "PointLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new ye(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      let zL = 0;
      function OL(s, e) {
        return (e.castShadow ? 1 : 0) - (s.castShadow ? 1 : 0);
      }
      function UL(s, e) {
        const t = new FL(),
          n = BL(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let h = 0; h < 9; h++) i.probe.push(new W());
        const r = new W(),
          o = new We(),
          a = new We();
        function l(h, u) {
          let d = 0,
            f = 0,
            m = 0;
          for (let K = 0; K < 9; K++) i.probe[K].set(0, 0, 0);
          let p = 0,
            g = 0,
            x = 0,
            _ = 0,
            M = 0,
            S = 0,
            v = 0,
            y = 0;
          h.sort(OL);
          const C = u !== !0 ? Math.PI : 1;
          for (let K = 0, X = h.length; K < X; K++) {
            const b = h[K],
              D = b.color,
              I = b.intensity,
              L = b.distance,
              B = b.shadow && b.shadow.map ? b.shadow.map.texture : null;
            if (b.isAmbientLight)
              (d += D.r * I * C), (f += D.g * I * C), (m += D.b * I * C);
            else if (b.isLightProbe)
              for (let R = 0; R < 9; R++)
                i.probe[R].addScaledVector(b.sh.coefficients[R], I);
            else if (b.isDirectionalLight) {
              const R = t.get(b);
              if (
                (R.color.copy(b.color).multiplyScalar(b.intensity * C),
                b.castShadow)
              ) {
                const V = b.shadow,
                  H = n.get(b);
                (H.shadowBias = V.bias),
                  (H.shadowNormalBias = V.normalBias),
                  (H.shadowRadius = V.radius),
                  (H.shadowMapSize = V.mapSize),
                  (i.directionalShadow[p] = H),
                  (i.directionalShadowMap[p] = B),
                  (i.directionalShadowMatrix[p] = b.shadow.matrix),
                  S++;
              }
              (i.directional[p] = R), p++;
            } else if (b.isSpotLight) {
              const R = t.get(b);
              if (
                (R.position.setFromMatrixPosition(b.matrixWorld),
                R.color.copy(D).multiplyScalar(I * C),
                (R.distance = L),
                (R.coneCos = Math.cos(b.angle)),
                (R.penumbraCos = Math.cos(b.angle * (1 - b.penumbra))),
                (R.decay = b.decay),
                b.castShadow)
              ) {
                const V = b.shadow,
                  H = n.get(b);
                (H.shadowBias = V.bias),
                  (H.shadowNormalBias = V.normalBias),
                  (H.shadowRadius = V.radius),
                  (H.shadowMapSize = V.mapSize),
                  (i.spotShadow[x] = H),
                  (i.spotShadowMap[x] = B),
                  (i.spotShadowMatrix[x] = b.shadow.matrix),
                  y++;
              }
              (i.spot[x] = R), x++;
            } else if (b.isRectAreaLight) {
              const R = t.get(b);
              R.color.copy(D).multiplyScalar(I),
                R.halfWidth.set(b.width * 0.5, 0, 0),
                R.halfHeight.set(0, b.height * 0.5, 0),
                (i.rectArea[_] = R),
                _++;
            } else if (b.isPointLight) {
              const R = t.get(b);
              if (
                (R.color.copy(b.color).multiplyScalar(b.intensity * C),
                (R.distance = b.distance),
                (R.decay = b.decay),
                b.castShadow)
              ) {
                const V = b.shadow,
                  H = n.get(b);
                (H.shadowBias = V.bias),
                  (H.shadowNormalBias = V.normalBias),
                  (H.shadowRadius = V.radius),
                  (H.shadowMapSize = V.mapSize),
                  (H.shadowCameraNear = V.camera.near),
                  (H.shadowCameraFar = V.camera.far),
                  (i.pointShadow[g] = H),
                  (i.pointShadowMap[g] = B),
                  (i.pointShadowMatrix[g] = b.shadow.matrix),
                  v++;
              }
              (i.point[g] = R), g++;
            } else if (b.isHemisphereLight) {
              const R = t.get(b);
              R.skyColor.copy(b.color).multiplyScalar(I * C),
                R.groundColor.copy(b.groundColor).multiplyScalar(I * C),
                (i.hemi[M] = R),
                M++;
            }
          }
          _ > 0 &&
            (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = De.LTC_FLOAT_1),
                (i.rectAreaLTC2 = De.LTC_FLOAT_2))
              : s.has("OES_texture_half_float_linear") === !0
              ? ((i.rectAreaLTC1 = De.LTC_HALF_1),
                (i.rectAreaLTC2 = De.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = d),
            (i.ambient[1] = f),
            (i.ambient[2] = m);
          const U = i.hash;
          (U.directionalLength !== p ||
            U.pointLength !== g ||
            U.spotLength !== x ||
            U.rectAreaLength !== _ ||
            U.hemiLength !== M ||
            U.numDirectionalShadows !== S ||
            U.numPointShadows !== v ||
            U.numSpotShadows !== y) &&
            ((i.directional.length = p),
            (i.spot.length = x),
            (i.rectArea.length = _),
            (i.point.length = g),
            (i.hemi.length = M),
            (i.directionalShadow.length = S),
            (i.directionalShadowMap.length = S),
            (i.pointShadow.length = v),
            (i.pointShadowMap.length = v),
            (i.spotShadow.length = y),
            (i.spotShadowMap.length = y),
            (i.directionalShadowMatrix.length = S),
            (i.pointShadowMatrix.length = v),
            (i.spotShadowMatrix.length = y),
            (U.directionalLength = p),
            (U.pointLength = g),
            (U.spotLength = x),
            (U.rectAreaLength = _),
            (U.hemiLength = M),
            (U.numDirectionalShadows = S),
            (U.numPointShadows = v),
            (U.numSpotShadows = y),
            (i.version = zL++));
        }
        function c(h, u) {
          let d = 0,
            f = 0,
            m = 0,
            p = 0,
            g = 0;
          const x = u.matrixWorldInverse;
          for (let _ = 0, M = h.length; _ < M; _++) {
            const S = h[_];
            if (S.isDirectionalLight) {
              const v = i.directional[d];
              v.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                v.direction.sub(r),
                v.direction.transformDirection(x),
                d++;
            } else if (S.isSpotLight) {
              const v = i.spot[m];
              v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(x),
                v.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                v.direction.sub(r),
                v.direction.transformDirection(x),
                m++;
            } else if (S.isRectAreaLight) {
              const v = i.rectArea[p];
              v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(x),
                a.identity(),
                o.copy(S.matrixWorld),
                o.premultiply(x),
                a.extractRotation(o),
                v.halfWidth.set(S.width * 0.5, 0, 0),
                v.halfHeight.set(0, S.height * 0.5, 0),
                v.halfWidth.applyMatrix4(a),
                v.halfHeight.applyMatrix4(a),
                p++;
            } else if (S.isPointLight) {
              const v = i.point[f];
              v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(x),
                f++;
            } else if (S.isHemisphereLight) {
              const v = i.hemi[g];
              v.direction.setFromMatrixPosition(S.matrixWorld),
                v.direction.transformDirection(x),
                v.direction.normalize(),
                g++;
            }
          }
        }
        return { setup: l, setupView: c, state: i };
      }
      function vp(s, e) {
        const t = new UL(s, e),
          n = [],
          i = [];
        function r() {
          (n.length = 0), (i.length = 0);
        }
        function o(u) {
          n.push(u);
        }
        function a(u) {
          i.push(u);
        }
        function l(u) {
          t.setup(n, u);
        }
        function c(u) {
          t.setupView(n, u);
        }
        return {
          init: r,
          state: { lightsArray: n, shadowsArray: i, lights: t },
          setupLights: l,
          setupLightsView: c,
          pushLight: o,
          pushShadow: a,
        };
      }
      function HL(s, e) {
        let t = new WeakMap();
        function n(r, o = 0) {
          let a;
          return (
            t.has(r) === !1
              ? ((a = new vp(s, e)), t.set(r, [a]))
              : o >= t.get(r).length
              ? ((a = new vp(s, e)), t.get(r).push(a))
              : (a = t.get(r)[o]),
            a
          );
        }
        function i() {
          t = new WeakMap();
        }
        return { get: n, dispose: i };
      }
      class wu extends Tt {
        constructor(e) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = s1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      wu.prototype.isMeshDepthMaterial = !0;
      class Su extends Tt {
        constructor(e) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new W()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      Su.prototype.isMeshDistanceMaterial = !0;
      const GL = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        VL = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function gg(s, e, t) {
        let n = new Fl();
        const i = new ye(),
          r = new ye(),
          o = new st(),
          a = new wu({ depthPacking: o1 }),
          l = new Su(),
          c = {},
          h = t.maxTextureSize,
          u = { 0: Nn, 1: Fo, 2: ps },
          d = new Fn({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new ye() },
              radius: { value: 4 },
            },
            vertexShader: GL,
            fragmentShader: VL,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const m = new pt();
        m.setAttribute(
          "position",
          new St(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const p = new on(m, d),
          g = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = jm),
          (this.render = function (S, v, y) {
            if (
              g.enabled === !1 ||
              (g.autoUpdate === !1 && g.needsUpdate === !1) ||
              S.length === 0
            )
              return;
            const C = s.getRenderTarget(),
              U = s.getActiveCubeFace(),
              K = s.getActiveMipmapLevel(),
              X = s.state;
            X.setBlending(zi),
              X.buffers.color.setClear(1, 1, 1, 1),
              X.buffers.depth.setTest(!0),
              X.setScissorTest(!1);
            for (let b = 0, D = S.length; b < D; b++) {
              const I = S[b],
                L = I.shadow;
              if (L === void 0) {
                console.warn("THREE.WebGLShadowMap:", I, "has no shadow.");
                continue;
              }
              if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
              i.copy(L.mapSize);
              const B = L.getFrameExtents();
              if (
                (i.multiply(B),
                r.copy(L.mapSize),
                (i.x > h || i.y > h) &&
                  (i.x > h &&
                    ((r.x = Math.floor(h / B.x)),
                    (i.x = r.x * B.x),
                    (L.mapSize.x = r.x)),
                  i.y > h &&
                    ((r.y = Math.floor(h / B.y)),
                    (i.y = r.y * B.y),
                    (L.mapSize.y = r.y))),
                L.map === null &&
                  !L.isPointLightShadow &&
                  this.type === ho &&
                  ((L.map = new fn(i.x, i.y)),
                  (L.map.texture.name = I.name + ".shadowMap"),
                  (L.mapPass = new fn(i.x, i.y)),
                  L.camera.updateProjectionMatrix()),
                L.map === null)
              ) {
                const V = { minFilter: Ct, magFilter: Ct, format: Dn };
                (L.map = new fn(i.x, i.y, V)),
                  (L.map.texture.name = I.name + ".shadowMap"),
                  L.camera.updateProjectionMatrix();
              }
              s.setRenderTarget(L.map), s.clear();
              const R = L.getViewportCount();
              for (let V = 0; V < R; V++) {
                const H = L.getViewport(V);
                o.set(r.x * H.x, r.y * H.y, r.x * H.z, r.y * H.w),
                  X.viewport(o),
                  L.updateMatrices(I, V),
                  (n = L.getFrustum()),
                  M(v, y, L.camera, I, this.type);
              }
              !L.isPointLightShadow && this.type === ho && x(L, y),
                (L.needsUpdate = !1);
            }
            (g.needsUpdate = !1), s.setRenderTarget(C, U, K);
          });
        function x(S, v) {
          const y = e.update(p);
          d.defines.VSM_SAMPLES !== S.blurSamples &&
            ((d.defines.VSM_SAMPLES = S.blurSamples),
            (f.defines.VSM_SAMPLES = S.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            (d.uniforms.shadow_pass.value = S.map.texture),
            (d.uniforms.resolution.value = S.mapSize),
            (d.uniforms.radius.value = S.radius),
            s.setRenderTarget(S.mapPass),
            s.clear(),
            s.renderBufferDirect(v, null, y, d, p, null),
            (f.uniforms.shadow_pass.value = S.mapPass.texture),
            (f.uniforms.resolution.value = S.mapSize),
            (f.uniforms.radius.value = S.radius),
            s.setRenderTarget(S.map),
            s.clear(),
            s.renderBufferDirect(v, null, y, f, p, null);
        }
        function _(S, v, y, C, U, K) {
          let X = null;
          const b =
            y.isPointLight === !0
              ? S.customDistanceMaterial
              : S.customDepthMaterial;
          if (
            (b !== void 0 ? (X = b) : (X = y.isPointLight === !0 ? l : a),
            (s.localClippingEnabled &&
              v.clipShadows === !0 &&
              v.clippingPlanes.length !== 0) ||
              (v.displacementMap && v.displacementScale !== 0) ||
              (v.alphaMap && v.alphaTest > 0))
          ) {
            const D = X.uuid,
              I = v.uuid;
            let L = c[D];
            L === void 0 && ((L = {}), (c[D] = L));
            let B = L[I];
            B === void 0 && ((B = X.clone()), (L[I] = B)), (X = B);
          }
          return (
            (X.visible = v.visible),
            (X.wireframe = v.wireframe),
            K === ho
              ? (X.side = v.shadowSide !== null ? v.shadowSide : v.side)
              : (X.side = v.shadowSide !== null ? v.shadowSide : u[v.side]),
            (X.alphaMap = v.alphaMap),
            (X.alphaTest = v.alphaTest),
            (X.clipShadows = v.clipShadows),
            (X.clippingPlanes = v.clippingPlanes),
            (X.clipIntersection = v.clipIntersection),
            (X.displacementMap = v.displacementMap),
            (X.displacementScale = v.displacementScale),
            (X.displacementBias = v.displacementBias),
            (X.wireframeLinewidth = v.wireframeLinewidth),
            (X.linewidth = v.linewidth),
            y.isPointLight === !0 &&
              X.isMeshDistanceMaterial === !0 &&
              (X.referencePosition.setFromMatrixPosition(y.matrixWorld),
              (X.nearDistance = C),
              (X.farDistance = U)),
            X
          );
        }
        function M(S, v, y, C, U) {
          if (S.visible === !1) return;
          if (
            S.layers.test(v.layers) &&
            (S.isMesh || S.isLine || S.isPoints) &&
            (S.castShadow || (S.receiveShadow && U === ho)) &&
            (!S.frustumCulled || n.intersectsObject(S))
          ) {
            S.modelViewMatrix.multiplyMatrices(
              y.matrixWorldInverse,
              S.matrixWorld
            );
            const b = e.update(S),
              D = S.material;
            if (Array.isArray(D)) {
              const I = b.groups;
              for (let L = 0, B = I.length; L < B; L++) {
                const R = I[L],
                  V = D[R.materialIndex];
                if (V && V.visible) {
                  const H = _(S, V, C, y.near, y.far, U);
                  s.renderBufferDirect(y, null, b, H, S, R);
                }
              }
            } else if (D.visible) {
              const I = _(S, D, C, y.near, y.far, U);
              s.renderBufferDirect(y, null, b, I, S, null);
            }
          }
          const X = S.children;
          for (let b = 0, D = X.length; b < D; b++) M(X[b], v, y, C, U);
        }
      }
      function kL(s, e, t) {
        const n = t.isWebGL2;
        function i() {
          let Y = !1;
          const _e = new st();
          let we = null;
          const Be = new st(0, 0, 0, 0);
          return {
            setMask: function (Ne) {
              we !== Ne && !Y && (s.colorMask(Ne, Ne, Ne, Ne), (we = Ne));
            },
            setLocked: function (Ne) {
              Y = Ne;
            },
            setClear: function (Ne, He, Le, qe, it) {
              it === !0 && ((Ne *= qe), (He *= qe), (Le *= qe)),
                _e.set(Ne, He, Le, qe),
                Be.equals(_e) === !1 &&
                  (s.clearColor(Ne, He, Le, qe), Be.copy(_e));
            },
            reset: function () {
              (Y = !1), (we = null), Be.set(-1, 0, 0, 0);
            },
          };
        }
        function r() {
          let Y = !1,
            _e = null,
            we = null,
            Be = null;
          return {
            setTest: function (Ne) {
              Ne ? Ee(2929) : $(2929);
            },
            setMask: function (Ne) {
              _e !== Ne && !Y && (s.depthMask(Ne), (_e = Ne));
            },
            setFunc: function (Ne) {
              if (we !== Ne) {
                if (Ne)
                  switch (Ne) {
                    case TS:
                      s.depthFunc(512);
                      break;
                    case ES:
                      s.depthFunc(519);
                      break;
                    case AS:
                      s.depthFunc(513);
                      break;
                    case Ah:
                      s.depthFunc(515);
                      break;
                    case LS:
                      s.depthFunc(514);
                      break;
                    case RS:
                      s.depthFunc(518);
                      break;
                    case CS:
                      s.depthFunc(516);
                      break;
                    case PS:
                      s.depthFunc(517);
                      break;
                    default:
                      s.depthFunc(515);
                  }
                else s.depthFunc(515);
                we = Ne;
              }
            },
            setLocked: function (Ne) {
              Y = Ne;
            },
            setClear: function (Ne) {
              Be !== Ne && (s.clearDepth(Ne), (Be = Ne));
            },
            reset: function () {
              (Y = !1), (_e = null), (we = null), (Be = null);
            },
          };
        }
        function o() {
          let Y = !1,
            _e = null,
            we = null,
            Be = null,
            Ne = null,
            He = null,
            Le = null,
            qe = null,
            it = null;
          return {
            setTest: function (Xe) {
              Y || (Xe ? Ee(2960) : $(2960));
            },
            setMask: function (Xe) {
              _e !== Xe && !Y && (s.stencilMask(Xe), (_e = Xe));
            },
            setFunc: function (Xe, ln, mn) {
              (we !== Xe || Be !== ln || Ne !== mn) &&
                (s.stencilFunc(Xe, ln, mn), (we = Xe), (Be = ln), (Ne = mn));
            },
            setOp: function (Xe, ln, mn) {
              (He !== Xe || Le !== ln || qe !== mn) &&
                (s.stencilOp(Xe, ln, mn), (He = Xe), (Le = ln), (qe = mn));
            },
            setLocked: function (Xe) {
              Y = Xe;
            },
            setClear: function (Xe) {
              it !== Xe && (s.clearStencil(Xe), (it = Xe));
            },
            reset: function () {
              (Y = !1),
                (_e = null),
                (we = null),
                (Be = null),
                (Ne = null),
                (He = null),
                (Le = null),
                (qe = null),
                (it = null);
            },
          };
        }
        const a = new i(),
          l = new r(),
          c = new o();
        let h = {},
          u = {},
          d = new WeakMap(),
          f = [],
          m = null,
          p = !1,
          g = null,
          x = null,
          _ = null,
          M = null,
          S = null,
          v = null,
          y = null,
          C = !1,
          U = null,
          K = null,
          X = null,
          b = null,
          D = null;
        const I = s.getParameter(35661);
        let L = !1,
          B = 0;
        const R = s.getParameter(7938);
        R.indexOf("WebGL") !== -1
          ? ((B = parseFloat(/^WebGL (\d)/.exec(R)[1])), (L = B >= 1))
          : R.indexOf("OpenGL ES") !== -1 &&
            ((B = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (L = B >= 2));
        let V = null,
          H = {};
        const J = s.getParameter(3088),
          ie = s.getParameter(2978),
          ne = new st().fromArray(J),
          ae = new st().fromArray(ie);
        function fe(Y, _e, we) {
          const Be = new Uint8Array(4),
            Ne = s.createTexture();
          s.bindTexture(Y, Ne),
            s.texParameteri(Y, 10241, 9728),
            s.texParameteri(Y, 10240, 9728);
          for (let He = 0; He < we; He++)
            s.texImage2D(_e + He, 0, 6408, 1, 1, 0, 6408, 5121, Be);
          return Ne;
        }
        const Fe = {};
        (Fe[3553] = fe(3553, 3553, 1)),
          (Fe[34067] = fe(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          Ee(2929),
          l.setFunc(Ah),
          te(!1),
          de(hf),
          Ee(2884),
          j(zi);
        function Ee(Y) {
          h[Y] !== !0 && (s.enable(Y), (h[Y] = !0));
        }
        function $(Y) {
          h[Y] !== !1 && (s.disable(Y), (h[Y] = !1));
        }
        function ke(Y, _e) {
          return u[Y] !== _e
            ? (s.bindFramebuffer(Y, _e),
              (u[Y] = _e),
              n &&
                (Y === 36009 && (u[36160] = _e),
                Y === 36160 && (u[36009] = _e)),
              !0)
            : !1;
        }
        function Re(Y, _e) {
          let we = f,
            Be = !1;
          if (Y)
            if (
              ((we = d.get(_e)),
              we === void 0 && ((we = []), d.set(_e, we)),
              Y.isWebGLMultipleRenderTargets)
            ) {
              const Ne = Y.texture;
              if (we.length !== Ne.length || we[0] !== 36064) {
                for (let He = 0, Le = Ne.length; He < Le; He++)
                  we[He] = 36064 + He;
                (we.length = Ne.length), (Be = !0);
              }
            } else we[0] !== 36064 && ((we[0] = 36064), (Be = !0));
          else we[0] !== 1029 && ((we[0] = 1029), (Be = !0));
          Be &&
            (t.isWebGL2
              ? s.drawBuffers(we)
              : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(we));
        }
        function Te(Y) {
          return m !== Y ? (s.useProgram(Y), (m = Y), !0) : !1;
        }
        const ce = { [Yr]: 32774, [pS]: 32778, [mS]: 32779 };
        if (n) (ce[pf] = 32775), (ce[mf] = 32776);
        else {
          const Y = e.get("EXT_blend_minmax");
          Y !== null && ((ce[pf] = Y.MIN_EXT), (ce[mf] = Y.MAX_EXT));
        }
        const Ie = {
          [gS]: 0,
          [xS]: 1,
          [_S]: 768,
          [Jm]: 770,
          [SS]: 776,
          [bS]: 774,
          [yS]: 772,
          [vS]: 769,
          [Km]: 771,
          [wS]: 775,
          [MS]: 773,
        };
        function j(Y, _e, we, Be, Ne, He, Le, qe) {
          if (Y === zi) {
            p === !0 && ($(3042), (p = !1));
            return;
          }
          if ((p === !1 && (Ee(3042), (p = !0)), Y !== fS)) {
            if (Y !== g || qe !== C) {
              if (
                ((x !== Yr || S !== Yr) &&
                  (s.blendEquation(32774), (x = Yr), (S = Yr)),
                qe)
              )
                switch (Y) {
                  case ss:
                    s.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case uf:
                    s.blendFunc(1, 1);
                    break;
                  case df:
                    s.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case ff:
                    s.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", Y);
                    break;
                }
              else
                switch (Y) {
                  case ss:
                    s.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case uf:
                    s.blendFunc(770, 1);
                    break;
                  case df:
                    s.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case ff:
                    s.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", Y);
                    break;
                }
              (_ = null), (M = null), (v = null), (y = null), (g = Y), (C = qe);
            }
            return;
          }
          (Ne = Ne || _e),
            (He = He || we),
            (Le = Le || Be),
            (_e !== x || Ne !== S) &&
              (s.blendEquationSeparate(ce[_e], ce[Ne]), (x = _e), (S = Ne)),
            (we !== _ || Be !== M || He !== v || Le !== y) &&
              (s.blendFuncSeparate(Ie[we], Ie[Be], Ie[He], Ie[Le]),
              (_ = we),
              (M = Be),
              (v = He),
              (y = Le)),
            (g = Y),
            (C = null);
        }
        function Z(Y, _e) {
          Y.side === ps ? $(2884) : Ee(2884);
          let we = Y.side === Nn;
          _e && (we = !we),
            te(we),
            Y.blending === ss && Y.transparent === !1
              ? j(zi)
              : j(
                  Y.blending,
                  Y.blendEquation,
                  Y.blendSrc,
                  Y.blendDst,
                  Y.blendEquationAlpha,
                  Y.blendSrcAlpha,
                  Y.blendDstAlpha,
                  Y.premultipliedAlpha
                ),
            l.setFunc(Y.depthFunc),
            l.setTest(Y.depthTest),
            l.setMask(Y.depthWrite),
            a.setMask(Y.colorWrite);
          const Be = Y.stencilWrite;
          c.setTest(Be),
            Be &&
              (c.setMask(Y.stencilWriteMask),
              c.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask),
              c.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)),
            N(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits),
            Y.alphaToCoverage === !0 ? Ee(32926) : $(32926);
        }
        function te(Y) {
          U !== Y && (Y ? s.frontFace(2304) : s.frontFace(2305), (U = Y));
        }
        function de(Y) {
          Y !== uS
            ? (Ee(2884),
              Y !== K &&
                (Y === hf
                  ? s.cullFace(1029)
                  : Y === dS
                  ? s.cullFace(1028)
                  : s.cullFace(1032)))
            : $(2884),
            (K = Y);
        }
        function se(Y) {
          Y !== X && (L && s.lineWidth(Y), (X = Y));
        }
        function N(Y, _e, we) {
          Y
            ? (Ee(32823),
              (b !== _e || D !== we) &&
                (s.polygonOffset(_e, we), (b = _e), (D = we)))
            : $(32823);
        }
        function E(Y) {
          Y ? Ee(3089) : $(3089);
        }
        function ee(Y) {
          Y === void 0 && (Y = 33984 + I - 1),
            V !== Y && (s.activeTexture(Y), (V = Y));
        }
        function ue(Y, _e) {
          V === null && ee();
          let we = H[V];
          we === void 0 &&
            ((we = { type: void 0, texture: void 0 }), (H[V] = we)),
            (we.type !== Y || we.texture !== _e) &&
              (s.bindTexture(Y, _e || Fe[Y]), (we.type = Y), (we.texture = _e));
        }
        function me() {
          const Y = H[V];
          Y !== void 0 &&
            Y.type !== void 0 &&
            (s.bindTexture(Y.type, null),
            (Y.type = void 0),
            (Y.texture = void 0));
        }
        function A() {
          try {
            s.compressedTexImage2D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function T() {
          try {
            s.texSubImage2D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function Q() {
          try {
            s.texSubImage3D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function oe() {
          try {
            s.compressedTexSubImage2D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function he() {
          try {
            s.texStorage2D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function O() {
          try {
            s.texStorage3D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function le() {
          try {
            s.texImage2D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function k() {
          try {
            s.texImage3D.apply(s, arguments);
          } catch (Y) {
            console.error("THREE.WebGLState:", Y);
          }
        }
        function ge(Y) {
          ne.equals(Y) === !1 && (s.scissor(Y.x, Y.y, Y.z, Y.w), ne.copy(Y));
        }
        function pe(Y) {
          ae.equals(Y) === !1 && (s.viewport(Y.x, Y.y, Y.z, Y.w), ae.copy(Y));
        }
        function be() {
          s.disable(3042),
            s.disable(2884),
            s.disable(2929),
            s.disable(32823),
            s.disable(3089),
            s.disable(2960),
            s.disable(32926),
            s.blendEquation(32774),
            s.blendFunc(1, 0),
            s.blendFuncSeparate(1, 0, 1, 0),
            s.colorMask(!0, !0, !0, !0),
            s.clearColor(0, 0, 0, 0),
            s.depthMask(!0),
            s.depthFunc(513),
            s.clearDepth(1),
            s.stencilMask(4294967295),
            s.stencilFunc(519, 0, 4294967295),
            s.stencilOp(7680, 7680, 7680),
            s.clearStencil(0),
            s.cullFace(1029),
            s.frontFace(2305),
            s.polygonOffset(0, 0),
            s.activeTexture(33984),
            s.bindFramebuffer(36160, null),
            n === !0 &&
              (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)),
            s.useProgram(null),
            s.lineWidth(1),
            s.scissor(0, 0, s.canvas.width, s.canvas.height),
            s.viewport(0, 0, s.canvas.width, s.canvas.height),
            (h = {}),
            (V = null),
            (H = {}),
            (u = {}),
            (d = new WeakMap()),
            (f = []),
            (m = null),
            (p = !1),
            (g = null),
            (x = null),
            (_ = null),
            (M = null),
            (S = null),
            (v = null),
            (y = null),
            (C = !1),
            (U = null),
            (K = null),
            (X = null),
            (b = null),
            (D = null),
            ne.set(0, 0, s.canvas.width, s.canvas.height),
            ae.set(0, 0, s.canvas.width, s.canvas.height),
            a.reset(),
            l.reset(),
            c.reset();
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: Ee,
          disable: $,
          bindFramebuffer: ke,
          drawBuffers: Re,
          useProgram: Te,
          setBlending: j,
          setMaterial: Z,
          setFlipSided: te,
          setCullFace: de,
          setLineWidth: se,
          setPolygonOffset: N,
          setScissorTest: E,
          activeTexture: ee,
          bindTexture: ue,
          unbindTexture: me,
          compressedTexImage2D: A,
          texImage2D: le,
          texImage3D: k,
          texStorage2D: he,
          texStorage3D: O,
          texSubImage2D: T,
          texSubImage3D: Q,
          compressedTexSubImage2D: oe,
          scissor: ge,
          viewport: pe,
          reset: be,
        };
      }
      function WL(s, e, t, n, i, r, o) {
        const a = i.isWebGL2,
          l = i.maxTextures,
          c = i.maxCubemapSize,
          h = i.maxTextureSize,
          u = i.maxSamples,
          d = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : null,
          f = /OculusBrowser/g.test(navigator.userAgent),
          m = new WeakMap();
        let p;
        const g = new WeakMap();
        let x = !1;
        try {
          x =
            typeof OffscreenCanvas != "undefined" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function _(A, T) {
          return x ? new OffscreenCanvas(A, T) : Oo("canvas");
        }
        function M(A, T, Q, oe) {
          let he = 1;
          if (
            ((A.width > oe || A.height > oe) &&
              (he = oe / Math.max(A.width, A.height)),
            he < 1 || T === !0)
          )
            if (
              (typeof HTMLImageElement != "undefined" &&
                A instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement != "undefined" &&
                A instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap != "undefined" && A instanceof ImageBitmap)
            ) {
              const O = T ? Nh : Math.floor,
                le = O(he * A.width),
                k = O(he * A.height);
              p === void 0 && (p = _(le, k));
              const ge = Q ? _(le, k) : p;
              return (
                (ge.width = le),
                (ge.height = k),
                ge.getContext("2d").drawImage(A, 0, 0, le, k),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    A.width +
                    "x" +
                    A.height +
                    ") to (" +
                    le +
                    "x" +
                    k +
                    ")."
                ),
                ge
              );
            } else
              return (
                "data" in A &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      A.width +
                      "x" +
                      A.height +
                      ")."
                  ),
                A
              );
          return A;
        }
        function S(A) {
          return Hf(A.width) && Hf(A.height);
        }
        function v(A) {
          return a
            ? !1
            : A.wrapS !== Pn ||
                A.wrapT !== Pn ||
                (A.minFilter !== Ct && A.minFilter !== nn);
        }
        function y(A, T) {
          return (
            A.generateMipmaps && T && A.minFilter !== Ct && A.minFilter !== nn
          );
        }
        function C(A) {
          s.generateMipmap(A);
        }
        function U(A, T, Q, oe, he = !1) {
          if (a === !1) return T;
          if (A !== null) {
            if (s[A] !== void 0) return s[A];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                A +
                "'"
            );
          }
          let O = T;
          return (
            T === 6403 &&
              (Q === 5126 && (O = 33326),
              Q === 5131 && (O = 33325),
              Q === 5121 && (O = 33321)),
            T === 33319 &&
              (Q === 5126 && (O = 33328),
              Q === 5131 && (O = 33327),
              Q === 5121 && (O = 33323)),
            T === 6408 &&
              (Q === 5126 && (O = 34836),
              Q === 5131 && (O = 34842),
              Q === 5121 && (O = oe === ht && he === !1 ? 35907 : 32856),
              Q === 32819 && (O = 32854),
              Q === 32820 && (O = 32855)),
            (O === 33325 ||
              O === 33326 ||
              O === 33327 ||
              O === 33328 ||
              O === 34842 ||
              O === 34836) &&
              e.get("EXT_color_buffer_float"),
            O
          );
        }
        function K(A, T, Q) {
          return y(A, Q) === !0 ||
            (A.isFramebufferTexture && A.minFilter !== Ct && A.minFilter !== nn)
            ? Math.log2(Math.max(T.width, T.height)) + 1
            : A.mipmaps !== void 0 && A.mipmaps.length > 0
            ? A.mipmaps.length
            : A.isCompressedTexture && Array.isArray(A.image)
            ? T.mipmaps.length
            : 1;
        }
        function X(A) {
          return A === Ct || A === gf || A === xf ? 9728 : 9729;
        }
        function b(A) {
          const T = A.target;
          T.removeEventListener("dispose", b),
            I(T),
            T.isVideoTexture && m.delete(T);
        }
        function D(A) {
          const T = A.target;
          T.removeEventListener("dispose", D), B(T);
        }
        function I(A) {
          const T = n.get(A);
          if (T.__webglInit === void 0) return;
          const Q = A.source,
            oe = g.get(Q);
          if (oe) {
            const he = oe[T.__cacheKey];
            he.usedTimes--,
              he.usedTimes === 0 && L(A),
              Object.keys(oe).length === 0 && g.delete(Q);
          }
          n.remove(A);
        }
        function L(A) {
          const T = n.get(A);
          s.deleteTexture(T.__webglTexture);
          const Q = A.source,
            oe = g.get(Q);
          delete oe[T.__cacheKey], o.memory.textures--;
        }
        function B(A) {
          const T = A.texture,
            Q = n.get(A),
            oe = n.get(T);
          if (
            (oe.__webglTexture !== void 0 &&
              (s.deleteTexture(oe.__webglTexture), o.memory.textures--),
            A.depthTexture && A.depthTexture.dispose(),
            A.isWebGLCubeRenderTarget)
          )
            for (let he = 0; he < 6; he++)
              s.deleteFramebuffer(Q.__webglFramebuffer[he]),
                Q.__webglDepthbuffer &&
                  s.deleteRenderbuffer(Q.__webglDepthbuffer[he]);
          else
            s.deleteFramebuffer(Q.__webglFramebuffer),
              Q.__webglDepthbuffer &&
                s.deleteRenderbuffer(Q.__webglDepthbuffer),
              Q.__webglMultisampledFramebuffer &&
                s.deleteFramebuffer(Q.__webglMultisampledFramebuffer),
              Q.__webglColorRenderbuffer &&
                s.deleteRenderbuffer(Q.__webglColorRenderbuffer),
              Q.__webglDepthRenderbuffer &&
                s.deleteRenderbuffer(Q.__webglDepthRenderbuffer);
          if (A.isWebGLMultipleRenderTargets)
            for (let he = 0, O = T.length; he < O; he++) {
              const le = n.get(T[he]);
              le.__webglTexture &&
                (s.deleteTexture(le.__webglTexture), o.memory.textures--),
                n.remove(T[he]);
            }
          n.remove(T), n.remove(A);
        }
        let R = 0;
        function V() {
          R = 0;
        }
        function H() {
          const A = R;
          return (
            A >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  A +
                  " texture units while this GPU supports only " +
                  l
              ),
            (R += 1),
            A
          );
        }
        function J(A) {
          const T = [];
          return (
            T.push(A.wrapS),
            T.push(A.wrapT),
            T.push(A.magFilter),
            T.push(A.minFilter),
            T.push(A.anisotropy),
            T.push(A.internalFormat),
            T.push(A.format),
            T.push(A.type),
            T.push(A.generateMipmaps),
            T.push(A.premultiplyAlpha),
            T.push(A.flipY),
            T.push(A.unpackAlignment),
            T.push(A.encoding),
            T.join()
          );
        }
        function ie(A, T) {
          const Q = n.get(A);
          if (
            (A.isVideoTexture && ue(A),
            A.isRenderTargetTexture === !1 &&
              A.version > 0 &&
              Q.__version !== A.version)
          ) {
            const oe = A.image;
            if (oe === null)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else if (oe.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              Re(Q, A, T);
              return;
            }
          }
          t.activeTexture(33984 + T), t.bindTexture(3553, Q.__webglTexture);
        }
        function ne(A, T) {
          const Q = n.get(A);
          if (A.version > 0 && Q.__version !== A.version) {
            Re(Q, A, T);
            return;
          }
          t.activeTexture(33984 + T), t.bindTexture(35866, Q.__webglTexture);
        }
        function ae(A, T) {
          const Q = n.get(A);
          if (A.version > 0 && Q.__version !== A.version) {
            Re(Q, A, T);
            return;
          }
          t.activeTexture(33984 + T), t.bindTexture(32879, Q.__webglTexture);
        }
        function fe(A, T) {
          const Q = n.get(A);
          if (A.version > 0 && Q.__version !== A.version) {
            Te(Q, A, T);
            return;
          }
          t.activeTexture(33984 + T), t.bindTexture(34067, Q.__webglTexture);
        }
        const Fe = { [Ch]: 10497, [Pn]: 33071, [Ph]: 33648 },
          Ee = {
            [Ct]: 9728,
            [gf]: 9984,
            [xf]: 9986,
            [nn]: 9729,
            [US]: 9985,
            [Pl]: 9987,
          };
        function $(A, T, Q) {
          if (
            (Q
              ? (s.texParameteri(A, 10242, Fe[T.wrapS]),
                s.texParameteri(A, 10243, Fe[T.wrapT]),
                (A === 32879 || A === 35866) &&
                  s.texParameteri(A, 32882, Fe[T.wrapR]),
                s.texParameteri(A, 10240, Ee[T.magFilter]),
                s.texParameteri(A, 10241, Ee[T.minFilter]))
              : (s.texParameteri(A, 10242, 33071),
                s.texParameteri(A, 10243, 33071),
                (A === 32879 || A === 35866) &&
                  s.texParameteri(A, 32882, 33071),
                (T.wrapS !== Pn || T.wrapT !== Pn) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                s.texParameteri(A, 10240, X(T.magFilter)),
                s.texParameteri(A, 10241, X(T.minFilter)),
                T.minFilter !== Ct &&
                  T.minFilter !== nn &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            const oe = e.get("EXT_texture_filter_anisotropic");
            if (
              (T.type === Qi && e.has("OES_texture_float_linear") === !1) ||
              (a === !1 &&
                T.type === os &&
                e.has("OES_texture_half_float_linear") === !1)
            )
              return;
            (T.anisotropy > 1 || n.get(T).__currentAnisotropy) &&
              (s.texParameterf(
                A,
                oe.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(T.anisotropy, i.getMaxAnisotropy())
              ),
              (n.get(T).__currentAnisotropy = T.anisotropy));
          }
        }
        function ke(A, T) {
          let Q = !1;
          A.__webglInit === void 0 &&
            ((A.__webglInit = !0), T.addEventListener("dispose", b));
          const oe = T.source;
          let he = g.get(oe);
          he === void 0 && ((he = {}), g.set(oe, he));
          const O = J(T);
          if (O !== A.__cacheKey) {
            he[O] === void 0 &&
              ((he[O] = { texture: s.createTexture(), usedTimes: 0 }),
              o.memory.textures++,
              (Q = !0)),
              he[O].usedTimes++;
            const le = he[A.__cacheKey];
            le !== void 0 &&
              (he[A.__cacheKey].usedTimes--, le.usedTimes === 0 && L(T)),
              (A.__cacheKey = O),
              (A.__webglTexture = he[O].texture);
          }
          return Q;
        }
        function Re(A, T, Q) {
          let oe = 3553;
          T.isDataArrayTexture && (oe = 35866),
            T.isData3DTexture && (oe = 32879);
          const he = ke(A, T),
            O = T.source;
          if (
            (t.activeTexture(33984 + Q),
            t.bindTexture(oe, A.__webglTexture),
            O.version !== O.__currentVersion || he === !0)
          ) {
            s.pixelStorei(37440, T.flipY),
              s.pixelStorei(37441, T.premultiplyAlpha),
              s.pixelStorei(3317, T.unpackAlignment),
              s.pixelStorei(37443, 0);
            const le = v(T) && S(T.image) === !1;
            let k = M(T.image, le, !1, h);
            k = me(T, k);
            const ge = S(k) || a,
              pe = r.convert(T.format, T.encoding);
            let be = r.convert(T.type),
              Y = U(T.internalFormat, pe, be, T.encoding, T.isVideoTexture);
            $(oe, T, ge);
            let _e;
            const we = T.mipmaps,
              Be = a && T.isVideoTexture !== !0,
              Ne = A.__version === void 0,
              He = K(T, k, ge);
            if (T.isDepthTexture)
              (Y = 6402),
                a
                  ? T.type === Qi
                    ? (Y = 36012)
                    : T.type === ol
                    ? (Y = 33190)
                    : T.type === as
                    ? (Y = 35056)
                    : (Y = 33189)
                  : T.type === Qi &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                T.format === tr &&
                  Y === 6402 &&
                  T.type !== Bo &&
                  T.type !== ol &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (T.type = Bo),
                  (be = r.convert(T.type))),
                T.format === xs &&
                  Y === 6402 &&
                  ((Y = 34041),
                  T.type !== as &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (T.type = as),
                    (be = r.convert(T.type)))),
                Be && Ne
                  ? t.texStorage2D(3553, 1, Y, k.width, k.height)
                  : t.texImage2D(
                      3553,
                      0,
                      Y,
                      k.width,
                      k.height,
                      0,
                      pe,
                      be,
                      null
                    );
            else if (T.isDataTexture)
              if (we.length > 0 && ge) {
                Be &&
                  Ne &&
                  t.texStorage2D(3553, He, Y, we[0].width, we[0].height);
                for (let Le = 0, qe = we.length; Le < qe; Le++)
                  (_e = we[Le]),
                    Be
                      ? t.texSubImage2D(
                          3553,
                          Le,
                          0,
                          0,
                          _e.width,
                          _e.height,
                          pe,
                          be,
                          _e.data
                        )
                      : t.texImage2D(
                          3553,
                          Le,
                          Y,
                          _e.width,
                          _e.height,
                          0,
                          pe,
                          be,
                          _e.data
                        );
                T.generateMipmaps = !1;
              } else
                Be
                  ? (Ne && t.texStorage2D(3553, He, Y, k.width, k.height),
                    t.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      k.width,
                      k.height,
                      pe,
                      be,
                      k.data
                    ))
                  : t.texImage2D(
                      3553,
                      0,
                      Y,
                      k.width,
                      k.height,
                      0,
                      pe,
                      be,
                      k.data
                    );
            else if (T.isCompressedTexture) {
              Be &&
                Ne &&
                t.texStorage2D(3553, He, Y, we[0].width, we[0].height);
              for (let Le = 0, qe = we.length; Le < qe; Le++)
                (_e = we[Le]),
                  T.format !== Dn
                    ? pe !== null
                      ? Be
                        ? t.compressedTexSubImage2D(
                            3553,
                            Le,
                            0,
                            0,
                            _e.width,
                            _e.height,
                            pe,
                            _e.data
                          )
                        : t.compressedTexImage2D(
                            3553,
                            Le,
                            Y,
                            _e.width,
                            _e.height,
                            0,
                            _e.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : Be
                    ? t.texSubImage2D(
                        3553,
                        Le,
                        0,
                        0,
                        _e.width,
                        _e.height,
                        pe,
                        be,
                        _e.data
                      )
                    : t.texImage2D(
                        3553,
                        Le,
                        Y,
                        _e.width,
                        _e.height,
                        0,
                        pe,
                        be,
                        _e.data
                      );
            } else if (T.isDataArrayTexture)
              Be
                ? (Ne &&
                    t.texStorage3D(35866, He, Y, k.width, k.height, k.depth),
                  t.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    k.width,
                    k.height,
                    k.depth,
                    pe,
                    be,
                    k.data
                  ))
                : t.texImage3D(
                    35866,
                    0,
                    Y,
                    k.width,
                    k.height,
                    k.depth,
                    0,
                    pe,
                    be,
                    k.data
                  );
            else if (T.isData3DTexture)
              Be
                ? (Ne &&
                    t.texStorage3D(32879, He, Y, k.width, k.height, k.depth),
                  t.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    k.width,
                    k.height,
                    k.depth,
                    pe,
                    be,
                    k.data
                  ))
                : t.texImage3D(
                    32879,
                    0,
                    Y,
                    k.width,
                    k.height,
                    k.depth,
                    0,
                    pe,
                    be,
                    k.data
                  );
            else if (T.isFramebufferTexture)
              Be && Ne
                ? t.texStorage2D(3553, He, Y, k.width, k.height)
                : t.texImage2D(3553, 0, Y, k.width, k.height, 0, pe, be, null);
            else if (we.length > 0 && ge) {
              Be &&
                Ne &&
                t.texStorage2D(3553, He, Y, we[0].width, we[0].height);
              for (let Le = 0, qe = we.length; Le < qe; Le++)
                (_e = we[Le]),
                  Be
                    ? t.texSubImage2D(3553, Le, 0, 0, pe, be, _e)
                    : t.texImage2D(3553, Le, Y, pe, be, _e);
              T.generateMipmaps = !1;
            } else
              Be
                ? (Ne && t.texStorage2D(3553, He, Y, k.width, k.height),
                  t.texSubImage2D(3553, 0, 0, 0, pe, be, k))
                : t.texImage2D(3553, 0, Y, pe, be, k);
            y(T, ge) && C(oe),
              (O.__currentVersion = O.version),
              T.onUpdate && T.onUpdate(T);
          }
          A.__version = T.version;
        }
        function Te(A, T, Q) {
          if (T.image.length !== 6) return;
          const oe = ke(A, T),
            he = T.source;
          if (
            (t.activeTexture(33984 + Q),
            t.bindTexture(34067, A.__webglTexture),
            he.version !== he.__currentVersion || oe === !0)
          ) {
            s.pixelStorei(37440, T.flipY),
              s.pixelStorei(37441, T.premultiplyAlpha),
              s.pixelStorei(3317, T.unpackAlignment),
              s.pixelStorei(37443, 0);
            const O = T.isCompressedTexture || T.image[0].isCompressedTexture,
              le = T.image[0] && T.image[0].isDataTexture,
              k = [];
            for (let Le = 0; Le < 6; Le++)
              !O && !le
                ? (k[Le] = M(T.image[Le], !1, !0, c))
                : (k[Le] = le ? T.image[Le].image : T.image[Le]),
                (k[Le] = me(T, k[Le]));
            const ge = k[0],
              pe = S(ge) || a,
              be = r.convert(T.format, T.encoding),
              Y = r.convert(T.type),
              _e = U(T.internalFormat, be, Y, T.encoding),
              we = a && T.isVideoTexture !== !0,
              Be = A.__version === void 0;
            let Ne = K(T, ge, pe);
            $(34067, T, pe);
            let He;
            if (O) {
              we && Be && t.texStorage2D(34067, Ne, _e, ge.width, ge.height);
              for (let Le = 0; Le < 6; Le++) {
                He = k[Le].mipmaps;
                for (let qe = 0; qe < He.length; qe++) {
                  const it = He[qe];
                  T.format !== Dn
                    ? be !== null
                      ? we
                        ? t.compressedTexSubImage2D(
                            34069 + Le,
                            qe,
                            0,
                            0,
                            it.width,
                            it.height,
                            be,
                            it.data
                          )
                        : t.compressedTexImage2D(
                            34069 + Le,
                            qe,
                            _e,
                            it.width,
                            it.height,
                            0,
                            it.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : we
                    ? t.texSubImage2D(
                        34069 + Le,
                        qe,
                        0,
                        0,
                        it.width,
                        it.height,
                        be,
                        Y,
                        it.data
                      )
                    : t.texImage2D(
                        34069 + Le,
                        qe,
                        _e,
                        it.width,
                        it.height,
                        0,
                        be,
                        Y,
                        it.data
                      );
                }
              }
            } else {
              (He = T.mipmaps),
                we &&
                  Be &&
                  (He.length > 0 && Ne++,
                  t.texStorage2D(34067, Ne, _e, k[0].width, k[0].height));
              for (let Le = 0; Le < 6; Le++)
                if (le) {
                  we
                    ? t.texSubImage2D(
                        34069 + Le,
                        0,
                        0,
                        0,
                        k[Le].width,
                        k[Le].height,
                        be,
                        Y,
                        k[Le].data
                      )
                    : t.texImage2D(
                        34069 + Le,
                        0,
                        _e,
                        k[Le].width,
                        k[Le].height,
                        0,
                        be,
                        Y,
                        k[Le].data
                      );
                  for (let qe = 0; qe < He.length; qe++) {
                    const Xe = He[qe].image[Le].image;
                    we
                      ? t.texSubImage2D(
                          34069 + Le,
                          qe + 1,
                          0,
                          0,
                          Xe.width,
                          Xe.height,
                          be,
                          Y,
                          Xe.data
                        )
                      : t.texImage2D(
                          34069 + Le,
                          qe + 1,
                          _e,
                          Xe.width,
                          Xe.height,
                          0,
                          be,
                          Y,
                          Xe.data
                        );
                  }
                } else {
                  we
                    ? t.texSubImage2D(34069 + Le, 0, 0, 0, be, Y, k[Le])
                    : t.texImage2D(34069 + Le, 0, _e, be, Y, k[Le]);
                  for (let qe = 0; qe < He.length; qe++) {
                    const it = He[qe];
                    we
                      ? t.texSubImage2D(
                          34069 + Le,
                          qe + 1,
                          0,
                          0,
                          be,
                          Y,
                          it.image[Le]
                        )
                      : t.texImage2D(
                          34069 + Le,
                          qe + 1,
                          _e,
                          be,
                          Y,
                          it.image[Le]
                        );
                  }
                }
            }
            y(T, pe) && C(34067),
              (he.__currentVersion = he.version),
              T.onUpdate && T.onUpdate(T);
          }
          A.__version = T.version;
        }
        function ce(A, T, Q, oe, he) {
          const O = r.convert(Q.format, Q.encoding),
            le = r.convert(Q.type),
            k = U(Q.internalFormat, O, le, Q.encoding);
          n.get(T).__hasExternalTextures ||
            (he === 32879 || he === 35866
              ? t.texImage3D(
                  he,
                  0,
                  k,
                  T.width,
                  T.height,
                  T.depth,
                  0,
                  O,
                  le,
                  null
                )
              : t.texImage2D(he, 0, k, T.width, T.height, 0, O, le, null)),
            t.bindFramebuffer(36160, A),
            ee(T)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  oe,
                  he,
                  n.get(Q).__webglTexture,
                  0,
                  E(T)
                )
              : s.framebufferTexture2D(
                  36160,
                  oe,
                  he,
                  n.get(Q).__webglTexture,
                  0
                ),
            t.bindFramebuffer(36160, null);
        }
        function Ie(A, T, Q) {
          if (
            (s.bindRenderbuffer(36161, A), T.depthBuffer && !T.stencilBuffer)
          ) {
            let oe = 33189;
            if (Q || ee(T)) {
              const he = T.depthTexture;
              he &&
                he.isDepthTexture &&
                (he.type === Qi
                  ? (oe = 36012)
                  : he.type === ol && (oe = 33190));
              const O = E(T);
              ee(T)
                ? d.renderbufferStorageMultisampleEXT(
                    36161,
                    O,
                    oe,
                    T.width,
                    T.height
                  )
                : s.renderbufferStorageMultisample(
                    36161,
                    O,
                    oe,
                    T.width,
                    T.height
                  );
            } else s.renderbufferStorage(36161, oe, T.width, T.height);
            s.framebufferRenderbuffer(36160, 36096, 36161, A);
          } else if (T.depthBuffer && T.stencilBuffer) {
            const oe = E(T);
            Q && ee(T) === !1
              ? s.renderbufferStorageMultisample(
                  36161,
                  oe,
                  35056,
                  T.width,
                  T.height
                )
              : ee(T)
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  oe,
                  35056,
                  T.width,
                  T.height
                )
              : s.renderbufferStorage(36161, 34041, T.width, T.height),
              s.framebufferRenderbuffer(36160, 33306, 36161, A);
          } else {
            const oe =
                T.isWebGLMultipleRenderTargets === !0
                  ? T.texture[0]
                  : T.texture,
              he = r.convert(oe.format, oe.encoding),
              O = r.convert(oe.type),
              le = U(oe.internalFormat, he, O, oe.encoding),
              k = E(T);
            Q && ee(T) === !1
              ? s.renderbufferStorageMultisample(
                  36161,
                  k,
                  le,
                  T.width,
                  T.height
                )
              : ee(T)
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  k,
                  le,
                  T.width,
                  T.height
                )
              : s.renderbufferStorage(36161, le, T.width, T.height);
          }
          s.bindRenderbuffer(36161, null);
        }
        function j(A, T) {
          if (T && T.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(36160, A),
            !(T.depthTexture && T.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(T.depthTexture).__webglTexture ||
            T.depthTexture.image.width !== T.width ||
            T.depthTexture.image.height !== T.height) &&
            ((T.depthTexture.image.width = T.width),
            (T.depthTexture.image.height = T.height),
            (T.depthTexture.needsUpdate = !0)),
            ie(T.depthTexture, 0);
          const oe = n.get(T.depthTexture).__webglTexture,
            he = E(T);
          if (T.depthTexture.format === tr)
            ee(T)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  36096,
                  3553,
                  oe,
                  0,
                  he
                )
              : s.framebufferTexture2D(36160, 36096, 3553, oe, 0);
          else if (T.depthTexture.format === xs)
            ee(T)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  33306,
                  3553,
                  oe,
                  0,
                  he
                )
              : s.framebufferTexture2D(36160, 33306, 3553, oe, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Z(A) {
          const T = n.get(A),
            Q = A.isWebGLCubeRenderTarget === !0;
          if (A.depthTexture && !T.__autoAllocateDepthBuffer) {
            if (Q)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            j(T.__webglFramebuffer, A);
          } else if (Q) {
            T.__webglDepthbuffer = [];
            for (let oe = 0; oe < 6; oe++)
              t.bindFramebuffer(36160, T.__webglFramebuffer[oe]),
                (T.__webglDepthbuffer[oe] = s.createRenderbuffer()),
                Ie(T.__webglDepthbuffer[oe], A, !1);
          } else
            t.bindFramebuffer(36160, T.__webglFramebuffer),
              (T.__webglDepthbuffer = s.createRenderbuffer()),
              Ie(T.__webglDepthbuffer, A, !1);
          t.bindFramebuffer(36160, null);
        }
        function te(A, T, Q) {
          const oe = n.get(A);
          T !== void 0 && ce(oe.__webglFramebuffer, A, A.texture, 36064, 3553),
            Q !== void 0 && Z(A);
        }
        function de(A) {
          const T = A.texture,
            Q = n.get(A),
            oe = n.get(T);
          A.addEventListener("dispose", D),
            A.isWebGLMultipleRenderTargets !== !0 &&
              (oe.__webglTexture === void 0 &&
                (oe.__webglTexture = s.createTexture()),
              (oe.__version = T.version),
              o.memory.textures++);
          const he = A.isWebGLCubeRenderTarget === !0,
            O = A.isWebGLMultipleRenderTargets === !0,
            le = S(A) || a;
          if (he) {
            Q.__webglFramebuffer = [];
            for (let k = 0; k < 6; k++)
              Q.__webglFramebuffer[k] = s.createFramebuffer();
          } else if (((Q.__webglFramebuffer = s.createFramebuffer()), O))
            if (i.drawBuffers) {
              const k = A.texture;
              for (let ge = 0, pe = k.length; ge < pe; ge++) {
                const be = n.get(k[ge]);
                be.__webglTexture === void 0 &&
                  ((be.__webglTexture = s.createTexture()),
                  o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (a && A.samples > 0 && ee(A) === !1) {
            (Q.__webglMultisampledFramebuffer = s.createFramebuffer()),
              (Q.__webglColorRenderbuffer = s.createRenderbuffer()),
              s.bindRenderbuffer(36161, Q.__webglColorRenderbuffer);
            const k = r.convert(T.format, T.encoding),
              ge = r.convert(T.type),
              pe = U(T.internalFormat, k, ge, T.encoding),
              be = E(A);
            s.renderbufferStorageMultisample(36161, be, pe, A.width, A.height),
              t.bindFramebuffer(36160, Q.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                36160,
                36064,
                36161,
                Q.__webglColorRenderbuffer
              ),
              s.bindRenderbuffer(36161, null),
              A.depthBuffer &&
                ((Q.__webglDepthRenderbuffer = s.createRenderbuffer()),
                Ie(Q.__webglDepthRenderbuffer, A, !0)),
              t.bindFramebuffer(36160, null);
          }
          if (he) {
            t.bindTexture(34067, oe.__webglTexture), $(34067, T, le);
            for (let k = 0; k < 6; k++)
              ce(Q.__webglFramebuffer[k], A, T, 36064, 34069 + k);
            y(T, le) && C(34067), t.unbindTexture();
          } else if (O) {
            const k = A.texture;
            for (let ge = 0, pe = k.length; ge < pe; ge++) {
              const be = k[ge],
                Y = n.get(be);
              t.bindTexture(3553, Y.__webglTexture),
                $(3553, be, le),
                ce(Q.__webglFramebuffer, A, be, 36064 + ge, 3553),
                y(be, le) && C(3553);
            }
            t.unbindTexture();
          } else {
            let k = 3553;
            (A.isWebGL3DRenderTarget || A.isWebGLArrayRenderTarget) &&
              (a
                ? (k = A.isWebGL3DRenderTarget ? 32879 : 35866)
                : console.error(
                    "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                  )),
              t.bindTexture(k, oe.__webglTexture),
              $(k, T, le),
              ce(Q.__webglFramebuffer, A, T, 36064, k),
              y(T, le) && C(k),
              t.unbindTexture();
          }
          A.depthBuffer && Z(A);
        }
        function se(A) {
          const T = S(A) || a,
            Q = A.isWebGLMultipleRenderTargets === !0 ? A.texture : [A.texture];
          for (let oe = 0, he = Q.length; oe < he; oe++) {
            const O = Q[oe];
            if (y(O, T)) {
              const le = A.isWebGLCubeRenderTarget ? 34067 : 3553,
                k = n.get(O).__webglTexture;
              t.bindTexture(le, k), C(le), t.unbindTexture();
            }
          }
        }
        function N(A) {
          if (a && A.samples > 0 && ee(A) === !1) {
            const T = A.width,
              Q = A.height;
            let oe = 16384;
            const he = [36064],
              O = A.stencilBuffer ? 33306 : 36096;
            A.depthBuffer && he.push(O);
            const le = n.get(A),
              k =
                le.__ignoreDepthValues !== void 0 ? le.__ignoreDepthValues : !1;
            k === !1 &&
              (A.depthBuffer && (oe |= 256), A.stencilBuffer && (oe |= 1024)),
              t.bindFramebuffer(36008, le.__webglMultisampledFramebuffer),
              t.bindFramebuffer(36009, le.__webglFramebuffer),
              k === !0 &&
                (s.invalidateFramebuffer(36008, [O]),
                s.invalidateFramebuffer(36009, [O])),
              s.blitFramebuffer(0, 0, T, Q, 0, 0, T, Q, oe, 9728),
              f && s.invalidateFramebuffer(36008, he),
              t.bindFramebuffer(36008, null),
              t.bindFramebuffer(36009, le.__webglMultisampledFramebuffer);
          }
        }
        function E(A) {
          return Math.min(u, A.samples);
        }
        function ee(A) {
          const T = n.get(A);
          return (
            a &&
            A.samples > 0 &&
            e.has("WEBGL_multisampled_render_to_texture") === !0 &&
            T.__useRenderToTexture !== !1
          );
        }
        function ue(A) {
          const T = o.render.frame;
          m.get(A) !== T && (m.set(A, T), A.update());
        }
        function me(A, T) {
          const Q = A.encoding,
            oe = A.format,
            he = A.type;
          return (
            A.isCompressedTexture === !0 ||
              A.isVideoTexture === !0 ||
              A.format === Dh ||
              (Q !== hi &&
                (Q === ht
                  ? a === !1
                    ? e.has("EXT_sRGB") === !0 && oe === Dn
                      ? ((A.format = Dh),
                        (A.minFilter = nn),
                        (A.generateMipmaps = !1))
                      : (T = cr.sRGBToLinear(T))
                    : (oe !== Dn || he !== rr) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      Q
                    ))),
            T
          );
        }
        (this.allocateTextureUnit = H),
          (this.resetTextureUnits = V),
          (this.setTexture2D = ie),
          (this.setTexture2DArray = ne),
          (this.setTexture3D = ae),
          (this.setTextureCube = fe),
          (this.rebindTextures = te),
          (this.setupRenderTarget = de),
          (this.updateRenderTargetMipmap = se),
          (this.updateMultisampleRenderTarget = N),
          (this.setupDepthRenderbuffer = Z),
          (this.setupFrameBufferTexture = ce),
          (this.useMultisampledRTT = ee);
      }
      function $L(s, e, t) {
        const n = t.isWebGL2;
        function i(r, o = null) {
          let a;
          if (r === rr) return 5121;
          if (r === kS) return 32819;
          if (r === WS) return 32820;
          if (r === HS) return 5120;
          if (r === GS) return 5122;
          if (r === Bo) return 5123;
          if (r === VS) return 5124;
          if (r === ol) return 5125;
          if (r === Qi) return 5126;
          if (r === os)
            return n
              ? 5131
              : ((a = e.get("OES_texture_half_float")),
                a !== null ? a.HALF_FLOAT_OES : null);
          if (r === $S) return 6406;
          if (r === Dn) return 6408;
          if (r === XS) return 6409;
          if (r === jS) return 6410;
          if (r === tr) return 6402;
          if (r === xs) return 34041;
          if (r === YS) return 6403;
          if (r === qS)
            return (
              console.warn(
                "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
              ),
              6408
            );
          if (r === Dh)
            return (
              (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null
            );
          if (r === ZS) return 36244;
          if (r === JS) return 33319;
          if (r === KS) return 33320;
          if (r === QS) return 36249;
          if (r === Tc || r === Ec || r === Ac || r === Lc)
            if (o === ht)
              if (
                ((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)
              ) {
                if (r === Tc) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (r === Ec) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (r === Ac) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (r === Lc) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else return null;
            else if (
              ((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)
            ) {
              if (r === Tc) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (r === Ec) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (r === Ac) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (r === Lc) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (r === _f || r === vf || r === yf || r === Mf)
            if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
              if (r === _f) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (r === vf) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (r === yf) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (r === Mf) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (r === e1)
            return (
              (a = e.get("WEBGL_compressed_texture_etc1")),
              a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (r === bf || r === wf)
            if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
              if (r === bf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ETC2
                  : a.COMPRESSED_RGB8_ETC2;
              if (r === wf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : a.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
          if (
            r === Sf ||
            r === Tf ||
            r === Ef ||
            r === Af ||
            r === Lf ||
            r === Rf ||
            r === Cf ||
            r === Pf ||
            r === Df ||
            r === If ||
            r === Nf ||
            r === Ff ||
            r === Bf ||
            r === zf
          )
            if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
              if (r === Sf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (r === Tf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (r === Ef)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (r === Af)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (r === Lf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (r === Rf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (r === Cf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (r === Pf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (r === Df)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (r === If)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (r === Nf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (r === Ff)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (r === Bf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (r === zf)
                return o === ht
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
          if (r === Of)
            if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
              if (r === Of)
                return o === ht
                  ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else return null;
          if (r === as)
            return n
              ? 34042
              : ((a = e.get("WEBGL_depth_texture")),
                a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null);
        }
        return { convert: i };
      }
      class xg extends Yt {
        constructor(e = []) {
          super(), (this.cameras = e);
        }
      }
      xg.prototype.isArrayCamera = !0;
      class fo extends tt {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      fo.prototype.isGroup = !0;
      const qL = { type: "move" };
      class rh {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new fo()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new fo()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new W()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new W())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new fo()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new W()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new W())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            o = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred")
            if (
              (a !== null &&
                ((i = t.getPose(e.targetRaySpace, n)),
                i !== null &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(qL))),
              c && e.hand)
            ) {
              o = !0;
              for (const p of e.hand.values()) {
                const g = t.getJointPose(p, n);
                if (c.joints[p.jointName] === void 0) {
                  const _ = new fo();
                  (_.matrixAutoUpdate = !1),
                    (_.visible = !1),
                    (c.joints[p.jointName] = _),
                    c.add(_);
                }
                const x = c.joints[p.jointName];
                g !== null &&
                  (x.matrix.fromArray(g.transform.matrix),
                  x.matrix.decompose(x.position, x.rotation, x.scale),
                  (x.jointRadius = g.radius)),
                  (x.visible = g !== null);
              }
              const h = c.joints["index-finger-tip"],
                u = c.joints["thumb-tip"],
                d = h.position.distanceTo(u.position),
                f = 0.02,
                m = 0.005;
              c.inputState.pinching && d > f + m
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  d <= f - m &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              l !== null &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                r !== null &&
                  (l.matrix.fromArray(r.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  r.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(r.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(r.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
          return (
            a !== null && (a.visible = i !== null),
            l !== null && (l.visible = r !== null),
            c !== null && (c.visible = o !== null),
            this
          );
        }
      }
      class _g extends Nt {
        constructor(e, t, n, i, r, o, a, l, c, h) {
          if (((h = h !== void 0 ? h : tr), h !== tr && h !== xs))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && h === tr && (n = Bo),
            n === void 0 && h === xs && (n = as),
            super(null, i, r, o, a, l, h, n, c),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : Ct),
            (this.minFilter = l !== void 0 ? l : Ct),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      _g.prototype.isDepthTexture = !0;
      class XL extends lr {
        constructor(e, t) {
          super();
          const n = this;
          let i = null,
            r = 1,
            o = null,
            a = "local-floor",
            l = null,
            c = null,
            h = null,
            u = null,
            d = null;
          const f = t.getContextAttributes();
          let m = null,
            p = null;
          const g = [],
            x = new Map(),
            _ = new Yt();
          _.layers.enable(1), (_.viewport = new st());
          const M = new Yt();
          M.layers.enable(2), (M.viewport = new st());
          const S = [_, M],
            v = new xg();
          v.layers.enable(1), v.layers.enable(2);
          let y = null,
            C = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (H) {
              let J = g[H];
              return (
                J === void 0 && ((J = new rh()), (g[H] = J)),
                J.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (H) {
              let J = g[H];
              return (
                J === void 0 && ((J = new rh()), (g[H] = J)), J.getGripSpace()
              );
            }),
            (this.getHand = function (H) {
              let J = g[H];
              return (
                J === void 0 && ((J = new rh()), (g[H] = J)), J.getHandSpace()
              );
            });
          function U(H) {
            const J = x.get(H.inputSource);
            J && J.dispatchEvent({ type: H.type, data: H.inputSource });
          }
          function K() {
            x.forEach(function (H, J) {
              H.disconnect(J);
            }),
              x.clear(),
              (y = null),
              (C = null),
              e.setRenderTarget(m),
              (u = null),
              (h = null),
              (c = null),
              (i = null),
              (p = null),
              V.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (H) {
            (r = H),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (H) {
              (a = H),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return o;
            }),
            (this.getBaseLayer = function () {
              return h !== null ? h : u;
            }),
            (this.getBinding = function () {
              return c;
            }),
            (this.getFrame = function () {
              return d;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (H) {
              if (((i = H), i !== null)) {
                if (
                  ((m = e.getRenderTarget()),
                  i.addEventListener("select", U),
                  i.addEventListener("selectstart", U),
                  i.addEventListener("selectend", U),
                  i.addEventListener("squeeze", U),
                  i.addEventListener("squeezestart", U),
                  i.addEventListener("squeezeend", U),
                  i.addEventListener("end", K),
                  i.addEventListener("inputsourceschange", X),
                  f.xrCompatible !== !0 && (await t.makeXRCompatible()),
                  i.renderState.layers === void 0 ||
                    e.capabilities.isWebGL2 === !1)
                ) {
                  const J = {
                    antialias:
                      i.renderState.layers === void 0 ? f.antialias : !0,
                    alpha: f.alpha,
                    depth: f.depth,
                    stencil: f.stencil,
                    framebufferScaleFactor: r,
                  };
                  (u = new XRWebGLLayer(i, t, J)),
                    i.updateRenderState({ baseLayer: u }),
                    (p = new fn(u.framebufferWidth, u.framebufferHeight, {
                      format: Dn,
                      type: rr,
                      encoding: e.outputEncoding,
                    }));
                } else {
                  let J = null,
                    ie = null,
                    ne = null;
                  f.depth &&
                    ((ne = f.stencil ? 35056 : 33190),
                    (J = f.stencil ? xs : tr),
                    (ie = f.stencil ? as : Bo));
                  const ae = {
                    colorFormat: e.outputEncoding === ht ? 35907 : 32856,
                    depthFormat: ne,
                    scaleFactor: r,
                  };
                  (c = new XRWebGLBinding(i, t)),
                    (h = c.createProjectionLayer(ae)),
                    i.updateRenderState({ layers: [h] }),
                    (p = new fn(h.textureWidth, h.textureHeight, {
                      format: Dn,
                      type: rr,
                      depthTexture: new _g(
                        h.textureWidth,
                        h.textureHeight,
                        ie,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        J
                      ),
                      stencilBuffer: f.stencil,
                      encoding: e.outputEncoding,
                      samples: f.antialias ? 4 : 0,
                    }));
                  const fe = e.properties.get(p);
                  fe.__ignoreDepthValues = h.ignoreDepthValues;
                }
                (p.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (o = await i.requestReferenceSpace(a)),
                  V.setContext(i),
                  V.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          function X(H) {
            const J = i.inputSources;
            for (let ie = 0; ie < g.length; ie++) x.set(J[ie], g[ie]);
            for (let ie = 0; ie < H.removed.length; ie++) {
              const ne = H.removed[ie],
                ae = x.get(ne);
              ae &&
                (ae.dispatchEvent({ type: "disconnected", data: ne }),
                x.delete(ne));
            }
            for (let ie = 0; ie < H.added.length; ie++) {
              const ne = H.added[ie],
                ae = x.get(ne);
              ae && ae.dispatchEvent({ type: "connected", data: ne });
            }
          }
          const b = new W(),
            D = new W();
          function I(H, J, ie) {
            b.setFromMatrixPosition(J.matrixWorld),
              D.setFromMatrixPosition(ie.matrixWorld);
            const ne = b.distanceTo(D),
              ae = J.projectionMatrix.elements,
              fe = ie.projectionMatrix.elements,
              Fe = ae[14] / (ae[10] - 1),
              Ee = ae[14] / (ae[10] + 1),
              $ = (ae[9] + 1) / ae[5],
              ke = (ae[9] - 1) / ae[5],
              Re = (ae[8] - 1) / ae[0],
              Te = (fe[8] + 1) / fe[0],
              ce = Fe * Re,
              Ie = Fe * Te,
              j = ne / (-Re + Te),
              Z = j * -Re;
            J.matrixWorld.decompose(H.position, H.quaternion, H.scale),
              H.translateX(Z),
              H.translateZ(j),
              H.matrixWorld.compose(H.position, H.quaternion, H.scale),
              H.matrixWorldInverse.copy(H.matrixWorld).invert();
            const te = Fe + j,
              de = Ee + j,
              se = ce - Z,
              N = Ie + (ne - Z),
              E = (($ * Ee) / de) * te,
              ee = ((ke * Ee) / de) * te;
            H.projectionMatrix.makePerspective(se, N, E, ee, te, de);
          }
          function L(H, J) {
            J === null
              ? H.matrixWorld.copy(H.matrix)
              : H.matrixWorld.multiplyMatrices(J.matrixWorld, H.matrix),
              H.matrixWorldInverse.copy(H.matrixWorld).invert();
          }
          (this.updateCamera = function (H) {
            if (i === null) return;
            (v.near = M.near = _.near = H.near),
              (v.far = M.far = _.far = H.far),
              (y !== v.near || C !== v.far) &&
                (i.updateRenderState({ depthNear: v.near, depthFar: v.far }),
                (y = v.near),
                (C = v.far));
            const J = H.parent,
              ie = v.cameras;
            L(v, J);
            for (let ae = 0; ae < ie.length; ae++) L(ie[ae], J);
            v.matrixWorld.decompose(v.position, v.quaternion, v.scale),
              H.position.copy(v.position),
              H.quaternion.copy(v.quaternion),
              H.scale.copy(v.scale),
              H.matrix.copy(v.matrix),
              H.matrixWorld.copy(v.matrixWorld);
            const ne = H.children;
            for (let ae = 0, fe = ne.length; ae < fe; ae++)
              ne[ae].updateMatrixWorld(!0);
            ie.length === 2
              ? I(v, _, M)
              : v.projectionMatrix.copy(_.projectionMatrix);
          }),
            (this.getCamera = function () {
              return v;
            }),
            (this.getFoveation = function () {
              if (h !== null) return h.fixedFoveation;
              if (u !== null) return u.fixedFoveation;
            }),
            (this.setFoveation = function (H) {
              h !== null && (h.fixedFoveation = H),
                u !== null &&
                  u.fixedFoveation !== void 0 &&
                  (u.fixedFoveation = H);
            });
          let B = null;
          function R(H, J) {
            if (((l = J.getViewerPose(o)), (d = J), l !== null)) {
              const ne = l.views;
              u !== null &&
                (e.setRenderTargetFramebuffer(p, u.framebuffer),
                e.setRenderTarget(p));
              let ae = !1;
              ne.length !== v.cameras.length &&
                ((v.cameras.length = 0), (ae = !0));
              for (let fe = 0; fe < ne.length; fe++) {
                const Fe = ne[fe];
                let Ee = null;
                if (u !== null) Ee = u.getViewport(Fe);
                else {
                  const ke = c.getViewSubImage(h, Fe);
                  (Ee = ke.viewport),
                    fe === 0 &&
                      (e.setRenderTargetTextures(
                        p,
                        ke.colorTexture,
                        h.ignoreDepthValues ? void 0 : ke.depthStencilTexture
                      ),
                      e.setRenderTarget(p));
                }
                const $ = S[fe];
                $.matrix.fromArray(Fe.transform.matrix),
                  $.projectionMatrix.fromArray(Fe.projectionMatrix),
                  $.viewport.set(Ee.x, Ee.y, Ee.width, Ee.height),
                  fe === 0 && v.matrix.copy($.matrix),
                  ae === !0 && v.cameras.push($);
              }
            }
            const ie = i.inputSources;
            for (let ne = 0; ne < g.length; ne++) {
              const ae = g[ne],
                fe = ie[ne];
              ae.update(fe, J, o);
            }
            B && B(H, J), (d = null);
          }
          const V = new lg();
          V.setAnimationLoop(R),
            (this.setAnimationLoop = function (H) {
              B = H;
            }),
            (this.dispose = function () {});
        }
      }
      function jL(s, e) {
        function t(p, g) {
          p.fogColor.value.copy(g.color),
            g.isFog
              ? ((p.fogNear.value = g.near), (p.fogFar.value = g.far))
              : g.isFogExp2 && (p.fogDensity.value = g.density);
        }
        function n(p, g, x, _, M) {
          g.isMeshBasicMaterial || g.isMeshLambertMaterial
            ? i(p, g)
            : g.isMeshToonMaterial
            ? (i(p, g), h(p, g))
            : g.isMeshPhongMaterial
            ? (i(p, g), c(p, g))
            : g.isMeshStandardMaterial
            ? (i(p, g), u(p, g), g.isMeshPhysicalMaterial && d(p, g, M))
            : g.isMeshMatcapMaterial
            ? (i(p, g), f(p, g))
            : g.isMeshDepthMaterial
            ? i(p, g)
            : g.isMeshDistanceMaterial
            ? (i(p, g), m(p, g))
            : g.isMeshNormalMaterial
            ? i(p, g)
            : g.isLineBasicMaterial
            ? (r(p, g), g.isLineDashedMaterial && o(p, g))
            : g.isPointsMaterial
            ? a(p, g, x, _)
            : g.isSpriteMaterial
            ? l(p, g)
            : g.isShadowMaterial
            ? (p.color.value.copy(g.color), (p.opacity.value = g.opacity))
            : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
        }
        function i(p, g) {
          (p.opacity.value = g.opacity),
            g.color && p.diffuse.value.copy(g.color),
            g.emissive &&
              p.emissive.value
                .copy(g.emissive)
                .multiplyScalar(g.emissiveIntensity),
            g.map && (p.map.value = g.map),
            g.alphaMap && (p.alphaMap.value = g.alphaMap),
            g.bumpMap &&
              ((p.bumpMap.value = g.bumpMap),
              (p.bumpScale.value = g.bumpScale),
              g.side === Nn && (p.bumpScale.value *= -1)),
            g.displacementMap &&
              ((p.displacementMap.value = g.displacementMap),
              (p.displacementScale.value = g.displacementScale),
              (p.displacementBias.value = g.displacementBias)),
            g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
            g.normalMap &&
              ((p.normalMap.value = g.normalMap),
              p.normalScale.value.copy(g.normalScale),
              g.side === Nn && p.normalScale.value.negate()),
            g.specularMap && (p.specularMap.value = g.specularMap),
            g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
          const x = e.get(g).envMap;
          if (
            (x &&
              ((p.envMap.value = x),
              (p.flipEnvMap.value =
                x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
              (p.reflectivity.value = g.reflectivity),
              (p.ior.value = g.ior),
              (p.refractionRatio.value = g.refractionRatio)),
            g.lightMap)
          ) {
            p.lightMap.value = g.lightMap;
            const S = s.physicallyCorrectLights !== !0 ? Math.PI : 1;
            p.lightMapIntensity.value = g.lightMapIntensity * S;
          }
          g.aoMap &&
            ((p.aoMap.value = g.aoMap),
            (p.aoMapIntensity.value = g.aoMapIntensity));
          let _;
          g.map
            ? (_ = g.map)
            : g.specularMap
            ? (_ = g.specularMap)
            : g.displacementMap
            ? (_ = g.displacementMap)
            : g.normalMap
            ? (_ = g.normalMap)
            : g.bumpMap
            ? (_ = g.bumpMap)
            : g.roughnessMap
            ? (_ = g.roughnessMap)
            : g.metalnessMap
            ? (_ = g.metalnessMap)
            : g.alphaMap
            ? (_ = g.alphaMap)
            : g.emissiveMap
            ? (_ = g.emissiveMap)
            : g.clearcoatMap
            ? (_ = g.clearcoatMap)
            : g.clearcoatNormalMap
            ? (_ = g.clearcoatNormalMap)
            : g.clearcoatRoughnessMap
            ? (_ = g.clearcoatRoughnessMap)
            : g.specularIntensityMap
            ? (_ = g.specularIntensityMap)
            : g.specularColorMap
            ? (_ = g.specularColorMap)
            : g.transmissionMap
            ? (_ = g.transmissionMap)
            : g.thicknessMap
            ? (_ = g.thicknessMap)
            : g.sheenColorMap
            ? (_ = g.sheenColorMap)
            : g.sheenRoughnessMap && (_ = g.sheenRoughnessMap),
            _ !== void 0 &&
              (_.isWebGLRenderTarget && (_ = _.texture),
              _.matrixAutoUpdate === !0 && _.updateMatrix(),
              p.uvTransform.value.copy(_.matrix));
          let M;
          g.aoMap ? (M = g.aoMap) : g.lightMap && (M = g.lightMap),
            M !== void 0 &&
              (M.isWebGLRenderTarget && (M = M.texture),
              M.matrixAutoUpdate === !0 && M.updateMatrix(),
              p.uv2Transform.value.copy(M.matrix));
        }
        function r(p, g) {
          p.diffuse.value.copy(g.color), (p.opacity.value = g.opacity);
        }
        function o(p, g) {
          (p.dashSize.value = g.dashSize),
            (p.totalSize.value = g.dashSize + g.gapSize),
            (p.scale.value = g.scale);
        }
        function a(p, g, x, _) {
          p.diffuse.value.copy(g.color),
            (p.opacity.value = g.opacity),
            (p.size.value = g.size * x),
            (p.scale.value = _ * 0.5),
            g.map && (p.map.value = g.map),
            g.alphaMap && (p.alphaMap.value = g.alphaMap),
            g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
          let M;
          g.map ? (M = g.map) : g.alphaMap && (M = g.alphaMap),
            M !== void 0 &&
              (M.matrixAutoUpdate === !0 && M.updateMatrix(),
              p.uvTransform.value.copy(M.matrix));
        }
        function l(p, g) {
          p.diffuse.value.copy(g.color),
            (p.opacity.value = g.opacity),
            (p.rotation.value = g.rotation),
            g.map && (p.map.value = g.map),
            g.alphaMap && (p.alphaMap.value = g.alphaMap),
            g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
          let x;
          g.map ? (x = g.map) : g.alphaMap && (x = g.alphaMap),
            x !== void 0 &&
              (x.matrixAutoUpdate === !0 && x.updateMatrix(),
              p.uvTransform.value.copy(x.matrix));
        }
        function c(p, g) {
          p.specular.value.copy(g.specular),
            (p.shininess.value = Math.max(g.shininess, 1e-4));
        }
        function h(p, g) {
          g.gradientMap && (p.gradientMap.value = g.gradientMap);
        }
        function u(p, g) {
          (p.roughness.value = g.roughness),
            (p.metalness.value = g.metalness),
            g.roughnessMap && (p.roughnessMap.value = g.roughnessMap),
            g.metalnessMap && (p.metalnessMap.value = g.metalnessMap),
            e.get(g).envMap && (p.envMapIntensity.value = g.envMapIntensity);
        }
        function d(p, g, x) {
          (p.ior.value = g.ior),
            g.sheen > 0 &&
              (p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
              (p.sheenRoughness.value = g.sheenRoughness),
              g.sheenColorMap && (p.sheenColorMap.value = g.sheenColorMap),
              g.sheenRoughnessMap &&
                (p.sheenRoughnessMap.value = g.sheenRoughnessMap)),
            g.clearcoat > 0 &&
              ((p.clearcoat.value = g.clearcoat),
              (p.clearcoatRoughness.value = g.clearcoatRoughness),
              g.clearcoatMap && (p.clearcoatMap.value = g.clearcoatMap),
              g.clearcoatRoughnessMap &&
                (p.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
              g.clearcoatNormalMap &&
                (p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
                (p.clearcoatNormalMap.value = g.clearcoatNormalMap),
                g.side === Nn && p.clearcoatNormalScale.value.negate())),
            g.transmission > 0 &&
              ((p.transmission.value = g.transmission),
              (p.transmissionSamplerMap.value = x.texture),
              p.transmissionSamplerSize.value.set(x.width, x.height),
              g.transmissionMap &&
                (p.transmissionMap.value = g.transmissionMap),
              (p.thickness.value = g.thickness),
              g.thicknessMap && (p.thicknessMap.value = g.thicknessMap),
              (p.attenuationDistance.value = g.attenuationDistance),
              p.attenuationColor.value.copy(g.attenuationColor)),
            (p.specularIntensity.value = g.specularIntensity),
            p.specularColor.value.copy(g.specularColor),
            g.specularIntensityMap &&
              (p.specularIntensityMap.value = g.specularIntensityMap),
            g.specularColorMap &&
              (p.specularColorMap.value = g.specularColorMap);
        }
        function f(p, g) {
          g.matcap && (p.matcap.value = g.matcap);
        }
        function m(p, g) {
          p.referencePosition.value.copy(g.referencePosition),
            (p.nearDistance.value = g.nearDistance),
            (p.farDistance.value = g.farDistance);
        }
        return { refreshFogUniforms: t, refreshMaterialUniforms: n };
      }
      function YL() {
        const s = Oo("canvas");
        return (s.style.display = "block"), s;
      }
      function nt(s = {}) {
        const e = s.canvas !== void 0 ? s.canvas : YL(),
          t = s.context !== void 0 ? s.context : null,
          n = s.depth !== void 0 ? s.depth : !0,
          i = s.stencil !== void 0 ? s.stencil : !0,
          r = s.antialias !== void 0 ? s.antialias : !1,
          o = s.premultipliedAlpha !== void 0 ? s.premultipliedAlpha : !0,
          a = s.preserveDrawingBuffer !== void 0 ? s.preserveDrawingBuffer : !1,
          l = s.powerPreference !== void 0 ? s.powerPreference : "default",
          c =
            s.failIfMajorPerformanceCaveat !== void 0
              ? s.failIfMajorPerformanceCaveat
              : !1;
        let h;
        s.context !== void 0
          ? (h = t.getContextAttributes().alpha)
          : (h = s.alpha !== void 0 ? s.alpha : !1);
        let u = null,
          d = null;
        const f = [],
          m = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = hi),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = li),
          (this.toneMappingExposure = 1);
        const p = this;
        let g = !1,
          x = 0,
          _ = 0,
          M = null,
          S = -1,
          v = null;
        const y = new st(),
          C = new st();
        let U = null,
          K = e.width,
          X = e.height,
          b = 1,
          D = null,
          I = null;
        const L = new st(0, 0, K, X),
          B = new st(0, 0, K, X);
        let R = !1;
        const V = new Fl();
        let H = !1,
          J = !1,
          ie = null;
        const ne = new We(),
          ae = new ye(),
          fe = new W(),
          Fe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Ee() {
          return M === null ? b : 1;
        }
        let $ = t;
        function ke(w, P) {
          for (let z = 0; z < w.length; z++) {
            const q = w[z],
              re = e.getContext(q, P);
            if (re !== null) return re;
          }
          return null;
        }
        try {
          const w = {
            alpha: !0,
            depth: n,
            stencil: i,
            antialias: r,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c,
          };
          if (
            ("setAttribute" in e &&
              e.setAttribute("data-engine", `three.js r${mu}`),
            e.addEventListener("webglcontextlost", Y, !1),
            e.addEventListener("webglcontextrestored", _e, !1),
            $ === null)
          ) {
            const P = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (p.isWebGL1Renderer === !0 && P.shift(),
              ($ = ke(P, w)),
              $ === null)
            )
              throw ke(P)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          $.getShaderPrecisionFormat === void 0 &&
            ($.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (w) {
          throw (console.error("THREE.WebGLRenderer: " + w.message), w);
        }
        let Re,
          Te,
          ce,
          Ie,
          j,
          Z,
          te,
          de,
          se,
          N,
          E,
          ee,
          ue,
          me,
          A,
          T,
          Q,
          oe,
          he,
          O,
          le,
          k,
          ge;
        function pe() {
          (Re = new fA($)),
            (Te = new aA($, Re, s)),
            Re.init(Te),
            (k = new $L($, Re, Te)),
            (ce = new kL($, Re, Te)),
            (Ie = new gA($)),
            (j = new DL()),
            (Z = new WL($, Re, ce, j, Te, k, Ie)),
            (te = new cA(p)),
            (de = new dA(p)),
            (se = new C1($, Te)),
            (ge = new sA($, Re, se, Te)),
            (N = new pA($, se, Ie, ge)),
            (E = new yA($, N, se, Ie)),
            (he = new vA($, Te, Z)),
            (T = new lA(j)),
            (ee = new PL(p, te, de, Re, Te, ge, T)),
            (ue = new jL(p, j)),
            (me = new NL()),
            (A = new HL(Re, Te)),
            (oe = new rA(p, te, ce, E, h, o)),
            (Q = new gg(p, E, Te)),
            (O = new oA($, Re, Ie, Te)),
            (le = new mA($, Re, Ie, Te)),
            (Ie.programs = ee.programs),
            (p.capabilities = Te),
            (p.extensions = Re),
            (p.properties = j),
            (p.renderLists = me),
            (p.shadowMap = Q),
            (p.state = ce),
            (p.info = Ie);
        }
        pe();
        const be = new XL(p, $);
        (this.xr = be),
          (this.getContext = function () {
            return $;
          }),
          (this.getContextAttributes = function () {
            return $.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const w = Re.get("WEBGL_lose_context");
            w && w.loseContext();
          }),
          (this.forceContextRestore = function () {
            const w = Re.get("WEBGL_lose_context");
            w && w.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return b;
          }),
          (this.setPixelRatio = function (w) {
            w !== void 0 && ((b = w), this.setSize(K, X, !1));
          }),
          (this.getSize = function (w) {
            return w.set(K, X);
          }),
          (this.setSize = function (w, P, z) {
            if (be.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (K = w),
              (X = P),
              (e.width = Math.floor(w * b)),
              (e.height = Math.floor(P * b)),
              z !== !1 &&
                ((e.style.width = w + "px"), (e.style.height = P + "px")),
              this.setViewport(0, 0, w, P);
          }),
          (this.getDrawingBufferSize = function (w) {
            return w.set(K * b, X * b).floor();
          }),
          (this.setDrawingBufferSize = function (w, P, z) {
            (K = w),
              (X = P),
              (b = z),
              (e.width = Math.floor(w * z)),
              (e.height = Math.floor(P * z)),
              this.setViewport(0, 0, w, P);
          }),
          (this.getCurrentViewport = function (w) {
            return w.copy(y);
          }),
          (this.getViewport = function (w) {
            return w.copy(L);
          }),
          (this.setViewport = function (w, P, z, q) {
            w.isVector4 ? L.set(w.x, w.y, w.z, w.w) : L.set(w, P, z, q),
              ce.viewport(y.copy(L).multiplyScalar(b).floor());
          }),
          (this.getScissor = function (w) {
            return w.copy(B);
          }),
          (this.setScissor = function (w, P, z, q) {
            w.isVector4 ? B.set(w.x, w.y, w.z, w.w) : B.set(w, P, z, q),
              ce.scissor(C.copy(B).multiplyScalar(b).floor());
          }),
          (this.getScissorTest = function () {
            return R;
          }),
          (this.setScissorTest = function (w) {
            ce.setScissorTest((R = w));
          }),
          (this.setOpaqueSort = function (w) {
            D = w;
          }),
          (this.setTransparentSort = function (w) {
            I = w;
          }),
          (this.getClearColor = function (w) {
            return w.copy(oe.getClearColor());
          }),
          (this.setClearColor = function () {
            oe.setClearColor.apply(oe, arguments);
          }),
          (this.getClearAlpha = function () {
            return oe.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            oe.setClearAlpha.apply(oe, arguments);
          }),
          (this.clear = function (w = !0, P = !0, z = !0) {
            let q = 0;
            w && (q |= 16384), P && (q |= 256), z && (q |= 1024), $.clear(q);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", Y, !1),
              e.removeEventListener("webglcontextrestored", _e, !1),
              me.dispose(),
              A.dispose(),
              j.dispose(),
              te.dispose(),
              de.dispose(),
              E.dispose(),
              ge.dispose(),
              ee.dispose(),
              be.dispose(),
              be.removeEventListener("sessionstart", qe),
              be.removeEventListener("sessionend", it),
              ie && (ie.dispose(), (ie = null)),
              Xe.stop();
          });
        function Y(w) {
          w.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (g = !0);
        }
        function _e() {
          console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
          const w = Ie.autoReset,
            P = Q.enabled,
            z = Q.autoUpdate,
            q = Q.needsUpdate,
            re = Q.type;
          pe(),
            (Ie.autoReset = w),
            (Q.enabled = P),
            (Q.autoUpdate = z),
            (Q.needsUpdate = q),
            (Q.type = re);
        }
        function we(w) {
          const P = w.target;
          P.removeEventListener("dispose", we), Be(P);
        }
        function Be(w) {
          Ne(w), j.remove(w);
        }
        function Ne(w) {
          const P = j.get(w).programs;
          P !== void 0 &&
            (P.forEach(function (z) {
              ee.releaseProgram(z);
            }),
            w.isShaderMaterial && ee.releaseShaderCache(w));
        }
        (this.renderBufferDirect = function (w, P, z, q, re, Me) {
          P === null && (P = Fe);
          const xe = re.isMesh && re.matrixWorld.determinant() < 0,
            Ce = Hl(w, P, z, q, re);
          ce.setMaterial(q, xe);
          let ve = z.index;
          const ze = z.attributes.position;
          if (ve === null) {
            if (ze === void 0 || ze.count === 0) return;
          } else if (ve.count === 0) return;
          let Ae = 1;
          q.wireframe === !0 && ((ve = N.getWireframeAttribute(z)), (Ae = 2)),
            ge.setup(re, q, Ce, z, ve);
          let Oe,
            Ze = O;
          ve !== null && ((Oe = se.get(ve)), (Ze = le), Ze.setIndex(Oe));
          const mt = ve !== null ? ve.count : ze.count,
            Qt = z.drawRange.start * Ae,
            at = z.drawRange.count * Ae,
            Et = Me !== null ? Me.start * Ae : 0,
            $e = Me !== null ? Me.count * Ae : 1 / 0,
            di = Math.max(Qt, Et),
            ct = Math.min(mt, Qt + at, Et + $e) - 1,
            Gt = Math.max(0, ct - di + 1);
          if (Gt !== 0) {
            if (re.isMesh)
              q.wireframe === !0
                ? (ce.setLineWidth(q.wireframeLinewidth * Ee()), Ze.setMode(1))
                : Ze.setMode(4);
            else if (re.isLine) {
              let fi = q.linewidth;
              fi === void 0 && (fi = 1),
                ce.setLineWidth(fi * Ee()),
                re.isLineSegments
                  ? Ze.setMode(1)
                  : re.isLineLoop
                  ? Ze.setMode(2)
                  : Ze.setMode(3);
            } else re.isPoints ? Ze.setMode(0) : re.isSprite && Ze.setMode(4);
            if (re.isInstancedMesh) Ze.renderInstances(di, Gt, re.count);
            else if (z.isInstancedBufferGeometry) {
              const fi = Math.min(z.instanceCount, z._maxInstanceCount);
              Ze.renderInstances(di, Gt, fi);
            } else Ze.render(di, Gt);
          }
        }),
          (this.compile = function (w, P) {
            (d = A.get(w)),
              d.init(),
              m.push(d),
              w.traverseVisible(function (z) {
                z.isLight &&
                  z.layers.test(P.layers) &&
                  (d.pushLight(z), z.castShadow && d.pushShadow(z));
              }),
              d.setupLights(p.physicallyCorrectLights),
              w.traverse(function (z) {
                const q = z.material;
                if (q)
                  if (Array.isArray(q))
                    for (let re = 0; re < q.length; re++) {
                      const Me = q[re];
                      dr(Me, w, z);
                    }
                  else dr(q, w, z);
              }),
              m.pop(),
              (d = null);
          });
        let He = null;
        function Le(w) {
          He && He(w);
        }
        function qe() {
          Xe.stop();
        }
        function it() {
          Xe.start();
        }
        const Xe = new lg();
        Xe.setAnimationLoop(Le),
          typeof self != "undefined" && Xe.setContext(self),
          (this.setAnimationLoop = function (w) {
            (He = w),
              be.setAnimationLoop(w),
              w === null ? Xe.stop() : Xe.start();
          }),
          be.addEventListener("sessionstart", qe),
          be.addEventListener("sessionend", it),
          (this.render = function (w, P) {
            if (P !== void 0 && P.isCamera !== !0) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (g === !0) return;
            w.autoUpdate === !0 && w.updateMatrixWorld(),
              P.parent === null && P.updateMatrixWorld(),
              be.enabled === !0 &&
                be.isPresenting === !0 &&
                (be.cameraAutoUpdate === !0 && be.updateCamera(P),
                (P = be.getCamera())),
              w.isScene === !0 && w.onBeforeRender(p, w, P, M),
              (d = A.get(w, m.length)),
              d.init(),
              m.push(d),
              ne.multiplyMatrices(P.projectionMatrix, P.matrixWorldInverse),
              V.setFromProjectionMatrix(ne),
              (J = this.localClippingEnabled),
              (H = T.init(this.clippingPlanes, J, P)),
              (u = me.get(w, f.length)),
              u.init(),
              f.push(u),
              ln(w, P, 0, p.sortObjects),
              u.finish(),
              p.sortObjects === !0 && u.sort(D, I),
              H === !0 && T.beginShadows();
            const z = d.state.shadowsArray;
            if (
              (Q.render(z, w, P),
              H === !0 && T.endShadows(),
              this.info.autoReset === !0 && this.info.reset(),
              oe.render(u, w),
              d.setupLights(p.physicallyCorrectLights),
              P.isArrayCamera)
            ) {
              const q = P.cameras;
              for (let re = 0, Me = q.length; re < Me; re++) {
                const xe = q[re];
                mn(u, w, xe, xe.viewport);
              }
            } else mn(u, w, P);
            M !== null &&
              (Z.updateMultisampleRenderTarget(M),
              Z.updateRenderTargetMipmap(M)),
              w.isScene === !0 && w.onAfterRender(p, w, P),
              ge.resetDefaultState(),
              (S = -1),
              (v = null),
              m.pop(),
              m.length > 0 ? (d = m[m.length - 1]) : (d = null),
              f.pop(),
              f.length > 0 ? (u = f[f.length - 1]) : (u = null);
          });
        function ln(w, P, z, q) {
          if (w.visible === !1) return;
          if (w.layers.test(P.layers)) {
            if (w.isGroup) z = w.renderOrder;
            else if (w.isLOD) w.autoUpdate === !0 && w.update(P);
            else if (w.isLight) d.pushLight(w), w.castShadow && d.pushShadow(w);
            else if (w.isSprite) {
              if (!w.frustumCulled || V.intersectsSprite(w)) {
                q && fe.setFromMatrixPosition(w.matrixWorld).applyMatrix4(ne);
                const xe = E.update(w),
                  Ce = w.material;
                Ce.visible && u.push(w, xe, Ce, z, fe.z, null);
              }
            } else if (
              (w.isMesh || w.isLine || w.isPoints) &&
              (w.isSkinnedMesh &&
                w.skeleton.frame !== Ie.render.frame &&
                (w.skeleton.update(), (w.skeleton.frame = Ie.render.frame)),
              !w.frustumCulled || V.intersectsObject(w))
            ) {
              q && fe.setFromMatrixPosition(w.matrixWorld).applyMatrix4(ne);
              const xe = E.update(w),
                Ce = w.material;
              if (Array.isArray(Ce)) {
                const ve = xe.groups;
                for (let ze = 0, Ae = ve.length; ze < Ae; ze++) {
                  const Oe = ve[ze],
                    Ze = Ce[Oe.materialIndex];
                  Ze && Ze.visible && u.push(w, xe, Ze, z, fe.z, Oe);
                }
              } else Ce.visible && u.push(w, xe, Ce, z, fe.z, null);
            }
          }
          const Me = w.children;
          for (let xe = 0, Ce = Me.length; xe < Ce; xe++) ln(Me[xe], P, z, q);
        }
        function mn(w, P, z, q) {
          const re = w.opaque,
            Me = w.transmissive,
            xe = w.transparent;
          d.setupLightsView(z),
            Me.length > 0 && ur(re, P, z),
            q && ce.viewport(y.copy(q)),
            re.length > 0 && Wi(re, P, z),
            Me.length > 0 && Wi(Me, P, z),
            xe.length > 0 && Wi(xe, P, z),
            ce.buffers.depth.setTest(!0),
            ce.buffers.depth.setMask(!0),
            ce.buffers.color.setMask(!0),
            ce.setPolygonOffset(!1);
        }
        function ur(w, P, z) {
          const q = Te.isWebGL2;
          ie === null &&
            (ie = new fn(1, 1, {
              generateMipmaps: !0,
              type: k.convert(os) !== null ? os : rr,
              minFilter: Pl,
              samples: q && r === !0 ? 4 : 0,
            })),
            p.getDrawingBufferSize(ae),
            q ? ie.setSize(ae.x, ae.y) : ie.setSize(Nh(ae.x), Nh(ae.y));
          const re = p.getRenderTarget();
          p.setRenderTarget(ie), p.clear();
          const Me = p.toneMapping;
          (p.toneMapping = li),
            Wi(w, P, z),
            (p.toneMapping = Me),
            Z.updateMultisampleRenderTarget(ie),
            Z.updateRenderTargetMipmap(ie),
            p.setRenderTarget(re);
        }
        function Wi(w, P, z) {
          const q = P.isScene === !0 ? P.overrideMaterial : null;
          for (let re = 0, Me = w.length; re < Me; re++) {
            const xe = w[re],
              Ce = xe.object,
              ve = xe.geometry,
              ze = q === null ? xe.material : q,
              Ae = xe.group;
            Ce.layers.test(z.layers) && Os(Ce, P, z, ve, ze, Ae);
          }
        }
        function Os(w, P, z, q, re, Me) {
          w.onBeforeRender(p, P, z, q, re, Me),
            w.modelViewMatrix.multiplyMatrices(
              z.matrixWorldInverse,
              w.matrixWorld
            ),
            w.normalMatrix.getNormalMatrix(w.modelViewMatrix),
            re.onBeforeRender(p, P, z, q, w, Me),
            re.transparent === !0 && re.side === ps
              ? ((re.side = Nn),
                (re.needsUpdate = !0),
                p.renderBufferDirect(z, P, q, re, w, Me),
                (re.side = Fo),
                (re.needsUpdate = !0),
                p.renderBufferDirect(z, P, q, re, w, Me),
                (re.side = ps))
              : p.renderBufferDirect(z, P, q, re, w, Me),
            w.onAfterRender(p, P, z, q, re, Me);
        }
        function dr(w, P, z) {
          P.isScene !== !0 && (P = Fe);
          const q = j.get(w),
            re = d.state.lights,
            Me = d.state.shadowsArray,
            xe = re.state.version,
            Ce = ee.getParameters(w, re.state, Me, P, z),
            ve = ee.getProgramCacheKey(Ce);
          let ze = q.programs;
          (q.environment = w.isMeshStandardMaterial ? P.environment : null),
            (q.fog = P.fog),
            (q.envMap = (w.isMeshStandardMaterial ? de : te).get(
              w.envMap || q.environment
            )),
            ze === void 0 &&
              (w.addEventListener("dispose", we),
              (ze = new Map()),
              (q.programs = ze));
          let Ae = ze.get(ve);
          if (Ae !== void 0) {
            if (q.currentProgram === Ae && q.lightsStateVersion === xe)
              return Us(w, Ce), Ae;
          } else
            (Ce.uniforms = ee.getUniforms(w)),
              w.onBuild(z, Ce, p),
              w.onBeforeCompile(Ce, p),
              (Ae = ee.acquireProgram(Ce, ve)),
              ze.set(ve, Ae),
              (q.uniforms = Ce.uniforms);
          const Oe = q.uniforms;
          ((!w.isShaderMaterial && !w.isRawShaderMaterial) ||
            w.clipping === !0) &&
            (Oe.clippingPlanes = T.uniform),
            Us(w, Ce),
            (q.needsLights = F(w)),
            (q.lightsStateVersion = xe),
            q.needsLights &&
              ((Oe.ambientLightColor.value = re.state.ambient),
              (Oe.lightProbe.value = re.state.probe),
              (Oe.directionalLights.value = re.state.directional),
              (Oe.directionalLightShadows.value = re.state.directionalShadow),
              (Oe.spotLights.value = re.state.spot),
              (Oe.spotLightShadows.value = re.state.spotShadow),
              (Oe.rectAreaLights.value = re.state.rectArea),
              (Oe.ltc_1.value = re.state.rectAreaLTC1),
              (Oe.ltc_2.value = re.state.rectAreaLTC2),
              (Oe.pointLights.value = re.state.point),
              (Oe.pointLightShadows.value = re.state.pointShadow),
              (Oe.hemisphereLights.value = re.state.hemi),
              (Oe.directionalShadowMap.value = re.state.directionalShadowMap),
              (Oe.directionalShadowMatrix.value =
                re.state.directionalShadowMatrix),
              (Oe.spotShadowMap.value = re.state.spotShadowMap),
              (Oe.spotShadowMatrix.value = re.state.spotShadowMatrix),
              (Oe.pointShadowMap.value = re.state.pointShadowMap),
              (Oe.pointShadowMatrix.value = re.state.pointShadowMatrix));
          const Ze = Ae.getUniforms(),
            mt = Oi.seqWithValue(Ze.seq, Oe);
          return (q.currentProgram = Ae), (q.uniformsList = mt), Ae;
        }
        function Us(w, P) {
          const z = j.get(w);
          (z.outputEncoding = P.outputEncoding),
            (z.instancing = P.instancing),
            (z.skinning = P.skinning),
            (z.morphTargets = P.morphTargets),
            (z.morphNormals = P.morphNormals),
            (z.morphColors = P.morphColors),
            (z.morphTargetsCount = P.morphTargetsCount),
            (z.numClippingPlanes = P.numClippingPlanes),
            (z.numIntersection = P.numClipIntersection),
            (z.vertexAlphas = P.vertexAlphas),
            (z.vertexTangents = P.vertexTangents),
            (z.toneMapping = P.toneMapping);
        }
        function Hl(w, P, z, q, re) {
          P.isScene !== !0 && (P = Fe), Z.resetTextureUnits();
          const Me = P.fog,
            xe = q.isMeshStandardMaterial ? P.environment : null,
            Ce =
              M === null
                ? p.outputEncoding
                : M.isXRRenderTarget === !0
                ? M.texture.encoding
                : hi,
            ve = (q.isMeshStandardMaterial ? de : te).get(q.envMap || xe),
            ze =
              q.vertexColors === !0 &&
              !!z.attributes.color &&
              z.attributes.color.itemSize === 4,
            Ae = !!q.normalMap && !!z.attributes.tangent,
            Oe = !!z.morphAttributes.position,
            Ze = !!z.morphAttributes.normal,
            mt = !!z.morphAttributes.color,
            Qt = q.toneMapped ? p.toneMapping : li,
            at =
              z.morphAttributes.position ||
              z.morphAttributes.normal ||
              z.morphAttributes.color,
            Et = at !== void 0 ? at.length : 0,
            $e = j.get(q),
            di = d.state.lights;
          if (H === !0 && (J === !0 || w !== v)) {
            const bn = w === v && q.id === S;
            T.setState(q, w, bn);
          }
          let ct = !1;
          q.version === $e.__version
            ? (($e.needsLights && $e.lightsStateVersion !== di.state.version) ||
                $e.outputEncoding !== Ce ||
                (re.isInstancedMesh && $e.instancing === !1) ||
                (!re.isInstancedMesh && $e.instancing === !0) ||
                (re.isSkinnedMesh && $e.skinning === !1) ||
                (!re.isSkinnedMesh && $e.skinning === !0) ||
                $e.envMap !== ve ||
                (q.fog && $e.fog !== Me) ||
                ($e.numClippingPlanes !== void 0 &&
                  ($e.numClippingPlanes !== T.numPlanes ||
                    $e.numIntersection !== T.numIntersection)) ||
                $e.vertexAlphas !== ze ||
                $e.vertexTangents !== Ae ||
                $e.morphTargets !== Oe ||
                $e.morphNormals !== Ze ||
                $e.morphColors !== mt ||
                $e.toneMapping !== Qt ||
                (Te.isWebGL2 === !0 && $e.morphTargetsCount !== Et)) &&
              (ct = !0)
            : ((ct = !0), ($e.__version = q.version));
          let Gt = $e.currentProgram;
          ct === !0 && (Gt = dr(q, P, re));
          let fi = !1,
            Hs = !1,
            Vl = !1;
          const Vt = Gt.getUniforms(),
            Gs = $e.uniforms;
          if (
            (ce.useProgram(Gt.program) && ((fi = !0), (Hs = !0), (Vl = !0)),
            q.id !== S && ((S = q.id), (Hs = !0)),
            fi || v !== w)
          ) {
            if (
              (Vt.setValue($, "projectionMatrix", w.projectionMatrix),
              Te.logarithmicDepthBuffer &&
                Vt.setValue(
                  $,
                  "logDepthBufFC",
                  2 / (Math.log(w.far + 1) / Math.LN2)
                ),
              v !== w && ((v = w), (Hs = !0), (Vl = !0)),
              q.isShaderMaterial ||
                q.isMeshPhongMaterial ||
                q.isMeshToonMaterial ||
                q.isMeshStandardMaterial ||
                q.envMap)
            ) {
              const bn = Vt.map.cameraPosition;
              bn !== void 0 &&
                bn.setValue($, fe.setFromMatrixPosition(w.matrixWorld));
            }
            (q.isMeshPhongMaterial ||
              q.isMeshToonMaterial ||
              q.isMeshLambertMaterial ||
              q.isMeshBasicMaterial ||
              q.isMeshStandardMaterial ||
              q.isShaderMaterial) &&
              Vt.setValue($, "isOrthographic", w.isOrthographicCamera === !0),
              (q.isMeshPhongMaterial ||
                q.isMeshToonMaterial ||
                q.isMeshLambertMaterial ||
                q.isMeshBasicMaterial ||
                q.isMeshStandardMaterial ||
                q.isShaderMaterial ||
                q.isShadowMaterial ||
                re.isSkinnedMesh) &&
                Vt.setValue($, "viewMatrix", w.matrixWorldInverse);
          }
          if (re.isSkinnedMesh) {
            Vt.setOptional($, re, "bindMatrix"),
              Vt.setOptional($, re, "bindMatrixInverse");
            const bn = re.skeleton;
            bn &&
              (Te.floatVertexTextures
                ? (bn.boneTexture === null && bn.computeBoneTexture(),
                  Vt.setValue($, "boneTexture", bn.boneTexture, Z),
                  Vt.setValue($, "boneTextureSize", bn.boneTextureSize))
                : Vt.setOptional($, bn, "boneMatrices"));
          }
          const kl = z.morphAttributes;
          return (
            (kl.position !== void 0 ||
              kl.normal !== void 0 ||
              (kl.color !== void 0 && Te.isWebGL2 === !0)) &&
              he.update(re, z, q, Gt),
            (Hs || $e.receiveShadow !== re.receiveShadow) &&
              (($e.receiveShadow = re.receiveShadow),
              Vt.setValue($, "receiveShadow", re.receiveShadow)),
            Hs &&
              (Vt.setValue($, "toneMappingExposure", p.toneMappingExposure),
              $e.needsLights && Gl(Gs, Vl),
              Me && q.fog && ue.refreshFogUniforms(Gs, Me),
              ue.refreshMaterialUniforms(Gs, q, b, X, ie),
              Oi.upload($, $e.uniformsList, Gs, Z)),
            q.isShaderMaterial &&
              q.uniformsNeedUpdate === !0 &&
              (Oi.upload($, $e.uniformsList, Gs, Z),
              (q.uniformsNeedUpdate = !1)),
            q.isSpriteMaterial && Vt.setValue($, "center", re.center),
            Vt.setValue($, "modelViewMatrix", re.modelViewMatrix),
            Vt.setValue($, "normalMatrix", re.normalMatrix),
            Vt.setValue($, "modelMatrix", re.matrixWorld),
            Gt
          );
        }
        function Gl(w, P) {
          (w.ambientLightColor.needsUpdate = P),
            (w.lightProbe.needsUpdate = P),
            (w.directionalLights.needsUpdate = P),
            (w.directionalLightShadows.needsUpdate = P),
            (w.pointLights.needsUpdate = P),
            (w.pointLightShadows.needsUpdate = P),
            (w.spotLights.needsUpdate = P),
            (w.spotLightShadows.needsUpdate = P),
            (w.rectAreaLights.needsUpdate = P),
            (w.hemisphereLights.needsUpdate = P);
        }
        function F(w) {
          return (
            w.isMeshLambertMaterial ||
            w.isMeshToonMaterial ||
            w.isMeshPhongMaterial ||
            w.isMeshStandardMaterial ||
            w.isShadowMaterial ||
            (w.isShaderMaterial && w.lights === !0)
          );
        }
        (this.getActiveCubeFace = function () {
          return x;
        }),
          (this.getActiveMipmapLevel = function () {
            return _;
          }),
          (this.getRenderTarget = function () {
            return M;
          }),
          (this.setRenderTargetTextures = function (w, P, z) {
            (j.get(w.texture).__webglTexture = P),
              (j.get(w.depthTexture).__webglTexture = z);
            const q = j.get(w);
            (q.__hasExternalTextures = !0),
              q.__hasExternalTextures &&
                ((q.__autoAllocateDepthBuffer = z === void 0),
                q.__autoAllocateDepthBuffer ||
                  (Re.has("WEBGL_multisampled_render_to_texture") === !0 &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (q.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (w, P) {
            const z = j.get(w);
            (z.__webglFramebuffer = P),
              (z.__useDefaultFramebuffer = P === void 0);
          }),
          (this.setRenderTarget = function (w, P = 0, z = 0) {
            (M = w), (x = P), (_ = z);
            let q = !0;
            if (w) {
              const ve = j.get(w);
              ve.__useDefaultFramebuffer !== void 0
                ? (ce.bindFramebuffer(36160, null), (q = !1))
                : ve.__webglFramebuffer === void 0
                ? Z.setupRenderTarget(w)
                : ve.__hasExternalTextures &&
                  Z.rebindTextures(
                    w,
                    j.get(w.texture).__webglTexture,
                    j.get(w.depthTexture).__webglTexture
                  );
            }
            let re = null,
              Me = !1,
              xe = !1;
            if (w) {
              const ve = w.texture;
              (ve.isData3DTexture || ve.isDataArrayTexture) && (xe = !0);
              const ze = j.get(w).__webglFramebuffer;
              w.isWebGLCubeRenderTarget
                ? ((re = ze[P]), (Me = !0))
                : Te.isWebGL2 && w.samples > 0 && Z.useMultisampledRTT(w) === !1
                ? (re = j.get(w).__webglMultisampledFramebuffer)
                : (re = ze),
                y.copy(w.viewport),
                C.copy(w.scissor),
                (U = w.scissorTest);
            } else
              y.copy(L).multiplyScalar(b).floor(),
                C.copy(B).multiplyScalar(b).floor(),
                (U = R);
            if (
              (ce.bindFramebuffer(36160, re) &&
                Te.drawBuffers &&
                q &&
                ce.drawBuffers(w, re),
              ce.viewport(y),
              ce.scissor(C),
              ce.setScissorTest(U),
              Me)
            ) {
              const ve = j.get(w.texture);
              $.framebufferTexture2D(
                36160,
                36064,
                34069 + P,
                ve.__webglTexture,
                z
              );
            } else if (xe) {
              const ve = j.get(w.texture),
                ze = P || 0;
              $.framebufferTextureLayer(
                36160,
                36064,
                ve.__webglTexture,
                z || 0,
                ze
              );
            }
            S = -1;
          }),
          (this.readRenderTargetPixels = function (w, P, z, q, re, Me, xe) {
            if (!(w && w.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let Ce = j.get(w).__webglFramebuffer;
            if (
              (w.isWebGLCubeRenderTarget && xe !== void 0 && (Ce = Ce[xe]), Ce)
            ) {
              ce.bindFramebuffer(36160, Ce);
              try {
                const ve = w.texture,
                  ze = ve.format,
                  Ae = ve.type;
                if (ze !== Dn && k.convert(ze) !== $.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                const Oe =
                  Ae === os &&
                  (Re.has("EXT_color_buffer_half_float") ||
                    (Te.isWebGL2 && Re.has("EXT_color_buffer_float")));
                if (
                  Ae !== rr &&
                  k.convert(Ae) !== $.getParameter(35738) &&
                  !(
                    Ae === Qi &&
                    (Te.isWebGL2 ||
                      Re.has("OES_texture_float") ||
                      Re.has("WEBGL_color_buffer_float"))
                  ) &&
                  !Oe
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                P >= 0 &&
                  P <= w.width - q &&
                  z >= 0 &&
                  z <= w.height - re &&
                  $.readPixels(P, z, q, re, k.convert(ze), k.convert(Ae), Me);
              } finally {
                const ve = M !== null ? j.get(M).__webglFramebuffer : null;
                ce.bindFramebuffer(36160, ve);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (w, P, z = 0) {
            if (P.isFramebufferTexture !== !0) {
              console.error(
                "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
              );
              return;
            }
            const q = Math.pow(2, -z),
              re = Math.floor(P.image.width * q),
              Me = Math.floor(P.image.height * q);
            Z.setTexture2D(P, 0),
              $.copyTexSubImage2D(3553, z, 0, 0, w.x, w.y, re, Me),
              ce.unbindTexture();
          }),
          (this.copyTextureToTexture = function (w, P, z, q = 0) {
            const re = P.image.width,
              Me = P.image.height,
              xe = k.convert(z.format),
              Ce = k.convert(z.type);
            Z.setTexture2D(z, 0),
              $.pixelStorei(37440, z.flipY),
              $.pixelStorei(37441, z.premultiplyAlpha),
              $.pixelStorei(3317, z.unpackAlignment),
              P.isDataTexture
                ? $.texSubImage2D(
                    3553,
                    q,
                    w.x,
                    w.y,
                    re,
                    Me,
                    xe,
                    Ce,
                    P.image.data
                  )
                : P.isCompressedTexture
                ? $.compressedTexSubImage2D(
                    3553,
                    q,
                    w.x,
                    w.y,
                    P.mipmaps[0].width,
                    P.mipmaps[0].height,
                    xe,
                    P.mipmaps[0].data
                  )
                : $.texSubImage2D(3553, q, w.x, w.y, xe, Ce, P.image),
              q === 0 && z.generateMipmaps && $.generateMipmap(3553),
              ce.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (w, P, z, q, re = 0) {
            if (p.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            const Me = w.max.x - w.min.x + 1,
              xe = w.max.y - w.min.y + 1,
              Ce = w.max.z - w.min.z + 1,
              ve = k.convert(q.format),
              ze = k.convert(q.type);
            let Ae;
            if (q.isData3DTexture) Z.setTexture3D(q, 0), (Ae = 32879);
            else if (q.isDataArrayTexture)
              Z.setTexture2DArray(q, 0), (Ae = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            $.pixelStorei(37440, q.flipY),
              $.pixelStorei(37441, q.premultiplyAlpha),
              $.pixelStorei(3317, q.unpackAlignment);
            const Oe = $.getParameter(3314),
              Ze = $.getParameter(32878),
              mt = $.getParameter(3316),
              Qt = $.getParameter(3315),
              at = $.getParameter(32877),
              Et = z.isCompressedTexture ? z.mipmaps[0] : z.image;
            $.pixelStorei(3314, Et.width),
              $.pixelStorei(32878, Et.height),
              $.pixelStorei(3316, w.min.x),
              $.pixelStorei(3315, w.min.y),
              $.pixelStorei(32877, w.min.z),
              z.isDataTexture || z.isData3DTexture
                ? $.texSubImage3D(
                    Ae,
                    re,
                    P.x,
                    P.y,
                    P.z,
                    Me,
                    xe,
                    Ce,
                    ve,
                    ze,
                    Et.data
                  )
                : z.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  $.compressedTexSubImage3D(
                    Ae,
                    re,
                    P.x,
                    P.y,
                    P.z,
                    Me,
                    xe,
                    Ce,
                    ve,
                    Et.data
                  ))
                : $.texSubImage3D(
                    Ae,
                    re,
                    P.x,
                    P.y,
                    P.z,
                    Me,
                    xe,
                    Ce,
                    ve,
                    ze,
                    Et
                  ),
              $.pixelStorei(3314, Oe),
              $.pixelStorei(32878, Ze),
              $.pixelStorei(3316, mt),
              $.pixelStorei(3315, Qt),
              $.pixelStorei(32877, at),
              re === 0 && q.generateMipmaps && $.generateMipmap(Ae),
              ce.unbindTexture();
          }),
          (this.initTexture = function (w) {
            Z.setTexture2D(w, 0), ce.unbindTexture();
          }),
          (this.resetState = function () {
            (x = 0), (_ = 0), (M = null), ce.reset(), ge.reset();
          }),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      nt.prototype.isWebGLRenderer = !0;
      class ZL extends nt {}
      ZL.prototype.isWebGL1Renderer = !0;
      class Tu extends tt {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ != "undefined" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
              (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
        }
      }
      Tu.prototype.isScene = !0;
      class Xo {
        constructor(e, t) {
          (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = zo),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Vn());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = Vn()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = Vn()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Xo.prototype.isInterleavedBuffer = !0;
      const jt = new W();
      class Uo {
        constructor(e, t, n, i = !1) {
          (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i === !0);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            jt.fromBufferAttribute(this, t),
              jt.applyMatrix4(e),
              this.setXYZ(t, jt.x, jt.y, jt.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            jt.fromBufferAttribute(this, t),
              jt.applyNormalMatrix(e),
              this.setXYZ(t, jt.x, jt.y, jt.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            jt.fromBufferAttribute(this, t),
              jt.transformDirection(e),
              this.setXYZ(t, jt.x, jt.y, jt.z);
          return this;
        }
        setX(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset] = t), this
          );
        }
        setY(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 1] = t), this
          );
        }
        setZ(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 2] = t), this
          );
        }
        setW(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 3] = t), this
          );
        }
        getX(e) {
          return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
          return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
          return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
          return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return new St(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Uo(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
        }
      }
      Uo.prototype.isInterleavedBufferAttribute = !0;
      class Eu extends Tt {
        constructor(e) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new Ve(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        }
      }
      Eu.prototype.isSpriteMaterial = !0;
      let Wr;
      const io = new W(),
        $r = new W(),
        qr = new W(),
        Xr = new ye(),
        ro = new ye(),
        vg = new We(),
        Xa = new W(),
        so = new W(),
        ja = new W(),
        yp = new ye(),
        sh = new ye(),
        Mp = new ye();
      class JL extends tt {
        constructor(e) {
          if ((super(), (this.type = "Sprite"), Wr === void 0)) {
            Wr = new pt();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              n = new Xo(t, 5);
            Wr.setIndex([0, 1, 2, 0, 2, 3]),
              Wr.setAttribute("position", new Uo(n, 3, 0, !1)),
              Wr.setAttribute("uv", new Uo(n, 2, 3, !1));
          }
          (this.geometry = Wr),
            (this.material = e !== void 0 ? e : new Eu()),
            (this.center = new ye(0.5, 0.5));
        }
        raycast(e, t) {
          e.camera === null &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            $r.setFromMatrixScale(this.matrixWorld),
            vg.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            qr.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              this.material.sizeAttenuation === !1 &&
              $r.multiplyScalar(-qr.z);
          const n = this.material.rotation;
          let i, r;
          n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
          const o = this.center;
          Ya(Xa.set(-0.5, -0.5, 0), qr, o, $r, i, r),
            Ya(so.set(0.5, -0.5, 0), qr, o, $r, i, r),
            Ya(ja.set(0.5, 0.5, 0), qr, o, $r, i, r),
            yp.set(0, 0),
            sh.set(1, 0),
            Mp.set(1, 1);
          let a = e.ray.intersectTriangle(Xa, so, ja, !1, io);
          if (
            a === null &&
            (Ya(so.set(-0.5, 0.5, 0), qr, o, $r, i, r),
            sh.set(0, 1),
            (a = e.ray.intersectTriangle(Xa, ja, so, !1, io)),
            a === null)
          )
            return;
          const l = e.ray.origin.distanceTo(io);
          l < e.near ||
            l > e.far ||
            t.push({
              distance: l,
              point: io.clone(),
              uv: Mt.getUV(io, Xa, so, ja, yp, sh, Mp, new ye()),
              face: null,
              object: this,
            });
        }
        copy(e) {
          return (
            super.copy(e),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        }
      }
      JL.prototype.isSprite = !0;
      function Ya(s, e, t, n, i, r) {
        Xr.subVectors(s, t).addScalar(0.5).multiply(n),
          i !== void 0
            ? ((ro.x = r * Xr.x - i * Xr.y), (ro.y = i * Xr.x + r * Xr.y))
            : ro.copy(Xr),
          s.copy(e),
          (s.x += ro.x),
          (s.y += ro.y),
          s.applyMatrix4(vg);
      }
      const bp = new W(),
        wp = new st(),
        Sp = new st(),
        KL = new W(),
        Tp = new We();
      class yg extends on {
        constructor(e, t) {
          super(e, t),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new We()),
            (this.bindMatrixInverse = new We());
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new st(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === "attached"
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === "detached"
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          wp.fromBufferAttribute(i.attributes.skinIndex, e),
            Sp.fromBufferAttribute(i.attributes.skinWeight, e),
            bp.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const o = Sp.getComponent(r);
            if (o !== 0) {
              const a = wp.getComponent(r);
              Tp.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(KL.copy(bp).applyMatrix4(Tp), o);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      yg.prototype.isSkinnedMesh = !0;
      class QL extends tt {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      QL.prototype.isBone = !0;
      class eR extends Nt {
        constructor(
          e = null,
          t = 1,
          n = 1,
          i,
          r,
          o,
          a,
          l,
          c = Ct,
          h = Ct,
          u,
          d
        ) {
          super(null, o, a, l, c, h, i, r, u, d),
            (this.image = { data: e, width: t, height: n }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      eR.prototype.isDataTexture = !0;
      class Bh extends St {
        constructor(e, t, n, i = 1) {
          typeof n == "number" &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(e, t, n),
            (this.meshPerAttribute = i);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      Bh.prototype.isInstancedBufferAttribute = !0;
      const Ep = new We(),
        Ap = new We(),
        Za = [],
        oo = new on();
      class tR extends on {
        constructor(e, t, n) {
          super(e, t),
            (this.instanceMatrix = new Bh(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(e) {
          return (
            super.copy(e),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((oo.geometry = this.geometry),
            (oo.material = this.material),
            oo.material !== void 0)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, Ep),
                Ap.multiplyMatrices(n, Ep),
                (oo.matrixWorld = Ap),
                oo.raycast(e, Za);
              for (let o = 0, a = Za.length; o < a; o++) {
                const l = Za[o];
                (l.instanceId = r), (l.object = this), t.push(l);
              }
              Za.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null &&
            (this.instanceColor = new Bh(
              new Float32Array(this.instanceMatrix.count * 3),
              3
            )),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      tR.prototype.isInstancedMesh = !0;
      class Ns extends Tt {
        constructor(e) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new Ve(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            this
          );
        }
      }
      Ns.prototype.isLineBasicMaterial = !0;
      const Lp = new W(),
        Rp = new W(),
        Cp = new We(),
        oh = new Ds(),
        Ja = new Ps();
      class Au extends tt {
        constructor(e = new pt(), t = new Ns()) {
          super(),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [0];
              for (let i = 1, r = t.count; i < r; i++)
                Lp.fromBufferAttribute(t, i - 1),
                  Rp.fromBufferAttribute(t, i),
                  (n[i] = n[i - 1]),
                  (n[i] += Lp.distanceTo(Rp));
              e.setAttribute("lineDistance", new Dt(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Ja.copy(n.boundingSphere),
            Ja.applyMatrix4(i),
            (Ja.radius += r),
            e.ray.intersectsSphere(Ja) === !1)
          )
            return;
          Cp.copy(i).invert(), oh.copy(e.ray).applyMatrix4(Cp);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new W(),
            h = new W(),
            u = new W(),
            d = new W(),
            f = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const m = n.index,
              g = n.attributes.position;
            if (m !== null) {
              const x = Math.max(0, o.start),
                _ = Math.min(m.count, o.start + o.count);
              for (let M = x, S = _ - 1; M < S; M += f) {
                const v = m.getX(M),
                  y = m.getX(M + 1);
                if (
                  (c.fromBufferAttribute(g, v),
                  h.fromBufferAttribute(g, y),
                  oh.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const U = e.ray.origin.distanceTo(d);
                U < e.near ||
                  U > e.far ||
                  t.push({
                    distance: U,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const x = Math.max(0, o.start),
                _ = Math.min(g.count, o.start + o.count);
              for (let M = x, S = _ - 1; M < S; M += f) {
                if (
                  (c.fromBufferAttribute(g, M),
                  h.fromBufferAttribute(g, M + 1),
                  oh.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const y = e.ray.origin.distanceTo(d);
                y < e.near ||
                  y > e.far ||
                  t.push({
                    distance: y,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Au.prototype.isLine = !0;
      const Pp = new W(),
        Dp = new W();
      class Lu extends Au {
        constructor(e, t) {
          super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [];
              for (let i = 0, r = t.count; i < r; i += 2)
                Pp.fromBufferAttribute(t, i),
                  Dp.fromBufferAttribute(t, i + 1),
                  (n[i] = i === 0 ? 0 : n[i - 1]),
                  (n[i + 1] = n[i] + Pp.distanceTo(Dp));
              e.setAttribute("lineDistance", new Dt(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      Lu.prototype.isLineSegments = !0;
      class nR extends Au {
        constructor(e, t) {
          super(e, t), (this.type = "LineLoop");
        }
      }
      nR.prototype.isLineLoop = !0;
      class Ru extends Tt {
        constructor(e) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new Ve(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        }
      }
      Ru.prototype.isPointsMaterial = !0;
      const Ip = new We(),
        zh = new Ds(),
        Ka = new Ps(),
        Qa = new W();
      class iR extends tt {
        constructor(e = new pt(), t = new Ru()) {
          super(),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Ka.copy(n.boundingSphere),
            Ka.applyMatrix4(i),
            (Ka.radius += r),
            e.ray.intersectsSphere(Ka) === !1)
          )
            return;
          Ip.copy(i).invert(), zh.copy(e.ray).applyMatrix4(Ip);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a;
          if (n.isBufferGeometry) {
            const c = n.index,
              u = n.attributes.position;
            if (c !== null) {
              const d = Math.max(0, o.start),
                f = Math.min(c.count, o.start + o.count);
              for (let m = d, p = f; m < p; m++) {
                const g = c.getX(m);
                Qa.fromBufferAttribute(u, g), Np(Qa, g, l, i, e, t, this);
              }
            } else {
              const d = Math.max(0, o.start),
                f = Math.min(u.count, o.start + o.count);
              for (let m = d, p = f; m < p; m++)
                Qa.fromBufferAttribute(u, m), Np(Qa, m, l, i, e, t, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      iR.prototype.isPoints = !0;
      function Np(s, e, t, n, i, r, o) {
        const a = zh.distanceSqToPoint(s);
        if (a < t) {
          const l = new W();
          zh.closestPointToPoint(s, l), l.applyMatrix4(n);
          const c = i.ray.origin.distanceTo(l);
          if (c < i.near || c > i.far) return;
          r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      class rR extends Nt {
        constructor(e, t, n, i, r, o, a, l, c) {
          super(e, t, n, i, r, o, a, l, c),
            (this.minFilter = o !== void 0 ? o : nn),
            (this.magFilter = r !== void 0 ? r : nn),
            (this.generateMipmaps = !1);
          const h = this;
          function u() {
            (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
          }
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      rR.prototype.isVideoTexture = !0;
      class sR extends Nt {
        constructor(e, t, n) {
          super({ width: e, height: t }),
            (this.format = n),
            (this.magFilter = Ct),
            (this.minFilter = Ct),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
        }
      }
      sR.prototype.isFramebufferTexture = !0;
      class oR extends Nt {
        constructor(e, t, n, i, r, o, a, l, c, h, u, d) {
          super(null, o, a, l, c, h, i, r, u, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      oR.prototype.isCompressedTexture = !0;
      class aR extends Nt {
        constructor(e, t, n, i, r, o, a, l, c) {
          super(e, t, n, i, r, o, a, l, c), (this.needsUpdate = !0);
        }
      }
      aR.prototype.isCanvasTexture = !0;
      class Mn {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let o = 1; o <= e; o++)
            (n = this.getPoint(o / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let o;
          t ? (o = t) : (o = e * n[r - 1]);
          let a = 0,
            l = r - 1,
            c;
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - o), c < 0))
              a = i + 1;
            else if (c > 0) l = i - 1;
            else {
              l = i;
              break;
            }
          if (((i = l), n[i] === o)) return i / (r - 1);
          const h = n[i],
            d = n[i + 1] - h,
            f = (o - h) / d;
          return (i + f) / (r - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4,
            r = e + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const o = this.getPoint(i),
            a = this.getPoint(r),
            l = t || (o.isVector2 ? new ye() : new W());
          return l.copy(a).sub(o).normalize(), l;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new W(),
            i = [],
            r = [],
            o = [],
            a = new W(),
            l = new We();
          for (let f = 0; f <= e; f++) {
            const m = f / e;
            i[f] = this.getTangentAt(m, new W());
          }
          (r[0] = new W()), (o[0] = new W());
          let c = Number.MAX_VALUE;
          const h = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
          h <= c && ((c = h), n.set(1, 0, 0)),
            u <= c && ((c = u), n.set(0, 1, 0)),
            d <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], r[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((r[f] = r[f - 1].clone()),
              (o[f] = o[f - 1].clone()),
              a.crossVectors(i[f - 1], i[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const m = Math.acos($t(i[f - 1].dot(i[f]), -1, 1));
              r[f].applyMatrix4(l.makeRotationAxis(a, m));
            }
            o[f].crossVectors(i[f], r[f]);
          }
          if (t === !0) {
            let f = Math.acos($t(r[0].dot(r[e]), -1, 1));
            (f /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let m = 1; m <= e; m++)
              r[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)),
                o[m].crossVectors(i[m], r[m]);
          }
          return { tangents: i, normals: r, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class zl extends Mn {
        constructor(
          e = 0,
          t = 0,
          n = 1,
          i = 1,
          r = 0,
          o = Math.PI * 2,
          a = !1,
          l = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = o),
            (this.aClockwise = a),
            (this.aRotation = l);
        }
        getPoint(e, t) {
          const n = t || new ye(),
            i = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const o = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (o ? (r = 0) : (r = i)),
            this.aClockwise === !0 && !o && (r === i ? (r = -i) : (r = r - i));
          const a = this.aStartAngle + e * r;
          let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
          if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation),
              u = Math.sin(this.aRotation),
              d = l - this.aX,
              f = c - this.aY;
            (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
          }
          return n.set(l, c);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
      }
      zl.prototype.isEllipseCurve = !0;
      class Mg extends zl {
        constructor(e, t, n, i, r, o) {
          super(e, t, n, n, i, r, o), (this.type = "ArcCurve");
        }
      }
      Mg.prototype.isArcCurve = !0;
      function Cu() {
        let s = 0,
          e = 0,
          t = 0,
          n = 0;
        function i(r, o, a, l) {
          (s = r),
            (e = a),
            (t = -3 * r + 3 * o - 2 * a - l),
            (n = 2 * r - 2 * o + a + l);
        }
        return {
          initCatmullRom: function (r, o, a, l, c) {
            i(o, a, c * (a - r), c * (l - o));
          },
          initNonuniformCatmullRom: function (r, o, a, l, c, h, u) {
            let d = (o - r) / c - (a - r) / (c + h) + (a - o) / h,
              f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            (d *= h), (f *= h), i(o, a, d, f);
          },
          calc: function (r) {
            const o = r * r,
              a = o * r;
            return s + e * r + t * o + n * a;
          },
        };
      }
      const el = new W(),
        ah = new Cu(),
        lh = new Cu(),
        ch = new Cu();
      class bg extends Mn {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(e, t = new W()) {
          const n = t,
            i = this.points,
            r = i.length,
            o = (r - (this.closed ? 0 : 1)) * e;
          let a = Math.floor(o),
            l = o - a;
          this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r)
            : l === 0 && a === r - 1 && ((a = r - 2), (l = 1));
          let c, h;
          this.closed || a > 0
            ? (c = i[(a - 1) % r])
            : (el.subVectors(i[0], i[1]).add(i[0]), (c = el));
          const u = i[a % r],
            d = i[(a + 1) % r];
          if (
            (this.closed || a + 2 < r
              ? (h = i[(a + 2) % r])
              : (el.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (h = el)),
            this.curveType === "centripetal" || this.curveType === "chordal")
          ) {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let m = Math.pow(c.distanceToSquared(u), f),
              p = Math.pow(u.distanceToSquared(d), f),
              g = Math.pow(d.distanceToSquared(h), f);
            p < 1e-4 && (p = 1),
              m < 1e-4 && (m = p),
              g < 1e-4 && (g = p),
              ah.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, p, g),
              lh.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, p, g),
              ch.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, p, g);
          } else
            this.curveType === "catmullrom" &&
              (ah.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
              lh.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
              ch.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
          return n.set(ah.calc(l), lh.calc(l), ch.calc(l)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new W().fromArray(i));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
      }
      bg.prototype.isCatmullRomCurve3 = !0;
      function Fp(s, e, t, n, i) {
        const r = (n - e) * 0.5,
          o = (i - t) * 0.5,
          a = s * s,
          l = s * a;
        return (
          (2 * t - 2 * n + r + o) * l +
          (-3 * t + 3 * n - 2 * r - o) * a +
          r * s +
          t
        );
      }
      function lR(s, e) {
        const t = 1 - s;
        return t * t * e;
      }
      function cR(s, e) {
        return 2 * (1 - s) * s * e;
      }
      function hR(s, e) {
        return s * s * e;
      }
      function bo(s, e, t, n) {
        return lR(s, e) + cR(s, t) + hR(s, n);
      }
      function uR(s, e) {
        const t = 1 - s;
        return t * t * t * e;
      }
      function dR(s, e) {
        const t = 1 - s;
        return 3 * t * t * s * e;
      }
      function fR(s, e) {
        return 3 * (1 - s) * s * s * e;
      }
      function pR(s, e) {
        return s * s * s * e;
      }
      function wo(s, e, t, n, i) {
        return uR(s, e) + dR(s, t) + fR(s, n) + pR(s, i);
      }
      class Pu extends Mn {
        constructor(e = new ye(), t = new ye(), n = new ye(), i = new ye()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new ye()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return n.set(wo(e, i.x, r.x, o.x, a.x), wo(e, i.y, r.y, o.y, a.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      Pu.prototype.isCubicBezierCurve = !0;
      class wg extends Mn {
        constructor(e = new W(), t = new W(), n = new W(), i = new W()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new W()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return (
            n.set(
              wo(e, i.x, r.x, o.x, a.x),
              wo(e, i.y, r.y, o.y, a.y),
              wo(e, i.z, r.z, o.z, a.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      wg.prototype.isCubicBezierCurve3 = !0;
      class Ol extends Mn {
        constructor(e = new ye(), t = new ye()) {
          super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new ye()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const n = t || new ye();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Ol.prototype.isLineCurve = !0;
      class mR extends Mn {
        constructor(e = new W(), t = new W()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new W()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      class Du extends Mn {
        constructor(e = new ye(), t = new ye(), n = new ye()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new ye()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return n.set(bo(e, i.x, r.x, o.x), bo(e, i.y, r.y, o.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Du.prototype.isQuadraticBezierCurve = !0;
      class Sg extends Mn {
        constructor(e = new W(), t = new W(), n = new W()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new W()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return (
            n.set(
              bo(e, i.x, r.x, o.x),
              bo(e, i.y, r.y, o.y),
              bo(e, i.z, r.z, o.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Sg.prototype.isQuadraticBezierCurve3 = !0;
      class Iu extends Mn {
        constructor(e = []) {
          super(), (this.type = "SplineCurve"), (this.points = e);
        }
        getPoint(e, t = new ye()) {
          const n = t,
            i = this.points,
            r = (i.length - 1) * e,
            o = Math.floor(r),
            a = r - o,
            l = i[o === 0 ? o : o - 1],
            c = i[o],
            h = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
          return n.set(Fp(a, l.x, c.x, h.x, u.x), Fp(a, l.y, c.y, h.y, u.y)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new ye().fromArray(i));
          }
          return this;
        }
      }
      Iu.prototype.isSplineCurve = !0;
      var Tg = Object.freeze({
        __proto__: null,
        ArcCurve: Mg,
        CatmullRomCurve3: bg,
        CubicBezierCurve: Pu,
        CubicBezierCurve3: wg,
        EllipseCurve: zl,
        LineCurve: Ol,
        LineCurve3: mR,
        QuadraticBezierCurve: Du,
        QuadraticBezierCurve3: Sg,
        SplineCurve: Iu,
      });
      class gR extends Mn {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new Ol(t, e));
        }
        getPoint(e, t) {
          const n = e * this.getLength(),
            i = this.getCurveLengths();
          let r = 0;
          for (; r < i.length; ) {
            if (i[r] >= n) {
              const o = i[r] - n,
                a = this.curves[r],
                l = a.getLength(),
                c = l === 0 ? 0 : 1 - o / l;
              return a.getPointAt(c, t);
            }
            r++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const o = r[i],
              a = o.isEllipseCurve
                ? e * 2
                : o.isLineCurve || o.isLineCurve3
                ? 1
                : o.isSplineCurve
                ? e * o.points.length
                : e,
              l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
              const h = l[c];
              (n && n.equals(h)) || (t.push(h), (n = h));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        }
        copy(e) {
          super.copy(e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone());
          }
          return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Tg[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class Oh extends gR {
        constructor(e) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new ye()),
            e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const n = new Ol(this.currentPoint.clone(), new ye(e, t));
          return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          const r = new Du(
            this.currentPoint.clone(),
            new ye(e, t),
            new ye(n, i)
          );
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, o) {
          const a = new Pu(
            this.currentPoint.clone(),
            new ye(e, t),
            new ye(n, i),
            new ye(r, o)
          );
          return this.curves.push(a), this.currentPoint.set(r, o), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            n = new Iu(t);
          return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
          );
        }
        arc(e, t, n, i, r, o) {
          const a = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absarc(e + a, t + l, n, i, r, o), this;
        }
        absarc(e, t, n, i, r, o) {
          return this.absellipse(e, t, n, n, i, r, o), this;
        }
        ellipse(e, t, n, i, r, o, a, l) {
          const c = this.currentPoint.x,
            h = this.currentPoint.y;
          return this.absellipse(e + c, t + h, n, i, r, o, a, l), this;
        }
        absellipse(e, t, n, i, r, o, a, l) {
          const c = new zl(e, t, n, i, r, o, a, l);
          if (this.curves.length > 0) {
            const u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
          }
          this.curves.push(c);
          const h = c.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
          );
        }
      }
      new W();
      new W();
      new W();
      new Mt();
      class jo extends Oh {
        constructor(e) {
          super(e),
            (this.uuid = Vn()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(e) {
          const t = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
          super.copy(e), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.uuid = this.uuid), (e.holes = []);
          for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new Oh().fromJSON(i));
          }
          return this;
        }
      }
      const xR = {
        triangulate: function (s, e, t = 2) {
          const n = e && e.length,
            i = n ? e[0] * t : s.length;
          let r = Eg(s, 0, i, t, !0);
          const o = [];
          if (!r || r.next === r.prev) return o;
          let a, l, c, h, u, d, f;
          if ((n && (r = bR(s, e, r, t)), s.length > 80 * t)) {
            (a = c = s[0]), (l = h = s[1]);
            for (let m = t; m < i; m += t)
              (u = s[m]),
                (d = s[m + 1]),
                u < a && (a = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            (f = Math.max(c - a, h - l)), (f = f !== 0 ? 1 / f : 0);
          }
          return Ho(r, o, t, a, l, f), o;
        },
      };
      function Eg(s, e, t, n, i) {
        let r, o;
        if (i === IR(s, e, t, n) > 0)
          for (r = e; r < t; r += n) o = Bp(r, s[r], s[r + 1], o);
        else for (r = t - n; r >= e; r -= n) o = Bp(r, s[r], s[r + 1], o);
        return o && Ul(o, o.next) && (Vo(o), (o = o.next)), o;
      }
      function Gi(s, e) {
        if (!s) return s;
        e || (e = s);
        let t = s,
          n;
        do
          if (
            ((n = !1),
            !t.steiner && (Ul(t, t.next) || xt(t.prev, t, t.next) === 0))
          ) {
            if ((Vo(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
          } else t = t.next;
        while (n || t !== e);
        return e;
      }
      function Ho(s, e, t, n, i, r, o) {
        if (!s) return;
        !o && r && AR(s, n, i, r);
        let a = s,
          l,
          c;
        for (; s.prev !== s.next; ) {
          if (((l = s.prev), (c = s.next), r ? vR(s, n, i, r) : _R(s))) {
            e.push(l.i / t),
              e.push(s.i / t),
              e.push(c.i / t),
              Vo(s),
              (s = c.next),
              (a = c.next);
            continue;
          }
          if (((s = c), s === a)) {
            o
              ? o === 1
                ? ((s = yR(Gi(s), e, t)), Ho(s, e, t, n, i, r, 2))
                : o === 2 && MR(s, e, t, n, i, r)
              : Ho(Gi(s), e, t, n, i, r, 1);
            break;
          }
        }
      }
      function _R(s) {
        const e = s.prev,
          t = s,
          n = s.next;
        if (xt(e, t, n) >= 0) return !1;
        let i = s.next.next;
        for (; i !== s.prev; ) {
          if (
            ns(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            xt(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function vR(s, e, t, n) {
        const i = s.prev,
          r = s,
          o = s.next;
        if (xt(i, r, o) >= 0) return !1;
        const a = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
          l = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
          c = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
          h = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
          u = Uh(a, l, e, t, n),
          d = Uh(c, h, e, t, n);
        let f = s.prevZ,
          m = s.nextZ;
        for (; f && f.z >= u && m && m.z <= d; ) {
          if (
            (f !== s.prev &&
              f !== s.next &&
              ns(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
              xt(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            m !== s.prev &&
              m !== s.next &&
              ns(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
              xt(m.prev, m, m.next) >= 0)
          )
            return !1;
          m = m.nextZ;
        }
        for (; f && f.z >= u; ) {
          if (
            f !== s.prev &&
            f !== s.next &&
            ns(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
            xt(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; m && m.z <= d; ) {
          if (
            m !== s.prev &&
            m !== s.next &&
            ns(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
            xt(m.prev, m, m.next) >= 0
          )
            return !1;
          m = m.nextZ;
        }
        return !0;
      }
      function yR(s, e, t) {
        let n = s;
        do {
          const i = n.prev,
            r = n.next.next;
          !Ul(i, r) &&
            Ag(i, n, n.next, r) &&
            Go(i, r) &&
            Go(r, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(r.i / t),
            Vo(n),
            Vo(n.next),
            (n = s = r)),
            (n = n.next);
        } while (n !== s);
        return Gi(n);
      }
      function MR(s, e, t, n, i, r) {
        let o = s;
        do {
          let a = o.next.next;
          for (; a !== o.prev; ) {
            if (o.i !== a.i && CR(o, a)) {
              let l = Lg(o, a);
              (o = Gi(o, o.next)),
                (l = Gi(l, l.next)),
                Ho(o, e, t, n, i, r),
                Ho(l, e, t, n, i, r);
              return;
            }
            a = a.next;
          }
          o = o.next;
        } while (o !== s);
      }
      function bR(s, e, t, n) {
        const i = [];
        let r, o, a, l, c;
        for (r = 0, o = e.length; r < o; r++)
          (a = e[r] * n),
            (l = r < o - 1 ? e[r + 1] * n : s.length),
            (c = Eg(s, a, l, n, !1)),
            c === c.next && (c.steiner = !0),
            i.push(RR(c));
        for (i.sort(wR), r = 0; r < i.length; r++)
          SR(i[r], t), (t = Gi(t, t.next));
        return t;
      }
      function wR(s, e) {
        return s.x - e.x;
      }
      function SR(s, e) {
        if (((e = TR(s, e)), e)) {
          const t = Lg(e, s);
          Gi(e, e.next), Gi(t, t.next);
        }
      }
      function TR(s, e) {
        let t = e;
        const n = s.x,
          i = s.y;
        let r = -1 / 0,
          o;
        do {
          if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > r) {
              if (((r = d), d === n)) {
                if (i === t.y) return t;
                if (i === t.next.y) return t.next;
              }
              o = t.x < t.next.x ? t : t.next;
            }
          }
          t = t.next;
        } while (t !== e);
        if (!o) return null;
        if (n === r) return o;
        const a = o,
          l = o.x,
          c = o.y;
        let h = 1 / 0,
          u;
        t = o;
        do
          n >= t.x &&
            t.x >= l &&
            n !== t.x &&
            ns(i < c ? n : r, i, l, c, i < c ? r : n, i, t.x, t.y) &&
            ((u = Math.abs(i - t.y) / (n - t.x)),
            Go(t, s) &&
              (u < h ||
                (u === h && (t.x > o.x || (t.x === o.x && ER(o, t))))) &&
              ((o = t), (h = u))),
            (t = t.next);
        while (t !== a);
        return o;
      }
      function ER(s, e) {
        return xt(s.prev, s, e.prev) < 0 && xt(e.next, s, s.next) < 0;
      }
      function AR(s, e, t, n) {
        let i = s;
        do
          i.z === null && (i.z = Uh(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
        while (i !== s);
        (i.prevZ.nextZ = null), (i.prevZ = null), LR(i);
      }
      function LR(s) {
        let e,
          t,
          n,
          i,
          r,
          o,
          a,
          l,
          c = 1;
        do {
          for (t = s, s = null, r = null, o = 0; t; ) {
            for (
              o++, n = t, a = 0, e = 0;
              e < c && (a++, (n = n.nextZ), !!n);
              e++
            );
            for (l = c; a > 0 || (l > 0 && n); )
              a !== 0 && (l === 0 || !n || t.z <= n.z)
                ? ((i = t), (t = t.nextZ), a--)
                : ((i = n), (n = n.nextZ), l--),
                r ? (r.nextZ = i) : (s = i),
                (i.prevZ = r),
                (r = i);
            t = n;
          }
          (r.nextZ = null), (c *= 2);
        } while (o > 1);
        return s;
      }
      function Uh(s, e, t, n, i) {
        return (
          (s = 32767 * (s - t) * i),
          (e = 32767 * (e - n) * i),
          (s = (s | (s << 8)) & 16711935),
          (s = (s | (s << 4)) & 252645135),
          (s = (s | (s << 2)) & 858993459),
          (s = (s | (s << 1)) & 1431655765),
          (e = (e | (e << 8)) & 16711935),
          (e = (e | (e << 4)) & 252645135),
          (e = (e | (e << 2)) & 858993459),
          (e = (e | (e << 1)) & 1431655765),
          s | (e << 1)
        );
      }
      function RR(s) {
        let e = s,
          t = s;
        do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
        while (e !== s);
        return t;
      }
      function ns(s, e, t, n, i, r, o, a) {
        return (
          (i - o) * (e - a) - (s - o) * (r - a) >= 0 &&
          (s - o) * (n - a) - (t - o) * (e - a) >= 0 &&
          (t - o) * (r - a) - (i - o) * (n - a) >= 0
        );
      }
      function CR(s, e) {
        return (
          s.next.i !== e.i &&
          s.prev.i !== e.i &&
          !PR(s, e) &&
          ((Go(s, e) &&
            Go(e, s) &&
            DR(s, e) &&
            (xt(s.prev, s, e.prev) || xt(s, e.prev, e))) ||
            (Ul(s, e) &&
              xt(s.prev, s, s.next) > 0 &&
              xt(e.prev, e, e.next) > 0))
        );
      }
      function xt(s, e, t) {
        return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
      }
      function Ul(s, e) {
        return s.x === e.x && s.y === e.y;
      }
      function Ag(s, e, t, n) {
        const i = nl(xt(s, e, t)),
          r = nl(xt(s, e, n)),
          o = nl(xt(t, n, s)),
          a = nl(xt(t, n, e));
        return !!(
          (i !== r && o !== a) ||
          (i === 0 && tl(s, t, e)) ||
          (r === 0 && tl(s, n, e)) ||
          (o === 0 && tl(t, s, n)) ||
          (a === 0 && tl(t, e, n))
        );
      }
      function tl(s, e, t) {
        return (
          e.x <= Math.max(s.x, t.x) &&
          e.x >= Math.min(s.x, t.x) &&
          e.y <= Math.max(s.y, t.y) &&
          e.y >= Math.min(s.y, t.y)
        );
      }
      function nl(s) {
        return s > 0 ? 1 : s < 0 ? -1 : 0;
      }
      function PR(s, e) {
        let t = s;
        do {
          if (
            t.i !== s.i &&
            t.next.i !== s.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            Ag(t, t.next, s, e)
          )
            return !0;
          t = t.next;
        } while (t !== s);
        return !1;
      }
      function Go(s, e) {
        return xt(s.prev, s, s.next) < 0
          ? xt(s, e, s.next) >= 0 && xt(s, s.prev, e) >= 0
          : xt(s, e, s.prev) < 0 || xt(s, s.next, e) < 0;
      }
      function DR(s, e) {
        let t = s,
          n = !1;
        const i = (s.x + e.x) / 2,
          r = (s.y + e.y) / 2;
        do
          t.y > r != t.next.y > r &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
        while (t !== s);
        return n;
      }
      function Lg(s, e) {
        const t = new Hh(s.i, s.x, s.y),
          n = new Hh(e.i, e.x, e.y),
          i = s.next,
          r = e.prev;
        return (
          (s.next = e),
          (e.prev = s),
          (t.next = i),
          (i.prev = t),
          (n.next = t),
          (t.prev = n),
          (r.next = n),
          (n.prev = r),
          n
        );
      }
      function Bp(s, e, t, n) {
        const i = new Hh(s, e, t);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function Vo(s) {
        (s.next.prev = s.prev),
          (s.prev.next = s.next),
          s.prevZ && (s.prevZ.nextZ = s.nextZ),
          s.nextZ && (s.nextZ.prevZ = s.prevZ);
      }
      function Hh(s, e, t) {
        (this.i = s),
          (this.x = e),
          (this.y = t),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function IR(s, e, t, n) {
        let i = 0;
        for (let r = e, o = t - n; r < t; r += n)
          (i += (s[o] - s[r]) * (s[r + 1] + s[o + 1])), (o = r);
        return i;
      }
      class Ui {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return n * 0.5;
        }
        static isClockWise(e) {
          return Ui.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          zp(e), Op(n, e);
          let o = e.length;
          t.forEach(zp);
          for (let l = 0; l < t.length; l++)
            i.push(o), (o += t[l].length), Op(n, t[l]);
          const a = xR.triangulate(n, i);
          for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
          return r;
        }
      }
      function zp(s) {
        const e = s.length;
        e > 2 && s[e - 1].equals(s[0]) && s.pop();
      }
      function Op(s, e) {
        for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
      }
      class Fs extends pt {
        constructor(
          e = new jo([
            new ye(0.5, 0.5),
            new ye(-0.5, 0.5),
            new ye(-0.5, -0.5),
            new ye(0.5, -0.5),
          ]),
          t = {}
        ) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            r = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c);
          }
          this.setAttribute("position", new Dt(i, 3)),
            this.setAttribute("uv", new Dt(r, 2)),
            this.computeVertexNormals();
          function o(a) {
            const l = [],
              c = t.curveSegments !== void 0 ? t.curveSegments : 12,
              h = t.steps !== void 0 ? t.steps : 1;
            let u = t.depth !== void 0 ? t.depth : 1,
              d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
              f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
              m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
              p = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
              g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const x = t.extrudePath,
              _ = t.UVGenerator !== void 0 ? t.UVGenerator : NR;
            t.amount !== void 0 &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (u = t.amount));
            let M,
              S = !1,
              v,
              y,
              C,
              U;
            x &&
              ((M = x.getSpacedPoints(h)),
              (S = !0),
              (d = !1),
              (v = x.computeFrenetFrames(h, !1)),
              (y = new W()),
              (C = new W()),
              (U = new W())),
              d || ((g = 0), (f = 0), (m = 0), (p = 0));
            const K = a.extractPoints(c);
            let X = K.shape;
            const b = K.holes;
            if (!Ui.isClockWise(X)) {
              X = X.reverse();
              for (let j = 0, Z = b.length; j < Z; j++) {
                const te = b[j];
                Ui.isClockWise(te) && (b[j] = te.reverse());
              }
            }
            const I = Ui.triangulateShape(X, b),
              L = X;
            for (let j = 0, Z = b.length; j < Z; j++) {
              const te = b[j];
              X = X.concat(te);
            }
            function B(j, Z, te) {
              return (
                Z || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Z.clone().multiplyScalar(te).add(j)
              );
            }
            const R = X.length,
              V = I.length;
            function H(j, Z, te) {
              let de, se, N;
              const E = j.x - Z.x,
                ee = j.y - Z.y,
                ue = te.x - j.x,
                me = te.y - j.y,
                A = E * E + ee * ee,
                T = E * me - ee * ue;
              if (Math.abs(T) > Number.EPSILON) {
                const Q = Math.sqrt(A),
                  oe = Math.sqrt(ue * ue + me * me),
                  he = Z.x - ee / Q,
                  O = Z.y + E / Q,
                  le = te.x - me / oe,
                  k = te.y + ue / oe,
                  ge = ((le - he) * me - (k - O) * ue) / (E * me - ee * ue);
                (de = he + E * ge - j.x), (se = O + ee * ge - j.y);
                const pe = de * de + se * se;
                if (pe <= 2) return new ye(de, se);
                N = Math.sqrt(pe / 2);
              } else {
                let Q = !1;
                E > Number.EPSILON
                  ? ue > Number.EPSILON && (Q = !0)
                  : E < -Number.EPSILON
                  ? ue < -Number.EPSILON && (Q = !0)
                  : Math.sign(ee) === Math.sign(me) && (Q = !0),
                  Q
                    ? ((de = -ee), (se = E), (N = Math.sqrt(A)))
                    : ((de = E), (se = ee), (N = Math.sqrt(A / 2)));
              }
              return new ye(de / N, se / N);
            }
            const J = [];
            for (
              let j = 0, Z = L.length, te = Z - 1, de = j + 1;
              j < Z;
              j++, te++, de++
            )
              te === Z && (te = 0),
                de === Z && (de = 0),
                (J[j] = H(L[j], L[te], L[de]));
            const ie = [];
            let ne,
              ae = J.concat();
            for (let j = 0, Z = b.length; j < Z; j++) {
              const te = b[j];
              ne = [];
              for (
                let de = 0, se = te.length, N = se - 1, E = de + 1;
                de < se;
                de++, N++, E++
              )
                N === se && (N = 0),
                  E === se && (E = 0),
                  (ne[de] = H(te[de], te[N], te[E]));
              ie.push(ne), (ae = ae.concat(ne));
            }
            for (let j = 0; j < g; j++) {
              const Z = j / g,
                te = f * Math.cos((Z * Math.PI) / 2),
                de = m * Math.sin((Z * Math.PI) / 2) + p;
              for (let se = 0, N = L.length; se < N; se++) {
                const E = B(L[se], J[se], de);
                ke(E.x, E.y, -te);
              }
              for (let se = 0, N = b.length; se < N; se++) {
                const E = b[se];
                ne = ie[se];
                for (let ee = 0, ue = E.length; ee < ue; ee++) {
                  const me = B(E[ee], ne[ee], de);
                  ke(me.x, me.y, -te);
                }
              }
            }
            const fe = m + p;
            for (let j = 0; j < R; j++) {
              const Z = d ? B(X[j], ae[j], fe) : X[j];
              S
                ? (C.copy(v.normals[0]).multiplyScalar(Z.x),
                  y.copy(v.binormals[0]).multiplyScalar(Z.y),
                  U.copy(M[0]).add(C).add(y),
                  ke(U.x, U.y, U.z))
                : ke(Z.x, Z.y, 0);
            }
            for (let j = 1; j <= h; j++)
              for (let Z = 0; Z < R; Z++) {
                const te = d ? B(X[Z], ae[Z], fe) : X[Z];
                S
                  ? (C.copy(v.normals[j]).multiplyScalar(te.x),
                    y.copy(v.binormals[j]).multiplyScalar(te.y),
                    U.copy(M[j]).add(C).add(y),
                    ke(U.x, U.y, U.z))
                  : ke(te.x, te.y, (u / h) * j);
              }
            for (let j = g - 1; j >= 0; j--) {
              const Z = j / g,
                te = f * Math.cos((Z * Math.PI) / 2),
                de = m * Math.sin((Z * Math.PI) / 2) + p;
              for (let se = 0, N = L.length; se < N; se++) {
                const E = B(L[se], J[se], de);
                ke(E.x, E.y, u + te);
              }
              for (let se = 0, N = b.length; se < N; se++) {
                const E = b[se];
                ne = ie[se];
                for (let ee = 0, ue = E.length; ee < ue; ee++) {
                  const me = B(E[ee], ne[ee], de);
                  S
                    ? ke(me.x, me.y + M[h - 1].y, M[h - 1].x + te)
                    : ke(me.x, me.y, u + te);
                }
              }
            }
            Fe(), Ee();
            function Fe() {
              const j = i.length / 3;
              if (d) {
                let Z = 0,
                  te = R * Z;
                for (let de = 0; de < V; de++) {
                  const se = I[de];
                  Re(se[2] + te, se[1] + te, se[0] + te);
                }
                (Z = h + g * 2), (te = R * Z);
                for (let de = 0; de < V; de++) {
                  const se = I[de];
                  Re(se[0] + te, se[1] + te, se[2] + te);
                }
              } else {
                for (let Z = 0; Z < V; Z++) {
                  const te = I[Z];
                  Re(te[2], te[1], te[0]);
                }
                for (let Z = 0; Z < V; Z++) {
                  const te = I[Z];
                  Re(te[0] + R * h, te[1] + R * h, te[2] + R * h);
                }
              }
              n.addGroup(j, i.length / 3 - j, 0);
            }
            function Ee() {
              const j = i.length / 3;
              let Z = 0;
              $(L, Z), (Z += L.length);
              for (let te = 0, de = b.length; te < de; te++) {
                const se = b[te];
                $(se, Z), (Z += se.length);
              }
              n.addGroup(j, i.length / 3 - j, 1);
            }
            function $(j, Z) {
              let te = j.length;
              for (; --te >= 0; ) {
                const de = te;
                let se = te - 1;
                se < 0 && (se = j.length - 1);
                for (let N = 0, E = h + g * 2; N < E; N++) {
                  const ee = R * N,
                    ue = R * (N + 1),
                    me = Z + de + ee,
                    A = Z + se + ee,
                    T = Z + se + ue,
                    Q = Z + de + ue;
                  Te(me, A, T, Q);
                }
              }
            }
            function ke(j, Z, te) {
              l.push(j), l.push(Z), l.push(te);
            }
            function Re(j, Z, te) {
              ce(j), ce(Z), ce(te);
              const de = i.length / 3,
                se = _.generateTopUV(n, i, de - 3, de - 2, de - 1);
              Ie(se[0]), Ie(se[1]), Ie(se[2]);
            }
            function Te(j, Z, te, de) {
              ce(j), ce(Z), ce(de), ce(Z), ce(te), ce(de);
              const se = i.length / 3,
                N = _.generateSideWallUV(n, i, se - 6, se - 3, se - 2, se - 1);
              Ie(N[0]), Ie(N[1]), Ie(N[3]), Ie(N[1]), Ie(N[2]), Ie(N[3]);
            }
            function ce(j) {
              i.push(l[j * 3 + 0]), i.push(l[j * 3 + 1]), i.push(l[j * 3 + 2]);
            }
            function Ie(j) {
              r.push(j.x), r.push(j.y);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
          return FR(t, n, e);
        }
        static fromJSON(e, t) {
          const n = [];
          for (let r = 0, o = e.shapes.length; r < o; r++) {
            const a = t[e.shapes[r]];
            n.push(a);
          }
          const i = e.options.extrudePath;
          return (
            i !== void 0 &&
              (e.options.extrudePath = new Tg[i.type]().fromJSON(i)),
            new Fs(n, e.options)
          );
        }
      }
      const NR = {
        generateTopUV: function (s, e, t, n, i) {
          const r = e[t * 3],
            o = e[t * 3 + 1],
            a = e[n * 3],
            l = e[n * 3 + 1],
            c = e[i * 3],
            h = e[i * 3 + 1];
          return [new ye(r, o), new ye(a, l), new ye(c, h)];
        },
        generateSideWallUV: function (s, e, t, n, i, r) {
          const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[n * 3],
            h = e[n * 3 + 1],
            u = e[n * 3 + 2],
            d = e[i * 3],
            f = e[i * 3 + 1],
            m = e[i * 3 + 2],
            p = e[r * 3],
            g = e[r * 3 + 1],
            x = e[r * 3 + 2];
          return Math.abs(a - h) < Math.abs(o - c)
            ? [
                new ye(o, 1 - l),
                new ye(c, 1 - u),
                new ye(d, 1 - m),
                new ye(p, 1 - x),
              ]
            : [
                new ye(a, 1 - l),
                new ye(h, 1 - u),
                new ye(f, 1 - m),
                new ye(g, 1 - x),
              ];
        },
      };
      function FR(s, e, t) {
        if (((t.shapes = []), Array.isArray(s)))
          for (let n = 0, i = s.length; n < i; n++) {
            const r = s[n];
            t.shapes.push(r.uuid);
          }
        else t.shapes.push(s.uuid);
        return (
          e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
          t
        );
      }
      class Nu extends pt {
        constructor(
          e = new jo([new ye(0, 0.5), new ye(-0.5, -0.5), new ye(0.5, -0.5)]),
          t = 12
        ) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            r = [],
            o = [];
          let a = 0,
            l = 0;
          if (Array.isArray(e) === !1) c(e);
          else
            for (let h = 0; h < e.length; h++)
              c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
          this.setIndex(n),
            this.setAttribute("position", new Dt(i, 3)),
            this.setAttribute("normal", new Dt(r, 3)),
            this.setAttribute("uv", new Dt(o, 2));
          function c(h) {
            const u = i.length / 3,
              d = h.extractPoints(t);
            let f = d.shape;
            const m = d.holes;
            Ui.isClockWise(f) === !1 && (f = f.reverse());
            for (let g = 0, x = m.length; g < x; g++) {
              const _ = m[g];
              Ui.isClockWise(_) === !0 && (m[g] = _.reverse());
            }
            const p = Ui.triangulateShape(f, m);
            for (let g = 0, x = m.length; g < x; g++) {
              const _ = m[g];
              f = f.concat(_);
            }
            for (let g = 0, x = f.length; g < x; g++) {
              const _ = f[g];
              i.push(_.x, _.y, 0), r.push(0, 0, 1), o.push(_.x, _.y);
            }
            for (let g = 0, x = p.length; g < x; g++) {
              const _ = p[g],
                M = _[0] + u,
                S = _[1] + u,
                v = _[2] + u;
              n.push(M, S, v), (l += 3);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes;
          return BR(t, e);
        }
        static fromJSON(e, t) {
          const n = [];
          for (let i = 0, r = e.shapes.length; i < r; i++) {
            const o = t[e.shapes[i]];
            n.push(o);
          }
          return new Nu(n, e.curveSegments);
        }
      }
      function BR(s, e) {
        if (((e.shapes = []), Array.isArray(s)))
          for (let t = 0, n = s.length; t < n; t++) {
            const i = s[t];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(s.uuid);
        return e;
      }
      class Rg extends Tt {
        constructor(e) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new Ve(0)),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this;
        }
      }
      Rg.prototype.isShadowMaterial = !0;
      class Cg extends Fn {
        constructor(e) {
          super(e), (this.type = "RawShaderMaterial");
        }
      }
      Cg.prototype.isRawShaderMaterial = !0;
      class Fu extends Tt {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new Ve(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ve(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Cs),
            (this.normalScale = new ye(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Fu.prototype.isMeshStandardMaterial = !0;
      class Pg extends Fu {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new ye(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return $t((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.sheenColor = new Ve(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new Ve(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new Ve(1, 1, 1)),
            (this.specularColorMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.ior = e.ior),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      Pg.prototype.isMeshPhysicalMaterial = !0;
      class Dg extends Tt {
        constructor(e) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new Ve(16777215)),
            (this.specular = new Ve(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ve(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Cs),
            (this.normalScale = new ye(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Rl),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Dg.prototype.isMeshPhongMaterial = !0;
      class Ig extends Tt {
        constructor(e) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new Ve(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ve(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Cs),
            (this.normalScale = new ye(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            this
          );
        }
      }
      Ig.prototype.isMeshToonMaterial = !0;
      class Ng extends Tt {
        constructor(e) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Cs),
            (this.normalScale = new ye(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Ng.prototype.isMeshNormalMaterial = !0;
      class Fg extends Tt {
        constructor(e) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new Ve(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ve(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Rl),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            this
          );
        }
      }
      Fg.prototype.isMeshLambertMaterial = !0;
      class Bg extends Tt {
        constructor(e) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new Ve(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Cs),
            (this.normalScale = new ye(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Bg.prototype.isMeshMatcapMaterial = !0;
      class zg extends Ns {
        constructor(e) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        }
      }
      zg.prototype.isLineDashedMaterial = !0;
      const zR = {
        ShadowMaterial: Rg,
        SpriteMaterial: Eu,
        RawShaderMaterial: Cg,
        ShaderMaterial: Fn,
        PointsMaterial: Ru,
        MeshPhysicalMaterial: Pg,
        MeshStandardMaterial: Fu,
        MeshPhongMaterial: Dg,
        MeshToonMaterial: Ig,
        MeshNormalMaterial: Ng,
        MeshLambertMaterial: Fg,
        MeshDepthMaterial: wu,
        MeshDistanceMaterial: Su,
        MeshBasicMaterial: Il,
        MeshMatcapMaterial: Bg,
        LineDashedMaterial: zg,
        LineBasicMaterial: Ns,
        Material: Tt,
      };
      Tt.fromType = function (s) {
        return new zR[s]();
      };
      const ft = {
        arraySlice: function (s, e, t) {
          return ft.isTypedArray(s)
            ? new s.constructor(s.subarray(e, t !== void 0 ? t : s.length))
            : s.slice(e, t);
        },
        convertArray: function (s, e, t) {
          return !s || (!t && s.constructor === e)
            ? s
            : typeof e.BYTES_PER_ELEMENT == "number"
            ? new e(s)
            : Array.prototype.slice.call(s);
        },
        isTypedArray: function (s) {
          return ArrayBuffer.isView(s) && !(s instanceof DataView);
        },
        getKeyframeOrder: function (s) {
          function e(i, r) {
            return s[i] - s[r];
          }
          const t = s.length,
            n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = i;
          return n.sort(e), n;
        },
        sortedArray: function (s, e, t) {
          const n = s.length,
            i = new s.constructor(n);
          for (let r = 0, o = 0; o !== n; ++r) {
            const a = t[r] * e;
            for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
          }
          return i;
        },
        flattenJSON: function (s, e, t, n) {
          let i = 1,
            r = s[0];
          for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
          if (r === void 0) return;
          let o = r[n];
          if (o !== void 0)
            if (Array.isArray(o))
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push.apply(t, o)),
                  (r = s[i++]);
              while (r !== void 0);
            else if (o.toArray !== void 0)
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), o.toArray(t, t.length)),
                  (r = s[i++]);
              while (r !== void 0);
            else
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push(o)),
                  (r = s[i++]);
              while (r !== void 0);
        },
        subclip: function (s, e, t, n, i = 30) {
          const r = s.clone();
          r.name = e;
          const o = [];
          for (let l = 0; l < r.tracks.length; ++l) {
            const c = r.tracks[l],
              h = c.getValueSize(),
              u = [],
              d = [];
            for (let f = 0; f < c.times.length; ++f) {
              const m = c.times[f] * i;
              if (!(m < t || m >= n)) {
                u.push(c.times[f]);
                for (let p = 0; p < h; ++p) d.push(c.values[f * h + p]);
              }
            }
            u.length !== 0 &&
              ((c.times = ft.convertArray(u, c.times.constructor)),
              (c.values = ft.convertArray(d, c.values.constructor)),
              o.push(c));
          }
          r.tracks = o;
          let a = 1 / 0;
          for (let l = 0; l < r.tracks.length; ++l)
            a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
          for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
          return r.resetDuration(), r;
        },
        makeClipAdditive: function (s, e = 0, t = s, n = 30) {
          n <= 0 && (n = 30);
          const i = t.tracks.length,
            r = e / n;
          for (let o = 0; o < i; ++o) {
            const a = t.tracks[o],
              l = a.ValueTypeName;
            if (l === "bool" || l === "string") continue;
            const c = s.tracks.find(function (x) {
              return x.name === a.name && x.ValueTypeName === l;
            });
            if (c === void 0) continue;
            let h = 0;
            const u = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (h = u / 3);
            let d = 0;
            const f = c.getValueSize();
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (d = f / 3);
            const m = a.times.length - 1;
            let p;
            if (r <= a.times[0]) {
              const x = h,
                _ = u - h;
              p = ft.arraySlice(a.values, x, _);
            } else if (r >= a.times[m]) {
              const x = m * u + h,
                _ = x + u - h;
              p = ft.arraySlice(a.values, x, _);
            } else {
              const x = a.createInterpolant(),
                _ = h,
                M = u - h;
              x.evaluate(r), (p = ft.arraySlice(x.resultBuffer, _, M));
            }
            l === "quaternion" &&
              new an().fromArray(p).normalize().conjugate().toArray(p);
            const g = c.times.length;
            for (let x = 0; x < g; ++x) {
              const _ = x * f + d;
              if (l === "quaternion")
                an.multiplyQuaternionsFlat(c.values, _, p, 0, c.values, _);
              else {
                const M = f - d * 2;
                for (let S = 0; S < M; ++S) c.values[_ + S] -= p[S];
              }
            }
          }
          return (s.blendMode = eg), s;
        },
      };
      class Vi {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (i === void 0) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (!(e >= r)) {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let l = n - 2; ; ) {
                    if (r === void 0)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === l) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (o = n), (n = 0);
                  break n;
                }
                break e;
              }
              for (; n < o; ) {
                const a = (n + o) >>> 1;
                e < t[a] ? (o = a) : (n = a + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), r === void 0))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (i === void 0)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let o = 0; o !== i; ++o) t[o] = n[r + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      Vi.prototype.beforeStart_ = Vi.prototype.copySampleValue_;
      Vi.prototype.afterEnd_ = Vi.prototype.copySampleValue_;
      class OR extends Vi {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Qr, endingEnd: Qr });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            o = e + 1,
            a = i[r],
            l = i[o];
          if (a === void 0)
            switch (this.getSettings_().endingStart) {
              case es:
                (r = e), (a = 2 * t - n);
                break;
              case gl:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (l === void 0)
            switch (this.getSettings_().endingEnd) {
              case es:
                (o = e), (l = 2 * n - t);
                break;
              case gl:
                (o = 1), (l = n + i[1] - i[0]);
                break;
              default:
                (o = e - 1), (l = t);
            }
          const c = (n - t) * 0.5,
            h = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - n)),
            (this._offsetPrev = r * h),
            (this._offsetNext = o * h);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = this._offsetPrev,
            u = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            m = (n - t) / (i - t),
            p = m * m,
            g = p * m,
            x = -d * g + 2 * d * p - d * m,
            _ = (1 + d) * g + (-1.5 - 2 * d) * p + (-0.5 + d) * m + 1,
            M = (-1 - f) * g + (1.5 + f) * p + 0.5 * m,
            S = f * g - f * p;
          for (let v = 0; v !== a; ++v)
            r[v] = x * o[h + v] + _ * o[c + v] + M * o[l + v] + S * o[u + v];
          return r;
        }
      }
      class Og extends Vi {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = (n - t) / (i - t),
            u = 1 - h;
          for (let d = 0; d !== a; ++d) r[d] = o[c + d] * u + o[l + d] * h;
          return r;
        }
      }
      class UR extends Vi {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class qn {
        constructor(e, t, n, i) {
          if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = ft.convertArray(t, this.TimeBufferType)),
            (this.values = ft.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: ft.convertArray(e.times, Array),
              values: ft.convertArray(e.values, Array),
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new UR(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new Og(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new OR(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case pl:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case ml:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Rc:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return pl;
            case this.InterpolantFactoryMethodLinear:
              return ml;
            case this.InterpolantFactoryMethodSmooth:
              return Rc;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            o = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; o !== -1 && n[o] > t; ) --o;
          if ((++o, r !== 0 || o !== i)) {
            r >= o && ((o = Math.max(o, 1)), (r = o - 1));
            const a = this.getValueSize();
            (this.times = ft.arraySlice(n, r, o)),
              (this.values = ft.arraySlice(this.values, r * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          r === 0 &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l
              ),
                (e = !1);
              break;
            }
            if (o !== null && o > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                o
              ),
                (e = !1);
              break;
            }
            o = l;
          }
          if (i !== void 0 && ft.isTypedArray(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
              const c = i[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = ft.arraySlice(this.times),
            t = ft.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === Rc,
            r = e.length - 1;
          let o = 1;
          for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a],
              h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0]))
              if (i) l = !0;
              else {
                const u = a * n,
                  d = u - n,
                  f = u + n;
                for (let m = 0; m !== n; ++m) {
                  const p = t[u + m];
                  if (p !== t[d + m] || p !== t[f + m]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== o) {
                e[o] = e[a];
                const u = a * n,
                  d = o * n;
                for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
              }
              ++o;
            }
          }
          if (r > 0) {
            e[o] = e[r];
            for (let a = r * n, l = o * n, c = 0; c !== n; ++c)
              t[l + c] = t[a + c];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = ft.arraySlice(e, 0, o)),
                (this.values = ft.arraySlice(t, 0, o * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = ft.arraySlice(this.times, 0),
            t = ft.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, e, t);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      qn.prototype.TimeBufferType = Float32Array;
      qn.prototype.ValueBufferType = Float32Array;
      qn.prototype.DefaultInterpolation = ml;
      class Bs extends qn {}
      Bs.prototype.ValueTypeName = "bool";
      Bs.prototype.ValueBufferType = Array;
      Bs.prototype.DefaultInterpolation = pl;
      Bs.prototype.InterpolantFactoryMethodLinear = void 0;
      Bs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Ug extends qn {}
      Ug.prototype.ValueTypeName = "color";
      class _l extends qn {}
      _l.prototype.ValueTypeName = "number";
      class HR extends Vi {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (n - t) / (i - t);
          let c = e * a;
          for (let h = c + a; c !== h; c += 4)
            an.slerpFlat(r, 0, o, c - a, o, c, l);
          return r;
        }
      }
      class Yo extends qn {
        InterpolantFactoryMethodLinear(e) {
          return new HR(this.times, this.values, this.getValueSize(), e);
        }
      }
      Yo.prototype.ValueTypeName = "quaternion";
      Yo.prototype.DefaultInterpolation = ml;
      Yo.prototype.InterpolantFactoryMethodSmooth = void 0;
      class zs extends qn {}
      zs.prototype.ValueTypeName = "string";
      zs.prototype.ValueBufferType = Array;
      zs.prototype.DefaultInterpolation = pl;
      zs.prototype.InterpolantFactoryMethodLinear = void 0;
      zs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class vl extends qn {}
      vl.prototype.ValueTypeName = "vector";
      class Up {
        constructor(e, t = -1, n, i = gu) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = Vn()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let o = 0, a = n.length; o !== a; ++o) t.push(VR(n[o]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let r = 0, o = n.length; r !== o; ++r) t.push(qn.toJSON(n[r]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            o = [];
          for (let a = 0; a < r; a++) {
            let l = [],
              c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            const h = ft.getKeyframeOrder(l);
            (l = ft.sortedArray(l, 1, h)),
              (c = ft.sortedArray(c, 1, h)),
              !i && l[0] === 0 && (l.push(r), c.push(c[0])),
              o.push(
                new _l(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, o);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = c.name.match(r);
            if (h && h.length > 1) {
              const u = h[1];
              let d = i[u];
              d || (i[u] = d = []), d.push(c);
            }
          }
          const o = [];
          for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
          return o;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (u, d, f, m, p) {
              if (f.length !== 0) {
                const g = [],
                  x = [];
                ft.flattenJSON(f, g, x, m),
                  g.length !== 0 && p.push(new u(d, g, x));
              }
            },
            i = [],
            r = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0))
              if (d[0].morphTargets) {
                const f = {};
                let m;
                for (m = 0; m < d.length; m++)
                  if (d[m].morphTargets)
                    for (let p = 0; p < d[m].morphTargets.length; p++)
                      f[d[m].morphTargets[p]] = -1;
                for (const p in f) {
                  const g = [],
                    x = [];
                  for (let _ = 0; _ !== d[m].morphTargets.length; ++_) {
                    const M = d[m];
                    g.push(M.time), x.push(M.morphTarget === p ? 1 : 0);
                  }
                  i.push(new _l(".morphTargetInfluence[" + p + "]", g, x));
                }
                l = f.length * o;
              } else {
                const f = ".bones[" + t[u].name + "]";
                n(vl, f + ".position", d, "pos", i),
                  n(Yo, f + ".quaternion", d, "rot", i),
                  n(vl, f + ".scale", d, "scl", i);
              }
          }
          return i.length === 0 ? null : new this(r, l, i, a);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function GR(s) {
        switch (s.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return _l;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return vl;
          case "color":
            return Ug;
          case "quaternion":
            return Yo;
          case "bool":
          case "boolean":
            return Bs;
          case "string":
            return zs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
      }
      function VR(s) {
        if (s.type === void 0)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = GR(s.type);
        if (s.times === void 0) {
          const t = [],
            n = [];
          ft.flattenJSON(s.keys, t, n, "value"), (s.times = t), (s.values = n);
        }
        return e.parse !== void 0
          ? e.parse(s)
          : new e(s.name, s.times, s.values, s.interpolation);
      }
      const vs = {
        enabled: !1,
        files: {},
        add: function (s, e) {
          this.enabled !== !1 && (this.files[s] = e);
        },
        get: function (s) {
          if (this.enabled !== !1) return this.files[s];
        },
        remove: function (s) {
          delete this.files[s];
        },
        clear: function () {
          this.files = {};
        },
      };
      class kR {
        constructor(e, t, n) {
          const i = this;
          let r = !1,
            o = 0,
            a = 0,
            l;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (h) {
              a++,
                r === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
                (r = !0);
            }),
            (this.itemEnd = function (h) {
              o++,
                i.onProgress !== void 0 && i.onProgress(h, o, a),
                o === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
            }),
            (this.itemError = function (h) {
              i.onError !== void 0 && i.onError(h);
            }),
            (this.resolveURL = function (h) {
              return l ? l(h) : h;
            }),
            (this.setURLModifier = function (h) {
              return (l = h), this;
            }),
            (this.addHandler = function (h, u) {
              return c.push(h, u), this;
            }),
            (this.removeHandler = function (h) {
              const u = c.indexOf(h);
              return u !== -1 && c.splice(u, 2), this;
            }),
            (this.getHandler = function (h) {
              for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u],
                  m = c[u + 1];
                if ((f.global && (f.lastIndex = 0), f.test(h))) return m;
              }
              return null;
            });
        }
      }
      const WR = new kR();
      class ki {
        constructor(e) {
          (this.manager = e !== void 0 ? e : WR),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      const ri = {};
      class $R extends ki {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = vs.get(e);
          if (r !== void 0)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(r), this.manager.itemEnd(e);
              }, 0),
              r
            );
          if (ri[e] !== void 0) {
            ri[e].push({ onLoad: t, onProgress: n, onError: i });
            return;
          }
          (ri[e] = []), ri[e].push({ onLoad: t, onProgress: n, onError: i });
          const o = new Request(e, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            l = this.responseType;
          fetch(o)
            .then((c) => {
              if (c.status === 200 || c.status === 0) {
                if (
                  (c.status === 0 &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  typeof ReadableStream == "undefined" ||
                    c.body === void 0 ||
                    c.body.getReader === void 0)
                )
                  return c;
                const h = ri[e],
                  u = c.body.getReader(),
                  d = c.headers.get("Content-Length"),
                  f = d ? parseInt(d) : 0,
                  m = f !== 0;
                let p = 0;
                const g = new ReadableStream({
                  start(x) {
                    _();
                    function _() {
                      u.read().then(({ done: M, value: S }) => {
                        if (M) x.close();
                        else {
                          p += S.byteLength;
                          const v = new ProgressEvent("progress", {
                            lengthComputable: m,
                            loaded: p,
                            total: f,
                          });
                          for (let y = 0, C = h.length; y < C; y++) {
                            const U = h[y];
                            U.onProgress && U.onProgress(v);
                          }
                          x.enqueue(S), _();
                        }
                      });
                    }
                  },
                });
                return new Response(g);
              } else
                throw Error(
                  `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`
                );
            })
            .then((c) => {
              switch (l) {
                case "arraybuffer":
                  return c.arrayBuffer();
                case "blob":
                  return c.blob();
                case "document":
                  return c
                    .text()
                    .then((h) => new DOMParser().parseFromString(h, a));
                case "json":
                  return c.json();
                default:
                  if (a === void 0) return c.text();
                  {
                    const u = /charset="?([^;"\s]*)"?/i.exec(a),
                      d = u && u[1] ? u[1].toLowerCase() : void 0,
                      f = new TextDecoder(d);
                    return c.arrayBuffer().then((m) => f.decode(m));
                  }
              }
            })
            .then((c) => {
              vs.add(e, c);
              const h = ri[e];
              delete ri[e];
              for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onLoad && f.onLoad(c);
              }
            })
            .catch((c) => {
              const h = ri[e];
              if (h === void 0) throw (this.manager.itemError(e), c);
              delete ri[e];
              for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onError && f.onError(c);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class Hg extends ki {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = vs.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = Oo("img");
          function l() {
            h(), vs.add(e, this), t && t(this), r.manager.itemEnd(e);
          }
          function c(u) {
            h(), i && i(u), r.manager.itemError(e), r.manager.itemEnd(e);
          }
          function h() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            e.slice(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class qR extends ki {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Nl(),
            o = new Hg(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let a = 0;
          function l(c) {
            o.load(
              e[c],
              function (h) {
                (r.images[c] = h),
                  a++,
                  a === 6 && ((r.needsUpdate = !0), t && t(r));
              },
              void 0,
              i
            );
          }
          for (let c = 0; c < e.length; ++c) l(c);
          return r;
        }
      }
      class XR extends ki {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Nt(),
            o = new Hg(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                (r.image = a), (r.needsUpdate = !0), t !== void 0 && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class Wn extends tt {
        constructor(e, t = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new Ve(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      Wn.prototype.isLight = !0;
      class jR extends Wn {
        constructor(e, t, n) {
          super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(tt.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new Ve(t));
        }
        copy(e) {
          return (
            Wn.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
          );
        }
      }
      jR.prototype.isHemisphereLight = !0;
      const Hp = new We(),
        Gp = new W(),
        Vp = new W();
      class Bu {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new ye(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new We()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Fl()),
            (this._frameExtents = new ye(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new st(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          Gp.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(Gp),
            Vp.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Vp),
            t.updateMatrixWorld(),
            Hp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Hp),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class Gg extends Bu {
        constructor() {
          super(new Yt(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = Ih * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n !== t.fov || i !== t.aspect || r !== t.far) &&
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      Gg.prototype.isSpotLightShadow = !0;
      class YR extends Wn {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 1) {
          super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(tt.DefaultUp),
            this.updateMatrix(),
            (this.target = new tt()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = o),
            (this.shadow = new Gg());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      YR.prototype.isSpotLight = !0;
      const kp = new We(),
        ao = new W(),
        hh = new W();
      class Vg extends Bu {
        constructor() {
          super(new Yt(90, 1, 0.5, 500)),
            (this._frameExtents = new ye(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new st(2, 1, 1, 1),
              new st(0, 1, 1, 1),
              new st(3, 1, 1, 1),
              new st(1, 1, 1, 1),
              new st(3, 0, 1, 1),
              new st(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new W(1, 0, 0),
              new W(-1, 0, 0),
              new W(0, 0, 1),
              new W(0, 0, -1),
              new W(0, 1, 0),
              new W(0, -1, 0),
            ]),
            (this._cubeUps = [
              new W(0, 1, 0),
              new W(0, 1, 0),
              new W(0, 1, 0),
              new W(0, 1, 0),
              new W(0, 0, 1),
              new W(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            ao.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(ao),
            hh.copy(n.position),
            hh.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(hh),
            n.updateMatrixWorld(),
            i.makeTranslation(-ao.x, -ao.y, -ao.z),
            kp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(kp);
        }
      }
      Vg.prototype.isPointLightShadow = !0;
      class ZR extends Wn {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Vg());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      ZR.prototype.isPointLight = !0;
      class kg extends Bu {
        constructor() {
          super(new Mu(-5, 5, 5, -5, 0.5, 500));
        }
      }
      kg.prototype.isDirectionalLightShadow = !0;
      class JR extends Wn {
        constructor(e, t) {
          super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(tt.DefaultUp),
            this.updateMatrix(),
            (this.target = new tt()),
            (this.shadow = new kg());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      JR.prototype.isDirectionalLight = !0;
      class KR extends Wn {
        constructor(e, t) {
          super(e, t), (this.type = "AmbientLight");
        }
      }
      KR.prototype.isAmbientLight = !0;
      class QR extends Wn {
        constructor(e, t, n = 10, i = 10) {
          super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(e) {
          this.intensity = e / (this.width * this.height * Math.PI);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.width = this.width), (t.object.height = this.height), t
          );
        }
      }
      QR.prototype.isRectAreaLight = !0;
      class Wg {
        constructor() {
          this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new W());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * i),
            t.addScaledVector(o[2], 0.488603 * r),
            t.addScaledVector(o[3], 0.488603 * n),
            t.addScaledVector(o[4], 1.092548 * (n * i)),
            t.addScaledVector(o[5], 1.092548 * (i * r)),
            t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
            t.addScaledVector(o[7], 1.092548 * (n * r)),
            t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * i),
            t.addScaledVector(o[2], 2 * 0.511664 * r),
            t.addScaledVector(o[3], 2 * 0.511664 * n),
            t.addScaledVector(o[4], 2 * 0.429043 * n * i),
            t.addScaledVector(o[5], 2 * 0.429043 * i * r),
            t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * n * r),
            t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * r),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * r),
            (t[6] = 0.315392 * (3 * r * r - 1)),
            (t[7] = 1.092548 * n * r),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      Wg.prototype.isSphericalHarmonics3 = !0;
      class zu extends Wn {
        constructor(e = new Wg(), t = 1) {
          super(void 0, t), (this.sh = e);
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (t.object.sh = this.sh.toArray()), t;
        }
      }
      zu.prototype.isLightProbe = !0;
      class e3 {
        static decodeText(e) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return typeof e != "string" || e === ""
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
      }
      class t3 extends pt {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(e) {
          return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        }
      }
      t3.prototype.isInstancedBufferGeometry = !0;
      class n3 extends ki {
        constructor(e) {
          super(e),
            typeof createImageBitmap == "undefined" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch == "undefined" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = vs.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = {};
          (a.credentials =
            this.crossOrigin === "anonymous" ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (l) {
                return l.blob();
              })
              .then(function (l) {
                return createImageBitmap(
                  l,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (l) {
                vs.add(e, l), t && t(l), r.manager.itemEnd(e);
              })
              .catch(function (l) {
                i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
              }),
            r.manager.itemStart(e);
        }
      }
      n3.prototype.isImageBitmapLoader = !0;
      let il;
      const i3 = {
        getContext: function () {
          return (
            il === void 0 &&
              (il = new (window.AudioContext || window.webkitAudioContext)()),
            il
          );
        },
        setContext: function (s) {
          il = s;
        },
      };
      class r3 extends ki {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new $R(this.manager);
          o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  const l = a.slice(0);
                  i3.getContext().decodeAudioData(l, function (h) {
                    t(h);
                  });
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
      }
      class s3 extends zu {
        constructor(e, t, n = 1) {
          super(void 0, n);
          const i = new Ve().set(e),
            r = new Ve().set(t),
            o = new W(i.r, i.g, i.b),
            a = new W(r.r, r.g, r.b),
            l = Math.sqrt(Math.PI),
            c = l * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
            this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
        }
      }
      s3.prototype.isHemisphereLightProbe = !0;
      class o3 extends zu {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new Ve().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      o3.prototype.isAmbientLightProbe = !0;
      class a3 extends tt {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            this.isPlaying === !0 &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.loop === !0 &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            this._connected === !0
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), this.source.detune !== void 0))
            return (
              this.isPlaying === !0 &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return this.hasPlaybackControl === !1
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }
      class l3 {
        constructor(e, t, n) {
          (this.binding = e), (this.valueSize = n);
          let i, r, o;
          switch (t) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(n * 6)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(n * 5));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(n * 5));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let o = this.cumulativeWeight;
          if (o === 0) {
            for (let a = 0; a !== i; ++a) n[r + a] = n[a];
            o = t;
          } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, r, 0, a, i);
          }
          this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const l = t * this._origIndex;
            this._mixBufferRegion(n, i, l, 1 - r, t);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let l = t, c = t + t; l !== c; ++l)
            if (n[l] !== n[l + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let r = n, o = i; r !== o; ++r) t[r] = t[i + (r % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
        }
        _slerp(e, t, n, i) {
          an.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const o = this._workIndex * r;
          an.multiplyQuaternionsFlat(e, o, e, t, e, n),
            an.slerpFlat(e, t, e, t, e, o, i);
        }
        _lerp(e, t, n, i, r) {
          const o = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let o = 0; o !== r; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i;
          }
        }
      }
      const Ou = "\\[\\]\\.:\\/",
        c3 = new RegExp("[" + Ou + "]", "g"),
        Uu = "[^" + Ou + "]",
        h3 = "[^" + Ou.replace("\\.", "") + "]",
        u3 = /((?:WC+[\/:])*)/.source.replace("WC", Uu),
        d3 = /(WCOD+)?/.source.replace("WCOD", h3),
        f3 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Uu),
        p3 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Uu),
        m3 = new RegExp("^" + u3 + d3 + f3 + p3 + "$"),
        g3 = ["material", "materials", "bones"];
      class x3 {
        constructor(e, t, n) {
          const i = n || et.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }
      class et {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || et.parseTrackName(t)),
            (this.node = et.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new et.Composite(e, t, n)
            : new et(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(c3, "");
        }
        static parseTrackName(e) {
          const t = m3.exec(e);
          if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            g3.indexOf(r) !== -1 &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
          }
          if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            t === void 0 ||
            t === "" ||
            t === "." ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
          }
          if (e.children) {
            const n = function (r) {
                for (let o = 0; o < r.length; o++) {
                  const a = r[o];
                  if (a.name === t || a.uuid === t) return a;
                  const l = n(a.children);
                  if (l) return l;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = et.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
            return;
          }
          if (n) {
            let c = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!e.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                  if (e[h].name === c) {
                    c = h;
                    break;
                  }
                break;
              default:
                if (e[n] === void 0) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                e = e[n];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
                return;
              }
              e = e[c];
            }
          }
          const o = e[i];
          if (o === void 0) {
            const c = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                c +
                "." +
                i +
                " but it wasn't found.",
              e
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            e.needsUpdate !== void 0
              ? (a = this.Versioning.NeedsUpdate)
              : e.matrixWorldNeedsUpdate !== void 0 &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let l = this.BindingType.Direct;
          if (r !== void 0) {
            if (i === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (e.geometry.isBufferGeometry) {
                if (!e.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                e.morphTargetDictionary[r] !== void 0 &&
                  (r = e.morphTargetDictionary[r]);
              } else {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
                return;
              }
            }
            (l = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = r);
          } else
            o.fromArray !== void 0 && o.toArray !== void 0
              ? ((l = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((l = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[l]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      et.Composite = x3;
      et.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      };
      et.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      };
      et.prototype.GetterByBindingType = [
        et.prototype._getValue_direct,
        et.prototype._getValue_array,
        et.prototype._getValue_arrayElement,
        et.prototype._getValue_toArray,
      ];
      et.prototype.SetterByBindingTypeAndVersioning = [
        [
          et.prototype._setValue_direct,
          et.prototype._setValue_direct_setNeedsUpdate,
          et.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          et.prototype._setValue_array,
          et.prototype._setValue_array_setNeedsUpdate,
          et.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          et.prototype._setValue_arrayElement,
          et.prototype._setValue_arrayElement_setNeedsUpdate,
          et.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          et.prototype._setValue_fromArray,
          et.prototype._setValue_fromArray_setNeedsUpdate,
          et.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ];
      class _3 {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            o = r.length,
            a = new Array(o),
            l = { endingStart: Qr, endingEnd: Qr };
          for (let c = 0; c !== o; ++c) {
            const h = r[c].createInterpolant(null);
            (a[c] = h), (h.settings = l);
          }
          (this._interpolantSettings = l),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = n1),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const i = this._clip.duration,
              r = e._clip.duration,
              o = r / i,
              a = i / r;
            e.warp(1, o, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            e !== null &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            o = this.timeScale;
          let a = this._timeScaleInterpolant;
          a === null &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const l = a.parameterPositions,
            c = a.sampleValues;
          return (
            (l[0] = r), (l[1] = r + n), (c[0] = e / o), (c[1] = t / o), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            e !== null &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const l = (e - r) * n;
            if (l < 0 || n === 0) return;
            (this._startTime = null), (t = n * l);
          }
          t *= this._updateTimeScale(e);
          const o = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const l = this._interpolants,
              c = this._propertyBindings;
            switch (this.blendMode) {
              case eg:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulateAdditive(a);
                break;
              case gu:
              default:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulate(i, a);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), i === 0 && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            n !== null &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                t === 0 ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const o = n === i1;
          if (e === 0) return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
          if (n === t1) {
            r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else if (i < 0) i = 0;
              else {
                this.time = i;
                break e;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (r === -1 &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o))
                  : this._setEndings(this.repetitions === 0, !0, o)),
              i >= t || i < 0)
            ) {
              const a = Math.floor(i / t);
              (i -= t * a), (r += Math.abs(a));
              const l = this.repetitions - r;
              if (l <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (l === 1) {
                  const c = e < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = i;
            if (o && (r & 1) === 1) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = es), (i.endingEnd = es))
            : (e
                ? (i.endingStart = this.zeroSlopeAtStart ? es : Qr)
                : (i.endingStart = gl),
              t
                ? (i.endingEnd = this.zeroSlopeAtEnd ? es : Qr)
                : (i.endingEnd = gl));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let o = this._weightInterpolant;
          o === null &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const a = o.parameterPositions,
            l = o.sampleValues;
          return (a[0] = r), (l[0] = t), (a[1] = r + e), (l[1] = n), this;
        }
      }
      class v3 extends lr {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = n.uuid,
            c = this._bindingsByRootAndName;
          let h = c[l];
          h === void 0 && ((h = {}), (c[l] = h));
          for (let u = 0; u !== r; ++u) {
            const d = i[u],
              f = d.name;
            let m = h[f];
            if (m !== void 0) ++m.referenceCount, (o[u] = m);
            else {
              if (((m = o[u]), m !== void 0)) {
                m._cacheIndex === null &&
                  (++m.referenceCount, this._addInactiveBinding(m, l, f));
                continue;
              }
              const p = t && t._propertyBindings[u].binding.parsedPath;
              (m = new l3(
                et.create(n, f, p),
                d.ValueTypeName,
                d.getValueSize()
              )),
                ++m.referenceCount,
                this._addInactiveBinding(m, l, f),
                (o[u] = m);
            }
            a[u].resultBuffer = m.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const n = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                r = this._actionsByClip[i];
              this._bindAction(e, r && r.knownActions[0]),
                this._addInactiveAction(e, i, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              r.useCount++ === 0 &&
                (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              --r.useCount === 0 &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let o = r[t];
          if (o === void 0)
            (o = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = o);
          else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            o = this._actionsByClip,
            a = o[r],
            l = a.knownActions,
            c = l[l.length - 1],
            h = e._byClipCacheIndex;
          (c._byClipCacheIndex = h),
            (l[h] = c),
            l.pop(),
            (e._byClipCacheIndex = null);
          const u = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
          delete u[d],
            l.length === 0 && delete o[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const r = t[n];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let o = i[t];
          o === void 0 && ((o = {}), (i[t] = o)),
            (o[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = t[t.length - 1],
            c = e._cacheIndex;
          (l._cacheIndex = c),
            (t[c] = l),
            t.pop(),
            delete a[r],
            Object.keys(a).length === 0 && delete o[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            n === void 0 &&
              ((n = new Og(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let o = typeof e == "string" ? Up.findByName(i, e) : e;
          const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
          let c = null;
          if (
            (n === void 0 && (o !== null ? (n = o.blendMode) : (n = gu)),
            l !== void 0)
          ) {
            const u = l.actionByRoot[r];
            if (u !== void 0 && u.blendMode === n) return u;
            (c = l.knownActions[0]), o === null && (o = c._clip);
          }
          if (o === null) return null;
          const h = new _3(this, o, t, n);
          return this._bindAction(h, c), this._addInactiveAction(h, a, r), h;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = typeof e == "string" ? Up.findByName(n, e) : e,
            o = r ? r.uuid : e,
            a = this._actionsByClip[o];
          return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions,
            t = this._nActiveActions;
          for (let n = t - 1; n >= 0; --n) e[n].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            o = (this._accuIndex ^= 1);
          for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, o);
          const a = this._bindings,
            l = this._nActiveBindings;
          for (let c = 0; c !== l; ++c) a[c].apply(o);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (r !== void 0) {
            const o = r.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
              const c = o[a];
              this._deactivateAction(c);
              const h = c._cacheIndex,
                u = t[t.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (u._cacheIndex = h),
                (t[h] = u),
                t.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const o in n) {
            const a = n[o].actionByRoot,
              l = a[t];
            l !== void 0 &&
              (this._deactivateAction(l), this._removeInactiveAction(l));
          }
          const i = this._bindingsByRootAndName,
            r = i[t];
          if (r !== void 0)
            for (const o in r) {
              const a = r[o];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      v3.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class y3 extends Xo {
        constructor(e, t, n = 1) {
          super(e, t), (this.meshPerAttribute = n);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        clone(e) {
          const t = super.clone(e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        }
      }
      y3.prototype.isInstancedInterleavedBuffer = !0;
      const Ci = new W(),
        rl = new We(),
        uh = new We();
      class M3 extends Lu {
        constructor(e) {
          const t = $g(e),
            n = new pt(),
            i = [],
            r = [],
            o = new Ve(0, 0, 1),
            a = new Ve(0, 1, 0);
          for (let c = 0; c < t.length; c++) {
            const h = t[c];
            h.parent &&
              h.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(o.r, o.g, o.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new Dt(i, 3)),
            n.setAttribute("color", new Dt(r, 3));
          const l = new Ns({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, l),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          uh.copy(this.root.matrixWorld).invert();
          for (let r = 0, o = 0; r < t.length; r++) {
            const a = t[r];
            a.parent &&
              a.parent.isBone &&
              (rl.multiplyMatrices(uh, a.matrixWorld),
              Ci.setFromMatrixPosition(rl),
              i.setXYZ(o, Ci.x, Ci.y, Ci.z),
              rl.multiplyMatrices(uh, a.parent.matrixWorld),
              Ci.setFromMatrixPosition(rl),
              i.setXYZ(o + 1, Ci.x, Ci.y, Ci.z),
              (o += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }
      function $g(s) {
        const e = [];
        s.isBone === !0 && e.push(s);
        for (let t = 0; t < s.children.length; t++)
          e.push.apply(e, $g(s.children[t]));
        return e;
      }
      class b3 extends Lu {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new Ve(n)), (i = new Ve(i));
          const r = t / 2,
            o = e / t,
            a = e / 2,
            l = [],
            c = [];
          for (let d = 0, f = 0, m = -a; d <= t; d++, m += o) {
            l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
            const p = d === r ? n : i;
            p.toArray(c, f),
              (f += 3),
              p.toArray(c, f),
              (f += 3),
              p.toArray(c, f),
              (f += 3),
              p.toArray(c, f),
              (f += 3);
          }
          const h = new pt();
          h.setAttribute("position", new Dt(l, 3)),
            h.setAttribute("color", new Dt(c, 3));
          const u = new Ns({ vertexColors: !0, toneMapped: !1 });
          super(h, u), (this.type = "GridHelper");
        }
      }
      const zn = new Uint32Array(512),
        On = new Uint32Array(512);
      for (let s = 0; s < 256; ++s) {
        const e = s - 127;
        e < -27
          ? ((zn[s] = 0),
            (zn[s | 256] = 32768),
            (On[s] = 24),
            (On[s | 256] = 24))
          : e < -14
          ? ((zn[s] = 1024 >> (-e - 14)),
            (zn[s | 256] = (1024 >> (-e - 14)) | 32768),
            (On[s] = -e - 1),
            (On[s | 256] = -e - 1))
          : e <= 15
          ? ((zn[s] = (e + 15) << 10),
            (zn[s | 256] = ((e + 15) << 10) | 32768),
            (On[s] = 13),
            (On[s | 256] = 13))
          : e < 128
          ? ((zn[s] = 31744),
            (zn[s | 256] = 64512),
            (On[s] = 24),
            (On[s | 256] = 24))
          : ((zn[s] = 31744),
            (zn[s | 256] = 64512),
            (On[s] = 13),
            (On[s | 256] = 13));
      }
      const qg = new Uint32Array(2048),
        Zo = new Uint32Array(64),
        w3 = new Uint32Array(64);
      for (let s = 1; s < 1024; ++s) {
        let e = s << 13,
          t = 0;
        for (; (e & 8388608) === 0; ) (e <<= 1), (t -= 8388608);
        (e &= -8388609), (t += 947912704), (qg[s] = e | t);
      }
      for (let s = 1024; s < 2048; ++s) qg[s] = 939524096 + ((s - 1024) << 13);
      for (let s = 1; s < 31; ++s) Zo[s] = s << 23;
      Zo[31] = 1199570944;
      Zo[32] = 2147483648;
      for (let s = 33; s < 63; ++s) Zo[s] = 2147483648 + ((s - 32) << 23);
      Zo[63] = 3347054592;
      for (let s = 1; s < 64; ++s) s !== 32 && (w3[s] = 1024);
      Mn.create = function (s, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (s.prototype = Object.create(Mn.prototype)),
          (s.prototype.constructor = s),
          (s.prototype.getPoint = e),
          s
        );
      };
      Oh.prototype.fromPoints = function (s) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(s)
        );
      };
      b3.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      };
      M3.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      };
      ki.prototype.extractUrlBase = function (s) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          e3.extractUrlBase(s)
        );
      };
      ki.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      };
      Bn.prototype.center = function (s) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(s)
        );
      };
      Bn.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      Bn.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      Bn.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      Bn.prototype.size = function (s) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(s)
        );
      };
      hr.prototype.toVector3 = function () {
        console.error(
          "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
        );
      };
      Ps.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      };
      Fl.prototype.setFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(s)
        );
      };
      Ut.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      Ut.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      Ut.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      };
      Ut.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      Ut.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      };
      Ut.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      We.prototype.extractPosition = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(s)
        );
      };
      We.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      We.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new W().setFromMatrixColumn(this, 3)
        );
      };
      We.prototype.setRotationFromQuaternion = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(s)
        );
      };
      We.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      We.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      We.prototype.multiplyVector4 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      We.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      };
      We.prototype.rotateAxis = function (s) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          s.transformDirection(this);
      };
      We.prototype.crossVector = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      We.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      We.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      We.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      We.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      We.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      We.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      We.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      };
      We.prototype.makeFrustum = function (s, e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(s, e, n, t, i, r)
        );
      };
      We.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      oi.prototype.isIntersectionLine = function (s) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(s)
        );
      };
      an.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          s.applyQuaternion(this)
        );
      };
      an.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      };
      Ds.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      Ds.prototype.isIntersectionPlane = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(s)
        );
      };
      Ds.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      Mt.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      };
      Mt.prototype.barycoordFromPoint = function (s, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(s, e)
        );
      };
      Mt.prototype.midpoint = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(s)
        );
      };
      Mt.prototypenormal = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(s)
        );
      };
      Mt.prototype.plane = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(s)
        );
      };
      Mt.barycoordFromPoint = function (s, e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          Mt.getBarycoord(s, e, t, n, i)
        );
      };
      Mt.normal = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          Mt.getNormal(s, e, t, n)
        );
      };
      jo.prototype.extractAllPoints = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(s)
        );
      };
      jo.prototype.extrude = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new Fs(this, s)
        );
      };
      jo.prototype.makeGeometry = function (s) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new Nu(this, s)
        );
      };
      ye.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      ye.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      ye.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      W.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      };
      W.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      };
      W.prototype.getPositionFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(s)
        );
      };
      W.prototype.getScaleFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(s)
        );
      };
      W.prototype.getColumnFromMatrix = function (s, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, s)
        );
      };
      W.prototype.applyProjection = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(s)
        );
      };
      W.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      W.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      W.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      st.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      st.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      tt.prototype.getChildByName = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(s)
        );
      };
      tt.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      };
      tt.prototype.translate = function (s, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, s)
        );
      };
      tt.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      };
      tt.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(tt.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (s) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = s);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      on.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      };
      Object.defineProperties(on.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              r1
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      });
      yg.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      Yt.prototype.setLens = function (s, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          e !== void 0 && (this.filmGauge = e),
          this.setFocalLength(s);
      };
      Object.defineProperties(Wn.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = s);
          },
        },
        shadowCameraLeft: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = s);
          },
        },
        shadowCameraRight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = s);
          },
        },
        shadowCameraTop: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = s);
          },
        },
        shadowCameraBottom: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = s);
          },
        },
        shadowCameraNear: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = s);
          },
        },
        shadowCameraFar: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = s);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (s) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = s);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = s);
          },
        },
        shadowMapHeight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = s);
          },
        },
      });
      Object.defineProperties(St.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === xl
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(xl);
          },
        },
      });
      St.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? xl : zo),
          this
        );
      };
      (St.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
        (St.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        });
      pt.prototype.addIndex = function (s) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(s);
      };
      pt.prototype.addAttribute = function (s, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(s, new St(arguments[1], arguments[2])))
            : s === "index"
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(s, e)
        );
      };
      pt.prototype.addDrawCall = function (s, e, t) {
        t !== void 0 &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(s, e);
      };
      pt.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      };
      pt.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      };
      pt.prototype.removeAttribute = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(s)
        );
      };
      pt.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(pt.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      });
      Xo.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? xl : zo),
          this
        );
      };
      Xo.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      };
      Fs.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      Fs.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      };
      Fs.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Tu.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Object.defineProperties(Tt.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new Ve()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = s === Zm);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = s);
          },
        },
        vertexTangents: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
          set: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
        },
      });
      Object.defineProperties(Fn.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (s) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = s);
          },
        },
      });
      nt.prototype.clearTarget = function (s, e, t, n) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(s),
          this.clear(e, t, n);
      };
      nt.prototype.animate = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(s);
      };
      nt.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      };
      nt.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      };
      nt.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      };
      nt.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      };
      nt.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      };
      nt.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      };
      nt.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      };
      nt.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      };
      nt.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      };
      nt.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      };
      nt.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      };
      nt.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      };
      nt.prototype.enableScissorTest = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(s);
      };
      nt.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      nt.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      nt.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      nt.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      };
      nt.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      };
      nt.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      };
      nt.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      nt.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      nt.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      };
      nt.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      };
      Object.defineProperties(nt.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = s);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = s);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = s === !0 ? ht : hi);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
        gammaFactor: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              ),
              2
            );
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          },
        },
      });
      Object.defineProperties(gg.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      });
      Object.defineProperties(fn.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = s);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = s);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = s);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = s);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = s);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = s);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = s);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = s);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = s);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = s);
          },
        },
      });
      a3.prototype.load = function (s) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new r3().load(s, function (n) {
            e.setBuffer(n);
          }),
          this
        );
      };
      vu.prototype.updateCubeMap = function (s, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(s, e)
        );
      };
      vu.prototype.clear = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(s, e, t, n)
        );
      };
      cr.crossOrigin = void 0;
      cr.loadTexture = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new XR();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      cr.loadTextureCube = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new qR();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      cr.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      };
      cr.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      };
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: mu } })
        );
      typeof window != "undefined" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = mu));
      class S3 {
        constructor({
          anchor: e = { lat: 0, lng: 0, altitude: 0 },
          rotation: t = new Float32Array([0, 0, 0]),
          scale: n = new Float32Array([1, 1, 1]),
          scene: i = new Tu(),
          map: r,
        }) {
          (this.overlay = new google.maps.WebGLOverlayView()),
            (this.renderer = null),
            (this.camera = null),
            (this.anchor = e),
            (this.rotation = t),
            (this.scale = n),
            (this.scene = i),
            (this.scene.rotation.x = Math.PI / 2),
            (this.overlay.onAdd = this.onAdd.bind(this)),
            (this.overlay.onRemove = this.onRemove.bind(this)),
            (this.overlay.onContextLost = this.onContextLost.bind(this)),
            (this.overlay.onContextRestored =
              this.onContextRestored.bind(this)),
            (this.overlay.onDraw = this.onDraw.bind(this)),
            (this.camera = new Yt()),
            r && this.setMap(r);
        }
        onStateUpdate(e) {
          this.overlay.onStateUpdate(e);
        }
        requestStateUpdate() {
          this.overlay.requestStateUpdate();
        }
        onAdd() {}
        onRemove() {}
        getMap() {
          return this.overlay.getMap();
        }
        requestRedraw() {
          this.overlay.requestRedraw();
        }
        setMap(e) {
          this.overlay.setMap(e);
        }
        addListener(e, t) {
          return this.overlay.addListener(e, t);
        }
        bindTo(e, t, n, i) {
          this.overlay.bindTo(e, t, n, i);
        }
        get(e) {
          return this.overlay.get(e);
        }
        notify(e) {
          this.overlay.notify(e);
        }
        set(e, t) {
          this.overlay.set(e, t);
        }
        setValues(e) {
          this.overlay.setValues(e);
        }
        unbind(e) {
          this.overlay.unbind(e);
        }
        unbindAll() {
          this.overlay.unbindAll();
        }
        onContextRestored({ gl: e }) {
          (this.renderer = new nt(
            Object.assign(
              { canvas: e.canvas, context: e },
              e.getContextAttributes()
            )
          )),
            (this.renderer.autoClear = !1),
            (this.renderer.autoClearDepth = !1),
            (this.renderer.shadowMap.enabled = !0),
            (this.renderer.shadowMap.type = Ym),
            (this.renderer.outputEncoding = ht);
          const { width: t, height: n, clientWidth: i } = e.canvas;
          this.renderer.setPixelRatio(t / i), this.renderer.setSize(t, n, !1);
        }
        onContextLost() {
          !this.renderer || (this.renderer.dispose(), (this.renderer = null));
        }
        onDraw({ gl: e, transformer: t }) {
          this.camera.projectionMatrix.fromArray(
            t.fromLatLngAltitude(this.anchor, this.rotation, this.scale)
          ),
            e.disable(e.SCISSOR_TEST),
            this.requestRedraw(),
            this.renderer.render(this.scene, this.camera),
            this.renderer.resetState();
        }
      }
      let dh;
      const fh = {
        tilt: 0,
        heading: 0,
        zoom: 18,
        center: { lat: 35.6594945, lng: 139.6999859 },
        mapId: "15431d2b469f209e",
        disableDefaultUI: !0,
        gestureHandling: "none",
        keyboardShortcuts: !1,
      };
      function T3() {
        const s = document.getElementById("map");
        dh = new google.maps.Map(s, fh);
        const e = new Jh(),
          t = new Vm(16777215, 0.75);
        e.add(t);
        const n = new uu(16777215, 0.25);
        n.position.set(0, 10, 50), e.add(n);
        const i = new Ww(),
          r =
            "https://raw.githubusercontent.com/googlemaps/js-samples/main/assets/pin.gltf";
        i.load(r, (o) => {
          o.scene.scale.set(10, 10, 10),
            (o.scene.rotation.x = Math.PI / 2),
            e.add(o.scene);
          let { tilt: a, heading: l, zoom: c } = fh;
          const h = () => {
            if (a < 67.5) a += 0.5;
            else if (l <= 360) (l += 0.2), (c -= 5e-4);
            else return;
            dh.moveCamera({ tilt: a, heading: l, zoom: c }),
              requestAnimationFrame(h);
          };
          requestAnimationFrame(h);
        }),
          new S3({
            map: dh,
            scene: e,
            anchor: { ...fh.center, altitude: 100 },
          });
      }
      window.initMap = T3;
    </script>
    <link rel="stylesheet" href="./assets/index.cfe0d128.css" />
  </head>
  <body>
    <div id="map" class="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=beta"
      defer
    ></script>
  </body>
</html>
