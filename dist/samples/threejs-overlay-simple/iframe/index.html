<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Simple ThreeJS Overlay View</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>

    <script type="module" crossorigin>
      const ff = function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
          n(i);
        new MutationObserver((i) => {
          for (const r of i)
            if (r.type === "childList")
              for (const o of r.addedNodes)
                o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(i) {
          const r = {};
          return (
            i.integrity && (r.integrity = i.integrity),
            i.referrerpolicy && (r.referrerPolicy = i.referrerpolicy),
            i.crossorigin === "use-credentials"
              ? (r.credentials = "include")
              : i.crossorigin === "anonymous"
              ? (r.credentials = "omit")
              : (r.credentials = "same-origin"),
            r
          );
        }
        function n(i) {
          if (i.ep) return;
          i.ep = !0;
          const r = t(i);
          fetch(i.href, r);
        }
      };
      ff();
      /**
       * @license
       * Copyright 2010-2021 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const za = "129",
        pf = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        mf = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        gu = 0,
        da = 1,
        xu = 2,
        gf = 3,
        xf = 0,
        Ha = 1,
        yu = 2,
        Ei = 3,
        jn = 0,
        Qe = 1,
        Vi = 2,
        ka = 1,
        yf = 2,
        nn = 0,
        Li = 1,
        fa = 2,
        pa = 3,
        ma = 4,
        vu = 5,
        Wn = 100,
        _u = 101,
        Mu = 102,
        ga = 103,
        xa = 104,
        wu = 200,
        bu = 201,
        Su = 202,
        Tu = 203,
        Va = 204,
        Wa = 205,
        Eu = 206,
        Au = 207,
        Lu = 208,
        Ru = 209,
        Cu = 210,
        Pu = 0,
        Iu = 1,
        Du = 2,
        Hs = 3,
        Fu = 4,
        Bu = 5,
        Nu = 6,
        Gu = 7,
        Dr = 0,
        Ou = 1,
        Uu = 2,
        Yn = 0,
        zu = 1,
        Hu = 2,
        ku = 3,
        Vu = 4,
        Wu = 5,
        no = 300,
        Fr = 301,
        Br = 302,
        ks = 303,
        Vs = 304,
        Wi = 306,
        Nr = 307,
        bn = 1e3,
        at = 1001,
        Pi = 1002,
        Je = 1003,
        yr = 1004,
        vf = 1004,
        vr = 1005,
        _f = 1005,
        Ke = 1006,
        io = 1007,
        Mf = 1007,
        ln = 1008,
        wf = 1008,
        qi = 1009,
        qu = 1010,
        Xu = 1011,
        _r = 1012,
        Yu = 1013,
        pr = 1014,
        tn = 1015,
        Mr = 1016,
        Zu = 1017,
        Ju = 1018,
        ju = 1019,
        Ri = 1020,
        Ku = 1021,
        rn = 1022,
        Et = 1023,
        $u = 1024,
        Qu = 1025,
        eh = Et,
        Zn = 1026,
        Ii = 1027,
        th = 1028,
        nh = 1029,
        ih = 1030,
        rh = 1031,
        sh = 1032,
        oh = 1033,
        ya = 33776,
        va = 33777,
        _a = 33778,
        Ma = 33779,
        wa = 35840,
        ba = 35841,
        Sa = 35842,
        Ta = 35843,
        ah = 36196,
        Ea = 37492,
        Aa = 37496,
        lh = 37808,
        ch = 37809,
        uh = 37810,
        hh = 37811,
        dh = 37812,
        fh = 37813,
        ph = 37814,
        mh = 37815,
        gh = 37816,
        xh = 37817,
        yh = 37818,
        vh = 37819,
        _h = 37820,
        Mh = 37821,
        wh = 36492,
        bh = 37840,
        Sh = 37841,
        Th = 37842,
        Eh = 37843,
        Ah = 37844,
        Lh = 37845,
        Rh = 37846,
        Ch = 37847,
        Ph = 37848,
        Ih = 37849,
        Dh = 37850,
        Fh = 37851,
        Bh = 37852,
        Nh = 37853,
        Gh = 2200,
        Oh = 2201,
        Uh = 2202,
        Di = 2300,
        Kn = 2301,
        Us = 2302,
        qn = 2400,
        Xn = 2401,
        wr = 2402,
        ro = 2500,
        qa = 2501,
        zh = 0,
        Hh = 1,
        Xa = 2,
        vt = 3e3,
        $n = 3001,
        so = 3007,
        oo = 3002,
        kh = 3003,
        Ya = 3004,
        Za = 3005,
        Ja = 3006,
        Vh = 3200,
        Wh = 3201,
        En = 0,
        qh = 1,
        bf = 0,
        zs = 7680,
        Sf = 7681,
        Tf = 7682,
        Ef = 7683,
        Af = 34055,
        Lf = 34056,
        Rf = 5386,
        Cf = 512,
        Pf = 513,
        If = 514,
        Df = 515,
        Ff = 516,
        Bf = 517,
        Nf = 518,
        Xh = 519,
        Fi = 35044,
        Bi = 35048,
        Gf = 35040,
        Of = 35045,
        Uf = 35049,
        zf = 35041,
        Hf = 35046,
        kf = 35050,
        Vf = 35042,
        Wf = "100",
        La = "300 es";
      class An {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e];
          if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e.type];
          if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
            e.target = null;
          }
        }
      }
      const ct = [];
      for (let s = 0; s < 256; s++)
        ct[s] = (s < 16 ? "0" : "") + s.toString(16);
      let $r = 1234567;
      const Jn = Math.PI / 180,
        br = 180 / Math.PI;
      function At() {
        const s = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          ct[s & 255] +
          ct[(s >> 8) & 255] +
          ct[(s >> 16) & 255] +
          ct[(s >> 24) & 255] +
          "-" +
          ct[e & 255] +
          ct[(e >> 8) & 255] +
          "-" +
          ct[((e >> 16) & 15) | 64] +
          ct[(e >> 24) & 255] +
          "-" +
          ct[(t & 63) | 128] +
          ct[(t >> 8) & 255] +
          "-" +
          ct[(t >> 16) & 255] +
          ct[(t >> 24) & 255] +
          ct[n & 255] +
          ct[(n >> 8) & 255] +
          ct[(n >> 16) & 255] +
          ct[(n >> 24) & 255]
        ).toUpperCase();
      }
      function ut(s, e, t) {
        return Math.max(e, Math.min(t, s));
      }
      function ja(s, e) {
        return ((s % e) + e) % e;
      }
      function qf(s, e, t, n, i) {
        return n + ((s - e) * (i - n)) / (t - e);
      }
      function Xf(s, e, t) {
        return s !== e ? (t - s) / (e - s) : 0;
      }
      function mr(s, e, t) {
        return (1 - t) * s + t * e;
      }
      function Yf(s, e, t, n) {
        return mr(s, e, 1 - Math.exp(-t * n));
      }
      function Zf(s, e = 1) {
        return e - Math.abs(ja(s, e * 2) - e);
      }
      function Jf(s, e, t) {
        return s <= e
          ? 0
          : s >= t
          ? 1
          : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
      }
      function jf(s, e, t) {
        return s <= e
          ? 0
          : s >= t
          ? 1
          : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
      }
      function Kf(s, e) {
        return s + Math.floor(Math.random() * (e - s + 1));
      }
      function $f(s, e) {
        return s + Math.random() * (e - s);
      }
      function Qf(s) {
        return s * (0.5 - Math.random());
      }
      function ep(s) {
        return (
          s !== void 0 && ($r = s % 2147483647),
          ($r = ($r * 16807) % 2147483647),
          ($r - 1) / 2147483646
        );
      }
      function tp(s) {
        return s * Jn;
      }
      function np(s) {
        return s * br;
      }
      function Ra(s) {
        return (s & (s - 1)) === 0 && s !== 0;
      }
      function Yh(s) {
        return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
      }
      function Zh(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      function ip(s, e, t, n, i) {
        const r = Math.cos,
          o = Math.sin,
          a = r(t / 2),
          c = o(t / 2),
          l = r((e + n) / 2),
          u = o((e + n) / 2),
          h = r((e - n) / 2),
          d = o((e - n) / 2),
          f = r((n - e) / 2),
          p = o((n - e) / 2);
        switch (i) {
          case "XYX":
            s.set(a * u, c * h, c * d, a * l);
            break;
          case "YZY":
            s.set(c * d, a * u, c * h, a * l);
            break;
          case "ZXZ":
            s.set(c * h, c * d, a * u, a * l);
            break;
          case "XZX":
            s.set(a * u, c * p, c * f, a * l);
            break;
          case "YXY":
            s.set(c * f, a * u, c * p, a * l);
            break;
          case "ZYZ":
            s.set(c * p, c * f, a * u, a * l);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
            );
        }
      }
      var Ca = Object.freeze({
        __proto__: null,
        DEG2RAD: Jn,
        RAD2DEG: br,
        generateUUID: At,
        clamp: ut,
        euclideanModulo: ja,
        mapLinear: qf,
        inverseLerp: Xf,
        lerp: mr,
        damp: Yf,
        pingpong: Zf,
        smoothstep: Jf,
        smootherstep: jf,
        randInt: Kf,
        randFloat: $f,
        randFloatSpread: Qf,
        seededRandom: ep,
        degToRad: tp,
        radToDeg: np,
        isPowerOfTwo: Ra,
        ceilPowerOfTwo: Yh,
        floorPowerOfTwo: Zh,
        setQuaternionFromProperEuler: ip,
      });
      class q {
        constructor(e = 0, t = 0) {
          (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
      }
      q.prototype.isVector2 = !0;
      class it {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, c, l) {
          const u = this.elements;
          return (
            (u[0] = e),
            (u[1] = i),
            (u[2] = a),
            (u[3] = t),
            (u[4] = r),
            (u[5] = c),
            (u[6] = n),
            (u[7] = o),
            (u[8] = l),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[3],
            c = n[6],
            l = n[1],
            u = n[4],
            h = n[7],
            d = n[2],
            f = n[5],
            p = n[8],
            x = i[0],
            y = i[3],
            m = i[6],
            g = i[1],
            _ = i[4],
            w = i[7],
            T = i[2],
            v = i[5],
            A = i[8];
          return (
            (r[0] = o * x + a * g + c * T),
            (r[3] = o * y + a * _ + c * v),
            (r[6] = o * m + a * w + c * A),
            (r[1] = l * x + u * g + h * T),
            (r[4] = l * y + u * _ + h * v),
            (r[7] = l * m + u * w + h * A),
            (r[2] = d * x + f * g + p * T),
            (r[5] = d * y + f * _ + p * v),
            (r[8] = d * m + f * w + p * A),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            c = e[6],
            l = e[7],
            u = e[8];
          return (
            t * o * u -
            t * a * l -
            n * r * u +
            n * a * c +
            i * r * l -
            i * o * c
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            c = e[6],
            l = e[7],
            u = e[8],
            h = u * o - a * l,
            d = a * c - u * r,
            f = l * r - o * c,
            p = t * h + n * d + i * f;
          if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const x = 1 / p;
          return (
            (e[0] = h * x),
            (e[1] = (i * l - u * n) * x),
            (e[2] = (a * n - i * o) * x),
            (e[3] = d * x),
            (e[4] = (u * t - i * c) * x),
            (e[5] = (i * r - a * t) * x),
            (e[6] = f * x),
            (e[7] = (n * c - l * t) * x),
            (e[8] = (o * t - n * r) * x),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, o, a) {
          const c = Math.cos(r),
            l = Math.sin(r);
          return (
            this.set(
              n * c,
              n * l,
              -n * (c * o + l * a) + o + e,
              -i * l,
              i * c,
              -i * (-l * o + c * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            o = i[3],
            a = i[6],
            c = i[1],
            l = i[4],
            u = i[7];
          return (
            (i[0] = t * r + n * c),
            (i[3] = t * o + n * l),
            (i[6] = t * a + n * u),
            (i[1] = -n * r + t * c),
            (i[4] = -n * o + t * l),
            (i[7] = -n * a + t * u),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      it.prototype.isMatrix3 = !0;
      let ai;
      class ti {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            ai === void 0 &&
              (ai = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (ai.width = e.width),
              (ai.height = e.height);
            const n = ai.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = ai);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
      }
      let rp = 0;
      class rt extends An {
        constructor(
          e = rt.DEFAULT_IMAGE,
          t = rt.DEFAULT_MAPPING,
          n = at,
          i = at,
          r = Ke,
          o = ln,
          a = Et,
          c = qi,
          l = 1,
          u = vt
        ) {
          super(),
            Object.defineProperty(this, "id", { value: rp++ }),
            (this.uuid = At()),
            (this.name = ""),
            (this.image = e),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = o),
            (this.anisotropy = l),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = c),
            (this.offset = new q(0, 0)),
            (this.repeat = new q(1, 1)),
            (this.center = new q(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new it()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = u),
            (this.version = 0),
            (this.onUpdate = null);
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.image = e.image),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            this
          );
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (this.image !== void 0) {
            const i = this.image;
            if (
              (i.uuid === void 0 && (i.uuid = At()),
              !t && e.images[i.uuid] === void 0)
            ) {
              let r;
              if (Array.isArray(i)) {
                r = [];
                for (let o = 0, a = i.length; o < a; o++)
                  i[o].isDataTexture
                    ? r.push(Ao(i[o].image))
                    : r.push(Ao(i[o]));
              } else r = Ao(i);
              e.images[i.uuid] = { uuid: i.uuid, url: r };
            }
            n.image = i.uuid;
          }
          return t || (e.textures[this.uuid] = n), n;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== no) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case bn:
                e.x = e.x - Math.floor(e.x);
                break;
              case at:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case Pi:
                Math.abs(Math.floor(e.x) % 2) === 1
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case bn:
                e.y = e.y - Math.floor(e.y);
                break;
              case at:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case Pi:
                Math.abs(Math.floor(e.y) % 2) === 1
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      rt.DEFAULT_IMAGE = void 0;
      rt.DEFAULT_MAPPING = no;
      rt.prototype.isTexture = !0;
      function Ao(s) {
        return (typeof HTMLImageElement != "undefined" &&
          s instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            s instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && s instanceof ImageBitmap)
          ? ti.getDataURL(s)
          : s.data
          ? {
              data: Array.prototype.slice.call(s.data),
              width: s.width,
              height: s.height,
              type: s.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      class Ge {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.x = e), (this.y = t), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const c = e.elements,
            l = c[0],
            u = c[4],
            h = c[8],
            d = c[1],
            f = c[5],
            p = c[9],
            x = c[2],
            y = c[6],
            m = c[10];
          if (
            Math.abs(u - d) < 0.01 &&
            Math.abs(h - x) < 0.01 &&
            Math.abs(p - y) < 0.01
          ) {
            if (
              Math.abs(u + d) < 0.1 &&
              Math.abs(h + x) < 0.1 &&
              Math.abs(p + y) < 0.1 &&
              Math.abs(l + f + m - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const _ = (l + 1) / 2,
              w = (f + 1) / 2,
              T = (m + 1) / 2,
              v = (u + d) / 4,
              A = (h + x) / 4,
              L = (p + y) / 4;
            return (
              _ > w && _ > T
                ? _ < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(_)), (i = v / n), (r = A / n))
                : w > T
                ? w < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(w)), (n = v / i), (r = L / i))
                : T < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(T)), (n = A / r), (i = L / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let g = Math.sqrt(
            (y - p) * (y - p) + (h - x) * (h - x) + (d - u) * (d - u)
          );
          return (
            Math.abs(g) < 0.001 && (g = 1),
            (this.x = (y - p) / g),
            (this.y = (h - x) / g),
            (this.z = (d - u) / g),
            (this.w = Math.acos((l + f + m - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
      }
      Ge.prototype.isVector4 = !0;
      class Ot extends An {
        constructor(e, t, n) {
          super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Ge(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Ge(0, 0, e, t)),
            (n = n || {}),
            (this.texture = new rt(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding
            )),
            (this.texture.image = {}),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = 1),
            (this.texture.generateMipmaps =
              n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.minFilter =
              n.minFilter !== void 0 ? n.minFilter : Ke),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
              n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
              n.depthTexture !== void 0 ? n.depthTexture : null);
        }
        setTexture(e) {
          (e.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = e);
        }
        setSize(e, t, n = 1) {
          (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Ot.prototype.isWebGLRenderTarget = !0;
      class Jh extends Ot {
        constructor(e, t, n) {
          super(e, t);
          const i = this.texture;
          this.texture = [];
          for (let r = 0; r < n; r++) this.texture[r] = i.clone();
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = e),
                (this.texture[i].image.height = t),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
          );
        }
        copy(e) {
          this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            (this.texture.length = 0);
          for (let t = 0, n = e.texture.length; t < n; t++)
            this.texture[t] = e.texture[t].clone();
          return this;
        }
      }
      Jh.prototype.isWebGLMultipleRenderTargets = !0;
      class jh extends Ot {
        constructor(e, t, n) {
          super(e, t, n), (this.samples = 4);
        }
        copy(e) {
          return super.copy.call(this, e), (this.samples = e.samples), this;
        }
      }
      jh.prototype.isWebGLMultisampleRenderTarget = !0;
      class lt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this._x = e), (this._y = t), (this._z = n), (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, r, o, a) {
          let c = n[i + 0],
            l = n[i + 1],
            u = n[i + 2],
            h = n[i + 3];
          const d = r[o + 0],
            f = r[o + 1],
            p = r[o + 2],
            x = r[o + 3];
          if (a === 0) {
            (e[t + 0] = c), (e[t + 1] = l), (e[t + 2] = u), (e[t + 3] = h);
            return;
          }
          if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = p), (e[t + 3] = x);
            return;
          }
          if (h !== x || c !== d || l !== f || u !== p) {
            let y = 1 - a;
            const m = c * d + l * f + u * p + h * x,
              g = m >= 0 ? 1 : -1,
              _ = 1 - m * m;
            if (_ > Number.EPSILON) {
              const T = Math.sqrt(_),
                v = Math.atan2(T, m * g);
              (y = Math.sin(y * v) / T), (a = Math.sin(a * v) / T);
            }
            const w = a * g;
            if (
              ((c = c * y + d * w),
              (l = l * y + f * w),
              (u = u * y + p * w),
              (h = h * y + x * w),
              y === 1 - a)
            ) {
              const T = 1 / Math.sqrt(c * c + l * l + u * u + h * h);
              (c *= T), (l *= T), (u *= T), (h *= T);
            }
          }
          (e[t] = c), (e[t + 1] = l), (e[t + 2] = u), (e[t + 3] = h);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, o) {
          const a = n[i],
            c = n[i + 1],
            l = n[i + 2],
            u = n[i + 3],
            h = r[o],
            d = r[o + 1],
            f = r[o + 2],
            p = r[o + 3];
          return (
            (e[t] = a * p + u * h + c * f - l * d),
            (e[t + 1] = c * p + u * d + l * h - a * f),
            (e[t + 2] = l * p + u * f + a * d - c * h),
            (e[t + 3] = u * p - a * h - c * d - l * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!(e && e.isEuler))
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._order,
            a = Math.cos,
            c = Math.sin,
            l = a(n / 2),
            u = a(i / 2),
            h = a(r / 2),
            d = c(n / 2),
            f = c(i / 2),
            p = c(r / 2);
          switch (o) {
            case "XYZ":
              (this._x = d * u * h + l * f * p),
                (this._y = l * f * h - d * u * p),
                (this._z = l * u * p + d * f * h),
                (this._w = l * u * h - d * f * p);
              break;
            case "YXZ":
              (this._x = d * u * h + l * f * p),
                (this._y = l * f * h - d * u * p),
                (this._z = l * u * p - d * f * h),
                (this._w = l * u * h + d * f * p);
              break;
            case "ZXY":
              (this._x = d * u * h - l * f * p),
                (this._y = l * f * h + d * u * p),
                (this._z = l * u * p + d * f * h),
                (this._w = l * u * h - d * f * p);
              break;
            case "ZYX":
              (this._x = d * u * h - l * f * p),
                (this._y = l * f * h + d * u * p),
                (this._z = l * u * p - d * f * h),
                (this._w = l * u * h + d * f * p);
              break;
            case "YZX":
              (this._x = d * u * h + l * f * p),
                (this._y = l * f * h + d * u * p),
                (this._z = l * u * p - d * f * h),
                (this._w = l * u * h - d * f * p);
              break;
            case "XZY":
              (this._x = d * u * h - l * f * p),
                (this._y = l * f * h - d * u * p),
                (this._z = l * u * p + d * f * h),
                (this._w = l * u * h + d * f * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return t !== !1 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            o = t[1],
            a = t[5],
            c = t[9],
            l = t[2],
            u = t[6],
            h = t[10],
            d = n + a + h;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
              (this._x = (u - c) * f),
              (this._y = (r - l) * f),
              (this._z = (o - i) * f);
          } else if (n > a && n > h) {
            const f = 2 * Math.sqrt(1 + n - a - h);
            (this._w = (u - c) / f),
              (this._x = 0.25 * f),
              (this._y = (i + o) / f),
              (this._z = (r + l) / f);
          } else if (a > h) {
            const f = 2 * Math.sqrt(1 + a - n - h);
            (this._w = (r - l) / f),
              (this._x = (i + o) / f),
              (this._y = 0.25 * f),
              (this._z = (c + u) / f);
          } else {
            const f = 2 * Math.sqrt(1 + h - n - a);
            (this._w = (o - i) / f),
              (this._x = (r + l) / f),
              (this._y = (c + u) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(ut(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (n === 0) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._w,
            a = t._x,
            c = t._y,
            l = t._z,
            u = t._w;
          return (
            (this._x = n * u + o * a + i * l - r * c),
            (this._y = i * u + o * c + r * a - n * l),
            (this._z = r * u + o * l + n * c - i * a),
            (this._w = o * u - n * a - i * c - r * l),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            o = this._w;
          let a = o * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          const c = 1 - a * a;
          if (c <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * n + t * this._x),
              (this._y = f * i + t * this._y),
              (this._z = f * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const l = Math.sqrt(c),
            u = Math.atan2(l, a),
            h = Math.sin((1 - t) * u) / l,
            d = Math.sin(t * u) / l;
          return (
            (this._w = o * h + this._w * d),
            (this._x = n * h + this._x * d),
            (this._y = i * h + this._y * d),
            (this._z = r * h + this._z * d),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          this.copy(e).slerp(t, n);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      lt.prototype.isQuaternion = !0;
      class M {
        constructor(e = 0, t = 0, n = 0) {
          (this.x = e), (this.y = t), (this.z = n);
        }
        set(e, t, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(kl.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(kl.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            o = e.y,
            a = e.z,
            c = e.w,
            l = c * t + o * i - a * n,
            u = c * n + a * t - r * i,
            h = c * i + r * n - o * t,
            d = -r * t - o * n - a * i;
          return (
            (this.x = l * c + d * -r + u * -a - h * -o),
            (this.y = u * c + d * -o + h * -r - l * -a),
            (this.z = h * c + d * -a + l * -o - u * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = t.x,
            a = t.y,
            c = t.z;
          return (
            (this.x = i * c - r * a),
            (this.y = r * o - n * c),
            (this.z = n * a - i * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return Lo.copy(this).projectOnVector(e), this.sub(Lo);
        }
        reflect(e) {
          return this.sub(Lo.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(ut(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
      }
      M.prototype.isVector3 = !0;
      const Lo = new M(),
        kl = new lt();
      class wt {
        constructor(
          e = new M(1 / 0, 1 / 0, 1 / 0),
          t = new M(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let c = 0, l = e.length; c < l; c += 3) {
            const u = e[c],
              h = e[c + 1],
              d = e[c + 2];
            u < t && (t = u),
              h < n && (n = h),
              d < i && (i = d),
              u > r && (r = u),
              h > o && (o = h),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let c = 0, l = e.count; c < l; c++) {
            const u = e.getX(c),
              h = e.getY(c),
              d = e.getZ(c);
            u < t && (t = u),
              h < n && (n = h),
              d < i && (i = d),
              u > r && (r = u),
              h > o && (o = h),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Qi.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e) {
          return this.makeEmpty(), this.expandByObject(e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box3: .getCenter() target is now required"),
              (e = new M())),
            this.isEmpty()
              ? e.set(0, 0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        }
        getSize(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
              (e = new M())),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
          );
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e) {
          e.updateWorldMatrix(!1, !1);
          const t = e.geometry;
          t !== void 0 &&
            (t.boundingBox === null && t.computeBoundingBox(),
            Ro.copy(t.boundingBox),
            Ro.applyMatrix4(e.matrixWorld),
            this.union(Ro));
          const n = e.children;
          for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
              (t = new M())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y),
              (e.z - this.min.z) / (this.max.z - this.min.z)
            )
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, Qi),
            Qi.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(er),
            Qr.subVectors(this.max, er),
            li.subVectors(e.a, er),
            ci.subVectors(e.b, er),
            ui.subVectors(e.c, er),
            un.subVectors(ci, li),
            hn.subVectors(ui, ci),
            Bn.subVectors(li, ui);
          let t = [
            0,
            -un.z,
            un.y,
            0,
            -hn.z,
            hn.y,
            0,
            -Bn.z,
            Bn.y,
            un.z,
            0,
            -un.x,
            hn.z,
            0,
            -hn.x,
            Bn.z,
            0,
            -Bn.x,
            -un.y,
            un.x,
            0,
            -hn.y,
            hn.x,
            0,
            -Bn.y,
            Bn.x,
            0,
          ];
          return !Co(t, li, ci, ui, Qr) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Co(t, li, ci, ui, Qr))
            ? !1
            : (es.crossVectors(un, hn),
              (t = [es.x, es.y, es.z]),
              Co(t, li, ci, ui, Qr));
        }
        clampPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Box3: .clampPoint() target is now required"),
              (t = new M())),
            t.copy(e).clamp(this.min, this.max)
          );
        }
        distanceToPoint(e) {
          return Qi.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            e === void 0 &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              ),
            this.getCenter(e.center),
            (e.radius = this.getSize(Qi).length() * 0.5),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (Jt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Jt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Jt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Jt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Jt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Jt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Jt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Jt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Jt),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      wt.prototype.isBox3 = !0;
      const Jt = [
          new M(),
          new M(),
          new M(),
          new M(),
          new M(),
          new M(),
          new M(),
          new M(),
        ],
        Qi = new M(),
        Ro = new wt(),
        li = new M(),
        ci = new M(),
        ui = new M(),
        un = new M(),
        hn = new M(),
        Bn = new M(),
        er = new M(),
        Qr = new M(),
        es = new M(),
        Nn = new M();
      function Co(s, e, t, n, i) {
        for (let r = 0, o = s.length - 3; r <= o; r += 3) {
          Nn.fromArray(s, r);
          const a =
              i.x * Math.abs(Nn.x) +
              i.y * Math.abs(Nn.y) +
              i.z * Math.abs(Nn.z),
            c = e.dot(Nn),
            l = t.dot(Nn),
            u = n.dot(Nn);
          if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > a) return !1;
        }
        return !0;
      }
      const sp = new wt(),
        Vl = new M(),
        Po = new M(),
        Io = new M();
      class cn {
        constructor(e = new M(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          t !== void 0 ? n.copy(t) : sp.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let r = 0, o = e.length; r < o; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
              (t = new M())),
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
              (e = new wt())),
            this.isEmpty()
              ? (e.makeEmpty(), e)
              : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
          );
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          Io.subVectors(e, this.center);
          const t = Io.lengthSq();
          if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
              i = (n - this.radius) * 0.5;
            this.center.add(Io.multiplyScalar(i / n)), (this.radius += i);
          }
          return this;
        }
        union(e) {
          return (
            Po.subVectors(e.center, this.center)
              .normalize()
              .multiplyScalar(e.radius),
            this.expandByPoint(Vl.copy(e.center).add(Po)),
            this.expandByPoint(Vl.copy(e.center).sub(Po)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const jt = new M(),
        Do = new M(),
        ts = new M(),
        dn = new M(),
        Fo = new M(),
        ns = new M(),
        Bo = new M();
      class Ln {
        constructor(e = new M(), t = new M(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (t = new M())),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
          );
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, jt)), this;
        }
        closestPointToPoint(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Ray: .closestPointToPoint() target is now required"
            ),
            (t = new M())),
            t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = jt.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (jt.copy(this.direction).multiplyScalar(t).add(this.origin),
              jt.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          Do.copy(e).add(t).multiplyScalar(0.5),
            ts.copy(t).sub(e).normalize(),
            dn.copy(this.origin).sub(Do);
          const r = e.distanceTo(t) * 0.5,
            o = -this.direction.dot(ts),
            a = dn.dot(this.direction),
            c = -dn.dot(ts),
            l = dn.lengthSq(),
            u = Math.abs(1 - o * o);
          let h, d, f, p;
          if (u > 0)
            if (((h = o * c - a), (d = o * a - c), (p = r * u), h >= 0))
              if (d >= -p)
                if (d <= p) {
                  const x = 1 / u;
                  (h *= x),
                    (d *= x),
                    (f = h * (h + o * d + 2 * a) + d * (o * h + d + 2 * c) + l);
                } else
                  (d = r),
                    (h = Math.max(0, -(o * d + a))),
                    (f = -h * h + d * (d + 2 * c) + l);
              else
                (d = -r),
                  (h = Math.max(0, -(o * d + a))),
                  (f = -h * h + d * (d + 2 * c) + l);
            else
              d <= -p
                ? ((h = Math.max(0, -(-o * r + a))),
                  (d = h > 0 ? -r : Math.min(Math.max(-r, -c), r)),
                  (f = -h * h + d * (d + 2 * c) + l))
                : d <= p
                ? ((h = 0),
                  (d = Math.min(Math.max(-r, -c), r)),
                  (f = d * (d + 2 * c) + l))
                : ((h = Math.max(0, -(o * r + a))),
                  (d = h > 0 ? r : Math.min(Math.max(-r, -c), r)),
                  (f = -h * h + d * (d + 2 * c) + l));
          else
            (d = o > 0 ? -r : r),
              (h = Math.max(0, -(o * d + a))),
              (f = -h * h + d * (d + 2 * c) + l);
          return (
            n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
            i && i.copy(ts).multiplyScalar(d).add(Do),
            f
          );
        }
        intersectSphere(e, t) {
          jt.subVectors(e.center, this.origin);
          const n = jt.dot(this.direction),
            i = jt.dot(jt) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const o = Math.sqrt(r - i),
            a = n - o,
            c = n + o;
          return a < 0 && c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, o, a, c;
          const l = 1 / this.direction.x,
            u = 1 / this.direction.y,
            h = 1 / this.direction.z,
            d = this.origin;
          return (
            l >= 0
              ? ((n = (e.min.x - d.x) * l), (i = (e.max.x - d.x) * l))
              : ((n = (e.max.x - d.x) * l), (i = (e.min.x - d.x) * l)),
            u >= 0
              ? ((r = (e.min.y - d.y) * u), (o = (e.max.y - d.y) * u))
              : ((r = (e.max.y - d.y) * u), (o = (e.min.y - d.y) * u)),
            n > o ||
            r > i ||
            ((r > n || n !== n) && (n = r),
            (o < i || i !== i) && (i = o),
            h >= 0
              ? ((a = (e.min.z - d.z) * h), (c = (e.max.z - d.z) * h))
              : ((a = (e.max.z - d.z) * h), (c = (e.min.z - d.z) * h)),
            n > c || a > i) ||
            ((a > n || n !== n) && (n = a),
            (c < i || i !== i) && (i = c),
            i < 0)
              ? null
              : this.at(n >= 0 ? n : i, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, jt) !== null;
        }
        intersectTriangle(e, t, n, i, r) {
          Fo.subVectors(t, e), ns.subVectors(n, e), Bo.crossVectors(Fo, ns);
          let o = this.direction.dot(Bo),
            a;
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else if (o < 0) (a = -1), (o = -o);
          else return null;
          dn.subVectors(this.origin, e);
          const c = a * this.direction.dot(ns.crossVectors(dn, ns));
          if (c < 0) return null;
          const l = a * this.direction.dot(Fo.cross(dn));
          if (l < 0 || c + l > o) return null;
          const u = -a * dn.dot(Bo);
          return u < 0 ? null : this.at(u / o, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ce {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, c, l, u, h, d, f, p, x, y) {
          const m = this.elements;
          return (
            (m[0] = e),
            (m[4] = t),
            (m[8] = n),
            (m[12] = i),
            (m[1] = r),
            (m[5] = o),
            (m[9] = a),
            (m[13] = c),
            (m[2] = l),
            (m[6] = u),
            (m[10] = h),
            (m[14] = d),
            (m[3] = f),
            (m[7] = p),
            (m[11] = x),
            (m[15] = y),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ce().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / hi.setFromMatrixColumn(e, 0).length(),
            r = 1 / hi.setFromMatrixColumn(e, 1).length(),
            o = 1 / hi.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * o),
            (t[9] = n[9] * o),
            (t[10] = n[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            o = Math.cos(n),
            a = Math.sin(n),
            c = Math.cos(i),
            l = Math.sin(i),
            u = Math.cos(r),
            h = Math.sin(r);
          if (e.order === "XYZ") {
            const d = o * u,
              f = o * h,
              p = a * u,
              x = a * h;
            (t[0] = c * u),
              (t[4] = -c * h),
              (t[8] = l),
              (t[1] = f + p * l),
              (t[5] = d - x * l),
              (t[9] = -a * c),
              (t[2] = x - d * l),
              (t[6] = p + f * l),
              (t[10] = o * c);
          } else if (e.order === "YXZ") {
            const d = c * u,
              f = c * h,
              p = l * u,
              x = l * h;
            (t[0] = d + x * a),
              (t[4] = p * a - f),
              (t[8] = o * l),
              (t[1] = o * h),
              (t[5] = o * u),
              (t[9] = -a),
              (t[2] = f * a - p),
              (t[6] = x + d * a),
              (t[10] = o * c);
          } else if (e.order === "ZXY") {
            const d = c * u,
              f = c * h,
              p = l * u,
              x = l * h;
            (t[0] = d - x * a),
              (t[4] = -o * h),
              (t[8] = p + f * a),
              (t[1] = f + p * a),
              (t[5] = o * u),
              (t[9] = x - d * a),
              (t[2] = -o * l),
              (t[6] = a),
              (t[10] = o * c);
          } else if (e.order === "ZYX") {
            const d = o * u,
              f = o * h,
              p = a * u,
              x = a * h;
            (t[0] = c * u),
              (t[4] = p * l - f),
              (t[8] = d * l + x),
              (t[1] = c * h),
              (t[5] = x * l + d),
              (t[9] = f * l - p),
              (t[2] = -l),
              (t[6] = a * c),
              (t[10] = o * c);
          } else if (e.order === "YZX") {
            const d = o * c,
              f = o * l,
              p = a * c,
              x = a * l;
            (t[0] = c * u),
              (t[4] = x - d * h),
              (t[8] = p * h + f),
              (t[1] = h),
              (t[5] = o * u),
              (t[9] = -a * u),
              (t[2] = -l * u),
              (t[6] = f * h + p),
              (t[10] = d - x * h);
          } else if (e.order === "XZY") {
            const d = o * c,
              f = o * l,
              p = a * c,
              x = a * l;
            (t[0] = c * u),
              (t[4] = -h),
              (t[8] = l * u),
              (t[1] = d * h + x),
              (t[5] = o * u),
              (t[9] = f * h - p),
              (t[2] = p * h - f),
              (t[6] = a * u),
              (t[10] = x * h + d);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(op, e, ap);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            St.subVectors(e, t),
            St.lengthSq() === 0 && (St.z = 1),
            St.normalize(),
            fn.crossVectors(n, St),
            fn.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (St.x += 1e-4) : (St.z += 1e-4),
              St.normalize(),
              fn.crossVectors(n, St)),
            fn.normalize(),
            is.crossVectors(St, fn),
            (i[0] = fn.x),
            (i[4] = is.x),
            (i[8] = St.x),
            (i[1] = fn.y),
            (i[5] = is.y),
            (i[9] = St.y),
            (i[2] = fn.z),
            (i[6] = is.z),
            (i[10] = St.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[4],
            c = n[8],
            l = n[12],
            u = n[1],
            h = n[5],
            d = n[9],
            f = n[13],
            p = n[2],
            x = n[6],
            y = n[10],
            m = n[14],
            g = n[3],
            _ = n[7],
            w = n[11],
            T = n[15],
            v = i[0],
            A = i[4],
            L = i[8],
            I = i[12],
            N = i[1],
            U = i[5],
            G = i[9],
            R = i[13],
            D = i[2],
            F = i[6],
            C = i[10],
            V = i[14],
            te = i[3],
            J = i[7],
            oe = i[11],
            re = i[15];
          return (
            (r[0] = o * v + a * N + c * D + l * te),
            (r[4] = o * A + a * U + c * F + l * J),
            (r[8] = o * L + a * G + c * C + l * oe),
            (r[12] = o * I + a * R + c * V + l * re),
            (r[1] = u * v + h * N + d * D + f * te),
            (r[5] = u * A + h * U + d * F + f * J),
            (r[9] = u * L + h * G + d * C + f * oe),
            (r[13] = u * I + h * R + d * V + f * re),
            (r[2] = p * v + x * N + y * D + m * te),
            (r[6] = p * A + x * U + y * F + m * J),
            (r[10] = p * L + x * G + y * C + m * oe),
            (r[14] = p * I + x * R + y * V + m * re),
            (r[3] = g * v + _ * N + w * D + T * te),
            (r[7] = g * A + _ * U + w * F + T * J),
            (r[11] = g * L + _ * G + w * C + T * oe),
            (r[15] = g * I + _ * R + w * V + T * re),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            o = e[1],
            a = e[5],
            c = e[9],
            l = e[13],
            u = e[2],
            h = e[6],
            d = e[10],
            f = e[14],
            p = e[3],
            x = e[7],
            y = e[11],
            m = e[15];
          return (
            p *
              (+r * c * h -
                i * l * h -
                r * a * d +
                n * l * d +
                i * a * f -
                n * c * f) +
            x *
              (+t * c * f -
                t * l * d +
                r * o * d -
                i * o * f +
                i * l * u -
                r * c * u) +
            y *
              (+t * l * h -
                t * a * f -
                r * o * h +
                n * o * f +
                r * a * u -
                n * l * u) +
            m *
              (-i * a * u -
                t * c * h +
                t * a * d +
                i * o * h -
                n * o * d +
                n * c * u)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            c = e[6],
            l = e[7],
            u = e[8],
            h = e[9],
            d = e[10],
            f = e[11],
            p = e[12],
            x = e[13],
            y = e[14],
            m = e[15],
            g =
              h * y * l -
              x * d * l +
              x * c * f -
              a * y * f -
              h * c * m +
              a * d * m,
            _ =
              p * d * l -
              u * y * l -
              p * c * f +
              o * y * f +
              u * c * m -
              o * d * m,
            w =
              u * x * l -
              p * h * l +
              p * a * f -
              o * x * f -
              u * a * m +
              o * h * m,
            T =
              p * h * c -
              u * x * c -
              p * a * d +
              o * x * d +
              u * a * y -
              o * h * y,
            v = t * g + n * _ + i * w + r * T;
          if (v === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const A = 1 / v;
          return (
            (e[0] = g * A),
            (e[1] =
              (x * d * r -
                h * y * r -
                x * i * f +
                n * y * f +
                h * i * m -
                n * d * m) *
              A),
            (e[2] =
              (a * y * r -
                x * c * r +
                x * i * l -
                n * y * l -
                a * i * m +
                n * c * m) *
              A),
            (e[3] =
              (h * c * r -
                a * d * r -
                h * i * l +
                n * d * l +
                a * i * f -
                n * c * f) *
              A),
            (e[4] = _ * A),
            (e[5] =
              (u * y * r -
                p * d * r +
                p * i * f -
                t * y * f -
                u * i * m +
                t * d * m) *
              A),
            (e[6] =
              (p * c * r -
                o * y * r -
                p * i * l +
                t * y * l +
                o * i * m -
                t * c * m) *
              A),
            (e[7] =
              (o * d * r -
                u * c * r +
                u * i * l -
                t * d * l -
                o * i * f +
                t * c * f) *
              A),
            (e[8] = w * A),
            (e[9] =
              (p * h * r -
                u * x * r -
                p * n * f +
                t * x * f +
                u * n * m -
                t * h * m) *
              A),
            (e[10] =
              (o * x * r -
                p * a * r +
                p * n * l -
                t * x * l -
                o * n * m +
                t * a * m) *
              A),
            (e[11] =
              (u * a * r -
                o * h * r -
                u * n * l +
                t * h * l +
                o * n * f -
                t * a * f) *
              A),
            (e[12] = T * A),
            (e[13] =
              (u * x * i -
                p * h * i +
                p * n * d -
                t * x * d -
                u * n * y +
                t * h * y) *
              A),
            (e[14] =
              (p * a * i -
                o * x * i -
                p * n * c +
                t * x * c +
                o * n * y -
                t * a * y) *
              A),
            (e[15] =
              (o * h * i -
                u * a * i +
                u * n * c -
                t * h * c -
                o * n * d +
                t * a * d) *
              A),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            o = e.x,
            a = e.y,
            c = e.z,
            l = r * o,
            u = r * a;
          return (
            this.set(
              l * o + n,
              l * a - i * c,
              l * c + i * a,
              0,
              l * a + i * c,
              u * a + n,
              u * c - i * o,
              0,
              l * c - i * a,
              u * c + i * o,
              r * c * c + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, o) {
          return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            o = t._y,
            a = t._z,
            c = t._w,
            l = r + r,
            u = o + o,
            h = a + a,
            d = r * l,
            f = r * u,
            p = r * h,
            x = o * u,
            y = o * h,
            m = a * h,
            g = c * l,
            _ = c * u,
            w = c * h,
            T = n.x,
            v = n.y,
            A = n.z;
          return (
            (i[0] = (1 - (x + m)) * T),
            (i[1] = (f + w) * T),
            (i[2] = (p - _) * T),
            (i[3] = 0),
            (i[4] = (f - w) * v),
            (i[5] = (1 - (d + m)) * v),
            (i[6] = (y + g) * v),
            (i[7] = 0),
            (i[8] = (p + _) * A),
            (i[9] = (y - g) * A),
            (i[10] = (1 - (d + x)) * A),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = hi.set(i[0], i[1], i[2]).length();
          const o = hi.set(i[4], i[5], i[6]).length(),
            a = hi.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            It.copy(this);
          const l = 1 / r,
            u = 1 / o,
            h = 1 / a;
          return (
            (It.elements[0] *= l),
            (It.elements[1] *= l),
            (It.elements[2] *= l),
            (It.elements[4] *= u),
            (It.elements[5] *= u),
            (It.elements[6] *= u),
            (It.elements[8] *= h),
            (It.elements[9] *= h),
            (It.elements[10] *= h),
            t.setFromRotationMatrix(It),
            (n.x = r),
            (n.y = o),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, o) {
          o === void 0 &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            c = (2 * r) / (t - e),
            l = (2 * r) / (n - i),
            u = (t + e) / (t - e),
            h = (n + i) / (n - i),
            d = -(o + r) / (o - r),
            f = (-2 * o * r) / (o - r);
          return (
            (a[0] = c),
            (a[4] = 0),
            (a[8] = u),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = l),
            (a[9] = h),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, o) {
          const a = this.elements,
            c = 1 / (t - e),
            l = 1 / (n - i),
            u = 1 / (o - r),
            h = (t + e) * c,
            d = (n + i) * l,
            f = (o + r) * u;
          return (
            (a[0] = 2 * c),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -h),
            (a[1] = 0),
            (a[5] = 2 * l),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * u),
            (a[14] = -f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      ce.prototype.isMatrix4 = !0;
      const hi = new M(),
        It = new ce(),
        op = new M(0, 0, 0),
        ap = new M(1, 1, 1),
        fn = new M(),
        is = new M(),
        St = new M(),
        Wl = new ce(),
        ql = new lt();
      class ni {
        constructor(e = 0, t = 0, n = 0, i = ni.DefaultOrder) {
          (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i || this._order),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t, n) {
          const i = e.elements,
            r = i[0],
            o = i[4],
            a = i[8],
            c = i[1],
            l = i[5],
            u = i[9],
            h = i[2],
            d = i[6],
            f = i[10];
          switch (((t = t || this._order), t)) {
            case "XYZ":
              (this._y = Math.asin(ut(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-u, f)),
                    (this._z = Math.atan2(-o, r)))
                  : ((this._x = Math.atan2(d, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-ut(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(c, l)))
                  : ((this._y = Math.atan2(-h, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(ut(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-o, l)))
                  : ((this._y = 0), (this._z = Math.atan2(c, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-ut(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(c, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, l)));
              break;
            case "YZX":
              (this._z = Math.asin(ut(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._x = Math.atan2(-u, l)),
                    (this._y = Math.atan2(-h, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-ut(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-u, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), n !== !1 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            Wl.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Wl, t, n)
          );
        }
        setFromVector3(e, t) {
          return this.set(e.x, e.y, e.z, t || this._order);
        }
        reorder(e) {
          return ql.setFromEuler(this), this.setFromQuaternion(ql, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        toVector3(e) {
          return e
            ? e.set(this._x, this._y, this._z)
            : new M(this._x, this._y, this._z);
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      ni.prototype.isEuler = !0;
      ni.DefaultOrder = "XYZ";
      ni.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Ka {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e) | 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
      }
      let lp = 0;
      const Xl = new M(),
        di = new lt(),
        Kt = new ce(),
        rs = new M(),
        tr = new M(),
        cp = new M(),
        up = new lt(),
        Yl = new M(1, 0, 0),
        Zl = new M(0, 1, 0),
        Jl = new M(0, 0, 1),
        hp = { type: "added" },
        jl = { type: "removed" };
      class Ee extends An {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: lp++ }),
            (this.uuid = At()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Ee.DefaultUp.clone());
          const e = new M(),
            t = new ni(),
            n = new lt(),
            i = new M(1, 1, 1);
          function r() {
            n.setFromEuler(t, !1);
          }
          function o() {
            t.setFromQuaternion(n, void 0, !1);
          }
          t._onChange(r),
            n._onChange(o),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new ce() },
              normalMatrix: { value: new it() },
            }),
            (this.matrix = new ce()),
            (this.matrixWorld = new ce()),
            (this.matrixAutoUpdate = Ee.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Ka()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return di.setFromAxisAngle(e, t), this.quaternion.multiply(di), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            di.setFromAxisAngle(e, t), this.quaternion.premultiply(di), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(Yl, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(Zl, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(Jl, e);
        }
        translateOnAxis(e, t) {
          return (
            Xl.copy(e).applyQuaternion(this.quaternion),
            this.position.add(Xl.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(Yl, e);
        }
        translateY(e) {
          return this.translateOnAxis(Zl, e);
        }
        translateZ(e) {
          return this.translateOnAxis(Jl, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(Kt.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? rs.copy(e) : rs.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            tr.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Kt.lookAt(tr, rs, this.up)
              : Kt.lookAt(rs, tr, this.up),
            this.quaternion.setFromRotationMatrix(Kt),
            i &&
              (Kt.extractRotation(i.matrixWorld),
              di.setFromRotationMatrix(Kt),
              this.quaternion.premultiply(di.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.parent !== null && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(hp))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(jl)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(jl);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            Kt.copy(this.matrixWorld).invert(),
            e.parent !== null &&
              (e.parent.updateWorldMatrix(!0, !1),
              Kt.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Kt),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0) return o;
          }
        }
        getWorldPosition(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (e = new M())),
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (e = new lt())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(tr, e, cp),
            e
          );
        }
        getWorldScale(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (e = new M())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(tr, up, e),
            e
          );
        }
        getWorldDirection(e) {
          e === void 0 &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required"
            ),
            (e = new M())),
            this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            t === !0)
          ) {
            const i = this.children;
            for (let r = 0, o = i.length; r < o; r++)
              i[r].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            JSON.stringify(this.userData) !== "{}" &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (i.instanceColor = this.instanceColor.toJSON()));
          function r(a, c) {
            return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)), c.uuid;
          }
          if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const c = a.shapes;
              if (Array.isArray(c))
                for (let l = 0, u = c.length; l < u; l++) {
                  const h = c[l];
                  r(e.shapes, h);
                }
              else r(e.shapes, c);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const a = [];
              for (let c = 0, l = this.material.length; c < l; c++)
                a.push(r(e.materials, this.material[c]));
              i.material = a;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
              i.children.push(this.children[a].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const c = this.animations[a];
              i.animations.push(r(e.animations, c));
            }
          }
          if (t) {
            const a = o(e.geometries),
              c = o(e.materials),
              l = o(e.textures),
              u = o(e.images),
              h = o(e.shapes),
              d = o(e.skeletons),
              f = o(e.animations);
            a.length > 0 && (n.geometries = a),
              c.length > 0 && (n.materials = c),
              l.length > 0 && (n.textures = l),
              u.length > 0 && (n.images = u),
              h.length > 0 && (n.shapes = h),
              d.length > 0 && (n.skeletons = d),
              f.length > 0 && (n.animations = f);
          }
          return (n.object = i), n;
          function o(a) {
            const c = [];
            for (const l in a) {
              const u = a[l];
              delete u.metadata, c.push(u);
            }
            return c;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let n = 0; n < e.children.length; n++) {
              const i = e.children[n];
              this.add(i.clone());
            }
          return this;
        }
      }
      Ee.DefaultUp = new M(0, 1, 0);
      Ee.DefaultMatrixAutoUpdate = !0;
      Ee.prototype.isObject3D = !0;
      const No = new M(),
        dp = new M(),
        fp = new it();
      class Nt {
        constructor(e = new M(1, 0, 0), t = 0) {
          (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = No.subVectors(n, t).cross(dp.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
              (t = new M())),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
          );
        }
        intersectLine(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Plane: .intersectLine() target is now required"
            ),
            (t = new M()));
          const n = e.delta(No),
            i = this.normal.dot(n);
          if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
              (e = new M())),
            e.copy(this.normal).multiplyScalar(-this.constant)
          );
        }
        applyMatrix4(e, t) {
          const n = t || fp.getNormalMatrix(e),
            i = this.coplanarPoint(No).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Nt.prototype.isPlane = !0;
      const Dt = new M(),
        $t = new M(),
        Go = new M(),
        Qt = new M(),
        fi = new M(),
        pi = new M(),
        Kl = new M(),
        Oo = new M(),
        Uo = new M(),
        zo = new M();
      class je {
        constructor(e = new M(), t = new M(), n = new M()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i === void 0 &&
            (console.warn(
              "THREE.Triangle: .getNormal() target is now required"
            ),
            (i = new M())),
            i.subVectors(n, t),
            Dt.subVectors(e, t),
            i.cross(Dt);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          Dt.subVectors(i, t), $t.subVectors(n, t), Go.subVectors(e, t);
          const o = Dt.dot(Dt),
            a = Dt.dot($t),
            c = Dt.dot(Go),
            l = $t.dot($t),
            u = $t.dot(Go),
            h = o * l - a * a;
          if (
            (r === void 0 &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required"
              ),
              (r = new M())),
            h === 0)
          )
            return r.set(-2, -1, -1);
          const d = 1 / h,
            f = (l * c - a * u) * d,
            p = (o * u - a * c) * d;
          return r.set(1 - f - p, p, f);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, Qt),
            Qt.x >= 0 && Qt.y >= 0 && Qt.x + Qt.y <= 1
          );
        }
        static getUV(e, t, n, i, r, o, a, c) {
          return (
            this.getBarycoord(e, t, n, i, Qt),
            c.set(0, 0),
            c.addScaledVector(r, Qt.x),
            c.addScaledVector(o, Qt.y),
            c.addScaledVector(a, Qt.z),
            c
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            Dt.subVectors(n, t), $t.subVectors(e, t), Dt.cross($t).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            Dt.subVectors(this.c, this.b),
            $t.subVectors(this.a, this.b),
            Dt.cross($t).length() * 0.5
          );
        }
        getMidpoint(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (e = new M())),
            e
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        }
        getNormal(e) {
          return je.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (e = new Nt())),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        }
        getBarycoord(e, t) {
          return je.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return je.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return je.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return je.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (t = new M()));
          const n = this.a,
            i = this.b,
            r = this.c;
          let o, a;
          fi.subVectors(i, n), pi.subVectors(r, n), Oo.subVectors(e, n);
          const c = fi.dot(Oo),
            l = pi.dot(Oo);
          if (c <= 0 && l <= 0) return t.copy(n);
          Uo.subVectors(e, i);
          const u = fi.dot(Uo),
            h = pi.dot(Uo);
          if (u >= 0 && h <= u) return t.copy(i);
          const d = c * h - u * l;
          if (d <= 0 && c >= 0 && u <= 0)
            return (o = c / (c - u)), t.copy(n).addScaledVector(fi, o);
          zo.subVectors(e, r);
          const f = fi.dot(zo),
            p = pi.dot(zo);
          if (p >= 0 && f <= p) return t.copy(r);
          const x = f * l - c * p;
          if (x <= 0 && l >= 0 && p <= 0)
            return (a = l / (l - p)), t.copy(n).addScaledVector(pi, a);
          const y = u * p - f * h;
          if (y <= 0 && h - u >= 0 && f - p >= 0)
            return (
              Kl.subVectors(r, i),
              (a = (h - u) / (h - u + (f - p))),
              t.copy(i).addScaledVector(Kl, a)
            );
          const m = 1 / (y + x + d);
          return (
            (o = x * m),
            (a = d * m),
            t.copy(n).addScaledVector(fi, o).addScaledVector(pi, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let pp = 0;
      class et extends An {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: pp++ }),
            (this.uuid = At()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = Li),
            (this.side = jn),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = Va),
            (this.blendDst = Wa),
            (this.blendEquation = Wn),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = Hs),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Xh),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = zs),
            (this.stencilZFail = zs),
            (this.stencilZPass = zs),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0);
        }
        onBuild() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const n = e[t];
              if (n === void 0) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if (t === "shading") {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === ka);
                continue;
              }
              const i = this[t];
              if (i === void 0) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
                continue;
              }
              i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== Li && (n.blending = this.blending),
            this.side !== jn && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 &&
              (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.morphTargets === !0 && (n.morphTargets = !0),
            this.morphNormals === !0 && (n.morphNormals = !0),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData);
          function i(r) {
            const o = [];
            for (const a in r) {
              const c = r[a];
              delete c.metadata, o.push(c);
            }
            return o;
          }
          if (t) {
            const r = i(e.textures),
              o = i(e.images);
            r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      et.prototype.isMaterial = !0;
      const Kh = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Ft = { h: 0, s: 0, l: 0 },
        ss = { h: 0, s: 0, l: 0 };
      function Ho(s, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? s + (e - s) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? s + (e - s) * 6 * (2 / 3 - t)
            : s
        );
      }
      function ko(s) {
        return s < 0.04045
          ? s * 0.0773993808
          : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function Vo(s) {
        return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      class K {
        constructor(e, t, n) {
          return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : typeof e == "number"
              ? this.setHex(e)
              : typeof e == "string" && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            this
          );
        }
        setRGB(e, t, n) {
          return (this.r = e), (this.g = t), (this.b = n), this;
        }
        setHSL(e, t, n) {
          if (((e = ja(e, 1)), (t = ut(t, 0, 1)), (n = ut(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = Ho(r, i, e + 1 / 3)),
              (this.g = Ho(r, i, e)),
              (this.b = Ho(r, i, e - 1 / 3));
          }
          return this;
        }
        setStyle(e) {
          function t(i) {
            i !== void 0 &&
              parseFloat(i) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let n;
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let i;
            const r = n[1],
              o = n[2];
            switch (r) {
              case "rgb":
              case "rgba":
                if (
                  (i =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                    t(i[4]),
                    this
                  );
                if (
                  (i =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                    t(i[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (i =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                ) {
                  const a = parseFloat(i[1]) / 360,
                    c = parseInt(i[2], 10) / 100,
                    l = parseInt(i[3], 10) / 100;
                  return t(i[4]), this.setHSL(a, c, l);
                }
                break;
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const i = n[1],
              r = i.length;
            if (r === 3)
              return (
                (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
                (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
                (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
                this
              );
            if (r === 6)
              return (
                (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
                (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
                (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e) : this;
        }
        setColorName(e) {
          const t = Kh[e.toLowerCase()];
          return (
            t !== void 0
              ? this.setHex(t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copyGammaToLinear(e, t = 2) {
          return (
            (this.r = Math.pow(e.r, t)),
            (this.g = Math.pow(e.g, t)),
            (this.b = Math.pow(e.b, t)),
            this
          );
        }
        copyLinearToGamma(e, t = 2) {
          const n = t > 0 ? 1 / t : 1;
          return (
            (this.r = Math.pow(e.r, n)),
            (this.g = Math.pow(e.g, n)),
            (this.b = Math.pow(e.b, n)),
            this
          );
        }
        convertGammaToLinear(e) {
          return this.copyGammaToLinear(this, e), this;
        }
        convertLinearToGamma(e) {
          return this.copyLinearToGamma(this, e), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = ko(e.r)), (this.g = ko(e.g)), (this.b = ko(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = Vo(e.r)), (this.g = Vo(e.g)), (this.b = Vo(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((this.r * 255) << 16) ^
            ((this.g * 255) << 8) ^
            ((this.b * 255) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(e) {
          e === void 0 &&
            (console.warn("THREE.Color: .getHSL() target is now required"),
            (e = { h: 0, s: 0, l: 0 }));
          const t = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(t, n, i),
            o = Math.min(t, n, i);
          let a, c;
          const l = (o + r) / 2;
          if (o === r) (a = 0), (c = 0);
          else {
            const u = r - o;
            switch (((c = l <= 0.5 ? u / (r + o) : u / (2 - r - o)), r)) {
              case t:
                a = (n - i) / u + (n < i ? 6 : 0);
                break;
              case n:
                a = (i - t) / u + 2;
                break;
              case i:
                a = (t - n) / u + 4;
                break;
            }
            a /= 6;
          }
          return (e.h = a), (e.s = c), (e.l = l), e;
        }
        getStyle() {
          return (
            "rgb(" +
            ((this.r * 255) | 0) +
            "," +
            ((this.g * 255) | 0) +
            "," +
            ((this.b * 255) | 0) +
            ")"
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(Ft),
            (Ft.h += e),
            (Ft.s += t),
            (Ft.l += n),
            this.setHSL(Ft.h, Ft.s, Ft.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(Ft), e.getHSL(ss);
          const n = mr(Ft.h, ss.h, t),
            i = mr(Ft.s, ss.s, t),
            r = mr(Ft.l, ss.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      K.NAMES = Kh;
      K.prototype.isColor = !0;
      K.prototype.r = 1;
      K.prototype.g = 1;
      K.prototype.b = 1;
      class bt extends et {
        constructor(e) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new K(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Dr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      bt.prototype.isMeshBasicMaterial = !0;
      const ze = new M(),
        os = new q();
      class be {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n === !0),
            (this.usage = Fi),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (o = new K())),
              (t[n++] = o.r),
              (t[n++] = o.g),
              (t[n++] = o.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (o = new q())),
              (t[n++] = o.x),
              (t[n++] = o.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (o = new M())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (o = new Ge())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z),
              (t[n++] = o.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
              os.fromBufferAttribute(this, t),
                os.applyMatrix3(e),
                this.setXY(t, os.x, os.y);
          else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
              ze.fromBufferAttribute(this, t),
                ze.applyMatrix3(e),
                this.setXYZ(t, ze.x, ze.y, ze.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (ze.x = this.getX(t)),
              (ze.y = this.getY(t)),
              (ze.z = this.getZ(t)),
              ze.applyMatrix4(e),
              this.setXYZ(t, ze.x, ze.y, ze.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (ze.x = this.getX(t)),
              (ze.y = this.getY(t)),
              (ze.z = this.getZ(t)),
              ze.applyNormalMatrix(e),
              this.setXYZ(t, ze.x, ze.y, ze.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (ze.x = this.getX(t)),
              (ze.y = this.getY(t)),
              (ze.z = this.getZ(t)),
              ze.transformDirection(e),
              this.setXYZ(t, ze.x, ze.y, ze.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (e.name = this.name),
            this.usage !== Fi && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      be.prototype.isBufferAttribute = !0;
      class $h extends be {
        constructor(e, t, n) {
          super(new Int8Array(e), t, n);
        }
      }
      class Qh extends be {
        constructor(e, t, n) {
          super(new Uint8Array(e), t, n);
        }
      }
      class ed extends be {
        constructor(e, t, n) {
          super(new Uint8ClampedArray(e), t, n);
        }
      }
      class td extends be {
        constructor(e, t, n) {
          super(new Int16Array(e), t, n);
        }
      }
      class ao extends be {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class nd extends be {
        constructor(e, t, n) {
          super(new Int32Array(e), t, n);
        }
      }
      class lo extends be {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class id extends be {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      id.prototype.isFloat16BufferAttribute = !0;
      class le extends be {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      class rd extends be {
        constructor(e, t, n) {
          super(new Float64Array(e), t, n);
        }
      }
      function sd(s) {
        if (s.length === 0) return -1 / 0;
        let e = s[0];
        for (let t = 1, n = s.length; t < n; ++t) s[t] > e && (e = s[t]);
        return e;
      }
      const mp = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function dr(s, e) {
        return new mp[s](e);
      }
      let gp = 0;
      const Rt = new ce(),
        Wo = new Ee(),
        mi = new M(),
        Tt = new wt(),
        nr = new wt(),
        ot = new M();
      class de extends An {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: gp++ }),
            (this.uuid = At()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (sd(e) > 65535 ? lo : ao)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const r = new it().getNormalMatrix(e);
            n.applyNormalMatrix(r), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Rt.makeRotationFromQuaternion(e), this.applyMatrix4(Rt), this;
        }
        rotateX(e) {
          return Rt.makeRotationX(e), this.applyMatrix4(Rt), this;
        }
        rotateY(e) {
          return Rt.makeRotationY(e), this.applyMatrix4(Rt), this;
        }
        rotateZ(e) {
          return Rt.makeRotationZ(e), this.applyMatrix4(Rt), this;
        }
        translate(e, t, n) {
          return Rt.makeTranslation(e, t, n), this.applyMatrix4(Rt), this;
        }
        scale(e, t, n) {
          return Rt.makeScale(e, t, n), this.applyMatrix4(Rt), this;
        }
        lookAt(e) {
          return (
            Wo.lookAt(e), Wo.updateMatrix(), this.applyMatrix4(Wo.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(mi).negate(),
            this.translate(mi.x, mi.y, mi.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0);
          }
          return this.setAttribute("position", new le(t, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new wt());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingBox.set(
                new M(-1 / 0, -1 / 0, -1 / 0),
                new M(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let n = 0, i = t.length; n < i; n++) {
                const r = t[n];
                Tt.setFromBufferAttribute(r),
                  this.morphTargetsRelative
                    ? (ot.addVectors(this.boundingBox.min, Tt.min),
                      this.boundingBox.expandByPoint(ot),
                      ot.addVectors(this.boundingBox.max, Tt.max),
                      this.boundingBox.expandByPoint(ot))
                    : (this.boundingBox.expandByPoint(Tt.min),
                      this.boundingBox.expandByPoint(Tt.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new cn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingSphere.set(new M(), 1 / 0);
            return;
          }
          if (e) {
            const n = this.boundingSphere.center;
            if ((Tt.setFromBufferAttribute(e), t))
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r];
                nr.setFromBufferAttribute(a),
                  this.morphTargetsRelative
                    ? (ot.addVectors(Tt.min, nr.min),
                      Tt.expandByPoint(ot),
                      ot.addVectors(Tt.max, nr.max),
                      Tt.expandByPoint(ot))
                    : (Tt.expandByPoint(nr.min), Tt.expandByPoint(nr.max));
              }
            Tt.getCenter(n);
            let i = 0;
            for (let r = 0, o = e.count; r < o; r++)
              ot.fromBufferAttribute(e, r),
                (i = Math.max(i, n.distanceToSquared(ot)));
            if (t)
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r],
                  c = this.morphTargetsRelative;
                for (let l = 0, u = a.count; l < u; l++)
                  ot.fromBufferAttribute(a, l),
                    c && (mi.fromBufferAttribute(e, l), ot.add(mi)),
                    (i = Math.max(i, n.distanceToSquared(ot)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeFaceNormals() {}
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            o = t.uv.array,
            a = i.length / 3;
          t.tangent === void 0 &&
            this.setAttribute("tangent", new be(new Float32Array(4 * a), 4));
          const c = t.tangent.array,
            l = [],
            u = [];
          for (let N = 0; N < a; N++) (l[N] = new M()), (u[N] = new M());
          const h = new M(),
            d = new M(),
            f = new M(),
            p = new q(),
            x = new q(),
            y = new q(),
            m = new M(),
            g = new M();
          function _(N, U, G) {
            h.fromArray(i, N * 3),
              d.fromArray(i, U * 3),
              f.fromArray(i, G * 3),
              p.fromArray(o, N * 2),
              x.fromArray(o, U * 2),
              y.fromArray(o, G * 2),
              d.sub(h),
              f.sub(h),
              x.sub(p),
              y.sub(p);
            const R = 1 / (x.x * y.y - y.x * x.y);
            !isFinite(R) ||
              (m
                .copy(d)
                .multiplyScalar(y.y)
                .addScaledVector(f, -x.y)
                .multiplyScalar(R),
              g
                .copy(f)
                .multiplyScalar(x.x)
                .addScaledVector(d, -y.x)
                .multiplyScalar(R),
              l[N].add(m),
              l[U].add(m),
              l[G].add(m),
              u[N].add(g),
              u[U].add(g),
              u[G].add(g));
          }
          let w = this.groups;
          w.length === 0 && (w = [{ start: 0, count: n.length }]);
          for (let N = 0, U = w.length; N < U; ++N) {
            const G = w[N],
              R = G.start,
              D = G.count;
            for (let F = R, C = R + D; F < C; F += 3)
              _(n[F + 0], n[F + 1], n[F + 2]);
          }
          const T = new M(),
            v = new M(),
            A = new M(),
            L = new M();
          function I(N) {
            A.fromArray(r, N * 3), L.copy(A);
            const U = l[N];
            T.copy(U),
              T.sub(A.multiplyScalar(A.dot(U))).normalize(),
              v.crossVectors(L, U);
            const R = v.dot(u[N]) < 0 ? -1 : 1;
            (c[N * 4] = T.x),
              (c[N * 4 + 1] = T.y),
              (c[N * 4 + 2] = T.z),
              (c[N * 4 + 3] = R);
          }
          for (let N = 0, U = w.length; N < U; ++N) {
            const G = w[N],
              R = G.start,
              D = G.count;
            for (let F = R, C = R + D; F < C; F += 3)
              I(n[F + 0]), I(n[F + 1]), I(n[F + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new be(new Float32Array(t.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const i = new M(),
              r = new M(),
              o = new M(),
              a = new M(),
              c = new M(),
              l = new M(),
              u = new M(),
              h = new M();
            if (e)
              for (let d = 0, f = e.count; d < f; d += 3) {
                const p = e.getX(d + 0),
                  x = e.getX(d + 1),
                  y = e.getX(d + 2);
                i.fromBufferAttribute(t, p),
                  r.fromBufferAttribute(t, x),
                  o.fromBufferAttribute(t, y),
                  u.subVectors(o, r),
                  h.subVectors(i, r),
                  u.cross(h),
                  a.fromBufferAttribute(n, p),
                  c.fromBufferAttribute(n, x),
                  l.fromBufferAttribute(n, y),
                  a.add(u),
                  c.add(u),
                  l.add(u),
                  n.setXYZ(p, a.x, a.y, a.z),
                  n.setXYZ(x, c.x, c.y, c.z),
                  n.setXYZ(y, l.x, l.y, l.z);
              }
            else
              for (let d = 0, f = t.count; d < f; d += 3)
                i.fromBufferAttribute(t, d + 0),
                  r.fromBufferAttribute(t, d + 1),
                  o.fromBufferAttribute(t, d + 2),
                  u.subVectors(o, r),
                  h.subVectors(i, r),
                  u.cross(h),
                  n.setXYZ(d + 0, u.x, u.y, u.z),
                  n.setXYZ(d + 1, u.x, u.y, u.z),
                  n.setXYZ(d + 2, u.x, u.y, u.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!(e && e.isBufferGeometry)) {
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
            return;
          }
          t === void 0 &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (e.attributes[i] === void 0) continue;
            const o = n[i].array,
              a = e.attributes[i],
              c = a.array,
              l = a.itemSize * t,
              u = Math.min(c.length, o.length - l);
            for (let h = 0, d = l; h < u; h++, d++) o[d] = c[h];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            ot.fromBufferAttribute(e, t),
              ot.normalize(),
              e.setXYZ(t, ot.x, ot.y, ot.z);
        }
        toNonIndexed() {
          function e(a, c) {
            const l = a.array,
              u = a.itemSize,
              h = a.normalized,
              d = new l.constructor(c.length * u);
            let f = 0,
              p = 0;
            for (let x = 0, y = c.length; x < y; x++) {
              f = c[x] * u;
              for (let m = 0; m < u; m++) d[p++] = l[f++];
            }
            return new be(d, u, h);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new de(),
            n = this.index.array,
            i = this.attributes;
          for (const a in i) {
            const c = i[a],
              l = e(c, n);
            t.setAttribute(a, l);
          }
          const r = this.morphAttributes;
          for (const a in r) {
            const c = [],
              l = r[a];
            for (let u = 0, h = l.length; u < h; u++) {
              const d = l[u],
                f = e(d, n);
              c.push(f);
            }
            t.morphAttributes[a] = c;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, c = o.length; a < c; a++) {
            const l = o[a];
            t.addGroup(l.start, l.count, l.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const c = this.parameters;
            for (const l in c) c[l] !== void 0 && (e[l] = c[l]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const c in n) {
            const l = n[c];
            e.data.attributes[c] = l.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const c in this.morphAttributes) {
            const l = this.morphAttributes[c],
              u = [];
            for (let h = 0, d = l.length; h < d; h++) {
              const f = l[h];
              u.push(f.toJSON(e.data));
            }
            u.length > 0 && ((i[c] = u), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            a !== null &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new de().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          n !== null && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const l in i) {
            const u = i[l];
            this.setAttribute(l, u.clone(t));
          }
          const r = e.morphAttributes;
          for (const l in r) {
            const u = [],
              h = r[l];
            for (let d = 0, f = h.length; d < f; d++) u.push(h[d].clone(t));
            this.morphAttributes[l] = u;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let l = 0, u = o.length; l < u; l++) {
            const h = o[l];
            this.addGroup(h.start, h.count, h.materialIndex);
          }
          const a = e.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const c = e.boundingSphere;
          return (
            c !== null && (this.boundingSphere = c.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      de.prototype.isBufferGeometry = !0;
      const $l = new ce(),
        gi = new Ln(),
        qo = new cn(),
        pn = new M(),
        mn = new M(),
        gn = new M(),
        Xo = new M(),
        Yo = new M(),
        Zo = new M(),
        as = new M(),
        ls = new M(),
        cs = new M(),
        us = new q(),
        hs = new q(),
        ds = new q(),
        Jo = new M(),
        fs = new M();
      class $e extends Ee {
        constructor(e = new de(), t = new bt()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            e.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (
            i === void 0 ||
            (n.boundingSphere === null && n.computeBoundingSphere(),
            qo.copy(n.boundingSphere),
            qo.applyMatrix4(r),
            e.ray.intersectsSphere(qo) === !1) ||
            ($l.copy(r).invert(),
            gi.copy(e.ray).applyMatrix4($l),
            n.boundingBox !== null && gi.intersectsBox(n.boundingBox) === !1)
          )
            return;
          let o;
          if (n.isBufferGeometry) {
            const a = n.index,
              c = n.attributes.position,
              l = n.morphAttributes.position,
              u = n.morphTargetsRelative,
              h = n.attributes.uv,
              d = n.attributes.uv2,
              f = n.groups,
              p = n.drawRange;
            if (a !== null)
              if (Array.isArray(i))
                for (let x = 0, y = f.length; x < y; x++) {
                  const m = f[x],
                    g = i[m.materialIndex],
                    _ = Math.max(m.start, p.start),
                    w = Math.min(m.start + m.count, p.start + p.count);
                  for (let T = _, v = w; T < v; T += 3) {
                    const A = a.getX(T),
                      L = a.getX(T + 1),
                      I = a.getX(T + 2);
                    (o = ps(this, g, e, gi, c, l, u, h, d, A, L, I)),
                      o &&
                        ((o.faceIndex = Math.floor(T / 3)),
                        (o.face.materialIndex = m.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const x = Math.max(0, p.start),
                  y = Math.min(a.count, p.start + p.count);
                for (let m = x, g = y; m < g; m += 3) {
                  const _ = a.getX(m),
                    w = a.getX(m + 1),
                    T = a.getX(m + 2);
                  (o = ps(this, i, e, gi, c, l, u, h, d, _, w, T)),
                    o && ((o.faceIndex = Math.floor(m / 3)), t.push(o));
                }
              }
            else if (c !== void 0)
              if (Array.isArray(i))
                for (let x = 0, y = f.length; x < y; x++) {
                  const m = f[x],
                    g = i[m.materialIndex],
                    _ = Math.max(m.start, p.start),
                    w = Math.min(m.start + m.count, p.start + p.count);
                  for (let T = _, v = w; T < v; T += 3) {
                    const A = T,
                      L = T + 1,
                      I = T + 2;
                    (o = ps(this, g, e, gi, c, l, u, h, d, A, L, I)),
                      o &&
                        ((o.faceIndex = Math.floor(T / 3)),
                        (o.face.materialIndex = m.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const x = Math.max(0, p.start),
                  y = Math.min(c.count, p.start + p.count);
                for (let m = x, g = y; m < g; m += 3) {
                  const _ = m,
                    w = m + 1,
                    T = m + 2;
                  (o = ps(this, i, e, gi, c, l, u, h, d, _, w, T)),
                    o && ((o.faceIndex = Math.floor(m / 3)), t.push(o));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      $e.prototype.isMesh = !0;
      function xp(s, e, t, n, i, r, o, a) {
        let c;
        if (
          (e.side === Qe
            ? (c = n.intersectTriangle(o, r, i, !0, a))
            : (c = n.intersectTriangle(i, r, o, e.side !== Vi, a)),
          c === null)
        )
          return null;
        fs.copy(a), fs.applyMatrix4(s.matrixWorld);
        const l = t.ray.origin.distanceTo(fs);
        return l < t.near || l > t.far
          ? null
          : { distance: l, point: fs.clone(), object: s };
      }
      function ps(s, e, t, n, i, r, o, a, c, l, u, h) {
        pn.fromBufferAttribute(i, l),
          mn.fromBufferAttribute(i, u),
          gn.fromBufferAttribute(i, h);
        const d = s.morphTargetInfluences;
        if (e.morphTargets && r && d) {
          as.set(0, 0, 0), ls.set(0, 0, 0), cs.set(0, 0, 0);
          for (let p = 0, x = r.length; p < x; p++) {
            const y = d[p],
              m = r[p];
            y !== 0 &&
              (Xo.fromBufferAttribute(m, l),
              Yo.fromBufferAttribute(m, u),
              Zo.fromBufferAttribute(m, h),
              o
                ? (as.addScaledVector(Xo, y),
                  ls.addScaledVector(Yo, y),
                  cs.addScaledVector(Zo, y))
                : (as.addScaledVector(Xo.sub(pn), y),
                  ls.addScaledVector(Yo.sub(mn), y),
                  cs.addScaledVector(Zo.sub(gn), y)));
          }
          pn.add(as), mn.add(ls), gn.add(cs);
        }
        s.isSkinnedMesh &&
          (s.boneTransform(l, pn),
          s.boneTransform(u, mn),
          s.boneTransform(h, gn));
        const f = xp(s, e, t, n, pn, mn, gn, Jo);
        if (f) {
          a &&
            (us.fromBufferAttribute(a, l),
            hs.fromBufferAttribute(a, u),
            ds.fromBufferAttribute(a, h),
            (f.uv = je.getUV(Jo, pn, mn, gn, us, hs, ds, new q()))),
            c &&
              (us.fromBufferAttribute(c, l),
              hs.fromBufferAttribute(c, u),
              ds.fromBufferAttribute(c, h),
              (f.uv2 = je.getUV(Jo, pn, mn, gn, us, hs, ds, new q())));
          const p = { a: l, b: u, c: h, normal: new M(), materialIndex: 0 };
          je.getNormal(pn, mn, gn, p.normal), (f.face = p);
        }
        return f;
      }
      class Qn extends de {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: o,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
          const c = [],
            l = [],
            u = [],
            h = [];
          let d = 0,
            f = 0;
          p("z", "y", "x", -1, -1, n, t, e, o, r, 0),
            p("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
            p("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            p("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(c),
            this.setAttribute("position", new le(l, 3)),
            this.setAttribute("normal", new le(u, 3)),
            this.setAttribute("uv", new le(h, 2));
          function p(x, y, m, g, _, w, T, v, A, L, I) {
            const N = w / A,
              U = T / L,
              G = w / 2,
              R = T / 2,
              D = v / 2,
              F = A + 1,
              C = L + 1;
            let V = 0,
              te = 0;
            const J = new M();
            for (let oe = 0; oe < C; oe++) {
              const re = oe * U - R;
              for (let we = 0; we < F; we++) {
                const _e = we * N - G;
                (J[x] = _e * g),
                  (J[y] = re * _),
                  (J[m] = D),
                  l.push(J.x, J.y, J.z),
                  (J[x] = 0),
                  (J[y] = 0),
                  (J[m] = v > 0 ? 1 : -1),
                  u.push(J.x, J.y, J.z),
                  h.push(we / A),
                  h.push(1 - oe / L),
                  (V += 1);
              }
            }
            for (let oe = 0; oe < L; oe++)
              for (let re = 0; re < A; re++) {
                const we = d + re + F * oe,
                  _e = d + re + F * (oe + 1),
                  Be = d + (re + 1) + F * (oe + 1),
                  Ce = d + (re + 1) + F * oe;
                c.push(we, _e, Ce), c.push(_e, Be, Ce), (te += 6);
              }
            a.addGroup(f, te, I), (f += te), (d += V);
          }
        }
      }
      function Ni(s) {
        const e = {};
        for (const t in s) {
          e[t] = {};
          for (const n in s[t]) {
            const i = s[t][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (e[t][n] = i.clone())
              : Array.isArray(i)
              ? (e[t][n] = i.slice())
              : (e[t][n] = i);
          }
        }
        return e;
      }
      function mt(s) {
        const e = {};
        for (let t = 0; t < s.length; t++) {
          const n = Ni(s[t]);
          for (const i in n) e[i] = n[i];
        }
        return e;
      }
      const od = { clone: Ni, merge: mt };
      var yp = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        vp = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class sn extends et {
        constructor(e) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = yp),
            (this.fragmentShader = vp),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 &&
              (e.attributes !== void 0 &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = Ni(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture
              ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
              : o && o.isColor
              ? (t.uniforms[i] = { type: "c", value: o.getHex() })
              : o && o.isVector2
              ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
              : o && o.isVector3
              ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
              ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
              : o && o.isMatrix3
              ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
              : o && o.isMatrix4
              ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
              : (t.uniforms[i] = { value: o });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      sn.prototype.isShaderMaterial = !0;
      class Gr extends Ee {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new ce()),
            (this.projectionMatrix = new ce()),
            (this.projectionMatrixInverse = new ce());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          e === void 0 &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required"
            ),
            (e = new M())),
            this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Gr.prototype.isCamera = !0;
      class nt extends Gr {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = br * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(Jn * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return br * 2 * Math.atan(Math.tan(Jn * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, r, o) {
          (this.aspect = e / t),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(Jn * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const o = this.view;
          if (this.view !== null && this.view.enabled) {
            const c = o.fullWidth,
              l = o.fullHeight;
            (r += (o.offsetX * i) / c),
              (t -= (o.offsetY * n) / l),
              (i *= o.width / c),
              (n *= o.height / l);
          }
          const a = this.filmOffset;
          a !== 0 && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      nt.prototype.isPerspectiveCamera = !0;
      const xi = 90,
        yi = 1;
      class co extends Ee {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            n.isWebGLCubeRenderTarget !== !0)
          ) {
            console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
            return;
          }
          this.renderTarget = n;
          const i = new nt(xi, yi, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new M(1, 0, 0)),
            this.add(i);
          const r = new nt(xi, yi, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new M(-1, 0, 0)),
            this.add(r);
          const o = new nt(xi, yi, e, t);
          (o.layers = this.layers),
            o.up.set(0, 0, 1),
            o.lookAt(new M(0, 1, 0)),
            this.add(o);
          const a = new nt(xi, yi, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new M(0, -1, 0)),
            this.add(a);
          const c = new nt(xi, yi, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new M(0, 0, 1)),
            this.add(c);
          const l = new nt(xi, yi, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new M(0, 0, -1)),
            this.add(l);
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, o, a, c, l] = this.children,
            u = e.xr.enabled,
            h = e.getRenderTarget();
          e.xr.enabled = !1;
          const d = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, r),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, c),
            (n.texture.generateMipmaps = d),
            e.setRenderTarget(n, 5),
            e.render(t, l),
            e.setRenderTarget(h),
            (e.xr.enabled = u);
        }
      }
      class Xi extends rt {
        constructor(e, t, n, i, r, o, a, c, l, u) {
          (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : Fr),
            (a = a !== void 0 ? a : rn),
            super(e, t, n, i, r, o, a, c, l, u),
            (this._needsFlipEnvMap = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      Xi.prototype.isCubeTexture = !0;
      class uo extends Ot {
        constructor(e, t, n) {
          Number.isInteger(t) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (t = n)),
            super(e, e, t),
            (t = t || {}),
            (this.texture = new Xi(
              void 0,
              t.mapping,
              t.wrapS,
              t.wrapT,
              t.magFilter,
              t.minFilter,
              t.format,
              t.type,
              t.anisotropy,
              t.encoding
            )),
            (this.texture.generateMipmaps =
              t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
              t.minFilter !== void 0 ? t.minFilter : Ke),
            (this.texture._needsFlipEnvMap = !1);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.format = Et),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new Qn(5, 5, 5),
            r = new sn({
              name: "CubemapFromEquirect",
              uniforms: Ni(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: Qe,
              blending: nn,
            });
          r.uniforms.tEquirect.value = t;
          const o = new $e(i, r),
            a = t.minFilter;
          return (
            t.minFilter === ln && (t.minFilter = Ke),
            new co(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      uo.prototype.isWebGLCubeRenderTarget = !0;
      const vi = new cn(),
        ms = new M();
      class Or {
        constructor(
          e = new Nt(),
          t = new Nt(),
          n = new Nt(),
          i = new Nt(),
          r = new Nt(),
          o = new Nt()
        ) {
          this.planes = [e, t, n, i, r, o];
        }
        set(e, t, n, i, r, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            o = n[2],
            a = n[3],
            c = n[4],
            l = n[5],
            u = n[6],
            h = n[7],
            d = n[8],
            f = n[9],
            p = n[10],
            x = n[11],
            y = n[12],
            m = n[13],
            g = n[14],
            _ = n[15];
          return (
            t[0].setComponents(a - i, h - c, x - d, _ - y).normalize(),
            t[1].setComponents(a + i, h + c, x + d, _ + y).normalize(),
            t[2].setComponents(a + r, h + l, x + f, _ + m).normalize(),
            t[3].setComponents(a - r, h - l, x - f, _ - m).normalize(),
            t[4].setComponents(a - o, h - u, x - p, _ - g).normalize(),
            t[5].setComponents(a + o, h + u, x + p, _ + g).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            t.boundingSphere === null && t.computeBoundingSphere(),
            vi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(vi)
          );
        }
        intersectsSprite(e) {
          return (
            vi.center.set(0, 0, 0),
            (vi.radius = 0.7071067811865476),
            vi.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(vi)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((ms.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (ms.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (ms.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(ms) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function ad() {
        let s = null,
          e = !1,
          t = null,
          n = null;
        function i(r, o) {
          t(r, o), (n = s.requestAnimationFrame(i));
        }
        return {
          start: function () {
            e !== !0 &&
              t !== null &&
              ((n = s.requestAnimationFrame(i)), (e = !0));
          },
          stop: function () {
            s.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (r) {
            t = r;
          },
          setContext: function (r) {
            s = r;
          },
        };
      }
      function _p(s, e) {
        const t = e.isWebGL2,
          n = new WeakMap();
        function i(l, u) {
          const h = l.array,
            d = l.usage,
            f = s.createBuffer();
          s.bindBuffer(u, f), s.bufferData(u, h, d), l.onUploadCallback();
          let p = 5126;
          return (
            h instanceof Float32Array
              ? (p = 5126)
              : h instanceof Float64Array
              ? console.warn(
                  "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                )
              : h instanceof Uint16Array
              ? l.isFloat16BufferAttribute
                ? t
                  ? (p = 5131)
                  : console.warn(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    )
                : (p = 5123)
              : h instanceof Int16Array
              ? (p = 5122)
              : h instanceof Uint32Array
              ? (p = 5125)
              : h instanceof Int32Array
              ? (p = 5124)
              : h instanceof Int8Array
              ? (p = 5120)
              : (h instanceof Uint8Array || h instanceof Uint8ClampedArray) &&
                (p = 5121),
            {
              buffer: f,
              type: p,
              bytesPerElement: h.BYTES_PER_ELEMENT,
              version: l.version,
            }
          );
        }
        function r(l, u, h) {
          const d = u.array,
            f = u.updateRange;
          s.bindBuffer(h, l),
            f.count === -1
              ? s.bufferSubData(h, 0, d)
              : (t
                  ? s.bufferSubData(
                      h,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d,
                      f.offset,
                      f.count
                    )
                  : s.bufferSubData(
                      h,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d.subarray(f.offset, f.offset + f.count)
                    ),
                (f.count = -1));
        }
        function o(l) {
          return l.isInterleavedBufferAttribute && (l = l.data), n.get(l);
        }
        function a(l) {
          l.isInterleavedBufferAttribute && (l = l.data);
          const u = n.get(l);
          u && (s.deleteBuffer(u.buffer), n.delete(l));
        }
        function c(l, u) {
          if (l.isGLBufferAttribute) {
            const d = n.get(l);
            (!d || d.version < l.version) &&
              n.set(l, {
                buffer: l.buffer,
                type: l.type,
                bytesPerElement: l.elementSize,
                version: l.version,
              });
            return;
          }
          l.isInterleavedBufferAttribute && (l = l.data);
          const h = n.get(l);
          h === void 0
            ? n.set(l, i(l, u))
            : h.version < l.version &&
              (r(h.buffer, l, u), (h.version = l.version));
        }
        return { get: o, remove: a, update: c };
      }
      class Sr extends de {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            o = t / 2,
            a = Math.floor(n),
            c = Math.floor(i),
            l = a + 1,
            u = c + 1,
            h = e / a,
            d = t / c,
            f = [],
            p = [],
            x = [],
            y = [];
          for (let m = 0; m < u; m++) {
            const g = m * d - o;
            for (let _ = 0; _ < l; _++) {
              const w = _ * h - r;
              p.push(w, -g, 0),
                x.push(0, 0, 1),
                y.push(_ / a),
                y.push(1 - m / c);
            }
          }
          for (let m = 0; m < c; m++)
            for (let g = 0; g < a; g++) {
              const _ = g + l * m,
                w = g + l * (m + 1),
                T = g + 1 + l * (m + 1),
                v = g + 1 + l * m;
              f.push(_, w, v), f.push(w, T, v);
            }
          this.setIndex(f),
            this.setAttribute("position", new le(p, 3)),
            this.setAttribute("normal", new le(x, 3)),
            this.setAttribute("uv", new le(y, 2));
        }
      }
      var Mp = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
        wp = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        bp = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,
        Sp = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,
        Tp = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        Ep = "vec3 transformed = vec3( position );",
        Ap = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        Lp = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,
        Rp = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        Cp = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
        Pp = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        Ip = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        Dp = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        Fp = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        Bp = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        Np = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
        Gp = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
        Op = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
        Up = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        zp = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Hp = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        kp = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
        Vp = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        Wp = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        qp = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        Xp = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
        Yp = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        Zp = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        Jp = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        jp = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        Kp = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        $p = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,
        Qp = `#ifdef USE_FOG
	varying float fogDepth;
#endif`,
        em = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        tm = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        nm = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
        im = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,
        rm = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        sm = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
        om = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,
        am = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,
        lm = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        cm = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
        um = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        hm = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
        dm = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,
        fm = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        pm = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        mm = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,
        gm = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
        xm = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        ym = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        vm = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
        _m = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
        Mm = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
        wm = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        bm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        Sm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        Tm = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        Em = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        Am = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,
        Lm = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
        Rm = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,
        Cm = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
        Pm = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        Im = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
        Dm = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
        Fm = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
        Bm = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
        Nm = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
        Gm = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        Om = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        Um = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        zm = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        Hm = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        km = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        Vm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
        Wm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        qm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
        Xm = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        Ym = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        Zm = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
        Jm = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        jm = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        Km = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        $m = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        Qm = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        eg = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        tg = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		totalTransmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSNMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	vec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );
	vec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );
	vec3 f90 = vec3( 1.0 );
	vec3 f_transmission = totalTransmission * getIBLVolumeRefraction(
		normal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance);
	diffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );
#endif`,
        ng = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec4 vWorldPosition;
	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));
		return normalize(refractionVector) * thickness * modelScale;
	}
	float applyIorToRoughness(float roughness, float ior) {
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}
	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}
	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;
		}
	}
	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);
		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);
		float NdotV = saturate(dot(n, viewDir));
		vec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);
		vec3 specularColor = f0 * brdf.x + f90 * brdf.y;
		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif`,
        ig = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
        rg = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
        sg = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
        og = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
        ag = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
        lg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
        cg = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
        ug = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        hg = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        dg = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        fg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        pg = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
        mg = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        gg = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        xg = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        yg = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        vg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        _g = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        Mg = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        wg = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        bg = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        Sg = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Tg = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Eg = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Ag = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        Lg = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Rg = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Cg = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Pg = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Ig = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform vec3 attenuationColor;
	uniform float attenuationDistance;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef USE_TRANSMISSION
		float totalTransmission = transmission;
		float thicknessFactor = thickness;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	vec3 rawDiffuseColor = diffuseColor.rgb;
	#include <transmission_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Dg = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#ifdef USE_TRANSMISSION
	varying vec4 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition;
#endif
}`,
        Fg = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
        Bg = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        Ng = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        Gg = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        Og = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Ug = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        zg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Hg = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
      const Ae = {
          alphamap_fragment: Mp,
          alphamap_pars_fragment: wp,
          alphatest_fragment: bp,
          aomap_fragment: Sp,
          aomap_pars_fragment: Tp,
          begin_vertex: Ep,
          beginnormal_vertex: Ap,
          bsdfs: Lp,
          bumpmap_pars_fragment: Rp,
          clipping_planes_fragment: Cp,
          clipping_planes_pars_fragment: Pp,
          clipping_planes_pars_vertex: Ip,
          clipping_planes_vertex: Dp,
          color_fragment: Fp,
          color_pars_fragment: Bp,
          color_pars_vertex: Np,
          color_vertex: Gp,
          common: Op,
          cube_uv_reflection_fragment: Up,
          defaultnormal_vertex: zp,
          displacementmap_pars_vertex: Hp,
          displacementmap_vertex: kp,
          emissivemap_fragment: Vp,
          emissivemap_pars_fragment: Wp,
          encodings_fragment: qp,
          encodings_pars_fragment: Xp,
          envmap_fragment: Yp,
          envmap_common_pars_fragment: Zp,
          envmap_pars_fragment: Jp,
          envmap_pars_vertex: jp,
          envmap_physical_pars_fragment: am,
          envmap_vertex: Kp,
          fog_vertex: $p,
          fog_pars_vertex: Qp,
          fog_fragment: em,
          fog_pars_fragment: tm,
          gradientmap_pars_fragment: nm,
          lightmap_fragment: im,
          lightmap_pars_fragment: rm,
          lights_lambert_vertex: sm,
          lights_pars_begin: om,
          lights_toon_fragment: lm,
          lights_toon_pars_fragment: cm,
          lights_phong_fragment: um,
          lights_phong_pars_fragment: hm,
          lights_physical_fragment: dm,
          lights_physical_pars_fragment: fm,
          lights_fragment_begin: pm,
          lights_fragment_maps: mm,
          lights_fragment_end: gm,
          logdepthbuf_fragment: xm,
          logdepthbuf_pars_fragment: ym,
          logdepthbuf_pars_vertex: vm,
          logdepthbuf_vertex: _m,
          map_fragment: Mm,
          map_pars_fragment: wm,
          map_particle_fragment: bm,
          map_particle_pars_fragment: Sm,
          metalnessmap_fragment: Tm,
          metalnessmap_pars_fragment: Em,
          morphnormal_vertex: Am,
          morphtarget_pars_vertex: Lm,
          morphtarget_vertex: Rm,
          normal_fragment_begin: Cm,
          normal_fragment_maps: Pm,
          normalmap_pars_fragment: Im,
          clearcoat_normal_fragment_begin: Dm,
          clearcoat_normal_fragment_maps: Fm,
          clearcoat_pars_fragment: Bm,
          packing: Nm,
          premultiplied_alpha_fragment: Gm,
          project_vertex: Om,
          dithering_fragment: Um,
          dithering_pars_fragment: zm,
          roughnessmap_fragment: Hm,
          roughnessmap_pars_fragment: km,
          shadowmap_pars_fragment: Vm,
          shadowmap_pars_vertex: Wm,
          shadowmap_vertex: qm,
          shadowmask_pars_fragment: Xm,
          skinbase_vertex: Ym,
          skinning_pars_vertex: Zm,
          skinning_vertex: Jm,
          skinnormal_vertex: jm,
          specularmap_fragment: Km,
          specularmap_pars_fragment: $m,
          tonemapping_fragment: Qm,
          tonemapping_pars_fragment: eg,
          transmission_fragment: tg,
          transmission_pars_fragment: ng,
          uv_pars_fragment: ig,
          uv_pars_vertex: rg,
          uv_vertex: sg,
          uv2_pars_fragment: og,
          uv2_pars_vertex: ag,
          uv2_vertex: lg,
          worldpos_vertex: cg,
          background_frag: ug,
          background_vert: hg,
          cube_frag: dg,
          cube_vert: fg,
          depth_frag: pg,
          depth_vert: mg,
          distanceRGBA_frag: gg,
          distanceRGBA_vert: xg,
          equirect_frag: yg,
          equirect_vert: vg,
          linedashed_frag: _g,
          linedashed_vert: Mg,
          meshbasic_frag: wg,
          meshbasic_vert: bg,
          meshlambert_frag: Sg,
          meshlambert_vert: Tg,
          meshmatcap_frag: Eg,
          meshmatcap_vert: Ag,
          meshtoon_frag: Lg,
          meshtoon_vert: Rg,
          meshphong_frag: Cg,
          meshphong_vert: Pg,
          meshphysical_frag: Ig,
          meshphysical_vert: Dg,
          normal_frag: Fg,
          normal_vert: Bg,
          points_frag: Ng,
          points_vert: Gg,
          shadow_frag: Og,
          shadow_vert: Ug,
          sprite_frag: zg,
          sprite_vert: Hg,
        },
        ee = {
          common: {
            diffuse: { value: new K(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new it() },
            uv2Transform: { value: new it() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new q(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new K(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new K(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new it() },
          },
          sprite: {
            diffuse: { value: new K(16777215) },
            opacity: { value: 1 },
            center: { value: new q(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new it() },
          },
        },
        Gt = {
          basic: {
            uniforms: mt([
              ee.common,
              ee.specularmap,
              ee.envmap,
              ee.aomap,
              ee.lightmap,
              ee.fog,
            ]),
            vertexShader: Ae.meshbasic_vert,
            fragmentShader: Ae.meshbasic_frag,
          },
          lambert: {
            uniforms: mt([
              ee.common,
              ee.specularmap,
              ee.envmap,
              ee.aomap,
              ee.lightmap,
              ee.emissivemap,
              ee.fog,
              ee.lights,
              { emissive: { value: new K(0) } },
            ]),
            vertexShader: Ae.meshlambert_vert,
            fragmentShader: Ae.meshlambert_frag,
          },
          phong: {
            uniforms: mt([
              ee.common,
              ee.specularmap,
              ee.envmap,
              ee.aomap,
              ee.lightmap,
              ee.emissivemap,
              ee.bumpmap,
              ee.normalmap,
              ee.displacementmap,
              ee.fog,
              ee.lights,
              {
                emissive: { value: new K(0) },
                specular: { value: new K(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Ae.meshphong_vert,
            fragmentShader: Ae.meshphong_frag,
          },
          standard: {
            uniforms: mt([
              ee.common,
              ee.envmap,
              ee.aomap,
              ee.lightmap,
              ee.emissivemap,
              ee.bumpmap,
              ee.normalmap,
              ee.displacementmap,
              ee.roughnessmap,
              ee.metalnessmap,
              ee.fog,
              ee.lights,
              {
                emissive: { value: new K(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Ae.meshphysical_vert,
            fragmentShader: Ae.meshphysical_frag,
          },
          toon: {
            uniforms: mt([
              ee.common,
              ee.aomap,
              ee.lightmap,
              ee.emissivemap,
              ee.bumpmap,
              ee.normalmap,
              ee.displacementmap,
              ee.gradientmap,
              ee.fog,
              ee.lights,
              { emissive: { value: new K(0) } },
            ]),
            vertexShader: Ae.meshtoon_vert,
            fragmentShader: Ae.meshtoon_frag,
          },
          matcap: {
            uniforms: mt([
              ee.common,
              ee.bumpmap,
              ee.normalmap,
              ee.displacementmap,
              ee.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Ae.meshmatcap_vert,
            fragmentShader: Ae.meshmatcap_frag,
          },
          points: {
            uniforms: mt([ee.points, ee.fog]),
            vertexShader: Ae.points_vert,
            fragmentShader: Ae.points_frag,
          },
          dashed: {
            uniforms: mt([
              ee.common,
              ee.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Ae.linedashed_vert,
            fragmentShader: Ae.linedashed_frag,
          },
          depth: {
            uniforms: mt([ee.common, ee.displacementmap]),
            vertexShader: Ae.depth_vert,
            fragmentShader: Ae.depth_frag,
          },
          normal: {
            uniforms: mt([
              ee.common,
              ee.bumpmap,
              ee.normalmap,
              ee.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Ae.normal_vert,
            fragmentShader: Ae.normal_frag,
          },
          sprite: {
            uniforms: mt([ee.sprite, ee.fog]),
            vertexShader: Ae.sprite_vert,
            fragmentShader: Ae.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new it() },
              t2D: { value: null },
            },
            vertexShader: Ae.background_vert,
            fragmentShader: Ae.background_frag,
          },
          cube: {
            uniforms: mt([ee.envmap, { opacity: { value: 1 } }]),
            vertexShader: Ae.cube_vert,
            fragmentShader: Ae.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Ae.equirect_vert,
            fragmentShader: Ae.equirect_frag,
          },
          distanceRGBA: {
            uniforms: mt([
              ee.common,
              ee.displacementmap,
              {
                referencePosition: { value: new M() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Ae.distanceRGBA_vert,
            fragmentShader: Ae.distanceRGBA_frag,
          },
          shadow: {
            uniforms: mt([
              ee.lights,
              ee.fog,
              { color: { value: new K(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Ae.shadow_vert,
            fragmentShader: Ae.shadow_frag,
          },
        };
      Gt.physical = {
        uniforms: mt([
          Gt.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new q(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new K(0) },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new q() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new K(0) },
          },
        ]),
        vertexShader: Ae.meshphysical_vert,
        fragmentShader: Ae.meshphysical_frag,
      };
      function kg(s, e, t, n, i) {
        const r = new K(0);
        let o = 0,
          a,
          c,
          l = null,
          u = 0,
          h = null;
        function d(p, x) {
          let y = !1,
            m = x.isScene === !0 ? x.background : null;
          m && m.isTexture && (m = e.get(m));
          const g = s.xr,
            _ = g.getSession && g.getSession();
          _ && _.environmentBlendMode === "additive" && (m = null),
            m === null ? f(r, o) : m && m.isColor && (f(m, 1), (y = !0)),
            (s.autoClear || y) &&
              s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
            m && (m.isCubeTexture || m.mapping === Wi)
              ? (c === void 0 &&
                  ((c = new $e(
                    new Qn(1, 1, 1),
                    new sn({
                      name: "BackgroundCubeMaterial",
                      uniforms: Ni(Gt.cube.uniforms),
                      vertexShader: Gt.cube.vertexShader,
                      fragmentShader: Gt.cube.fragmentShader,
                      side: Qe,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  c.geometry.deleteAttribute("uv"),
                  (c.onBeforeRender = function (w, T, v) {
                    this.matrixWorld.copyPosition(v.matrixWorld);
                  }),
                  Object.defineProperty(c.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(c)),
                (c.material.uniforms.envMap.value = m),
                (c.material.uniforms.flipEnvMap.value =
                  m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1),
                (l !== m || u !== m.version || h !== s.toneMapping) &&
                  ((c.material.needsUpdate = !0),
                  (l = m),
                  (u = m.version),
                  (h = s.toneMapping)),
                p.unshift(c, c.geometry, c.material, 0, 0, null))
              : m &&
                m.isTexture &&
                (a === void 0 &&
                  ((a = new $e(
                    new Sr(2, 2),
                    new sn({
                      name: "BackgroundMaterial",
                      uniforms: Ni(Gt.background.uniforms),
                      vertexShader: Gt.background.vertexShader,
                      fragmentShader: Gt.background.fragmentShader,
                      side: jn,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(a)),
                (a.material.uniforms.t2D.value = m),
                m.matrixAutoUpdate === !0 && m.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(m.matrix),
                (l !== m || u !== m.version || h !== s.toneMapping) &&
                  ((a.material.needsUpdate = !0),
                  (l = m),
                  (u = m.version),
                  (h = s.toneMapping)),
                p.unshift(a, a.geometry, a.material, 0, 0, null));
        }
        function f(p, x) {
          t.buffers.color.setClear(p.r, p.g, p.b, x, i);
        }
        return {
          getClearColor: function () {
            return r;
          },
          setClearColor: function (p, x = 1) {
            r.set(p), (o = x), f(r, o);
          },
          getClearAlpha: function () {
            return o;
          },
          setClearAlpha: function (p) {
            (o = p), f(r, o);
          },
          render: d,
        };
      }
      function Vg(s, e, t, n) {
        const i = s.getParameter(34921),
          r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = n.isWebGL2 || r !== null,
          a = {},
          c = x(null);
        let l = c;
        function u(R, D, F, C, V) {
          let te = !1;
          if (o) {
            const J = p(C, F, D);
            l !== J && ((l = J), d(l.object)), (te = y(C, V)), te && m(C, V);
          } else {
            const J = D.wireframe === !0;
            (l.geometry !== C.id || l.program !== F.id || l.wireframe !== J) &&
              ((l.geometry = C.id),
              (l.program = F.id),
              (l.wireframe = J),
              (te = !0));
          }
          R.isInstancedMesh === !0 && (te = !0),
            V !== null && t.update(V, 34963),
            te &&
              (A(R, D, F, C),
              V !== null && s.bindBuffer(34963, t.get(V).buffer));
        }
        function h() {
          return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
        }
        function d(R) {
          return n.isWebGL2 ? s.bindVertexArray(R) : r.bindVertexArrayOES(R);
        }
        function f(R) {
          return n.isWebGL2
            ? s.deleteVertexArray(R)
            : r.deleteVertexArrayOES(R);
        }
        function p(R, D, F) {
          const C = F.wireframe === !0;
          let V = a[R.id];
          V === void 0 && ((V = {}), (a[R.id] = V));
          let te = V[D.id];
          te === void 0 && ((te = {}), (V[D.id] = te));
          let J = te[C];
          return J === void 0 && ((J = x(h())), (te[C] = J)), J;
        }
        function x(R) {
          const D = [],
            F = [],
            C = [];
          for (let V = 0; V < i; V++) (D[V] = 0), (F[V] = 0), (C[V] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: D,
            enabledAttributes: F,
            attributeDivisors: C,
            object: R,
            attributes: {},
            index: null,
          };
        }
        function y(R, D) {
          const F = l.attributes,
            C = R.attributes;
          let V = 0;
          for (const te in C) {
            const J = F[te],
              oe = C[te];
            if (J === void 0 || J.attribute !== oe || J.data !== oe.data)
              return !0;
            V++;
          }
          return l.attributesNum !== V || l.index !== D;
        }
        function m(R, D) {
          const F = {},
            C = R.attributes;
          let V = 0;
          for (const te in C) {
            const J = C[te],
              oe = {};
            (oe.attribute = J), J.data && (oe.data = J.data), (F[te] = oe), V++;
          }
          (l.attributes = F), (l.attributesNum = V), (l.index = D);
        }
        function g() {
          const R = l.newAttributes;
          for (let D = 0, F = R.length; D < F; D++) R[D] = 0;
        }
        function _(R) {
          w(R, 0);
        }
        function w(R, D) {
          const F = l.newAttributes,
            C = l.enabledAttributes,
            V = l.attributeDivisors;
          (F[R] = 1),
            C[R] === 0 && (s.enableVertexAttribArray(R), (C[R] = 1)),
            V[R] !== D &&
              ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](R, D),
              (V[R] = D));
        }
        function T() {
          const R = l.newAttributes,
            D = l.enabledAttributes;
          for (let F = 0, C = D.length; F < C; F++)
            D[F] !== R[F] && (s.disableVertexAttribArray(F), (D[F] = 0));
        }
        function v(R, D, F, C, V, te) {
          n.isWebGL2 === !0 && (F === 5124 || F === 5125)
            ? s.vertexAttribIPointer(R, D, F, V, te)
            : s.vertexAttribPointer(R, D, F, C, V, te);
        }
        function A(R, D, F, C) {
          if (
            n.isWebGL2 === !1 &&
            (R.isInstancedMesh || C.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
          )
            return;
          g();
          const V = C.attributes,
            te = F.getAttributes(),
            J = D.defaultAttributeValues;
          for (const oe in te) {
            const re = te[oe];
            if (re >= 0) {
              const we = V[oe];
              if (we !== void 0) {
                const _e = we.normalized,
                  Be = we.itemSize,
                  Ce = t.get(we);
                if (Ce === void 0) continue;
                const k = Ce.buffer,
                  Ve = Ce.type,
                  Pe = Ce.bytesPerElement;
                if (we.isInterleavedBufferAttribute) {
                  const Me = we.data,
                    me = Me.stride,
                    Le = we.offset;
                  Me && Me.isInstancedInterleavedBuffer
                    ? (w(re, Me.meshPerAttribute),
                      C._maxInstanceCount === void 0 &&
                        (C._maxInstanceCount = Me.meshPerAttribute * Me.count))
                    : _(re),
                    s.bindBuffer(34962, k),
                    v(re, Be, Ve, _e, me * Pe, Le * Pe);
                } else
                  we.isInstancedBufferAttribute
                    ? (w(re, we.meshPerAttribute),
                      C._maxInstanceCount === void 0 &&
                        (C._maxInstanceCount = we.meshPerAttribute * we.count))
                    : _(re),
                    s.bindBuffer(34962, k),
                    v(re, Be, Ve, _e, 0, 0);
              } else if (oe === "instanceMatrix") {
                const _e = t.get(R.instanceMatrix);
                if (_e === void 0) continue;
                const Be = _e.buffer,
                  Ce = _e.type;
                w(re + 0, 1),
                  w(re + 1, 1),
                  w(re + 2, 1),
                  w(re + 3, 1),
                  s.bindBuffer(34962, Be),
                  s.vertexAttribPointer(re + 0, 4, Ce, !1, 64, 0),
                  s.vertexAttribPointer(re + 1, 4, Ce, !1, 64, 16),
                  s.vertexAttribPointer(re + 2, 4, Ce, !1, 64, 32),
                  s.vertexAttribPointer(re + 3, 4, Ce, !1, 64, 48);
              } else if (oe === "instanceColor") {
                const _e = t.get(R.instanceColor);
                if (_e === void 0) continue;
                const Be = _e.buffer,
                  Ce = _e.type;
                w(re, 1),
                  s.bindBuffer(34962, Be),
                  s.vertexAttribPointer(re, 3, Ce, !1, 12, 0);
              } else if (J !== void 0) {
                const _e = J[oe];
                if (_e !== void 0)
                  switch (_e.length) {
                    case 2:
                      s.vertexAttrib2fv(re, _e);
                      break;
                    case 3:
                      s.vertexAttrib3fv(re, _e);
                      break;
                    case 4:
                      s.vertexAttrib4fv(re, _e);
                      break;
                    default:
                      s.vertexAttrib1fv(re, _e);
                  }
              }
            }
          }
          T();
        }
        function L() {
          U();
          for (const R in a) {
            const D = a[R];
            for (const F in D) {
              const C = D[F];
              for (const V in C) f(C[V].object), delete C[V];
              delete D[F];
            }
            delete a[R];
          }
        }
        function I(R) {
          if (a[R.id] === void 0) return;
          const D = a[R.id];
          for (const F in D) {
            const C = D[F];
            for (const V in C) f(C[V].object), delete C[V];
            delete D[F];
          }
          delete a[R.id];
        }
        function N(R) {
          for (const D in a) {
            const F = a[D];
            if (F[R.id] === void 0) continue;
            const C = F[R.id];
            for (const V in C) f(C[V].object), delete C[V];
            delete F[R.id];
          }
        }
        function U() {
          G(), l !== c && ((l = c), d(l.object));
        }
        function G() {
          (c.geometry = null), (c.program = null), (c.wireframe = !1);
        }
        return {
          setup: u,
          reset: U,
          resetDefaultState: G,
          dispose: L,
          releaseStatesOfGeometry: I,
          releaseStatesOfProgram: N,
          initAttributes: g,
          enableAttribute: _,
          disableUnusedAttributes: T,
        };
      }
      function Wg(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(l) {
          r = l;
        }
        function a(l, u) {
          s.drawArrays(r, l, u), t.update(u, r, 1);
        }
        function c(l, u, h) {
          if (h === 0) return;
          let d, f;
          if (i) (d = s), (f = "drawArraysInstanced");
          else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
          ) {
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          d[f](r, l, u, h), t.update(u, r, h);
        }
        (this.setMode = o), (this.render = a), (this.renderInstances = c);
      }
      function qg(s, e, t) {
        let n;
        function i() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const A = e.get("EXT_texture_filter_anisotropic");
            n = s.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function r(A) {
          if (A === "highp") {
            if (
              s.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              s.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            A = "mediump";
          }
          return A === "mediump" &&
            s.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            s.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          (typeof WebGL2RenderingContext != "undefined" &&
            s instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext != "undefined" &&
            s instanceof WebGL2ComputeRenderingContext);
        let a = t.precision !== void 0 ? t.precision : "highp";
        const c = r(a);
        c !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            c,
            "instead."
          ),
          (a = c));
        const l = o || e.has("WEBGL_draw_buffers"),
          u = t.logarithmicDepthBuffer === !0,
          h = s.getParameter(34930),
          d = s.getParameter(35660),
          f = s.getParameter(3379),
          p = s.getParameter(34076),
          x = s.getParameter(34921),
          y = s.getParameter(36347),
          m = s.getParameter(36348),
          g = s.getParameter(36349),
          _ = d > 0,
          w = o || e.has("OES_texture_float"),
          T = _ && w,
          v = o ? s.getParameter(36183) : 0;
        return {
          isWebGL2: o,
          drawBuffers: l,
          getMaxAnisotropy: i,
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: u,
          maxTextures: h,
          maxVertexTextures: d,
          maxTextureSize: f,
          maxCubemapSize: p,
          maxAttributes: x,
          maxVertexUniforms: y,
          maxVaryings: m,
          maxFragmentUniforms: g,
          vertexTextures: _,
          floatFragmentTextures: w,
          floatVertexTextures: T,
          maxSamples: v,
        };
      }
      function Xg(s) {
        const e = this;
        let t = null,
          n = 0,
          i = !1,
          r = !1;
        const o = new Nt(),
          a = new it(),
          c = { value: null, needsUpdate: !1 };
        (this.uniform = c),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (h, d, f) {
            const p = h.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = u(h, f, 0)), (n = h.length), p;
          }),
          (this.beginShadows = function () {
            (r = !0), u(null);
          }),
          (this.endShadows = function () {
            (r = !1), l();
          }),
          (this.setState = function (h, d, f) {
            const p = h.clippingPlanes,
              x = h.clipIntersection,
              y = h.clipShadows,
              m = s.get(h);
            if (!i || p === null || p.length === 0 || (r && !y))
              r ? u(null) : l();
            else {
              const g = r ? 0 : n,
                _ = g * 4;
              let w = m.clippingState || null;
              (c.value = w), (w = u(p, d, _, f));
              for (let T = 0; T !== _; ++T) w[T] = t[T];
              (m.clippingState = w),
                (this.numIntersection = x ? this.numPlanes : 0),
                (this.numPlanes += g);
            }
          });
        function l() {
          c.value !== t && ((c.value = t), (c.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function u(h, d, f, p) {
          const x = h !== null ? h.length : 0;
          let y = null;
          if (x !== 0) {
            if (((y = c.value), p !== !0 || y === null)) {
              const m = f + x * 4,
                g = d.matrixWorldInverse;
              a.getNormalMatrix(g),
                (y === null || y.length < m) && (y = new Float32Array(m));
              for (let _ = 0, w = f; _ !== x; ++_, w += 4)
                o.copy(h[_]).applyMatrix4(g, a),
                  o.normal.toArray(y, w),
                  (y[w + 3] = o.constant);
            }
            (c.value = y), (c.needsUpdate = !0);
          }
          return (e.numPlanes = x), (e.numIntersection = 0), y;
        }
      }
      function Yg(s) {
        let e = new WeakMap();
        function t(o, a) {
          return a === ks ? (o.mapping = Fr) : a === Vs && (o.mapping = Br), o;
        }
        function n(o) {
          if (o && o.isTexture) {
            const a = o.mapping;
            if (a === ks || a === Vs)
              if (e.has(o)) {
                const c = e.get(o).texture;
                return t(c, o.mapping);
              } else {
                const c = o.image;
                if (c && c.height > 0) {
                  const l = s.getRenderTarget(),
                    u = new uo(c.height / 2);
                  return (
                    u.fromEquirectangularTexture(s, o),
                    e.set(o, u),
                    s.setRenderTarget(l),
                    o.addEventListener("dispose", i),
                    t(u.texture, o.mapping)
                  );
                } else return null;
              }
          }
          return o;
        }
        function i(o) {
          const a = o.target;
          a.removeEventListener("dispose", i);
          const c = e.get(a);
          c !== void 0 && (e.delete(a), c.dispose());
        }
        function r() {
          e = new WeakMap();
        }
        return { get: n, dispose: r };
      }
      function Zg(s) {
        const e = {};
        function t(n) {
          if (e[n] !== void 0) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                s.getExtension("WEBGL_depth_texture") ||
                s.getExtension("MOZ_WEBGL_depth_texture") ||
                s.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                s.getExtension("EXT_texture_filter_anisotropic") ||
                s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                s.getExtension("WEBGL_compressed_texture_s3tc") ||
                s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                s.getExtension("WEBGL_compressed_texture_pvrtc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = s.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (n) {
            return t(n) !== null;
          },
          init: function (n) {
            n.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float");
          },
          get: function (n) {
            const i = t(n);
            return (
              i === null &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              i
            );
          },
        };
      }
      function Jg(s, e, t, n) {
        const i = {},
          r = new WeakMap();
        function o(h) {
          const d = h.target;
          d.index !== null && e.remove(d.index);
          for (const p in d.attributes) e.remove(d.attributes[p]);
          d.removeEventListener("dispose", o), delete i[d.id];
          const f = r.get(d);
          f && (e.remove(f), r.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
        }
        function a(h, d) {
          return (
            i[d.id] === !0 ||
              (d.addEventListener("dispose", o),
              (i[d.id] = !0),
              t.memory.geometries++),
            d
          );
        }
        function c(h) {
          const d = h.attributes;
          for (const p in d) e.update(d[p], 34962);
          const f = h.morphAttributes;
          for (const p in f) {
            const x = f[p];
            for (let y = 0, m = x.length; y < m; y++) e.update(x[y], 34962);
          }
        }
        function l(h) {
          const d = [],
            f = h.index,
            p = h.attributes.position;
          let x = 0;
          if (f !== null) {
            const g = f.array;
            x = f.version;
            for (let _ = 0, w = g.length; _ < w; _ += 3) {
              const T = g[_ + 0],
                v = g[_ + 1],
                A = g[_ + 2];
              d.push(T, v, v, A, A, T);
            }
          } else {
            const g = p.array;
            x = p.version;
            for (let _ = 0, w = g.length / 3 - 1; _ < w; _ += 3) {
              const T = _ + 0,
                v = _ + 1,
                A = _ + 2;
              d.push(T, v, v, A, A, T);
            }
          }
          const y = new (sd(d) > 65535 ? lo : ao)(d, 1);
          y.version = x;
          const m = r.get(h);
          m && e.remove(m), r.set(h, y);
        }
        function u(h) {
          const d = r.get(h);
          if (d) {
            const f = h.index;
            f !== null && d.version < f.version && l(h);
          } else l(h);
          return r.get(h);
        }
        return { get: a, update: c, getWireframeAttribute: u };
      }
      function jg(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(d) {
          r = d;
        }
        let a, c;
        function l(d) {
          (a = d.type), (c = d.bytesPerElement);
        }
        function u(d, f) {
          s.drawElements(r, f, a, d * c), t.update(f, r, 1);
        }
        function h(d, f, p) {
          if (p === 0) return;
          let x, y;
          if (i) (x = s), (y = "drawElementsInstanced");
          else if (
            ((x = e.get("ANGLE_instanced_arrays")),
            (y = "drawElementsInstancedANGLE"),
            x === null)
          ) {
            console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          x[y](r, f, a, d * c, p), t.update(f, r, p);
        }
        (this.setMode = o),
          (this.setIndex = l),
          (this.render = u),
          (this.renderInstances = h);
      }
      function Kg(s) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(r, o, a) {
          switch ((t.calls++, o)) {
            case 4:
              t.triangles += a * (r / 3);
              break;
            case 1:
              t.lines += a * (r / 2);
              break;
            case 3:
              t.lines += a * (r - 1);
              break;
            case 2:
              t.lines += a * r;
              break;
            case 0:
              t.points += a * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", o);
              break;
          }
        }
        function i() {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: !0,
          reset: i,
          update: n,
        };
      }
      function $g(s, e) {
        return s[0] - e[0];
      }
      function Qg(s, e) {
        return Math.abs(e[1]) - Math.abs(s[1]);
      }
      function ex(s) {
        const e = {},
          t = new Float32Array(8),
          n = [];
        for (let r = 0; r < 8; r++) n[r] = [r, 0];
        function i(r, o, a, c) {
          const l = r.morphTargetInfluences,
            u = l === void 0 ? 0 : l.length;
          let h = e[o.id];
          if (h === void 0) {
            h = [];
            for (let y = 0; y < u; y++) h[y] = [y, 0];
            e[o.id] = h;
          }
          for (let y = 0; y < u; y++) {
            const m = h[y];
            (m[0] = y), (m[1] = l[y]);
          }
          h.sort(Qg);
          for (let y = 0; y < 8; y++)
            y < u && h[y][1]
              ? ((n[y][0] = h[y][0]), (n[y][1] = h[y][1]))
              : ((n[y][0] = Number.MAX_SAFE_INTEGER), (n[y][1] = 0));
          n.sort($g);
          const d = a.morphTargets && o.morphAttributes.position,
            f = a.morphNormals && o.morphAttributes.normal;
          let p = 0;
          for (let y = 0; y < 8; y++) {
            const m = n[y],
              g = m[0],
              _ = m[1];
            g !== Number.MAX_SAFE_INTEGER && _
              ? (d &&
                  o.getAttribute("morphTarget" + y) !== d[g] &&
                  o.setAttribute("morphTarget" + y, d[g]),
                f &&
                  o.getAttribute("morphNormal" + y) !== f[g] &&
                  o.setAttribute("morphNormal" + y, f[g]),
                (t[y] = _),
                (p += _))
              : (d &&
                  o.hasAttribute("morphTarget" + y) === !0 &&
                  o.deleteAttribute("morphTarget" + y),
                f &&
                  o.hasAttribute("morphNormal" + y) === !0 &&
                  o.deleteAttribute("morphNormal" + y),
                (t[y] = 0));
          }
          const x = o.morphTargetsRelative ? 1 : 1 - p;
          c.getUniforms().setValue(s, "morphTargetBaseInfluence", x),
            c.getUniforms().setValue(s, "morphTargetInfluences", t);
        }
        return { update: i };
      }
      function tx(s, e, t, n) {
        let i = new WeakMap();
        function r(c) {
          const l = n.render.frame,
            u = c.geometry,
            h = e.get(c, u);
          return (
            i.get(h) !== l && (e.update(h), i.set(h, l)),
            c.isInstancedMesh &&
              (c.hasEventListener("dispose", a) === !1 &&
                c.addEventListener("dispose", a),
              t.update(c.instanceMatrix, 34962),
              c.instanceColor !== null && t.update(c.instanceColor, 34962)),
            h
          );
        }
        function o() {
          i = new WeakMap();
        }
        function a(c) {
          const l = c.target;
          l.removeEventListener("dispose", a),
            t.remove(l.instanceMatrix),
            l.instanceColor !== null && t.remove(l.instanceColor);
        }
        return { update: r, dispose: o };
      }
      class $a extends rt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = Je),
            (this.minFilter = Je),
            (this.wrapR = at),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      $a.prototype.isDataTexture2DArray = !0;
      class Qa extends rt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = Je),
            (this.minFilter = Je),
            (this.wrapR = at),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      Qa.prototype.isDataTexture3D = !0;
      const ld = new rt(),
        nx = new $a(),
        ix = new Qa(),
        cd = new Xi(),
        Ql = [],
        ec = [],
        tc = new Float32Array(16),
        nc = new Float32Array(9),
        ic = new Float32Array(4);
      function Yi(s, e, t) {
        const n = s[0];
        if (n <= 0 || n > 0) return s;
        const i = e * t;
        let r = Ql[i];
        if (
          (r === void 0 && ((r = new Float32Array(i)), (Ql[i] = r)), e !== 0)
        ) {
          n.toArray(r, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), s[o].toArray(r, a);
        }
        return r;
      }
      function _t(s, e) {
        if (s.length !== e.length) return !1;
        for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
        return !0;
      }
      function gt(s, e) {
        for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
      }
      function ud(s, e) {
        let t = ec[e];
        t === void 0 && ((t = new Int32Array(e)), (ec[e] = t));
        for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
        return t;
      }
      function rx(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
      }
      function sx(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y) &&
            (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (_t(t, e)) return;
          s.uniform2fv(this.addr, e), gt(t, e);
        }
      }
      function ox(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (s.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (s.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (_t(t, e)) return;
          s.uniform3fv(this.addr, e), gt(t, e);
        }
      }
      function ax(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (_t(t, e)) return;
          s.uniform4fv(this.addr, e), gt(t, e);
        }
      }
      function lx(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (_t(t, e)) return;
          s.uniformMatrix2fv(this.addr, !1, e), gt(t, e);
        } else {
          if (_t(t, n)) return;
          ic.set(n), s.uniformMatrix2fv(this.addr, !1, ic), gt(t, n);
        }
      }
      function cx(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (_t(t, e)) return;
          s.uniformMatrix3fv(this.addr, !1, e), gt(t, e);
        } else {
          if (_t(t, n)) return;
          nc.set(n), s.uniformMatrix3fv(this.addr, !1, nc), gt(t, n);
        }
      }
      function ux(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (_t(t, e)) return;
          s.uniformMatrix4fv(this.addr, !1, e), gt(t, e);
        } else {
          if (_t(t, n)) return;
          tc.set(n), s.uniformMatrix4fv(this.addr, !1, tc), gt(t, n);
        }
      }
      function hx(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
      }
      function dx(s, e) {
        const t = this.cache;
        _t(t, e) || (s.uniform2iv(this.addr, e), gt(t, e));
      }
      function fx(s, e) {
        const t = this.cache;
        _t(t, e) || (s.uniform3iv(this.addr, e), gt(t, e));
      }
      function px(s, e) {
        const t = this.cache;
        _t(t, e) || (s.uniform4iv(this.addr, e), gt(t, e));
      }
      function mx(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
      }
      function gx(s, e) {
        const t = this.cache;
        _t(t, e) || (s.uniform2uiv(this.addr, e), gt(t, e));
      }
      function xx(s, e) {
        const t = this.cache;
        _t(t, e) || (s.uniform3uiv(this.addr, e), gt(t, e));
      }
      function yx(s, e) {
        const t = this.cache;
        _t(t, e) || (s.uniform4uiv(this.addr, e), gt(t, e));
      }
      function vx(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.safeSetTexture2D(e || ld, i);
      }
      function _x(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture3D(e || ix, i);
      }
      function Mx(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.safeSetTextureCube(e || cd, i);
      }
      function wx(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2DArray(e || nx, i);
      }
      function bx(s) {
        switch (s) {
          case 5126:
            return rx;
          case 35664:
            return sx;
          case 35665:
            return ox;
          case 35666:
            return ax;
          case 35674:
            return lx;
          case 35675:
            return cx;
          case 35676:
            return ux;
          case 5124:
          case 35670:
            return hx;
          case 35667:
          case 35671:
            return dx;
          case 35668:
          case 35672:
            return fx;
          case 35669:
          case 35673:
            return px;
          case 5125:
            return mx;
          case 36294:
            return gx;
          case 36295:
            return xx;
          case 36296:
            return yx;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return vx;
          case 35679:
          case 36299:
          case 36307:
            return _x;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Mx;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return wx;
        }
      }
      function Sx(s, e) {
        s.uniform1fv(this.addr, e);
      }
      function Tx(s, e) {
        const t = Yi(e, this.size, 2);
        s.uniform2fv(this.addr, t);
      }
      function Ex(s, e) {
        const t = Yi(e, this.size, 3);
        s.uniform3fv(this.addr, t);
      }
      function Ax(s, e) {
        const t = Yi(e, this.size, 4);
        s.uniform4fv(this.addr, t);
      }
      function Lx(s, e) {
        const t = Yi(e, this.size, 4);
        s.uniformMatrix2fv(this.addr, !1, t);
      }
      function Rx(s, e) {
        const t = Yi(e, this.size, 9);
        s.uniformMatrix3fv(this.addr, !1, t);
      }
      function Cx(s, e) {
        const t = Yi(e, this.size, 16);
        s.uniformMatrix4fv(this.addr, !1, t);
      }
      function Px(s, e) {
        s.uniform1iv(this.addr, e);
      }
      function Ix(s, e) {
        s.uniform2iv(this.addr, e);
      }
      function Dx(s, e) {
        s.uniform3iv(this.addr, e);
      }
      function Fx(s, e) {
        s.uniform4iv(this.addr, e);
      }
      function Bx(s, e) {
        s.uniform1uiv(this.addr, e);
      }
      function Nx(s, e) {
        s.uniform2uiv(this.addr, e);
      }
      function Gx(s, e) {
        s.uniform3uiv(this.addr, e);
      }
      function Ox(s, e) {
        s.uniform4uiv(this.addr, e);
      }
      function Ux(s, e, t) {
        const n = e.length,
          i = ud(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.safeSetTexture2D(e[r] || ld, i[r]);
      }
      function zx(s, e, t) {
        const n = e.length,
          i = ud(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.safeSetTextureCube(e[r] || cd, i[r]);
      }
      function Hx(s) {
        switch (s) {
          case 5126:
            return Sx;
          case 35664:
            return Tx;
          case 35665:
            return Ex;
          case 35666:
            return Ax;
          case 35674:
            return Lx;
          case 35675:
            return Rx;
          case 35676:
            return Cx;
          case 5124:
          case 35670:
            return Px;
          case 35667:
          case 35671:
            return Ix;
          case 35668:
          case 35672:
            return Dx;
          case 35669:
          case 35673:
            return Fx;
          case 5125:
            return Bx;
          case 36294:
            return Nx;
          case 36295:
            return Gx;
          case 36296:
            return Ox;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Ux;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return zx;
        }
      }
      function kx(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.setValue = bx(e.type));
      }
      function hd(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = Hx(e.type));
      }
      hd.prototype.updateCache = function (s) {
        const e = this.cache;
        s instanceof Float32Array &&
          e.length !== s.length &&
          (this.cache = new Float32Array(s.length)),
          gt(e, s);
      };
      function dd(s) {
        (this.id = s), (this.seq = []), (this.map = {});
      }
      dd.prototype.setValue = function (s, e, t) {
        const n = this.seq;
        for (let i = 0, r = n.length; i !== r; ++i) {
          const o = n[i];
          o.setValue(s, e[o.id], t);
        }
      };
      const jo = /(\w+)(\])?(\[|\.)?/g;
      function rc(s, e) {
        s.seq.push(e), (s.map[e.id] = e);
      }
      function Vx(s, e, t) {
        const n = s.name,
          i = n.length;
        for (jo.lastIndex = 0; ; ) {
          const r = jo.exec(n),
            o = jo.lastIndex;
          let a = r[1];
          const c = r[2] === "]",
            l = r[3];
          if ((c && (a = a | 0), l === void 0 || (l === "[" && o + 2 === i))) {
            rc(t, l === void 0 ? new kx(a, s, e) : new hd(a, s, e));
            break;
          } else {
            let h = t.map[a];
            h === void 0 && ((h = new dd(a)), rc(t, h)), (t = h);
          }
        }
      }
      function vn(s, e) {
        (this.seq = []), (this.map = {});
        const t = s.getProgramParameter(e, 35718);
        for (let n = 0; n < t; ++n) {
          const i = s.getActiveUniform(e, n),
            r = s.getUniformLocation(e, i.name);
          Vx(i, r, this);
        }
      }
      vn.prototype.setValue = function (s, e, t, n) {
        const i = this.map[e];
        i !== void 0 && i.setValue(s, t, n);
      };
      vn.prototype.setOptional = function (s, e, t) {
        const n = e[t];
        n !== void 0 && this.setValue(s, t, n);
      };
      vn.upload = function (s, e, t, n) {
        for (let i = 0, r = e.length; i !== r; ++i) {
          const o = e[i],
            a = t[o.id];
          a.needsUpdate !== !1 && o.setValue(s, a.value, n);
        }
      };
      vn.seqWithValue = function (s, e) {
        const t = [];
        for (let n = 0, i = s.length; n !== i; ++n) {
          const r = s[n];
          r.id in e && t.push(r);
        }
        return t;
      };
      function sc(s, e, t) {
        const n = s.createShader(e);
        return s.shaderSource(n, t), s.compileShader(n), n;
      }
      let Wx = 0;
      function qx(s) {
        const e = s.split(`
`);
        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join(`
`);
      }
      function fd(s) {
        switch (s) {
          case vt:
            return ["Linear", "( value )"];
          case $n:
            return ["sRGB", "( value )"];
          case oo:
            return ["RGBE", "( value )"];
          case Ya:
            return ["RGBM", "( value, 7.0 )"];
          case Za:
            return ["RGBM", "( value, 16.0 )"];
          case Ja:
            return ["RGBD", "( value, 256.0 )"];
          case so:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case kh:
            return ["LogLuv", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", s),
              ["Linear", "( value )"]
            );
        }
      }
      function oc(s, e, t) {
        const n = s.getShaderParameter(e, 35713),
          i = s.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const r = s.getShaderSource(e);
        return (
          "THREE.WebGLShader: gl.getShaderInfoLog() " +
          t +
          `
` +
          i +
          qx(r)
        );
      }
      function ir(s, e) {
        const t = fd(e);
        return (
          "vec4 " +
          s +
          "( vec4 value ) { return " +
          t[0] +
          "ToLinear" +
          t[1] +
          "; }"
        );
      }
      function Xx(s, e) {
        const t = fd(e);
        return (
          "vec4 " + s + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function Yx(s, e) {
        let t;
        switch (e) {
          case zu:
            t = "Linear";
            break;
          case Hu:
            t = "Reinhard";
            break;
          case ku:
            t = "OptimizedCineon";
            break;
          case Vu:
            t = "ACESFilmic";
            break;
          case Wu:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          s +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function Zx(s) {
        return [
          s.extensionDerivatives ||
          s.envMapCubeUV ||
          s.bumpMap ||
          s.tangentSpaceNormalMap ||
          s.clearcoatNormalMap ||
          s.flatShading ||
          s.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
          s.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (s.extensionShaderTextureLOD || s.envMap || s.transmission > 0) &&
          s.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ].filter(fr).join(`
`);
      }
      function Jx(s) {
        const e = [];
        for (const t in s) {
          const n = s[t];
          n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
      }
      function jx(s, e) {
        const t = {},
          n = s.getProgramParameter(e, 35721);
        for (let i = 0; i < n; i++) {
          const o = s.getActiveAttrib(e, i).name;
          t[o] = s.getAttribLocation(e, o);
        }
        return t;
      }
      function fr(s) {
        return s !== "";
      }
      function ac(s, e) {
        return s
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function lc(s, e) {
        return s
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const Kx = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Pa(s) {
        return s.replace(Kx, $x);
      }
      function $x(s, e) {
        const t = Ae[e];
        if (t === void 0)
          throw new Error("Can not resolve #include <" + e + ">");
        return Pa(t);
      }
      const Qx =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        ey =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function cc(s) {
        return s.replace(ey, pd).replace(Qx, ty);
      }
      function ty(s, e, t, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          pd(s, e, t, n)
        );
      }
      function pd(s, e, t, n) {
        let i = "";
        for (let r = parseInt(e); r < parseInt(t); r++)
          i += n
            .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, r);
        return i;
      }
      function uc(s) {
        let e =
          "precision " +
          s.precision +
          ` float;
precision ` +
          s.precision +
          " int;";
        return (
          s.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : s.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : s.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function ny(s) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          s.shadowMapType === Ha
            ? (e = "SHADOWMAP_TYPE_PCF")
            : s.shadowMapType === yu
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : s.shadowMapType === Ei && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function iy(s) {
        let e = "ENVMAP_TYPE_CUBE";
        if (s.envMap)
          switch (s.envMapMode) {
            case Fr:
            case Br:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case Wi:
            case Nr:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function ry(s) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (s.envMap)
          switch (s.envMapMode) {
            case Br:
            case Nr:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function sy(s) {
        let e = "ENVMAP_BLENDING_NONE";
        if (s.envMap)
          switch (s.combine) {
            case Dr:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case Ou:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case Uu:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function oy(s, e, t, n) {
        const i = s.getContext(),
          r = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const c = ny(t),
          l = iy(t),
          u = ry(t),
          h = sy(t),
          d = s.gammaFactor > 0 ? s.gammaFactor : 1,
          f = t.isWebGL2 ? "" : Zx(t),
          p = Jx(r),
          x = i.createProgram();
        let y,
          m,
          g = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((y = [p].filter(fr).join(`
`)),
            y.length > 0 &&
              (y += `
`),
            (m = [f, p].filter(fr).join(`
`)),
            m.length > 0 &&
              (m += `
`))
          : ((y = [
              uc(t),
              "#define SHADER_NAME " + t.shaderName,
              p,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + d,
              "#define MAX_BONES " + t.maxBones,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.useVertexTexture ? "#define BONE_TEXTURE" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + c : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(fr).join(`
`)),
            (m = [
              f,
              uc(t),
              "#define SHADER_NAME " + t.shaderName,
              p,
              t.alphaTest
                ? "#define ALPHATEST " +
                  t.alphaTest +
                  (t.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + d,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + l : "",
              t.envMap ? "#define " + u : "",
              t.envMap ? "#define " + h : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + c : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (t.extensionShaderTextureLOD || t.envMap) &&
              t.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== Yn ? "#define TONE_MAPPING" : "",
              t.toneMapping !== Yn ? Ae.tonemapping_pars_fragment : "",
              t.toneMapping !== Yn ? Yx("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              Ae.encodings_pars_fragment,
              t.map ? ir("mapTexelToLinear", t.mapEncoding) : "",
              t.matcap ? ir("matcapTexelToLinear", t.matcapEncoding) : "",
              t.envMap ? ir("envMapTexelToLinear", t.envMapEncoding) : "",
              t.emissiveMap
                ? ir("emissiveMapTexelToLinear", t.emissiveMapEncoding)
                : "",
              t.lightMap ? ir("lightMapTexelToLinear", t.lightMapEncoding) : "",
              Xx("linearToOutputTexel", t.outputEncoding),
              t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
              `
`,
            ].filter(fr).join(`
`))),
          (o = Pa(o)),
          (o = ac(o, t)),
          (o = lc(o, t)),
          (a = Pa(a)),
          (a = ac(a, t)),
          (a = lc(a, t)),
          (o = cc(o)),
          (a = cc(a)),
          t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((g = `#version 300 es
`),
            (y =
              [
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              y),
            (m =
              [
                "#define varying in",
                t.glslVersion === La ? "" : "out highp vec4 pc_fragColor;",
                t.glslVersion === La ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              m));
        const _ = g + y + o,
          w = g + m + a,
          T = sc(i, 35633, _),
          v = sc(i, 35632, w);
        if (
          (i.attachShader(x, T),
          i.attachShader(x, v),
          t.index0AttributeName !== void 0
            ? i.bindAttribLocation(x, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"),
          i.linkProgram(x),
          s.debug.checkShaderErrors)
        ) {
          const I = i.getProgramInfoLog(x).trim(),
            N = i.getShaderInfoLog(T).trim(),
            U = i.getShaderInfoLog(v).trim();
          let G = !0,
            R = !0;
          if (i.getProgramParameter(x, 35714) === !1) {
            G = !1;
            const D = oc(i, T, "vertex"),
              F = oc(i, v, "fragment");
            console.error(
              "THREE.WebGLProgram: shader error: ",
              i.getError(),
              "35715",
              i.getProgramParameter(x, 35715),
              "gl.getProgramInfoLog",
              I,
              D,
              F
            );
          } else
            I !== ""
              ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", I)
              : (N === "" || U === "") && (R = !1);
          R &&
            (this.diagnostics = {
              runnable: G,
              programLog: I,
              vertexShader: { log: N, prefix: y },
              fragmentShader: { log: U, prefix: m },
            });
        }
        i.deleteShader(T), i.deleteShader(v);
        let A;
        this.getUniforms = function () {
          return A === void 0 && (A = new vn(i, x)), A;
        };
        let L;
        return (
          (this.getAttributes = function () {
            return L === void 0 && (L = jx(i, x)), L;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              i.deleteProgram(x),
              (this.program = void 0);
          }),
          (this.name = t.shaderName),
          (this.id = Wx++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = x),
          (this.vertexShader = T),
          (this.fragmentShader = v),
          this
        );
      }
      function ay(s, e, t, n, i, r) {
        const o = [],
          a = n.isWebGL2,
          c = n.logarithmicDepthBuffer,
          l = n.floatVertexTextures,
          u = n.maxVertexUniforms,
          h = n.vertexTextures;
        let d = n.precision;
        const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
          p = [
            "precision",
            "isWebGL2",
            "supportsVertexTextures",
            "outputEncoding",
            "instancing",
            "instancingColor",
            "map",
            "mapEncoding",
            "matcap",
            "matcapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "envMapCubeUV",
            "lightMap",
            "lightMapEncoding",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "tangentSpaceNormalMap",
            "clearcoatMap",
            "clearcoatRoughnessMap",
            "clearcoatNormalMap",
            "displacementMap",
            "specularMap",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "vertexAlphas",
            "vertexTangents",
            "vertexUvs",
            "uvsVertexOnly",
            "fog",
            "useFog",
            "fogExp2",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "numDirLightShadows",
            "numPointLightShadows",
            "numSpotLightShadows",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
            "sheen",
            "transmission",
            "transmissionMap",
            "thicknessMap",
          ];
        function x(v) {
          const L = v.skeleton.bones;
          if (l) return 1024;
          {
            const N = Math.floor((u - 20) / 4),
              U = Math.min(N, L.length);
            return U < L.length
              ? (console.warn(
                  "THREE.WebGLRenderer: Skeleton has " +
                    L.length +
                    " bones. This GPU supports " +
                    U +
                    "."
                ),
                0)
              : U;
          }
        }
        function y(v) {
          let A;
          return (
            v && v.isTexture
              ? (A = v.encoding)
              : v && v.isWebGLRenderTarget
              ? (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (A = v.texture.encoding))
              : (A = vt),
            A
          );
        }
        function m(v, A, L, I, N) {
          const U = I.fog,
            G = v.isMeshStandardMaterial ? I.environment : null,
            R = e.get(v.envMap || G),
            D = f[v.type],
            F = N.isSkinnedMesh ? x(N) : 0;
          v.precision !== null &&
            ((d = n.getMaxPrecision(v.precision)),
            d !== v.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                v.precision,
                "not supported, using",
                d,
                "instead."
              ));
          let C, V;
          if (D) {
            const oe = Gt[D];
            (C = oe.vertexShader), (V = oe.fragmentShader);
          } else (C = v.vertexShader), (V = v.fragmentShader);
          const te = s.getRenderTarget();
          return {
            isWebGL2: a,
            shaderID: D,
            shaderName: v.type,
            vertexShader: C,
            fragmentShader: V,
            defines: v.defines,
            isRawShaderMaterial: v.isRawShaderMaterial === !0,
            glslVersion: v.glslVersion,
            precision: d,
            instancing: N.isInstancedMesh === !0,
            instancingColor:
              N.isInstancedMesh === !0 && N.instanceColor !== null,
            supportsVertexTextures: h,
            outputEncoding: te !== null ? y(te.texture) : s.outputEncoding,
            map: !!v.map,
            mapEncoding: y(v.map),
            matcap: !!v.matcap,
            matcapEncoding: y(v.matcap),
            envMap: !!R,
            envMapMode: R && R.mapping,
            envMapEncoding: y(R),
            envMapCubeUV: !!R && (R.mapping === Wi || R.mapping === Nr),
            lightMap: !!v.lightMap,
            lightMapEncoding: y(v.lightMap),
            aoMap: !!v.aoMap,
            emissiveMap: !!v.emissiveMap,
            emissiveMapEncoding: y(v.emissiveMap),
            bumpMap: !!v.bumpMap,
            normalMap: !!v.normalMap,
            objectSpaceNormalMap: v.normalMapType === qh,
            tangentSpaceNormalMap: v.normalMapType === En,
            clearcoatMap: !!v.clearcoatMap,
            clearcoatRoughnessMap: !!v.clearcoatRoughnessMap,
            clearcoatNormalMap: !!v.clearcoatNormalMap,
            displacementMap: !!v.displacementMap,
            roughnessMap: !!v.roughnessMap,
            metalnessMap: !!v.metalnessMap,
            specularMap: !!v.specularMap,
            alphaMap: !!v.alphaMap,
            gradientMap: !!v.gradientMap,
            sheen: !!v.sheen,
            transmission: !!v.transmission,
            transmissionMap: !!v.transmissionMap,
            thicknessMap: !!v.thicknessMap,
            combine: v.combine,
            vertexTangents: v.normalMap && v.vertexTangents,
            vertexColors: v.vertexColors,
            vertexAlphas:
              v.vertexColors === !0 &&
              N.geometry &&
              N.geometry.attributes.color &&
              N.geometry.attributes.color.itemSize === 4,
            vertexUvs:
              !!v.map ||
              !!v.bumpMap ||
              !!v.normalMap ||
              !!v.specularMap ||
              !!v.alphaMap ||
              !!v.emissiveMap ||
              !!v.roughnessMap ||
              !!v.metalnessMap ||
              !!v.clearcoatMap ||
              !!v.clearcoatRoughnessMap ||
              !!v.clearcoatNormalMap ||
              !!v.displacementMap ||
              !!v.transmission ||
              !!v.transmissionMap ||
              !!v.thicknessMap,
            uvsVertexOnly:
              !(
                !!v.map ||
                !!v.bumpMap ||
                !!v.normalMap ||
                !!v.specularMap ||
                !!v.alphaMap ||
                !!v.emissiveMap ||
                !!v.roughnessMap ||
                !!v.metalnessMap ||
                !!v.clearcoatNormalMap ||
                !!v.transmission ||
                !!v.transmissionMap ||
                !!v.thicknessMap
              ) && !!v.displacementMap,
            fog: !!U,
            useFog: v.fog,
            fogExp2: U && U.isFogExp2,
            flatShading: !!v.flatShading,
            sizeAttenuation: v.sizeAttenuation,
            logarithmicDepthBuffer: c,
            skinning: N.isSkinnedMesh === !0 && F > 0,
            maxBones: F,
            useVertexTexture: l,
            morphTargets: v.morphTargets,
            morphNormals: v.morphNormals,
            numDirLights: A.directional.length,
            numPointLights: A.point.length,
            numSpotLights: A.spot.length,
            numRectAreaLights: A.rectArea.length,
            numHemiLights: A.hemi.length,
            numDirLightShadows: A.directionalShadowMap.length,
            numPointLightShadows: A.pointShadowMap.length,
            numSpotLightShadows: A.spotShadowMap.length,
            numClippingPlanes: r.numPlanes,
            numClipIntersection: r.numIntersection,
            dithering: v.dithering,
            shadowMapEnabled: s.shadowMap.enabled && L.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: v.toneMapped ? s.toneMapping : Yn,
            physicallyCorrectLights: s.physicallyCorrectLights,
            premultipliedAlpha: v.premultipliedAlpha,
            alphaTest: v.alphaTest,
            doubleSided: v.side === Vi,
            flipSided: v.side === Qe,
            depthPacking: v.depthPacking !== void 0 ? v.depthPacking : !1,
            index0AttributeName: v.index0AttributeName,
            extensionDerivatives: v.extensions && v.extensions.derivatives,
            extensionFragDepth: v.extensions && v.extensions.fragDepth,
            extensionDrawBuffers: v.extensions && v.extensions.drawBuffers,
            extensionShaderTextureLOD:
              v.extensions && v.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: a || t.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: a || t.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              a || t.has("EXT_shader_texture_lod"),
            customProgramCacheKey: v.customProgramCacheKey(),
          };
        }
        function g(v) {
          const A = [];
          if (
            (v.shaderID
              ? A.push(v.shaderID)
              : (A.push(v.fragmentShader), A.push(v.vertexShader)),
            v.defines !== void 0)
          )
            for (const L in v.defines) A.push(L), A.push(v.defines[L]);
          if (v.isRawShaderMaterial === !1) {
            for (let L = 0; L < p.length; L++) A.push(v[p[L]]);
            A.push(s.outputEncoding), A.push(s.gammaFactor);
          }
          return A.push(v.customProgramCacheKey), A.join();
        }
        function _(v) {
          const A = f[v.type];
          let L;
          if (A) {
            const I = Gt[A];
            L = od.clone(I.uniforms);
          } else L = v.uniforms;
          return L;
        }
        function w(v, A) {
          let L;
          for (let I = 0, N = o.length; I < N; I++) {
            const U = o[I];
            if (U.cacheKey === A) {
              (L = U), ++L.usedTimes;
              break;
            }
          }
          return L === void 0 && ((L = new oy(s, A, v, i)), o.push(L)), L;
        }
        function T(v) {
          if (--v.usedTimes === 0) {
            const A = o.indexOf(v);
            (o[A] = o[o.length - 1]), o.pop(), v.destroy();
          }
        }
        return {
          getParameters: m,
          getProgramCacheKey: g,
          getUniforms: _,
          acquireProgram: w,
          releaseProgram: T,
          programs: o,
        };
      }
      function ly() {
        let s = new WeakMap();
        function e(r) {
          let o = s.get(r);
          return o === void 0 && ((o = {}), s.set(r, o)), o;
        }
        function t(r) {
          s.delete(r);
        }
        function n(r, o, a) {
          s.get(r)[o] = a;
        }
        function i() {
          s = new WeakMap();
        }
        return { get: e, remove: t, update: n, dispose: i };
      }
      function cy(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.program !== e.program
          ? s.program.id - e.program.id
          : s.material.id !== e.material.id
          ? s.material.id - e.material.id
          : s.z !== e.z
          ? s.z - e.z
          : s.id - e.id;
      }
      function hc(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.z !== e.z
          ? e.z - s.z
          : s.id - e.id;
      }
      function dc(s) {
        const e = [];
        let t = 0;
        const n = [],
          i = [],
          r = [],
          o = { id: -1 };
        function a() {
          (t = 0), (n.length = 0), (i.length = 0), (r.length = 0);
        }
        function c(f, p, x, y, m, g) {
          let _ = e[t];
          const w = s.get(x);
          return (
            _ === void 0
              ? ((_ = {
                  id: f.id,
                  object: f,
                  geometry: p,
                  material: x,
                  program: w.program || o,
                  groupOrder: y,
                  renderOrder: f.renderOrder,
                  z: m,
                  group: g,
                }),
                (e[t] = _))
              : ((_.id = f.id),
                (_.object = f),
                (_.geometry = p),
                (_.material = x),
                (_.program = w.program || o),
                (_.groupOrder = y),
                (_.renderOrder = f.renderOrder),
                (_.z = m),
                (_.group = g)),
            t++,
            _
          );
        }
        function l(f, p, x, y, m, g) {
          const _ = c(f, p, x, y, m, g);
          x.transmission > 0
            ? i.push(_)
            : x.transparent === !0
            ? r.push(_)
            : n.push(_);
        }
        function u(f, p, x, y, m, g) {
          const _ = c(f, p, x, y, m, g);
          x.transmission > 0
            ? i.unshift(_)
            : x.transparent === !0
            ? r.unshift(_)
            : n.unshift(_);
        }
        function h(f, p) {
          n.length > 1 && n.sort(f || cy),
            i.length > 1 && i.sort(p || hc),
            r.length > 1 && r.sort(p || hc);
        }
        function d() {
          for (let f = t, p = e.length; f < p; f++) {
            const x = e[f];
            if (x.id === null) break;
            (x.id = null),
              (x.object = null),
              (x.geometry = null),
              (x.material = null),
              (x.program = null),
              (x.group = null);
          }
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: a,
          push: l,
          unshift: u,
          finish: d,
          sort: h,
        };
      }
      function uy(s) {
        let e = new WeakMap();
        function t(i, r) {
          let o;
          return (
            e.has(i) === !1
              ? ((o = new dc(s)), e.set(i, [o]))
              : r >= e.get(i).length
              ? ((o = new dc(s)), e.get(i).push(o))
              : (o = e.get(i)[r]),
            o
          );
        }
        function n() {
          e = new WeakMap();
        }
        return { get: t, dispose: n };
      }
      function hy() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new M(), color: new K() };
                break;
              case "SpotLight":
                t = {
                  position: new M(),
                  direction: new M(),
                  color: new K(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new M(),
                  color: new K(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new M(),
                  skyColor: new K(),
                  groundColor: new K(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new K(),
                  position: new M(),
                  halfWidth: new M(),
                  halfHeight: new M(),
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      function dy() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new q(),
                };
                break;
              case "SpotLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new q(),
                };
                break;
              case "PointLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new q(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      let fy = 0;
      function py(s, e) {
        return (e.castShadow ? 1 : 0) - (s.castShadow ? 1 : 0);
      }
      function my(s, e) {
        const t = new hy(),
          n = dy(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let u = 0; u < 9; u++) i.probe.push(new M());
        const r = new M(),
          o = new ce(),
          a = new ce();
        function c(u) {
          let h = 0,
            d = 0,
            f = 0;
          for (let A = 0; A < 9; A++) i.probe[A].set(0, 0, 0);
          let p = 0,
            x = 0,
            y = 0,
            m = 0,
            g = 0,
            _ = 0,
            w = 0,
            T = 0;
          u.sort(py);
          for (let A = 0, L = u.length; A < L; A++) {
            const I = u[A],
              N = I.color,
              U = I.intensity,
              G = I.distance,
              R = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
            if (I.isAmbientLight)
              (h += N.r * U), (d += N.g * U), (f += N.b * U);
            else if (I.isLightProbe)
              for (let D = 0; D < 9; D++)
                i.probe[D].addScaledVector(I.sh.coefficients[D], U);
            else if (I.isDirectionalLight) {
              const D = t.get(I);
              if (
                (D.color.copy(I.color).multiplyScalar(I.intensity),
                I.castShadow)
              ) {
                const F = I.shadow,
                  C = n.get(I);
                (C.shadowBias = F.bias),
                  (C.shadowNormalBias = F.normalBias),
                  (C.shadowRadius = F.radius),
                  (C.shadowMapSize = F.mapSize),
                  (i.directionalShadow[p] = C),
                  (i.directionalShadowMap[p] = R),
                  (i.directionalShadowMatrix[p] = I.shadow.matrix),
                  _++;
              }
              (i.directional[p] = D), p++;
            } else if (I.isSpotLight) {
              const D = t.get(I);
              if (
                (D.position.setFromMatrixPosition(I.matrixWorld),
                D.color.copy(N).multiplyScalar(U),
                (D.distance = G),
                (D.coneCos = Math.cos(I.angle)),
                (D.penumbraCos = Math.cos(I.angle * (1 - I.penumbra))),
                (D.decay = I.decay),
                I.castShadow)
              ) {
                const F = I.shadow,
                  C = n.get(I);
                (C.shadowBias = F.bias),
                  (C.shadowNormalBias = F.normalBias),
                  (C.shadowRadius = F.radius),
                  (C.shadowMapSize = F.mapSize),
                  (i.spotShadow[y] = C),
                  (i.spotShadowMap[y] = R),
                  (i.spotShadowMatrix[y] = I.shadow.matrix),
                  T++;
              }
              (i.spot[y] = D), y++;
            } else if (I.isRectAreaLight) {
              const D = t.get(I);
              D.color.copy(N).multiplyScalar(U),
                D.halfWidth.set(I.width * 0.5, 0, 0),
                D.halfHeight.set(0, I.height * 0.5, 0),
                (i.rectArea[m] = D),
                m++;
            } else if (I.isPointLight) {
              const D = t.get(I);
              if (
                (D.color.copy(I.color).multiplyScalar(I.intensity),
                (D.distance = I.distance),
                (D.decay = I.decay),
                I.castShadow)
              ) {
                const F = I.shadow,
                  C = n.get(I);
                (C.shadowBias = F.bias),
                  (C.shadowNormalBias = F.normalBias),
                  (C.shadowRadius = F.radius),
                  (C.shadowMapSize = F.mapSize),
                  (C.shadowCameraNear = F.camera.near),
                  (C.shadowCameraFar = F.camera.far),
                  (i.pointShadow[x] = C),
                  (i.pointShadowMap[x] = R),
                  (i.pointShadowMatrix[x] = I.shadow.matrix),
                  w++;
              }
              (i.point[x] = D), x++;
            } else if (I.isHemisphereLight) {
              const D = t.get(I);
              D.skyColor.copy(I.color).multiplyScalar(U),
                D.groundColor.copy(I.groundColor).multiplyScalar(U),
                (i.hemi[g] = D),
                g++;
            }
          }
          m > 0 &&
            (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = ee.LTC_FLOAT_1),
                (i.rectAreaLTC2 = ee.LTC_FLOAT_2))
              : s.has("OES_texture_half_float_linear") === !0
              ? ((i.rectAreaLTC1 = ee.LTC_HALF_1),
                (i.rectAreaLTC2 = ee.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = h),
            (i.ambient[1] = d),
            (i.ambient[2] = f);
          const v = i.hash;
          (v.directionalLength !== p ||
            v.pointLength !== x ||
            v.spotLength !== y ||
            v.rectAreaLength !== m ||
            v.hemiLength !== g ||
            v.numDirectionalShadows !== _ ||
            v.numPointShadows !== w ||
            v.numSpotShadows !== T) &&
            ((i.directional.length = p),
            (i.spot.length = y),
            (i.rectArea.length = m),
            (i.point.length = x),
            (i.hemi.length = g),
            (i.directionalShadow.length = _),
            (i.directionalShadowMap.length = _),
            (i.pointShadow.length = w),
            (i.pointShadowMap.length = w),
            (i.spotShadow.length = T),
            (i.spotShadowMap.length = T),
            (i.directionalShadowMatrix.length = _),
            (i.pointShadowMatrix.length = w),
            (i.spotShadowMatrix.length = T),
            (v.directionalLength = p),
            (v.pointLength = x),
            (v.spotLength = y),
            (v.rectAreaLength = m),
            (v.hemiLength = g),
            (v.numDirectionalShadows = _),
            (v.numPointShadows = w),
            (v.numSpotShadows = T),
            (i.version = fy++));
        }
        function l(u, h) {
          let d = 0,
            f = 0,
            p = 0,
            x = 0,
            y = 0;
          const m = h.matrixWorldInverse;
          for (let g = 0, _ = u.length; g < _; g++) {
            const w = u[g];
            if (w.isDirectionalLight) {
              const T = i.directional[d];
              T.direction.setFromMatrixPosition(w.matrixWorld),
                r.setFromMatrixPosition(w.target.matrixWorld),
                T.direction.sub(r),
                T.direction.transformDirection(m),
                d++;
            } else if (w.isSpotLight) {
              const T = i.spot[p];
              T.position.setFromMatrixPosition(w.matrixWorld),
                T.position.applyMatrix4(m),
                T.direction.setFromMatrixPosition(w.matrixWorld),
                r.setFromMatrixPosition(w.target.matrixWorld),
                T.direction.sub(r),
                T.direction.transformDirection(m),
                p++;
            } else if (w.isRectAreaLight) {
              const T = i.rectArea[x];
              T.position.setFromMatrixPosition(w.matrixWorld),
                T.position.applyMatrix4(m),
                a.identity(),
                o.copy(w.matrixWorld),
                o.premultiply(m),
                a.extractRotation(o),
                T.halfWidth.set(w.width * 0.5, 0, 0),
                T.halfHeight.set(0, w.height * 0.5, 0),
                T.halfWidth.applyMatrix4(a),
                T.halfHeight.applyMatrix4(a),
                x++;
            } else if (w.isPointLight) {
              const T = i.point[f];
              T.position.setFromMatrixPosition(w.matrixWorld),
                T.position.applyMatrix4(m),
                f++;
            } else if (w.isHemisphereLight) {
              const T = i.hemi[y];
              T.direction.setFromMatrixPosition(w.matrixWorld),
                T.direction.transformDirection(m),
                T.direction.normalize(),
                y++;
            }
          }
        }
        return { setup: c, setupView: l, state: i };
      }
      function fc(s, e) {
        const t = new my(s, e),
          n = [],
          i = [];
        function r() {
          (n.length = 0), (i.length = 0);
        }
        function o(h) {
          n.push(h);
        }
        function a(h) {
          i.push(h);
        }
        function c() {
          t.setup(n);
        }
        function l(h) {
          t.setupView(n, h);
        }
        return {
          init: r,
          state: { lightsArray: n, shadowsArray: i, lights: t },
          setupLights: c,
          setupLightsView: l,
          pushLight: o,
          pushShadow: a,
        };
      }
      function gy(s, e) {
        let t = new WeakMap();
        function n(r, o = 0) {
          let a;
          return (
            t.has(r) === !1
              ? ((a = new fc(s, e)), t.set(r, [a]))
              : o >= t.get(r).length
              ? ((a = new fc(s, e)), t.get(r).push(a))
              : (a = t.get(r)[o]),
            a
          );
        }
        function i() {
          t = new WeakMap();
        }
        return { get: n, dispose: i };
      }
      class ho extends et {
        constructor(e) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = Vh),
            (this.morphTargets = !1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      ho.prototype.isMeshDepthMaterial = !0;
      class fo extends et {
        constructor(e) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new M()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.morphTargets = !1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      fo.prototype.isMeshDistanceMaterial = !0;
      var xy = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,
        yy = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
      function md(s, e, t) {
        let n = new Or();
        const i = new q(),
          r = new q(),
          o = new Ge(),
          a = [],
          c = [],
          l = {},
          u = t.maxTextureSize,
          h = { 0: Qe, 1: jn, 2: Vi },
          d = new sn({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new q() },
              radius: { value: 4 },
            },
            vertexShader: yy,
            fragmentShader: xy,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const p = new de();
        p.setAttribute(
          "position",
          new be(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const x = new $e(p, d),
          y = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = Ha),
          (this.render = function (v, A, L) {
            if (
              y.enabled === !1 ||
              (y.autoUpdate === !1 && y.needsUpdate === !1) ||
              v.length === 0
            )
              return;
            const I = s.getRenderTarget(),
              N = s.getActiveCubeFace(),
              U = s.getActiveMipmapLevel(),
              G = s.state;
            G.setBlending(nn),
              G.buffers.color.setClear(1, 1, 1, 1),
              G.buffers.depth.setTest(!0),
              G.setScissorTest(!1);
            for (let R = 0, D = v.length; R < D; R++) {
              const F = v[R],
                C = F.shadow;
              if (C === void 0) {
                console.warn("THREE.WebGLShadowMap:", F, "has no shadow.");
                continue;
              }
              if (C.autoUpdate === !1 && C.needsUpdate === !1) continue;
              i.copy(C.mapSize);
              const V = C.getFrameExtents();
              if (
                (i.multiply(V),
                r.copy(C.mapSize),
                (i.x > u || i.y > u) &&
                  (i.x > u &&
                    ((r.x = Math.floor(u / V.x)),
                    (i.x = r.x * V.x),
                    (C.mapSize.x = r.x)),
                  i.y > u &&
                    ((r.y = Math.floor(u / V.y)),
                    (i.y = r.y * V.y),
                    (C.mapSize.y = r.y))),
                C.map === null && !C.isPointLightShadow && this.type === Ei)
              ) {
                const J = { minFilter: Ke, magFilter: Ke, format: Et };
                (C.map = new Ot(i.x, i.y, J)),
                  (C.map.texture.name = F.name + ".shadowMap"),
                  (C.mapPass = new Ot(i.x, i.y, J)),
                  C.camera.updateProjectionMatrix();
              }
              if (C.map === null) {
                const J = { minFilter: Je, magFilter: Je, format: Et };
                (C.map = new Ot(i.x, i.y, J)),
                  (C.map.texture.name = F.name + ".shadowMap"),
                  C.camera.updateProjectionMatrix();
              }
              s.setRenderTarget(C.map), s.clear();
              const te = C.getViewportCount();
              for (let J = 0; J < te; J++) {
                const oe = C.getViewport(J);
                o.set(r.x * oe.x, r.y * oe.y, r.x * oe.z, r.y * oe.w),
                  G.viewport(o),
                  C.updateMatrices(F, J),
                  (n = C.getFrustum()),
                  T(A, L, C.camera, F, this.type);
              }
              !C.isPointLightShadow && this.type === Ei && m(C, L),
                (C.needsUpdate = !1);
            }
            (y.needsUpdate = !1), s.setRenderTarget(I, N, U);
          });
        function m(v, A) {
          const L = e.update(x);
          (d.uniforms.shadow_pass.value = v.map.texture),
            (d.uniforms.resolution.value = v.mapSize),
            (d.uniforms.radius.value = v.radius),
            s.setRenderTarget(v.mapPass),
            s.clear(),
            s.renderBufferDirect(A, null, L, d, x, null),
            (f.uniforms.shadow_pass.value = v.mapPass.texture),
            (f.uniforms.resolution.value = v.mapSize),
            (f.uniforms.radius.value = v.radius),
            s.setRenderTarget(v.map),
            s.clear(),
            s.renderBufferDirect(A, null, L, f, x, null);
        }
        function g(v) {
          const A = v << 0;
          let L = a[A];
          return (
            L === void 0 &&
              ((L = new ho({ depthPacking: Wh, morphTargets: v })), (a[A] = L)),
            L
          );
        }
        function _(v) {
          const A = v << 0;
          let L = c[A];
          return (
            L === void 0 && ((L = new fo({ morphTargets: v })), (c[A] = L)), L
          );
        }
        function w(v, A, L, I, N, U, G) {
          let R = null,
            D = g,
            F = v.customDepthMaterial;
          if (
            (I.isPointLight === !0 && ((D = _), (F = v.customDistanceMaterial)),
            F === void 0)
          ) {
            let C = !1;
            L.morphTargets === !0 &&
              (C =
                A.morphAttributes &&
                A.morphAttributes.position &&
                A.morphAttributes.position.length > 0),
              (R = D(C));
          } else R = F;
          if (
            s.localClippingEnabled &&
            L.clipShadows === !0 &&
            L.clippingPlanes.length !== 0
          ) {
            const C = R.uuid,
              V = L.uuid;
            let te = l[C];
            te === void 0 && ((te = {}), (l[C] = te));
            let J = te[V];
            J === void 0 && ((J = R.clone()), (te[V] = J)), (R = J);
          }
          return (
            (R.visible = L.visible),
            (R.wireframe = L.wireframe),
            G === Ei
              ? (R.side = L.shadowSide !== null ? L.shadowSide : L.side)
              : (R.side = L.shadowSide !== null ? L.shadowSide : h[L.side]),
            (R.clipShadows = L.clipShadows),
            (R.clippingPlanes = L.clippingPlanes),
            (R.clipIntersection = L.clipIntersection),
            (R.wireframeLinewidth = L.wireframeLinewidth),
            (R.linewidth = L.linewidth),
            I.isPointLight === !0 &&
              R.isMeshDistanceMaterial === !0 &&
              (R.referencePosition.setFromMatrixPosition(I.matrixWorld),
              (R.nearDistance = N),
              (R.farDistance = U)),
            R
          );
        }
        function T(v, A, L, I, N) {
          if (v.visible === !1) return;
          if (
            v.layers.test(A.layers) &&
            (v.isMesh || v.isLine || v.isPoints) &&
            (v.castShadow || (v.receiveShadow && N === Ei)) &&
            (!v.frustumCulled || n.intersectsObject(v))
          ) {
            v.modelViewMatrix.multiplyMatrices(
              L.matrixWorldInverse,
              v.matrixWorld
            );
            const R = e.update(v),
              D = v.material;
            if (Array.isArray(D)) {
              const F = R.groups;
              for (let C = 0, V = F.length; C < V; C++) {
                const te = F[C],
                  J = D[te.materialIndex];
                if (J && J.visible) {
                  const oe = w(v, R, J, I, L.near, L.far, N);
                  s.renderBufferDirect(L, null, R, oe, v, te);
                }
              }
            } else if (D.visible) {
              const F = w(v, R, D, I, L.near, L.far, N);
              s.renderBufferDirect(L, null, R, F, v, null);
            }
          }
          const G = v.children;
          for (let R = 0, D = G.length; R < D; R++) T(G[R], A, L, I, N);
        }
      }
      function vy(s, e, t) {
        const n = t.isWebGL2;
        function i() {
          let P = !1;
          const j = new Ge();
          let W = null;
          const fe = new Ge(0, 0, 0, 0);
          return {
            setMask: function (ie) {
              W !== ie && !P && (s.colorMask(ie, ie, ie, ie), (W = ie));
            },
            setLocked: function (ie) {
              P = ie;
            },
            setClear: function (ie, ke, dt, ft, Pn) {
              Pn === !0 && ((ie *= ft), (ke *= ft), (dt *= ft)),
                j.set(ie, ke, dt, ft),
                fe.equals(j) === !1 &&
                  (s.clearColor(ie, ke, dt, ft), fe.copy(j));
            },
            reset: function () {
              (P = !1), (W = null), fe.set(-1, 0, 0, 0);
            },
          };
        }
        function r() {
          let P = !1,
            j = null,
            W = null,
            fe = null;
          return {
            setTest: function (ie) {
              ie ? Be(2929) : Ce(2929);
            },
            setMask: function (ie) {
              j !== ie && !P && (s.depthMask(ie), (j = ie));
            },
            setFunc: function (ie) {
              if (W !== ie) {
                if (ie)
                  switch (ie) {
                    case Pu:
                      s.depthFunc(512);
                      break;
                    case Iu:
                      s.depthFunc(519);
                      break;
                    case Du:
                      s.depthFunc(513);
                      break;
                    case Hs:
                      s.depthFunc(515);
                      break;
                    case Fu:
                      s.depthFunc(514);
                      break;
                    case Bu:
                      s.depthFunc(518);
                      break;
                    case Nu:
                      s.depthFunc(516);
                      break;
                    case Gu:
                      s.depthFunc(517);
                      break;
                    default:
                      s.depthFunc(515);
                  }
                else s.depthFunc(515);
                W = ie;
              }
            },
            setLocked: function (ie) {
              P = ie;
            },
            setClear: function (ie) {
              fe !== ie && (s.clearDepth(ie), (fe = ie));
            },
            reset: function () {
              (P = !1), (j = null), (W = null), (fe = null);
            },
          };
        }
        function o() {
          let P = !1,
            j = null,
            W = null,
            fe = null,
            ie = null,
            ke = null,
            dt = null,
            ft = null,
            Pn = null;
          return {
            setTest: function (Xe) {
              P || (Xe ? Be(2960) : Ce(2960));
            },
            setMask: function (Xe) {
              j !== Xe && !P && (s.stencilMask(Xe), (j = Xe));
            },
            setFunc: function (Xe, Zt, Pt) {
              (W !== Xe || fe !== Zt || ie !== Pt) &&
                (s.stencilFunc(Xe, Zt, Pt), (W = Xe), (fe = Zt), (ie = Pt));
            },
            setOp: function (Xe, Zt, Pt) {
              (ke !== Xe || dt !== Zt || ft !== Pt) &&
                (s.stencilOp(Xe, Zt, Pt), (ke = Xe), (dt = Zt), (ft = Pt));
            },
            setLocked: function (Xe) {
              P = Xe;
            },
            setClear: function (Xe) {
              Pn !== Xe && (s.clearStencil(Xe), (Pn = Xe));
            },
            reset: function () {
              (P = !1),
                (j = null),
                (W = null),
                (fe = null),
                (ie = null),
                (ke = null),
                (dt = null),
                (ft = null),
                (Pn = null);
            },
          };
        }
        const a = new i(),
          c = new r(),
          l = new o();
        let u = {},
          h = null,
          d = {},
          f = null,
          p = !1,
          x = null,
          y = null,
          m = null,
          g = null,
          _ = null,
          w = null,
          T = null,
          v = !1,
          A = null,
          L = null,
          I = null,
          N = null,
          U = null;
        const G = s.getParameter(35661);
        let R = !1,
          D = 0;
        const F = s.getParameter(7938);
        F.indexOf("WebGL") !== -1
          ? ((D = parseFloat(/^WebGL (\d)/.exec(F)[1])), (R = D >= 1))
          : F.indexOf("OpenGL ES") !== -1 &&
            ((D = parseFloat(/^OpenGL ES (\d)/.exec(F)[1])), (R = D >= 2));
        let C = null,
          V = {};
        const te = s.getParameter(3088),
          J = s.getParameter(2978),
          oe = new Ge().fromArray(te),
          re = new Ge().fromArray(J);
        function we(P, j, W) {
          const fe = new Uint8Array(4),
            ie = s.createTexture();
          s.bindTexture(P, ie),
            s.texParameteri(P, 10241, 9728),
            s.texParameteri(P, 10240, 9728);
          for (let ke = 0; ke < W; ke++)
            s.texImage2D(j + ke, 0, 6408, 1, 1, 0, 6408, 5121, fe);
          return ie;
        }
        const _e = {};
        (_e[3553] = we(3553, 3553, 1)),
          (_e[34067] = we(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          c.setClear(1),
          l.setClear(0),
          Be(2929),
          c.setFunc(Hs),
          Z(!1),
          $(da),
          Be(2884),
          Le(nn);
        function Be(P) {
          u[P] !== !0 && (s.enable(P), (u[P] = !0));
        }
        function Ce(P) {
          u[P] !== !1 && (s.disable(P), (u[P] = !1));
        }
        function k(P) {
          P !== h && (s.bindFramebuffer(36160, P), (h = P));
        }
        function Ve(P, j) {
          return (
            j === null && h !== null && (j = h),
            d[P] !== j
              ? (s.bindFramebuffer(P, j),
                (d[P] = j),
                n &&
                  (P === 36009 && (d[36160] = j),
                  P === 36160 && (d[36009] = j)),
                !0)
              : !1
          );
        }
        function Pe(P) {
          return f !== P ? (s.useProgram(P), (f = P), !0) : !1;
        }
        const Me = { [Wn]: 32774, [_u]: 32778, [Mu]: 32779 };
        if (n) (Me[ga] = 32775), (Me[xa] = 32776);
        else {
          const P = e.get("EXT_blend_minmax");
          P !== null && ((Me[ga] = P.MIN_EXT), (Me[xa] = P.MAX_EXT));
        }
        const me = {
          [wu]: 0,
          [bu]: 1,
          [Su]: 768,
          [Va]: 770,
          [Cu]: 776,
          [Lu]: 774,
          [Eu]: 772,
          [Tu]: 769,
          [Wa]: 771,
          [Ru]: 775,
          [Au]: 773,
        };
        function Le(P, j, W, fe, ie, ke, dt, ft) {
          if (P === nn) {
            p === !0 && (Ce(3042), (p = !1));
            return;
          }
          if ((p === !1 && (Be(3042), (p = !0)), P !== vu)) {
            if (P !== x || ft !== v) {
              if (
                ((y !== Wn || _ !== Wn) &&
                  (s.blendEquation(32774), (y = Wn), (_ = Wn)),
                ft)
              )
                switch (P) {
                  case Li:
                    s.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case fa:
                    s.blendFunc(1, 1);
                    break;
                  case pa:
                    s.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case ma:
                    s.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", P);
                    break;
                }
              else
                switch (P) {
                  case Li:
                    s.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case fa:
                    s.blendFunc(770, 1);
                    break;
                  case pa:
                    s.blendFunc(0, 769);
                    break;
                  case ma:
                    s.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", P);
                    break;
                }
              (m = null), (g = null), (w = null), (T = null), (x = P), (v = ft);
            }
            return;
          }
          (ie = ie || j),
            (ke = ke || W),
            (dt = dt || fe),
            (j !== y || ie !== _) &&
              (s.blendEquationSeparate(Me[j], Me[ie]), (y = j), (_ = ie)),
            (W !== m || fe !== g || ke !== w || dt !== T) &&
              (s.blendFuncSeparate(me[W], me[fe], me[ke], me[dt]),
              (m = W),
              (g = fe),
              (w = ke),
              (T = dt)),
            (x = P),
            (v = null);
        }
        function X(P, j) {
          P.side === Vi ? Ce(2884) : Be(2884);
          let W = P.side === Qe;
          j && (W = !W),
            Z(W),
            P.blending === Li && P.transparent === !1
              ? Le(nn)
              : Le(
                  P.blending,
                  P.blendEquation,
                  P.blendSrc,
                  P.blendDst,
                  P.blendEquationAlpha,
                  P.blendSrcAlpha,
                  P.blendDstAlpha,
                  P.premultipliedAlpha
                ),
            c.setFunc(P.depthFunc),
            c.setTest(P.depthTest),
            c.setMask(P.depthWrite),
            a.setMask(P.colorWrite);
          const fe = P.stencilWrite;
          l.setTest(fe),
            fe &&
              (l.setMask(P.stencilWriteMask),
              l.setFunc(P.stencilFunc, P.stencilRef, P.stencilFuncMask),
              l.setOp(P.stencilFail, P.stencilZFail, P.stencilZPass)),
            se(P.polygonOffset, P.polygonOffsetFactor, P.polygonOffsetUnits),
            P.alphaToCoverage === !0 ? Be(32926) : Ce(32926);
        }
        function Z(P) {
          A !== P && (P ? s.frontFace(2304) : s.frontFace(2305), (A = P));
        }
        function $(P) {
          P !== gu
            ? (Be(2884),
              P !== L &&
                (P === da
                  ? s.cullFace(1029)
                  : P === xu
                  ? s.cullFace(1028)
                  : s.cullFace(1032)))
            : Ce(2884),
            (L = P);
        }
        function he(P) {
          P !== I && (R && s.lineWidth(P), (I = P));
        }
        function se(P, j, W) {
          P
            ? (Be(32823),
              (N !== j || U !== W) && (s.polygonOffset(j, W), (N = j), (U = W)))
            : Ce(32823);
        }
        function E(P) {
          P ? Be(3089) : Ce(3089);
        }
        function S(P) {
          P === void 0 && (P = 33984 + G - 1),
            C !== P && (s.activeTexture(P), (C = P));
        }
        function H(P, j) {
          C === null && S();
          let W = V[C];
          W === void 0 && ((W = { type: void 0, texture: void 0 }), (V[C] = W)),
            (W.type !== P || W.texture !== j) &&
              (s.bindTexture(P, j || _e[P]), (W.type = P), (W.texture = j));
        }
        function Y() {
          const P = V[C];
          P !== void 0 &&
            P.type !== void 0 &&
            (s.bindTexture(P.type, null),
            (P.type = void 0),
            (P.texture = void 0));
        }
        function ne() {
          try {
            s.compressedTexImage2D.apply(s, arguments);
          } catch (P) {
            console.error("THREE.WebGLState:", P);
          }
        }
        function ae() {
          try {
            s.texImage2D.apply(s, arguments);
          } catch (P) {
            console.error("THREE.WebGLState:", P);
          }
        }
        function ye() {
          try {
            s.texImage3D.apply(s, arguments);
          } catch (P) {
            console.error("THREE.WebGLState:", P);
          }
        }
        function ge(P) {
          oe.equals(P) === !1 && (s.scissor(P.x, P.y, P.z, P.w), oe.copy(P));
        }
        function Se(P) {
          re.equals(P) === !1 && (s.viewport(P.x, P.y, P.z, P.w), re.copy(P));
        }
        function ue() {
          s.disable(3042),
            s.disable(2884),
            s.disable(2929),
            s.disable(32823),
            s.disable(3089),
            s.disable(2960),
            s.disable(32926),
            s.blendEquation(32774),
            s.blendFunc(1, 0),
            s.blendFuncSeparate(1, 0, 1, 0),
            s.colorMask(!0, !0, !0, !0),
            s.clearColor(0, 0, 0, 0),
            s.depthMask(!0),
            s.depthFunc(513),
            s.clearDepth(1),
            s.stencilMask(4294967295),
            s.stencilFunc(519, 0, 4294967295),
            s.stencilOp(7680, 7680, 7680),
            s.clearStencil(0),
            s.cullFace(1029),
            s.frontFace(2305),
            s.polygonOffset(0, 0),
            s.activeTexture(33984),
            s.bindFramebuffer(36160, null),
            n === !0 &&
              (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)),
            s.useProgram(null),
            s.lineWidth(1),
            s.scissor(0, 0, s.canvas.width, s.canvas.height),
            s.viewport(0, 0, s.canvas.width, s.canvas.height),
            (u = {}),
            (C = null),
            (V = {}),
            (h = null),
            (d = {}),
            (f = null),
            (p = !1),
            (x = null),
            (y = null),
            (m = null),
            (g = null),
            (_ = null),
            (w = null),
            (T = null),
            (v = !1),
            (A = null),
            (L = null),
            (I = null),
            (N = null),
            (U = null),
            oe.set(0, 0, s.canvas.width, s.canvas.height),
            re.set(0, 0, s.canvas.width, s.canvas.height),
            a.reset(),
            c.reset(),
            l.reset();
        }
        return {
          buffers: { color: a, depth: c, stencil: l },
          enable: Be,
          disable: Ce,
          bindFramebuffer: Ve,
          bindXRFramebuffer: k,
          useProgram: Pe,
          setBlending: Le,
          setMaterial: X,
          setFlipSided: Z,
          setCullFace: $,
          setLineWidth: he,
          setPolygonOffset: se,
          setScissorTest: E,
          activeTexture: S,
          bindTexture: H,
          unbindTexture: Y,
          compressedTexImage2D: ne,
          texImage2D: ae,
          texImage3D: ye,
          scissor: ge,
          viewport: Se,
          reset: ue,
        };
      }
      function _y(s, e, t, n, i, r, o) {
        const a = i.isWebGL2,
          c = i.maxTextures,
          l = i.maxCubemapSize,
          u = i.maxTextureSize,
          h = i.maxSamples,
          d = new WeakMap();
        let f,
          p = !1;
        try {
          p =
            typeof OffscreenCanvas != "undefined" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function x(E, S) {
          return p
            ? new OffscreenCanvas(E, S)
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
        }
        function y(E, S, H, Y) {
          let ne = 1;
          if (
            ((E.width > Y || E.height > Y) &&
              (ne = Y / Math.max(E.width, E.height)),
            ne < 1 || S === !0)
          )
            if (
              (typeof HTMLImageElement != "undefined" &&
                E instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement != "undefined" &&
                E instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap != "undefined" && E instanceof ImageBitmap)
            ) {
              const ae = S ? Zh : Math.floor,
                ye = ae(ne * E.width),
                ge = ae(ne * E.height);
              f === void 0 && (f = x(ye, ge));
              const Se = H ? x(ye, ge) : f;
              return (
                (Se.width = ye),
                (Se.height = ge),
                Se.getContext("2d").drawImage(E, 0, 0, ye, ge),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    E.width +
                    "x" +
                    E.height +
                    ") to (" +
                    ye +
                    "x" +
                    ge +
                    ")."
                ),
                Se
              );
            } else
              return (
                "data" in E &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      E.width +
                      "x" +
                      E.height +
                      ")."
                  ),
                E
              );
          return E;
        }
        function m(E) {
          return Ra(E.width) && Ra(E.height);
        }
        function g(E) {
          return a
            ? !1
            : E.wrapS !== at ||
                E.wrapT !== at ||
                (E.minFilter !== Je && E.minFilter !== Ke);
        }
        function _(E, S) {
          return (
            E.generateMipmaps && S && E.minFilter !== Je && E.minFilter !== Ke
          );
        }
        function w(E, S, H, Y) {
          s.generateMipmap(E);
          const ne = n.get(S);
          ne.__maxMipLevel = Math.log2(Math.max(H, Y));
        }
        function T(E, S, H) {
          if (a === !1) return S;
          if (E !== null) {
            if (s[E] !== void 0) return s[E];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                E +
                "'"
            );
          }
          let Y = S;
          return (
            S === 6403 &&
              (H === 5126 && (Y = 33326),
              H === 5131 && (Y = 33325),
              H === 5121 && (Y = 33321)),
            S === 6407 &&
              (H === 5126 && (Y = 34837),
              H === 5131 && (Y = 34843),
              H === 5121 && (Y = 32849)),
            S === 6408 &&
              (H === 5126 && (Y = 34836),
              H === 5131 && (Y = 34842),
              H === 5121 && (Y = 32856)),
            (Y === 33325 || Y === 33326 || Y === 34842 || Y === 34836) &&
              e.get("EXT_color_buffer_float"),
            Y
          );
        }
        function v(E) {
          return E === Je || E === yr || E === vr ? 9728 : 9729;
        }
        function A(E) {
          const S = E.target;
          S.removeEventListener("dispose", A),
            I(S),
            S.isVideoTexture && d.delete(S),
            o.memory.textures--;
        }
        function L(E) {
          const S = E.target;
          S.removeEventListener("dispose", L), N(S);
        }
        function I(E) {
          const S = n.get(E);
          S.__webglInit !== void 0 &&
            (s.deleteTexture(S.__webglTexture), n.remove(E));
        }
        function N(E) {
          const S = E.texture,
            H = n.get(E),
            Y = n.get(S);
          if (!!E) {
            if (
              (Y.__webglTexture !== void 0 &&
                (s.deleteTexture(Y.__webglTexture), o.memory.textures--),
              E.depthTexture && E.depthTexture.dispose(),
              E.isWebGLCubeRenderTarget)
            )
              for (let ne = 0; ne < 6; ne++)
                s.deleteFramebuffer(H.__webglFramebuffer[ne]),
                  H.__webglDepthbuffer &&
                    s.deleteRenderbuffer(H.__webglDepthbuffer[ne]);
            else
              s.deleteFramebuffer(H.__webglFramebuffer),
                H.__webglDepthbuffer &&
                  s.deleteRenderbuffer(H.__webglDepthbuffer),
                H.__webglMultisampledFramebuffer &&
                  s.deleteFramebuffer(H.__webglMultisampledFramebuffer),
                H.__webglColorRenderbuffer &&
                  s.deleteRenderbuffer(H.__webglColorRenderbuffer),
                H.__webglDepthRenderbuffer &&
                  s.deleteRenderbuffer(H.__webglDepthRenderbuffer);
            if (E.isWebGLMultipleRenderTargets)
              for (let ne = 0, ae = S.length; ne < ae; ne++) {
                const ye = n.get(S[ne]);
                ye.__webglTexture &&
                  (s.deleteTexture(ye.__webglTexture), o.memory.textures--),
                  n.remove(S[ne]);
              }
            n.remove(S), n.remove(E);
          }
        }
        let U = 0;
        function G() {
          U = 0;
        }
        function R() {
          const E = U;
          return (
            E >= c &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  E +
                  " texture units while this GPU supports only " +
                  c
              ),
            (U += 1),
            E
          );
        }
        function D(E, S) {
          const H = n.get(E);
          if (
            (E.isVideoTexture && X(E),
            E.version > 0 && H.__version !== E.version)
          ) {
            const Y = E.image;
            if (Y === void 0)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else if (Y.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              we(H, E, S);
              return;
            }
          }
          t.activeTexture(33984 + S), t.bindTexture(3553, H.__webglTexture);
        }
        function F(E, S) {
          const H = n.get(E);
          if (E.version > 0 && H.__version !== E.version) {
            we(H, E, S);
            return;
          }
          t.activeTexture(33984 + S), t.bindTexture(35866, H.__webglTexture);
        }
        function C(E, S) {
          const H = n.get(E);
          if (E.version > 0 && H.__version !== E.version) {
            we(H, E, S);
            return;
          }
          t.activeTexture(33984 + S), t.bindTexture(32879, H.__webglTexture);
        }
        function V(E, S) {
          const H = n.get(E);
          if (E.version > 0 && H.__version !== E.version) {
            _e(H, E, S);
            return;
          }
          t.activeTexture(33984 + S), t.bindTexture(34067, H.__webglTexture);
        }
        const te = { [bn]: 10497, [at]: 33071, [Pi]: 33648 },
          J = {
            [Je]: 9728,
            [yr]: 9984,
            [vr]: 9986,
            [Ke]: 9729,
            [io]: 9985,
            [ln]: 9987,
          };
        function oe(E, S, H) {
          if (
            (H
              ? (s.texParameteri(E, 10242, te[S.wrapS]),
                s.texParameteri(E, 10243, te[S.wrapT]),
                (E === 32879 || E === 35866) &&
                  s.texParameteri(E, 32882, te[S.wrapR]),
                s.texParameteri(E, 10240, J[S.magFilter]),
                s.texParameteri(E, 10241, J[S.minFilter]))
              : (s.texParameteri(E, 10242, 33071),
                s.texParameteri(E, 10243, 33071),
                (E === 32879 || E === 35866) &&
                  s.texParameteri(E, 32882, 33071),
                (S.wrapS !== at || S.wrapT !== at) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                s.texParameteri(E, 10240, v(S.magFilter)),
                s.texParameteri(E, 10241, v(S.minFilter)),
                S.minFilter !== Je &&
                  S.minFilter !== Ke &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            const Y = e.get("EXT_texture_filter_anisotropic");
            if (
              (S.type === tn && e.has("OES_texture_float_linear") === !1) ||
              (a === !1 &&
                S.type === Mr &&
                e.has("OES_texture_half_float_linear") === !1)
            )
              return;
            (S.anisotropy > 1 || n.get(S).__currentAnisotropy) &&
              (s.texParameterf(
                E,
                Y.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(S.anisotropy, i.getMaxAnisotropy())
              ),
              (n.get(S).__currentAnisotropy = S.anisotropy));
          }
        }
        function re(E, S) {
          E.__webglInit === void 0 &&
            ((E.__webglInit = !0),
            S.addEventListener("dispose", A),
            (E.__webglTexture = s.createTexture()),
            o.memory.textures++);
        }
        function we(E, S, H) {
          let Y = 3553;
          S.isDataTexture2DArray && (Y = 35866),
            S.isDataTexture3D && (Y = 32879),
            re(E, S),
            t.activeTexture(33984 + H),
            t.bindTexture(Y, E.__webglTexture),
            s.pixelStorei(37440, S.flipY),
            s.pixelStorei(37441, S.premultiplyAlpha),
            s.pixelStorei(3317, S.unpackAlignment),
            s.pixelStorei(37443, 0);
          const ne = g(S) && m(S.image) === !1,
            ae = y(S.image, ne, !1, u),
            ye = m(ae) || a,
            ge = r.convert(S.format);
          let Se = r.convert(S.type),
            ue = T(S.internalFormat, ge, Se);
          oe(Y, S, ye);
          let P;
          const j = S.mipmaps;
          if (S.isDepthTexture)
            (ue = 6402),
              a
                ? S.type === tn
                  ? (ue = 36012)
                  : S.type === pr
                  ? (ue = 33190)
                  : S.type === Ri
                  ? (ue = 35056)
                  : (ue = 33189)
                : S.type === tn &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              S.format === Zn &&
                ue === 6402 &&
                S.type !== _r &&
                S.type !== pr &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (S.type = _r),
                (Se = r.convert(S.type))),
              S.format === Ii &&
                ue === 6402 &&
                ((ue = 34041),
                S.type !== Ri &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (S.type = Ri),
                  (Se = r.convert(S.type)))),
              t.texImage2D(3553, 0, ue, ae.width, ae.height, 0, ge, Se, null);
          else if (S.isDataTexture)
            if (j.length > 0 && ye) {
              for (let W = 0, fe = j.length; W < fe; W++)
                (P = j[W]),
                  t.texImage2D(
                    3553,
                    W,
                    ue,
                    P.width,
                    P.height,
                    0,
                    ge,
                    Se,
                    P.data
                  );
              (S.generateMipmaps = !1), (E.__maxMipLevel = j.length - 1);
            } else
              t.texImage2D(
                3553,
                0,
                ue,
                ae.width,
                ae.height,
                0,
                ge,
                Se,
                ae.data
              ),
                (E.__maxMipLevel = 0);
          else if (S.isCompressedTexture) {
            for (let W = 0, fe = j.length; W < fe; W++)
              (P = j[W]),
                S.format !== Et && S.format !== rn
                  ? ge !== null
                    ? t.compressedTexImage2D(
                        3553,
                        W,
                        ue,
                        P.width,
                        P.height,
                        0,
                        P.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : t.texImage2D(
                      3553,
                      W,
                      ue,
                      P.width,
                      P.height,
                      0,
                      ge,
                      Se,
                      P.data
                    );
            E.__maxMipLevel = j.length - 1;
          } else if (S.isDataTexture2DArray)
            t.texImage3D(
              35866,
              0,
              ue,
              ae.width,
              ae.height,
              ae.depth,
              0,
              ge,
              Se,
              ae.data
            ),
              (E.__maxMipLevel = 0);
          else if (S.isDataTexture3D)
            t.texImage3D(
              32879,
              0,
              ue,
              ae.width,
              ae.height,
              ae.depth,
              0,
              ge,
              Se,
              ae.data
            ),
              (E.__maxMipLevel = 0);
          else if (j.length > 0 && ye) {
            for (let W = 0, fe = j.length; W < fe; W++)
              (P = j[W]), t.texImage2D(3553, W, ue, ge, Se, P);
            (S.generateMipmaps = !1), (E.__maxMipLevel = j.length - 1);
          } else t.texImage2D(3553, 0, ue, ge, Se, ae), (E.__maxMipLevel = 0);
          _(S, ye) && w(Y, S, ae.width, ae.height),
            (E.__version = S.version),
            S.onUpdate && S.onUpdate(S);
        }
        function _e(E, S, H) {
          if (S.image.length !== 6) return;
          re(E, S),
            t.activeTexture(33984 + H),
            t.bindTexture(34067, E.__webglTexture),
            s.pixelStorei(37440, S.flipY),
            s.pixelStorei(37441, S.premultiplyAlpha),
            s.pixelStorei(3317, S.unpackAlignment),
            s.pixelStorei(37443, 0);
          const Y =
              S && (S.isCompressedTexture || S.image[0].isCompressedTexture),
            ne = S.image[0] && S.image[0].isDataTexture,
            ae = [];
          for (let W = 0; W < 6; W++)
            !Y && !ne
              ? (ae[W] = y(S.image[W], !1, !0, l))
              : (ae[W] = ne ? S.image[W].image : S.image[W]);
          const ye = ae[0],
            ge = m(ye) || a,
            Se = r.convert(S.format),
            ue = r.convert(S.type),
            P = T(S.internalFormat, Se, ue);
          oe(34067, S, ge);
          let j;
          if (Y) {
            for (let W = 0; W < 6; W++) {
              j = ae[W].mipmaps;
              for (let fe = 0; fe < j.length; fe++) {
                const ie = j[fe];
                S.format !== Et && S.format !== rn
                  ? Se !== null
                    ? t.compressedTexImage2D(
                        34069 + W,
                        fe,
                        P,
                        ie.width,
                        ie.height,
                        0,
                        ie.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                      )
                  : t.texImage2D(
                      34069 + W,
                      fe,
                      P,
                      ie.width,
                      ie.height,
                      0,
                      Se,
                      ue,
                      ie.data
                    );
              }
            }
            E.__maxMipLevel = j.length - 1;
          } else {
            j = S.mipmaps;
            for (let W = 0; W < 6; W++)
              if (ne) {
                t.texImage2D(
                  34069 + W,
                  0,
                  P,
                  ae[W].width,
                  ae[W].height,
                  0,
                  Se,
                  ue,
                  ae[W].data
                );
                for (let fe = 0; fe < j.length; fe++) {
                  const ke = j[fe].image[W].image;
                  t.texImage2D(
                    34069 + W,
                    fe + 1,
                    P,
                    ke.width,
                    ke.height,
                    0,
                    Se,
                    ue,
                    ke.data
                  );
                }
              } else {
                t.texImage2D(34069 + W, 0, P, Se, ue, ae[W]);
                for (let fe = 0; fe < j.length; fe++) {
                  const ie = j[fe];
                  t.texImage2D(34069 + W, fe + 1, P, Se, ue, ie.image[W]);
                }
              }
            E.__maxMipLevel = j.length;
          }
          _(S, ge) && w(34067, S, ye.width, ye.height),
            (E.__version = S.version),
            S.onUpdate && S.onUpdate(S);
        }
        function Be(E, S, H, Y, ne) {
          const ae = r.convert(H.format),
            ye = r.convert(H.type),
            ge = T(H.internalFormat, ae, ye);
          ne === 32879 || ne === 35866
            ? t.texImage3D(
                ne,
                0,
                ge,
                S.width,
                S.height,
                S.depth,
                0,
                ae,
                ye,
                null
              )
            : t.texImage2D(ne, 0, ge, S.width, S.height, 0, ae, ye, null),
            t.bindFramebuffer(36160, E),
            s.framebufferTexture2D(36160, Y, ne, n.get(H).__webglTexture, 0),
            t.bindFramebuffer(36160, null);
        }
        function Ce(E, S, H) {
          if (
            (s.bindRenderbuffer(36161, E), S.depthBuffer && !S.stencilBuffer)
          ) {
            let Y = 33189;
            if (H) {
              const ne = S.depthTexture;
              ne &&
                ne.isDepthTexture &&
                (ne.type === tn ? (Y = 36012) : ne.type === pr && (Y = 33190));
              const ae = Le(S);
              s.renderbufferStorageMultisample(36161, ae, Y, S.width, S.height);
            } else s.renderbufferStorage(36161, Y, S.width, S.height);
            s.framebufferRenderbuffer(36160, 36096, 36161, E);
          } else if (S.depthBuffer && S.stencilBuffer) {
            if (H) {
              const Y = Le(S);
              s.renderbufferStorageMultisample(
                36161,
                Y,
                35056,
                S.width,
                S.height
              );
            } else s.renderbufferStorage(36161, 34041, S.width, S.height);
            s.framebufferRenderbuffer(36160, 33306, 36161, E);
          } else {
            const Y =
                S.isWebGLMultipleRenderTargets === !0
                  ? S.texture[0]
                  : S.texture,
              ne = r.convert(Y.format),
              ae = r.convert(Y.type),
              ye = T(Y.internalFormat, ne, ae);
            if (H) {
              const ge = Le(S);
              s.renderbufferStorageMultisample(
                36161,
                ge,
                ye,
                S.width,
                S.height
              );
            } else s.renderbufferStorage(36161, ye, S.width, S.height);
          }
          s.bindRenderbuffer(36161, null);
        }
        function k(E, S) {
          if (S && S.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(36160, E),
            !(S.depthTexture && S.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(S.depthTexture).__webglTexture ||
            S.depthTexture.image.width !== S.width ||
            S.depthTexture.image.height !== S.height) &&
            ((S.depthTexture.image.width = S.width),
            (S.depthTexture.image.height = S.height),
            (S.depthTexture.needsUpdate = !0)),
            D(S.depthTexture, 0);
          const Y = n.get(S.depthTexture).__webglTexture;
          if (S.depthTexture.format === Zn)
            s.framebufferTexture2D(36160, 36096, 3553, Y, 0);
          else if (S.depthTexture.format === Ii)
            s.framebufferTexture2D(36160, 33306, 3553, Y, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Ve(E) {
          const S = n.get(E),
            H = E.isWebGLCubeRenderTarget === !0;
          if (E.depthTexture) {
            if (H)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            k(S.__webglFramebuffer, E);
          } else if (H) {
            S.__webglDepthbuffer = [];
            for (let Y = 0; Y < 6; Y++)
              t.bindFramebuffer(36160, S.__webglFramebuffer[Y]),
                (S.__webglDepthbuffer[Y] = s.createRenderbuffer()),
                Ce(S.__webglDepthbuffer[Y], E, !1);
          } else
            t.bindFramebuffer(36160, S.__webglFramebuffer),
              (S.__webglDepthbuffer = s.createRenderbuffer()),
              Ce(S.__webglDepthbuffer, E, !1);
          t.bindFramebuffer(36160, null);
        }
        function Pe(E) {
          const S = E.texture,
            H = n.get(E),
            Y = n.get(S);
          E.addEventListener("dispose", L),
            E.isWebGLMultipleRenderTargets !== !0 &&
              ((Y.__webglTexture = s.createTexture()),
              (Y.__version = S.version),
              o.memory.textures++);
          const ne = E.isWebGLCubeRenderTarget === !0,
            ae = E.isWebGLMultipleRenderTargets === !0,
            ye = E.isWebGLMultisampleRenderTarget === !0,
            ge = S.isDataTexture3D || S.isDataTexture2DArray,
            Se = m(E) || a;
          if (
            (a &&
              S.format === rn &&
              (S.type === tn || S.type === Mr) &&
              ((S.format = Et),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            ne)
          ) {
            H.__webglFramebuffer = [];
            for (let ue = 0; ue < 6; ue++)
              H.__webglFramebuffer[ue] = s.createFramebuffer();
          } else if (((H.__webglFramebuffer = s.createFramebuffer()), ae))
            if (i.drawBuffers) {
              const ue = E.texture;
              for (let P = 0, j = ue.length; P < j; P++) {
                const W = n.get(ue[P]);
                W.__webglTexture === void 0 &&
                  ((W.__webglTexture = s.createTexture()), o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (ye)
            if (a) {
              (H.__webglMultisampledFramebuffer = s.createFramebuffer()),
                (H.__webglColorRenderbuffer = s.createRenderbuffer()),
                s.bindRenderbuffer(36161, H.__webglColorRenderbuffer);
              const ue = r.convert(S.format),
                P = r.convert(S.type),
                j = T(S.internalFormat, ue, P),
                W = Le(E);
              s.renderbufferStorageMultisample(36161, W, j, E.width, E.height),
                t.bindFramebuffer(36160, H.__webglMultisampledFramebuffer),
                s.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  H.__webglColorRenderbuffer
                ),
                s.bindRenderbuffer(36161, null),
                E.depthBuffer &&
                  ((H.__webglDepthRenderbuffer = s.createRenderbuffer()),
                  Ce(H.__webglDepthRenderbuffer, E, !0)),
                t.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (ne) {
            t.bindTexture(34067, Y.__webglTexture), oe(34067, S, Se);
            for (let ue = 0; ue < 6; ue++)
              Be(H.__webglFramebuffer[ue], E, S, 36064, 34069 + ue);
            _(S, Se) && w(34067, S, E.width, E.height),
              t.bindTexture(34067, null);
          } else if (ae) {
            const ue = E.texture;
            for (let P = 0, j = ue.length; P < j; P++) {
              const W = ue[P],
                fe = n.get(W);
              t.bindTexture(3553, fe.__webglTexture),
                oe(3553, W, Se),
                Be(H.__webglFramebuffer, E, W, 36064 + P, 3553),
                _(W, Se) && w(3553, W, E.width, E.height);
            }
            t.bindTexture(3553, null);
          } else {
            let ue = 3553;
            ge &&
              (a
                ? (ue = S.isDataTexture3D ? 32879 : 35866)
                : console.warn(
                    "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                  )),
              t.bindTexture(ue, Y.__webglTexture),
              oe(ue, S, Se),
              Be(H.__webglFramebuffer, E, S, 36064, ue),
              _(S, Se) && w(3553, S, E.width, E.height),
              t.bindTexture(3553, null);
          }
          E.depthBuffer && Ve(E);
        }
        function Me(E) {
          const S = m(E) || a,
            H = E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
          for (let Y = 0, ne = H.length; Y < ne; Y++) {
            const ae = H[Y];
            if (_(ae, S)) {
              const ye = E.isWebGLCubeRenderTarget ? 34067 : 3553,
                ge = n.get(ae).__webglTexture;
              t.bindTexture(ye, ge),
                w(ye, ae, E.width, E.height),
                t.bindTexture(ye, null);
            }
          }
        }
        function me(E) {
          if (E.isWebGLMultisampleRenderTarget)
            if (a) {
              const S = E.width,
                H = E.height;
              let Y = 16384;
              E.depthBuffer && (Y |= 256), E.stencilBuffer && (Y |= 1024);
              const ne = n.get(E);
              t.bindFramebuffer(36008, ne.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, ne.__webglFramebuffer),
                s.blitFramebuffer(0, 0, S, H, 0, 0, S, H, Y, 9728),
                t.bindFramebuffer(36008, null),
                t.bindFramebuffer(36009, ne.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }
        function Le(E) {
          return a && E.isWebGLMultisampleRenderTarget
            ? Math.min(h, E.samples)
            : 0;
        }
        function X(E) {
          const S = o.render.frame;
          d.get(E) !== S && (d.set(E, S), E.update());
        }
        let Z = !1,
          $ = !1;
        function he(E, S) {
          E &&
            E.isWebGLRenderTarget &&
            (Z === !1 &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (Z = !0)),
            (E = E.texture)),
            D(E, S);
        }
        function se(E, S) {
          E &&
            E.isWebGLCubeRenderTarget &&
            ($ === !1 &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              ($ = !0)),
            (E = E.texture)),
            V(E, S);
        }
        (this.allocateTextureUnit = R),
          (this.resetTextureUnits = G),
          (this.setTexture2D = D),
          (this.setTexture2DArray = F),
          (this.setTexture3D = C),
          (this.setTextureCube = V),
          (this.setupRenderTarget = Pe),
          (this.updateRenderTargetMipmap = Me),
          (this.updateMultisampleRenderTarget = me),
          (this.safeSetTexture2D = he),
          (this.safeSetTextureCube = se);
      }
      function gd(s, e, t) {
        const n = t.isWebGL2;
        function i(r) {
          let o;
          if (r === qi) return 5121;
          if (r === Zu) return 32819;
          if (r === Ju) return 32820;
          if (r === ju) return 33635;
          if (r === qu) return 5120;
          if (r === Xu) return 5122;
          if (r === _r) return 5123;
          if (r === Yu) return 5124;
          if (r === pr) return 5125;
          if (r === tn) return 5126;
          if (r === Mr)
            return n
              ? 5131
              : ((o = e.get("OES_texture_half_float")),
                o !== null ? o.HALF_FLOAT_OES : null);
          if (r === Ku) return 6406;
          if (r === rn) return 6407;
          if (r === Et) return 6408;
          if (r === $u) return 6409;
          if (r === Qu) return 6410;
          if (r === Zn) return 6402;
          if (r === Ii) return 34041;
          if (r === th) return 6403;
          if (r === nh) return 36244;
          if (r === ih) return 33319;
          if (r === rh) return 33320;
          if (r === sh) return 36248;
          if (r === oh) return 36249;
          if (r === ya || r === va || r === _a || r === Ma)
            if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
              if (r === ya) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (r === va) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (r === _a) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (r === Ma) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (r === wa || r === ba || r === Sa || r === Ta)
            if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
              if (r === wa) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (r === ba) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (r === Sa) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (r === Ta) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (r === ah)
            return (
              (o = e.get("WEBGL_compressed_texture_etc1")),
              o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (r === Ea || r === Aa) &&
            ((o = e.get("WEBGL_compressed_texture_etc")), o !== null)
          ) {
            if (r === Ea) return o.COMPRESSED_RGB8_ETC2;
            if (r === Aa) return o.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            r === lh ||
            r === ch ||
            r === uh ||
            r === hh ||
            r === dh ||
            r === fh ||
            r === ph ||
            r === mh ||
            r === gh ||
            r === xh ||
            r === yh ||
            r === vh ||
            r === _h ||
            r === Mh ||
            r === bh ||
            r === Sh ||
            r === Th ||
            r === Eh ||
            r === Ah ||
            r === Lh ||
            r === Rh ||
            r === Ch ||
            r === Ph ||
            r === Ih ||
            r === Dh ||
            r === Fh ||
            r === Bh ||
            r === Nh
          )
            return (
              (o = e.get("WEBGL_compressed_texture_astc")),
              o !== null ? r : null
            );
          if (r === wh)
            return (
              (o = e.get("EXT_texture_compression_bptc")), o !== null ? r : null
            );
          if (r === Ri)
            return n
              ? 34042
              : ((o = e.get("WEBGL_depth_texture")),
                o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
        }
        return { convert: i };
      }
      class el extends nt {
        constructor(e = []) {
          super(), (this.cameras = e);
        }
      }
      el.prototype.isArrayCamera = !0;
      class Vt extends Ee {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      Vt.prototype.isGroup = !0;
      const My = { type: "move" };
      class Ko {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new Vt()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new Vt()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new M()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new M())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new Vt()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new M()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new M())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            o = null;
          const a = this._targetRay,
            c = this._grip,
            l = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred")
            if (
              (a !== null &&
                ((i = t.getPose(e.targetRaySpace, n)),
                i !== null &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(My))),
              l && e.hand)
            ) {
              o = !0;
              for (const x of e.hand.values()) {
                const y = t.getJointPose(x, n);
                if (l.joints[x.jointName] === void 0) {
                  const g = new Vt();
                  (g.matrixAutoUpdate = !1),
                    (g.visible = !1),
                    (l.joints[x.jointName] = g),
                    l.add(g);
                }
                const m = l.joints[x.jointName];
                y !== null &&
                  (m.matrix.fromArray(y.transform.matrix),
                  m.matrix.decompose(m.position, m.rotation, m.scale),
                  (m.jointRadius = y.radius)),
                  (m.visible = y !== null);
              }
              const u = l.joints["index-finger-tip"],
                h = l.joints["thumb-tip"],
                d = u.position.distanceTo(h.position),
                f = 0.02,
                p = 0.005;
              l.inputState.pinching && d > f + p
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  d <= f - p &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              c !== null &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                r !== null &&
                  (c.matrix.fromArray(r.transform.matrix),
                  c.matrix.decompose(c.position, c.rotation, c.scale),
                  r.linearVelocity
                    ? ((c.hasLinearVelocity = !0),
                      c.linearVelocity.copy(r.linearVelocity))
                    : (c.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((c.hasAngularVelocity = !0),
                      c.angularVelocity.copy(r.angularVelocity))
                    : (c.hasAngularVelocity = !1)));
          return (
            a !== null && (a.visible = i !== null),
            c !== null && (c.visible = r !== null),
            l !== null && (l.visible = o !== null),
            this
          );
        }
      }
      class wy extends An {
        constructor(e, t) {
          super();
          const n = this,
            i = e.state;
          let r = null,
            o = 1,
            a = null,
            c = "local-floor",
            l = null;
          const u = [],
            h = new Map(),
            d = new nt();
          d.layers.enable(1), (d.viewport = new Ge());
          const f = new nt();
          f.layers.enable(2), (f.viewport = new Ge());
          const p = [d, f],
            x = new el();
          x.layers.enable(1), x.layers.enable(2);
          let y = null,
            m = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (G) {
              let R = u[G];
              return (
                R === void 0 && ((R = new Ko()), (u[G] = R)),
                R.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (G) {
              let R = u[G];
              return (
                R === void 0 && ((R = new Ko()), (u[G] = R)), R.getGripSpace()
              );
            }),
            (this.getHand = function (G) {
              let R = u[G];
              return (
                R === void 0 && ((R = new Ko()), (u[G] = R)), R.getHandSpace()
              );
            });
          function g(G) {
            const R = h.get(G.inputSource);
            R && R.dispatchEvent({ type: G.type, data: G.inputSource });
          }
          function _() {
            h.forEach(function (G, R) {
              G.disconnect(R);
            }),
              h.clear(),
              (y = null),
              (m = null),
              i.bindXRFramebuffer(null),
              e.setRenderTarget(e.getRenderTarget()),
              U.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (G) {
            (o = G),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (G) {
              (c = G),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return a;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = async function (G) {
              if (((r = G), r !== null)) {
                r.addEventListener("select", g),
                  r.addEventListener("selectstart", g),
                  r.addEventListener("selectend", g),
                  r.addEventListener("squeeze", g),
                  r.addEventListener("squeezestart", g),
                  r.addEventListener("squeezeend", g),
                  r.addEventListener("end", _),
                  r.addEventListener("inputsourceschange", w);
                const R = t.getContextAttributes();
                R.xrCompatible !== !0 && (await t.makeXRCompatible());
                const D = {
                    antialias: R.antialias,
                    alpha: R.alpha,
                    depth: R.depth,
                    stencil: R.stencil,
                    framebufferScaleFactor: o,
                  },
                  F = new XRWebGLLayer(r, t, D);
                r.updateRenderState({ baseLayer: F }),
                  (a = await r.requestReferenceSpace(c)),
                  U.setContext(r),
                  U.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          function w(G) {
            const R = r.inputSources;
            for (let D = 0; D < u.length; D++) h.set(R[D], u[D]);
            for (let D = 0; D < G.removed.length; D++) {
              const F = G.removed[D],
                C = h.get(F);
              C &&
                (C.dispatchEvent({ type: "disconnected", data: F }),
                h.delete(F));
            }
            for (let D = 0; D < G.added.length; D++) {
              const F = G.added[D],
                C = h.get(F);
              C && C.dispatchEvent({ type: "connected", data: F });
            }
          }
          const T = new M(),
            v = new M();
          function A(G, R, D) {
            T.setFromMatrixPosition(R.matrixWorld),
              v.setFromMatrixPosition(D.matrixWorld);
            const F = T.distanceTo(v),
              C = R.projectionMatrix.elements,
              V = D.projectionMatrix.elements,
              te = C[14] / (C[10] - 1),
              J = C[14] / (C[10] + 1),
              oe = (C[9] + 1) / C[5],
              re = (C[9] - 1) / C[5],
              we = (C[8] - 1) / C[0],
              _e = (V[8] + 1) / V[0],
              Be = te * we,
              Ce = te * _e,
              k = F / (-we + _e),
              Ve = k * -we;
            R.matrixWorld.decompose(G.position, G.quaternion, G.scale),
              G.translateX(Ve),
              G.translateZ(k),
              G.matrixWorld.compose(G.position, G.quaternion, G.scale),
              G.matrixWorldInverse.copy(G.matrixWorld).invert();
            const Pe = te + k,
              Me = J + k,
              me = Be - Ve,
              Le = Ce + (F - Ve),
              X = ((oe * J) / Me) * Pe,
              Z = ((re * J) / Me) * Pe;
            G.projectionMatrix.makePerspective(me, Le, X, Z, Pe, Me);
          }
          function L(G, R) {
            R === null
              ? G.matrixWorld.copy(G.matrix)
              : G.matrixWorld.multiplyMatrices(R.matrixWorld, G.matrix),
              G.matrixWorldInverse.copy(G.matrixWorld).invert();
          }
          (this.updateCamera = function (G) {
            if (r === null) return;
            (x.near = f.near = d.near = G.near),
              (x.far = f.far = d.far = G.far),
              (y !== x.near || m !== x.far) &&
                (r.updateRenderState({ depthNear: x.near, depthFar: x.far }),
                (y = x.near),
                (m = x.far));
            const R = G.parent,
              D = x.cameras;
            L(x, R);
            for (let C = 0; C < D.length; C++) L(D[C], R);
            G.matrixWorld.copy(x.matrixWorld),
              G.matrix.copy(x.matrix),
              G.matrix.decompose(G.position, G.quaternion, G.scale);
            const F = G.children;
            for (let C = 0, V = F.length; C < V; C++)
              F[C].updateMatrixWorld(!0);
            D.length === 2
              ? A(x, d, f)
              : x.projectionMatrix.copy(d.projectionMatrix);
          }),
            (this.getCamera = function () {
              return x;
            });
          let I = null;
          function N(G, R) {
            if (((l = R.getViewerPose(a)), l !== null)) {
              const F = l.views,
                C = r.renderState.baseLayer;
              i.bindXRFramebuffer(C.framebuffer);
              let V = !1;
              F.length !== x.cameras.length &&
                ((x.cameras.length = 0), (V = !0));
              for (let te = 0; te < F.length; te++) {
                const J = F[te],
                  oe = C.getViewport(J),
                  re = p[te];
                re.matrix.fromArray(J.transform.matrix),
                  re.projectionMatrix.fromArray(J.projectionMatrix),
                  re.viewport.set(oe.x, oe.y, oe.width, oe.height),
                  te === 0 && x.matrix.copy(re.matrix),
                  V === !0 && x.cameras.push(re);
              }
            }
            const D = r.inputSources;
            for (let F = 0; F < u.length; F++) {
              const C = u[F],
                V = D[F];
              C.update(V, R, a);
            }
            I && I(G, R);
          }
          const U = new ad();
          U.setAnimationLoop(N),
            (this.setAnimationLoop = function (G) {
              I = G;
            }),
            (this.dispose = function () {});
        }
      }
      function by(s) {
        function e(m, g) {
          m.fogColor.value.copy(g.color),
            g.isFog
              ? ((m.fogNear.value = g.near), (m.fogFar.value = g.far))
              : g.isFogExp2 && (m.fogDensity.value = g.density);
        }
        function t(m, g, _, w, T) {
          g.isMeshBasicMaterial
            ? n(m, g)
            : g.isMeshLambertMaterial
            ? (n(m, g), c(m, g))
            : g.isMeshToonMaterial
            ? (n(m, g), u(m, g))
            : g.isMeshPhongMaterial
            ? (n(m, g), l(m, g))
            : g.isMeshStandardMaterial
            ? (n(m, g), g.isMeshPhysicalMaterial ? d(m, g, T) : h(m, g))
            : g.isMeshMatcapMaterial
            ? (n(m, g), f(m, g))
            : g.isMeshDepthMaterial
            ? (n(m, g), p(m, g))
            : g.isMeshDistanceMaterial
            ? (n(m, g), x(m, g))
            : g.isMeshNormalMaterial
            ? (n(m, g), y(m, g))
            : g.isLineBasicMaterial
            ? (i(m, g), g.isLineDashedMaterial && r(m, g))
            : g.isPointsMaterial
            ? o(m, g, _, w)
            : g.isSpriteMaterial
            ? a(m, g)
            : g.isShadowMaterial
            ? (m.color.value.copy(g.color), (m.opacity.value = g.opacity))
            : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
        }
        function n(m, g) {
          (m.opacity.value = g.opacity),
            g.color && m.diffuse.value.copy(g.color),
            g.emissive &&
              m.emissive.value
                .copy(g.emissive)
                .multiplyScalar(g.emissiveIntensity),
            g.map && (m.map.value = g.map),
            g.alphaMap && (m.alphaMap.value = g.alphaMap),
            g.specularMap && (m.specularMap.value = g.specularMap);
          const _ = s.get(g).envMap;
          if (_) {
            (m.envMap.value = _),
              (m.flipEnvMap.value =
                _.isCubeTexture && _._needsFlipEnvMap ? -1 : 1),
              (m.reflectivity.value = g.reflectivity),
              (m.refractionRatio.value = g.refractionRatio);
            const v = s.get(_).__maxMipLevel;
            v !== void 0 && (m.maxMipLevel.value = v);
          }
          g.lightMap &&
            ((m.lightMap.value = g.lightMap),
            (m.lightMapIntensity.value = g.lightMapIntensity)),
            g.aoMap &&
              ((m.aoMap.value = g.aoMap),
              (m.aoMapIntensity.value = g.aoMapIntensity));
          let w;
          g.map
            ? (w = g.map)
            : g.specularMap
            ? (w = g.specularMap)
            : g.displacementMap
            ? (w = g.displacementMap)
            : g.normalMap
            ? (w = g.normalMap)
            : g.bumpMap
            ? (w = g.bumpMap)
            : g.roughnessMap
            ? (w = g.roughnessMap)
            : g.metalnessMap
            ? (w = g.metalnessMap)
            : g.alphaMap
            ? (w = g.alphaMap)
            : g.emissiveMap
            ? (w = g.emissiveMap)
            : g.clearcoatMap
            ? (w = g.clearcoatMap)
            : g.clearcoatNormalMap
            ? (w = g.clearcoatNormalMap)
            : g.clearcoatRoughnessMap && (w = g.clearcoatRoughnessMap),
            w !== void 0 &&
              (w.isWebGLRenderTarget && (w = w.texture),
              w.matrixAutoUpdate === !0 && w.updateMatrix(),
              m.uvTransform.value.copy(w.matrix));
          let T;
          g.aoMap ? (T = g.aoMap) : g.lightMap && (T = g.lightMap),
            T !== void 0 &&
              (T.isWebGLRenderTarget && (T = T.texture),
              T.matrixAutoUpdate === !0 && T.updateMatrix(),
              m.uv2Transform.value.copy(T.matrix));
        }
        function i(m, g) {
          m.diffuse.value.copy(g.color), (m.opacity.value = g.opacity);
        }
        function r(m, g) {
          (m.dashSize.value = g.dashSize),
            (m.totalSize.value = g.dashSize + g.gapSize),
            (m.scale.value = g.scale);
        }
        function o(m, g, _, w) {
          m.diffuse.value.copy(g.color),
            (m.opacity.value = g.opacity),
            (m.size.value = g.size * _),
            (m.scale.value = w * 0.5),
            g.map && (m.map.value = g.map),
            g.alphaMap && (m.alphaMap.value = g.alphaMap);
          let T;
          g.map ? (T = g.map) : g.alphaMap && (T = g.alphaMap),
            T !== void 0 &&
              (T.matrixAutoUpdate === !0 && T.updateMatrix(),
              m.uvTransform.value.copy(T.matrix));
        }
        function a(m, g) {
          m.diffuse.value.copy(g.color),
            (m.opacity.value = g.opacity),
            (m.rotation.value = g.rotation),
            g.map && (m.map.value = g.map),
            g.alphaMap && (m.alphaMap.value = g.alphaMap);
          let _;
          g.map ? (_ = g.map) : g.alphaMap && (_ = g.alphaMap),
            _ !== void 0 &&
              (_.matrixAutoUpdate === !0 && _.updateMatrix(),
              m.uvTransform.value.copy(_.matrix));
        }
        function c(m, g) {
          g.emissiveMap && (m.emissiveMap.value = g.emissiveMap);
        }
        function l(m, g) {
          m.specular.value.copy(g.specular),
            (m.shininess.value = Math.max(g.shininess, 1e-4)),
            g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
            g.bumpMap &&
              ((m.bumpMap.value = g.bumpMap),
              (m.bumpScale.value = g.bumpScale),
              g.side === Qe && (m.bumpScale.value *= -1)),
            g.normalMap &&
              ((m.normalMap.value = g.normalMap),
              m.normalScale.value.copy(g.normalScale),
              g.side === Qe && m.normalScale.value.negate()),
            g.displacementMap &&
              ((m.displacementMap.value = g.displacementMap),
              (m.displacementScale.value = g.displacementScale),
              (m.displacementBias.value = g.displacementBias));
        }
        function u(m, g) {
          g.gradientMap && (m.gradientMap.value = g.gradientMap),
            g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
            g.bumpMap &&
              ((m.bumpMap.value = g.bumpMap),
              (m.bumpScale.value = g.bumpScale),
              g.side === Qe && (m.bumpScale.value *= -1)),
            g.normalMap &&
              ((m.normalMap.value = g.normalMap),
              m.normalScale.value.copy(g.normalScale),
              g.side === Qe && m.normalScale.value.negate()),
            g.displacementMap &&
              ((m.displacementMap.value = g.displacementMap),
              (m.displacementScale.value = g.displacementScale),
              (m.displacementBias.value = g.displacementBias));
        }
        function h(m, g) {
          (m.roughness.value = g.roughness),
            (m.metalness.value = g.metalness),
            g.roughnessMap && (m.roughnessMap.value = g.roughnessMap),
            g.metalnessMap && (m.metalnessMap.value = g.metalnessMap),
            g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
            g.bumpMap &&
              ((m.bumpMap.value = g.bumpMap),
              (m.bumpScale.value = g.bumpScale),
              g.side === Qe && (m.bumpScale.value *= -1)),
            g.normalMap &&
              ((m.normalMap.value = g.normalMap),
              m.normalScale.value.copy(g.normalScale),
              g.side === Qe && m.normalScale.value.negate()),
            g.displacementMap &&
              ((m.displacementMap.value = g.displacementMap),
              (m.displacementScale.value = g.displacementScale),
              (m.displacementBias.value = g.displacementBias)),
            s.get(g).envMap && (m.envMapIntensity.value = g.envMapIntensity);
        }
        function d(m, g, _) {
          h(m, g),
            (m.reflectivity.value = g.reflectivity),
            (m.clearcoat.value = g.clearcoat),
            (m.clearcoatRoughness.value = g.clearcoatRoughness),
            g.sheen && m.sheen.value.copy(g.sheen),
            g.clearcoatMap && (m.clearcoatMap.value = g.clearcoatMap),
            g.clearcoatRoughnessMap &&
              (m.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
            g.clearcoatNormalMap &&
              (m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
              (m.clearcoatNormalMap.value = g.clearcoatNormalMap),
              g.side === Qe && m.clearcoatNormalScale.value.negate()),
            (m.transmission.value = g.transmission),
            g.transmissionMap && (m.transmissionMap.value = g.transmissionMap),
            g.transmission > 0 &&
              ((m.transmissionSamplerMap.value = _.texture),
              m.transmissionSamplerSize.value.set(_.width, _.height)),
            (m.thickness.value = g.thickness),
            g.thicknessMap && (m.thicknessMap.value = g.thicknessMap),
            (m.attenuationDistance.value = g.attenuationDistance),
            m.attenuationColor.value.copy(g.attenuationColor);
        }
        function f(m, g) {
          g.matcap && (m.matcap.value = g.matcap),
            g.bumpMap &&
              ((m.bumpMap.value = g.bumpMap),
              (m.bumpScale.value = g.bumpScale),
              g.side === Qe && (m.bumpScale.value *= -1)),
            g.normalMap &&
              ((m.normalMap.value = g.normalMap),
              m.normalScale.value.copy(g.normalScale),
              g.side === Qe && m.normalScale.value.negate()),
            g.displacementMap &&
              ((m.displacementMap.value = g.displacementMap),
              (m.displacementScale.value = g.displacementScale),
              (m.displacementBias.value = g.displacementBias));
        }
        function p(m, g) {
          g.displacementMap &&
            ((m.displacementMap.value = g.displacementMap),
            (m.displacementScale.value = g.displacementScale),
            (m.displacementBias.value = g.displacementBias));
        }
        function x(m, g) {
          g.displacementMap &&
            ((m.displacementMap.value = g.displacementMap),
            (m.displacementScale.value = g.displacementScale),
            (m.displacementBias.value = g.displacementBias)),
            m.referencePosition.value.copy(g.referencePosition),
            (m.nearDistance.value = g.nearDistance),
            (m.farDistance.value = g.farDistance);
        }
        function y(m, g) {
          g.bumpMap &&
            ((m.bumpMap.value = g.bumpMap),
            (m.bumpScale.value = g.bumpScale),
            g.side === Qe && (m.bumpScale.value *= -1)),
            g.normalMap &&
              ((m.normalMap.value = g.normalMap),
              m.normalScale.value.copy(g.normalScale),
              g.side === Qe && m.normalScale.value.negate()),
            g.displacementMap &&
              ((m.displacementMap.value = g.displacementMap),
              (m.displacementScale.value = g.displacementScale),
              (m.displacementBias.value = g.displacementBias));
        }
        return { refreshFogUniforms: e, refreshMaterialUniforms: t };
      }
      function Sy() {
        const s = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return (s.style.display = "block"), s;
      }
      function Ue(s) {
        s = s || {};
        const e = s.canvas !== void 0 ? s.canvas : Sy(),
          t = s.context !== void 0 ? s.context : null,
          n = s.alpha !== void 0 ? s.alpha : !1,
          i = s.depth !== void 0 ? s.depth : !0,
          r = s.stencil !== void 0 ? s.stencil : !0,
          o = s.antialias !== void 0 ? s.antialias : !1,
          a = s.premultipliedAlpha !== void 0 ? s.premultipliedAlpha : !0,
          c = s.preserveDrawingBuffer !== void 0 ? s.preserveDrawingBuffer : !1,
          l = s.powerPreference !== void 0 ? s.powerPreference : "default",
          u =
            s.failIfMajorPerformanceCaveat !== void 0
              ? s.failIfMajorPerformanceCaveat
              : !1;
        let h = null,
          d = null;
        const f = [],
          p = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = vt),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = Yn),
          (this.toneMappingExposure = 1);
        const x = this;
        let y = !1,
          m = 0,
          g = 0,
          _ = null,
          w = -1,
          T = null;
        const v = new Ge(),
          A = new Ge();
        let L = null,
          I = e.width,
          N = e.height,
          U = 1,
          G = null,
          R = null;
        const D = new Ge(0, 0, I, N),
          F = new Ge(0, 0, I, N);
        let C = !1;
        const V = [],
          te = new Or();
        let J = !1,
          oe = !1,
          re = null;
        const we = new ce(),
          _e = new M(),
          Be = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Ce() {
          return _ === null ? U : 1;
        }
        let k = t;
        function Ve(b, O) {
          for (let B = 0; B < b.length; B++) {
            const z = b[B],
              Q = e.getContext(z, O);
            if (Q !== null) return Q;
          }
          return null;
        }
        try {
          const b = {
            alpha: n,
            depth: i,
            stencil: r,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: c,
            powerPreference: l,
            failIfMajorPerformanceCaveat: u,
          };
          if (
            (e.addEventListener("webglcontextlost", ke, !1),
            e.addEventListener("webglcontextrestored", dt, !1),
            k === null)
          ) {
            const O = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (x.isWebGL1Renderer === !0 && O.shift(),
              (k = Ve(O, b)),
              k === null)
            )
              throw Ve(O)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          k.getShaderPrecisionFormat === void 0 &&
            (k.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (b) {
          throw (console.error("THREE.WebGLRenderer: " + b.message), b);
        }
        let Pe,
          Me,
          me,
          Le,
          X,
          Z,
          $,
          he,
          se,
          E,
          S,
          H,
          Y,
          ne,
          ae,
          ye,
          ge,
          Se,
          ue,
          P,
          j,
          W;
        function fe() {
          (Pe = new Zg(k)),
            (Me = new qg(k, Pe, s)),
            Pe.init(Me),
            (j = new gd(k, Pe, Me)),
            (me = new vy(k, Pe, Me)),
            (V[0] = 1029),
            (Le = new Kg(k)),
            (X = new ly()),
            (Z = new _y(k, Pe, me, X, Me, j, Le)),
            ($ = new Yg(x)),
            (he = new _p(k, Me)),
            (W = new Vg(k, Pe, he, Me)),
            (se = new Jg(k, he, Le, W)),
            (E = new tx(k, se, he, Le)),
            (Se = new ex(k)),
            (ae = new Xg(X)),
            (S = new ay(x, $, Pe, Me, W, ae)),
            (H = new by(X)),
            (Y = new uy(X)),
            (ne = new gy(Pe, Me)),
            (ge = new kg(x, $, me, E, a)),
            (ye = new md(x, E, Me)),
            (ue = new Wg(k, Pe, Le, Me)),
            (P = new jg(k, Pe, Le, Me)),
            (Le.programs = S.programs),
            (x.capabilities = Me),
            (x.extensions = Pe),
            (x.properties = X),
            (x.renderLists = Y),
            (x.shadowMap = ye),
            (x.state = me),
            (x.info = Le);
        }
        fe();
        const ie = new wy(x, k);
        (this.xr = ie),
          (this.getContext = function () {
            return k;
          }),
          (this.getContextAttributes = function () {
            return k.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const b = Pe.get("WEBGL_lose_context");
            b && b.loseContext();
          }),
          (this.forceContextRestore = function () {
            const b = Pe.get("WEBGL_lose_context");
            b && b.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return U;
          }),
          (this.setPixelRatio = function (b) {
            b !== void 0 && ((U = b), this.setSize(I, N, !1));
          }),
          (this.getSize = function (b) {
            return (
              b === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                ),
                (b = new q())),
              b.set(I, N)
            );
          }),
          (this.setSize = function (b, O, B) {
            if (ie.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (I = b),
              (N = O),
              (e.width = Math.floor(b * U)),
              (e.height = Math.floor(O * U)),
              B !== !1 &&
                ((e.style.width = b + "px"), (e.style.height = O + "px")),
              this.setViewport(0, 0, b, O);
          }),
          (this.getDrawingBufferSize = function (b) {
            return (
              b === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                ),
                (b = new q())),
              b.set(I * U, N * U).floor()
            );
          }),
          (this.setDrawingBufferSize = function (b, O, B) {
            (I = b),
              (N = O),
              (U = B),
              (e.width = Math.floor(b * B)),
              (e.height = Math.floor(O * B)),
              this.setViewport(0, 0, b, O);
          }),
          (this.getCurrentViewport = function (b) {
            return (
              b === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                ),
                (b = new Ge())),
              b.copy(v)
            );
          }),
          (this.getViewport = function (b) {
            return b.copy(D);
          }),
          (this.setViewport = function (b, O, B, z) {
            b.isVector4 ? D.set(b.x, b.y, b.z, b.w) : D.set(b, O, B, z),
              me.viewport(v.copy(D).multiplyScalar(U).floor());
          }),
          (this.getScissor = function (b) {
            return b.copy(F);
          }),
          (this.setScissor = function (b, O, B, z) {
            b.isVector4 ? F.set(b.x, b.y, b.z, b.w) : F.set(b, O, B, z),
              me.scissor(A.copy(F).multiplyScalar(U).floor());
          }),
          (this.getScissorTest = function () {
            return C;
          }),
          (this.setScissorTest = function (b) {
            me.setScissorTest((C = b));
          }),
          (this.setOpaqueSort = function (b) {
            G = b;
          }),
          (this.setTransparentSort = function (b) {
            R = b;
          }),
          (this.getClearColor = function (b) {
            return (
              b === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getClearColor() now requires a Color as an argument"
                ),
                (b = new K())),
              b.copy(ge.getClearColor())
            );
          }),
          (this.setClearColor = function () {
            ge.setClearColor.apply(ge, arguments);
          }),
          (this.getClearAlpha = function () {
            return ge.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            ge.setClearAlpha.apply(ge, arguments);
          }),
          (this.clear = function (b, O, B) {
            let z = 0;
            (b === void 0 || b) && (z |= 16384),
              (O === void 0 || O) && (z |= 256),
              (B === void 0 || B) && (z |= 1024),
              k.clear(z);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", ke, !1),
              e.removeEventListener("webglcontextrestored", dt, !1),
              Y.dispose(),
              ne.dispose(),
              X.dispose(),
              $.dispose(),
              E.dispose(),
              W.dispose(),
              ie.dispose(),
              ie.removeEventListener("sessionstart", Nl),
              ie.removeEventListener("sessionend", Gl),
              re && (re.dispose(), (re = null)),
              In.stop();
          });
        function ke(b) {
          b.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (y = !0);
        }
        function dt() {
          console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
          const b = Le.autoReset,
            O = ye.enabled,
            B = ye.autoUpdate,
            z = ye.needsUpdate,
            Q = ye.type;
          fe(),
            (Le.autoReset = b),
            (ye.enabled = O),
            (ye.autoUpdate = B),
            (ye.needsUpdate = z),
            (ye.type = Q);
        }
        function ft(b) {
          const O = b.target;
          O.removeEventListener("dispose", ft), Pn(O);
        }
        function Pn(b) {
          Xe(b), X.remove(b);
        }
        function Xe(b) {
          const O = X.get(b).programs;
          O !== void 0 &&
            O.forEach(function (B) {
              S.releaseProgram(B);
            });
        }
        function Zt(b, O) {
          b.render(function (B) {
            x.renderBufferImmediate(B, O);
          });
        }
        (this.renderBufferImmediate = function (b, O) {
          W.initAttributes();
          const B = X.get(b);
          b.hasPositions && !B.position && (B.position = k.createBuffer()),
            b.hasNormals && !B.normal && (B.normal = k.createBuffer()),
            b.hasUvs && !B.uv && (B.uv = k.createBuffer()),
            b.hasColors && !B.color && (B.color = k.createBuffer());
          const z = O.getAttributes();
          b.hasPositions &&
            (k.bindBuffer(34962, B.position),
            k.bufferData(34962, b.positionArray, 35048),
            W.enableAttribute(z.position),
            k.vertexAttribPointer(z.position, 3, 5126, !1, 0, 0)),
            b.hasNormals &&
              (k.bindBuffer(34962, B.normal),
              k.bufferData(34962, b.normalArray, 35048),
              W.enableAttribute(z.normal),
              k.vertexAttribPointer(z.normal, 3, 5126, !1, 0, 0)),
            b.hasUvs &&
              (k.bindBuffer(34962, B.uv),
              k.bufferData(34962, b.uvArray, 35048),
              W.enableAttribute(z.uv),
              k.vertexAttribPointer(z.uv, 2, 5126, !1, 0, 0)),
            b.hasColors &&
              (k.bindBuffer(34962, B.color),
              k.bufferData(34962, b.colorArray, 35048),
              W.enableAttribute(z.color),
              k.vertexAttribPointer(z.color, 3, 5126, !1, 0, 0)),
            W.disableUnusedAttributes(),
            k.drawArrays(4, 0, b.count),
            (b.count = 0);
        }),
          (this.renderBufferDirect = function (b, O, B, z, Q, Fe) {
            O === null && (O = Be);
            const Te = Q.isMesh && Q.matrixWorld.determinant() < 0,
              xe = Hl(b, O, z, Q);
            me.setMaterial(z, Te);
            let Re = B.index;
            const pe = B.attributes.position;
            if (Re === null) {
              if (pe === void 0 || pe.count === 0) return;
            } else if (Re.count === 0) return;
            let Ie = 1;
            z.wireframe === !0 &&
              ((Re = se.getWireframeAttribute(B)), (Ie = 2)),
              (z.morphTargets || z.morphNormals) && Se.update(Q, B, z, xe),
              W.setup(Q, z, xe, B, Re);
            let ve,
              Oe = ue;
            Re !== null && ((ve = he.get(Re)), (Oe = P), Oe.setIndex(ve));
            const Ht = Re !== null ? Re.count : pe.count,
              xt = B.drawRange.start * Ie,
              Dn = B.drawRange.count * Ie,
              tt = Fe !== null ? Fe.start * Ie : 0,
              Fn = Fe !== null ? Fe.count * Ie : 1 / 0,
              pt = Math.max(xt, tt),
              df = Math.min(Ht, xt + Dn, tt + Fn) - 1,
              Kr = Math.max(0, df - pt + 1);
            if (Kr !== 0) {
              if (Q.isMesh)
                z.wireframe === !0
                  ? (me.setLineWidth(z.wireframeLinewidth * Ce()),
                    Oe.setMode(1))
                  : Oe.setMode(4);
              else if (Q.isLine) {
                let $i = z.linewidth;
                $i === void 0 && ($i = 1),
                  me.setLineWidth($i * Ce()),
                  Q.isLineSegments
                    ? Oe.setMode(1)
                    : Q.isLineLoop
                    ? Oe.setMode(2)
                    : Oe.setMode(3);
              } else Q.isPoints ? Oe.setMode(0) : Q.isSprite && Oe.setMode(4);
              if (Q.isInstancedMesh) Oe.renderInstances(pt, Kr, Q.count);
              else if (B.isInstancedBufferGeometry) {
                const $i = Math.min(B.instanceCount, B._maxInstanceCount);
                Oe.renderInstances(pt, Kr, $i);
              } else Oe.render(pt, Kr);
            }
          }),
          (this.compile = function (b, O) {
            (d = ne.get(b)),
              d.init(),
              b.traverseVisible(function (B) {
                B.isLight &&
                  B.layers.test(O.layers) &&
                  (d.pushLight(B), B.castShadow && d.pushShadow(B));
              }),
              d.setupLights(),
              b.traverse(function (B) {
                const z = B.material;
                if (z)
                  if (Array.isArray(z))
                    for (let Q = 0; Q < z.length; Q++) {
                      const Fe = z[Q];
                      Eo(Fe, b, B);
                    }
                  else Eo(z, b, B);
              });
          });
        let Pt = null;
        function lf(b) {
          Pt && Pt(b);
        }
        function Nl() {
          In.stop();
        }
        function Gl() {
          In.start();
        }
        const In = new ad();
        In.setAnimationLoop(lf),
          typeof window != "undefined" && In.setContext(window),
          (this.setAnimationLoop = function (b) {
            (Pt = b),
              ie.setAnimationLoop(b),
              b === null ? In.stop() : In.start();
          }),
          ie.addEventListener("sessionstart", Nl),
          ie.addEventListener("sessionend", Gl),
          (this.render = function (b, O) {
            if (O !== void 0 && O.isCamera !== !0) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (y === !0) return;
            b.autoUpdate === !0 && b.updateMatrixWorld(),
              O.parent === null && O.updateMatrixWorld(),
              ie.enabled === !0 &&
                ie.isPresenting === !0 &&
                (ie.cameraAutoUpdate === !0 && ie.updateCamera(O),
                (O = ie.getCamera())),
              b.isScene === !0 && b.onBeforeRender(x, b, O, _),
              (d = ne.get(b, p.length)),
              d.init(),
              p.push(d),
              we.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse),
              te.setFromProjectionMatrix(we),
              (oe = this.localClippingEnabled),
              (J = ae.init(this.clippingPlanes, oe, O)),
              (h = Y.get(b, f.length)),
              h.init(),
              f.push(h),
              Ol(b, O, 0, x.sortObjects),
              h.finish(),
              x.sortObjects === !0 && h.sort(G, R),
              J === !0 && ae.beginShadows();
            const B = d.state.shadowsArray;
            ye.render(B, b, O),
              d.setupLights(),
              d.setupLightsView(O),
              J === !0 && ae.endShadows(),
              this.info.autoReset === !0 && this.info.reset(),
              ge.render(h, b);
            const z = h.opaque,
              Q = h.transmissive,
              Fe = h.transparent;
            z.length > 0 && jr(z, b, O),
              Q.length > 0 && cf(z, Q, b, O),
              Fe.length > 0 && jr(Fe, b, O),
              _ !== null &&
                (Z.updateRenderTargetMipmap(_),
                Z.updateMultisampleRenderTarget(_)),
              b.isScene === !0 && b.onAfterRender(x, b, O),
              me.buffers.depth.setTest(!0),
              me.buffers.depth.setMask(!0),
              me.buffers.color.setMask(!0),
              me.setPolygonOffset(!1),
              W.resetDefaultState(),
              (w = -1),
              (T = null),
              p.pop(),
              p.length > 0 ? (d = p[p.length - 1]) : (d = null),
              f.pop(),
              f.length > 0 ? (h = f[f.length - 1]) : (h = null);
          });
        function Ol(b, O, B, z) {
          if (b.visible === !1) return;
          if (b.layers.test(O.layers)) {
            if (b.isGroup) B = b.renderOrder;
            else if (b.isLOD) b.autoUpdate === !0 && b.update(O);
            else if (b.isLight) d.pushLight(b), b.castShadow && d.pushShadow(b);
            else if (b.isSprite) {
              if (!b.frustumCulled || te.intersectsSprite(b)) {
                z && _e.setFromMatrixPosition(b.matrixWorld).applyMatrix4(we);
                const Te = E.update(b),
                  xe = b.material;
                xe.visible && h.push(b, Te, xe, B, _e.z, null);
              }
            } else if (b.isImmediateRenderObject)
              z && _e.setFromMatrixPosition(b.matrixWorld).applyMatrix4(we),
                h.push(b, null, b.material, B, _e.z, null);
            else if (
              (b.isMesh || b.isLine || b.isPoints) &&
              (b.isSkinnedMesh &&
                b.skeleton.frame !== Le.render.frame &&
                (b.skeleton.update(), (b.skeleton.frame = Le.render.frame)),
              !b.frustumCulled || te.intersectsObject(b))
            ) {
              z && _e.setFromMatrixPosition(b.matrixWorld).applyMatrix4(we);
              const Te = E.update(b),
                xe = b.material;
              if (Array.isArray(xe)) {
                const Re = Te.groups;
                for (let pe = 0, Ie = Re.length; pe < Ie; pe++) {
                  const ve = Re[pe],
                    Oe = xe[ve.materialIndex];
                  Oe && Oe.visible && h.push(b, Te, Oe, B, _e.z, ve);
                }
              } else xe.visible && h.push(b, Te, xe, B, _e.z, null);
            }
          }
          const Fe = b.children;
          for (let Te = 0, xe = Fe.length; Te < xe; Te++) Ol(Fe[Te], O, B, z);
        }
        function cf(b, O, B, z) {
          re === null &&
            (re = new Ot(1024, 1024, {
              generateMipmaps: !0,
              minFilter: ln,
              magFilter: Je,
              wrapS: at,
              wrapT: at,
            }));
          const Q = x.getRenderTarget();
          x.setRenderTarget(re),
            x.clear(),
            jr(b, B, z),
            Z.updateRenderTargetMipmap(re),
            x.setRenderTarget(Q),
            jr(O, B, z);
        }
        function jr(b, O, B) {
          const z = O.isScene === !0 ? O.overrideMaterial : null;
          for (let Q = 0, Fe = b.length; Q < Fe; Q++) {
            const Te = b[Q],
              xe = Te.object,
              Re = Te.geometry,
              pe = z === null ? Te.material : z,
              Ie = Te.group;
            if (B.isArrayCamera) {
              const ve = B.cameras;
              for (let Oe = 0, Ht = ve.length; Oe < Ht; Oe++) {
                const xt = ve[Oe];
                xe.layers.test(xt.layers) &&
                  (me.viewport(v.copy(xt.viewport)),
                  d.setupLightsView(xt),
                  Ul(xe, O, xt, Re, pe, Ie));
              }
            } else Ul(xe, O, B, Re, pe, Ie);
          }
        }
        function Ul(b, O, B, z, Q, Fe) {
          if (
            (b.onBeforeRender(x, O, B, z, Q, Fe),
            b.modelViewMatrix.multiplyMatrices(
              B.matrixWorldInverse,
              b.matrixWorld
            ),
            b.normalMatrix.getNormalMatrix(b.modelViewMatrix),
            b.isImmediateRenderObject)
          ) {
            const Te = Hl(B, O, Q, b);
            me.setMaterial(Q), W.reset(), Zt(b, Te);
          } else x.renderBufferDirect(B, O, z, Q, b, Fe);
          b.onAfterRender(x, O, B, z, Q, Fe);
        }
        function Eo(b, O, B) {
          O.isScene !== !0 && (O = Be);
          const z = X.get(b),
            Q = d.state.lights,
            Fe = d.state.shadowsArray,
            Te = Q.state.version,
            xe = S.getParameters(b, Q.state, Fe, O, B),
            Re = S.getProgramCacheKey(xe);
          let pe = z.programs;
          (z.environment = b.isMeshStandardMaterial ? O.environment : null),
            (z.fog = O.fog),
            (z.envMap = $.get(b.envMap || z.environment)),
            pe === void 0 &&
              (b.addEventListener("dispose", ft),
              (pe = new Map()),
              (z.programs = pe));
          let Ie = pe.get(Re);
          if (Ie !== void 0) {
            if (z.currentProgram === Ie && z.lightsStateVersion === Te)
              return zl(b, xe), Ie;
          } else
            (xe.uniforms = S.getUniforms(b)),
              b.onBuild(xe, x),
              b.onBeforeCompile(xe, x),
              (Ie = S.acquireProgram(xe, Re)),
              pe.set(Re, Ie),
              (z.uniforms = xe.uniforms);
          const ve = z.uniforms;
          ((!b.isShaderMaterial && !b.isRawShaderMaterial) ||
            b.clipping === !0) &&
            (ve.clippingPlanes = ae.uniform),
            zl(b, xe),
            (z.needsLights = hf(b)),
            (z.lightsStateVersion = Te),
            z.needsLights &&
              ((ve.ambientLightColor.value = Q.state.ambient),
              (ve.lightProbe.value = Q.state.probe),
              (ve.directionalLights.value = Q.state.directional),
              (ve.directionalLightShadows.value = Q.state.directionalShadow),
              (ve.spotLights.value = Q.state.spot),
              (ve.spotLightShadows.value = Q.state.spotShadow),
              (ve.rectAreaLights.value = Q.state.rectArea),
              (ve.ltc_1.value = Q.state.rectAreaLTC1),
              (ve.ltc_2.value = Q.state.rectAreaLTC2),
              (ve.pointLights.value = Q.state.point),
              (ve.pointLightShadows.value = Q.state.pointShadow),
              (ve.hemisphereLights.value = Q.state.hemi),
              (ve.directionalShadowMap.value = Q.state.directionalShadowMap),
              (ve.directionalShadowMatrix.value =
                Q.state.directionalShadowMatrix),
              (ve.spotShadowMap.value = Q.state.spotShadowMap),
              (ve.spotShadowMatrix.value = Q.state.spotShadowMatrix),
              (ve.pointShadowMap.value = Q.state.pointShadowMap),
              (ve.pointShadowMatrix.value = Q.state.pointShadowMatrix));
          const Oe = Ie.getUniforms(),
            Ht = vn.seqWithValue(Oe.seq, ve);
          return (z.currentProgram = Ie), (z.uniformsList = Ht), Ie;
        }
        function zl(b, O) {
          const B = X.get(b);
          (B.outputEncoding = O.outputEncoding),
            (B.instancing = O.instancing),
            (B.skinning = O.skinning),
            (B.numClippingPlanes = O.numClippingPlanes),
            (B.numIntersection = O.numClipIntersection),
            (B.vertexAlphas = O.vertexAlphas);
        }
        function Hl(b, O, B, z) {
          O.isScene !== !0 && (O = Be), Z.resetTextureUnits();
          const Q = O.fog,
            Fe = B.isMeshStandardMaterial ? O.environment : null,
            Te = _ === null ? x.outputEncoding : _.texture.encoding,
            xe = $.get(B.envMap || Fe),
            Re =
              B.vertexColors === !0 &&
              z.geometry &&
              z.geometry.attributes.color &&
              z.geometry.attributes.color.itemSize === 4,
            pe = X.get(B),
            Ie = d.state.lights;
          if (J === !0 && (oe === !0 || b !== T)) {
            const pt = b === T && B.id === w;
            ae.setState(B, b, pt);
          }
          let ve = !1;
          B.version === pe.__version
            ? ((pe.needsLights && pe.lightsStateVersion !== Ie.state.version) ||
                pe.outputEncoding !== Te ||
                (z.isInstancedMesh && pe.instancing === !1) ||
                (!z.isInstancedMesh && pe.instancing === !0) ||
                (z.isSkinnedMesh && pe.skinning === !1) ||
                (!z.isSkinnedMesh && pe.skinning === !0) ||
                pe.envMap !== xe ||
                (B.fog && pe.fog !== Q) ||
                (pe.numClippingPlanes !== void 0 &&
                  (pe.numClippingPlanes !== ae.numPlanes ||
                    pe.numIntersection !== ae.numIntersection)) ||
                pe.vertexAlphas !== Re) &&
              (ve = !0)
            : ((ve = !0), (pe.__version = B.version));
          let Oe = pe.currentProgram;
          ve === !0 && (Oe = Eo(B, O, z));
          let Ht = !1,
            xt = !1,
            Dn = !1;
          const tt = Oe.getUniforms(),
            Fn = pe.uniforms;
          if (
            (me.useProgram(Oe.program) && ((Ht = !0), (xt = !0), (Dn = !0)),
            B.id !== w && ((w = B.id), (xt = !0)),
            Ht || T !== b)
          ) {
            if (
              (tt.setValue(k, "projectionMatrix", b.projectionMatrix),
              Me.logarithmicDepthBuffer &&
                tt.setValue(
                  k,
                  "logDepthBufFC",
                  2 / (Math.log(b.far + 1) / Math.LN2)
                ),
              T !== b && ((T = b), (xt = !0), (Dn = !0)),
              B.isShaderMaterial ||
                B.isMeshPhongMaterial ||
                B.isMeshToonMaterial ||
                B.isMeshStandardMaterial ||
                B.envMap)
            ) {
              const pt = tt.map.cameraPosition;
              pt !== void 0 &&
                pt.setValue(k, _e.setFromMatrixPosition(b.matrixWorld));
            }
            (B.isMeshPhongMaterial ||
              B.isMeshToonMaterial ||
              B.isMeshLambertMaterial ||
              B.isMeshBasicMaterial ||
              B.isMeshStandardMaterial ||
              B.isShaderMaterial) &&
              tt.setValue(k, "isOrthographic", b.isOrthographicCamera === !0),
              (B.isMeshPhongMaterial ||
                B.isMeshToonMaterial ||
                B.isMeshLambertMaterial ||
                B.isMeshBasicMaterial ||
                B.isMeshStandardMaterial ||
                B.isShaderMaterial ||
                B.isShadowMaterial ||
                z.isSkinnedMesh) &&
                tt.setValue(k, "viewMatrix", b.matrixWorldInverse);
          }
          if (z.isSkinnedMesh) {
            tt.setOptional(k, z, "bindMatrix"),
              tt.setOptional(k, z, "bindMatrixInverse");
            const pt = z.skeleton;
            pt &&
              (Me.floatVertexTextures
                ? (pt.boneTexture === null && pt.computeBoneTexture(),
                  tt.setValue(k, "boneTexture", pt.boneTexture, Z),
                  tt.setValue(k, "boneTextureSize", pt.boneTextureSize))
                : tt.setOptional(k, pt, "boneMatrices"));
          }
          return (
            (xt || pe.receiveShadow !== z.receiveShadow) &&
              ((pe.receiveShadow = z.receiveShadow),
              tt.setValue(k, "receiveShadow", z.receiveShadow)),
            xt &&
              (tt.setValue(k, "toneMappingExposure", x.toneMappingExposure),
              pe.needsLights && uf(Fn, Dn),
              Q && B.fog && H.refreshFogUniforms(Fn, Q),
              H.refreshMaterialUniforms(Fn, B, U, N, re),
              vn.upload(k, pe.uniformsList, Fn, Z)),
            B.isShaderMaterial &&
              B.uniformsNeedUpdate === !0 &&
              (vn.upload(k, pe.uniformsList, Fn, Z),
              (B.uniformsNeedUpdate = !1)),
            B.isSpriteMaterial && tt.setValue(k, "center", z.center),
            tt.setValue(k, "modelViewMatrix", z.modelViewMatrix),
            tt.setValue(k, "normalMatrix", z.normalMatrix),
            tt.setValue(k, "modelMatrix", z.matrixWorld),
            Oe
          );
        }
        function uf(b, O) {
          (b.ambientLightColor.needsUpdate = O),
            (b.lightProbe.needsUpdate = O),
            (b.directionalLights.needsUpdate = O),
            (b.directionalLightShadows.needsUpdate = O),
            (b.pointLights.needsUpdate = O),
            (b.pointLightShadows.needsUpdate = O),
            (b.spotLights.needsUpdate = O),
            (b.spotLightShadows.needsUpdate = O),
            (b.rectAreaLights.needsUpdate = O),
            (b.hemisphereLights.needsUpdate = O);
        }
        function hf(b) {
          return (
            b.isMeshLambertMaterial ||
            b.isMeshToonMaterial ||
            b.isMeshPhongMaterial ||
            b.isMeshStandardMaterial ||
            b.isShadowMaterial ||
            (b.isShaderMaterial && b.lights === !0)
          );
        }
        (this.getActiveCubeFace = function () {
          return m;
        }),
          (this.getActiveMipmapLevel = function () {
            return g;
          }),
          (this.getRenderTarget = function () {
            return _;
          }),
          (this.setRenderTarget = function (b, O = 0, B = 0) {
            (_ = b),
              (m = O),
              (g = B),
              b &&
                X.get(b).__webglFramebuffer === void 0 &&
                Z.setupRenderTarget(b);
            let z = null,
              Q = !1,
              Fe = !1;
            if (b) {
              const xe = b.texture;
              (xe.isDataTexture3D || xe.isDataTexture2DArray) && (Fe = !0);
              const Re = X.get(b).__webglFramebuffer;
              b.isWebGLCubeRenderTarget
                ? ((z = Re[O]), (Q = !0))
                : b.isWebGLMultisampleRenderTarget
                ? (z = X.get(b).__webglMultisampledFramebuffer)
                : (z = Re),
                v.copy(b.viewport),
                A.copy(b.scissor),
                (L = b.scissorTest);
            } else
              v.copy(D).multiplyScalar(U).floor(),
                A.copy(F).multiplyScalar(U).floor(),
                (L = C);
            if (me.bindFramebuffer(36160, z) && Me.drawBuffers) {
              let xe = !1;
              if (b)
                if (b.isWebGLMultipleRenderTargets) {
                  const Re = b.texture;
                  if (V.length !== Re.length || V[0] !== 36064) {
                    for (let pe = 0, Ie = Re.length; pe < Ie; pe++)
                      V[pe] = 36064 + pe;
                    (V.length = Re.length), (xe = !0);
                  }
                } else
                  (V.length !== 1 || V[0] !== 36064) &&
                    ((V[0] = 36064), (V.length = 1), (xe = !0));
              else
                (V.length !== 1 || V[0] !== 1029) &&
                  ((V[0] = 1029), (V.length = 1), (xe = !0));
              xe &&
                (Me.isWebGL2
                  ? k.drawBuffers(V)
                  : Pe.get("WEBGL_draw_buffers").drawBuffersWEBGL(V));
            }
            if ((me.viewport(v), me.scissor(A), me.setScissorTest(L), Q)) {
              const xe = X.get(b.texture);
              k.framebufferTexture2D(
                36160,
                36064,
                34069 + O,
                xe.__webglTexture,
                B
              );
            } else if (Fe) {
              const xe = X.get(b.texture),
                Re = O || 0;
              k.framebufferTextureLayer(
                36160,
                36064,
                xe.__webglTexture,
                B || 0,
                Re
              );
            }
          }),
          (this.readRenderTargetPixels = function (b, O, B, z, Q, Fe, Te) {
            if (!(b && b.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let xe = X.get(b).__webglFramebuffer;
            if (
              (b.isWebGLCubeRenderTarget && Te !== void 0 && (xe = xe[Te]), xe)
            ) {
              me.bindFramebuffer(36160, xe);
              try {
                const Re = b.texture,
                  pe = Re.format,
                  Ie = Re.type;
                if (pe !== Et && j.convert(pe) !== k.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                const ve =
                  Ie === Mr &&
                  (Pe.has("EXT_color_buffer_half_float") ||
                    (Me.isWebGL2 && Pe.has("EXT_color_buffer_float")));
                if (
                  Ie !== qi &&
                  j.convert(Ie) !== k.getParameter(35738) &&
                  !(
                    Ie === tn &&
                    (Me.isWebGL2 ||
                      Pe.has("OES_texture_float") ||
                      Pe.has("WEBGL_color_buffer_float"))
                  ) &&
                  !ve
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                k.checkFramebufferStatus(36160) === 36053
                  ? O >= 0 &&
                    O <= b.width - z &&
                    B >= 0 &&
                    B <= b.height - Q &&
                    k.readPixels(O, B, z, Q, j.convert(pe), j.convert(Ie), Fe)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                const Re = _ !== null ? X.get(_).__webglFramebuffer : null;
                me.bindFramebuffer(36160, Re);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (b, O, B = 0) {
            const z = Math.pow(2, -B),
              Q = Math.floor(O.image.width * z),
              Fe = Math.floor(O.image.height * z);
            let Te = j.convert(O.format);
            Me.isWebGL2 &&
              (Te === 6407 && (Te = 32849), Te === 6408 && (Te = 32856)),
              Z.setTexture2D(O, 0),
              k.copyTexImage2D(3553, B, Te, b.x, b.y, Q, Fe, 0),
              me.unbindTexture();
          }),
          (this.copyTextureToTexture = function (b, O, B, z = 0) {
            const Q = O.image.width,
              Fe = O.image.height,
              Te = j.convert(B.format),
              xe = j.convert(B.type);
            Z.setTexture2D(B, 0),
              k.pixelStorei(37440, B.flipY),
              k.pixelStorei(37441, B.premultiplyAlpha),
              k.pixelStorei(3317, B.unpackAlignment),
              O.isDataTexture
                ? k.texSubImage2D(
                    3553,
                    z,
                    b.x,
                    b.y,
                    Q,
                    Fe,
                    Te,
                    xe,
                    O.image.data
                  )
                : O.isCompressedTexture
                ? k.compressedTexSubImage2D(
                    3553,
                    z,
                    b.x,
                    b.y,
                    O.mipmaps[0].width,
                    O.mipmaps[0].height,
                    Te,
                    O.mipmaps[0].data
                  )
                : k.texSubImage2D(3553, z, b.x, b.y, Te, xe, O.image),
              z === 0 && B.generateMipmaps && k.generateMipmap(3553),
              me.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (b, O, B, z, Q = 0) {
            if (x.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            const { width: Fe, height: Te, data: xe } = B.image,
              Re = j.convert(z.format),
              pe = j.convert(z.type);
            let Ie;
            if (z.isDataTexture3D) Z.setTexture3D(z, 0), (Ie = 32879);
            else if (z.isDataTexture2DArray)
              Z.setTexture2DArray(z, 0), (Ie = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            k.pixelStorei(37440, z.flipY),
              k.pixelStorei(37441, z.premultiplyAlpha),
              k.pixelStorei(3317, z.unpackAlignment);
            const ve = k.getParameter(3314),
              Oe = k.getParameter(32878),
              Ht = k.getParameter(3316),
              xt = k.getParameter(3315),
              Dn = k.getParameter(32877);
            k.pixelStorei(3314, Fe),
              k.pixelStorei(32878, Te),
              k.pixelStorei(3316, b.min.x),
              k.pixelStorei(3315, b.min.y),
              k.pixelStorei(32877, b.min.z),
              k.texSubImage3D(
                Ie,
                Q,
                O.x,
                O.y,
                O.z,
                b.max.x - b.min.x + 1,
                b.max.y - b.min.y + 1,
                b.max.z - b.min.z + 1,
                Re,
                pe,
                xe
              ),
              k.pixelStorei(3314, ve),
              k.pixelStorei(32878, Oe),
              k.pixelStorei(3316, Ht),
              k.pixelStorei(3315, xt),
              k.pixelStorei(32877, Dn),
              Q === 0 && z.generateMipmaps && k.generateMipmap(Ie),
              me.unbindTexture();
          }),
          (this.initTexture = function (b) {
            Z.setTexture2D(b, 0), me.unbindTexture();
          }),
          (this.resetState = function () {
            (m = 0), (g = 0), (_ = null), me.reset(), W.reset();
          }),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      class xd extends Ue {}
      xd.prototype.isWebGL1Renderer = !0;
      class Ur {
        constructor(e, t = 25e-5) {
          (this.name = ""), (this.color = new K(e)), (this.density = t);
        }
        clone() {
          return new Ur(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        }
      }
      Ur.prototype.isFogExp2 = !0;
      class zr {
        constructor(e, t = 1, n = 1e3) {
          (this.name = ""),
            (this.color = new K(e)),
            (this.near = t),
            (this.far = n);
        }
        clone() {
          return new zr(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      zr.prototype.isFog = !0;
      class Hr extends Ee {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ != "undefined" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
              (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            this.background !== null &&
              (t.object.background = this.background.toJSON(e)),
            this.environment !== null &&
              (t.object.environment = this.environment.toJSON(e)),
            this.fog !== null && (t.object.fog = this.fog.toJSON()),
            t
          );
        }
      }
      Hr.prototype.isScene = !0;
      class Rn {
        constructor(e, t) {
          (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = Fi),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = At());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = At()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = At()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Rn.prototype.isInterleavedBuffer = !0;
      const Ye = new M();
      class on {
        constructor(e, t, n, i) {
          (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i === !0);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            (Ye.x = this.getX(t)),
              (Ye.y = this.getY(t)),
              (Ye.z = this.getZ(t)),
              Ye.applyMatrix4(e),
              this.setXYZ(t, Ye.x, Ye.y, Ye.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (Ye.x = this.getX(t)),
              (Ye.y = this.getY(t)),
              (Ye.z = this.getZ(t)),
              Ye.applyNormalMatrix(e),
              this.setXYZ(t, Ye.x, Ye.y, Ye.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (Ye.x = this.getX(t)),
              (Ye.y = this.getY(t)),
              (Ye.z = this.getZ(t)),
              Ye.transformDirection(e),
              this.setXYZ(t, Ye.x, Ye.y, Ye.z);
          return this;
        }
        setX(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset] = t), this
          );
        }
        setY(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 1] = t), this
          );
        }
        setZ(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 2] = t), this
          );
        }
        setW(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 3] = t), this
          );
        }
        getX(e) {
          return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
          return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
          return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
          return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return new be(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new on(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
        }
      }
      on.prototype.isInterleavedBufferAttribute = !0;
      class po extends et {
        constructor(e) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new K(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        }
      }
      po.prototype.isSpriteMaterial = !0;
      let _i;
      const rr = new M(),
        Mi = new M(),
        wi = new M(),
        bi = new q(),
        sr = new q(),
        yd = new ce(),
        gs = new M(),
        or = new M(),
        xs = new M(),
        pc = new q(),
        $o = new q(),
        mc = new q();
      class mo extends Ee {
        constructor(e) {
          if ((super(), (this.type = "Sprite"), _i === void 0)) {
            _i = new de();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              n = new Rn(t, 5);
            _i.setIndex([0, 1, 2, 0, 2, 3]),
              _i.setAttribute("position", new on(n, 3, 0, !1)),
              _i.setAttribute("uv", new on(n, 2, 3, !1));
          }
          (this.geometry = _i),
            (this.material = e !== void 0 ? e : new po()),
            (this.center = new q(0.5, 0.5));
        }
        raycast(e, t) {
          e.camera === null &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Mi.setFromMatrixScale(this.matrixWorld),
            yd.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            wi.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              this.material.sizeAttenuation === !1 &&
              Mi.multiplyScalar(-wi.z);
          const n = this.material.rotation;
          let i, r;
          n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
          const o = this.center;
          ys(gs.set(-0.5, -0.5, 0), wi, o, Mi, i, r),
            ys(or.set(0.5, -0.5, 0), wi, o, Mi, i, r),
            ys(xs.set(0.5, 0.5, 0), wi, o, Mi, i, r),
            pc.set(0, 0),
            $o.set(1, 0),
            mc.set(1, 1);
          let a = e.ray.intersectTriangle(gs, or, xs, !1, rr);
          if (
            a === null &&
            (ys(or.set(-0.5, 0.5, 0), wi, o, Mi, i, r),
            $o.set(0, 1),
            (a = e.ray.intersectTriangle(gs, xs, or, !1, rr)),
            a === null)
          )
            return;
          const c = e.ray.origin.distanceTo(rr);
          c < e.near ||
            c > e.far ||
            t.push({
              distance: c,
              point: rr.clone(),
              uv: je.getUV(rr, gs, or, xs, pc, $o, mc, new q()),
              face: null,
              object: this,
            });
        }
        copy(e) {
          return (
            super.copy(e),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        }
      }
      mo.prototype.isSprite = !0;
      function ys(s, e, t, n, i, r) {
        bi.subVectors(s, t).addScalar(0.5).multiply(n),
          i !== void 0
            ? ((sr.x = r * bi.x - i * bi.y), (sr.y = i * bi.x + r * bi.y))
            : sr.copy(bi),
          s.copy(e),
          (s.x += sr.x),
          (s.y += sr.y),
          s.applyMatrix4(yd);
      }
      const vs = new M(),
        gc = new M();
      class vd extends Ee {
        constructor() {
          super(),
            (this._currentLevel = 0),
            (this.type = "LOD"),
            Object.defineProperties(this, {
              levels: { enumerable: !0, value: [] },
              isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
        }
        copy(e) {
          super.copy(e, !1);
          const t = e.levels;
          for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            this.addLevel(r.object.clone(), r.distance);
          }
          return (this.autoUpdate = e.autoUpdate), this;
        }
        addLevel(e, t = 0) {
          t = Math.abs(t);
          const n = this.levels;
          let i;
          for (i = 0; i < n.length && !(t < n[i].distance); i++);
          return n.splice(i, 0, { distance: t, object: e }), this.add(e), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(e) {
          const t = this.levels;
          if (t.length > 0) {
            let n, i;
            for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
            return t[n - 1].object;
          }
          return null;
        }
        raycast(e, t) {
          if (this.levels.length > 0) {
            vs.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(vs);
            this.getObjectForDistance(i).raycast(e, t);
          }
        }
        update(e) {
          const t = this.levels;
          if (t.length > 1) {
            vs.setFromMatrixPosition(e.matrixWorld),
              gc.setFromMatrixPosition(this.matrixWorld);
            const n = vs.distanceTo(gc) / e.zoom;
            t[0].object.visible = !0;
            let i, r;
            for (i = 1, r = t.length; i < r && n >= t[i].distance; i++)
              (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
            for (this._currentLevel = i - 1; i < r; i++)
              t[i].object.visible = !1;
          }
        }
        toJSON(e) {
          const t = super.toJSON(e);
          this.autoUpdate === !1 && (t.object.autoUpdate = !1),
            (t.object.levels = []);
          const n = this.levels;
          for (let i = 0, r = n.length; i < r; i++) {
            const o = n[i];
            t.object.levels.push({
              object: o.object.uuid,
              distance: o.distance,
            });
          }
          return t;
        }
      }
      const xc = new M(),
        yc = new Ge(),
        vc = new Ge(),
        Ty = new M(),
        _c = new ce();
      class kr extends $e {
        constructor(e, t) {
          super(e, t),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new ce()),
            (this.bindMatrixInverse = new ce());
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new Ge(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            (e.x = t.getX(n)),
              (e.y = t.getY(n)),
              (e.z = t.getZ(n)),
              (e.w = t.getW(n));
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === "attached"
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === "detached"
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          yc.fromBufferAttribute(i.attributes.skinIndex, e),
            vc.fromBufferAttribute(i.attributes.skinWeight, e),
            xc
              .fromBufferAttribute(i.attributes.position, e)
              .applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const o = vc.getComponent(r);
            if (o !== 0) {
              const a = yc.getComponent(r);
              _c.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(Ty.copy(xc).applyMatrix4(_c), o);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      kr.prototype.isSkinnedMesh = !0;
      class Vr extends Ee {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      Vr.prototype.isBone = !0;
      class Gi extends rt {
        constructor(e, t, n, i, r, o, a, c, l, u, h, d) {
          super(null, o, a, c, l, u, i, r, h, d),
            (this.image = { data: e || null, width: t || 1, height: n || 1 }),
            (this.magFilter = l !== void 0 ? l : Je),
            (this.minFilter = u !== void 0 ? u : Je),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      Gi.prototype.isDataTexture = !0;
      const Mc = new ce(),
        Ey = new ce();
      class Wr {
        constructor(e = [], t = []) {
          (this.uuid = At()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(e.length * 16)),
            t.length === 0)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let n = 0, i = this.bones.length; n < i; n++)
              this.boneInverses.push(new ce());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new ce();
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(n);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n &&
              (n.parent && n.parent.isBone
                ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                  n.matrix.multiply(n.matrixWorld))
                : n.matrix.copy(n.matrixWorld),
              n.matrix.decompose(n.position, n.quaternion, n.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let r = 0, o = e.length; r < o; r++) {
            const a = e[r] ? e[r].matrixWorld : Ey;
            Mc.multiplyMatrices(a, t[r]), Mc.toArray(n, r * 16);
          }
          i !== null && (i.needsUpdate = !0);
        }
        clone() {
          return new Wr(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          (e = Yh(e)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new Gi(t, e, e, Et, tn);
          return (
            (this.boneMatrices = t),
            (this.boneTexture = n),
            (this.boneTextureSize = e),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e) return i;
          }
        }
        dispose() {
          this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const r = e.bones[n];
            let o = t[r];
            o === void 0 &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", r),
              (o = new Vr())),
              this.bones.push(o),
              this.boneInverses.push(new ce().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray());
          }
          return e;
        }
      }
      const wc = new ce(),
        bc = new ce(),
        _s = [],
        ar = new $e();
      class tl extends $e {
        constructor(e, t, n) {
          super(e, t),
            (this.instanceMatrix = new be(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(e) {
          return (
            super.copy(e),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((ar.geometry = this.geometry),
            (ar.material = this.material),
            ar.material !== void 0)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, wc),
                bc.multiplyMatrices(n, wc),
                (ar.matrixWorld = bc),
                ar.raycast(e, _s);
              for (let o = 0, a = _s.length; o < a; o++) {
                const c = _s[o];
                (c.instanceId = r), (c.object = this), t.push(c);
              }
              _s.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null &&
            (this.instanceColor = new be(new Float32Array(this.count * 3), 3)),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      tl.prototype.isInstancedMesh = !0;
      class st extends et {
        constructor(e) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new K(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      st.prototype.isLineBasicMaterial = !0;
      const Sc = new M(),
        Tc = new M(),
        Ec = new ce(),
        Qo = new Ln(),
        Ms = new cn();
      class Xt extends Ee {
        constructor(e = new de(), t = new st()) {
          super(),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [0];
              for (let i = 1, r = t.count; i < r; i++)
                Sc.fromBufferAttribute(t, i - 1),
                  Tc.fromBufferAttribute(t, i),
                  (n[i] = n[i - 1]),
                  (n[i] += Sc.distanceTo(Tc));
              e.setAttribute("lineDistance", new le(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Ms.copy(n.boundingSphere),
            Ms.applyMatrix4(i),
            (Ms.radius += r),
            e.ray.intersectsSphere(Ms) === !1)
          )
            return;
          Ec.copy(i).invert(), Qo.copy(e.ray).applyMatrix4(Ec);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            c = a * a,
            l = new M(),
            u = new M(),
            h = new M(),
            d = new M(),
            f = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const p = n.index,
              y = n.attributes.position;
            if (p !== null) {
              const m = Math.max(0, o.start),
                g = Math.min(p.count, o.start + o.count);
              for (let _ = m, w = g - 1; _ < w; _ += f) {
                const T = p.getX(_),
                  v = p.getX(_ + 1);
                if (
                  (l.fromBufferAttribute(y, T),
                  u.fromBufferAttribute(y, v),
                  Qo.distanceSqToSegment(l, u, d, h) > c)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const L = e.ray.origin.distanceTo(d);
                L < e.near ||
                  L > e.far ||
                  t.push({
                    distance: L,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: _,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const m = Math.max(0, o.start),
                g = Math.min(y.count, o.start + o.count);
              for (let _ = m, w = g - 1; _ < w; _ += f) {
                if (
                  (l.fromBufferAttribute(y, _),
                  u.fromBufferAttribute(y, _ + 1),
                  Qo.distanceSqToSegment(l, u, d, h) > c)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const v = e.ray.origin.distanceTo(d);
                v < e.near ||
                  v > e.far ||
                  t.push({
                    distance: v,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: _,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Xt.prototype.isLine = !0;
      const Ac = new M(),
        Lc = new M();
      class Mt extends Xt {
        constructor(e, t) {
          super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [];
              for (let i = 0, r = t.count; i < r; i += 2)
                Ac.fromBufferAttribute(t, i),
                  Lc.fromBufferAttribute(t, i + 1),
                  (n[i] = i === 0 ? 0 : n[i - 1]),
                  (n[i + 1] = n[i] + Ac.distanceTo(Lc));
              e.setAttribute("lineDistance", new le(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      Mt.prototype.isLineSegments = !0;
      class go extends Xt {
        constructor(e, t) {
          super(e, t), (this.type = "LineLoop");
        }
      }
      go.prototype.isLineLoop = !0;
      class Cn extends et {
        constructor(e) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new K(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      Cn.prototype.isPointsMaterial = !0;
      const Rc = new ce(),
        Ia = new Ln(),
        ws = new cn(),
        bs = new M();
      class Zi extends Ee {
        constructor(e = new de(), t = new Cn()) {
          super(),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            ws.copy(n.boundingSphere),
            ws.applyMatrix4(i),
            (ws.radius += r),
            e.ray.intersectsSphere(ws) === !1)
          )
            return;
          Rc.copy(i).invert(), Ia.copy(e.ray).applyMatrix4(Rc);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            c = a * a;
          if (n.isBufferGeometry) {
            const l = n.index,
              h = n.attributes.position;
            if (l !== null) {
              const d = Math.max(0, o.start),
                f = Math.min(l.count, o.start + o.count);
              for (let p = d, x = f; p < x; p++) {
                const y = l.getX(p);
                bs.fromBufferAttribute(h, y), Cc(bs, y, c, i, e, t, this);
              }
            } else {
              const d = Math.max(0, o.start),
                f = Math.min(h.count, o.start + o.count);
              for (let p = d, x = f; p < x; p++)
                bs.fromBufferAttribute(h, p), Cc(bs, p, c, i, e, t, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Zi.prototype.isPoints = !0;
      function Cc(s, e, t, n, i, r, o) {
        const a = Ia.distanceSqToPoint(s);
        if (a < t) {
          const c = new M();
          Ia.closestPointToPoint(s, c), c.applyMatrix4(n);
          const l = i.ray.origin.distanceTo(c);
          if (l < i.near || l > i.far) return;
          r.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: c,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      class _d extends rt {
        constructor(e, t, n, i, r, o, a, c, l) {
          super(e, t, n, i, r, o, a, c, l),
            (this.format = a !== void 0 ? a : rn),
            (this.minFilter = o !== void 0 ? o : Ke),
            (this.magFilter = r !== void 0 ? r : Ke),
            (this.generateMipmaps = !1);
          const u = this;
          function h() {
            (u.needsUpdate = !0), e.requestVideoFrameCallback(h);
          }
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      _d.prototype.isVideoTexture = !0;
      class nl extends rt {
        constructor(e, t, n, i, r, o, a, c, l, u, h, d) {
          super(null, o, a, c, l, u, i, r, h, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      nl.prototype.isCompressedTexture = !0;
      class il extends rt {
        constructor(e, t, n, i, r, o, a, c, l) {
          super(e, t, n, i, r, o, a, c, l), (this.needsUpdate = !0);
        }
      }
      il.prototype.isCanvasTexture = !0;
      class Md extends rt {
        constructor(e, t, n, i, r, o, a, c, l, u) {
          if (((u = u !== void 0 ? u : Zn), u !== Zn && u !== Ii))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && u === Zn && (n = _r),
            n === void 0 && u === Ii && (n = Ri),
            super(null, i, r, o, a, c, u, n, l),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : Je),
            (this.minFilter = c !== void 0 ? c : Je),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      Md.prototype.isDepthTexture = !0;
      class Ws extends de {
        constructor(e = 1, t = 8, n = 0, i = Math.PI * 2) {
          super(),
            (this.type = "CircleGeometry"),
            (this.parameters = {
              radius: e,
              segments: t,
              thetaStart: n,
              thetaLength: i,
            }),
            (t = Math.max(3, t));
          const r = [],
            o = [],
            a = [],
            c = [],
            l = new M(),
            u = new q();
          o.push(0, 0, 0), a.push(0, 0, 1), c.push(0.5, 0.5);
          for (let h = 0, d = 3; h <= t; h++, d += 3) {
            const f = n + (h / t) * i;
            (l.x = e * Math.cos(f)),
              (l.y = e * Math.sin(f)),
              o.push(l.x, l.y, l.z),
              a.push(0, 0, 1),
              (u.x = (o[d] / e + 1) / 2),
              (u.y = (o[d + 1] / e + 1) / 2),
              c.push(u.x, u.y);
          }
          for (let h = 1; h <= t; h++) r.push(h, h + 1, 0);
          this.setIndex(r),
            this.setAttribute("position", new le(o, 3)),
            this.setAttribute("normal", new le(a, 3)),
            this.setAttribute("uv", new le(c, 2));
        }
      }
      class Oi extends de {
        constructor(
          e = 1,
          t = 1,
          n = 1,
          i = 8,
          r = 1,
          o = !1,
          a = 0,
          c = Math.PI * 2
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: e,
              radiusBottom: t,
              height: n,
              radialSegments: i,
              heightSegments: r,
              openEnded: o,
              thetaStart: a,
              thetaLength: c,
            });
          const l = this;
          (i = Math.floor(i)), (r = Math.floor(r));
          const u = [],
            h = [],
            d = [],
            f = [];
          let p = 0;
          const x = [],
            y = n / 2;
          let m = 0;
          g(),
            o === !1 && (e > 0 && _(!0), t > 0 && _(!1)),
            this.setIndex(u),
            this.setAttribute("position", new le(h, 3)),
            this.setAttribute("normal", new le(d, 3)),
            this.setAttribute("uv", new le(f, 2));
          function g() {
            const w = new M(),
              T = new M();
            let v = 0;
            const A = (t - e) / n;
            for (let L = 0; L <= r; L++) {
              const I = [],
                N = L / r,
                U = N * (t - e) + e;
              for (let G = 0; G <= i; G++) {
                const R = G / i,
                  D = R * c + a,
                  F = Math.sin(D),
                  C = Math.cos(D);
                (T.x = U * F),
                  (T.y = -N * n + y),
                  (T.z = U * C),
                  h.push(T.x, T.y, T.z),
                  w.set(F, A, C).normalize(),
                  d.push(w.x, w.y, w.z),
                  f.push(R, 1 - N),
                  I.push(p++);
              }
              x.push(I);
            }
            for (let L = 0; L < i; L++)
              for (let I = 0; I < r; I++) {
                const N = x[I][L],
                  U = x[I + 1][L],
                  G = x[I + 1][L + 1],
                  R = x[I][L + 1];
                u.push(N, U, R), u.push(U, G, R), (v += 6);
              }
            l.addGroup(m, v, 0), (m += v);
          }
          function _(w) {
            const T = p,
              v = new q(),
              A = new M();
            let L = 0;
            const I = w === !0 ? e : t,
              N = w === !0 ? 1 : -1;
            for (let G = 1; G <= i; G++)
              h.push(0, y * N, 0), d.push(0, N, 0), f.push(0.5, 0.5), p++;
            const U = p;
            for (let G = 0; G <= i; G++) {
              const D = (G / i) * c + a,
                F = Math.cos(D),
                C = Math.sin(D);
              (A.x = I * C),
                (A.y = y * N),
                (A.z = I * F),
                h.push(A.x, A.y, A.z),
                d.push(0, N, 0),
                (v.x = F * 0.5 + 0.5),
                (v.y = C * 0.5 * N + 0.5),
                f.push(v.x, v.y),
                p++;
            }
            for (let G = 0; G < i; G++) {
              const R = T + G,
                D = U + G;
              w === !0 ? u.push(D, D + 1, R) : u.push(D + 1, D, R), (L += 3);
            }
            l.addGroup(m, L, w === !0 ? 1 : 2), (m += L);
          }
        }
      }
      class qs extends Oi {
        constructor(
          e = 1,
          t = 1,
          n = 8,
          i = 1,
          r = !1,
          o = 0,
          a = Math.PI * 2
        ) {
          super(0, e, t, n, i, r, o, a),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: e,
              height: t,
              radialSegments: n,
              heightSegments: i,
              openEnded: r,
              thetaStart: o,
              thetaLength: a,
            });
        }
      }
      class Sn extends de {
        constructor(e, t, n = 1, i = 0) {
          super(),
            (this.type = "PolyhedronGeometry"),
            (this.parameters = {
              vertices: e,
              indices: t,
              radius: n,
              detail: i,
            });
          const r = [],
            o = [];
          a(i),
            l(n),
            u(),
            this.setAttribute("position", new le(r, 3)),
            this.setAttribute("normal", new le(r.slice(), 3)),
            this.setAttribute("uv", new le(o, 2)),
            i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
          function a(g) {
            const _ = new M(),
              w = new M(),
              T = new M();
            for (let v = 0; v < t.length; v += 3)
              f(t[v + 0], _), f(t[v + 1], w), f(t[v + 2], T), c(_, w, T, g);
          }
          function c(g, _, w, T) {
            const v = T + 1,
              A = [];
            for (let L = 0; L <= v; L++) {
              A[L] = [];
              const I = g.clone().lerp(w, L / v),
                N = _.clone().lerp(w, L / v),
                U = v - L;
              for (let G = 0; G <= U; G++)
                G === 0 && L === v
                  ? (A[L][G] = I)
                  : (A[L][G] = I.clone().lerp(N, G / U));
            }
            for (let L = 0; L < v; L++)
              for (let I = 0; I < 2 * (v - L) - 1; I++) {
                const N = Math.floor(I / 2);
                I % 2 === 0
                  ? (d(A[L][N + 1]), d(A[L + 1][N]), d(A[L][N]))
                  : (d(A[L][N + 1]), d(A[L + 1][N + 1]), d(A[L + 1][N]));
              }
          }
          function l(g) {
            const _ = new M();
            for (let w = 0; w < r.length; w += 3)
              (_.x = r[w + 0]),
                (_.y = r[w + 1]),
                (_.z = r[w + 2]),
                _.normalize().multiplyScalar(g),
                (r[w + 0] = _.x),
                (r[w + 1] = _.y),
                (r[w + 2] = _.z);
          }
          function u() {
            const g = new M();
            for (let _ = 0; _ < r.length; _ += 3) {
              (g.x = r[_ + 0]), (g.y = r[_ + 1]), (g.z = r[_ + 2]);
              const w = y(g) / 2 / Math.PI + 0.5,
                T = m(g) / Math.PI + 0.5;
              o.push(w, 1 - T);
            }
            p(), h();
          }
          function h() {
            for (let g = 0; g < o.length; g += 6) {
              const _ = o[g + 0],
                w = o[g + 2],
                T = o[g + 4],
                v = Math.max(_, w, T),
                A = Math.min(_, w, T);
              v > 0.9 &&
                A < 0.1 &&
                (_ < 0.2 && (o[g + 0] += 1),
                w < 0.2 && (o[g + 2] += 1),
                T < 0.2 && (o[g + 4] += 1));
            }
          }
          function d(g) {
            r.push(g.x, g.y, g.z);
          }
          function f(g, _) {
            const w = g * 3;
            (_.x = e[w + 0]), (_.y = e[w + 1]), (_.z = e[w + 2]);
          }
          function p() {
            const g = new M(),
              _ = new M(),
              w = new M(),
              T = new M(),
              v = new q(),
              A = new q(),
              L = new q();
            for (let I = 0, N = 0; I < r.length; I += 9, N += 6) {
              g.set(r[I + 0], r[I + 1], r[I + 2]),
                _.set(r[I + 3], r[I + 4], r[I + 5]),
                w.set(r[I + 6], r[I + 7], r[I + 8]),
                v.set(o[N + 0], o[N + 1]),
                A.set(o[N + 2], o[N + 3]),
                L.set(o[N + 4], o[N + 5]),
                T.copy(g).add(_).add(w).divideScalar(3);
              const U = y(T);
              x(v, N + 0, g, U), x(A, N + 2, _, U), x(L, N + 4, w, U);
            }
          }
          function x(g, _, w, T) {
            T < 0 && g.x === 1 && (o[_] = g.x - 1),
              w.x === 0 && w.z === 0 && (o[_] = T / 2 / Math.PI + 0.5);
          }
          function y(g) {
            return Math.atan2(g.z, -g.x);
          }
          function m(g) {
            return Math.atan2(-g.y, Math.sqrt(g.x * g.x + g.z * g.z));
          }
        }
      }
      class Xs extends Sn {
        constructor(e = 1, t = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n,
            r = [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              0,
              -n,
              0,
              -i,
              n,
              0,
              -i,
              -n,
              0,
              i,
              n,
              0,
              i,
            ],
            o = [
              3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17,
              4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12,
              1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18,
              2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
              12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14,
              4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ];
          super(r, o, e, t),
            (this.type = "DodecahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
      }
      const Ss = new M(),
        Ts = new M(),
        ea = new M(),
        Es = new je();
      class rl extends de {
        constructor(e, t) {
          if (
            (super(),
            (this.type = "EdgesGeometry"),
            (this.parameters = { thresholdAngle: t }),
            (t = t !== void 0 ? t : 1),
            e.isGeometry === !0)
          ) {
            console.error(
              "THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
            return;
          }
          const i = Math.pow(10, 4),
            r = Math.cos(Jn * t),
            o = e.getIndex(),
            a = e.getAttribute("position"),
            c = o ? o.count : a.count,
            l = [0, 0, 0],
            u = ["a", "b", "c"],
            h = new Array(3),
            d = {},
            f = [];
          for (let p = 0; p < c; p += 3) {
            o
              ? ((l[0] = o.getX(p)),
                (l[1] = o.getX(p + 1)),
                (l[2] = o.getX(p + 2)))
              : ((l[0] = p), (l[1] = p + 1), (l[2] = p + 2));
            const { a: x, b: y, c: m } = Es;
            if (
              (x.fromBufferAttribute(a, l[0]),
              y.fromBufferAttribute(a, l[1]),
              m.fromBufferAttribute(a, l[2]),
              Es.getNormal(ea),
              (h[0] = `${Math.round(x.x * i)},${Math.round(
                x.y * i
              )},${Math.round(x.z * i)}`),
              (h[1] = `${Math.round(y.x * i)},${Math.round(
                y.y * i
              )},${Math.round(y.z * i)}`),
              (h[2] = `${Math.round(m.x * i)},${Math.round(
                m.y * i
              )},${Math.round(m.z * i)}`),
              !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
            )
              for (let g = 0; g < 3; g++) {
                const _ = (g + 1) % 3,
                  w = h[g],
                  T = h[_],
                  v = Es[u[g]],
                  A = Es[u[_]],
                  L = `${w}_${T}`,
                  I = `${T}_${w}`;
                I in d && d[I]
                  ? (ea.dot(d[I].normal) <= r &&
                      (f.push(v.x, v.y, v.z), f.push(A.x, A.y, A.z)),
                    (d[I] = null))
                  : L in d ||
                    (d[L] = { index0: l[g], index1: l[_], normal: ea.clone() });
              }
          }
          for (const p in d)
            if (d[p]) {
              const { index0: x, index1: y } = d[p];
              Ss.fromBufferAttribute(a, x),
                Ts.fromBufferAttribute(a, y),
                f.push(Ss.x, Ss.y, Ss.z),
                f.push(Ts.x, Ts.y, Ts.z);
            }
          this.setAttribute("position", new le(f, 3));
        }
      }
      const Ay = {
        triangulate: function (s, e, t) {
          t = t || 2;
          const n = e && e.length,
            i = n ? e[0] * t : s.length;
          let r = wd(s, 0, i, t, !0);
          const o = [];
          if (!r || r.next === r.prev) return o;
          let a, c, l, u, h, d, f;
          if ((n && (r = Iy(s, e, r, t)), s.length > 80 * t)) {
            (a = l = s[0]), (c = u = s[1]);
            for (let p = t; p < i; p += t)
              (h = s[p]),
                (d = s[p + 1]),
                h < a && (a = h),
                d < c && (c = d),
                h > l && (l = h),
                d > u && (u = d);
            (f = Math.max(l - a, u - c)), (f = f !== 0 ? 1 / f : 0);
          }
          return Tr(r, o, t, a, c, f), o;
        },
      };
      function wd(s, e, t, n, i) {
        let r, o;
        if (i === Vy(s, e, t, n) > 0)
          for (r = e; r < t; r += n) o = Pc(r, s[r], s[r + 1], o);
        else for (r = t - n; r >= e; r -= n) o = Pc(r, s[r], s[r + 1], o);
        return o && xo(o, o.next) && (Ar(o), (o = o.next)), o;
      }
      function Tn(s, e) {
        if (!s) return s;
        e || (e = s);
        let t = s,
          n;
        do
          if (
            ((n = !1),
            !t.steiner && (xo(t, t.next) || We(t.prev, t, t.next) === 0))
          ) {
            if ((Ar(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
          } else t = t.next;
        while (n || t !== e);
        return e;
      }
      function Tr(s, e, t, n, i, r, o) {
        if (!s) return;
        !o && r && Gy(s, n, i, r);
        let a = s,
          c,
          l;
        for (; s.prev !== s.next; ) {
          if (((c = s.prev), (l = s.next), r ? Ry(s, n, i, r) : Ly(s))) {
            e.push(c.i / t),
              e.push(s.i / t),
              e.push(l.i / t),
              Ar(s),
              (s = l.next),
              (a = l.next);
            continue;
          }
          if (((s = l), s === a)) {
            o
              ? o === 1
                ? ((s = Cy(Tn(s), e, t)), Tr(s, e, t, n, i, r, 2))
                : o === 2 && Py(s, e, t, n, i, r)
              : Tr(Tn(s), e, t, n, i, r, 1);
            break;
          }
        }
      }
      function Ly(s) {
        const e = s.prev,
          t = s,
          n = s.next;
        if (We(e, t, n) >= 0) return !1;
        let i = s.next.next;
        for (; i !== s.prev; ) {
          if (
            Ai(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            We(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function Ry(s, e, t, n) {
        const i = s.prev,
          r = s,
          o = s.next;
        if (We(i, r, o) >= 0) return !1;
        const a = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
          c = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
          l = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
          u = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
          h = Da(a, c, e, t, n),
          d = Da(l, u, e, t, n);
        let f = s.prevZ,
          p = s.nextZ;
        for (; f && f.z >= h && p && p.z <= d; ) {
          if (
            (f !== s.prev &&
              f !== s.next &&
              Ai(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
              We(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            p !== s.prev &&
              p !== s.next &&
              Ai(i.x, i.y, r.x, r.y, o.x, o.y, p.x, p.y) &&
              We(p.prev, p, p.next) >= 0)
          )
            return !1;
          p = p.nextZ;
        }
        for (; f && f.z >= h; ) {
          if (
            f !== s.prev &&
            f !== s.next &&
            Ai(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
            We(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; p && p.z <= d; ) {
          if (
            p !== s.prev &&
            p !== s.next &&
            Ai(i.x, i.y, r.x, r.y, o.x, o.y, p.x, p.y) &&
            We(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.nextZ;
        }
        return !0;
      }
      function Cy(s, e, t) {
        let n = s;
        do {
          const i = n.prev,
            r = n.next.next;
          !xo(i, r) &&
            bd(i, n, n.next, r) &&
            Er(i, r) &&
            Er(r, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(r.i / t),
            Ar(n),
            Ar(n.next),
            (n = s = r)),
            (n = n.next);
        } while (n !== s);
        return Tn(n);
      }
      function Py(s, e, t, n, i, r) {
        let o = s;
        do {
          let a = o.next.next;
          for (; a !== o.prev; ) {
            if (o.i !== a.i && zy(o, a)) {
              let c = Sd(o, a);
              (o = Tn(o, o.next)),
                (c = Tn(c, c.next)),
                Tr(o, e, t, n, i, r),
                Tr(c, e, t, n, i, r);
              return;
            }
            a = a.next;
          }
          o = o.next;
        } while (o !== s);
      }
      function Iy(s, e, t, n) {
        const i = [];
        let r, o, a, c, l;
        for (r = 0, o = e.length; r < o; r++)
          (a = e[r] * n),
            (c = r < o - 1 ? e[r + 1] * n : s.length),
            (l = wd(s, a, c, n, !1)),
            l === l.next && (l.steiner = !0),
            i.push(Uy(l));
        for (i.sort(Dy), r = 0; r < i.length; r++)
          Fy(i[r], t), (t = Tn(t, t.next));
        return t;
      }
      function Dy(s, e) {
        return s.x - e.x;
      }
      function Fy(s, e) {
        if (((e = By(s, e)), e)) {
          const t = Sd(e, s);
          Tn(e, e.next), Tn(t, t.next);
        }
      }
      function By(s, e) {
        let t = e;
        const n = s.x,
          i = s.y;
        let r = -1 / 0,
          o;
        do {
          if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > r) {
              if (((r = d), d === n)) {
                if (i === t.y) return t;
                if (i === t.next.y) return t.next;
              }
              o = t.x < t.next.x ? t : t.next;
            }
          }
          t = t.next;
        } while (t !== e);
        if (!o) return null;
        if (n === r) return o;
        const a = o,
          c = o.x,
          l = o.y;
        let u = 1 / 0,
          h;
        t = o;
        do
          n >= t.x &&
            t.x >= c &&
            n !== t.x &&
            Ai(i < l ? n : r, i, c, l, i < l ? r : n, i, t.x, t.y) &&
            ((h = Math.abs(i - t.y) / (n - t.x)),
            Er(t, s) &&
              (h < u ||
                (h === u && (t.x > o.x || (t.x === o.x && Ny(o, t))))) &&
              ((o = t), (u = h))),
            (t = t.next);
        while (t !== a);
        return o;
      }
      function Ny(s, e) {
        return We(s.prev, s, e.prev) < 0 && We(e.next, s, s.next) < 0;
      }
      function Gy(s, e, t, n) {
        let i = s;
        do
          i.z === null && (i.z = Da(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
        while (i !== s);
        (i.prevZ.nextZ = null), (i.prevZ = null), Oy(i);
      }
      function Oy(s) {
        let e,
          t,
          n,
          i,
          r,
          o,
          a,
          c,
          l = 1;
        do {
          for (t = s, s = null, r = null, o = 0; t; ) {
            for (
              o++, n = t, a = 0, e = 0;
              e < l && (a++, (n = n.nextZ), !!n);
              e++
            );
            for (c = l; a > 0 || (c > 0 && n); )
              a !== 0 && (c === 0 || !n || t.z <= n.z)
                ? ((i = t), (t = t.nextZ), a--)
                : ((i = n), (n = n.nextZ), c--),
                r ? (r.nextZ = i) : (s = i),
                (i.prevZ = r),
                (r = i);
            t = n;
          }
          (r.nextZ = null), (l *= 2);
        } while (o > 1);
        return s;
      }
      function Da(s, e, t, n, i) {
        return (
          (s = 32767 * (s - t) * i),
          (e = 32767 * (e - n) * i),
          (s = (s | (s << 8)) & 16711935),
          (s = (s | (s << 4)) & 252645135),
          (s = (s | (s << 2)) & 858993459),
          (s = (s | (s << 1)) & 1431655765),
          (e = (e | (e << 8)) & 16711935),
          (e = (e | (e << 4)) & 252645135),
          (e = (e | (e << 2)) & 858993459),
          (e = (e | (e << 1)) & 1431655765),
          s | (e << 1)
        );
      }
      function Uy(s) {
        let e = s,
          t = s;
        do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
        while (e !== s);
        return t;
      }
      function Ai(s, e, t, n, i, r, o, a) {
        return (
          (i - o) * (e - a) - (s - o) * (r - a) >= 0 &&
          (s - o) * (n - a) - (t - o) * (e - a) >= 0 &&
          (t - o) * (r - a) - (i - o) * (n - a) >= 0
        );
      }
      function zy(s, e) {
        return (
          s.next.i !== e.i &&
          s.prev.i !== e.i &&
          !Hy(s, e) &&
          ((Er(s, e) &&
            Er(e, s) &&
            ky(s, e) &&
            (We(s.prev, s, e.prev) || We(s, e.prev, e))) ||
            (xo(s, e) &&
              We(s.prev, s, s.next) > 0 &&
              We(e.prev, e, e.next) > 0))
        );
      }
      function We(s, e, t) {
        return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
      }
      function xo(s, e) {
        return s.x === e.x && s.y === e.y;
      }
      function bd(s, e, t, n) {
        const i = Ls(We(s, e, t)),
          r = Ls(We(s, e, n)),
          o = Ls(We(t, n, s)),
          a = Ls(We(t, n, e));
        return !!(
          (i !== r && o !== a) ||
          (i === 0 && As(s, t, e)) ||
          (r === 0 && As(s, n, e)) ||
          (o === 0 && As(t, s, n)) ||
          (a === 0 && As(t, e, n))
        );
      }
      function As(s, e, t) {
        return (
          e.x <= Math.max(s.x, t.x) &&
          e.x >= Math.min(s.x, t.x) &&
          e.y <= Math.max(s.y, t.y) &&
          e.y >= Math.min(s.y, t.y)
        );
      }
      function Ls(s) {
        return s > 0 ? 1 : s < 0 ? -1 : 0;
      }
      function Hy(s, e) {
        let t = s;
        do {
          if (
            t.i !== s.i &&
            t.next.i !== s.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            bd(t, t.next, s, e)
          )
            return !0;
          t = t.next;
        } while (t !== s);
        return !1;
      }
      function Er(s, e) {
        return We(s.prev, s, s.next) < 0
          ? We(s, e, s.next) >= 0 && We(s, s.prev, e) >= 0
          : We(s, e, s.prev) < 0 || We(s, s.next, e) < 0;
      }
      function ky(s, e) {
        let t = s,
          n = !1;
        const i = (s.x + e.x) / 2,
          r = (s.y + e.y) / 2;
        do
          t.y > r != t.next.y > r &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
        while (t !== s);
        return n;
      }
      function Sd(s, e) {
        const t = new Fa(s.i, s.x, s.y),
          n = new Fa(e.i, e.x, e.y),
          i = s.next,
          r = e.prev;
        return (
          (s.next = e),
          (e.prev = s),
          (t.next = i),
          (i.prev = t),
          (n.next = t),
          (t.prev = n),
          (r.next = n),
          (n.prev = r),
          n
        );
      }
      function Pc(s, e, t, n) {
        const i = new Fa(s, e, t);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function Ar(s) {
        (s.next.prev = s.prev),
          (s.prev.next = s.next),
          s.prevZ && (s.prevZ.nextZ = s.nextZ),
          s.nextZ && (s.nextZ.prevZ = s.prevZ);
      }
      function Fa(s, e, t) {
        (this.i = s),
          (this.x = e),
          (this.y = t),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function Vy(s, e, t, n) {
        let i = 0;
        for (let r = e, o = t - n; r < t; r += n)
          (i += (s[o] - s[r]) * (s[r + 1] + s[o + 1])), (o = r);
        return i;
      }
      class qt {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return n * 0.5;
        }
        static isClockWise(e) {
          return qt.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          Ic(e), Dc(n, e);
          let o = e.length;
          t.forEach(Ic);
          for (let c = 0; c < t.length; c++)
            i.push(o), (o += t[c].length), Dc(n, t[c]);
          const a = Ay.triangulate(n, i);
          for (let c = 0; c < a.length; c += 3) r.push(a.slice(c, c + 3));
          return r;
        }
      }
      function Ic(s) {
        const e = s.length;
        e > 2 && s[e - 1].equals(s[0]) && s.pop();
      }
      function Dc(s, e) {
        for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
      }
      class an extends de {
        constructor(e, t) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            r = [];
          for (let a = 0, c = e.length; a < c; a++) {
            const l = e[a];
            o(l);
          }
          this.setAttribute("position", new le(i, 3)),
            this.setAttribute("uv", new le(r, 2)),
            this.computeVertexNormals();
          function o(a) {
            const c = [],
              l = t.curveSegments !== void 0 ? t.curveSegments : 12,
              u = t.steps !== void 0 ? t.steps : 1;
            let h = t.depth !== void 0 ? t.depth : 100,
              d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
              f = t.bevelThickness !== void 0 ? t.bevelThickness : 6,
              p = t.bevelSize !== void 0 ? t.bevelSize : f - 2,
              x = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
              y = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const m = t.extrudePath,
              g = t.UVGenerator !== void 0 ? t.UVGenerator : Wy;
            t.amount !== void 0 &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (h = t.amount));
            let _,
              w = !1,
              T,
              v,
              A,
              L;
            m &&
              ((_ = m.getSpacedPoints(u)),
              (w = !0),
              (d = !1),
              (T = m.computeFrenetFrames(u, !1)),
              (v = new M()),
              (A = new M()),
              (L = new M())),
              d || ((y = 0), (f = 0), (p = 0), (x = 0));
            const I = a.extractPoints(l);
            let N = I.shape;
            const U = I.holes;
            if (!qt.isClockWise(N)) {
              N = N.reverse();
              for (let X = 0, Z = U.length; X < Z; X++) {
                const $ = U[X];
                qt.isClockWise($) && (U[X] = $.reverse());
              }
            }
            const R = qt.triangulateShape(N, U),
              D = N;
            for (let X = 0, Z = U.length; X < Z; X++) {
              const $ = U[X];
              N = N.concat($);
            }
            function F(X, Z, $) {
              return (
                Z || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Z.clone().multiplyScalar($).add(X)
              );
            }
            const C = N.length,
              V = R.length;
            function te(X, Z, $) {
              let he, se, E;
              const S = X.x - Z.x,
                H = X.y - Z.y,
                Y = $.x - X.x,
                ne = $.y - X.y,
                ae = S * S + H * H,
                ye = S * ne - H * Y;
              if (Math.abs(ye) > Number.EPSILON) {
                const ge = Math.sqrt(ae),
                  Se = Math.sqrt(Y * Y + ne * ne),
                  ue = Z.x - H / ge,
                  P = Z.y + S / ge,
                  j = $.x - ne / Se,
                  W = $.y + Y / Se,
                  fe = ((j - ue) * ne - (W - P) * Y) / (S * ne - H * Y);
                (he = ue + S * fe - X.x), (se = P + H * fe - X.y);
                const ie = he * he + se * se;
                if (ie <= 2) return new q(he, se);
                E = Math.sqrt(ie / 2);
              } else {
                let ge = !1;
                S > Number.EPSILON
                  ? Y > Number.EPSILON && (ge = !0)
                  : S < -Number.EPSILON
                  ? Y < -Number.EPSILON && (ge = !0)
                  : Math.sign(H) === Math.sign(ne) && (ge = !0),
                  ge
                    ? ((he = -H), (se = S), (E = Math.sqrt(ae)))
                    : ((he = S), (se = H), (E = Math.sqrt(ae / 2)));
              }
              return new q(he / E, se / E);
            }
            const J = [];
            for (
              let X = 0, Z = D.length, $ = Z - 1, he = X + 1;
              X < Z;
              X++, $++, he++
            )
              $ === Z && ($ = 0),
                he === Z && (he = 0),
                (J[X] = te(D[X], D[$], D[he]));
            const oe = [];
            let re,
              we = J.concat();
            for (let X = 0, Z = U.length; X < Z; X++) {
              const $ = U[X];
              re = [];
              for (
                let he = 0, se = $.length, E = se - 1, S = he + 1;
                he < se;
                he++, E++, S++
              )
                E === se && (E = 0),
                  S === se && (S = 0),
                  (re[he] = te($[he], $[E], $[S]));
              oe.push(re), (we = we.concat(re));
            }
            for (let X = 0; X < y; X++) {
              const Z = X / y,
                $ = f * Math.cos((Z * Math.PI) / 2),
                he = p * Math.sin((Z * Math.PI) / 2) + x;
              for (let se = 0, E = D.length; se < E; se++) {
                const S = F(D[se], J[se], he);
                Ve(S.x, S.y, -$);
              }
              for (let se = 0, E = U.length; se < E; se++) {
                const S = U[se];
                re = oe[se];
                for (let H = 0, Y = S.length; H < Y; H++) {
                  const ne = F(S[H], re[H], he);
                  Ve(ne.x, ne.y, -$);
                }
              }
            }
            const _e = p + x;
            for (let X = 0; X < C; X++) {
              const Z = d ? F(N[X], we[X], _e) : N[X];
              w
                ? (A.copy(T.normals[0]).multiplyScalar(Z.x),
                  v.copy(T.binormals[0]).multiplyScalar(Z.y),
                  L.copy(_[0]).add(A).add(v),
                  Ve(L.x, L.y, L.z))
                : Ve(Z.x, Z.y, 0);
            }
            for (let X = 1; X <= u; X++)
              for (let Z = 0; Z < C; Z++) {
                const $ = d ? F(N[Z], we[Z], _e) : N[Z];
                w
                  ? (A.copy(T.normals[X]).multiplyScalar($.x),
                    v.copy(T.binormals[X]).multiplyScalar($.y),
                    L.copy(_[X]).add(A).add(v),
                    Ve(L.x, L.y, L.z))
                  : Ve($.x, $.y, (h / u) * X);
              }
            for (let X = y - 1; X >= 0; X--) {
              const Z = X / y,
                $ = f * Math.cos((Z * Math.PI) / 2),
                he = p * Math.sin((Z * Math.PI) / 2) + x;
              for (let se = 0, E = D.length; se < E; se++) {
                const S = F(D[se], J[se], he);
                Ve(S.x, S.y, h + $);
              }
              for (let se = 0, E = U.length; se < E; se++) {
                const S = U[se];
                re = oe[se];
                for (let H = 0, Y = S.length; H < Y; H++) {
                  const ne = F(S[H], re[H], he);
                  w
                    ? Ve(ne.x, ne.y + _[u - 1].y, _[u - 1].x + $)
                    : Ve(ne.x, ne.y, h + $);
                }
              }
            }
            Be(), Ce();
            function Be() {
              const X = i.length / 3;
              if (d) {
                let Z = 0,
                  $ = C * Z;
                for (let he = 0; he < V; he++) {
                  const se = R[he];
                  Pe(se[2] + $, se[1] + $, se[0] + $);
                }
                (Z = u + y * 2), ($ = C * Z);
                for (let he = 0; he < V; he++) {
                  const se = R[he];
                  Pe(se[0] + $, se[1] + $, se[2] + $);
                }
              } else {
                for (let Z = 0; Z < V; Z++) {
                  const $ = R[Z];
                  Pe($[2], $[1], $[0]);
                }
                for (let Z = 0; Z < V; Z++) {
                  const $ = R[Z];
                  Pe($[0] + C * u, $[1] + C * u, $[2] + C * u);
                }
              }
              n.addGroup(X, i.length / 3 - X, 0);
            }
            function Ce() {
              const X = i.length / 3;
              let Z = 0;
              k(D, Z), (Z += D.length);
              for (let $ = 0, he = U.length; $ < he; $++) {
                const se = U[$];
                k(se, Z), (Z += se.length);
              }
              n.addGroup(X, i.length / 3 - X, 1);
            }
            function k(X, Z) {
              let $ = X.length;
              for (; --$ >= 0; ) {
                const he = $;
                let se = $ - 1;
                se < 0 && (se = X.length - 1);
                for (let E = 0, S = u + y * 2; E < S; E++) {
                  const H = C * E,
                    Y = C * (E + 1),
                    ne = Z + he + H,
                    ae = Z + se + H,
                    ye = Z + se + Y,
                    ge = Z + he + Y;
                  Me(ne, ae, ye, ge);
                }
              }
            }
            function Ve(X, Z, $) {
              c.push(X), c.push(Z), c.push($);
            }
            function Pe(X, Z, $) {
              me(X), me(Z), me($);
              const he = i.length / 3,
                se = g.generateTopUV(n, i, he - 3, he - 2, he - 1);
              Le(se[0]), Le(se[1]), Le(se[2]);
            }
            function Me(X, Z, $, he) {
              me(X), me(Z), me(he), me(Z), me($), me(he);
              const se = i.length / 3,
                E = g.generateSideWallUV(n, i, se - 6, se - 3, se - 2, se - 1);
              Le(E[0]), Le(E[1]), Le(E[3]), Le(E[1]), Le(E[2]), Le(E[3]);
            }
            function me(X) {
              i.push(c[X * 3 + 0]), i.push(c[X * 3 + 1]), i.push(c[X * 3 + 2]);
            }
            function Le(X) {
              r.push(X.x), r.push(X.y);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
          return qy(t, n, e);
        }
      }
      const Wy = {
        generateTopUV: function (s, e, t, n, i) {
          const r = e[t * 3],
            o = e[t * 3 + 1],
            a = e[n * 3],
            c = e[n * 3 + 1],
            l = e[i * 3],
            u = e[i * 3 + 1];
          return [new q(r, o), new q(a, c), new q(l, u)];
        },
        generateSideWallUV: function (s, e, t, n, i, r) {
          const o = e[t * 3],
            a = e[t * 3 + 1],
            c = e[t * 3 + 2],
            l = e[n * 3],
            u = e[n * 3 + 1],
            h = e[n * 3 + 2],
            d = e[i * 3],
            f = e[i * 3 + 1],
            p = e[i * 3 + 2],
            x = e[r * 3],
            y = e[r * 3 + 1],
            m = e[r * 3 + 2];
          return Math.abs(a - u) < Math.abs(o - l)
            ? [
                new q(o, 1 - c),
                new q(l, 1 - h),
                new q(d, 1 - p),
                new q(x, 1 - m),
              ]
            : [
                new q(a, 1 - c),
                new q(u, 1 - h),
                new q(f, 1 - p),
                new q(y, 1 - m),
              ];
        },
      };
      function qy(s, e, t) {
        if (((t.shapes = []), Array.isArray(s)))
          for (let n = 0, i = s.length; n < i; n++) {
            const r = s[n];
            t.shapes.push(r.uuid);
          }
        else t.shapes.push(s.uuid);
        return (
          e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
          t
        );
      }
      class Ys extends Sn {
        constructor(e = 1, t = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = [
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              0,
              0,
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              n,
              0,
              -1,
              n,
              0,
              1,
              -n,
              0,
              -1,
              -n,
              0,
              1,
            ],
            r = [
              0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
              4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6,
              8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ];
          super(i, r, e, t),
            (this.type = "IcosahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
      }
      class Zs extends de {
        constructor(e, t = 12, n = 0, i = Math.PI * 2) {
          super(),
            (this.type = "LatheGeometry"),
            (this.parameters = {
              points: e,
              segments: t,
              phiStart: n,
              phiLength: i,
            }),
            (t = Math.floor(t)),
            (i = ut(i, 0, Math.PI * 2));
          const r = [],
            o = [],
            a = [],
            c = 1 / t,
            l = new M(),
            u = new q();
          for (let h = 0; h <= t; h++) {
            const d = n + h * c * i,
              f = Math.sin(d),
              p = Math.cos(d);
            for (let x = 0; x <= e.length - 1; x++)
              (l.x = e[x].x * f),
                (l.y = e[x].y),
                (l.z = e[x].x * p),
                o.push(l.x, l.y, l.z),
                (u.x = h / t),
                (u.y = x / (e.length - 1)),
                a.push(u.x, u.y);
          }
          for (let h = 0; h < t; h++)
            for (let d = 0; d < e.length - 1; d++) {
              const f = d + h * e.length,
                p = f,
                x = f + e.length,
                y = f + e.length + 1,
                m = f + 1;
              r.push(p, x, m), r.push(x, y, m);
            }
          if (
            (this.setIndex(r),
            this.setAttribute("position", new le(o, 3)),
            this.setAttribute("uv", new le(a, 2)),
            this.computeVertexNormals(),
            i === Math.PI * 2)
          ) {
            const h = this.attributes.normal.array,
              d = new M(),
              f = new M(),
              p = new M(),
              x = t * e.length * 3;
            for (let y = 0, m = 0; y < e.length; y++, m += 3)
              (d.x = h[m + 0]),
                (d.y = h[m + 1]),
                (d.z = h[m + 2]),
                (f.x = h[x + m + 0]),
                (f.y = h[x + m + 1]),
                (f.z = h[x + m + 2]),
                p.addVectors(d, f).normalize(),
                (h[m + 0] = h[x + m + 0] = p.x),
                (h[m + 1] = h[x + m + 1] = p.y),
                (h[m + 2] = h[x + m + 2] = p.z);
          }
        }
      }
      class Lr extends Sn {
        constructor(e = 1, t = 0) {
          const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            i = [
              0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1,
              4, 2,
            ];
          super(n, i, e, t),
            (this.type = "OctahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
      }
      class Js extends de {
        constructor(e, t, n) {
          super(),
            (this.type = "ParametricGeometry"),
            (this.parameters = { func: e, slices: t, stacks: n });
          const i = [],
            r = [],
            o = [],
            a = [],
            c = 1e-5,
            l = new M(),
            u = new M(),
            h = new M(),
            d = new M(),
            f = new M();
          e.length < 3 &&
            console.error(
              "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
            );
          const p = t + 1;
          for (let x = 0; x <= n; x++) {
            const y = x / n;
            for (let m = 0; m <= t; m++) {
              const g = m / t;
              e(g, y, u),
                r.push(u.x, u.y, u.z),
                g - c >= 0
                  ? (e(g - c, y, h), d.subVectors(u, h))
                  : (e(g + c, y, h), d.subVectors(h, u)),
                y - c >= 0
                  ? (e(g, y - c, h), f.subVectors(u, h))
                  : (e(g, y + c, h), f.subVectors(h, u)),
                l.crossVectors(d, f).normalize(),
                o.push(l.x, l.y, l.z),
                a.push(g, y);
            }
          }
          for (let x = 0; x < n; x++)
            for (let y = 0; y < t; y++) {
              const m = x * p + y,
                g = x * p + y + 1,
                _ = (x + 1) * p + y + 1,
                w = (x + 1) * p + y;
              i.push(m, g, w), i.push(g, _, w);
            }
          this.setIndex(i),
            this.setAttribute("position", new le(r, 3)),
            this.setAttribute("normal", new le(o, 3)),
            this.setAttribute("uv", new le(a, 2));
        }
      }
      class js extends de {
        constructor(e = 0.5, t = 1, n = 8, i = 1, r = 0, o = Math.PI * 2) {
          super(),
            (this.type = "RingGeometry"),
            (this.parameters = {
              innerRadius: e,
              outerRadius: t,
              thetaSegments: n,
              phiSegments: i,
              thetaStart: r,
              thetaLength: o,
            }),
            (n = Math.max(3, n)),
            (i = Math.max(1, i));
          const a = [],
            c = [],
            l = [],
            u = [];
          let h = e;
          const d = (t - e) / i,
            f = new M(),
            p = new q();
          for (let x = 0; x <= i; x++) {
            for (let y = 0; y <= n; y++) {
              const m = r + (y / n) * o;
              (f.x = h * Math.cos(m)),
                (f.y = h * Math.sin(m)),
                c.push(f.x, f.y, f.z),
                l.push(0, 0, 1),
                (p.x = (f.x / t + 1) / 2),
                (p.y = (f.y / t + 1) / 2),
                u.push(p.x, p.y);
            }
            h += d;
          }
          for (let x = 0; x < i; x++) {
            const y = x * (n + 1);
            for (let m = 0; m < n; m++) {
              const g = m + y,
                _ = g,
                w = g + n + 1,
                T = g + n + 2,
                v = g + 1;
              a.push(_, w, v), a.push(w, T, v);
            }
          }
          this.setIndex(a),
            this.setAttribute("position", new le(c, 3)),
            this.setAttribute("normal", new le(l, 3)),
            this.setAttribute("uv", new le(u, 2));
        }
      }
      class Rr extends de {
        constructor(e, t = 12) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            r = [],
            o = [];
          let a = 0,
            c = 0;
          if (Array.isArray(e) === !1) l(e);
          else
            for (let u = 0; u < e.length; u++)
              l(e[u]), this.addGroup(a, c, u), (a += c), (c = 0);
          this.setIndex(n),
            this.setAttribute("position", new le(i, 3)),
            this.setAttribute("normal", new le(r, 3)),
            this.setAttribute("uv", new le(o, 2));
          function l(u) {
            const h = i.length / 3,
              d = u.extractPoints(t);
            let f = d.shape;
            const p = d.holes;
            qt.isClockWise(f) === !1 && (f = f.reverse());
            for (let y = 0, m = p.length; y < m; y++) {
              const g = p[y];
              qt.isClockWise(g) === !0 && (p[y] = g.reverse());
            }
            const x = qt.triangulateShape(f, p);
            for (let y = 0, m = p.length; y < m; y++) {
              const g = p[y];
              f = f.concat(g);
            }
            for (let y = 0, m = f.length; y < m; y++) {
              const g = f[y];
              i.push(g.x, g.y, 0), r.push(0, 0, 1), o.push(g.x, g.y);
            }
            for (let y = 0, m = x.length; y < m; y++) {
              const g = x[y],
                _ = g[0] + h,
                w = g[1] + h,
                T = g[2] + h;
              n.push(_, w, T), (c += 3);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes;
          return Xy(t, e);
        }
      }
      function Xy(s, e) {
        if (((e.shapes = []), Array.isArray(s)))
          for (let t = 0, n = s.length; t < n; t++) {
            const i = s[t];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(s.uuid);
        return e;
      }
      class Cr extends de {
        constructor(
          e = 1,
          t = 8,
          n = 6,
          i = 0,
          r = Math.PI * 2,
          o = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: e,
              widthSegments: t,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: o,
              thetaLength: a,
            }),
            (t = Math.max(3, Math.floor(t))),
            (n = Math.max(2, Math.floor(n)));
          const c = Math.min(o + a, Math.PI);
          let l = 0;
          const u = [],
            h = new M(),
            d = new M(),
            f = [],
            p = [],
            x = [],
            y = [];
          for (let m = 0; m <= n; m++) {
            const g = [],
              _ = m / n;
            let w = 0;
            m == 0 && o == 0
              ? (w = 0.5 / t)
              : m == n && c == Math.PI && (w = -0.5 / t);
            for (let T = 0; T <= t; T++) {
              const v = T / t;
              (h.x = -e * Math.cos(i + v * r) * Math.sin(o + _ * a)),
                (h.y = e * Math.cos(o + _ * a)),
                (h.z = e * Math.sin(i + v * r) * Math.sin(o + _ * a)),
                p.push(h.x, h.y, h.z),
                d.copy(h).normalize(),
                x.push(d.x, d.y, d.z),
                y.push(v + w, 1 - _),
                g.push(l++);
            }
            u.push(g);
          }
          for (let m = 0; m < n; m++)
            for (let g = 0; g < t; g++) {
              const _ = u[m][g + 1],
                w = u[m][g],
                T = u[m + 1][g],
                v = u[m + 1][g + 1];
              (m !== 0 || o > 0) && f.push(_, w, v),
                (m !== n - 1 || c < Math.PI) && f.push(w, T, v);
            }
          this.setIndex(f),
            this.setAttribute("position", new le(p, 3)),
            this.setAttribute("normal", new le(x, 3)),
            this.setAttribute("uv", new le(y, 2));
        }
      }
      class Ks extends Sn {
        constructor(e = 1, t = 0) {
          const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(n, i, e, t),
            (this.type = "TetrahedronGeometry"),
            (this.parameters = { radius: e, detail: t });
        }
      }
      class $s extends an {
        constructor(e, t = {}) {
          const n = t.font;
          if (!(n && n.isFont))
            return (
              console.error(
                "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
              ),
              new de()
            );
          const i = n.generateShapes(e, t.size);
          (t.depth = t.height !== void 0 ? t.height : 50),
            t.bevelThickness === void 0 && (t.bevelThickness = 10),
            t.bevelSize === void 0 && (t.bevelSize = 8),
            t.bevelEnabled === void 0 && (t.bevelEnabled = !1),
            super(i, t),
            (this.type = "TextGeometry");
        }
      }
      class Qs extends de {
        constructor(e = 1, t = 0.4, n = 8, i = 6, r = Math.PI * 2) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const o = [],
            a = [],
            c = [],
            l = [],
            u = new M(),
            h = new M(),
            d = new M();
          for (let f = 0; f <= n; f++)
            for (let p = 0; p <= i; p++) {
              const x = (p / i) * r,
                y = (f / n) * Math.PI * 2;
              (h.x = (e + t * Math.cos(y)) * Math.cos(x)),
                (h.y = (e + t * Math.cos(y)) * Math.sin(x)),
                (h.z = t * Math.sin(y)),
                a.push(h.x, h.y, h.z),
                (u.x = e * Math.cos(x)),
                (u.y = e * Math.sin(x)),
                d.subVectors(h, u).normalize(),
                c.push(d.x, d.y, d.z),
                l.push(p / i),
                l.push(f / n);
            }
          for (let f = 1; f <= n; f++)
            for (let p = 1; p <= i; p++) {
              const x = (i + 1) * f + p - 1,
                y = (i + 1) * (f - 1) + p - 1,
                m = (i + 1) * (f - 1) + p,
                g = (i + 1) * f + p;
              o.push(x, y, g), o.push(y, m, g);
            }
          this.setIndex(o),
            this.setAttribute("position", new le(a, 3)),
            this.setAttribute("normal", new le(c, 3)),
            this.setAttribute("uv", new le(l, 2));
        }
      }
      class eo extends de {
        constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, o = 3) {
          super(),
            (this.type = "TorusKnotGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              tubularSegments: n,
              radialSegments: i,
              p: r,
              q: o,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const a = [],
            c = [],
            l = [],
            u = [],
            h = new M(),
            d = new M(),
            f = new M(),
            p = new M(),
            x = new M(),
            y = new M(),
            m = new M();
          for (let _ = 0; _ <= n; ++_) {
            const w = (_ / n) * r * Math.PI * 2;
            g(w, r, o, e, f),
              g(w + 0.01, r, o, e, p),
              y.subVectors(p, f),
              m.addVectors(p, f),
              x.crossVectors(y, m),
              m.crossVectors(x, y),
              x.normalize(),
              m.normalize();
            for (let T = 0; T <= i; ++T) {
              const v = (T / i) * Math.PI * 2,
                A = -t * Math.cos(v),
                L = t * Math.sin(v);
              (h.x = f.x + (A * m.x + L * x.x)),
                (h.y = f.y + (A * m.y + L * x.y)),
                (h.z = f.z + (A * m.z + L * x.z)),
                c.push(h.x, h.y, h.z),
                d.subVectors(h, f).normalize(),
                l.push(d.x, d.y, d.z),
                u.push(_ / n),
                u.push(T / i);
            }
          }
          for (let _ = 1; _ <= n; _++)
            for (let w = 1; w <= i; w++) {
              const T = (i + 1) * (_ - 1) + (w - 1),
                v = (i + 1) * _ + (w - 1),
                A = (i + 1) * _ + w,
                L = (i + 1) * (_ - 1) + w;
              a.push(T, v, L), a.push(v, A, L);
            }
          this.setIndex(a),
            this.setAttribute("position", new le(c, 3)),
            this.setAttribute("normal", new le(l, 3)),
            this.setAttribute("uv", new le(u, 2));
          function g(_, w, T, v, A) {
            const L = Math.cos(_),
              I = Math.sin(_),
              N = (T / w) * _,
              U = Math.cos(N);
            (A.x = v * (2 + U) * 0.5 * L),
              (A.y = v * (2 + U) * I * 0.5),
              (A.z = v * Math.sin(N) * 0.5);
          }
        }
      }
      class to extends de {
        constructor(e, t = 64, n = 1, i = 8, r = !1) {
          super(),
            (this.type = "TubeGeometry"),
            (this.parameters = {
              path: e,
              tubularSegments: t,
              radius: n,
              radialSegments: i,
              closed: r,
            });
          const o = e.computeFrenetFrames(t, r);
          (this.tangents = o.tangents),
            (this.normals = o.normals),
            (this.binormals = o.binormals);
          const a = new M(),
            c = new M(),
            l = new q();
          let u = new M();
          const h = [],
            d = [],
            f = [],
            p = [];
          x(),
            this.setIndex(p),
            this.setAttribute("position", new le(h, 3)),
            this.setAttribute("normal", new le(d, 3)),
            this.setAttribute("uv", new le(f, 2));
          function x() {
            for (let _ = 0; _ < t; _++) y(_);
            y(r === !1 ? t : 0), g(), m();
          }
          function y(_) {
            u = e.getPointAt(_ / t, u);
            const w = o.normals[_],
              T = o.binormals[_];
            for (let v = 0; v <= i; v++) {
              const A = (v / i) * Math.PI * 2,
                L = Math.sin(A),
                I = -Math.cos(A);
              (c.x = I * w.x + L * T.x),
                (c.y = I * w.y + L * T.y),
                (c.z = I * w.z + L * T.z),
                c.normalize(),
                d.push(c.x, c.y, c.z),
                (a.x = u.x + n * c.x),
                (a.y = u.y + n * c.y),
                (a.z = u.z + n * c.z),
                h.push(a.x, a.y, a.z);
            }
          }
          function m() {
            for (let _ = 1; _ <= t; _++)
              for (let w = 1; w <= i; w++) {
                const T = (i + 1) * (_ - 1) + (w - 1),
                  v = (i + 1) * _ + (w - 1),
                  A = (i + 1) * _ + w,
                  L = (i + 1) * (_ - 1) + w;
                p.push(T, v, L), p.push(v, A, L);
              }
          }
          function g() {
            for (let _ = 0; _ <= t; _++)
              for (let w = 0; w <= i; w++)
                (l.x = _ / t), (l.y = w / i), f.push(l.x, l.y);
          }
        }
        toJSON() {
          const e = super.toJSON();
          return (e.path = this.parameters.path.toJSON()), e;
        }
      }
      class sl extends de {
        constructor(e) {
          if (
            (super(), (this.type = "WireframeGeometry"), e.isGeometry === !0)
          ) {
            console.error(
              "THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
            return;
          }
          const t = [],
            n = [0, 0],
            i = {},
            r = new M();
          if (e.index !== null) {
            const o = e.attributes.position,
              a = e.index;
            let c = e.groups;
            c.length === 0 &&
              (c = [{ start: 0, count: a.count, materialIndex: 0 }]);
            for (let l = 0, u = c.length; l < u; ++l) {
              const h = c[l],
                d = h.start,
                f = h.count;
              for (let p = d, x = d + f; p < x; p += 3)
                for (let y = 0; y < 3; y++) {
                  const m = a.getX(p + y),
                    g = a.getX(p + ((y + 1) % 3));
                  (n[0] = Math.min(m, g)), (n[1] = Math.max(m, g));
                  const _ = n[0] + "," + n[1];
                  i[_] === void 0 && (i[_] = { index1: n[0], index2: n[1] });
                }
            }
            for (const l in i) {
              const u = i[l];
              r.fromBufferAttribute(o, u.index1),
                t.push(r.x, r.y, r.z),
                r.fromBufferAttribute(o, u.index2),
                t.push(r.x, r.y, r.z);
            }
          } else {
            const o = e.attributes.position;
            for (let a = 0, c = o.count / 3; a < c; a++)
              for (let l = 0; l < 3; l++) {
                const u = 3 * a + l;
                r.fromBufferAttribute(o, u), t.push(r.x, r.y, r.z);
                const h = 3 * a + ((l + 1) % 3);
                r.fromBufferAttribute(o, h), t.push(r.x, r.y, r.z);
              }
          }
          this.setAttribute("position", new le(t, 3));
        }
      }
      var yt = Object.freeze({
        __proto__: null,
        BoxGeometry: Qn,
        BoxBufferGeometry: Qn,
        CircleGeometry: Ws,
        CircleBufferGeometry: Ws,
        ConeGeometry: qs,
        ConeBufferGeometry: qs,
        CylinderGeometry: Oi,
        CylinderBufferGeometry: Oi,
        DodecahedronGeometry: Xs,
        DodecahedronBufferGeometry: Xs,
        EdgesGeometry: rl,
        ExtrudeGeometry: an,
        ExtrudeBufferGeometry: an,
        IcosahedronGeometry: Ys,
        IcosahedronBufferGeometry: Ys,
        LatheGeometry: Zs,
        LatheBufferGeometry: Zs,
        OctahedronGeometry: Lr,
        OctahedronBufferGeometry: Lr,
        ParametricGeometry: Js,
        ParametricBufferGeometry: Js,
        PlaneGeometry: Sr,
        PlaneBufferGeometry: Sr,
        PolyhedronGeometry: Sn,
        PolyhedronBufferGeometry: Sn,
        RingGeometry: js,
        RingBufferGeometry: js,
        ShapeGeometry: Rr,
        ShapeBufferGeometry: Rr,
        SphereGeometry: Cr,
        SphereBufferGeometry: Cr,
        TetrahedronGeometry: Ks,
        TetrahedronBufferGeometry: Ks,
        TextGeometry: $s,
        TextBufferGeometry: $s,
        TorusGeometry: Qs,
        TorusBufferGeometry: Qs,
        TorusKnotGeometry: eo,
        TorusKnotBufferGeometry: eo,
        TubeGeometry: to,
        TubeBufferGeometry: to,
        WireframeGeometry: sl,
      });
      class ol extends et {
        constructor(e) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new K(0)),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this;
        }
      }
      ol.prototype.isShadowMaterial = !0;
      class Ji extends sn {
        constructor(e) {
          super(e), (this.type = "RawShaderMaterial");
        }
      }
      Ji.prototype.isRawShaderMaterial = !0;
      class ii extends et {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new K(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new K(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = En),
            (this.normalScale = new q(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            (this.vertexTangents = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            (this.vertexTangents = e.vertexTangents),
            this
          );
        }
      }
      ii.prototype.isMeshStandardMaterial = !0;
      class qr extends ii {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new q(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, "ior", {
              get: function () {
                return (
                  (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
                );
              },
              set: function (t) {
                this.reflectivity = ut((2.5 * (t - 1)) / (t + 1), 0, 1);
              },
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            (this.thickness = 0.01),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new K(1, 1, 1)),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.reflectivity = e.reflectivity),
            e.sheen
              ? (this.sheen = (this.sheen || new K()).copy(e.sheen))
              : (this.sheen = null),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            this
          );
        }
      }
      qr.prototype.isMeshPhysicalMaterial = !0;
      class al extends et {
        constructor(e) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new K(16777215)),
            (this.specular = new K(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new K(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = En),
            (this.normalScale = new q(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Dr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      al.prototype.isMeshPhongMaterial = !0;
      class ll extends et {
        constructor(e) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new K(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new K(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = En),
            (this.normalScale = new q(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }
      }
      ll.prototype.isMeshToonMaterial = !0;
      class cl extends et {
        constructor(e) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = En),
            (this.normalScale = new q(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      cl.prototype.isMeshNormalMaterial = !0;
      class ul extends et {
        constructor(e) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new K(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new K(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Dr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }
      }
      ul.prototype.isMeshLambertMaterial = !0;
      class hl extends et {
        constructor(e) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new K(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = En),
            (this.normalScale = new q(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      hl.prototype.isMeshMatcapMaterial = !0;
      class dl extends st {
        constructor(e) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        }
      }
      dl.prototype.isLineDashedMaterial = !0;
      var Yy = Object.freeze({
        __proto__: null,
        ShadowMaterial: ol,
        SpriteMaterial: po,
        RawShaderMaterial: Ji,
        ShaderMaterial: sn,
        PointsMaterial: Cn,
        MeshPhysicalMaterial: qr,
        MeshStandardMaterial: ii,
        MeshPhongMaterial: al,
        MeshToonMaterial: ll,
        MeshNormalMaterial: cl,
        MeshLambertMaterial: ul,
        MeshDepthMaterial: ho,
        MeshDistanceMaterial: fo,
        MeshBasicMaterial: bt,
        MeshMatcapMaterial: hl,
        LineDashedMaterial: dl,
        LineBasicMaterial: st,
        Material: et,
      });
      const He = {
        arraySlice: function (s, e, t) {
          return He.isTypedArray(s)
            ? new s.constructor(s.subarray(e, t !== void 0 ? t : s.length))
            : s.slice(e, t);
        },
        convertArray: function (s, e, t) {
          return !s || (!t && s.constructor === e)
            ? s
            : typeof e.BYTES_PER_ELEMENT == "number"
            ? new e(s)
            : Array.prototype.slice.call(s);
        },
        isTypedArray: function (s) {
          return ArrayBuffer.isView(s) && !(s instanceof DataView);
        },
        getKeyframeOrder: function (s) {
          function e(i, r) {
            return s[i] - s[r];
          }
          const t = s.length,
            n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = i;
          return n.sort(e), n;
        },
        sortedArray: function (s, e, t) {
          const n = s.length,
            i = new s.constructor(n);
          for (let r = 0, o = 0; o !== n; ++r) {
            const a = t[r] * e;
            for (let c = 0; c !== e; ++c) i[o++] = s[a + c];
          }
          return i;
        },
        flattenJSON: function (s, e, t, n) {
          let i = 1,
            r = s[0];
          for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
          if (r === void 0) return;
          let o = r[n];
          if (o !== void 0)
            if (Array.isArray(o))
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push.apply(t, o)),
                  (r = s[i++]);
              while (r !== void 0);
            else if (o.toArray !== void 0)
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), o.toArray(t, t.length)),
                  (r = s[i++]);
              while (r !== void 0);
            else
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push(o)),
                  (r = s[i++]);
              while (r !== void 0);
        },
        subclip: function (s, e, t, n, i = 30) {
          const r = s.clone();
          r.name = e;
          const o = [];
          for (let c = 0; c < r.tracks.length; ++c) {
            const l = r.tracks[c],
              u = l.getValueSize(),
              h = [],
              d = [];
            for (let f = 0; f < l.times.length; ++f) {
              const p = l.times[f] * i;
              if (!(p < t || p >= n)) {
                h.push(l.times[f]);
                for (let x = 0; x < u; ++x) d.push(l.values[f * u + x]);
              }
            }
            h.length !== 0 &&
              ((l.times = He.convertArray(h, l.times.constructor)),
              (l.values = He.convertArray(d, l.values.constructor)),
              o.push(l));
          }
          r.tracks = o;
          let a = 1 / 0;
          for (let c = 0; c < r.tracks.length; ++c)
            a > r.tracks[c].times[0] && (a = r.tracks[c].times[0]);
          for (let c = 0; c < r.tracks.length; ++c) r.tracks[c].shift(-1 * a);
          return r.resetDuration(), r;
        },
        makeClipAdditive: function (s, e = 0, t = s, n = 30) {
          n <= 0 && (n = 30);
          const i = t.tracks.length,
            r = e / n;
          for (let o = 0; o < i; ++o) {
            const a = t.tracks[o],
              c = a.ValueTypeName;
            if (c === "bool" || c === "string") continue;
            const l = s.tracks.find(function (m) {
              return m.name === a.name && m.ValueTypeName === c;
            });
            if (l === void 0) continue;
            let u = 0;
            const h = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (u = h / 3);
            let d = 0;
            const f = l.getValueSize();
            l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (d = f / 3);
            const p = a.times.length - 1;
            let x;
            if (r <= a.times[0]) {
              const m = u,
                g = h - u;
              x = He.arraySlice(a.values, m, g);
            } else if (r >= a.times[p]) {
              const m = p * h + u,
                g = m + h - u;
              x = He.arraySlice(a.values, m, g);
            } else {
              const m = a.createInterpolant(),
                g = u,
                _ = h - u;
              m.evaluate(r), (x = He.arraySlice(m.resultBuffer, g, _));
            }
            c === "quaternion" &&
              new lt().fromArray(x).normalize().conjugate().toArray(x);
            const y = l.times.length;
            for (let m = 0; m < y; ++m) {
              const g = m * f + d;
              if (c === "quaternion")
                lt.multiplyQuaternionsFlat(l.values, g, x, 0, l.values, g);
              else {
                const _ = f - d * 2;
                for (let w = 0; w < _; ++w) l.values[g + w] -= x[w];
              }
            }
          }
          return (s.blendMode = qa), s;
        },
      };
      class Yt {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (i === void 0) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (!(e >= r)) {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let c = n - 2; ; ) {
                    if (r === void 0)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === c) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (o = n), (n = 0);
                  break n;
                }
                break e;
              }
              for (; n < o; ) {
                const a = (n + o) >>> 1;
                e < t[a] ? (o = a) : (n = a + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), r === void 0))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (i === void 0)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let o = 0; o !== i; ++o) t[o] = n[r + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      Yt.prototype.beforeStart_ = Yt.prototype.copySampleValue_;
      Yt.prototype.afterEnd_ = Yt.prototype.copySampleValue_;
      class Td extends Yt {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: qn, endingEnd: qn });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            o = e + 1,
            a = i[r],
            c = i[o];
          if (a === void 0)
            switch (this.getSettings_().endingStart) {
              case Xn:
                (r = e), (a = 2 * t - n);
                break;
              case wr:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (c === void 0)
            switch (this.getSettings_().endingEnd) {
              case Xn:
                (o = e), (c = 2 * n - t);
                break;
              case wr:
                (o = 1), (c = n + i[1] - i[0]);
                break;
              default:
                (o = e - 1), (c = t);
            }
          const l = (n - t) * 0.5,
            u = this.valueSize;
          (this._weightPrev = l / (t - a)),
            (this._weightNext = l / (c - n)),
            (this._offsetPrev = r * u),
            (this._offsetNext = o * u);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            c = e * a,
            l = c - a,
            u = this._offsetPrev,
            h = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            p = (n - t) / (i - t),
            x = p * p,
            y = x * p,
            m = -d * y + 2 * d * x - d * p,
            g = (1 + d) * y + (-1.5 - 2 * d) * x + (-0.5 + d) * p + 1,
            _ = (-1 - f) * y + (1.5 + f) * x + 0.5 * p,
            w = f * y - f * x;
          for (let T = 0; T !== a; ++T)
            r[T] = m * o[u + T] + g * o[l + T] + _ * o[c + T] + w * o[h + T];
          return r;
        }
      }
      class fl extends Yt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            c = e * a,
            l = c - a,
            u = (n - t) / (i - t),
            h = 1 - u;
          for (let d = 0; d !== a; ++d) r[d] = o[l + d] * h + o[c + d] * u;
          return r;
        }
      }
      class Ed extends Yt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class zt {
        constructor(e, t, n, i) {
          if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = He.convertArray(t, this.TimeBufferType)),
            (this.values = He.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: He.convertArray(e.times, Array),
              values: He.convertArray(e.values, Array),
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new Ed(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new fl(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new Td(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Di:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case Kn:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Us:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Di;
            case this.InterpolantFactoryMethodLinear:
              return Kn;
            case this.InterpolantFactoryMethodSmooth:
              return Us;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            o = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; o !== -1 && n[o] > t; ) --o;
          if ((++o, r !== 0 || o !== i)) {
            r >= o && ((o = Math.max(o, 1)), (r = o - 1));
            const a = this.getValueSize();
            (this.times = He.arraySlice(n, r, o)),
              (this.values = He.arraySlice(this.values, r * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          r === 0 &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== r; a++) {
            const c = n[a];
            if (typeof c == "number" && isNaN(c)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                c
              ),
                (e = !1);
              break;
            }
            if (o !== null && o > c) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                c,
                o
              ),
                (e = !1);
              break;
            }
            o = c;
          }
          if (i !== void 0 && He.isTypedArray(i))
            for (let a = 0, c = i.length; a !== c; ++a) {
              const l = i[a];
              if (isNaN(l)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  l
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = He.arraySlice(this.times),
            t = He.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === Us,
            r = e.length - 1;
          let o = 1;
          for (let a = 1; a < r; ++a) {
            let c = !1;
            const l = e[a],
              u = e[a + 1];
            if (l !== u && (a !== 1 || l !== e[0]))
              if (i) c = !0;
              else {
                const h = a * n,
                  d = h - n,
                  f = h + n;
                for (let p = 0; p !== n; ++p) {
                  const x = t[h + p];
                  if (x !== t[d + p] || x !== t[f + p]) {
                    c = !0;
                    break;
                  }
                }
              }
            if (c) {
              if (a !== o) {
                e[o] = e[a];
                const h = a * n,
                  d = o * n;
                for (let f = 0; f !== n; ++f) t[d + f] = t[h + f];
              }
              ++o;
            }
          }
          if (r > 0) {
            e[o] = e[r];
            for (let a = r * n, c = o * n, l = 0; l !== n; ++l)
              t[c + l] = t[a + l];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = He.arraySlice(e, 0, o)),
                (this.values = He.arraySlice(t, 0, o * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = He.arraySlice(this.times, 0),
            t = He.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, e, t);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      zt.prototype.TimeBufferType = Float32Array;
      zt.prototype.ValueBufferType = Float32Array;
      zt.prototype.DefaultInterpolation = Kn;
      class ri extends zt {}
      ri.prototype.ValueTypeName = "bool";
      ri.prototype.ValueBufferType = Array;
      ri.prototype.DefaultInterpolation = Di;
      ri.prototype.InterpolantFactoryMethodLinear = void 0;
      ri.prototype.InterpolantFactoryMethodSmooth = void 0;
      class pl extends zt {}
      pl.prototype.ValueTypeName = "color";
      class Ui extends zt {}
      Ui.prototype.ValueTypeName = "number";
      class Ad extends Yt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            c = (n - t) / (i - t);
          let l = e * a;
          for (let u = l + a; l !== u; l += 4)
            lt.slerpFlat(r, 0, o, l - a, o, l, c);
          return r;
        }
      }
      class si extends zt {
        InterpolantFactoryMethodLinear(e) {
          return new Ad(this.times, this.values, this.getValueSize(), e);
        }
      }
      si.prototype.ValueTypeName = "quaternion";
      si.prototype.DefaultInterpolation = Kn;
      si.prototype.InterpolantFactoryMethodSmooth = void 0;
      class oi extends zt {}
      oi.prototype.ValueTypeName = "string";
      oi.prototype.ValueBufferType = Array;
      oi.prototype.DefaultInterpolation = Di;
      oi.prototype.InterpolantFactoryMethodLinear = void 0;
      oi.prototype.InterpolantFactoryMethodSmooth = void 0;
      class zi extends zt {}
      zi.prototype.ValueTypeName = "vector";
      class Hi {
        constructor(e, t = -1, n, i = ro) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = At()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let o = 0, a = n.length; o !== a; ++o) t.push(Jy(n[o]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let r = 0, o = n.length; r !== o; ++r) t.push(zt.toJSON(n[r]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            o = [];
          for (let a = 0; a < r; a++) {
            let c = [],
              l = [];
            c.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
            const u = He.getKeyframeOrder(c);
            (c = He.sortedArray(c, 1, u)),
              (l = He.sortedArray(l, 1, u)),
              !i && c[0] === 0 && (c.push(r), l.push(l[0])),
              o.push(
                new Ui(".morphTargetInfluences[" + t[a].name + "]", c, l).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, o);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, c = e.length; a < c; a++) {
            const l = e[a],
              u = l.name.match(r);
            if (u && u.length > 1) {
              const h = u[1];
              let d = i[h];
              d || (i[h] = d = []), d.push(l);
            }
          }
          const o = [];
          for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
          return o;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (h, d, f, p, x) {
              if (f.length !== 0) {
                const y = [],
                  m = [];
                He.flattenJSON(f, y, m, p),
                  y.length !== 0 && x.push(new h(d, y, m));
              }
            },
            i = [],
            r = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
          let c = e.length || -1;
          const l = e.hierarchy || [];
          for (let h = 0; h < l.length; h++) {
            const d = l[h].keys;
            if (!(!d || d.length === 0))
              if (d[0].morphTargets) {
                const f = {};
                let p;
                for (p = 0; p < d.length; p++)
                  if (d[p].morphTargets)
                    for (let x = 0; x < d[p].morphTargets.length; x++)
                      f[d[p].morphTargets[x]] = -1;
                for (const x in f) {
                  const y = [],
                    m = [];
                  for (let g = 0; g !== d[p].morphTargets.length; ++g) {
                    const _ = d[p];
                    y.push(_.time), m.push(_.morphTarget === x ? 1 : 0);
                  }
                  i.push(new Ui(".morphTargetInfluence[" + x + "]", y, m));
                }
                c = f.length * (o || 1);
              } else {
                const f = ".bones[" + t[h].name + "]";
                n(zi, f + ".position", d, "pos", i),
                  n(si, f + ".quaternion", d, "rot", i),
                  n(zi, f + ".scale", d, "scl", i);
              }
          }
          return i.length === 0 ? null : new this(r, c, i, a);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Zy(s) {
        switch (s.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Ui;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return zi;
          case "color":
            return pl;
          case "quaternion":
            return si;
          case "bool":
          case "boolean":
            return ri;
          case "string":
            return oi;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
      }
      function Jy(s) {
        if (s.type === void 0)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = Zy(s.type);
        if (s.times === void 0) {
          const t = [],
            n = [];
          He.flattenJSON(s.keys, t, n, "value"), (s.times = t), (s.values = n);
        }
        return e.parse !== void 0
          ? e.parse(s)
          : new e(s.name, s.times, s.values, s.interpolation);
      }
      const ei = {
        enabled: !1,
        files: {},
        add: function (s, e) {
          this.enabled !== !1 && (this.files[s] = e);
        },
        get: function (s) {
          if (this.enabled !== !1) return this.files[s];
        },
        remove: function (s) {
          delete this.files[s];
        },
        clear: function () {
          this.files = {};
        },
      };
      class ml {
        constructor(e, t, n) {
          const i = this;
          let r = !1,
            o = 0,
            a = 0,
            c;
          const l = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (u) {
              a++,
                r === !1 && i.onStart !== void 0 && i.onStart(u, o, a),
                (r = !0);
            }),
            (this.itemEnd = function (u) {
              o++,
                i.onProgress !== void 0 && i.onProgress(u, o, a),
                o === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
            }),
            (this.itemError = function (u) {
              i.onError !== void 0 && i.onError(u);
            }),
            (this.resolveURL = function (u) {
              return c ? c(u) : u;
            }),
            (this.setURLModifier = function (u) {
              return (c = u), this;
            }),
            (this.addHandler = function (u, h) {
              return l.push(u, h), this;
            }),
            (this.removeHandler = function (u) {
              const h = l.indexOf(u);
              return h !== -1 && l.splice(h, 2), this;
            }),
            (this.getHandler = function (u) {
              for (let h = 0, d = l.length; h < d; h += 2) {
                const f = l[h],
                  p = l[h + 1];
                if ((f.global && (f.lastIndex = 0), f.test(u))) return p;
              }
              return null;
            });
        }
      }
      const Ld = new ml();
      class ht {
        constructor(e) {
          (this.manager = e !== void 0 ? e : Ld),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      const Bt = {};
      class Ct extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = ei.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          if (Bt[e] !== void 0) {
            Bt[e].push({ onLoad: t, onProgress: n, onError: i });
            return;
          }
          const a = /^data:(.*?)(;base64)?,(.*)$/,
            c = e.match(a);
          let l;
          if (c) {
            const u = c[1],
              h = !!c[2];
            let d = c[3];
            (d = decodeURIComponent(d)), h && (d = atob(d));
            try {
              let f;
              const p = (this.responseType || "").toLowerCase();
              switch (p) {
                case "arraybuffer":
                case "blob":
                  const x = new Uint8Array(d.length);
                  for (let m = 0; m < d.length; m++) x[m] = d.charCodeAt(m);
                  p === "blob"
                    ? (f = new Blob([x.buffer], { type: u }))
                    : (f = x.buffer);
                  break;
                case "document":
                  f = new DOMParser().parseFromString(d, u);
                  break;
                case "json":
                  f = JSON.parse(d);
                  break;
                default:
                  f = d;
                  break;
              }
              setTimeout(function () {
                t && t(f), r.manager.itemEnd(e);
              }, 0);
            } catch (f) {
              setTimeout(function () {
                i && i(f), r.manager.itemError(e), r.manager.itemEnd(e);
              }, 0);
            }
          } else {
            (Bt[e] = []),
              Bt[e].push({ onLoad: t, onProgress: n, onError: i }),
              (l = new XMLHttpRequest()),
              l.open("GET", e, !0),
              l.addEventListener(
                "load",
                function (u) {
                  const h = this.response,
                    d = Bt[e];
                  if (
                    (delete Bt[e], this.status === 200 || this.status === 0)
                  ) {
                    this.status === 0 &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                      ei.add(e, h);
                    for (let f = 0, p = d.length; f < p; f++) {
                      const x = d[f];
                      x.onLoad && x.onLoad(h);
                    }
                    r.manager.itemEnd(e);
                  } else {
                    for (let f = 0, p = d.length; f < p; f++) {
                      const x = d[f];
                      x.onError && x.onError(u);
                    }
                    r.manager.itemError(e), r.manager.itemEnd(e);
                  }
                },
                !1
              ),
              l.addEventListener(
                "progress",
                function (u) {
                  const h = Bt[e];
                  for (let d = 0, f = h.length; d < f; d++) {
                    const p = h[d];
                    p.onProgress && p.onProgress(u);
                  }
                },
                !1
              ),
              l.addEventListener(
                "error",
                function (u) {
                  const h = Bt[e];
                  delete Bt[e];
                  for (let d = 0, f = h.length; d < f; d++) {
                    const p = h[d];
                    p.onError && p.onError(u);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              l.addEventListener(
                "abort",
                function (u) {
                  const h = Bt[e];
                  delete Bt[e];
                  for (let d = 0, f = h.length; d < f; d++) {
                    const p = h[d];
                    p.onError && p.onError(u);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              this.responseType !== void 0 &&
                (l.responseType = this.responseType),
              this.withCredentials !== void 0 &&
                (l.withCredentials = this.withCredentials),
              l.overrideMimeType &&
                l.overrideMimeType(
                  this.mimeType !== void 0 ? this.mimeType : "text/plain"
                );
            for (const u in this.requestHeader)
              l.setRequestHeader(u, this.requestHeader[u]);
            l.send(null);
          }
          return r.manager.itemStart(e), l;
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class jy extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new Ct(this.manager);
          o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  t(r.parse(JSON.parse(a)));
                } catch (c) {
                  i ? i(c) : console.error(c), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e) {
          const t = [];
          for (let n = 0; n < e.length; n++) {
            const i = Hi.parse(e[n]);
            t.push(i);
          }
          return t;
        }
      }
      class Ky extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = [],
            a = new nl(),
            c = new Ct(this.manager);
          c.setPath(this.path),
            c.setResponseType("arraybuffer"),
            c.setRequestHeader(this.requestHeader),
            c.setWithCredentials(r.withCredentials);
          let l = 0;
          function u(h) {
            c.load(
              e[h],
              function (d) {
                const f = r.parse(d, !0);
                (o[h] = {
                  width: f.width,
                  height: f.height,
                  format: f.format,
                  mipmaps: f.mipmaps,
                }),
                  (l += 1),
                  l === 6 &&
                    (f.mipmapCount === 1 && (a.minFilter = Ke),
                    (a.image = o),
                    (a.format = f.format),
                    (a.needsUpdate = !0),
                    t && t(a));
              },
              n,
              i
            );
          }
          if (Array.isArray(e)) for (let h = 0, d = e.length; h < d; ++h) u(h);
          else
            c.load(
              e,
              function (h) {
                const d = r.parse(h, !0);
                if (d.isCubemap) {
                  const f = d.mipmaps.length / d.mipmapCount;
                  for (let p = 0; p < f; p++) {
                    o[p] = { mipmaps: [] };
                    for (let x = 0; x < d.mipmapCount; x++)
                      o[p].mipmaps.push(d.mipmaps[p * d.mipmapCount + x]),
                        (o[p].format = d.format),
                        (o[p].width = d.width),
                        (o[p].height = d.height);
                  }
                  a.image = o;
                } else
                  (a.image.width = d.width),
                    (a.image.height = d.height),
                    (a.mipmaps = d.mipmaps);
                d.mipmapCount === 1 && (a.minFilter = Ke),
                  (a.format = d.format),
                  (a.needsUpdate = !0),
                  t && t(a);
              },
              n,
              i
            );
          return a;
        }
      }
      class yo extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = ei.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function c() {
            a.removeEventListener("load", c, !1),
              a.removeEventListener("error", l, !1),
              ei.add(e, this),
              t && t(this),
              r.manager.itemEnd(e);
          }
          function l(u) {
            a.removeEventListener("load", c, !1),
              a.removeEventListener("error", l, !1),
              i && i(u),
              r.manager.itemError(e),
              r.manager.itemEnd(e);
          }
          return (
            a.addEventListener("load", c, !1),
            a.addEventListener("error", l, !1),
            e.substr(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class Rd extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Xi(),
            o = new yo(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let a = 0;
          function c(l) {
            o.load(
              e[l],
              function (u) {
                (r.images[l] = u),
                  a++,
                  a === 6 && ((r.needsUpdate = !0), t && t(r));
              },
              void 0,
              i
            );
          }
          for (let l = 0; l < e.length; ++l) c(l);
          return r;
        }
      }
      class Cd extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new Gi(),
            a = new Ct(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (c) {
                const l = r.parse(c);
                !l ||
                  (l.image !== void 0
                    ? (o.image = l.image)
                    : l.data !== void 0 &&
                      ((o.image.width = l.width),
                      (o.image.height = l.height),
                      (o.image.data = l.data)),
                  (o.wrapS = l.wrapS !== void 0 ? l.wrapS : at),
                  (o.wrapT = l.wrapT !== void 0 ? l.wrapT : at),
                  (o.magFilter = l.magFilter !== void 0 ? l.magFilter : Ke),
                  (o.minFilter = l.minFilter !== void 0 ? l.minFilter : Ke),
                  (o.anisotropy = l.anisotropy !== void 0 ? l.anisotropy : 1),
                  l.encoding !== void 0 && (o.encoding = l.encoding),
                  l.flipY !== void 0 && (o.flipY = l.flipY),
                  l.format !== void 0 && (o.format = l.format),
                  l.type !== void 0 && (o.type = l.type),
                  l.mipmaps !== void 0 &&
                    ((o.mipmaps = l.mipmaps), (o.minFilter = ln)),
                  l.mipmapCount === 1 && (o.minFilter = Ke),
                  l.generateMipmaps !== void 0 &&
                    (o.generateMipmaps = l.generateMipmaps),
                  (o.needsUpdate = !0),
                  t && t(o, l));
              },
              n,
              i
            ),
            o
          );
        }
      }
      class gl extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new rt(),
            o = new yo(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                r.image = a;
                const c =
                  e.search(/\.jpe?g($|\?)/i) > 0 ||
                  e.search(/^data\:image\/jpeg/) === 0;
                (r.format = c ? rn : Et),
                  (r.needsUpdate = !0),
                  t !== void 0 && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class Lt {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let o = 1; o <= e; o++)
            (n = this.getPoint(o / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let o;
          t ? (o = t) : (o = e * n[r - 1]);
          let a = 0,
            c = r - 1,
            l;
          for (; a <= c; )
            if (((i = Math.floor(a + (c - a) / 2)), (l = n[i] - o), l < 0))
              a = i + 1;
            else if (l > 0) c = i - 1;
            else {
              c = i;
              break;
            }
          if (((i = c), n[i] === o)) return i / (r - 1);
          const u = n[i],
            d = n[i + 1] - u,
            f = (o - u) / d;
          return (i + f) / (r - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4,
            r = e + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const o = this.getPoint(i),
            a = this.getPoint(r),
            c = t || (o.isVector2 ? new q() : new M());
          return c.copy(a).sub(o).normalize(), c;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new M(),
            i = [],
            r = [],
            o = [],
            a = new M(),
            c = new ce();
          for (let f = 0; f <= e; f++) {
            const p = f / e;
            (i[f] = this.getTangentAt(p, new M())), i[f].normalize();
          }
          (r[0] = new M()), (o[0] = new M());
          let l = Number.MAX_VALUE;
          const u = Math.abs(i[0].x),
            h = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
          u <= l && ((l = u), n.set(1, 0, 0)),
            h <= l && ((l = h), n.set(0, 1, 0)),
            d <= l && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], r[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((r[f] = r[f - 1].clone()),
              (o[f] = o[f - 1].clone()),
              a.crossVectors(i[f - 1], i[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const p = Math.acos(ut(i[f - 1].dot(i[f]), -1, 1));
              r[f].applyMatrix4(c.makeRotationAxis(a, p));
            }
            o[f].crossVectors(i[f], r[f]);
          }
          if (t === !0) {
            let f = Math.acos(ut(r[0].dot(r[e]), -1, 1));
            (f /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let p = 1; p <= e; p++)
              r[p].applyMatrix4(c.makeRotationAxis(i[p], f * p)),
                o[p].crossVectors(i[p], r[p]);
          }
          return { tangents: i, normals: r, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class Xr extends Lt {
        constructor(
          e = 0,
          t = 0,
          n = 1,
          i = 1,
          r = 0,
          o = Math.PI * 2,
          a = !1,
          c = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = o),
            (this.aClockwise = a),
            (this.aRotation = c);
        }
        getPoint(e, t) {
          const n = t || new q(),
            i = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const o = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (o ? (r = 0) : (r = i)),
            this.aClockwise === !0 && !o && (r === i ? (r = -i) : (r = r - i));
          const a = this.aStartAngle + e * r;
          let c = this.aX + this.xRadius * Math.cos(a),
            l = this.aY + this.yRadius * Math.sin(a);
          if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation),
              h = Math.sin(this.aRotation),
              d = c - this.aX,
              f = l - this.aY;
            (c = d * u - f * h + this.aX), (l = d * h + f * u + this.aY);
          }
          return n.set(c, l);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
      }
      Xr.prototype.isEllipseCurve = !0;
      class xl extends Xr {
        constructor(e, t, n, i, r, o) {
          super(e, t, n, n, i, r, o), (this.type = "ArcCurve");
        }
      }
      xl.prototype.isArcCurve = !0;
      function yl() {
        let s = 0,
          e = 0,
          t = 0,
          n = 0;
        function i(r, o, a, c) {
          (s = r),
            (e = a),
            (t = -3 * r + 3 * o - 2 * a - c),
            (n = 2 * r - 2 * o + a + c);
        }
        return {
          initCatmullRom: function (r, o, a, c, l) {
            i(o, a, l * (a - r), l * (c - o));
          },
          initNonuniformCatmullRom: function (r, o, a, c, l, u, h) {
            let d = (o - r) / l - (a - r) / (l + u) + (a - o) / u,
              f = (a - o) / u - (c - o) / (u + h) + (c - a) / h;
            (d *= u), (f *= u), i(o, a, d, f);
          },
          calc: function (r) {
            const o = r * r,
              a = o * r;
            return s + e * r + t * o + n * a;
          },
        };
      }
      const Rs = new M(),
        ta = new yl(),
        na = new yl(),
        ia = new yl();
      class vl extends Lt {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(e, t = new M()) {
          const n = t,
            i = this.points,
            r = i.length,
            o = (r - (this.closed ? 0 : 1)) * e;
          let a = Math.floor(o),
            c = o - a;
          this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r)
            : c === 0 && a === r - 1 && ((a = r - 2), (c = 1));
          let l, u;
          this.closed || a > 0
            ? (l = i[(a - 1) % r])
            : (Rs.subVectors(i[0], i[1]).add(i[0]), (l = Rs));
          const h = i[a % r],
            d = i[(a + 1) % r];
          if (
            (this.closed || a + 2 < r
              ? (u = i[(a + 2) % r])
              : (Rs.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (u = Rs)),
            this.curveType === "centripetal" || this.curveType === "chordal")
          ) {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let p = Math.pow(l.distanceToSquared(h), f),
              x = Math.pow(h.distanceToSquared(d), f),
              y = Math.pow(d.distanceToSquared(u), f);
            x < 1e-4 && (x = 1),
              p < 1e-4 && (p = x),
              y < 1e-4 && (y = x),
              ta.initNonuniformCatmullRom(l.x, h.x, d.x, u.x, p, x, y),
              na.initNonuniformCatmullRom(l.y, h.y, d.y, u.y, p, x, y),
              ia.initNonuniformCatmullRom(l.z, h.z, d.z, u.z, p, x, y);
          } else
            this.curveType === "catmullrom" &&
              (ta.initCatmullRom(l.x, h.x, d.x, u.x, this.tension),
              na.initCatmullRom(l.y, h.y, d.y, u.y, this.tension),
              ia.initCatmullRom(l.z, h.z, d.z, u.z, this.tension));
          return n.set(ta.calc(c), na.calc(c), ia.calc(c)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new M().fromArray(i));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
      }
      vl.prototype.isCatmullRomCurve3 = !0;
      function Fc(s, e, t, n, i) {
        const r = (n - e) * 0.5,
          o = (i - t) * 0.5,
          a = s * s,
          c = s * a;
        return (
          (2 * t - 2 * n + r + o) * c +
          (-3 * t + 3 * n - 2 * r - o) * a +
          r * s +
          t
        );
      }
      function $y(s, e) {
        const t = 1 - s;
        return t * t * e;
      }
      function Qy(s, e) {
        return 2 * (1 - s) * s * e;
      }
      function ev(s, e) {
        return s * s * e;
      }
      function gr(s, e, t, n) {
        return $y(s, e) + Qy(s, t) + ev(s, n);
      }
      function tv(s, e) {
        const t = 1 - s;
        return t * t * t * e;
      }
      function nv(s, e) {
        const t = 1 - s;
        return 3 * t * t * s * e;
      }
      function iv(s, e) {
        return 3 * (1 - s) * s * s * e;
      }
      function rv(s, e) {
        return s * s * s * e;
      }
      function xr(s, e, t, n, i) {
        return tv(s, e) + nv(s, t) + iv(s, n) + rv(s, i);
      }
      class vo extends Lt {
        constructor(e = new q(), t = new q(), n = new q(), i = new q()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new q()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return n.set(xr(e, i.x, r.x, o.x, a.x), xr(e, i.y, r.y, o.y, a.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      vo.prototype.isCubicBezierCurve = !0;
      class _l extends Lt {
        constructor(e = new M(), t = new M(), n = new M(), i = new M()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new M()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return (
            n.set(
              xr(e, i.x, r.x, o.x, a.x),
              xr(e, i.y, r.y, o.y, a.y),
              xr(e, i.z, r.z, o.z, a.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      _l.prototype.isCubicBezierCurve3 = !0;
      class Yr extends Lt {
        constructor(e = new q(), t = new q()) {
          super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new q()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const n = t || new q();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Yr.prototype.isLineCurve = !0;
      class Pd extends Lt {
        constructor(e = new M(), t = new M()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new M()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      class _o extends Lt {
        constructor(e = new q(), t = new q(), n = new q()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new q()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return n.set(gr(e, i.x, r.x, o.x), gr(e, i.y, r.y, o.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      _o.prototype.isQuadraticBezierCurve = !0;
      class Ml extends Lt {
        constructor(e = new M(), t = new M(), n = new M()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new M()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return (
            n.set(
              gr(e, i.x, r.x, o.x),
              gr(e, i.y, r.y, o.y),
              gr(e, i.z, r.z, o.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Ml.prototype.isQuadraticBezierCurve3 = !0;
      class Mo extends Lt {
        constructor(e = []) {
          super(), (this.type = "SplineCurve"), (this.points = e);
        }
        getPoint(e, t = new q()) {
          const n = t,
            i = this.points,
            r = (i.length - 1) * e,
            o = Math.floor(r),
            a = r - o,
            c = i[o === 0 ? o : o - 1],
            l = i[o],
            u = i[o > i.length - 2 ? i.length - 1 : o + 1],
            h = i[o > i.length - 3 ? i.length - 1 : o + 2];
          return n.set(Fc(a, c.x, l.x, u.x, h.x), Fc(a, c.y, l.y, u.y, h.y)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new q().fromArray(i));
          }
          return this;
        }
      }
      Mo.prototype.isSplineCurve = !0;
      var Ba = Object.freeze({
        __proto__: null,
        ArcCurve: xl,
        CatmullRomCurve3: vl,
        CubicBezierCurve: vo,
        CubicBezierCurve3: _l,
        EllipseCurve: Xr,
        LineCurve: Yr,
        LineCurve3: Pd,
        QuadraticBezierCurve: _o,
        QuadraticBezierCurve3: Ml,
        SplineCurve: Mo,
      });
      class Id extends Lt {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new Yr(t, e));
        }
        getPoint(e) {
          const t = e * this.getLength(),
            n = this.getCurveLengths();
          let i = 0;
          for (; i < n.length; ) {
            if (n[i] >= t) {
              const r = n[i] - t,
                o = this.curves[i],
                a = o.getLength(),
                c = a === 0 ? 0 : 1 - r / a;
              return o.getPointAt(c);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const o = r[i],
              a =
                o && o.isEllipseCurve
                  ? e * 2
                  : o && (o.isLineCurve || o.isLineCurve3)
                  ? 1
                  : o && o.isSplineCurve
                  ? e * o.points.length
                  : e,
              c = o.getPoints(a);
            for (let l = 0; l < c.length; l++) {
              const u = c[l];
              (n && n.equals(u)) || (t.push(u), (n = u));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        }
        copy(e) {
          super.copy(e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone());
          }
          return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Ba[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class Pr extends Id {
        constructor(e) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new q()),
            e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const n = new Yr(this.currentPoint.clone(), new q(e, t));
          return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          const r = new _o(this.currentPoint.clone(), new q(e, t), new q(n, i));
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, o) {
          const a = new vo(
            this.currentPoint.clone(),
            new q(e, t),
            new q(n, i),
            new q(r, o)
          );
          return this.curves.push(a), this.currentPoint.set(r, o), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            n = new Mo(t);
          return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
          );
        }
        arc(e, t, n, i, r, o) {
          const a = this.currentPoint.x,
            c = this.currentPoint.y;
          return this.absarc(e + a, t + c, n, i, r, o), this;
        }
        absarc(e, t, n, i, r, o) {
          return this.absellipse(e, t, n, n, i, r, o), this;
        }
        ellipse(e, t, n, i, r, o, a, c) {
          const l = this.currentPoint.x,
            u = this.currentPoint.y;
          return this.absellipse(e + l, t + u, n, i, r, o, a, c), this;
        }
        absellipse(e, t, n, i, r, o, a, c) {
          const l = new Xr(e, t, n, i, r, o, a, c);
          if (this.curves.length > 0) {
            const h = l.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
          }
          this.curves.push(l);
          const u = l.getPoint(1);
          return this.currentPoint.copy(u), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
          );
        }
      }
      class _n extends Pr {
        constructor(e) {
          super(e),
            (this.uuid = At()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(e) {
          const t = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
          super.copy(e), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.uuid = this.uuid), (e.holes = []);
          for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new Pr().fromJSON(i));
          }
          return this;
        }
      }
      class Ut extends Ee {
        constructor(e, t = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new K(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      Ut.prototype.isLight = !0;
      class wl extends Ut {
        constructor(e, t, n) {
          super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Ee.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new K(t));
        }
        copy(e) {
          return (
            Ut.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
          );
        }
      }
      wl.prototype.isHemisphereLight = !0;
      const Bc = new ce(),
        Nc = new M(),
        Gc = new M();
      class bl {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.mapSize = new q(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new ce()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Or()),
            (this._frameExtents = new q(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Ge(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          Nc.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(Nc),
            Gc.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Gc),
            t.updateMatrixWorld(),
            Bc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Bc),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class Dd extends bl {
        constructor() {
          super(new nt(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = br * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n !== t.fov || i !== t.aspect || r !== t.far) &&
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      Dd.prototype.isSpotLightShadow = !0;
      class wo extends Ut {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 1) {
          super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(Ee.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ee()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = o),
            (this.shadow = new Dd());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      wo.prototype.isSpotLight = !0;
      const Oc = new ce(),
        lr = new M(),
        ra = new M();
      class Fd extends bl {
        constructor() {
          super(new nt(90, 1, 0.5, 500)),
            (this._frameExtents = new q(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Ge(2, 1, 1, 1),
              new Ge(0, 1, 1, 1),
              new Ge(3, 1, 1, 1),
              new Ge(1, 1, 1, 1),
              new Ge(3, 0, 1, 1),
              new Ge(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new M(1, 0, 0),
              new M(-1, 0, 0),
              new M(0, 0, 1),
              new M(0, 0, -1),
              new M(0, 1, 0),
              new M(0, -1, 0),
            ]),
            (this._cubeUps = [
              new M(0, 1, 0),
              new M(0, 1, 0),
              new M(0, 1, 0),
              new M(0, 1, 0),
              new M(0, 0, 1),
              new M(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            lr.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(lr),
            ra.copy(n.position),
            ra.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(ra),
            n.updateMatrixWorld(),
            i.makeTranslation(-lr.x, -lr.y, -lr.z),
            Oc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Oc);
        }
      }
      Fd.prototype.isPointLightShadow = !0;
      class bo extends Ut {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Fd());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      bo.prototype.isPointLight = !0;
      class ji extends Gr {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, o) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            o = n + e,
            a = i + t,
            c = i - t;
          if (this.view !== null && this.view.enabled) {
            const l =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += l * this.view.offsetX),
              (o = r + l * this.view.width),
              (a -= u * this.view.offsetY),
              (c = a - u * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            a,
            c,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      ji.prototype.isOrthographicCamera = !0;
      class Bd extends bl {
        constructor() {
          super(new ji(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Bd.prototype.isDirectionalLightShadow = !0;
      class Zr extends Ut {
        constructor(e, t) {
          super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(Ee.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ee()),
            (this.shadow = new Bd());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Zr.prototype.isDirectionalLight = !0;
      class So extends Ut {
        constructor(e, t) {
          super(e, t), (this.type = "AmbientLight");
        }
      }
      So.prototype.isAmbientLight = !0;
      class Sl extends Ut {
        constructor(e, t, n = 10, i = 10) {
          super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.width = this.width), (t.object.height = this.height), t
          );
        }
      }
      Sl.prototype.isRectAreaLight = !0;
      class Tl {
        constructor() {
          this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new M());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * i),
            t.addScaledVector(o[2], 0.488603 * r),
            t.addScaledVector(o[3], 0.488603 * n),
            t.addScaledVector(o[4], 1.092548 * (n * i)),
            t.addScaledVector(o[5], 1.092548 * (i * r)),
            t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
            t.addScaledVector(o[7], 1.092548 * (n * r)),
            t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * i),
            t.addScaledVector(o[2], 2 * 0.511664 * r),
            t.addScaledVector(o[3], 2 * 0.511664 * n),
            t.addScaledVector(o[4], 2 * 0.429043 * n * i),
            t.addScaledVector(o[5], 2 * 0.429043 * i * r),
            t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * n * r),
            t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * r),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * r),
            (t[6] = 0.315392 * (3 * r * r - 1)),
            (t[7] = 1.092548 * n * r),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      Tl.prototype.isSphericalHarmonics3 = !0;
      class Jr extends Ut {
        constructor(e = new Tl(), t = 1) {
          super(void 0, t), (this.sh = e);
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (t.object.sh = this.sh.toArray()), t;
        }
      }
      Jr.prototype.isLightProbe = !0;
      class Nd extends ht {
        constructor(e) {
          super(e), (this.textures = {});
        }
        load(e, t, n, i) {
          const r = this,
            o = new Ct(r.manager);
          o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  t(r.parse(JSON.parse(a)));
                } catch (c) {
                  i ? i(c) : console.error(c), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e) {
          const t = this.textures;
          function n(r) {
            return (
              t[r] === void 0 &&
                console.warn("THREE.MaterialLoader: Undefined texture", r),
              t[r]
            );
          }
          const i = new Yy[e.type]();
          if (
            (e.uuid !== void 0 && (i.uuid = e.uuid),
            e.name !== void 0 && (i.name = e.name),
            e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
            e.roughness !== void 0 && (i.roughness = e.roughness),
            e.metalness !== void 0 && (i.metalness = e.metalness),
            e.sheen !== void 0 && (i.sheen = new K().setHex(e.sheen)),
            e.emissive !== void 0 &&
              i.emissive !== void 0 &&
              i.emissive.setHex(e.emissive),
            e.specular !== void 0 &&
              i.specular !== void 0 &&
              i.specular.setHex(e.specular),
            e.shininess !== void 0 && (i.shininess = e.shininess),
            e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
            e.clearcoatRoughness !== void 0 &&
              (i.clearcoatRoughness = e.clearcoatRoughness),
            e.transmission !== void 0 && (i.transmission = e.transmission),
            e.thickness !== void 0 && (i.thickness = e.thickness),
            e.attenuationDistance !== void 0 &&
              (i.attenuationDistance = e.attenuationDistance),
            e.attenuationColor !== void 0 &&
              i.attenuationColor !== void 0 &&
              i.attenuationColor.setHex(e.attenuationColor),
            e.fog !== void 0 && (i.fog = e.fog),
            e.flatShading !== void 0 && (i.flatShading = e.flatShading),
            e.blending !== void 0 && (i.blending = e.blending),
            e.combine !== void 0 && (i.combine = e.combine),
            e.side !== void 0 && (i.side = e.side),
            e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
            e.opacity !== void 0 && (i.opacity = e.opacity),
            e.transparent !== void 0 && (i.transparent = e.transparent),
            e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
            e.depthTest !== void 0 && (i.depthTest = e.depthTest),
            e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
            e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
            e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
            e.stencilWriteMask !== void 0 &&
              (i.stencilWriteMask = e.stencilWriteMask),
            e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
            e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
            e.stencilFuncMask !== void 0 &&
              (i.stencilFuncMask = e.stencilFuncMask),
            e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
            e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
            e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
            e.wireframe !== void 0 && (i.wireframe = e.wireframe),
            e.wireframeLinewidth !== void 0 &&
              (i.wireframeLinewidth = e.wireframeLinewidth),
            e.wireframeLinecap !== void 0 &&
              (i.wireframeLinecap = e.wireframeLinecap),
            e.wireframeLinejoin !== void 0 &&
              (i.wireframeLinejoin = e.wireframeLinejoin),
            e.rotation !== void 0 && (i.rotation = e.rotation),
            e.linewidth !== 1 && (i.linewidth = e.linewidth),
            e.dashSize !== void 0 && (i.dashSize = e.dashSize),
            e.gapSize !== void 0 && (i.gapSize = e.gapSize),
            e.scale !== void 0 && (i.scale = e.scale),
            e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
            e.polygonOffsetFactor !== void 0 &&
              (i.polygonOffsetFactor = e.polygonOffsetFactor),
            e.polygonOffsetUnits !== void 0 &&
              (i.polygonOffsetUnits = e.polygonOffsetUnits),
            e.morphTargets !== void 0 && (i.morphTargets = e.morphTargets),
            e.morphNormals !== void 0 && (i.morphNormals = e.morphNormals),
            e.dithering !== void 0 && (i.dithering = e.dithering),
            e.alphaToCoverage !== void 0 &&
              (i.alphaToCoverage = e.alphaToCoverage),
            e.premultipliedAlpha !== void 0 &&
              (i.premultipliedAlpha = e.premultipliedAlpha),
            e.vertexTangents !== void 0 &&
              (i.vertexTangents = e.vertexTangents),
            e.visible !== void 0 && (i.visible = e.visible),
            e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
            e.userData !== void 0 && (i.userData = e.userData),
            e.vertexColors !== void 0 &&
              (typeof e.vertexColors == "number"
                ? (i.vertexColors = e.vertexColors > 0)
                : (i.vertexColors = e.vertexColors)),
            e.uniforms !== void 0)
          )
            for (const r in e.uniforms) {
              const o = e.uniforms[r];
              switch (((i.uniforms[r] = {}), o.type)) {
                case "t":
                  i.uniforms[r].value = n(o.value);
                  break;
                case "c":
                  i.uniforms[r].value = new K().setHex(o.value);
                  break;
                case "v2":
                  i.uniforms[r].value = new q().fromArray(o.value);
                  break;
                case "v3":
                  i.uniforms[r].value = new M().fromArray(o.value);
                  break;
                case "v4":
                  i.uniforms[r].value = new Ge().fromArray(o.value);
                  break;
                case "m3":
                  i.uniforms[r].value = new it().fromArray(o.value);
                  break;
                case "m4":
                  i.uniforms[r].value = new ce().fromArray(o.value);
                  break;
                default:
                  i.uniforms[r].value = o.value;
              }
            }
          if (
            (e.defines !== void 0 && (i.defines = e.defines),
            e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
            e.fragmentShader !== void 0 &&
              (i.fragmentShader = e.fragmentShader),
            e.extensions !== void 0)
          )
            for (const r in e.extensions) i.extensions[r] = e.extensions[r];
          if (
            (e.shading !== void 0 && (i.flatShading = e.shading === 1),
            e.size !== void 0 && (i.size = e.size),
            e.sizeAttenuation !== void 0 &&
              (i.sizeAttenuation = e.sizeAttenuation),
            e.map !== void 0 && (i.map = n(e.map)),
            e.matcap !== void 0 && (i.matcap = n(e.matcap)),
            e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
            e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
            e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
            e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
            e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
            e.normalScale !== void 0)
          ) {
            let r = e.normalScale;
            Array.isArray(r) === !1 && (r = [r, r]),
              (i.normalScale = new q().fromArray(r));
          }
          return (
            e.displacementMap !== void 0 &&
              (i.displacementMap = n(e.displacementMap)),
            e.displacementScale !== void 0 &&
              (i.displacementScale = e.displacementScale),
            e.displacementBias !== void 0 &&
              (i.displacementBias = e.displacementBias),
            e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
            e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
            e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
            e.emissiveIntensity !== void 0 &&
              (i.emissiveIntensity = e.emissiveIntensity),
            e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
            e.envMap !== void 0 && (i.envMap = n(e.envMap)),
            e.envMapIntensity !== void 0 &&
              (i.envMapIntensity = e.envMapIntensity),
            e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
            e.refractionRatio !== void 0 &&
              (i.refractionRatio = e.refractionRatio),
            e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
            e.lightMapIntensity !== void 0 &&
              (i.lightMapIntensity = e.lightMapIntensity),
            e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
            e.aoMapIntensity !== void 0 &&
              (i.aoMapIntensity = e.aoMapIntensity),
            e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
            e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
            e.clearcoatRoughnessMap !== void 0 &&
              (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
            e.clearcoatNormalMap !== void 0 &&
              (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
            e.clearcoatNormalScale !== void 0 &&
              (i.clearcoatNormalScale = new q().fromArray(
                e.clearcoatNormalScale
              )),
            e.transmissionMap !== void 0 &&
              (i.transmissionMap = n(e.transmissionMap)),
            e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
            i
          );
        }
        setTextures(e) {
          return (this.textures = e), this;
        }
      }
      class Mn {
        static decodeText(e) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.substr(0, t + 1);
        }
      }
      class El extends de {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(e) {
          return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        }
      }
      El.prototype.isInstancedBufferGeometry = !0;
      class Al extends be {
        constructor(e, t, n, i) {
          typeof n == "number" &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(e, t, n),
            (this.meshPerAttribute = i || 1);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      Al.prototype.isInstancedBufferAttribute = !0;
      class Gd extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new Ct(r.manager);
          o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  t(r.parse(JSON.parse(a)));
                } catch (c) {
                  i ? i(c) : console.error(c), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e) {
          const t = {},
            n = {};
          function i(f, p) {
            if (t[p] !== void 0) return t[p];
            const y = f.interleavedBuffers[p],
              m = r(f, y.buffer),
              g = dr(y.type, m),
              _ = new Rn(g, y.stride);
            return (_.uuid = y.uuid), (t[p] = _), _;
          }
          function r(f, p) {
            if (n[p] !== void 0) return n[p];
            const y = f.arrayBuffers[p],
              m = new Uint32Array(y).buffer;
            return (n[p] = m), m;
          }
          const o = e.isInstancedBufferGeometry ? new El() : new de(),
            a = e.data.index;
          if (a !== void 0) {
            const f = dr(a.type, a.array);
            o.setIndex(new be(f, 1));
          }
          const c = e.data.attributes;
          for (const f in c) {
            const p = c[f];
            let x;
            if (p.isInterleavedBufferAttribute) {
              const y = i(e.data, p.data);
              x = new on(y, p.itemSize, p.offset, p.normalized);
            } else {
              const y = dr(p.type, p.array),
                m = p.isInstancedBufferAttribute ? Al : be;
              x = new m(y, p.itemSize, p.normalized);
            }
            p.name !== void 0 && (x.name = p.name),
              p.usage !== void 0 && x.setUsage(p.usage),
              p.updateRange !== void 0 &&
                ((x.updateRange.offset = p.updateRange.offset),
                (x.updateRange.count = p.updateRange.count)),
              o.setAttribute(f, x);
          }
          const l = e.data.morphAttributes;
          if (l)
            for (const f in l) {
              const p = l[f],
                x = [];
              for (let y = 0, m = p.length; y < m; y++) {
                const g = p[y];
                let _;
                if (g.isInterleavedBufferAttribute) {
                  const w = i(e.data, g.data);
                  _ = new on(w, g.itemSize, g.offset, g.normalized);
                } else {
                  const w = dr(g.type, g.array);
                  _ = new be(w, g.itemSize, g.normalized);
                }
                g.name !== void 0 && (_.name = g.name), x.push(_);
              }
              o.morphAttributes[f] = x;
            }
          e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
          const h = e.data.groups || e.data.drawcalls || e.data.offsets;
          if (h !== void 0)
            for (let f = 0, p = h.length; f !== p; ++f) {
              const x = h[f];
              o.addGroup(x.start, x.count, x.materialIndex);
            }
          const d = e.data.boundingSphere;
          if (d !== void 0) {
            const f = new M();
            d.center !== void 0 && f.fromArray(d.center),
              (o.boundingSphere = new cn(f, d.radius));
          }
          return (
            e.name && (o.name = e.name),
            e.userData && (o.userData = e.userData),
            o
          );
        }
      }
      class sv extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = this.path === "" ? Mn.extractUrlBase(e) : this.path;
          this.resourcePath = this.resourcePath || o;
          const a = new Ct(this.manager);
          a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              e,
              function (c) {
                let l = null;
                try {
                  l = JSON.parse(c);
                } catch (h) {
                  i !== void 0 && i(h),
                    console.error(
                      "THREE:ObjectLoader: Can't parse " + e + ".",
                      h.message
                    );
                  return;
                }
                const u = l.metadata;
                if (
                  u === void 0 ||
                  u.type === void 0 ||
                  u.type.toLowerCase() === "geometry"
                ) {
                  console.error("THREE.ObjectLoader: Can't load " + e);
                  return;
                }
                r.parse(l, t);
              },
              n,
              i
            );
        }
        parse(e, t) {
          const n = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            r = this.parseGeometries(e.geometries, i),
            o = this.parseImages(e.images, function () {
              t !== void 0 && t(l);
            }),
            a = this.parseTextures(e.textures, o),
            c = this.parseMaterials(e.materials, a),
            l = this.parseObject(e.object, r, c, n),
            u = this.parseSkeletons(e.skeletons, l);
          if ((this.bindSkeletons(l, u), t !== void 0)) {
            let h = !1;
            for (const d in o)
              if (o[d] instanceof HTMLImageElement) {
                h = !0;
                break;
              }
            h === !1 && t(l);
          }
          return l;
        }
        parseShapes(e) {
          const t = {};
          if (e !== void 0)
            for (let n = 0, i = e.length; n < i; n++) {
              const r = new _n().fromJSON(e[n]);
              t[r.uuid] = r;
            }
          return t;
        }
        parseSkeletons(e, t) {
          const n = {},
            i = {};
          if (
            (t.traverse(function (r) {
              r.isBone && (i[r.uuid] = r);
            }),
            e !== void 0)
          )
            for (let r = 0, o = e.length; r < o; r++) {
              const a = new Wr().fromJSON(e[r], i);
              n[a.uuid] = a;
            }
          return n;
        }
        parseGeometries(e, t) {
          const n = {};
          let i;
          if (e !== void 0) {
            const r = new Gd();
            for (let o = 0, a = e.length; o < a; o++) {
              let c;
              const l = e[o];
              switch (l.type) {
                case "PlaneGeometry":
                case "PlaneBufferGeometry":
                  c = new yt[l.type](
                    l.width,
                    l.height,
                    l.widthSegments,
                    l.heightSegments
                  );
                  break;
                case "BoxGeometry":
                case "BoxBufferGeometry":
                  c = new yt[l.type](
                    l.width,
                    l.height,
                    l.depth,
                    l.widthSegments,
                    l.heightSegments,
                    l.depthSegments
                  );
                  break;
                case "CircleGeometry":
                case "CircleBufferGeometry":
                  c = new yt[l.type](
                    l.radius,
                    l.segments,
                    l.thetaStart,
                    l.thetaLength
                  );
                  break;
                case "CylinderGeometry":
                case "CylinderBufferGeometry":
                  c = new yt[l.type](
                    l.radiusTop,
                    l.radiusBottom,
                    l.height,
                    l.radialSegments,
                    l.heightSegments,
                    l.openEnded,
                    l.thetaStart,
                    l.thetaLength
                  );
                  break;
                case "ConeGeometry":
                case "ConeBufferGeometry":
                  c = new yt[l.type](
                    l.radius,
                    l.height,
                    l.radialSegments,
                    l.heightSegments,
                    l.openEnded,
                    l.thetaStart,
                    l.thetaLength
                  );
                  break;
                case "SphereGeometry":
                case "SphereBufferGeometry":
                  c = new yt[l.type](
                    l.radius,
                    l.widthSegments,
                    l.heightSegments,
                    l.phiStart,
                    l.phiLength,
                    l.thetaStart,
                    l.thetaLength
                  );
                  break;
                case "DodecahedronGeometry":
                case "DodecahedronBufferGeometry":
                case "IcosahedronGeometry":
                case "IcosahedronBufferGeometry":
                case "OctahedronGeometry":
                case "OctahedronBufferGeometry":
                case "TetrahedronGeometry":
                case "TetrahedronBufferGeometry":
                  c = new yt[l.type](l.radius, l.detail);
                  break;
                case "RingGeometry":
                case "RingBufferGeometry":
                  c = new yt[l.type](
                    l.innerRadius,
                    l.outerRadius,
                    l.thetaSegments,
                    l.phiSegments,
                    l.thetaStart,
                    l.thetaLength
                  );
                  break;
                case "TorusGeometry":
                case "TorusBufferGeometry":
                  c = new yt[l.type](
                    l.radius,
                    l.tube,
                    l.radialSegments,
                    l.tubularSegments,
                    l.arc
                  );
                  break;
                case "TorusKnotGeometry":
                case "TorusKnotBufferGeometry":
                  c = new yt[l.type](
                    l.radius,
                    l.tube,
                    l.tubularSegments,
                    l.radialSegments,
                    l.p,
                    l.q
                  );
                  break;
                case "TubeGeometry":
                case "TubeBufferGeometry":
                  c = new yt[l.type](
                    new Ba[l.path.type]().fromJSON(l.path),
                    l.tubularSegments,
                    l.radius,
                    l.radialSegments,
                    l.closed
                  );
                  break;
                case "LatheGeometry":
                case "LatheBufferGeometry":
                  c = new yt[l.type](
                    l.points,
                    l.segments,
                    l.phiStart,
                    l.phiLength
                  );
                  break;
                case "PolyhedronGeometry":
                case "PolyhedronBufferGeometry":
                  c = new yt[l.type](
                    l.vertices,
                    l.indices,
                    l.radius,
                    l.details
                  );
                  break;
                case "ShapeGeometry":
                case "ShapeBufferGeometry":
                  i = [];
                  for (let h = 0, d = l.shapes.length; h < d; h++) {
                    const f = t[l.shapes[h]];
                    i.push(f);
                  }
                  c = new yt[l.type](i, l.curveSegments);
                  break;
                case "ExtrudeGeometry":
                case "ExtrudeBufferGeometry":
                  i = [];
                  for (let h = 0, d = l.shapes.length; h < d; h++) {
                    const f = t[l.shapes[h]];
                    i.push(f);
                  }
                  const u = l.options.extrudePath;
                  u !== void 0 &&
                    (l.options.extrudePath = new Ba[u.type]().fromJSON(u)),
                    (c = new yt[l.type](i, l.options));
                  break;
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  c = r.parse(l);
                  break;
                case "Geometry":
                  console.error(
                    'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
                  );
                  break;
                default:
                  console.warn(
                    'THREE.ObjectLoader: Unsupported geometry type "' +
                      l.type +
                      '"'
                  );
                  continue;
              }
              (c.uuid = l.uuid),
                l.name !== void 0 && (c.name = l.name),
                c.isBufferGeometry === !0 &&
                  l.userData !== void 0 &&
                  (c.userData = l.userData),
                (n[l.uuid] = c);
            }
          }
          return n;
        }
        parseMaterials(e, t) {
          const n = {},
            i = {};
          if (e !== void 0) {
            const r = new Nd();
            r.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
              const c = e[o];
              if (c.type === "MultiMaterial") {
                const l = [];
                for (let u = 0; u < c.materials.length; u++) {
                  const h = c.materials[u];
                  n[h.uuid] === void 0 && (n[h.uuid] = r.parse(h)),
                    l.push(n[h.uuid]);
                }
                i[c.uuid] = l;
              } else
                n[c.uuid] === void 0 && (n[c.uuid] = r.parse(c)),
                  (i[c.uuid] = n[c.uuid]);
            }
          }
          return i;
        }
        parseAnimations(e) {
          const t = {};
          if (e !== void 0)
            for (let n = 0; n < e.length; n++) {
              const i = e[n],
                r = Hi.parse(i);
              t[r.uuid] = r;
            }
          return t;
        }
        parseImages(e, t) {
          const n = this,
            i = {};
          let r;
          function o(c) {
            return (
              n.manager.itemStart(c),
              r.load(
                c,
                function () {
                  n.manager.itemEnd(c);
                },
                void 0,
                function () {
                  n.manager.itemError(c), n.manager.itemEnd(c);
                }
              )
            );
          }
          function a(c) {
            if (typeof c == "string") {
              const l = c,
                u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)
                  ? l
                  : n.resourcePath + l;
              return o(u);
            } else
              return c.data
                ? { data: dr(c.type, c.data), width: c.width, height: c.height }
                : null;
          }
          if (e !== void 0 && e.length > 0) {
            const c = new ml(t);
            (r = new yo(c)), r.setCrossOrigin(this.crossOrigin);
            for (let l = 0, u = e.length; l < u; l++) {
              const h = e[l],
                d = h.url;
              if (Array.isArray(d)) {
                i[h.uuid] = [];
                for (let f = 0, p = d.length; f < p; f++) {
                  const x = d[f],
                    y = a(x);
                  y !== null &&
                    (y instanceof HTMLImageElement
                      ? i[h.uuid].push(y)
                      : i[h.uuid].push(new Gi(y.data, y.width, y.height)));
                }
              } else {
                const f = a(h.url);
                f !== null && (i[h.uuid] = f);
              }
            }
          }
          return i;
        }
        parseTextures(e, t) {
          function n(r, o) {
            return typeof r == "number"
              ? r
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  r
                ),
                o[r]);
          }
          const i = {};
          if (e !== void 0)
            for (let r = 0, o = e.length; r < o; r++) {
              const a = e[r];
              a.image === void 0 &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  a.uuid
                ),
                t[a.image] === void 0 &&
                  console.warn("THREE.ObjectLoader: Undefined image", a.image);
              let c;
              const l = t[a.image];
              Array.isArray(l)
                ? ((c = new Xi(l)), l.length === 6 && (c.needsUpdate = !0))
                : (l && l.data
                    ? (c = new Gi(l.data, l.width, l.height))
                    : (c = new rt(l)),
                  l && (c.needsUpdate = !0)),
                (c.uuid = a.uuid),
                a.name !== void 0 && (c.name = a.name),
                a.mapping !== void 0 && (c.mapping = n(a.mapping, ov)),
                a.offset !== void 0 && c.offset.fromArray(a.offset),
                a.repeat !== void 0 && c.repeat.fromArray(a.repeat),
                a.center !== void 0 && c.center.fromArray(a.center),
                a.rotation !== void 0 && (c.rotation = a.rotation),
                a.wrap !== void 0 &&
                  ((c.wrapS = n(a.wrap[0], Uc)), (c.wrapT = n(a.wrap[1], Uc))),
                a.format !== void 0 && (c.format = a.format),
                a.type !== void 0 && (c.type = a.type),
                a.encoding !== void 0 && (c.encoding = a.encoding),
                a.minFilter !== void 0 && (c.minFilter = n(a.minFilter, zc)),
                a.magFilter !== void 0 && (c.magFilter = n(a.magFilter, zc)),
                a.anisotropy !== void 0 && (c.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (c.flipY = a.flipY),
                a.premultiplyAlpha !== void 0 &&
                  (c.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 &&
                  (c.unpackAlignment = a.unpackAlignment),
                (i[a.uuid] = c);
            }
          return i;
        }
        parseObject(e, t, n, i) {
          let r;
          function o(u) {
            return (
              t[u] === void 0 &&
                console.warn("THREE.ObjectLoader: Undefined geometry", u),
              t[u]
            );
          }
          function a(u) {
            if (u !== void 0) {
              if (Array.isArray(u)) {
                const h = [];
                for (let d = 0, f = u.length; d < f; d++) {
                  const p = u[d];
                  n[p] === void 0 &&
                    console.warn("THREE.ObjectLoader: Undefined material", p),
                    h.push(n[p]);
                }
                return h;
              }
              return (
                n[u] === void 0 &&
                  console.warn("THREE.ObjectLoader: Undefined material", u),
                n[u]
              );
            }
          }
          let c, l;
          switch (e.type) {
            case "Scene":
              (r = new Hr()),
                e.background !== void 0 &&
                  Number.isInteger(e.background) &&
                  (r.background = new K(e.background)),
                e.fog !== void 0 &&
                  (e.fog.type === "Fog"
                    ? (r.fog = new zr(e.fog.color, e.fog.near, e.fog.far))
                    : e.fog.type === "FogExp2" &&
                      (r.fog = new Ur(e.fog.color, e.fog.density)));
              break;
            case "PerspectiveCamera":
              (r = new nt(e.fov, e.aspect, e.near, e.far)),
                e.focus !== void 0 && (r.focus = e.focus),
                e.zoom !== void 0 && (r.zoom = e.zoom),
                e.filmGauge !== void 0 && (r.filmGauge = e.filmGauge),
                e.filmOffset !== void 0 && (r.filmOffset = e.filmOffset),
                e.view !== void 0 && (r.view = Object.assign({}, e.view));
              break;
            case "OrthographicCamera":
              (r = new ji(e.left, e.right, e.top, e.bottom, e.near, e.far)),
                e.zoom !== void 0 && (r.zoom = e.zoom),
                e.view !== void 0 && (r.view = Object.assign({}, e.view));
              break;
            case "AmbientLight":
              r = new So(e.color, e.intensity);
              break;
            case "DirectionalLight":
              r = new Zr(e.color, e.intensity);
              break;
            case "PointLight":
              r = new bo(e.color, e.intensity, e.distance, e.decay);
              break;
            case "RectAreaLight":
              r = new Sl(e.color, e.intensity, e.width, e.height);
              break;
            case "SpotLight":
              r = new wo(
                e.color,
                e.intensity,
                e.distance,
                e.angle,
                e.penumbra,
                e.decay
              );
              break;
            case "HemisphereLight":
              r = new wl(e.color, e.groundColor, e.intensity);
              break;
            case "LightProbe":
              r = new Jr().fromJSON(e);
              break;
            case "SkinnedMesh":
              (c = o(e.geometry)),
                (l = a(e.material)),
                (r = new kr(c, l)),
                e.bindMode !== void 0 && (r.bindMode = e.bindMode),
                e.bindMatrix !== void 0 && r.bindMatrix.fromArray(e.bindMatrix),
                e.skeleton !== void 0 && (r.skeleton = e.skeleton);
              break;
            case "Mesh":
              (c = o(e.geometry)), (l = a(e.material)), (r = new $e(c, l));
              break;
            case "InstancedMesh":
              (c = o(e.geometry)), (l = a(e.material));
              const u = e.count,
                h = e.instanceMatrix,
                d = e.instanceColor;
              (r = new tl(c, l, u)),
                (r.instanceMatrix = new be(new Float32Array(h.array), 16)),
                d !== void 0 &&
                  (r.instanceColor = new be(
                    new Float32Array(d.array),
                    d.itemSize
                  ));
              break;
            case "LOD":
              r = new vd();
              break;
            case "Line":
              r = new Xt(o(e.geometry), a(e.material));
              break;
            case "LineLoop":
              r = new go(o(e.geometry), a(e.material));
              break;
            case "LineSegments":
              r = new Mt(o(e.geometry), a(e.material));
              break;
            case "PointCloud":
            case "Points":
              r = new Zi(o(e.geometry), a(e.material));
              break;
            case "Sprite":
              r = new mo(a(e.material));
              break;
            case "Group":
              r = new Vt();
              break;
            case "Bone":
              r = new Vr();
              break;
            default:
              r = new Ee();
          }
          if (
            ((r.uuid = e.uuid),
            e.name !== void 0 && (r.name = e.name),
            e.matrix !== void 0
              ? (r.matrix.fromArray(e.matrix),
                e.matrixAutoUpdate !== void 0 &&
                  (r.matrixAutoUpdate = e.matrixAutoUpdate),
                r.matrixAutoUpdate &&
                  r.matrix.decompose(r.position, r.quaternion, r.scale))
              : (e.position !== void 0 && r.position.fromArray(e.position),
                e.rotation !== void 0 && r.rotation.fromArray(e.rotation),
                e.quaternion !== void 0 && r.quaternion.fromArray(e.quaternion),
                e.scale !== void 0 && r.scale.fromArray(e.scale)),
            e.castShadow !== void 0 && (r.castShadow = e.castShadow),
            e.receiveShadow !== void 0 && (r.receiveShadow = e.receiveShadow),
            e.shadow &&
              (e.shadow.bias !== void 0 && (r.shadow.bias = e.shadow.bias),
              e.shadow.normalBias !== void 0 &&
                (r.shadow.normalBias = e.shadow.normalBias),
              e.shadow.radius !== void 0 && (r.shadow.radius = e.shadow.radius),
              e.shadow.mapSize !== void 0 &&
                r.shadow.mapSize.fromArray(e.shadow.mapSize),
              e.shadow.camera !== void 0 &&
                (r.shadow.camera = this.parseObject(e.shadow.camera))),
            e.visible !== void 0 && (r.visible = e.visible),
            e.frustumCulled !== void 0 && (r.frustumCulled = e.frustumCulled),
            e.renderOrder !== void 0 && (r.renderOrder = e.renderOrder),
            e.userData !== void 0 && (r.userData = e.userData),
            e.layers !== void 0 && (r.layers.mask = e.layers),
            e.children !== void 0)
          ) {
            const u = e.children;
            for (let h = 0; h < u.length; h++)
              r.add(this.parseObject(u[h], t, n, i));
          }
          if (e.animations !== void 0) {
            const u = e.animations;
            for (let h = 0; h < u.length; h++) {
              const d = u[h];
              r.animations.push(i[d]);
            }
          }
          if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (r.autoUpdate = e.autoUpdate);
            const u = e.levels;
            for (let h = 0; h < u.length; h++) {
              const d = u[h],
                f = r.getObjectByProperty("uuid", d.object);
              f !== void 0 && r.addLevel(f, d.distance);
            }
          }
          return r;
        }
        bindSkeletons(e, t) {
          Object.keys(t).length !== 0 &&
            e.traverse(function (n) {
              if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                const i = t[n.skeleton];
                i === void 0
                  ? console.warn(
                      "THREE.ObjectLoader: No skeleton found with UUID:",
                      n.skeleton
                    )
                  : n.bind(i, n.bindMatrix);
              }
            });
        }
        setTexturePath(e) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(e)
          );
        }
      }
      const ov = {
          UVMapping: no,
          CubeReflectionMapping: Fr,
          CubeRefractionMapping: Br,
          EquirectangularReflectionMapping: ks,
          EquirectangularRefractionMapping: Vs,
          CubeUVReflectionMapping: Wi,
          CubeUVRefractionMapping: Nr,
        },
        Uc = {
          RepeatWrapping: bn,
          ClampToEdgeWrapping: at,
          MirroredRepeatWrapping: Pi,
        },
        zc = {
          NearestFilter: Je,
          NearestMipmapNearestFilter: yr,
          NearestMipmapLinearFilter: vr,
          LinearFilter: Ke,
          LinearMipmapNearestFilter: io,
          LinearMipmapLinearFilter: ln,
        };
      class Ll extends ht {
        constructor(e) {
          super(e),
            typeof createImageBitmap == "undefined" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch == "undefined" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = ei.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = {};
          (a.credentials =
            this.crossOrigin === "anonymous" ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (c) {
                return c.blob();
              })
              .then(function (c) {
                return createImageBitmap(
                  c,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (c) {
                ei.add(e, c), t && t(c), r.manager.itemEnd(e);
              })
              .catch(function (c) {
                i && i(c), r.manager.itemError(e), r.manager.itemEnd(e);
              }),
            r.manager.itemStart(e);
        }
      }
      Ll.prototype.isImageBitmapLoader = !0;
      class Od {
        constructor() {
          (this.type = "ShapePath"),
            (this.color = new K()),
            (this.subPaths = []),
            (this.currentPath = null);
        }
        moveTo(e, t) {
          return (
            (this.currentPath = new Pr()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t),
            this
          );
        }
        lineTo(e, t) {
          return this.currentPath.lineTo(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          return this.currentPath.quadraticCurveTo(e, t, n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, o) {
          return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
        }
        splineThru(e) {
          return this.currentPath.splineThru(e), this;
        }
        toShapes(e, t) {
          function n(g) {
            const _ = [];
            for (let w = 0, T = g.length; w < T; w++) {
              const v = g[w],
                A = new _n();
              (A.curves = v.curves), _.push(A);
            }
            return _;
          }
          function i(g, _) {
            const w = _.length;
            let T = !1;
            for (let v = w - 1, A = 0; A < w; v = A++) {
              let L = _[v],
                I = _[A],
                N = I.x - L.x,
                U = I.y - L.y;
              if (Math.abs(U) > Number.EPSILON) {
                if (
                  (U < 0 && ((L = _[A]), (N = -N), (I = _[v]), (U = -U)),
                  g.y < L.y || g.y > I.y)
                )
                  continue;
                if (g.y === L.y) {
                  if (g.x === L.x) return !0;
                } else {
                  const G = U * (g.x - L.x) - N * (g.y - L.y);
                  if (G === 0) return !0;
                  if (G < 0) continue;
                  T = !T;
                }
              } else {
                if (g.y !== L.y) continue;
                if ((I.x <= g.x && g.x <= L.x) || (L.x <= g.x && g.x <= I.x))
                  return !0;
              }
            }
            return T;
          }
          const r = qt.isClockWise,
            o = this.subPaths;
          if (o.length === 0) return [];
          if (t === !0) return n(o);
          let a, c, l;
          const u = [];
          if (o.length === 1)
            return (
              (c = o[0]), (l = new _n()), (l.curves = c.curves), u.push(l), u
            );
          let h = !r(o[0].getPoints());
          h = e ? !h : h;
          const d = [],
            f = [];
          let p = [],
            x = 0,
            y;
          (f[x] = void 0), (p[x] = []);
          for (let g = 0, _ = o.length; g < _; g++)
            (c = o[g]),
              (y = c.getPoints()),
              (a = r(y)),
              (a = e ? !a : a),
              a
                ? (!h && f[x] && x++,
                  (f[x] = { s: new _n(), p: y }),
                  (f[x].s.curves = c.curves),
                  h && x++,
                  (p[x] = []))
                : p[x].push({ h: c, p: y[0] });
          if (!f[0]) return n(o);
          if (f.length > 1) {
            let g = !1;
            const _ = [];
            for (let w = 0, T = f.length; w < T; w++) d[w] = [];
            for (let w = 0, T = f.length; w < T; w++) {
              const v = p[w];
              for (let A = 0; A < v.length; A++) {
                const L = v[A];
                let I = !0;
                for (let N = 0; N < f.length; N++)
                  i(L.p, f[N].p) &&
                    (w !== N && _.push({ froms: w, tos: N, hole: A }),
                    I ? ((I = !1), d[N].push(L)) : (g = !0));
                I && d[w].push(L);
              }
            }
            _.length > 0 && (g || (p = d));
          }
          let m;
          for (let g = 0, _ = f.length; g < _; g++) {
            (l = f[g].s), u.push(l), (m = p[g]);
            for (let w = 0, T = m.length; w < T; w++) l.holes.push(m[w].h);
          }
          return u;
        }
      }
      class Rl {
        constructor(e) {
          (this.type = "Font"), (this.data = e);
        }
        generateShapes(e, t = 100) {
          const n = [],
            i = av(e, t, this.data);
          for (let r = 0, o = i.length; r < o; r++)
            Array.prototype.push.apply(n, i[r].toShapes());
          return n;
        }
      }
      function av(s, e, t) {
        const n = Array.from(s),
          i = e / t.resolution,
          r =
            (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) *
            i,
          o = [];
        let a = 0,
          c = 0;
        for (let l = 0; l < n.length; l++) {
          const u = n[l];
          if (
            u ===
            `
`
          )
            (a = 0), (c -= r);
          else {
            const h = lv(u, i, a, c, t);
            (a += h.offsetX), o.push(h.path);
          }
        }
        return o;
      }
      function lv(s, e, t, n, i) {
        const r = i.glyphs[s] || i.glyphs["?"];
        if (!r) {
          console.error(
            'THREE.Font: character "' +
              s +
              '" does not exists in font family ' +
              i.familyName +
              "."
          );
          return;
        }
        const o = new Od();
        let a, c, l, u, h, d, f, p;
        if (r.o) {
          const x = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
          for (let y = 0, m = x.length; y < m; )
            switch (x[y++]) {
              case "m":
                (a = x[y++] * e + t), (c = x[y++] * e + n), o.moveTo(a, c);
                break;
              case "l":
                (a = x[y++] * e + t), (c = x[y++] * e + n), o.lineTo(a, c);
                break;
              case "q":
                (l = x[y++] * e + t),
                  (u = x[y++] * e + n),
                  (h = x[y++] * e + t),
                  (d = x[y++] * e + n),
                  o.quadraticCurveTo(h, d, l, u);
                break;
              case "b":
                (l = x[y++] * e + t),
                  (u = x[y++] * e + n),
                  (h = x[y++] * e + t),
                  (d = x[y++] * e + n),
                  (f = x[y++] * e + t),
                  (p = x[y++] * e + n),
                  o.bezierCurveTo(h, d, f, p, l, u);
                break;
            }
        }
        return { offsetX: r.ha * e, path: o };
      }
      Rl.prototype.isFont = !0;
      class cv extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new Ct(this.manager);
          o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(
              e,
              function (a) {
                let c;
                try {
                  c = JSON.parse(a);
                } catch {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (c = JSON.parse(a.substring(65, a.length - 2)));
                }
                const l = r.parse(c);
                t && t(l);
              },
              n,
              i
            );
        }
        parse(e) {
          return new Rl(e);
        }
      }
      let Cs;
      const Cl = {
        getContext: function () {
          return (
            Cs === void 0 &&
              (Cs = new (window.AudioContext || window.webkitAudioContext)()),
            Cs
          );
        },
        setContext: function (s) {
          Cs = s;
        },
      };
      class Ud extends ht {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new Ct(this.manager);
          o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  const c = a.slice(0);
                  Cl.getContext().decodeAudioData(c, function (u) {
                    t(u);
                  });
                } catch (c) {
                  i ? i(c) : console.error(c), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
      }
      class zd extends Jr {
        constructor(e, t, n = 1) {
          super(void 0, n);
          const i = new K().set(e),
            r = new K().set(t),
            o = new M(i.r, i.g, i.b),
            a = new M(r.r, r.g, r.b),
            c = Math.sqrt(Math.PI),
            l = c * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o).add(a).multiplyScalar(c),
            this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(l);
        }
      }
      zd.prototype.isHemisphereLightProbe = !0;
      class Hd extends Jr {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new K().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Hd.prototype.isAmbientLightProbe = !0;
      const Hc = new ce(),
        kc = new ce();
      class uv {
        constructor() {
          (this.type = "StereoCamera"),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new nt()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new nt()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
              focus: null,
              fov: null,
              aspect: null,
              near: null,
              far: null,
              zoom: null,
              eyeSep: null,
            });
        }
        update(e) {
          const t = this._cache;
          if (
            t.focus !== e.focus ||
            t.fov !== e.fov ||
            t.aspect !== e.aspect * this.aspect ||
            t.near !== e.near ||
            t.far !== e.far ||
            t.zoom !== e.zoom ||
            t.eyeSep !== this.eyeSep
          ) {
            (t.focus = e.focus),
              (t.fov = e.fov),
              (t.aspect = e.aspect * this.aspect),
              (t.near = e.near),
              (t.far = e.far),
              (t.zoom = e.zoom),
              (t.eyeSep = this.eyeSep);
            const i = e.projectionMatrix.clone(),
              r = t.eyeSep / 2,
              o = (r * t.near) / t.focus,
              a = (t.near * Math.tan(Jn * t.fov * 0.5)) / t.zoom;
            let c, l;
            (kc.elements[12] = -r),
              (Hc.elements[12] = r),
              (c = -a * t.aspect + o),
              (l = a * t.aspect + o),
              (i.elements[0] = (2 * t.near) / (l - c)),
              (i.elements[8] = (l + c) / (l - c)),
              this.cameraL.projectionMatrix.copy(i),
              (c = -a * t.aspect - o),
              (l = a * t.aspect - o),
              (i.elements[0] = (2 * t.near) / (l - c)),
              (i.elements[8] = (l + c) / (l - c)),
              this.cameraR.projectionMatrix.copy(i);
          }
          this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(kc),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Hc);
        }
      }
      class kd {
        constructor(e = !0) {
          (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = Vc()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = Vc();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function Vc() {
        return (typeof performance == "undefined" ? Date : performance).now();
      }
      const Gn = new M(),
        Wc = new lt(),
        hv = new M(),
        On = new M();
      class dv extends Ee {
        constructor() {
          super(),
            (this.type = "AudioListener"),
            (this.context = Cl.getContext()),
            (this.gain = this.context.createGain()),
            this.gain.connect(this.context.destination),
            (this.filter = null),
            (this.timeDelta = 0),
            (this._clock = new kd());
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return (
            this.filter !== null &&
              (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination),
              this.gain.connect(this.context.destination),
              (this.filter = null)),
            this
          );
        }
        getFilter() {
          return this.filter;
        }
        setFilter(e) {
          return (
            this.filter !== null
              ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination))
              : this.gain.disconnect(this.context.destination),
            (this.filter = e),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
          );
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e);
          const t = this.context.listener,
            n = this.up;
          if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose(Gn, Wc, hv),
            On.set(0, 0, -1).applyQuaternion(Wc),
            t.positionX)
          ) {
            const i = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(Gn.x, i),
              t.positionY.linearRampToValueAtTime(Gn.y, i),
              t.positionZ.linearRampToValueAtTime(Gn.z, i),
              t.forwardX.linearRampToValueAtTime(On.x, i),
              t.forwardY.linearRampToValueAtTime(On.y, i),
              t.forwardZ.linearRampToValueAtTime(On.z, i),
              t.upX.linearRampToValueAtTime(n.x, i),
              t.upY.linearRampToValueAtTime(n.y, i),
              t.upZ.linearRampToValueAtTime(n.z, i);
          } else
            t.setPosition(Gn.x, Gn.y, Gn.z),
              t.setOrientation(On.x, On.y, On.z, n.x, n.y, n.z);
        }
      }
      class Pl extends Ee {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            this.isPlaying === !0 &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.loop === !0 &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            this._connected === !0
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), this.source.detune !== void 0))
            return (
              this.isPlaying === !0 &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return this.hasPlaybackControl === !1
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }
      const Un = new M(),
        qc = new lt(),
        fv = new M(),
        zn = new M();
      class pv extends Pl {
        constructor(e) {
          super(e),
            (this.panner = this.context.createPanner()),
            (this.panner.panningModel = "HRTF"),
            this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(e) {
          return (this.panner.refDistance = e), this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(e) {
          return (this.panner.rolloffFactor = e), this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(e) {
          return (this.panner.distanceModel = e), this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(e) {
          return (this.panner.maxDistance = e), this;
        }
        setDirectionalCone(e, t, n) {
          return (
            (this.panner.coneInnerAngle = e),
            (this.panner.coneOuterAngle = t),
            (this.panner.coneOuterGain = n),
            this
          );
        }
        updateMatrixWorld(e) {
          if (
            (super.updateMatrixWorld(e),
            this.hasPlaybackControl === !0 && this.isPlaying === !1)
          )
            return;
          this.matrixWorld.decompose(Un, qc, fv),
            zn.set(0, 0, 1).applyQuaternion(qc);
          const t = this.panner;
          if (t.positionX) {
            const n = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(Un.x, n),
              t.positionY.linearRampToValueAtTime(Un.y, n),
              t.positionZ.linearRampToValueAtTime(Un.z, n),
              t.orientationX.linearRampToValueAtTime(zn.x, n),
              t.orientationY.linearRampToValueAtTime(zn.y, n),
              t.orientationZ.linearRampToValueAtTime(zn.z, n);
          } else
            t.setPosition(Un.x, Un.y, Un.z), t.setOrientation(zn.x, zn.y, zn.z);
        }
      }
      class Vd {
        constructor(e, t = 2048) {
          (this.analyser = e.context.createAnalyser()),
            (this.analyser.fftSize = t),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            e.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let e = 0;
          const t = this.getFrequencyData();
          for (let n = 0; n < t.length; n++) e += t[n];
          return e / t.length;
        }
      }
      class Wd {
        constructor(e, t, n) {
          (this.binding = e), (this.valueSize = n);
          let i, r, o;
          switch (t) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(n * 6)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(n * 5));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(n * 5));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let o = this.cumulativeWeight;
          if (o === 0) {
            for (let a = 0; a !== i; ++a) n[r + a] = n[a];
            o = t;
          } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, r, 0, a, i);
          }
          this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const c = t * this._origIndex;
            this._mixBufferRegion(n, i, c, 1 - r, t);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let c = t, l = t + t; c !== l; ++c)
            if (n[c] !== n[c + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let r = n, o = i; r !== o; ++r) t[r] = t[i + (r % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
        }
        _slerp(e, t, n, i) {
          lt.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const o = this._workIndex * r;
          lt.multiplyQuaternionsFlat(e, o, e, t, e, n),
            lt.slerpFlat(e, t, e, t, e, o, i);
        }
        _lerp(e, t, n, i, r) {
          const o = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const c = t + a;
            e[c] = e[c] * o + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let o = 0; o !== r; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i;
          }
        }
      }
      const Il = "\\[\\]\\.:\\/",
        mv = new RegExp("[" + Il + "]", "g"),
        Dl = "[^" + Il + "]",
        gv = "[^" + Il.replace("\\.", "") + "]",
        xv = /((?:WC+[\/:])*)/.source.replace("WC", Dl),
        yv = /(WCOD+)?/.source.replace("WCOD", gv),
        vv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dl),
        _v = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dl),
        Mv = new RegExp("^" + xv + yv + vv + _v + "$"),
        wv = ["material", "materials", "bones"];
      class bv {
        constructor(e, t, n) {
          const i = n || De.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }
      class De {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || De.parseTrackName(t)),
            (this.node = De.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new De.Composite(e, t, n)
            : new De(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(mv, "");
        }
        static parseTrackName(e) {
          const t = Mv.exec(e);
          if (!t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            wv.indexOf(r) !== -1 &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
          }
          if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            !t ||
            t === "" ||
            t === "." ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
          }
          if (e.children) {
            const n = function (r) {
                for (let o = 0; o < r.length; o++) {
                  const a = r[o];
                  if (a.name === t || a.uuid === t) return a;
                  const c = n(a.children);
                  if (c) return c;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.node[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = De.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
            return;
          }
          if (n) {
            let l = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!e.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                e = e.skeleton.bones;
                for (let u = 0; u < e.length; u++)
                  if (e[u].name === l) {
                    l = u;
                    break;
                  }
                break;
              default:
                if (e[n] === void 0) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                e = e[n];
            }
            if (l !== void 0) {
              if (e[l] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
                return;
              }
              e = e[l];
            }
          }
          const o = e[i];
          if (o === void 0) {
            const l = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                l +
                "." +
                i +
                " but it wasn't found.",
              e
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            e.needsUpdate !== void 0
              ? (a = this.Versioning.NeedsUpdate)
              : e.matrixWorldNeedsUpdate !== void 0 &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let c = this.BindingType.Direct;
          if (r !== void 0) {
            if (i === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (e.geometry.isBufferGeometry) {
                if (!e.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                e.morphTargetDictionary[r] !== void 0 &&
                  (r = e.morphTargetDictionary[r]);
              } else {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
                return;
              }
            }
            (c = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = r);
          } else
            o.fromArray !== void 0 && o.toArray !== void 0
              ? ((c = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((c = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[c]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[c][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      De.Composite = bv;
      De.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      };
      De.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      };
      De.prototype.GetterByBindingType = [
        De.prototype._getValue_direct,
        De.prototype._getValue_array,
        De.prototype._getValue_arrayElement,
        De.prototype._getValue_toArray,
      ];
      De.prototype.SetterByBindingTypeAndVersioning = [
        [
          De.prototype._setValue_direct,
          De.prototype._setValue_direct_setNeedsUpdate,
          De.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          De.prototype._setValue_array,
          De.prototype._setValue_array_setNeedsUpdate,
          De.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          De.prototype._setValue_arrayElement,
          De.prototype._setValue_arrayElement_setNeedsUpdate,
          De.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          De.prototype._setValue_fromArray,
          De.prototype._setValue_fromArray_setNeedsUpdate,
          De.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ];
      class qd {
        constructor() {
          (this.uuid = At()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          const e = {};
          this._indicesByUUID = e;
          for (let n = 0, i = arguments.length; n !== i; ++n)
            e[arguments[n].uuid] = n;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          const t = this;
          this.stats = {
            objects: {
              get total() {
                return t._objects.length;
              },
              get inUse() {
                return this.total - t.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return t._bindings.length;
            },
          };
        }
        add() {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            r = this._bindings,
            o = r.length;
          let a,
            c = e.length,
            l = this.nCachedObjects_;
          for (let u = 0, h = arguments.length; u !== h; ++u) {
            const d = arguments[u],
              f = d.uuid;
            let p = t[f];
            if (p === void 0) {
              (p = c++), (t[f] = p), e.push(d);
              for (let x = 0, y = o; x !== y; ++x)
                r[x].push(new De(d, n[x], i[x]));
            } else if (p < l) {
              a = e[p];
              const x = --l,
                y = e[x];
              (t[y.uuid] = p), (e[p] = y), (t[f] = x), (e[x] = d);
              for (let m = 0, g = o; m !== g; ++m) {
                const _ = r[m],
                  w = _[x];
                let T = _[p];
                (_[p] = w),
                  T === void 0 && (T = new De(d, n[m], i[m])),
                  (_[x] = T);
              }
            } else
              e[p] !== a &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = l;
        }
        remove() {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_;
          for (let o = 0, a = arguments.length; o !== a; ++o) {
            const c = arguments[o],
              l = c.uuid,
              u = t[l];
            if (u !== void 0 && u >= r) {
              const h = r++,
                d = e[h];
              (t[d.uuid] = u), (e[u] = d), (t[l] = h), (e[h] = c);
              for (let f = 0, p = i; f !== p; ++f) {
                const x = n[f],
                  y = x[h],
                  m = x[u];
                (x[u] = y), (x[h] = m);
              }
            }
          }
          this.nCachedObjects_ = r;
        }
        uncache() {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_,
            o = e.length;
          for (let a = 0, c = arguments.length; a !== c; ++a) {
            const l = arguments[a],
              u = l.uuid,
              h = t[u];
            if (h !== void 0)
              if ((delete t[u], h < r)) {
                const d = --r,
                  f = e[d],
                  p = --o,
                  x = e[p];
                (t[f.uuid] = h),
                  (e[h] = f),
                  (t[x.uuid] = d),
                  (e[d] = x),
                  e.pop();
                for (let y = 0, m = i; y !== m; ++y) {
                  const g = n[y],
                    _ = g[d],
                    w = g[p];
                  (g[h] = _), (g[d] = w), g.pop();
                }
              } else {
                const d = --o,
                  f = e[d];
                d > 0 && (t[f.uuid] = h), (e[h] = f), e.pop();
                for (let p = 0, x = i; p !== x; ++p) {
                  const y = n[p];
                  (y[h] = y[d]), y.pop();
                }
              }
          }
          this.nCachedObjects_ = r;
        }
        subscribe_(e, t) {
          const n = this._bindingsIndicesByPath;
          let i = n[e];
          const r = this._bindings;
          if (i !== void 0) return r[i];
          const o = this._paths,
            a = this._parsedPaths,
            c = this._objects,
            l = c.length,
            u = this.nCachedObjects_,
            h = new Array(l);
          (i = r.length), (n[e] = i), o.push(e), a.push(t), r.push(h);
          for (let d = u, f = c.length; d !== f; ++d) {
            const p = c[d];
            h[d] = new De(p, e, t);
          }
          return h;
        }
        unsubscribe_(e) {
          const t = this._bindingsIndicesByPath,
            n = t[e];
          if (n !== void 0) {
            const i = this._paths,
              r = this._parsedPaths,
              o = this._bindings,
              a = o.length - 1,
              c = o[a],
              l = e[a];
            (t[l] = n),
              (o[n] = c),
              o.pop(),
              (r[n] = r[a]),
              r.pop(),
              (i[n] = i[a]),
              i.pop();
          }
        }
      }
      qd.prototype.isAnimationObjectGroup = !0;
      class Sv {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            o = r.length,
            a = new Array(o),
            c = { endingStart: qn, endingEnd: qn };
          for (let l = 0; l !== o; ++l) {
            const u = r[l].createInterpolant(null);
            (a[l] = u), (u.settings = c);
          }
          (this._interpolantSettings = c),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = Oh),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const i = this._clip.duration,
              r = e._clip.duration,
              o = r / i,
              a = i / r;
            e.warp(1, o, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            e !== null &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            o = this.timeScale;
          let a = this._timeScaleInterpolant;
          a === null &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const c = a.parameterPositions,
            l = a.sampleValues;
          return (
            (c[0] = r), (c[1] = r + n), (l[0] = e / o), (l[1] = t / o), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            e !== null &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const c = (e - r) * n;
            if (c < 0 || n === 0) return;
            (this._startTime = null), (t = n * c);
          }
          t *= this._updateTimeScale(e);
          const o = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const c = this._interpolants,
              l = this._propertyBindings;
            switch (this.blendMode) {
              case qa:
                for (let u = 0, h = c.length; u !== h; ++u)
                  c[u].evaluate(o), l[u].accumulateAdditive(a);
                break;
              case ro:
              default:
                for (let u = 0, h = c.length; u !== h; ++u)
                  c[u].evaluate(o), l[u].accumulate(i, a);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), i === 0 && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            n !== null &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                t === 0 ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const o = n === Uh;
          if (e === 0) return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
          if (n === Gh) {
            r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else if (i < 0) i = 0;
              else {
                this.time = i;
                break e;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (r === -1 &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o))
                  : this._setEndings(this.repetitions === 0, !0, o)),
              i >= t || i < 0)
            ) {
              const a = Math.floor(i / t);
              (i -= t * a), (r += Math.abs(a));
              const c = this.repetitions - r;
              if (c <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (c === 1) {
                  const l = e < 0;
                  this._setEndings(l, !l, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = i;
            if (o && (r & 1) === 1) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = Xn), (i.endingEnd = Xn))
            : (e
                ? (i.endingStart = this.zeroSlopeAtStart ? Xn : qn)
                : (i.endingStart = wr),
              t
                ? (i.endingEnd = this.zeroSlopeAtEnd ? Xn : qn)
                : (i.endingEnd = wr));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let o = this._weightInterpolant;
          o === null &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const a = o.parameterPositions,
            c = o.sampleValues;
          return (a[0] = r), (c[0] = t), (a[1] = r + e), (c[1] = n), this;
        }
      }
      class Xd extends An {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            c = n.uuid,
            l = this._bindingsByRootAndName;
          let u = l[c];
          u === void 0 && ((u = {}), (l[c] = u));
          for (let h = 0; h !== r; ++h) {
            const d = i[h],
              f = d.name;
            let p = u[f];
            if (p !== void 0) o[h] = p;
            else {
              if (((p = o[h]), p !== void 0)) {
                p._cacheIndex === null &&
                  (++p.referenceCount, this._addInactiveBinding(p, c, f));
                continue;
              }
              const x = t && t._propertyBindings[h].binding.parsedPath;
              (p = new Wd(
                De.create(n, f, x),
                d.ValueTypeName,
                d.getValueSize()
              )),
                ++p.referenceCount,
                this._addInactiveBinding(p, c, f),
                (o[h] = p);
            }
            a[h].resultBuffer = p.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const n = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                r = this._actionsByClip[i];
              this._bindAction(e, r && r.knownActions[0]),
                this._addInactiveAction(e, i, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              r.useCount++ === 0 &&
                (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              --r.useCount === 0 &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let o = r[t];
          if (o === void 0)
            (o = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = o);
          else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            o = this._actionsByClip,
            a = o[r],
            c = a.knownActions,
            l = c[c.length - 1],
            u = e._byClipCacheIndex;
          (l._byClipCacheIndex = u),
            (c[u] = l),
            c.pop(),
            (e._byClipCacheIndex = null);
          const h = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
          delete h[d],
            c.length === 0 && delete o[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const r = t[n];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let o = i[t];
          o === void 0 && ((o = {}), (i[t] = o)),
            (o[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            c = t[t.length - 1],
            l = e._cacheIndex;
          (c._cacheIndex = l),
            (t[l] = c),
            t.pop(),
            delete a[r],
            Object.keys(a).length === 0 && delete o[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            n === void 0 &&
              ((n = new fl(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let o = typeof e == "string" ? Hi.findByName(i, e) : e;
          const a = o !== null ? o.uuid : e,
            c = this._actionsByClip[a];
          let l = null;
          if (
            (n === void 0 && (o !== null ? (n = o.blendMode) : (n = ro)),
            c !== void 0)
          ) {
            const h = c.actionByRoot[r];
            if (h !== void 0 && h.blendMode === n) return h;
            (l = c.knownActions[0]), o === null && (o = l._clip);
          }
          if (o === null) return null;
          const u = new Sv(this, o, t, n);
          return this._bindAction(u, l), this._addInactiveAction(u, a, r), u;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = typeof e == "string" ? Hi.findByName(n, e) : e,
            o = r ? r.uuid : e,
            a = this._actionsByClip[o];
          return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions,
            t = this._nActiveActions;
          for (let n = t - 1; n >= 0; --n) e[n].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            o = (this._accuIndex ^= 1);
          for (let l = 0; l !== n; ++l) t[l]._update(i, e, r, o);
          const a = this._bindings,
            c = this._nActiveBindings;
          for (let l = 0; l !== c; ++l) a[l].apply(o);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (r !== void 0) {
            const o = r.knownActions;
            for (let a = 0, c = o.length; a !== c; ++a) {
              const l = o[a];
              this._deactivateAction(l);
              const u = l._cacheIndex,
                h = t[t.length - 1];
              (l._cacheIndex = null),
                (l._byClipCacheIndex = null),
                (h._cacheIndex = u),
                (t[u] = h),
                t.pop(),
                this._removeInactiveBindingsForAction(l);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const o in n) {
            const a = n[o].actionByRoot,
              c = a[t];
            c !== void 0 &&
              (this._deactivateAction(c), this._removeInactiveAction(c));
          }
          const i = this._bindingsByRootAndName,
            r = i[t];
          if (r !== void 0)
            for (const o in r) {
              const a = r[o];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      Xd.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class To {
        constructor(e) {
          typeof e == "string" &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (e = arguments[1])),
            (this.value = e);
        }
        clone() {
          return new To(
            this.value.clone === void 0 ? this.value : this.value.clone()
          );
        }
      }
      class Yd extends Rn {
        constructor(e, t, n = 1) {
          super(e, t), (this.meshPerAttribute = n || 1);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        clone(e) {
          const t = super.clone(e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        }
      }
      Yd.prototype.isInstancedInterleavedBuffer = !0;
      class Zd {
        constructor(e, t, n, i, r) {
          (this.buffer = e),
            (this.type = t),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = r),
            (this.version = 0);
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setBuffer(e) {
          return (this.buffer = e), this;
        }
        setType(e, t) {
          return (this.type = e), (this.elementSize = t), this;
        }
        setItemSize(e) {
          return (this.itemSize = e), this;
        }
        setCount(e) {
          return (this.count = e), this;
        }
      }
      Zd.prototype.isGLBufferAttribute = !0;
      class Tv {
        constructor(e, t, n = 0, i = 1 / 0) {
          (this.ray = new Ln(e, t)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Ka()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            });
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t && t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                .set(e.x, e.y, 0.5)
                .unproject(t)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = t))
            : t && t.isOrthographicCamera
            ? (this.ray.origin
                .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                .unproject(t),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(t.matrixWorld),
              (this.camera = t))
            : console.error(
                "THREE.Raycaster: Unsupported camera type: " + t.type
              );
        }
        intersectObject(e, t = !1, n = []) {
          return Na(e, this, n, t), n.sort(Xc), n;
        }
        intersectObjects(e, t = !1, n = []) {
          for (let i = 0, r = e.length; i < r; i++) Na(e[i], this, n, t);
          return n.sort(Xc), n;
        }
      }
      function Xc(s, e) {
        return s.distance - e.distance;
      }
      function Na(s, e, t, n) {
        if ((s.layers.test(e.layers) && s.raycast(e, t), n === !0)) {
          const i = s.children;
          for (let r = 0, o = i.length; r < o; r++) Na(i[r], e, t, !0);
        }
      }
      class Ev {
        constructor(e = 1, t = 0, n = 0) {
          return (this.radius = e), (this.phi = t), (this.theta = n), this;
        }
        set(e, t, n) {
          return (this.radius = e), (this.phi = t), (this.theta = n), this;
        }
        copy(e) {
          return (
            (this.radius = e.radius),
            (this.phi = e.phi),
            (this.theta = e.theta),
            this
          );
        }
        makeSafe() {
          return (
            (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
            this
          );
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
          return (
            (this.radius = Math.sqrt(e * e + t * t + n * n)),
            this.radius === 0
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(e, n)),
                (this.phi = Math.acos(ut(t / this.radius, -1, 1)))),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Av {
        constructor(e = 1, t = 0, n = 0) {
          return (this.radius = e), (this.theta = t), (this.y = n), this;
        }
        set(e, t, n) {
          return (this.radius = e), (this.theta = t), (this.y = n), this;
        }
        copy(e) {
          return (
            (this.radius = e.radius),
            (this.theta = e.theta),
            (this.y = e.y),
            this
          );
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
          return (
            (this.radius = Math.sqrt(e * e + n * n)),
            (this.theta = Math.atan2(e, n)),
            (this.y = t),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Yc = new q();
      class Ki {
        constructor(e = new q(1 / 0, 1 / 0), t = new q(-1 / 0, -1 / 0)) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Yc.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box2: .getCenter() target is now required"),
              (e = new q())),
            this.isEmpty()
              ? e.set(0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        }
        getSize(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box2: .getSize() target is now required"),
              (e = new q())),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
          );
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
          );
        }
        getParameter(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Box2: .getParameter() target is now required"
              ),
              (t = new q())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y)
            )
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y
          );
        }
        clampPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Box2: .clampPoint() target is now required"),
              (t = new q())),
            t.copy(e).clamp(this.min, this.max)
          );
        }
        distanceToPoint(e) {
          return Yc.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      Ki.prototype.isBox2 = !0;
      const Zc = new M(),
        Ps = new M();
      class Jd {
        constructor(e = new M(), t = new M()) {
          (this.start = e), (this.end = t);
        }
        set(e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Line3: .getCenter() target is now required"),
              (e = new M())),
            e.addVectors(this.start, this.end).multiplyScalar(0.5)
          );
        }
        delta(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Line3: .delta() target is now required"),
              (e = new M())),
            e.subVectors(this.end, this.start)
          );
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Line3: .at() target is now required"),
              (t = new M())),
            this.delta(t).multiplyScalar(e).add(this.start)
          );
        }
        closestPointToPointParameter(e, t) {
          Zc.subVectors(e, this.start), Ps.subVectors(this.end, this.start);
          const n = Ps.dot(Ps);
          let r = Ps.dot(Zc) / n;
          return t && (r = ut(r, 0, 1)), r;
        }
        closestPointToPoint(e, t, n) {
          const i = this.closestPointToPointParameter(e, t);
          return (
            n === void 0 &&
              (console.warn(
                "THREE.Line3: .closestPointToPoint() target is now required"
              ),
              (n = new M())),
            this.delta(n).multiplyScalar(i).add(this.start)
          );
        }
        applyMatrix4(e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class jd extends Ee {
        constructor(e) {
          super(),
            (this.material = e),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0);
        }
      }
      jd.prototype.isImmediateRenderObject = !0;
      const Jc = new M();
      class Lv extends Ee {
        constructor(e, t) {
          super(),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = t);
          const n = new de(),
            i = [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, -1, 1,
            ];
          for (let o = 0, a = 1, c = 32; o < c; o++, a++) {
            const l = (o / c) * Math.PI * 2,
              u = (a / c) * Math.PI * 2;
            i.push(Math.cos(l), Math.sin(l), 1, Math.cos(u), Math.sin(u), 1);
          }
          n.setAttribute("position", new le(i, 3));
          const r = new st({ fog: !1, toneMapped: !1 });
          (this.cone = new Mt(n, r)), this.add(this.cone), this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
          this.cone.scale.set(t, t, e),
            Jc.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(Jc),
            this.color !== void 0
              ? this.cone.material.color.set(this.color)
              : this.cone.material.color.copy(this.light.color);
        }
      }
      const xn = new M(),
        Is = new ce(),
        sa = new ce();
      class Kd extends Mt {
        constructor(e) {
          const t = $d(e),
            n = new de(),
            i = [],
            r = [],
            o = new K(0, 0, 1),
            a = new K(0, 1, 0);
          for (let l = 0; l < t.length; l++) {
            const u = t[l];
            u.parent &&
              u.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(o.r, o.g, o.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new le(i, 3)),
            n.setAttribute("color", new le(r, 3));
          const c = new st({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, c),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          sa.copy(this.root.matrixWorld).invert();
          for (let r = 0, o = 0; r < t.length; r++) {
            const a = t[r];
            a.parent &&
              a.parent.isBone &&
              (Is.multiplyMatrices(sa, a.matrixWorld),
              xn.setFromMatrixPosition(Is),
              i.setXYZ(o, xn.x, xn.y, xn.z),
              Is.multiplyMatrices(sa, a.parent.matrixWorld),
              xn.setFromMatrixPosition(Is),
              i.setXYZ(o + 1, xn.x, xn.y, xn.z),
              (o += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }
      function $d(s) {
        const e = [];
        s && s.isBone && e.push(s);
        for (let t = 0; t < s.children.length; t++)
          e.push.apply(e, $d(s.children[t]));
        return e;
      }
      class Rv extends $e {
        constructor(e, t, n) {
          const i = new Cr(t, 4, 2),
            r = new bt({ wireframe: !0, fog: !1, toneMapped: !1 });
          super(i, r),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.color = n),
            (this.type = "PointLightHelper"),
            (this.matrix = this.light.matrixWorld),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          this.color !== void 0
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        }
      }
      const Cv = new M(),
        jc = new K(),
        Kc = new K();
      class Pv extends Ee {
        constructor(e, t, n) {
          super(),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n);
          const i = new Lr(t);
          i.rotateY(Math.PI * 0.5),
            (this.material = new bt({
              wireframe: !0,
              fog: !1,
              toneMapped: !1,
            })),
            this.color === void 0 && (this.material.vertexColors = !0);
          const r = i.getAttribute("position"),
            o = new Float32Array(r.count * 3);
          i.setAttribute("color", new be(o, 3)),
            this.add(new $e(i, this.material)),
            this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }
        update() {
          const e = this.children[0];
          if (this.color !== void 0) this.material.color.set(this.color);
          else {
            const t = e.geometry.getAttribute("color");
            jc.copy(this.light.color), Kc.copy(this.light.groundColor);
            for (let n = 0, i = t.count; n < i; n++) {
              const r = n < i / 2 ? jc : Kc;
              t.setXYZ(n, r.r, r.g, r.b);
            }
            t.needsUpdate = !0;
          }
          e.lookAt(Cv.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class Qd extends Mt {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new K(n)), (i = new K(i));
          const r = t / 2,
            o = e / t,
            a = e / 2,
            c = [],
            l = [];
          for (let d = 0, f = 0, p = -a; d <= t; d++, p += o) {
            c.push(-a, 0, p, a, 0, p), c.push(p, 0, -a, p, 0, a);
            const x = d === r ? n : i;
            x.toArray(l, f),
              (f += 3),
              x.toArray(l, f),
              (f += 3),
              x.toArray(l, f),
              (f += 3),
              x.toArray(l, f),
              (f += 3);
          }
          const u = new de();
          u.setAttribute("position", new le(c, 3)),
            u.setAttribute("color", new le(l, 3));
          const h = new st({ vertexColors: !0, toneMapped: !1 });
          super(u, h), (this.type = "GridHelper");
        }
      }
      class Iv extends Mt {
        constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, o = 8947848) {
          (r = new K(r)), (o = new K(o));
          const a = [],
            c = [];
          for (let h = 0; h <= t; h++) {
            const d = (h / t) * (Math.PI * 2),
              f = Math.sin(d) * e,
              p = Math.cos(d) * e;
            a.push(0, 0, 0), a.push(f, 0, p);
            const x = h & 1 ? r : o;
            c.push(x.r, x.g, x.b), c.push(x.r, x.g, x.b);
          }
          for (let h = 0; h <= n; h++) {
            const d = h & 1 ? r : o,
              f = e - (e / n) * h;
            for (let p = 0; p < i; p++) {
              let x = (p / i) * (Math.PI * 2),
                y = Math.sin(x) * f,
                m = Math.cos(x) * f;
              a.push(y, 0, m),
                c.push(d.r, d.g, d.b),
                (x = ((p + 1) / i) * (Math.PI * 2)),
                (y = Math.sin(x) * f),
                (m = Math.cos(x) * f),
                a.push(y, 0, m),
                c.push(d.r, d.g, d.b);
            }
          }
          const l = new de();
          l.setAttribute("position", new le(a, 3)),
            l.setAttribute("color", new le(c, 3));
          const u = new st({ vertexColors: !0, toneMapped: !1 });
          super(l, u), (this.type = "PolarGridHelper");
        }
      }
      const $c = new M(),
        Ds = new M(),
        Qc = new M();
      class Dv extends Ee {
        constructor(e, t, n) {
          super(),
            (this.light = e),
            this.light.updateMatrixWorld(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n),
            t === void 0 && (t = 1);
          let i = new de();
          i.setAttribute(
            "position",
            new le([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
          );
          const r = new st({ fog: !1, toneMapped: !1 });
          (this.lightPlane = new Xt(i, r)),
            this.add(this.lightPlane),
            (i = new de()),
            i.setAttribute("position", new le([0, 0, 0, 0, 0, 1], 3)),
            (this.targetLine = new Xt(i, r)),
            this.add(this.targetLine),
            this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }
        update() {
          $c.setFromMatrixPosition(this.light.matrixWorld),
            Ds.setFromMatrixPosition(this.light.target.matrixWorld),
            Qc.subVectors(Ds, $c),
            this.lightPlane.lookAt(Ds),
            this.color !== void 0
              ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color))
              : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(Ds),
            (this.targetLine.scale.z = Qc.length());
        }
      }
      const Fs = new M(),
        qe = new Gr();
      class Fv extends Mt {
        constructor(e) {
          const t = new de(),
            n = new st({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
            i = [],
            r = [],
            o = {},
            a = new K(16755200),
            c = new K(16711680),
            l = new K(43775),
            u = new K(16777215),
            h = new K(3355443);
          d("n1", "n2", a),
            d("n2", "n4", a),
            d("n4", "n3", a),
            d("n3", "n1", a),
            d("f1", "f2", a),
            d("f2", "f4", a),
            d("f4", "f3", a),
            d("f3", "f1", a),
            d("n1", "f1", a),
            d("n2", "f2", a),
            d("n3", "f3", a),
            d("n4", "f4", a),
            d("p", "n1", c),
            d("p", "n2", c),
            d("p", "n3", c),
            d("p", "n4", c),
            d("u1", "u2", l),
            d("u2", "u3", l),
            d("u3", "u1", l),
            d("c", "t", u),
            d("p", "c", h),
            d("cn1", "cn2", h),
            d("cn3", "cn4", h),
            d("cf1", "cf2", h),
            d("cf3", "cf4", h);
          function d(p, x, y) {
            f(p, y), f(x, y);
          }
          function f(p, x) {
            i.push(0, 0, 0),
              r.push(x.r, x.g, x.b),
              o[p] === void 0 && (o[p] = []),
              o[p].push(i.length / 3 - 1);
          }
          t.setAttribute("position", new le(i, 3)),
            t.setAttribute("color", new le(r, 3)),
            super(t, n),
            (this.type = "CameraHelper"),
            (this.camera = e),
            this.camera.updateProjectionMatrix &&
              this.camera.updateProjectionMatrix(),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.pointMap = o),
            this.update();
        }
        update() {
          const e = this.geometry,
            t = this.pointMap,
            n = 1,
            i = 1;
          qe.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            Ze("c", t, e, qe, 0, 0, -1),
            Ze("t", t, e, qe, 0, 0, 1),
            Ze("n1", t, e, qe, -n, -i, -1),
            Ze("n2", t, e, qe, n, -i, -1),
            Ze("n3", t, e, qe, -n, i, -1),
            Ze("n4", t, e, qe, n, i, -1),
            Ze("f1", t, e, qe, -n, -i, 1),
            Ze("f2", t, e, qe, n, -i, 1),
            Ze("f3", t, e, qe, -n, i, 1),
            Ze("f4", t, e, qe, n, i, 1),
            Ze("u1", t, e, qe, n * 0.7, i * 1.1, -1),
            Ze("u2", t, e, qe, -n * 0.7, i * 1.1, -1),
            Ze("u3", t, e, qe, 0, i * 2, -1),
            Ze("cf1", t, e, qe, -n, 0, 1),
            Ze("cf2", t, e, qe, n, 0, 1),
            Ze("cf3", t, e, qe, 0, -i, 1),
            Ze("cf4", t, e, qe, 0, i, 1),
            Ze("cn1", t, e, qe, -n, 0, -1),
            Ze("cn2", t, e, qe, n, 0, -1),
            Ze("cn3", t, e, qe, 0, -i, -1),
            Ze("cn4", t, e, qe, 0, i, -1),
            (e.getAttribute("position").needsUpdate = !0);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      function Ze(s, e, t, n, i, r, o) {
        Fs.set(i, r, o).unproject(n);
        const a = e[s];
        if (a !== void 0) {
          const c = t.getAttribute("position");
          for (let l = 0, u = a.length; l < u; l++)
            c.setXYZ(a[l], Fs.x, Fs.y, Fs.z);
        }
      }
      const Bs = new wt();
      class ef extends Mt {
        constructor(e, t = 16776960) {
          const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            i = new Float32Array(8 * 3),
            r = new de();
          r.setIndex(new be(n, 1)),
            r.setAttribute("position", new be(i, 3)),
            super(r, new st({ color: t, toneMapped: !1 })),
            (this.object = e),
            (this.type = "BoxHelper"),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        update(e) {
          if (
            (e !== void 0 &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            this.object !== void 0 && Bs.setFromObject(this.object),
            Bs.isEmpty())
          )
            return;
          const t = Bs.min,
            n = Bs.max,
            i = this.geometry.attributes.position,
            r = i.array;
          (r[0] = n.x),
            (r[1] = n.y),
            (r[2] = n.z),
            (r[3] = t.x),
            (r[4] = n.y),
            (r[5] = n.z),
            (r[6] = t.x),
            (r[7] = t.y),
            (r[8] = n.z),
            (r[9] = n.x),
            (r[10] = t.y),
            (r[11] = n.z),
            (r[12] = n.x),
            (r[13] = n.y),
            (r[14] = t.z),
            (r[15] = t.x),
            (r[16] = n.y),
            (r[17] = t.z),
            (r[18] = t.x),
            (r[19] = t.y),
            (r[20] = t.z),
            (r[21] = n.x),
            (r[22] = t.y),
            (r[23] = t.z),
            (i.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
        setFromObject(e) {
          return (this.object = e), this.update(), this;
        }
        copy(e) {
          return (
            Mt.prototype.copy.call(this, e), (this.object = e.object), this
          );
        }
      }
      class Bv extends Mt {
        constructor(e, t = 16776960) {
          const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            i = [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
              -1, -1, 1, -1, -1,
            ],
            r = new de();
          r.setIndex(new be(n, 1)),
            r.setAttribute("position", new le(i, 3)),
            super(r, new st({ color: t, toneMapped: !1 })),
            (this.box = e),
            (this.type = "Box3Helper"),
            this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(e) {
          const t = this.box;
          t.isEmpty() ||
            (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            super.updateMatrixWorld(e));
        }
      }
      class Nv extends Xt {
        constructor(e, t = 1, n = 16776960) {
          const i = n,
            r = [
              1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
              -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
            ],
            o = new de();
          o.setAttribute("position", new le(r, 3)),
            o.computeBoundingSphere(),
            super(o, new st({ color: i, toneMapped: !1 })),
            (this.type = "PlaneHelper"),
            (this.plane = e),
            (this.size = t);
          const a = [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1,
            ],
            c = new de();
          c.setAttribute("position", new le(a, 3)),
            c.computeBoundingSphere(),
            this.add(
              new $e(
                c,
                new bt({
                  color: i,
                  opacity: 0.2,
                  transparent: !0,
                  depthWrite: !1,
                  toneMapped: !1,
                })
              )
            );
        }
        updateMatrixWorld(e) {
          let t = -this.plane.constant;
          Math.abs(t) < 1e-8 && (t = 1e-8),
            this.scale.set(0.5 * this.size, 0.5 * this.size, t),
            (this.children[0].material.side = t < 0 ? Qe : jn),
            this.lookAt(this.plane.normal),
            super.updateMatrixWorld(e);
        }
      }
      const eu = new M();
      let Ns, oa;
      class Gv extends Ee {
        constructor(
          e = new M(0, 0, 1),
          t = new M(0, 0, 0),
          n = 1,
          i = 16776960,
          r = n * 0.2,
          o = r * 0.2
        ) {
          super(),
            (this.type = "ArrowHelper"),
            Ns === void 0 &&
              ((Ns = new de()),
              Ns.setAttribute("position", new le([0, 0, 0, 0, 1, 0], 3)),
              (oa = new Oi(0, 0.5, 1, 5, 1)),
              oa.translate(0, -0.5, 0)),
            this.position.copy(t),
            (this.line = new Xt(Ns, new st({ color: i, toneMapped: !1 }))),
            (this.line.matrixAutoUpdate = !1),
            this.add(this.line),
            (this.cone = new $e(oa, new bt({ color: i, toneMapped: !1 }))),
            (this.cone.matrixAutoUpdate = !1),
            this.add(this.cone),
            this.setDirection(e),
            this.setLength(n, r, o);
        }
        setDirection(e) {
          if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
          else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
          else {
            eu.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(eu, t);
          }
        }
        setLength(e, t = e * 0.2, n = t * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, t, n),
            (this.cone.position.y = e),
            this.cone.updateMatrix();
        }
        setColor(e) {
          this.line.material.color.set(e), this.cone.material.color.set(e);
        }
        copy(e) {
          return (
            super.copy(e, !1),
            this.line.copy(e.line),
            this.cone.copy(e.cone),
            this
          );
        }
      }
      class tf extends Mt {
        constructor(e = 1) {
          const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            i = new de();
          i.setAttribute("position", new le(t, 3)),
            i.setAttribute("color", new le(n, 3));
          const r = new st({ vertexColors: !0, toneMapped: !1 });
          super(i, r), (this.type = "AxesHelper");
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      const nf = new Float32Array(1),
        Ov = new Int32Array(nf.buffer);
      class Uv {
        static toHalfFloat(e) {
          nf[0] = e;
          const t = Ov[0];
          let n = (t >> 16) & 32768,
            i = (t >> 12) & 2047;
          const r = (t >> 23) & 255;
          return r < 103
            ? n
            : r > 142
            ? ((n |= 31744), (n |= (r == 255 ? 0 : 1) && t & 8388607), n)
            : r < 113
            ? ((i |= 2048), (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), n)
            : ((n |= ((r - 112) << 10) | (i >> 1)), (n += i & 1), n);
        }
      }
      const Ci = 4,
        wn = 8,
        kt = Math.pow(2, wn),
        rf = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        sf = wn - Ci + 1 + rf.length,
        Si = 20,
        Wt = { [vt]: 0, [$n]: 1, [oo]: 2, [Ya]: 3, [Za]: 4, [Ja]: 5, [so]: 6 },
        Hn = new bt({ side: Qe, depthWrite: !1, depthTest: !1 }),
        zv = new $e(new Qn(), Hn),
        aa = new ji(),
        { _lodPlanes: cr, _sizeLods: tu, _sigmas: Gs } = Vv(),
        nu = new K();
      let la = null;
      const kn = (1 + Math.sqrt(5)) / 2,
        Ti = 1 / kn,
        iu = [
          new M(1, 1, 1),
          new M(-1, 1, 1),
          new M(1, 1, -1),
          new M(-1, 1, -1),
          new M(0, kn, Ti),
          new M(0, kn, -Ti),
          new M(Ti, 0, kn),
          new M(-Ti, 0, kn),
          new M(kn, Ti, 0),
          new M(-kn, Ti, 0),
        ];
      function ru(s) {
        const e = Math.max(s.r, s.g, s.b),
          t = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
        return s.multiplyScalar(Math.pow(2, -t)), (t + 128) / 255;
      }
      class Hv {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._blurMaterial = Wv(Si)),
            (this._equirectShader = null),
            (this._cubemapShader = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          la = this._renderer.getRenderTarget();
          const r = this._allocateTargets();
          return (
            this._sceneToCubeUV(e, n, i, r),
            t > 0 && this._blur(r, 0, 0, t),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(e) {
          return this._fromTexture(e);
        }
        fromCubemap(e) {
          return this._fromTexture(e);
        }
        compileCubemapShader() {
          this._cubemapShader === null &&
            ((this._cubemapShader = au()),
            this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
          this._equirectShader === null &&
            ((this._equirectShader = ou()),
            this._compileMaterial(this._equirectShader));
        }
        dispose() {
          this._blurMaterial.dispose(),
            this._cubemapShader !== null && this._cubemapShader.dispose(),
            this._equirectShader !== null && this._equirectShader.dispose();
          for (let e = 0; e < cr.length; e++) cr[e].dispose();
        }
        _cleanup(e) {
          this._pingPongRenderTarget.dispose(),
            this._renderer.setRenderTarget(la),
            (e.scissorTest = !1),
            Os(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e) {
          la = this._renderer.getRenderTarget();
          const t = this._allocateTargets(e);
          return (
            this._textureToCubeUV(e, t),
            this._applyPMREM(t),
            this._cleanup(t),
            t
          );
        }
        _allocateTargets(e) {
          const t = {
              magFilter: Je,
              minFilter: Je,
              generateMipmaps: !1,
              type: qi,
              format: eh,
              encoding: kv(e) ? e.encoding : oo,
              depthBuffer: !1,
            },
            n = su(t);
          return (n.depthBuffer = !e), (this._pingPongRenderTarget = su(t)), n;
        }
        _compileMaterial(e) {
          const t = new $e(cr[0], e);
          this._renderer.compile(t, aa);
        }
        _sceneToCubeUV(e, t, n, i) {
          const a = new nt(90, 1, t, n),
            c = [1, -1, 1, 1, 1, 1],
            l = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            h = u.autoClear,
            d = u.outputEncoding,
            f = u.toneMapping;
          u.getClearColor(nu),
            (u.toneMapping = Yn),
            (u.outputEncoding = vt),
            (u.autoClear = !1);
          let p = !1;
          const x = e.background;
          if (x) {
            if (x.isColor) {
              Hn.color.copy(x).convertSRGBToLinear(), (e.background = null);
              const y = ru(Hn.color);
              (Hn.opacity = y), (p = !0);
            }
          } else {
            Hn.color.copy(nu).convertSRGBToLinear();
            const y = ru(Hn.color);
            (Hn.opacity = y), (p = !0);
          }
          for (let y = 0; y < 6; y++) {
            const m = y % 3;
            m == 0
              ? (a.up.set(0, c[y], 0), a.lookAt(l[y], 0, 0))
              : m == 1
              ? (a.up.set(0, 0, c[y]), a.lookAt(0, l[y], 0))
              : (a.up.set(0, c[y], 0), a.lookAt(0, 0, l[y])),
              Os(i, m * kt, y > 2 ? kt : 0, kt, kt),
              u.setRenderTarget(i),
              p && u.render(zv, a),
              u.render(e, a);
          }
          (u.toneMapping = f), (u.outputEncoding = d), (u.autoClear = h);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer;
          e.isCubeTexture
            ? this._cubemapShader == null && (this._cubemapShader = au())
            : this._equirectShader == null && (this._equirectShader = ou());
          const i = e.isCubeTexture
              ? this._cubemapShader
              : this._equirectShader,
            r = new $e(cr[0], i),
            o = i.uniforms;
          (o.envMap.value = e),
            e.isCubeTexture ||
              o.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
            (o.inputEncoding.value = Wt[e.encoding]),
            (o.outputEncoding.value = Wt[t.texture.encoding]),
            Os(t, 0, 0, 3 * kt, 2 * kt),
            n.setRenderTarget(t),
            n.render(r, aa);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          for (let i = 1; i < sf; i++) {
            const r = Math.sqrt(Gs[i] * Gs[i] - Gs[i - 1] * Gs[i - 1]),
              o = iu[(i - 1) % iu.length];
            this._blur(e, i - 1, i, r, o);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, r) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(e, o, t, n, i, "latitudinal", r),
            this._halfBlur(o, e, n, n, i, "longitudinal", r);
        }
        _halfBlur(e, t, n, i, r, o, a) {
          const c = this._renderer,
            l = this._blurMaterial;
          o !== "latitudinal" &&
            o !== "longitudinal" &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const u = 3,
            h = new $e(cr[i], l),
            d = l.uniforms,
            f = tu[n] - 1,
            p = isFinite(r) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * Si - 1),
            x = r / p,
            y = isFinite(r) ? 1 + Math.floor(u * x) : Si;
          y > Si &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Si}`
            );
          const m = [];
          let g = 0;
          for (let v = 0; v < Si; ++v) {
            const A = v / x,
              L = Math.exp((-A * A) / 2);
            m.push(L), v == 0 ? (g += L) : v < y && (g += 2 * L);
          }
          for (let v = 0; v < m.length; v++) m[v] = m[v] / g;
          (d.envMap.value = e.texture),
            (d.samples.value = y),
            (d.weights.value = m),
            (d.latitudinal.value = o === "latitudinal"),
            a && (d.poleAxis.value = a),
            (d.dTheta.value = p),
            (d.mipInt.value = wn - n),
            (d.inputEncoding.value = Wt[e.texture.encoding]),
            (d.outputEncoding.value = Wt[e.texture.encoding]);
          const _ = tu[i],
            w = 3 * Math.max(0, kt - 2 * _),
            T =
              (i === 0 ? 0 : 2 * kt) + 2 * _ * (i > wn - Ci ? i - wn + Ci : 0);
          Os(t, w, T, 3 * _, 2 * _), c.setRenderTarget(t), c.render(h, aa);
        }
      }
      function kv(s) {
        return s === void 0 || s.type !== qi
          ? !1
          : s.encoding === vt || s.encoding === $n || s.encoding === so;
      }
      function Vv() {
        const s = [],
          e = [],
          t = [];
        let n = wn;
        for (let i = 0; i < sf; i++) {
          const r = Math.pow(2, n);
          e.push(r);
          let o = 1 / r;
          i > wn - Ci ? (o = rf[i - wn + Ci - 1]) : i == 0 && (o = 0),
            t.push(o);
          const a = 1 / (r - 1),
            c = -a / 2,
            l = 1 + a / 2,
            u = [c, c, l, c, l, l, c, c, l, l, c, l],
            h = 6,
            d = 6,
            f = 3,
            p = 2,
            x = 1,
            y = new Float32Array(f * d * h),
            m = new Float32Array(p * d * h),
            g = new Float32Array(x * d * h);
          for (let w = 0; w < h; w++) {
            const T = ((w % 3) * 2) / 3 - 1,
              v = w > 2 ? 0 : -1,
              A = [
                T,
                v,
                0,
                T + 2 / 3,
                v,
                0,
                T + 2 / 3,
                v + 1,
                0,
                T,
                v,
                0,
                T + 2 / 3,
                v + 1,
                0,
                T,
                v + 1,
                0,
              ];
            y.set(A, f * d * w), m.set(u, p * d * w);
            const L = [w, w, w, w, w, w];
            g.set(L, x * d * w);
          }
          const _ = new de();
          _.setAttribute("position", new be(y, f)),
            _.setAttribute("uv", new be(m, p)),
            _.setAttribute("faceIndex", new be(g, x)),
            s.push(_),
            n > Ci && n--;
        }
        return { _lodPlanes: s, _sizeLods: e, _sigmas: t };
      }
      function su(s) {
        const e = new Ot(3 * kt, 3 * kt, s);
        return (
          (e.texture.mapping = Wi),
          (e.texture.name = "PMREM.cubeUv"),
          (e.scissorTest = !0),
          e
        );
      }
      function Os(s, e, t, n, i) {
        s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
      }
      function Wv(s) {
        const e = new Float32Array(s),
          t = new M(0, 1, 0);
        return new Ji({
          name: "SphericalGaussianBlur",
          defines: { n: s },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: e },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: t },
            inputEncoding: { value: Wt[vt] },
            outputEncoding: { value: Wt[vt] },
          },
          vertexShader: Fl(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Bl()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: nn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ou() {
        const s = new q(1, 1);
        return new Ji({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: { value: null },
            texelSize: { value: s },
            inputEncoding: { value: Wt[vt] },
            outputEncoding: { value: Wt[vt] },
          },
          vertexShader: Fl(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Bl()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: nn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function au() {
        return new Ji({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: { value: null },
            inputEncoding: { value: Wt[vt] },
            outputEncoding: { value: Wt[vt] },
          },
          vertexShader: Fl(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Bl()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: nn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Fl() {
        return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function Bl() {
        return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
      }
      const qv = 0,
        Xv = 1,
        Yv = 0,
        Zv = 1,
        Jv = 2;
      function jv(s) {
        return (
          console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
          ),
          s
        );
      }
      function Kv(s = []) {
        return (
          console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
          ),
          (s.isMultiMaterial = !0),
          (s.materials = s),
          (s.clone = function () {
            return s.slice();
          }),
          s
        );
      }
      function $v(s, e) {
        return (
          console.warn("THREE.PointCloud has been renamed to THREE.Points."),
          new Zi(s, e)
        );
      }
      function Qv(s) {
        return (
          console.warn("THREE.Particle has been renamed to THREE.Sprite."),
          new mo(s)
        );
      }
      function e0(s, e) {
        return (
          console.warn(
            "THREE.ParticleSystem has been renamed to THREE.Points."
          ),
          new Zi(s, e)
        );
      }
      function t0(s) {
        return (
          console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Cn(s)
        );
      }
      function n0(s) {
        return (
          console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Cn(s)
        );
      }
      function i0(s) {
        return (
          console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Cn(s)
        );
      }
      function r0(s, e, t) {
        return (
          console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
          ),
          new M(s, e, t)
        );
      }
      function s0(s, e) {
        return (
          console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
          ),
          new be(s, e).setUsage(Bi)
        );
      }
      function o0(s, e) {
        return (
          console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
          ),
          new $h(s, e)
        );
      }
      function a0(s, e) {
        return (
          console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
          ),
          new Qh(s, e)
        );
      }
      function l0(s, e) {
        return (
          console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
          ),
          new ed(s, e)
        );
      }
      function c0(s, e) {
        return (
          console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
          ),
          new td(s, e)
        );
      }
      function u0(s, e) {
        return (
          console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
          ),
          new ao(s, e)
        );
      }
      function h0(s, e) {
        return (
          console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
          ),
          new nd(s, e)
        );
      }
      function d0(s, e) {
        return (
          console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
          ),
          new lo(s, e)
        );
      }
      function f0(s, e) {
        return (
          console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
          ),
          new le(s, e)
        );
      }
      function p0(s, e) {
        return (
          console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
          ),
          new rd(s, e)
        );
      }
      Lt.create = function (s, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (s.prototype = Object.create(Lt.prototype)),
          (s.prototype.constructor = s),
          (s.prototype.getPoint = e),
          s
        );
      };
      Pr.prototype.fromPoints = function (s) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(s)
        );
      };
      function m0(s) {
        return (
          console.warn(
            "THREE.AxisHelper has been renamed to THREE.AxesHelper."
          ),
          new tf(s)
        );
      }
      function g0(s, e) {
        return (
          console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
          ),
          new ef(s, e)
        );
      }
      function x0(s, e) {
        return (
          console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
          ),
          new Mt(
            new rl(s.geometry),
            new st({ color: e !== void 0 ? e : 16777215 })
          )
        );
      }
      Qd.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      };
      Kd.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      };
      function y0(s, e) {
        return (
          console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
          ),
          new Mt(
            new sl(s.geometry),
            new st({ color: e !== void 0 ? e : 16777215 })
          )
        );
      }
      ht.prototype.extractUrlBase = function (s) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Mn.extractUrlBase(s)
        );
      };
      ht.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      };
      function v0(s) {
        return (
          console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
          new Ct(s)
        );
      }
      function _0(s) {
        return (
          console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
          ),
          new Cd(s)
        );
      }
      Ki.prototype.center = function (s) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(s)
        );
      };
      Ki.prototype.empty = function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      Ki.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      Ki.prototype.size = function (s) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(s)
        );
      };
      wt.prototype.center = function (s) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(s)
        );
      };
      wt.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      wt.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      wt.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      wt.prototype.size = function (s) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(s)
        );
      };
      cn.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      };
      Or.prototype.setFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(s)
        );
      };
      Jd.prototype.center = function (s) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(s)
        );
      };
      it.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      it.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      it.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      };
      it.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      it.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      };
      it.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      ce.prototype.extractPosition = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(s)
        );
      };
      ce.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      ce.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new M().setFromMatrixColumn(this, 3)
        );
      };
      ce.prototype.setRotationFromQuaternion = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(s)
        );
      };
      ce.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      ce.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      ce.prototype.multiplyVector4 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      ce.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      };
      ce.prototype.rotateAxis = function (s) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          s.transformDirection(this);
      };
      ce.prototype.crossVector = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      ce.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      ce.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      ce.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      ce.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      ce.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      ce.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      ce.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      };
      ce.prototype.makeFrustum = function (s, e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(s, e, n, t, i, r)
        );
      };
      ce.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      Nt.prototype.isIntersectionLine = function (s) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(s)
        );
      };
      lt.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          s.applyQuaternion(this)
        );
      };
      lt.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      };
      Ln.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      Ln.prototype.isIntersectionPlane = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(s)
        );
      };
      Ln.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      je.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      };
      je.prototype.barycoordFromPoint = function (s, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(s, e)
        );
      };
      je.prototype.midpoint = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(s)
        );
      };
      je.prototypenormal = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(s)
        );
      };
      je.prototype.plane = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(s)
        );
      };
      je.barycoordFromPoint = function (s, e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          je.getBarycoord(s, e, t, n, i)
        );
      };
      je.normal = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          je.getNormal(s, e, t, n)
        );
      };
      _n.prototype.extractAllPoints = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(s)
        );
      };
      _n.prototype.extrude = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new an(this, s)
        );
      };
      _n.prototype.makeGeometry = function (s) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new Rr(this, s)
        );
      };
      q.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      q.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      q.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      M.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      };
      M.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      };
      M.prototype.getPositionFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(s)
        );
      };
      M.prototype.getScaleFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(s)
        );
      };
      M.prototype.getColumnFromMatrix = function (s, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, s)
        );
      };
      M.prototype.applyProjection = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(s)
        );
      };
      M.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      M.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      M.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Ge.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      Ge.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Ee.prototype.getChildByName = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(s)
        );
      };
      Ee.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      };
      Ee.prototype.translate = function (s, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, s)
        );
      };
      Ee.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      };
      Ee.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(Ee.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (s) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = s);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      $e.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      };
      Object.defineProperties($e.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              zh
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      });
      kr.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      nt.prototype.setLens = function (s, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          e !== void 0 && (this.filmGauge = e),
          this.setFocalLength(s);
      };
      Object.defineProperties(Ut.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = s);
          },
        },
        shadowCameraLeft: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = s);
          },
        },
        shadowCameraRight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = s);
          },
        },
        shadowCameraTop: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = s);
          },
        },
        shadowCameraBottom: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = s);
          },
        },
        shadowCameraNear: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = s);
          },
        },
        shadowCameraFar: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = s);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (s) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = s);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = s);
          },
        },
        shadowMapHeight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = s);
          },
        },
      });
      Object.defineProperties(be.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === Bi
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(Bi);
          },
        },
      });
      be.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? Bi : Fi),
          this
        );
      };
      (be.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
        (be.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        });
      de.prototype.addIndex = function (s) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(s);
      };
      de.prototype.addAttribute = function (s, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(s, new be(arguments[1], arguments[2])))
            : s === "index"
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(s, e)
        );
      };
      de.prototype.addDrawCall = function (s, e, t) {
        t !== void 0 &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(s, e);
      };
      de.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      };
      de.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      };
      de.prototype.removeAttribute = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(s)
        );
      };
      de.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(de.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      });
      Rn.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? Bi : Fi),
          this
        );
      };
      Rn.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      };
      an.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      an.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      };
      an.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Hr.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      To.prototype.onUpdate = function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      };
      Object.defineProperties(et.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new K()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = s === ka);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = s);
          },
        },
      });
      Object.defineProperties(sn.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (s) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = s);
          },
        },
      });
      Ue.prototype.clearTarget = function (s, e, t, n) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(s),
          this.clear(e, t, n);
      };
      Ue.prototype.animate = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(s);
      };
      Ue.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      };
      Ue.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      };
      Ue.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      };
      Ue.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      };
      Ue.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      };
      Ue.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      };
      Ue.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      };
      Ue.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      };
      Ue.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      };
      Ue.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      };
      Ue.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      };
      Ue.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      };
      Ue.prototype.enableScissorTest = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(s);
      };
      Ue.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      Ue.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      Ue.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      Ue.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      };
      Ue.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      };
      Ue.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      };
      Ue.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      Ue.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      Ue.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      };
      Ue.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      };
      Object.defineProperties(Ue.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = s);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = s);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = s === !0 ? $n : vt);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      });
      Object.defineProperties(md.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      });
      function M0(s, e, t) {
        return (
          console.warn(
            "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
          ),
          new uo(s, t)
        );
      }
      Object.defineProperties(Ot.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = s);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = s);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = s);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = s);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = s);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = s);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = s);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = s);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = s);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = s);
          },
        },
      });
      Pl.prototype.load = function (s) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new Ud().load(s, function (n) {
            e.setBuffer(n);
          }),
          this
        );
      };
      Vd.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      };
      co.prototype.updateCubeMap = function (s, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(s, e)
        );
      };
      co.prototype.clear = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(s, e, t, n)
        );
      };
      ti.crossOrigin = void 0;
      ti.loadTexture = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new gl();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      ti.loadTextureCube = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new Rd();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      ti.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      };
      ti.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      };
      function w0() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function b0() {
        console.error("THREE.JSONLoader has been removed.");
      }
      const S0 = {
        createMultiMaterialObject: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        detach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        attach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
      };
      function T0() {
        console.error(
          "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
        );
      }
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: za } })
        );
      typeof window != "undefined" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = za));
      var E0 = Object.freeze(
        Object.defineProperty(
          {
            __proto__: null,
            ACESFilmicToneMapping: Vu,
            AddEquation: Wn,
            AddOperation: Uu,
            AdditiveAnimationBlendMode: qa,
            AdditiveBlending: fa,
            AlphaFormat: Ku,
            AlwaysDepth: Iu,
            AlwaysStencilFunc: Xh,
            AmbientLight: So,
            AmbientLightProbe: Hd,
            AnimationClip: Hi,
            AnimationLoader: jy,
            AnimationMixer: Xd,
            AnimationObjectGroup: qd,
            AnimationUtils: He,
            ArcCurve: xl,
            ArrayCamera: el,
            ArrowHelper: Gv,
            Audio: Pl,
            AudioAnalyser: Vd,
            AudioContext: Cl,
            AudioListener: dv,
            AudioLoader: Ud,
            AxesHelper: tf,
            AxisHelper: m0,
            BackSide: Qe,
            BasicDepthPacking: Vh,
            BasicShadowMap: xf,
            BinaryTextureLoader: _0,
            Bone: Vr,
            BooleanKeyframeTrack: ri,
            BoundingBoxHelper: g0,
            Box2: Ki,
            Box3: wt,
            Box3Helper: Bv,
            BoxBufferGeometry: Qn,
            BoxGeometry: Qn,
            BoxHelper: ef,
            BufferAttribute: be,
            BufferGeometry: de,
            BufferGeometryLoader: Gd,
            ByteType: qu,
            Cache: ei,
            Camera: Gr,
            CameraHelper: Fv,
            CanvasRenderer: w0,
            CanvasTexture: il,
            CatmullRomCurve3: vl,
            CineonToneMapping: ku,
            CircleBufferGeometry: Ws,
            CircleGeometry: Ws,
            ClampToEdgeWrapping: at,
            Clock: kd,
            Color: K,
            ColorKeyframeTrack: pl,
            CompressedTexture: nl,
            CompressedTextureLoader: Ky,
            ConeBufferGeometry: qs,
            ConeGeometry: qs,
            CubeCamera: co,
            CubeReflectionMapping: Fr,
            CubeRefractionMapping: Br,
            CubeTexture: Xi,
            CubeTextureLoader: Rd,
            CubeUVReflectionMapping: Wi,
            CubeUVRefractionMapping: Nr,
            CubicBezierCurve: vo,
            CubicBezierCurve3: _l,
            CubicInterpolant: Td,
            CullFaceBack: da,
            CullFaceFront: xu,
            CullFaceFrontBack: gf,
            CullFaceNone: gu,
            Curve: Lt,
            CurvePath: Id,
            CustomBlending: vu,
            CustomToneMapping: Wu,
            CylinderBufferGeometry: Oi,
            CylinderGeometry: Oi,
            Cylindrical: Av,
            DataTexture: Gi,
            DataTexture2DArray: $a,
            DataTexture3D: Qa,
            DataTextureLoader: Cd,
            DataUtils: Uv,
            DecrementStencilOp: Ef,
            DecrementWrapStencilOp: Lf,
            DefaultLoadingManager: Ld,
            DepthFormat: Zn,
            DepthStencilFormat: Ii,
            DepthTexture: Md,
            DirectionalLight: Zr,
            DirectionalLightHelper: Dv,
            DiscreteInterpolant: Ed,
            DodecahedronBufferGeometry: Xs,
            DodecahedronGeometry: Xs,
            DoubleSide: Vi,
            DstAlphaFactor: Eu,
            DstColorFactor: Lu,
            DynamicBufferAttribute: s0,
            DynamicCopyUsage: kf,
            DynamicDrawUsage: Bi,
            DynamicReadUsage: Uf,
            EdgesGeometry: rl,
            EdgesHelper: x0,
            EllipseCurve: Xr,
            EqualDepth: Fu,
            EqualStencilFunc: If,
            EquirectangularReflectionMapping: ks,
            EquirectangularRefractionMapping: Vs,
            Euler: ni,
            EventDispatcher: An,
            ExtrudeBufferGeometry: an,
            ExtrudeGeometry: an,
            FaceColors: Zv,
            FileLoader: Ct,
            FlatShading: ka,
            Float16BufferAttribute: id,
            Float32Attribute: f0,
            Float32BufferAttribute: le,
            Float64Attribute: p0,
            Float64BufferAttribute: rd,
            FloatType: tn,
            Fog: zr,
            FogExp2: Ur,
            Font: Rl,
            FontLoader: cv,
            FrontSide: jn,
            Frustum: Or,
            GLBufferAttribute: Zd,
            GLSL1: Wf,
            GLSL3: La,
            GammaEncoding: so,
            GreaterDepth: Nu,
            GreaterEqualDepth: Bu,
            GreaterEqualStencilFunc: Nf,
            GreaterStencilFunc: Ff,
            GridHelper: Qd,
            Group: Vt,
            HalfFloatType: Mr,
            HemisphereLight: wl,
            HemisphereLightHelper: Pv,
            HemisphereLightProbe: zd,
            IcosahedronBufferGeometry: Ys,
            IcosahedronGeometry: Ys,
            ImageBitmapLoader: Ll,
            ImageLoader: yo,
            ImageUtils: ti,
            ImmediateRenderObject: jd,
            IncrementStencilOp: Tf,
            IncrementWrapStencilOp: Af,
            InstancedBufferAttribute: Al,
            InstancedBufferGeometry: El,
            InstancedInterleavedBuffer: Yd,
            InstancedMesh: tl,
            Int16Attribute: c0,
            Int16BufferAttribute: td,
            Int32Attribute: h0,
            Int32BufferAttribute: nd,
            Int8Attribute: o0,
            Int8BufferAttribute: $h,
            IntType: Yu,
            InterleavedBuffer: Rn,
            InterleavedBufferAttribute: on,
            Interpolant: Yt,
            InterpolateDiscrete: Di,
            InterpolateLinear: Kn,
            InterpolateSmooth: Us,
            InvertStencilOp: Rf,
            JSONLoader: b0,
            KeepStencilOp: zs,
            KeyframeTrack: zt,
            LOD: vd,
            LatheBufferGeometry: Zs,
            LatheGeometry: Zs,
            Layers: Ka,
            LensFlare: T0,
            LessDepth: Du,
            LessEqualDepth: Hs,
            LessEqualStencilFunc: Df,
            LessStencilFunc: Pf,
            Light: Ut,
            LightProbe: Jr,
            Line: Xt,
            Line3: Jd,
            LineBasicMaterial: st,
            LineCurve: Yr,
            LineCurve3: Pd,
            LineDashedMaterial: dl,
            LineLoop: go,
            LinePieces: Xv,
            LineSegments: Mt,
            LineStrip: qv,
            LinearEncoding: vt,
            LinearFilter: Ke,
            LinearInterpolant: fl,
            LinearMipMapLinearFilter: wf,
            LinearMipMapNearestFilter: Mf,
            LinearMipmapLinearFilter: ln,
            LinearMipmapNearestFilter: io,
            LinearToneMapping: zu,
            Loader: ht,
            LoaderUtils: Mn,
            LoadingManager: ml,
            LogLuvEncoding: kh,
            LoopOnce: Gh,
            LoopPingPong: Uh,
            LoopRepeat: Oh,
            LuminanceAlphaFormat: Qu,
            LuminanceFormat: $u,
            MOUSE: pf,
            Material: et,
            MaterialLoader: Nd,
            Math: Ca,
            MathUtils: Ca,
            Matrix3: it,
            Matrix4: ce,
            MaxEquation: xa,
            Mesh: $e,
            MeshBasicMaterial: bt,
            MeshDepthMaterial: ho,
            MeshDistanceMaterial: fo,
            MeshFaceMaterial: jv,
            MeshLambertMaterial: ul,
            MeshMatcapMaterial: hl,
            MeshNormalMaterial: cl,
            MeshPhongMaterial: al,
            MeshPhysicalMaterial: qr,
            MeshStandardMaterial: ii,
            MeshToonMaterial: ll,
            MinEquation: ga,
            MirroredRepeatWrapping: Pi,
            MixOperation: Ou,
            MultiMaterial: Kv,
            MultiplyBlending: ma,
            MultiplyOperation: Dr,
            NearestFilter: Je,
            NearestMipMapLinearFilter: _f,
            NearestMipMapNearestFilter: vf,
            NearestMipmapLinearFilter: vr,
            NearestMipmapNearestFilter: yr,
            NeverDepth: Pu,
            NeverStencilFunc: Cf,
            NoBlending: nn,
            NoColors: Yv,
            NoToneMapping: Yn,
            NormalAnimationBlendMode: ro,
            NormalBlending: Li,
            NotEqualDepth: Gu,
            NotEqualStencilFunc: Bf,
            NumberKeyframeTrack: Ui,
            Object3D: Ee,
            ObjectLoader: sv,
            ObjectSpaceNormalMap: qh,
            OctahedronBufferGeometry: Lr,
            OctahedronGeometry: Lr,
            OneFactor: bu,
            OneMinusDstAlphaFactor: Au,
            OneMinusDstColorFactor: Ru,
            OneMinusSrcAlphaFactor: Wa,
            OneMinusSrcColorFactor: Tu,
            OrthographicCamera: ji,
            PCFShadowMap: Ha,
            PCFSoftShadowMap: yu,
            PMREMGenerator: Hv,
            ParametricBufferGeometry: Js,
            ParametricGeometry: Js,
            Particle: Qv,
            ParticleBasicMaterial: n0,
            ParticleSystem: e0,
            ParticleSystemMaterial: i0,
            Path: Pr,
            PerspectiveCamera: nt,
            Plane: Nt,
            PlaneBufferGeometry: Sr,
            PlaneGeometry: Sr,
            PlaneHelper: Nv,
            PointCloud: $v,
            PointCloudMaterial: t0,
            PointLight: bo,
            PointLightHelper: Rv,
            Points: Zi,
            PointsMaterial: Cn,
            PolarGridHelper: Iv,
            PolyhedronBufferGeometry: Sn,
            PolyhedronGeometry: Sn,
            PositionalAudio: pv,
            PropertyBinding: De,
            PropertyMixer: Wd,
            QuadraticBezierCurve: _o,
            QuadraticBezierCurve3: Ml,
            Quaternion: lt,
            QuaternionKeyframeTrack: si,
            QuaternionLinearInterpolant: Ad,
            REVISION: za,
            RGBADepthPacking: Wh,
            RGBAFormat: Et,
            RGBAIntegerFormat: oh,
            RGBA_ASTC_10x10_Format: vh,
            RGBA_ASTC_10x5_Format: gh,
            RGBA_ASTC_10x6_Format: xh,
            RGBA_ASTC_10x8_Format: yh,
            RGBA_ASTC_12x10_Format: _h,
            RGBA_ASTC_12x12_Format: Mh,
            RGBA_ASTC_4x4_Format: lh,
            RGBA_ASTC_5x4_Format: ch,
            RGBA_ASTC_5x5_Format: uh,
            RGBA_ASTC_6x5_Format: hh,
            RGBA_ASTC_6x6_Format: dh,
            RGBA_ASTC_8x5_Format: fh,
            RGBA_ASTC_8x6_Format: ph,
            RGBA_ASTC_8x8_Format: mh,
            RGBA_BPTC_Format: wh,
            RGBA_ETC2_EAC_Format: Aa,
            RGBA_PVRTC_2BPPV1_Format: Ta,
            RGBA_PVRTC_4BPPV1_Format: Sa,
            RGBA_S3TC_DXT1_Format: va,
            RGBA_S3TC_DXT3_Format: _a,
            RGBA_S3TC_DXT5_Format: Ma,
            RGBDEncoding: Ja,
            RGBEEncoding: oo,
            RGBEFormat: eh,
            RGBFormat: rn,
            RGBIntegerFormat: sh,
            RGBM16Encoding: Za,
            RGBM7Encoding: Ya,
            RGB_ETC1_Format: ah,
            RGB_ETC2_Format: Ea,
            RGB_PVRTC_2BPPV1_Format: ba,
            RGB_PVRTC_4BPPV1_Format: wa,
            RGB_S3TC_DXT1_Format: ya,
            RGFormat: ih,
            RGIntegerFormat: rh,
            RawShaderMaterial: Ji,
            Ray: Ln,
            Raycaster: Tv,
            RectAreaLight: Sl,
            RedFormat: th,
            RedIntegerFormat: nh,
            ReinhardToneMapping: Hu,
            RepeatWrapping: bn,
            ReplaceStencilOp: Sf,
            ReverseSubtractEquation: Mu,
            RingBufferGeometry: js,
            RingGeometry: js,
            SRGB8_ALPHA8_ASTC_10x10_Format: Fh,
            SRGB8_ALPHA8_ASTC_10x5_Format: Ph,
            SRGB8_ALPHA8_ASTC_10x6_Format: Ih,
            SRGB8_ALPHA8_ASTC_10x8_Format: Dh,
            SRGB8_ALPHA8_ASTC_12x10_Format: Bh,
            SRGB8_ALPHA8_ASTC_12x12_Format: Nh,
            SRGB8_ALPHA8_ASTC_4x4_Format: bh,
            SRGB8_ALPHA8_ASTC_5x4_Format: Sh,
            SRGB8_ALPHA8_ASTC_5x5_Format: Th,
            SRGB8_ALPHA8_ASTC_6x5_Format: Eh,
            SRGB8_ALPHA8_ASTC_6x6_Format: Ah,
            SRGB8_ALPHA8_ASTC_8x5_Format: Lh,
            SRGB8_ALPHA8_ASTC_8x6_Format: Rh,
            SRGB8_ALPHA8_ASTC_8x8_Format: Ch,
            Scene: Hr,
            SceneUtils: S0,
            ShaderChunk: Ae,
            ShaderLib: Gt,
            ShaderMaterial: sn,
            ShadowMaterial: ol,
            Shape: _n,
            ShapeBufferGeometry: Rr,
            ShapeGeometry: Rr,
            ShapePath: Od,
            ShapeUtils: qt,
            ShortType: Xu,
            Skeleton: Wr,
            SkeletonHelper: Kd,
            SkinnedMesh: kr,
            SmoothShading: yf,
            Sphere: cn,
            SphereBufferGeometry: Cr,
            SphereGeometry: Cr,
            Spherical: Ev,
            SphericalHarmonics3: Tl,
            SplineCurve: Mo,
            SpotLight: wo,
            SpotLightHelper: Lv,
            Sprite: mo,
            SpriteMaterial: po,
            SrcAlphaFactor: Va,
            SrcAlphaSaturateFactor: Cu,
            SrcColorFactor: Su,
            StaticCopyUsage: Hf,
            StaticDrawUsage: Fi,
            StaticReadUsage: Of,
            StereoCamera: uv,
            StreamCopyUsage: Vf,
            StreamDrawUsage: Gf,
            StreamReadUsage: zf,
            StringKeyframeTrack: oi,
            SubtractEquation: _u,
            SubtractiveBlending: pa,
            TOUCH: mf,
            TangentSpaceNormalMap: En,
            TetrahedronBufferGeometry: Ks,
            TetrahedronGeometry: Ks,
            TextBufferGeometry: $s,
            TextGeometry: $s,
            Texture: rt,
            TextureLoader: gl,
            TorusBufferGeometry: Qs,
            TorusGeometry: Qs,
            TorusKnotBufferGeometry: eo,
            TorusKnotGeometry: eo,
            Triangle: je,
            TriangleFanDrawMode: Xa,
            TriangleStripDrawMode: Hh,
            TrianglesDrawMode: zh,
            TubeBufferGeometry: to,
            TubeGeometry: to,
            UVMapping: no,
            Uint16Attribute: u0,
            Uint16BufferAttribute: ao,
            Uint32Attribute: d0,
            Uint32BufferAttribute: lo,
            Uint8Attribute: a0,
            Uint8BufferAttribute: Qh,
            Uint8ClampedAttribute: l0,
            Uint8ClampedBufferAttribute: ed,
            Uniform: To,
            UniformsLib: ee,
            UniformsUtils: od,
            UnsignedByteType: qi,
            UnsignedInt248Type: Ri,
            UnsignedIntType: pr,
            UnsignedShort4444Type: Zu,
            UnsignedShort5551Type: Ju,
            UnsignedShort565Type: ju,
            UnsignedShortType: _r,
            VSMShadowMap: Ei,
            Vector2: q,
            Vector3: M,
            Vector4: Ge,
            VectorKeyframeTrack: zi,
            Vertex: r0,
            VertexColors: Jv,
            VideoTexture: _d,
            WebGL1Renderer: xd,
            WebGLCubeRenderTarget: uo,
            WebGLMultipleRenderTargets: Jh,
            WebGLMultisampleRenderTarget: jh,
            WebGLRenderTarget: Ot,
            WebGLRenderTargetCube: M0,
            WebGLRenderer: Ue,
            WebGLUtils: gd,
            WireframeGeometry: sl,
            WireframeHelper: y0,
            WrapAroundEnding: wr,
            XHRLoader: v0,
            ZeroCurvatureEnding: qn,
            ZeroFactor: wu,
            ZeroSlopeEnding: Xn,
            ZeroStencilOp: bf,
            sRGBEncoding: $n,
          },
          Symbol.toStringTag,
          { value: "Module" }
        )
      );
      class A0 extends ht {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new P0(t);
            }),
            this.register(function (t) {
              return new D0(t);
            }),
            this.register(function (t) {
              return new F0(t);
            }),
            this.register(function (t) {
              return new I0(t);
            }),
            this.register(function (t) {
              return new R0(t);
            }),
            this.register(function (t) {
              return new B0(t);
            });
        }
        load(e, t, n, i) {
          const r = this;
          let o;
          this.resourcePath !== ""
            ? (o = this.resourcePath)
            : this.path !== ""
            ? (o = this.path)
            : (o = Mn.extractUrlBase(e)),
            this.manager.itemStart(e);
          const a = function (l) {
              i ? i(l) : console.error(l),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            },
            c = new Ct(this.manager);
          c.setPath(this.path),
            c.setResponseType("arraybuffer"),
            c.setRequestHeader(this.requestHeader),
            c.setWithCredentials(this.withCredentials),
            c.load(
              e,
              function (l) {
                try {
                  r.parse(
                    l,
                    o,
                    function (u) {
                      t(u), r.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (u) {
                  a(u);
                }
              },
              n,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            this.pluginCallbacks.indexOf(e) === -1 &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            this.pluginCallbacks.indexOf(e) !== -1 &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let r;
          const o = {},
            a = {};
          if (typeof e == "string") r = e;
          else if (Mn.decodeText(new Uint8Array(e, 0, 4)) === of) {
            try {
              o[Ne.KHR_BINARY_GLTF] = new N0(e);
            } catch (h) {
              i && i(h);
              return;
            }
            r = o[Ne.KHR_BINARY_GLTF].content;
          } else r = Mn.decodeText(new Uint8Array(e));
          const c = JSON.parse(r);
          if (c.asset === void 0 || c.asset.version[0] < 2) {
            i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              );
            return;
          }
          const l = new X0(c, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          l.fileLoader.setRequestHeader(this.requestHeader);
          for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const h = this.pluginCallbacks[u](l);
            (a[h.name] = h), (o[h.name] = !0);
          }
          if (c.extensionsUsed)
            for (let u = 0; u < c.extensionsUsed.length; ++u) {
              const h = c.extensionsUsed[u],
                d = c.extensionsRequired || [];
              switch (h) {
                case Ne.KHR_MATERIALS_UNLIT:
                  o[h] = new C0();
                  break;
                case Ne.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  o[h] = new U0();
                  break;
                case Ne.KHR_DRACO_MESH_COMPRESSION:
                  o[h] = new G0(c, this.dracoLoader);
                  break;
                case Ne.KHR_TEXTURE_TRANSFORM:
                  o[h] = new O0();
                  break;
                case Ne.KHR_MESH_QUANTIZATION:
                  o[h] = new z0();
                  break;
                default:
                  d.indexOf(h) >= 0 &&
                    a[h] === void 0 &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + h + '".'
                    );
              }
            }
          l.setExtensions(o), l.setPlugins(a), l.parse(n, i);
        }
      }
      function L0() {
        let s = {};
        return {
          get: function (e) {
            return s[e];
          },
          add: function (e, t) {
            s[e] = t;
          },
          remove: function (e) {
            delete s[e];
          },
          removeAll: function () {
            s = {};
          },
        };
      }
      const Ne = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      };
      class R0 {
        constructor(e) {
          (this.parser = e),
            (this.name = Ne.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            r.extensions &&
              r.extensions[this.name] &&
              r.extensions[this.name].light !== void 0 &&
              e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let i = t.cache.get(n);
          if (i) return i;
          const r = t.json,
            c = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[e];
          let l;
          const u = new K(16777215);
          c.color !== void 0 && u.fromArray(c.color);
          const h = c.range !== void 0 ? c.range : 0;
          switch (c.type) {
            case "directional":
              (l = new Zr(u)), l.target.position.set(0, 0, -1), l.add(l.target);
              break;
            case "point":
              (l = new bo(u)), (l.distance = h);
              break;
            case "spot":
              (l = new wo(u)),
                (l.distance = h),
                (c.spot = c.spot || {}),
                (c.spot.innerConeAngle =
                  c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0),
                (c.spot.outerConeAngle =
                  c.spot.outerConeAngle !== void 0
                    ? c.spot.outerConeAngle
                    : Math.PI / 4),
                (l.angle = c.spot.outerConeAngle),
                (l.penumbra =
                  1 - c.spot.innerConeAngle / c.spot.outerConeAngle),
                l.target.position.set(0, 0, -1),
                l.add(l.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + c.type
              );
          }
          return (
            l.position.set(0, 0, 0),
            (l.decay = 2),
            c.intensity !== void 0 && (l.intensity = c.intensity),
            (l.name = t.createUniqueName(c.name || "light_" + e)),
            (i = Promise.resolve(l)),
            t.cache.add(n, i),
            i
          );
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            a = ((r.extensions && r.extensions[this.name]) || {}).light;
          return a === void 0
            ? null
            : this._loadLight(a).then(function (c) {
                return n._getNodeRef(t.cache, a, c);
              });
        }
      }
      class C0 {
        constructor() {
          this.name = Ne.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return bt;
        }
        extendParams(e, t, n) {
          const i = [];
          (e.color = new K(1, 1, 1)), (e.opacity = 1);
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const o = r.baseColorFactor;
              e.color.fromArray(o), (e.opacity = o[3]);
            }
            r.baseColorTexture !== void 0 &&
              i.push(n.assignTexture(e, "map", r.baseColorTexture));
          }
          return Promise.all(i);
        }
      }
      class P0 {
        constructor(e) {
          (this.parser = e), (this.name = Ne.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : qr;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          if (
            (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
            o.clearcoatTexture !== void 0 &&
              r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
            o.clearcoatRoughnessFactor !== void 0 &&
              (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
            o.clearcoatRoughnessTexture !== void 0 &&
              r.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  o.clearcoatRoughnessTexture
                )
              ),
            o.clearcoatNormalTexture !== void 0 &&
              (r.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  o.clearcoatNormalTexture
                )
              ),
              o.clearcoatNormalTexture.scale !== void 0))
          ) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new q(a, -a);
          }
          return Promise.all(r);
        }
      }
      class I0 {
        constructor(e) {
          (this.parser = e), (this.name = Ne.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : qr;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          return (
            o.transmissionFactor !== void 0 &&
              (t.transmission = o.transmissionFactor),
            o.transmissionTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "transmissionMap", o.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class D0 {
        constructor(e) {
          (this.parser = e), (this.name = Ne.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            o = n.images[r.source],
            a = t.options.ktx2Loader;
          if (!a) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, o, a);
        }
      }
      class F0 {
        constructor(e) {
          (this.parser = e),
            (this.name = Ne.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const o = r.extensions[t],
            a = i.images[o.source];
          let c = n.textureLoader;
          if (a.uri) {
            const l = n.options.manager.getHandler(a.uri);
            l !== null && (c = l);
          }
          return this.detectSupport().then(function (l) {
            if (l) return n.loadTextureImage(e, a, c);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(t.height === 1);
                    });
              })),
            this.isSupported
          );
        }
      }
      class B0 {
        constructor(e) {
          (this.name = Ne.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
              r = this.parser.getDependency("buffer", i.buffer),
              o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return Promise.all([r, o.ready]).then(function (a) {
              const c = i.byteOffset || 0,
                l = i.byteLength || 0,
                u = i.count,
                h = i.byteStride,
                d = new ArrayBuffer(u * h),
                f = new Uint8Array(a[0], c, l);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(d),
                  u,
                  h,
                  f,
                  i.mode,
                  i.filter
                ),
                d
              );
            });
          } else return null;
        }
      }
      const of = "glTF",
        ur = 12,
        lu = { JSON: 1313821514, BIN: 5130562 };
      class N0 {
        constructor(e) {
          (this.name = Ne.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, ur);
          if (
            ((this.header = {
              magic: Mn.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== of)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - ur,
            i = new DataView(e, ur);
          let r = 0;
          for (; r < n; ) {
            const o = i.getUint32(r, !0);
            r += 4;
            const a = i.getUint32(r, !0);
            if (((r += 4), a === lu.JSON)) {
              const c = new Uint8Array(e, ur + r, o);
              this.content = Mn.decodeText(c);
            } else if (a === lu.BIN) {
              const c = ur + r;
              this.body = e.slice(c, c + o);
            }
            r += o;
          }
          if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class G0 {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = Ne.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            i = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            c = {},
            l = {};
          for (const u in o) {
            const h = Oa[u] || u.toLowerCase();
            a[h] = o[u];
          }
          for (const u in e.attributes) {
            const h = Oa[u] || u.toLowerCase();
            if (o[u] !== void 0) {
              const d = n.accessors[e.attributes[u]],
                f = Ir[d.componentType];
              (l[h] = f), (c[h] = d.normalized === !0);
            }
          }
          return t.getDependency("bufferView", r).then(function (u) {
            return new Promise(function (h) {
              i.decodeDracoFile(
                u,
                function (d) {
                  for (const f in d.attributes) {
                    const p = d.attributes[f],
                      x = c[f];
                    x !== void 0 && (p.normalized = x);
                  }
                  h(d);
                },
                a,
                l
              );
            });
          });
        }
      }
      class O0 {
        constructor() {
          this.name = Ne.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            t.texCoord !== void 0 &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.'
              ),
            (t.offset === void 0 &&
              t.rotation === void 0 &&
              t.scale === void 0) ||
              ((e = e.clone()),
              t.offset !== void 0 && e.offset.fromArray(t.offset),
              t.rotation !== void 0 && (e.rotation = t.rotation),
              t.scale !== void 0 && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class Ga extends ii {
        constructor(e) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0);
          const t = [
              "#ifdef USE_SPECULARMAP",
              "	uniform sampler2D specularMap;",
              "#endif",
            ].join(`
`),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "	uniform sampler2D glossinessMap;",
              "#endif",
            ].join(`
`),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "	vec4 texelSpecular = texture2D( specularMap, vUv );",
              "	texelSpecular = sRGBToLinear( texelSpecular );",
              "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	specularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join(`
`),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	glossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join(`
`),
            o = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.specularRoughness += geometryRoughness;",
              "material.specularRoughness = min( material.specularRoughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join(`
`),
            a = {
              specular: { value: new K().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = a),
            (this.onBeforeCompile = function (c) {
              for (const l in a) c.uniforms[l] = a[l];
              c.fragmentShader = c.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", t)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", r)
                .replace("#include <lights_physical_fragment>", o);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return a.specular.value;
                },
                set: function (c) {
                  a.specular.value = c;
                },
              },
              specularMap: {
                get: function () {
                  return a.specularMap.value;
                },
                set: function (c) {
                  (a.specularMap.value = c),
                    c
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return a.glossiness.value;
                },
                set: function (c) {
                  a.glossiness.value = c;
                },
              },
              glossinessMap: {
                get: function () {
                  return a.glossinessMap.value;
                },
                set: function (c) {
                  (a.glossinessMap.value = c),
                    c
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.specularMap = e.specularMap),
            this.specular.copy(e.specular),
            (this.glossinessMap = e.glossinessMap),
            (this.glossiness = e.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          );
        }
      }
      class U0 {
        constructor() {
          (this.name = Ne.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
              "refractionRatio",
            ]);
        }
        getMaterialType() {
          return Ga;
        }
        extendParams(e, t, n) {
          const i = t.extensions[this.name];
          (e.color = new K(1, 1, 1)), (e.opacity = 1);
          const r = [];
          if (Array.isArray(i.diffuseFactor)) {
            const o = i.diffuseFactor;
            e.color.fromArray(o), (e.opacity = o[3]);
          }
          if (
            (i.diffuseTexture !== void 0 &&
              r.push(n.assignTexture(e, "map", i.diffuseTexture)),
            (e.emissive = new K(0, 0, 0)),
            (e.glossiness =
              i.glossinessFactor !== void 0 ? i.glossinessFactor : 1),
            (e.specular = new K(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              e.specular.fromArray(i.specularFactor),
            i.specularGlossinessTexture !== void 0)
          ) {
            const o = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", o)),
              r.push(n.assignTexture(e, "specularMap", o));
          }
          return Promise.all(r);
        }
        createMaterial(e) {
          const t = new Ga(e);
          return (
            (t.fog = !0),
            (t.color = e.color),
            (t.map = e.map === void 0 ? null : e.map),
            (t.lightMap = null),
            (t.lightMapIntensity = 1),
            (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
            (t.aoMapIntensity = 1),
            (t.emissive = e.emissive),
            (t.emissiveIntensity = 1),
            (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
            (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
            (t.bumpScale = 1),
            (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
            (t.normalMapType = En),
            e.normalScale && (t.normalScale = e.normalScale),
            (t.displacementMap = null),
            (t.displacementScale = 1),
            (t.displacementBias = 0),
            (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
            (t.specular = e.specular),
            (t.glossinessMap =
              e.glossinessMap === void 0 ? null : e.glossinessMap),
            (t.glossiness = e.glossiness),
            (t.alphaMap = null),
            (t.envMap = e.envMap === void 0 ? null : e.envMap),
            (t.envMapIntensity = 1),
            (t.refractionRatio = 0.98),
            t
          );
        }
      }
      class z0 {
        constructor() {
          this.name = Ne.KHR_MESH_QUANTIZATION;
        }
      }
      class ki extends Yt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i;
          for (let o = 0; o !== i; o++) t[o] = n[r + o];
          return t;
        }
      }
      ki.prototype.beforeStart_ = ki.prototype.copySampleValue_;
      ki.prototype.afterEnd_ = ki.prototype.copySampleValue_;
      ki.prototype.interpolate_ = function (s, e, t, n) {
        const i = this.resultBuffer,
          r = this.sampleValues,
          o = this.valueSize,
          a = o * 2,
          c = o * 3,
          l = n - e,
          u = (t - e) / l,
          h = u * u,
          d = h * u,
          f = s * c,
          p = f - c,
          x = -2 * d + 3 * h,
          y = d - h,
          m = 1 - x,
          g = y - h + u;
        for (let _ = 0; _ !== o; _++) {
          const w = r[p + _ + o],
            T = r[p + _ + a] * l,
            v = r[f + _ + o],
            A = r[f + _] * l;
          i[_] = m * w + g * T + x * v + y * A;
        }
        return i;
      };
      const en = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        Ir = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        cu = { 9728: Je, 9729: Ke, 9984: yr, 9985: io, 9986: vr, 9987: ln },
        uu = { 33071: at, 33648: Pi, 10497: bn },
        hu = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        Oa = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        yn = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        H0 = { CUBICSPLINE: void 0, LINEAR: Kn, STEP: Di },
        ca = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
      function du(s, e) {
        return typeof s != "string" || s === ""
          ? ""
          : (/^https?:\/\//i.test(e) &&
              /^\//.test(s) &&
              (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(s) ||
            /^data:.*,.*$/i.test(s) ||
            /^blob:.*$/i.test(s)
              ? s
              : e + s);
      }
      function k0(s) {
        return (
          s.DefaultMaterial === void 0 &&
            (s.DefaultMaterial = new ii({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: jn,
            })),
          s.DefaultMaterial
        );
      }
      function hr(s, e, t) {
        for (const n in t.extensions)
          s[n] === void 0 &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[n] = t.extensions[n]));
      }
      function Vn(s, e) {
        e.extras !== void 0 &&
          (typeof e.extras == "object"
            ? Object.assign(s.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function V0(s, e, t) {
        let n = !1,
          i = !1;
        for (let a = 0, c = e.length; a < c; a++) {
          const l = e[a];
          if (
            (l.POSITION !== void 0 && (n = !0),
            l.NORMAL !== void 0 && (i = !0),
            n && i)
          )
            break;
        }
        if (!n && !i) return Promise.resolve(s);
        const r = [],
          o = [];
        for (let a = 0, c = e.length; a < c; a++) {
          const l = e[a];
          if (n) {
            const u =
              l.POSITION !== void 0
                ? t.getDependency("accessor", l.POSITION)
                : s.attributes.position;
            r.push(u);
          }
          if (i) {
            const u =
              l.NORMAL !== void 0
                ? t.getDependency("accessor", l.NORMAL)
                : s.attributes.normal;
            o.push(u);
          }
        }
        return Promise.all([Promise.all(r), Promise.all(o)]).then(function (a) {
          const c = a[0],
            l = a[1];
          return (
            n && (s.morphAttributes.position = c),
            i && (s.morphAttributes.normal = l),
            (s.morphTargetsRelative = !0),
            s
          );
        });
      }
      function W0(s, e) {
        if ((s.updateMorphTargets(), e.weights !== void 0))
          for (let t = 0, n = e.weights.length; t < n; t++)
            s.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (s.morphTargetInfluences.length === t.length) {
            s.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
              s.morphTargetDictionary[t[n]] = n;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function q0(s) {
        const e = s.extensions && s.extensions[Ne.KHR_DRACO_MESH_COMPRESSION];
        let t;
        return (
          e
            ? (t =
                "draco:" +
                e.bufferView +
                ":" +
                e.indices +
                ":" +
                fu(e.attributes))
            : (t = s.indices + ":" + fu(s.attributes) + ":" + s.mode),
          t
        );
      }
      function fu(s) {
        let e = "";
        const t = Object.keys(s).sort();
        for (let n = 0, i = t.length; n < i; n++)
          e += t[n] + ":" + s[t[n]] + ";";
        return e;
      }
      function Ua(s) {
        switch (s) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      class X0 {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new L0()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {}),
            typeof createImageBitmap != "undefined" &&
            /Firefox/.test(navigator.userAgent) === !1
              ? (this.textureLoader = new Ll(this.options.manager))
              : (this.textureLoader = new gl(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new Ct(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            this.options.crossOrigin === "use-credentials" &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            this._invokeAll(function (o) {
              return o._markDefs && o._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (o) {
                return o.beforeRoot && o.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (o) {
                const a = {
                  scene: o[0][i.scene || 0],
                  scenes: o[0],
                  animations: o[1],
                  cameras: o[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                hr(r, a, i),
                  Vn(a, i),
                  Promise.all(
                    n._invokeAll(function (c) {
                      return c.afterRoot && c.afterRoot(a);
                    })
                  ).then(function () {
                    e(a);
                  });
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i].joints;
            for (let a = 0, c = o.length; a < c; a++) e[o[a]].isBone = !0;
          }
          for (let i = 0, r = e.length; i < r; i++) {
            const o = e[i];
            o.mesh !== void 0 &&
              (this._addNodeRef(this.meshCache, o.mesh),
              o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
              o.camera !== void 0 &&
                this._addNodeRef(this.cameraCache, o.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 &&
            (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone();
          return (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this.loadNode(t);
                break;
              case "mesh":
                i = this._invokeOne(function (r) {
                  return r.loadMesh && r.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (r) {
                  return r.loadBufferView && r.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (r) {
                  return r.loadMaterial && r.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (r) {
                  return r.loadTexture && r.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this.loadAnimation(t);
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (r, o) {
                return n.getDependency(e, o);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && t.type !== "arraybuffer")
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Ne.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (r, o) {
            n.load(du(t.uri, i.path), r, void 0, function () {
              o(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (n) {
            const i = t.byteLength || 0,
              r = t.byteOffset || 0;
            return n.slice(r, r + i);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            i = this.json.accessors[e];
          if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
          const r = [];
          return (
            i.bufferView !== void 0
              ? r.push(this.getDependency("bufferView", i.bufferView))
              : r.push(null),
            i.sparse !== void 0 &&
              (r.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              r.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(r).then(function (o) {
              const a = o[0],
                c = hu[i.type],
                l = Ir[i.componentType],
                u = l.BYTES_PER_ELEMENT,
                h = u * c,
                d = i.byteOffset || 0,
                f =
                  i.bufferView !== void 0
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                p = i.normalized === !0;
              let x, y;
              if (f && f !== h) {
                const m = Math.floor(d / f),
                  g =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    m +
                    ":" +
                    i.count;
                let _ = t.cache.get(g);
                _ ||
                  ((x = new l(a, m * f, (i.count * f) / u)),
                  (_ = new Rn(x, f / u)),
                  t.cache.add(g, _)),
                  (y = new on(_, c, (d % f) / u, p));
              } else a === null ? (x = new l(i.count * c)) : (x = new l(a, d, i.count * c)), (y = new be(x, c, p));
              if (i.sparse !== void 0) {
                const m = hu.SCALAR,
                  g = Ir[i.sparse.indices.componentType],
                  _ = i.sparse.indices.byteOffset || 0,
                  w = i.sparse.values.byteOffset || 0,
                  T = new g(o[1], _, i.sparse.count * m),
                  v = new l(o[2], w, i.sparse.count * c);
                a !== null &&
                  (y = new be(y.array.slice(), y.itemSize, y.normalized));
                for (let A = 0, L = T.length; A < L; A++) {
                  const I = T[A];
                  if (
                    (y.setX(I, v[A * c]),
                    c >= 2 && y.setY(I, v[A * c + 1]),
                    c >= 3 && y.setZ(I, v[A * c + 2]),
                    c >= 4 && y.setW(I, v[A * c + 3]),
                    c >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return y;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            i = t.textures[e],
            r = t.images[i.source];
          let o = this.textureLoader;
          if (r.uri) {
            const a = n.manager.getHandler(r.uri);
            a !== null && (o = a);
          }
          return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, n) {
          const i = this,
            r = this.json,
            o = this.options,
            a = r.textures[e],
            c = (t.uri || t.bufferView) + ":" + a.sampler;
          if (this.textureCache[c]) return this.textureCache[c];
          const l = self.URL || self.webkitURL;
          let u = t.uri || "",
            h = !1,
            d = !0;
          const f =
            u.search(/\.jpe?g($|\?)/i) > 0 ||
            u.search(/^data\:image\/jpeg/) === 0;
          if (
            ((t.mimeType === "image/jpeg" || f) && (d = !1),
            t.bufferView !== void 0)
          )
            u = i.getDependency("bufferView", t.bufferView).then(function (x) {
              if (t.mimeType === "image/png") {
                const m = new DataView(x, 25, 1).getUint8(0, !1);
                d = m === 6 || m === 4 || m === 3;
              }
              h = !0;
              const y = new Blob([x], { type: t.mimeType });
              return (u = l.createObjectURL(y)), u;
            });
          else if (t.uri === void 0)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const p = Promise.resolve(u)
            .then(function (x) {
              return new Promise(function (y, m) {
                let g = y;
                n.isImageBitmapLoader === !0 &&
                  (g = function (_) {
                    y(new il(_));
                  }),
                  n.load(du(x, o.path), g, void 0, m);
              });
            })
            .then(function (x) {
              h === !0 && l.revokeObjectURL(u),
                (x.flipY = !1),
                a.name && (x.name = a.name),
                d || (x.format = rn);
              const m = (r.samplers || {})[a.sampler] || {};
              return (
                (x.magFilter = cu[m.magFilter] || Ke),
                (x.minFilter = cu[m.minFilter] || ln),
                (x.wrapS = uu[m.wrapS] || bn),
                (x.wrapT = uu[m.wrapT] || bn),
                i.associations.set(x, { type: "textures", index: e }),
                x
              );
            });
          return (this.textureCache[c] = p), p;
        }
        assignTexture(e, t, n) {
          const i = this;
          return this.getDependency("texture", n.index).then(function (r) {
            if (
              (n.texCoord !== void 0 &&
                n.texCoord != 0 &&
                !(t === "aoMap" && n.texCoord == 1) &&
                console.warn(
                  "THREE.GLTFLoader: Custom UV set " +
                    n.texCoord +
                    " for texture " +
                    t +
                    " not yet supported."
                ),
              i.extensions[Ne.KHR_TEXTURE_TRANSFORM])
            ) {
              const o =
                n.extensions !== void 0
                  ? n.extensions[Ne.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (o) {
                const a = i.associations.get(r);
                (r = i.extensions[Ne.KHR_TEXTURE_TRANSFORM].extendTexture(
                  r,
                  o
                )),
                  i.associations.set(r, a);
              }
            }
            e[t] = r;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const i = t.attributes.tangent !== void 0,
            r = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0,
            a = Object.keys(t.morphAttributes).length > 0,
            c = a && t.morphAttributes.normal !== void 0;
          if (e.isPoints) {
            const l = "PointsMaterial:" + n.uuid;
            let u = this.cache.get(l);
            u ||
              ((u = new Cn()),
              et.prototype.copy.call(u, n),
              u.color.copy(n.color),
              (u.map = n.map),
              (u.sizeAttenuation = !1),
              this.cache.add(l, u)),
              (n = u);
          } else if (e.isLine) {
            const l = "LineBasicMaterial:" + n.uuid;
            let u = this.cache.get(l);
            u ||
              ((u = new st()),
              et.prototype.copy.call(u, n),
              u.color.copy(n.color),
              this.cache.add(l, u)),
              (n = u);
          }
          if (i || r || o || a) {
            let l = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (l += "specular-glossiness:"),
              i && (l += "vertex-tangents:"),
              r && (l += "vertex-colors:"),
              o && (l += "flat-shading:"),
              a && (l += "morph-targets:"),
              c && (l += "morph-normals:");
            let u = this.cache.get(l);
            u ||
              ((u = n.clone()),
              r && (u.vertexColors = !0),
              o && (u.flatShading = !0),
              a && (u.morphTargets = !0),
              c && (u.morphNormals = !0),
              i &&
                ((u.vertexTangents = !0),
                u.normalScale && (u.normalScale.y *= -1),
                u.clearcoatNormalScale && (u.clearcoatNormalScale.y *= -1)),
              this.cache.add(l, u),
              this.associations.set(u, this.associations.get(n))),
              (n = u);
          }
          n.aoMap &&
            t.attributes.uv2 === void 0 &&
            t.attributes.uv !== void 0 &&
            t.setAttribute("uv2", t.attributes.uv),
            (e.material = n);
        }
        getMaterialType() {
          return ii;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[e];
          let o;
          const a = {},
            c = r.extensions || {},
            l = [];
          if (c[Ne.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const h = i[Ne.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            (o = h.getMaterialType()), l.push(h.extendParams(a, r, t));
          } else if (c[Ne.KHR_MATERIALS_UNLIT]) {
            const h = i[Ne.KHR_MATERIALS_UNLIT];
            (o = h.getMaterialType()), l.push(h.extendParams(a, r, t));
          } else {
            const h = r.pbrMetallicRoughness || {};
            if (
              ((a.color = new K(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(h.baseColorFactor))
            ) {
              const d = h.baseColorFactor;
              a.color.fromArray(d), (a.opacity = d[3]);
            }
            h.baseColorTexture !== void 0 &&
              l.push(t.assignTexture(a, "map", h.baseColorTexture)),
              (a.metalness =
                h.metallicFactor !== void 0 ? h.metallicFactor : 1),
              (a.roughness =
                h.roughnessFactor !== void 0 ? h.roughnessFactor : 1),
              h.metallicRoughnessTexture !== void 0 &&
                (l.push(
                  t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)
                ),
                l.push(
                  t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture)
                )),
              (o = this._invokeOne(function (d) {
                return d.getMaterialType && d.getMaterialType(e);
              })),
              l.push(
                Promise.all(
                  this._invokeAll(function (d) {
                    return (
                      d.extendMaterialParams && d.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          r.doubleSided === !0 && (a.side = Vi);
          const u = r.alphaMode || ca.OPAQUE;
          return (
            u === ca.BLEND
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                u === ca.MASK &&
                  (a.alphaTest =
                    r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
            r.normalTexture !== void 0 &&
              o !== bt &&
              (l.push(t.assignTexture(a, "normalMap", r.normalTexture)),
              (a.normalScale = new q(1, -1)),
              r.normalTexture.scale !== void 0 &&
                a.normalScale.set(
                  r.normalTexture.scale,
                  -r.normalTexture.scale
                )),
            r.occlusionTexture !== void 0 &&
              o !== bt &&
              (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
              r.occlusionTexture.strength !== void 0 &&
                (a.aoMapIntensity = r.occlusionTexture.strength)),
            r.emissiveFactor !== void 0 &&
              o !== bt &&
              (a.emissive = new K().fromArray(r.emissiveFactor)),
            r.emissiveTexture !== void 0 &&
              o !== bt &&
              l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
            Promise.all(l).then(function () {
              let h;
              return (
                o === Ga
                  ? (h =
                      i[
                        Ne.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(a))
                  : (h = new o(a)),
                r.name && (h.name = r.name),
                h.map && (h.map.encoding = $n),
                h.emissiveMap && (h.emissiveMap.encoding = $n),
                Vn(h, r),
                t.associations.set(h, { type: "materials", index: e }),
                r.extensions && hr(i, h, r),
                h
              );
            })
          );
        }
        createUniqueName(e) {
          const t = De.sanitizeNodeName(e || "");
          let n = t;
          for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
          return (this.nodeNamesUsed[n] = !0), n;
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            i = this.primitiveCache;
          function r(a) {
            return n[Ne.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(a, t)
              .then(function (c) {
                return pu(c, a, t);
              });
          }
          const o = [];
          for (let a = 0, c = e.length; a < c; a++) {
            const l = e[a],
              u = q0(l),
              h = i[u];
            if (h) o.push(h.promise);
            else {
              let d;
              l.extensions && l.extensions[Ne.KHR_DRACO_MESH_COMPRESSION]
                ? (d = r(l))
                : (d = pu(new de(), l, t)),
                (i[u] = { primitive: l, promise: d }),
                o.push(d);
            }
          }
          return Promise.all(o);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[e],
            o = r.primitives,
            a = [];
          for (let c = 0, l = o.length; c < l; c++) {
            const u =
              o[c].material === void 0
                ? k0(this.cache)
                : this.getDependency("material", o[c].material);
            a.push(u);
          }
          return (
            a.push(t.loadGeometries(o)),
            Promise.all(a).then(function (c) {
              const l = c.slice(0, c.length - 1),
                u = c[c.length - 1],
                h = [];
              for (let f = 0, p = u.length; f < p; f++) {
                const x = u[f],
                  y = o[f];
                let m;
                const g = l[f];
                if (
                  y.mode === en.TRIANGLES ||
                  y.mode === en.TRIANGLE_STRIP ||
                  y.mode === en.TRIANGLE_FAN ||
                  y.mode === void 0
                )
                  (m = r.isSkinnedMesh === !0 ? new kr(x, g) : new $e(x, g)),
                    m.isSkinnedMesh === !0 &&
                      !m.geometry.attributes.skinWeight.normalized &&
                      m.normalizeSkinWeights(),
                    y.mode === en.TRIANGLE_STRIP
                      ? (m.geometry = mu(m.geometry, Hh))
                      : y.mode === en.TRIANGLE_FAN &&
                        (m.geometry = mu(m.geometry, Xa));
                else if (y.mode === en.LINES) m = new Mt(x, g);
                else if (y.mode === en.LINE_STRIP) m = new Xt(x, g);
                else if (y.mode === en.LINE_LOOP) m = new go(x, g);
                else if (y.mode === en.POINTS) m = new Zi(x, g);
                else
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + y.mode
                  );
                Object.keys(m.geometry.morphAttributes).length > 0 && W0(m, r),
                  (m.name = t.createUniqueName(r.name || "mesh_" + e)),
                  Vn(m, r),
                  y.extensions && hr(i, m, y),
                  t.assignFinalMaterial(m),
                  h.push(m);
              }
              if (h.length === 1) return h[0];
              const d = new Vt();
              for (let f = 0, p = h.length; f < p; f++) d.add(h[f]);
              return d;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            i = n[n.type];
          if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return (
            n.type === "perspective"
              ? (t = new nt(
                  Ca.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : n.type === "orthographic" &&
                (t = new ji(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            Vn(t, n),
            Promise.resolve(t)
          );
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = { joints: t.joints };
          return t.inverseBindMatrices === void 0
            ? Promise.resolve(n)
            : this.getDependency("accessor", t.inverseBindMatrices).then(
                function (i) {
                  return (n.inverseBindMatrices = i), n;
                }
              );
        }
        loadAnimation(e) {
          const n = this.json.animations[e],
            i = [],
            r = [],
            o = [],
            a = [],
            c = [];
          for (let l = 0, u = n.channels.length; l < u; l++) {
            const h = n.channels[l],
              d = n.samplers[h.sampler],
              f = h.target,
              p = f.node !== void 0 ? f.node : f.id,
              x = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
              y = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
            i.push(this.getDependency("node", p)),
              r.push(this.getDependency("accessor", x)),
              o.push(this.getDependency("accessor", y)),
              a.push(d),
              c.push(f);
          }
          return Promise.all([
            Promise.all(i),
            Promise.all(r),
            Promise.all(o),
            Promise.all(a),
            Promise.all(c),
          ]).then(function (l) {
            const u = l[0],
              h = l[1],
              d = l[2],
              f = l[3],
              p = l[4],
              x = [];
            for (let m = 0, g = u.length; m < g; m++) {
              const _ = u[m],
                w = h[m],
                T = d[m],
                v = f[m],
                A = p[m];
              if (_ === void 0) continue;
              _.updateMatrix(), (_.matrixAutoUpdate = !0);
              let L;
              switch (yn[A.path]) {
                case yn.weights:
                  L = Ui;
                  break;
                case yn.rotation:
                  L = si;
                  break;
                case yn.position:
                case yn.scale:
                default:
                  L = zi;
                  break;
              }
              const I = _.name ? _.name : _.uuid,
                N = v.interpolation !== void 0 ? H0[v.interpolation] : Kn,
                U = [];
              yn[A.path] === yn.weights
                ? _.traverse(function (R) {
                    R.isMesh === !0 &&
                      R.morphTargetInfluences &&
                      U.push(R.name ? R.name : R.uuid);
                  })
                : U.push(I);
              let G = T.array;
              if (T.normalized) {
                const R = Ua(G.constructor),
                  D = new Float32Array(G.length);
                for (let F = 0, C = G.length; F < C; F++) D[F] = G[F] * R;
                G = D;
              }
              for (let R = 0, D = U.length; R < D; R++) {
                const F = new L(U[R] + "." + yn[A.path], w.array, G, N);
                v.interpolation === "CUBICSPLINE" &&
                  ((F.createInterpolant = function (V) {
                    return new ki(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      V
                    );
                  }),
                  (F.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  x.push(F);
              }
            }
            const y = n.name ? n.name : "animation_" + e;
            return new Hi(y, void 0, x);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return i.mesh === void 0
            ? null
            : n.getDependency("mesh", i.mesh).then(function (r) {
                const o = n._getNodeRef(n.meshCache, i.mesh, r);
                return (
                  i.weights !== void 0 &&
                    o.traverse(function (a) {
                      if (!!a.isMesh)
                        for (let c = 0, l = i.weights.length; c < l; c++)
                          a.morphTargetInfluences[c] = i.weights[c];
                    }),
                  o
                );
              });
        }
        loadNode(e) {
          const t = this.json,
            n = this.extensions,
            i = this,
            r = t.nodes[e],
            o = r.name ? i.createUniqueName(r.name) : "";
          return (function () {
            const a = [],
              c = i._invokeOne(function (l) {
                return l.createNodeMesh && l.createNodeMesh(e);
              });
            return (
              c && a.push(c),
              r.camera !== void 0 &&
                a.push(
                  i.getDependency("camera", r.camera).then(function (l) {
                    return i._getNodeRef(i.cameraCache, r.camera, l);
                  })
                ),
              i
                ._invokeAll(function (l) {
                  return l.createNodeAttachment && l.createNodeAttachment(e);
                })
                .forEach(function (l) {
                  a.push(l);
                }),
              Promise.all(a)
            );
          })().then(function (a) {
            let c;
            if (
              (r.isBone === !0
                ? (c = new Vr())
                : a.length > 1
                ? (c = new Vt())
                : a.length === 1
                ? (c = a[0])
                : (c = new Ee()),
              c !== a[0])
            )
              for (let l = 0, u = a.length; l < u; l++) c.add(a[l]);
            if (
              (r.name && ((c.userData.name = r.name), (c.name = o)),
              Vn(c, r),
              r.extensions && hr(n, c, r),
              r.matrix !== void 0)
            ) {
              const l = new ce();
              l.fromArray(r.matrix), c.applyMatrix4(l);
            } else r.translation !== void 0 && c.position.fromArray(r.translation), r.rotation !== void 0 && c.quaternion.fromArray(r.rotation), r.scale !== void 0 && c.scale.fromArray(r.scale);
            return i.associations.set(c, { type: "nodes", index: e }), c;
          });
        }
        loadScene(e) {
          const t = this.json,
            n = this.extensions,
            i = this.json.scenes[e],
            r = this,
            o = new Vt();
          i.name && (o.name = r.createUniqueName(i.name)),
            Vn(o, i),
            i.extensions && hr(n, o, i);
          const a = i.nodes || [],
            c = [];
          for (let l = 0, u = a.length; l < u; l++) c.push(af(a[l], o, t, r));
          return Promise.all(c).then(function () {
            return o;
          });
        }
      }
      function af(s, e, t, n) {
        const i = t.nodes[s];
        return n
          .getDependency("node", s)
          .then(function (r) {
            if (i.skin === void 0) return r;
            let o;
            return n
              .getDependency("skin", i.skin)
              .then(function (a) {
                o = a;
                const c = [];
                for (let l = 0, u = o.joints.length; l < u; l++)
                  c.push(n.getDependency("node", o.joints[l]));
                return Promise.all(c);
              })
              .then(function (a) {
                return (
                  r.traverse(function (c) {
                    if (!c.isMesh) return;
                    const l = [],
                      u = [];
                    for (let h = 0, d = a.length; h < d; h++) {
                      const f = a[h];
                      if (f) {
                        l.push(f);
                        const p = new ce();
                        o.inverseBindMatrices !== void 0 &&
                          p.fromArray(o.inverseBindMatrices.array, h * 16),
                          u.push(p);
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          o.joints[h]
                        );
                    }
                    c.bind(new Wr(l, u), c.matrixWorld);
                  }),
                  r
                );
              });
          })
          .then(function (r) {
            e.add(r);
            const o = [];
            if (i.children) {
              const a = i.children;
              for (let c = 0, l = a.length; c < l; c++) {
                const u = a[c];
                o.push(af(u, r, t, n));
              }
            }
            return Promise.all(o);
          });
      }
      function Y0(s, e, t) {
        const n = e.attributes,
          i = new wt();
        if (n.POSITION !== void 0) {
          const a = t.json.accessors[n.POSITION],
            c = a.min,
            l = a.max;
          if (c !== void 0 && l !== void 0) {
            if (
              (i.set(new M(c[0], c[1], c[2]), new M(l[0], l[1], l[2])),
              a.normalized)
            ) {
              const u = Ua(Ir[a.componentType]);
              i.min.multiplyScalar(u), i.max.multiplyScalar(u);
            }
          } else {
            console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
            return;
          }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
          const a = new M(),
            c = new M();
          for (let l = 0, u = r.length; l < u; l++) {
            const h = r[l];
            if (h.POSITION !== void 0) {
              const d = t.json.accessors[h.POSITION],
                f = d.min,
                p = d.max;
              if (f !== void 0 && p !== void 0) {
                if (
                  (c.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))),
                  c.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))),
                  c.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))),
                  d.normalized)
                ) {
                  const x = Ua(Ir[d.componentType]);
                  c.multiplyScalar(x);
                }
                a.max(c);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          i.expandByVector(a);
        }
        s.boundingBox = i;
        const o = new cn();
        i.getCenter(o.center),
          (o.radius = i.min.distanceTo(i.max) / 2),
          (s.boundingSphere = o);
      }
      function pu(s, e, t) {
        const n = e.attributes,
          i = [];
        function r(o, a) {
          return t.getDependency("accessor", o).then(function (c) {
            s.setAttribute(a, c);
          });
        }
        for (const o in n) {
          const a = Oa[o] || o.toLowerCase();
          a in s.attributes || i.push(r(n[o], a));
        }
        if (e.indices !== void 0 && !s.index) {
          const o = t.getDependency("accessor", e.indices).then(function (a) {
            s.setIndex(a);
          });
          i.push(o);
        }
        return (
          Vn(s, e),
          Y0(s, e, t),
          Promise.all(i).then(function () {
            return e.targets !== void 0 ? V0(s, e.targets, t) : s;
          })
        );
      }
      function mu(s, e) {
        let t = s.getIndex();
        if (t === null) {
          const o = [],
            a = s.getAttribute("position");
          if (a !== void 0) {
            for (let c = 0; c < a.count; c++) o.push(c);
            s.setIndex(o), (t = s.getIndex());
          } else
            return (
              console.error(
                "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
              ),
              s
            );
        }
        const n = t.count - 2,
          i = [];
        if (e === Xa)
          for (let o = 1; o <= n; o++)
            i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
        else
          for (let o = 0; o < n; o++)
            o % 2 === 0
              ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2)))
              : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n &&
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
          );
        const r = s.clone();
        return r.setIndex(i), r;
      }
      class Z0 {
        constructor({
          anchor: e = { lat: 0, lng: 0, altitude: 0 },
          rotation: t = new Float32Array([0, 0, 0]),
          scale: n = new Float32Array([1, 1, 1]),
          scene: i,
          THREE: r,
          map: o,
        }) {
          (this.overlay = new google.maps.WebGLOverlayView()),
            (this.renderer = null),
            (this.camera = null),
            (this.anchor = e),
            (this.rotation = t),
            (this.scale = n),
            (this.THREE = r),
            (this.scene = i != null ? i : new this.THREE.Scene()),
            (this.scene.rotation.x = Math.PI / 2),
            (this.overlay.onAdd = this.onAdd.bind(this)),
            (this.overlay.onRemove = this.onRemove.bind(this)),
            (this.overlay.onContextLost = this.onContextLost.bind(this)),
            (this.overlay.onContextRestored =
              this.onContextRestored.bind(this)),
            (this.overlay.onDraw = this.onDraw.bind(this)),
            (this.camera = new this.THREE.PerspectiveCamera()),
            o && this.setMap(o);
        }
        onStateUpdate(e) {
          this.overlay.onStateUpdate(e);
        }
        requestStateUpdate() {
          this.overlay.requestStateUpdate();
        }
        onAdd() {}
        onRemove() {}
        getMap() {
          return this.overlay.getMap();
        }
        requestRedraw() {
          this.overlay.requestRedraw();
        }
        setMap(e) {
          this.overlay.setMap(e);
        }
        addListener(e, t) {
          return this.overlay.addListener(e, t);
        }
        bindTo(e, t, n, i) {
          this.overlay.bindTo(e, t, n, i);
        }
        get(e) {
          return this.overlay.get(e);
        }
        notify(e) {
          this.overlay.notify(e);
        }
        set(e, t) {
          this.overlay.set(e, t);
        }
        setValues(e) {
          this.overlay.setValues(e);
        }
        unbind(e) {
          this.overlay.unbind(e);
        }
        unbindAll() {
          this.overlay.unbindAll();
        }
        onContextRestored({ gl: e }) {
          (this.renderer = new this.THREE.WebGLRenderer(
            Object.assign(
              { canvas: e.canvas, context: e },
              e.getContextAttributes()
            )
          )),
            (this.renderer.autoClear = !1),
            (this.renderer.autoClearDepth = !1),
            (this.renderer.shadowMap.enabled = !0),
            (this.renderer.shadowMap.type = this.THREE.PCFSoftShadowMap),
            (this.renderer.outputEncoding = this.THREE.sRGBEncoding);
          const { width: t, height: n, clientWidth: i } = e.canvas;
          this.renderer.setPixelRatio(t / i), this.renderer.setSize(t, n, !1);
        }
        onContextLost() {
          !this.renderer || (this.renderer.dispose(), (this.renderer = null));
        }
        onDraw({ gl: e, transformer: t }) {
          this.camera.projectionMatrix.fromArray(
            t.fromLatLngAltitude(this.anchor, this.rotation, this.scale)
          ),
            e.disable(e.SCISSOR_TEST),
            this.requestRedraw(),
            this.renderer.render(this.scene, this.camera),
            this.renderer.resetState();
        }
      }
      let ua;
      const ha = {
        tilt: 0,
        heading: 0,
        zoom: 18,
        center: { lat: 35.6594945, lng: 139.6999859 },
        mapId: "15431d2b469f209e",
        disableDefaultUI: !0,
        gestureHandling: "none",
        keyboardShortcuts: !1,
      };
      function J0() {
        const s = document.getElementById("map");
        ua = new google.maps.Map(s, ha);
        const e = new Hr(),
          t = new So(16777215, 0.75);
        e.add(t);
        const n = new Zr(16777215, 0.25);
        n.position.set(0, 10, 50), e.add(n);
        const i = new A0(),
          r =
            "https://raw.githubusercontent.com/googlemaps/js-samples/main/assets/pin.gltf";
        i.load(r, (o) => {
          o.scene.scale.set(10, 10, 10),
            (o.scene.rotation.x = Math.PI / 2),
            e.add(o.scene);
          let { tilt: a, heading: c, zoom: l } = ha;
          const u = () => {
            if (a < 67.5) a += 0.5;
            else if (c <= 360) (c += 0.2), (l -= 5e-4);
            else return;
            ua.moveCamera({ tilt: a, heading: c, zoom: l }),
              requestAnimationFrame(u);
          };
          requestAnimationFrame(u);
        }),
          new Z0({
            map: ua,
            scene: e,
            anchor: { ...ha.center, altitude: 100 },
            THREE: E0,
          });
      }
      window.initMap = J0;
    </script>
    <style>
      #map,
      body,
      html {
        height: 100%;
      }
      body,
      html {
        margin: 0;
        padding: 0;
      }
      #map {
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="map" class="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=beta"
      defer
    ></script>
  </body>
</html>
