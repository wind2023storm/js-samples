<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Marker Clustering</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>

    <script type="module" crossorigin>
      const R = function () {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
          n(s);
        new MutationObserver((s) => {
          for (const o of s)
            if (o.type === "childList")
              for (const a of o.addedNodes)
                a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
        }).observe(document, { childList: !0, subtree: !0 });
        function e(s) {
          const o = {};
          return (
            s.integrity && (o.integrity = s.integrity),
            s.referrerpolicy && (o.referrerPolicy = s.referrerpolicy),
            s.crossorigin === "use-credentials"
              ? (o.credentials = "include")
              : s.crossorigin === "anonymous"
              ? (o.credentials = "omit")
              : (o.credentials = "same-origin"),
            o
          );
        }
        function n(s) {
          if (s.ep) return;
          s.ep = !0;
          const o = e(s);
          fetch(s.href, o);
        }
      };
      R();
      function O(r, t, e, n, s, o) {
        if (s - n <= e) return;
        const a = (n + s) >> 1;
        F(r, t, a, n, s, o % 2),
          O(r, t, e, n, a - 1, o + 1),
          O(r, t, e, a + 1, s, o + 1);
      }
      function F(r, t, e, n, s, o) {
        for (; s > n; ) {
          if (s - n > 600) {
            const l = s - n + 1,
              u = e - n + 1,
              h = Math.log(l),
              f = 0.5 * Math.exp((2 * h) / 3),
              m =
                0.5 *
                Math.sqrt((h * f * (l - f)) / l) *
                (u - l / 2 < 0 ? -1 : 1),
              p = Math.max(n, Math.floor(e - (u * f) / l + m)),
              d = Math.min(s, Math.floor(e + ((l - u) * f) / l + m));
            F(r, t, e, p, d, o);
          }
          const a = t[2 * e + o];
          let c = n,
            i = s;
          for (w(r, t, n, e), t[2 * s + o] > a && w(r, t, n, s); c < i; ) {
            for (w(r, t, c, i), c++, i--; t[2 * c + o] < a; ) c++;
            for (; t[2 * i + o] > a; ) i--;
          }
          t[2 * n + o] === a ? w(r, t, n, i) : (i++, w(r, t, i, s)),
            i <= e && (n = i + 1),
            e <= i && (s = i - 1);
        }
      }
      function w(r, t, e, n) {
        P(r, e, n), P(t, 2 * e, 2 * n), P(t, 2 * e + 1, 2 * n + 1);
      }
      function P(r, t, e) {
        const n = r[t];
        (r[t] = r[e]), (r[e] = n);
      }
      function G(r, t, e, n, s, o, a) {
        const c = [0, r.length - 1, 0],
          i = [];
        let l, u;
        for (; c.length; ) {
          const h = c.pop(),
            f = c.pop(),
            m = c.pop();
          if (f - m <= a) {
            for (let g = m; g <= f; g++)
              (l = t[2 * g]),
                (u = t[2 * g + 1]),
                l >= e && l <= s && u >= n && u <= o && i.push(r[g]);
            continue;
          }
          const p = Math.floor((m + f) / 2);
          (l = t[2 * p]),
            (u = t[2 * p + 1]),
            l >= e && l <= s && u >= n && u <= o && i.push(r[p]);
          const d = (h + 1) % 2;
          (h === 0 ? e <= l : n <= u) && (c.push(m), c.push(p - 1), c.push(d)),
            (h === 0 ? s >= l : o >= u) &&
              (c.push(p + 1), c.push(f), c.push(d));
        }
        return i;
      }
      function U(r, t, e, n, s, o) {
        const a = [0, r.length - 1, 0],
          c = [],
          i = s * s;
        for (; a.length; ) {
          const l = a.pop(),
            u = a.pop(),
            h = a.pop();
          if (u - h <= o) {
            for (let g = h; g <= u; g++)
              S(t[2 * g], t[2 * g + 1], e, n) <= i && c.push(r[g]);
            continue;
          }
          const f = Math.floor((h + u) / 2),
            m = t[2 * f],
            p = t[2 * f + 1];
          S(m, p, e, n) <= i && c.push(r[f]);
          const d = (l + 1) % 2;
          (l === 0 ? e - s <= m : n - s <= p) &&
            (a.push(h), a.push(f - 1), a.push(d)),
            (l === 0 ? e + s >= m : n + s >= p) &&
              (a.push(f + 1), a.push(u), a.push(d));
        }
        return c;
      }
      function S(r, t, e, n) {
        const s = r - e,
          o = t - n;
        return s * s + o * o;
      }
      const B = (r) => r[0],
        $ = (r) => r[1];
      class b {
        constructor(t, e = B, n = $, s = 64, o = Float64Array) {
          (this.nodeSize = s), (this.points = t);
          const a = t.length < 65536 ? Uint16Array : Uint32Array,
            c = (this.ids = new a(t.length)),
            i = (this.coords = new o(t.length * 2));
          for (let l = 0; l < t.length; l++)
            (c[l] = l), (i[2 * l] = e(t[l])), (i[2 * l + 1] = n(t[l]));
          O(c, i, s, 0, c.length - 1, 0);
        }
        range(t, e, n, s) {
          return G(this.ids, this.coords, t, e, n, s, this.nodeSize);
        }
        within(t, e, n) {
          return U(this.ids, this.coords, t, e, n, this.nodeSize);
        }
      }
      const K = {
          minZoom: 0,
          maxZoom: 16,
          minPoints: 2,
          radius: 40,
          extent: 512,
          nodeSize: 64,
          log: !1,
          generateId: !1,
          reduce: null,
          map: (r) => r,
        },
        v =
          Math.fround ||
          ((r) => (t) => ((r[0] = +t), r[0]))(new Float32Array(1));
      class H {
        constructor(t) {
          (this.options = x(Object.create(K), t)),
            (this.trees = new Array(this.options.maxZoom + 1));
        }
        load(t) {
          const { log: e, minZoom: n, maxZoom: s, nodeSize: o } = this.options;
          e && console.time("total time");
          const a = `prepare ${t.length} points`;
          e && console.time(a), (this.points = t);
          let c = [];
          for (let i = 0; i < t.length; i++)
            !t[i].geometry || c.push(W(t[i], i));
          (this.trees[s + 1] = new b(c, N, j, o, Float32Array)),
            e && console.timeEnd(a);
          for (let i = s; i >= n; i--) {
            const l = +Date.now();
            (c = this._cluster(c, i)),
              (this.trees[i] = new b(c, N, j, o, Float32Array)),
              e &&
                console.log(
                  "z%d: %d clusters in %dms",
                  i,
                  c.length,
                  +Date.now() - l
                );
          }
          return e && console.timeEnd("total time"), this;
        }
        getClusters(t, e) {
          let n = ((((t[0] + 180) % 360) + 360) % 360) - 180;
          const s = Math.max(-90, Math.min(90, t[1]));
          let o =
            t[2] === 180 ? 180 : ((((t[2] + 180) % 360) + 360) % 360) - 180;
          const a = Math.max(-90, Math.min(90, t[3]));
          if (t[2] - t[0] >= 360) (n = -180), (o = 180);
          else if (n > o) {
            const u = this.getClusters([n, s, 180, a], e),
              h = this.getClusters([-180, s, o, a], e);
            return u.concat(h);
          }
          const c = this.trees[this._limitZoom(e)],
            i = c.range(k(n), _(a), k(o), _(s)),
            l = [];
          for (const u of i) {
            const h = c.points[u];
            l.push(h.numPoints ? A(h) : this.points[h.index]);
          }
          return l;
        }
        getChildren(t) {
          const e = this._getOriginId(t),
            n = this._getOriginZoom(t),
            s = "No cluster with the specified id.",
            o = this.trees[n];
          if (!o) throw new Error(s);
          const a = o.points[e];
          if (!a) throw new Error(s);
          const c =
              this.options.radius / (this.options.extent * Math.pow(2, n - 1)),
            i = o.within(a.x, a.y, c),
            l = [];
          for (const u of i) {
            const h = o.points[u];
            h.parentId === t &&
              l.push(h.numPoints ? A(h) : this.points[h.index]);
          }
          if (l.length === 0) throw new Error(s);
          return l;
        }
        getLeaves(t, e, n) {
          (e = e || 10), (n = n || 0);
          const s = [];
          return this._appendLeaves(s, t, e, n, 0), s;
        }
        getTile(t, e, n) {
          const s = this.trees[this._limitZoom(t)],
            o = Math.pow(2, t),
            { extent: a, radius: c } = this.options,
            i = c / a,
            l = (n - i) / o,
            u = (n + 1 + i) / o,
            h = { features: [] };
          return (
            this._addTileFeatures(
              s.range((e - i) / o, l, (e + 1 + i) / o, u),
              s.points,
              e,
              n,
              o,
              h
            ),
            e === 0 &&
              this._addTileFeatures(
                s.range(1 - i / o, l, 1, u),
                s.points,
                o,
                n,
                o,
                h
              ),
            e === o - 1 &&
              this._addTileFeatures(
                s.range(0, l, i / o, u),
                s.points,
                -1,
                n,
                o,
                h
              ),
            h.features.length ? h : null
          );
        }
        getClusterExpansionZoom(t) {
          let e = this._getOriginZoom(t) - 1;
          for (; e <= this.options.maxZoom; ) {
            const n = this.getChildren(t);
            if ((e++, n.length !== 1)) break;
            t = n[0].properties.cluster_id;
          }
          return e;
        }
        _appendLeaves(t, e, n, s, o) {
          const a = this.getChildren(e);
          for (const c of a) {
            const i = c.properties;
            if (
              (i && i.cluster
                ? o + i.point_count <= s
                  ? (o += i.point_count)
                  : (o = this._appendLeaves(t, i.cluster_id, n, s, o))
                : o < s
                ? o++
                : t.push(c),
              t.length === n)
            )
              break;
          }
          return o;
        }
        _addTileFeatures(t, e, n, s, o, a) {
          for (const c of t) {
            const i = e[c],
              l = i.numPoints;
            let u, h, f;
            if (l) (u = z(i)), (h = i.x), (f = i.y);
            else {
              const d = this.points[i.index];
              (u = d.properties),
                (h = k(d.geometry.coordinates[0])),
                (f = _(d.geometry.coordinates[1]));
            }
            const m = {
              type: 1,
              geometry: [
                [
                  Math.round(this.options.extent * (h * o - n)),
                  Math.round(this.options.extent * (f * o - s)),
                ],
              ],
              tags: u,
            };
            let p;
            l
              ? (p = i.id)
              : this.options.generateId
              ? (p = i.index)
              : this.points[i.index].id && (p = this.points[i.index].id),
              p !== void 0 && (m.id = p),
              a.features.push(m);
          }
        }
        _limitZoom(t) {
          return Math.max(
            this.options.minZoom,
            Math.min(Math.floor(+t), this.options.maxZoom + 1)
          );
        }
        _cluster(t, e) {
          const n = [],
            { radius: s, extent: o, reduce: a, minPoints: c } = this.options,
            i = s / (o * Math.pow(2, e));
          for (let l = 0; l < t.length; l++) {
            const u = t[l];
            if (u.zoom <= e) continue;
            u.zoom = e;
            const h = this.trees[e + 1],
              f = h.within(u.x, u.y, i),
              m = u.numPoints || 1;
            let p = m;
            for (const d of f) {
              const g = h.points[d];
              g.zoom > e && (p += g.numPoints || 1);
            }
            if (p > m && p >= c) {
              let d = u.x * m,
                g = u.y * m,
                C = a && m > 1 ? this._map(u, !0) : null;
              const L = (l << 5) + (e + 1) + this.points.length;
              for (const D of f) {
                const y = h.points[D];
                if (y.zoom <= e) continue;
                y.zoom = e;
                const E = y.numPoints || 1;
                (d += y.x * E),
                  (g += y.y * E),
                  (y.parentId = L),
                  a && (C || (C = this._map(u, !0)), a(C, this._map(y)));
              }
              (u.parentId = L), n.push(V(d / p, g / p, L, p, C));
            } else if ((n.push(u), p > 1))
              for (const d of f) {
                const g = h.points[d];
                g.zoom <= e || ((g.zoom = e), n.push(g));
              }
          }
          return n;
        }
        _getOriginId(t) {
          return (t - this.points.length) >> 5;
        }
        _getOriginZoom(t) {
          return (t - this.points.length) % 32;
        }
        _map(t, e) {
          if (t.numPoints) return e ? x({}, t.properties) : t.properties;
          const n = this.points[t.index].properties,
            s = this.options.map(n);
          return e && s === n ? x({}, s) : s;
        }
      }
      function V(r, t, e, n, s) {
        return {
          x: v(r),
          y: v(t),
          zoom: 1 / 0,
          id: e,
          parentId: -1,
          numPoints: n,
          properties: s,
        };
      }
      function W(r, t) {
        const [e, n] = r.geometry.coordinates;
        return { x: v(k(e)), y: v(_(n)), zoom: 1 / 0, index: t, parentId: -1 };
      }
      function A(r) {
        return {
          type: "Feature",
          id: r.id,
          properties: z(r),
          geometry: { type: "Point", coordinates: [J(r.x), X(r.y)] },
        };
      }
      function z(r) {
        const t = r.numPoints,
          e =
            t >= 1e4
              ? `${Math.round(t / 1e3)}k`
              : t >= 1e3
              ? `${Math.round(t / 100) / 10}k`
              : t;
        return x(x({}, r.properties), {
          cluster: !0,
          cluster_id: r.id,
          point_count: t,
          point_count_abbreviated: e,
        });
      }
      function k(r) {
        return r / 360 + 0.5;
      }
      function _(r) {
        const t = Math.sin((r * Math.PI) / 180),
          e = 0.5 - (0.25 * Math.log((1 + t) / (1 - t))) / Math.PI;
        return e < 0 ? 0 : e > 1 ? 1 : e;
      }
      function J(r) {
        return (r - 0.5) * 360;
      }
      function X(r) {
        const t = ((180 - r * 360) * Math.PI) / 180;
        return (360 * Math.atan(Math.exp(t))) / Math.PI - 90;
      }
      function x(r, t) {
        for (const e in t) r[e] = t[e];
        return r;
      }
      function N(r) {
        return r.x;
      }
      function j(r) {
        return r.y;
      }
      var T = function r(t, e) {
        if (t === e) return !0;
        if (t && e && typeof t == "object" && typeof e == "object") {
          if (t.constructor !== e.constructor) return !1;
          var n, s, o;
          if (Array.isArray(t)) {
            if (((n = t.length), n != e.length)) return !1;
            for (s = n; s-- !== 0; ) if (!r(t[s], e[s])) return !1;
            return !0;
          }
          if (t.constructor === RegExp)
            return t.source === e.source && t.flags === e.flags;
          if (t.valueOf !== Object.prototype.valueOf)
            return t.valueOf() === e.valueOf();
          if (t.toString !== Object.prototype.toString)
            return t.toString() === e.toString();
          if (
            ((o = Object.keys(t)), (n = o.length), n !== Object.keys(e).length)
          )
            return !1;
          for (s = n; s-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(e, o[s])) return !1;
          for (s = n; s-- !== 0; ) {
            var a = o[s];
            if (!r(t[a], e[a])) return !1;
          }
          return !0;
        }
        return t !== t && e !== e;
      };
      /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ function Q(
        r,
        t
      ) {
        var e = {};
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) &&
            t.indexOf(n) < 0 &&
            (e[n] = r[n]);
        if (r != null && typeof Object.getOwnPropertySymbols == "function")
          for (
            var s = 0, n = Object.getOwnPropertySymbols(r);
            s < n.length;
            s++
          )
            t.indexOf(n[s]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(r, n[s]) &&
              (e[n[s]] = r[n[s]]);
        return e;
      }
      class I {
        constructor({ markers: t, position: e }) {
          (this.markers = t),
            e &&
              (e instanceof google.maps.LatLng
                ? (this._position = e)
                : (this._position = new google.maps.LatLng(e)));
        }
        get bounds() {
          if (!(this.markers.length === 0 && !this._position))
            return this.markers.reduce(
              (t, e) => t.extend(e.getPosition()),
              new google.maps.LatLngBounds(this._position, this._position)
            );
        }
        get position() {
          return this._position || this.bounds.getCenter();
        }
        get count() {
          return this.markers.filter((t) => t.getVisible()).length;
        }
        push(t) {
          this.markers.push(t);
        }
        delete() {
          this.marker && (this.marker.setMap(null), delete this.marker),
            (this.markers.length = 0);
        }
      }
      class Y {
        constructor({ maxZoom: t = 16 }) {
          this.maxZoom = t;
        }
        noop({ markers: t }) {
          return q(t);
        }
      }
      const q = (r) =>
        r.map((e) => new I({ position: e.getPosition(), markers: [e] }));
      class tt extends Y {
        constructor(t) {
          var { maxZoom: e, radius: n = 60 } = t,
            s = Q(t, ["maxZoom", "radius"]);
          super({ maxZoom: e }),
            (this.superCluster = new H(
              Object.assign({ maxZoom: this.maxZoom, radius: n }, s)
            )),
            (this.state = { zoom: null });
        }
        calculate(t) {
          let e = !1;
          if (!T(t.markers, this.markers)) {
            (e = !0), (this.markers = [...t.markers]);
            const s = this.markers.map((o) => ({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [o.getPosition().lng(), o.getPosition().lat()],
              },
              properties: { marker: o },
            }));
            this.superCluster.load(s);
          }
          const n = { zoom: t.map.getZoom() };
          return (
            e ||
              (this.state.zoom > this.maxZoom && n.zoom > this.maxZoom) ||
              (e = e || !T(this.state, n)),
            (this.state = n),
            e && (this.clusters = this.cluster(t)),
            { clusters: this.clusters, changed: e }
          );
        }
        cluster({ map: t }) {
          return this.superCluster
            .getClusters([-180, -90, 180, 90], Math.round(t.getZoom()))
            .map(this.transformCluster.bind(this));
        }
        transformCluster({
          geometry: {
            coordinates: [t, e],
          },
          properties: n,
        }) {
          if (n.cluster)
            return new I({
              markers: this.superCluster
                .getLeaves(n.cluster_id, 1 / 0)
                .map((s) => s.properties.marker),
              position: new google.maps.LatLng({ lat: e, lng: t }),
            });
          {
            const s = n.marker;
            return new I({ markers: [s], position: s.getPosition() });
          }
        }
      }
      class et {
        constructor(t, e) {
          this.markers = { sum: t.length };
          const n = e.map((o) => o.count),
            s = n.reduce((o, a) => o + a, 0);
          this.clusters = {
            count: e.length,
            markers: {
              mean: s / e.length,
              sum: s,
              min: Math.min(...n),
              max: Math.max(...n),
            },
          };
        }
      }
      class nt {
        render({ count: t, position: e }, n) {
          const s =
              t > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff",
            o = window.btoa(`
  <svg fill="${s}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
    <circle cx="120" cy="120" opacity=".6" r="70" />
    <circle cx="120" cy="120" opacity=".3" r="90" />
    <circle cx="120" cy="120" opacity=".2" r="110" />
  </svg>`);
          return new google.maps.Marker({
            position: e,
            icon: {
              url: `data:image/svg+xml;base64,${o}`,
              scaledSize: new google.maps.Size(45, 45),
            },
            label: {
              text: String(t),
              color: "rgba(255,255,255,0.9)",
              fontSize: "12px",
            },
            title: `Cluster of ${t} markers`,
            zIndex: Number(google.maps.Marker.MAX_ZINDEX) + t,
          });
        }
      }
      function st(r, t) {
        for (let e in t.prototype) r.prototype[e] = t.prototype[e];
      }
      class Z {
        constructor() {
          st(Z, google.maps.OverlayView);
        }
      }
      var M;
      (function (r) {
        (r.CLUSTERING_BEGIN = "clusteringbegin"),
          (r.CLUSTERING_END = "clusteringend"),
          (r.CLUSTER_CLICK = "click");
      })(M || (M = {}));
      const rt = (r, t, e) => {
        e.fitBounds(t.bounds);
      };
      class ot extends Z {
        constructor({
          map: t,
          markers: e = [],
          algorithm: n = new tt({}),
          renderer: s = new nt(),
          onClusterClick: o = rt,
        }) {
          super(),
            (this.markers = [...e]),
            (this.clusters = []),
            (this.algorithm = n),
            (this.renderer = s),
            (this.onClusterClick = o),
            t && this.setMap(t);
        }
        addMarker(t, e) {
          this.markers.includes(t) ||
            (this.markers.push(t), e || this.render());
        }
        addMarkers(t, e) {
          t.forEach((n) => {
            this.addMarker(n, !0);
          }),
            e || this.render();
        }
        removeMarker(t, e) {
          const n = this.markers.indexOf(t);
          return n === -1
            ? !1
            : (t.setMap(null),
              this.markers.splice(n, 1),
              e || this.render(),
              !0);
        }
        removeMarkers(t, e) {
          let n = !1;
          return (
            t.forEach((s) => {
              n = this.removeMarker(s, !0) || n;
            }),
            n && !e && this.render(),
            n
          );
        }
        clearMarkers(t) {
          (this.markers.length = 0), t || this.render();
        }
        render() {
          const t = this.getMap();
          if (t instanceof google.maps.Map && this.getProjection()) {
            google.maps.event.trigger(this, M.CLUSTERING_BEGIN, this);
            const { clusters: e, changed: n } = this.algorithm.calculate({
              markers: this.markers,
              map: t,
              mapCanvasProjection: this.getProjection(),
            });
            (n || n == null) &&
              (this.reset(), (this.clusters = e), this.renderClusters()),
              google.maps.event.trigger(this, M.CLUSTERING_END, this);
          }
        }
        onAdd() {
          (this.idleListener = this.getMap().addListener(
            "idle",
            this.render.bind(this)
          )),
            this.render();
        }
        onRemove() {
          google.maps.event.removeListener(this.idleListener), this.reset();
        }
        reset() {
          this.markers.forEach((t) => t.setMap(null)),
            this.clusters.forEach((t) => t.delete()),
            (this.clusters = []);
        }
        renderClusters() {
          const t = new et(this.markers, this.clusters),
            e = this.getMap();
          this.clusters.forEach((n) => {
            n.markers.length === 1
              ? (n.marker = n.markers[0])
              : ((n.marker = this.renderer.render(n, t)),
                this.onClusterClick &&
                  n.marker.addListener("click", (s) => {
                    google.maps.event.trigger(this, M.CLUSTER_CLICK, n),
                      this.onClusterClick(s, n, e);
                  })),
              n.marker.setMap(e);
          });
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * SPDX-License-Identifier: Apache-2.0
       */ function it() {
        const r = new google.maps.Map(document.getElementById("map"), {
            zoom: 3,
            center: { lat: -28.024, lng: 140.887 },
          }),
          t = new google.maps.InfoWindow({ content: "", disableAutoPan: !0 }),
          e = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          n = at.map((s, o) => {
            const a = e[o % e.length],
              c = new google.maps.Marker({ position: s, label: a });
            return (
              c.addListener("click", () => {
                t.setContent(a), t.open(r, c);
              }),
              c
            );
          });
        new ot({ markers: n, map: r });
      }
      const at = [
        { lat: -31.56391, lng: 147.154312 },
        { lat: -33.718234, lng: 150.363181 },
        { lat: -33.727111, lng: 150.371124 },
        { lat: -33.848588, lng: 151.209834 },
        { lat: -33.851702, lng: 151.216968 },
        { lat: -34.671264, lng: 150.863657 },
        { lat: -35.304724, lng: 148.662905 },
        { lat: -36.817685, lng: 175.699196 },
        { lat: -36.828611, lng: 175.790222 },
        { lat: -37.75, lng: 145.116667 },
        { lat: -37.759859, lng: 145.128708 },
        { lat: -37.765015, lng: 145.133858 },
        { lat: -37.770104, lng: 145.143299 },
        { lat: -37.7737, lng: 145.145187 },
        { lat: -37.774785, lng: 145.137978 },
        { lat: -37.819616, lng: 144.968119 },
        { lat: -38.330766, lng: 144.695692 },
        { lat: -39.927193, lng: 175.053218 },
        { lat: -41.330162, lng: 174.865694 },
        { lat: -42.734358, lng: 147.439506 },
        { lat: -42.734358, lng: 147.501315 },
        { lat: -42.735258, lng: 147.438 },
        { lat: -43.999792, lng: 170.463352 },
      ];
      window.initMap = it;
    </script>
    <style>
      #map,
      body,
      html {
        height: 100%;
      }
      body,
      html {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=weekly"
      defer
    ></script>
  </body>
</html>
