<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
<style type="text/css">
  /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
  #map {
    height: 100%;
  }

  /* Optional: Makes the sample page fill the window. */
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
  }
</style>
<script>
  /*! For license information please see iframe.js.LICENSE.txt */
  (() => {
    var t = {
        521: (t) => {
          function e(t, e, r, s) {
            (this.dataset = []),
              (this.epsilon = 1),
              (this.minPts = 2),
              (this.distance = this._euclideanDistance),
              (this.clusters = []),
              (this.noise = []),
              (this._visited = []),
              (this._assigned = []),
              (this._datasetLength = 0),
              this._init(t, e, r, s);
          }
          (e.prototype.run = function (t, e, r, s) {
            this._init(t, e, r, s);
            for (var i = 0; i < this._datasetLength; i++)
              if (1 !== this._visited[i]) {
                this._visited[i] = 1;
                var n = this._regionQuery(i);
                if (n.length < this.minPts) this.noise.push(i);
                else {
                  var o = this.clusters.length;
                  this.clusters.push([]),
                    this._addToCluster(i, o),
                    this._expandCluster(o, n);
                }
              }
            return this.clusters;
          }),
            (e.prototype._init = function (t, e, r, s) {
              if (t) {
                if (!(t instanceof Array))
                  throw Error(
                    "Dataset must be of type array, " + typeof t + " given"
                  );
                (this.dataset = t),
                  (this.clusters = []),
                  (this.noise = []),
                  (this._datasetLength = t.length),
                  (this._visited = new Array(this._datasetLength)),
                  (this._assigned = new Array(this._datasetLength));
              }
              e && (this.epsilon = e),
                r && (this.minPts = r),
                s && (this.distance = s);
            }),
            (e.prototype._expandCluster = function (t, e) {
              for (var r = 0; r < e.length; r++) {
                var s = e[r];
                if (1 !== this._visited[s]) {
                  this._visited[s] = 1;
                  var i = this._regionQuery(s);
                  i.length >= this.minPts && (e = this._mergeArrays(e, i));
                }
                1 !== this._assigned[s] && this._addToCluster(s, t);
              }
            }),
            (e.prototype._addToCluster = function (t, e) {
              this.clusters[e].push(t), (this._assigned[t] = 1);
            }),
            (e.prototype._regionQuery = function (t) {
              for (var e = [], r = 0; r < this._datasetLength; r++)
                this.distance(this.dataset[t], this.dataset[r]) <
                  this.epsilon && e.push(r);
              return e;
            }),
            (e.prototype._mergeArrays = function (t, e) {
              for (var r = e.length, s = 0; s < r; s++) {
                var i = e[s];
                t.indexOf(i) < 0 && t.push(i);
              }
              return t;
            }),
            (e.prototype._euclideanDistance = function (t, e) {
              for (var r = 0, s = Math.min(t.length, e.length); s--; )
                r += (t[s] - e[s]) * (t[s] - e[s]);
              return Math.sqrt(r);
            }),
            t.exports && (t.exports = e);
        },
        790: (t) => {
          function e(t, e, r) {
            (this.k = 3),
              (this.dataset = []),
              (this.assignments = []),
              (this.centroids = []),
              this.init(t, e, r);
          }
          (e.prototype.init = function (t, e, r) {
            (this.assignments = []),
              (this.centroids = []),
              void 0 !== t && (this.dataset = t),
              void 0 !== e && (this.k = e),
              void 0 !== r && (this.distance = r);
          }),
            (e.prototype.run = function (t, e) {
              this.init(t, e);
              for (var r = this.dataset.length, s = 0; s < this.k; s++)
                this.centroids[s] = this.randomCentroid();
              for (var i = !0; i; ) {
                i = this.assign();
                for (var n = 0; n < this.k; n++) {
                  for (var o = new Array(l), a = 0, h = 0; h < l; h++) o[h] = 0;
                  for (var u = 0; u < r; u++) {
                    var l = this.dataset[u].length;
                    if (n === this.assignments[u]) {
                      for (h = 0; h < l; h++) o[h] += this.dataset[u][h];
                      a++;
                    }
                  }
                  if (a > 0) {
                    for (h = 0; h < l; h++) o[h] /= a;
                    this.centroids[n] = o;
                  } else (this.centroids[n] = this.randomCentroid()), (i = !0);
                }
              }
              return this.getClusters();
            }),
            (e.prototype.randomCentroid = function () {
              var t,
                e,
                r = this.dataset.length - 1;
              do {
                (e = Math.round(Math.random() * r)), (t = this.dataset[e]);
              } while (this.centroids.indexOf(t) >= 0);
              return t;
            }),
            (e.prototype.assign = function () {
              for (var t, e = !1, r = this.dataset.length, s = 0; s < r; s++)
                (t = this.argmin(
                  this.dataset[s],
                  this.centroids,
                  this.distance
                )) != this.assignments[s] &&
                  ((this.assignments[s] = t), (e = !0));
              return e;
            }),
            (e.prototype.getClusters = function () {
              for (
                var t, e = new Array(this.k), r = 0;
                r < this.assignments.length;
                r++
              )
                void 0 === e[(t = this.assignments[r])] && (e[t] = []),
                  e[t].push(r);
              return e;
            }),
            (e.prototype.argmin = function (t, e, r) {
              for (
                var s, i = Number.MAX_VALUE, n = 0, o = e.length, a = 0;
                a < o;
                a++
              )
                (s = r(t, e[a])) < i && ((i = s), (n = a));
              return n;
            }),
            (e.prototype.distance = function (t, e) {
              for (var r = 0, s = Math.min(t.length, e.length); s--; ) {
                var i = t[s] - e[s];
                r += i * i;
              }
              return Math.sqrt(r);
            }),
            t.exports && (t.exports = e);
        },
        239: (t, e, r) => {
          if (t.exports) var s = r(856);
          function i(t, e, r, s) {
            (this.epsilon = 1),
              (this.minPts = 1),
              (this.distance = this._euclideanDistance),
              (this._reachability = []),
              (this._processed = []),
              (this._coreDistance = 0),
              (this._orderedList = []),
              this._init(t, e, r, s);
          }
          (i.prototype.run = function (t, e, r, i) {
            this._init(t, e, r, i);
            for (var n = 0, o = this.dataset.length; n < o; n++)
              if (1 !== this._processed[n]) {
                (this._processed[n] = 1), this.clusters.push([n]);
                var a = this.clusters.length - 1;
                this._orderedList.push(n);
                var h = new s(null, null, "asc"),
                  u = this._regionQuery(n);
                void 0 !== this._distanceToCore(n) &&
                  (this._updateQueue(n, u, h), this._expandCluster(a, h));
              }
            return this.clusters;
          }),
            (i.prototype.getReachabilityPlot = function () {
              for (
                var t = [], e = 0, r = this._orderedList.length;
                e < r;
                e++
              ) {
                var s = this._orderedList[e],
                  i = this._reachability[s];
                t.push([s, i]);
              }
              return t;
            }),
            (i.prototype._init = function (t, e, r, s) {
              if (t) {
                if (!(t instanceof Array))
                  throw Error(
                    "Dataset must be of type array, " + typeof t + " given"
                  );
                (this.dataset = t),
                  (this.clusters = []),
                  (this._reachability = new Array(this.dataset.length)),
                  (this._processed = new Array(this.dataset.length)),
                  (this._coreDistance = 0),
                  (this._orderedList = []);
              }
              e && (this.epsilon = e),
                r && (this.minPts = r),
                s && (this.distance = s);
            }),
            (i.prototype._updateQueue = function (t, e, r) {
              var s = this;
              (this._coreDistance = this._distanceToCore(t)),
                e.forEach(function (e) {
                  if (void 0 === s._processed[e]) {
                    var i = s.distance(s.dataset[t], s.dataset[e]),
                      n = Math.max(s._coreDistance, i);
                    void 0 === s._reachability[e]
                      ? ((s._reachability[e] = n), r.insert(e, n))
                      : n < s._reachability[e] &&
                        ((s._reachability[e] = n), r.remove(e), r.insert(e, n));
                  }
                });
            }),
            (i.prototype._expandCluster = function (t, e) {
              for (var r = e.getElements(), s = 0, i = r.length; s < i; s++) {
                var n = r[s];
                if (void 0 === this._processed[n]) {
                  var o = this._regionQuery(n);
                  (this._processed[n] = 1),
                    this.clusters[t].push(n),
                    this._orderedList.push(n),
                    void 0 !== this._distanceToCore(n) &&
                      (this._updateQueue(n, o, e), this._expandCluster(t, e));
                }
              }
            }),
            (i.prototype._distanceToCore = function (t) {
              for (var e = this.epsilon, r = 0; r < e; r++)
                if (this._regionQuery(t, r).length >= this.minPts) return r;
            }),
            (i.prototype._regionQuery = function (t, e) {
              e = e || this.epsilon;
              for (var r = [], s = 0, i = this.dataset.length; s < i; s++)
                this.distance(this.dataset[t], this.dataset[s]) < e &&
                  r.push(s);
              return r;
            }),
            (i.prototype._euclideanDistance = function (t, e) {
              for (var r = 0, s = Math.min(t.length, e.length); s--; )
                r += (t[s] - e[s]) * (t[s] - e[s]);
              return Math.sqrt(r);
            }),
            t.exports && (t.exports = i);
        },
        856: (t) => {
          function e(t, e, r) {
            (this._queue = []),
              (this._priorities = []),
              (this._sorting = "desc"),
              this._init(t, e, r);
          }
          (e.prototype.insert = function (t, e) {
            for (var r = this._queue.length, s = r; s--; ) {
              var i = this._priorities[s];
              "desc" === this._sorting ? e > i && (r = s) : e < i && (r = s);
            }
            this._insertAt(t, e, r);
          }),
            (e.prototype.remove = function (t) {
              for (var e = this._queue.length; e--; )
                if (t === this._queue[e]) {
                  this._queue.splice(e, 1), this._priorities.splice(e, 1);
                  break;
                }
            }),
            (e.prototype.forEach = function (t) {
              this._queue.forEach(t);
            }),
            (e.prototype.getElements = function () {
              return this._queue;
            }),
            (e.prototype.getElementPriority = function (t) {
              return this._priorities[t];
            }),
            (e.prototype.getPriorities = function () {
              return this._priorities;
            }),
            (e.prototype.getElementsWithPriorities = function () {
              for (var t = [], e = 0, r = this._queue.length; e < r; e++)
                t.push([this._queue[e], this._priorities[e]]);
              return t;
            }),
            (e.prototype._init = function (t, e, r) {
              if (t && e) {
                if (
                  ((this._queue = []),
                  (this._priorities = []),
                  t.length !== e.length)
                )
                  throw new Error("Arrays must have the same length");
                for (var s = 0; s < t.length; s++) this.insert(t[s], e[s]);
              }
              r && (this._sorting = r);
            }),
            (e.prototype._insertAt = function (t, e, r) {
              this._queue.length === r
                ? (this._queue.push(t), this._priorities.push(e))
                : (this._queue.splice(r, 0, t),
                  this._priorities.splice(r, 0, e));
            }),
            t.exports && (t.exports = e);
        },
        194: (t, e, r) => {
          t.exports &&
            (t.exports = {
              DBSCAN: r(521),
              KMEANS: r(790),
              OPTICS: r(239),
              PriorityQueue: r(856),
            });
        },
        617: (t) => {
          "use strict";
          t.exports = function t(e, r) {
            if (e === r) return !0;
            if (e && r && "object" == typeof e && "object" == typeof r) {
              if (e.constructor !== r.constructor) return !1;
              var s, i, n;
              if (Array.isArray(e)) {
                if ((s = e.length) != r.length) return !1;
                for (i = s; 0 != i--; ) if (!t(e[i], r[i])) return !1;
                return !0;
              }
              if (e instanceof Map && r instanceof Map) {
                if (e.size !== r.size) return !1;
                for (i of e.entries()) if (!r.has(i[0])) return !1;
                for (i of e.entries()) if (!t(i[1], r.get(i[0]))) return !1;
                return !0;
              }
              if (e instanceof Set && r instanceof Set) {
                if (e.size !== r.size) return !1;
                for (i of e.entries()) if (!r.has(i[0])) return !1;
                return !0;
              }
              if (ArrayBuffer.isView(e) && ArrayBuffer.isView(r)) {
                if ((s = e.length) != r.length) return !1;
                for (i = s; 0 != i--; ) if (e[i] !== r[i]) return !1;
                return !0;
              }
              if (e.constructor === RegExp)
                return e.source === r.source && e.flags === r.flags;
              if (e.valueOf !== Object.prototype.valueOf)
                return e.valueOf() === r.valueOf();
              if (e.toString !== Object.prototype.toString)
                return e.toString() === r.toString();
              if ((s = (n = Object.keys(e)).length) !== Object.keys(r).length)
                return !1;
              for (i = s; 0 != i--; )
                if (!Object.prototype.hasOwnProperty.call(r, n[i])) return !1;
              for (i = s; 0 != i--; ) {
                var o = n[i];
                if (!t(e[o], r[o])) return !1;
              }
              return !0;
            }
            return e != e && r != r;
          };
        },
        458: (t) => {
          "use strict";
          t.exports = {
            eudist: function (t, e, r) {
              for (var s = t.length, i = 0, n = 0; n < s; n++) {
                var o = (t[n] || 0) - (e[n] || 0);
                i += o * o;
              }
              return r ? Math.sqrt(i) : i;
            },
            mandist: function (t, e, r) {
              for (var s = t.length, i = 0, n = 0; n < s; n++)
                i += Math.abs((t[n] || 0) - (e[n] || 0));
              return r ? Math.sqrt(i) : i;
            },
            dist: function (t, e, r) {
              var s = Math.abs(t - e);
              return r ? s : s * s;
            },
          };
        },
        191: (t, e, r) => {
          "use strict";
          var s = r(458),
            i = s.eudist,
            n = s.dist;
          t.exports = {
            kmrand: function (t, e) {
              for (
                var r = {},
                  s = [],
                  i = e << 2,
                  n = t.length,
                  o = t[0].length > 0;
                s.length < e && i-- > 0;

              ) {
                var a = t[Math.floor(Math.random() * n)],
                  h = o ? a.join("_") : "" + a;
                r[h] || ((r[h] = !0), s.push(a));
              }
              if (s.length < e)
                throw new Error("Error initializating clusters");
              return s;
            },
            kmpp: function (t, e) {
              var r = t[0].length ? i : n,
                s = [],
                o = t.length,
                a = t[0].length > 0,
                h = t[Math.floor(Math.random() * o)];
              for (a && h.join("_"), s.push(h); s.length < e; ) {
                for (
                  var u = [], l = s.length, c = 0, p = [], d = 0;
                  d < o;
                  d++
                ) {
                  for (var f = 1 / 0, g = 0; g < l; g++) {
                    var m = r(t[d], s[g]);
                    m <= f && (f = m);
                  }
                  u[d] = f;
                }
                for (var _ = 0; _ < o; _++) c += u[_];
                for (var v = 0; v < o; v++)
                  p[v] = { i: v, v: t[v], pr: u[v] / c, cs: 0 };
                p.sort(function (t, e) {
                  return t.pr - e.pr;
                }),
                  (p[0].cs = p[0].pr);
                for (var y = 1; y < o; y++) p[y].cs = p[y - 1].cs + p[y].pr;
                for (
                  var x = Math.random(), M = 0;
                  M < o - 1 && p[M++].cs < x;

                );
                s.push(p[M - 1].v);
              }
              return s;
            },
          };
        },
        2: (t, e, r) => {
          "use strict";
          var s = r(458),
            i = r(191),
            n = s.eudist,
            o = (s.mandist, s.dist, i.kmrand),
            a = i.kmpp;
          function h(t, e, r) {
            r = r || [];
            for (var s = 0; s < t; s++) r[s] = e;
            return r;
          }
          t.exports = function (t, e, r, s) {
            var i = [],
              u = [],
              l = [],
              c = [],
              p = !1,
              d = s || 1e4,
              f = t.length,
              g = t[0].length,
              m = g > 0,
              _ = [];
            if (r) i = "kmrand" == r ? o(t, e) : "kmpp" == r ? a(t, e) : r;
            else
              for (var v = {}; i.length < e; ) {
                var y = Math.floor(Math.random() * f);
                v[y] || ((v[y] = !0), i.push(t[y]));
              }
            do {
              h(e, 0, _);
              for (var x = 0; x < f; x++) {
                for (var M = 1 / 0, k = 0, w = 0; w < e; w++)
                  (c = m ? n(t[x], i[w]) : Math.abs(t[x] - i[w])) <= M &&
                    ((M = c), (k = w));
                (l[x] = k), _[k]++;
              }
              for (var b = [], C = ((u = []), 0); C < e; C++)
                (b[C] = m ? h(g, 0, b[C]) : 0), (u[C] = i[C]);
              if (m) {
                for (var P = 0; P < e; P++) i[P] = [];
                for (var E = 0; E < f; E++)
                  for (var L = b[l[E]], O = t[E], S = 0; S < g; S++)
                    L[S] += O[S];
                p = !0;
                for (var A = 0; A < e; A++) {
                  for (
                    var z = i[A], Z = b[A], I = u[A], j = _[A], T = 0;
                    T < g;
                    T++
                  )
                    z[T] = Z[T] / j || 0;
                  if (p)
                    for (var q = 0; q < g; q++)
                      if (I[q] != z[q]) {
                        p = !1;
                        break;
                      }
                }
              } else {
                for (var D = 0; D < f; D++) b[l[D]] += t[D];
                for (var N = 0; N < e; N++) i[N] = b[N] / _[N] || 0;
                p = !0;
                for (var Q = 0; Q < e; Q++)
                  if (u[Q] != i[Q]) {
                    p = !1;
                    break;
                  }
              }
              p = p || --d <= 0;
            } while (!p);
            return { it: 1e4 - d, k: e, idxs: l, centroids: i };
          };
        },
      },
      e = {};
    function r(s) {
      var i = e[s];
      if (void 0 !== i) return i.exports;
      var n = (e[s] = { exports: {} });
      return t[s](n, n.exports, r), n.exports;
    }
    (r.n = (t) => {
      var e = t && t.__esModule ? () => t.default : () => t;
      return r.d(e, { a: e }), e;
    }),
      (r.d = (t, e) => {
        for (var s in e)
          r.o(e, s) &&
            !r.o(t, s) &&
            Object.defineProperty(t, s, { enumerable: !0, get: e[s] });
      }),
      (r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
      (r.r = (t) => {
        "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(t, "__esModule", { value: !0 });
      });
    var s = {};
    (() => {
      "use strict";
      function t(r, s, i, n, o, a) {
        if (o - n <= i) return;
        const h = (n + o) >> 1;
        e(r, s, h, n, o, a % 2),
          t(r, s, i, n, h - 1, a + 1),
          t(r, s, i, h + 1, o, a + 1);
      }
      function e(t, r, s, n, o, a) {
        for (; o > n; ) {
          if (o - n > 600) {
            const i = o - n + 1,
              h = s - n + 1,
              u = Math.log(i),
              l = 0.5 * Math.exp((2 * u) / 3),
              c =
                0.5 *
                Math.sqrt((u * l * (i - l)) / i) *
                (h - i / 2 < 0 ? -1 : 1);
            e(
              t,
              r,
              s,
              Math.max(n, Math.floor(s - (h * l) / i + c)),
              Math.min(o, Math.floor(s + ((i - h) * l) / i + c)),
              a
            );
          }
          const h = r[2 * s + a];
          let u = n,
            l = o;
          for (i(t, r, n, s), r[2 * o + a] > h && i(t, r, n, o); u < l; ) {
            for (i(t, r, u, l), u++, l--; r[2 * u + a] < h; ) u++;
            for (; r[2 * l + a] > h; ) l--;
          }
          r[2 * n + a] === h ? i(t, r, n, l) : (l++, i(t, r, l, o)),
            l <= s && (n = l + 1),
            s <= l && (o = l - 1);
        }
      }
      function i(t, e, r, s) {
        n(t, r, s), n(e, 2 * r, 2 * s), n(e, 2 * r + 1, 2 * s + 1);
      }
      function n(t, e, r) {
        const s = t[e];
        (t[e] = t[r]), (t[r] = s);
      }
      function o(t, e, r, s) {
        const i = t - r,
          n = e - s;
        return i * i + n * n;
      }
      r.r(s), r.d(s, { initMap: () => j }), r(2), r(194);
      const a = (t) => t[0],
        h = (t) => t[1];
      class u {
        constructor(e, r = a, s = h, i = 64, n = Float64Array) {
          (this.nodeSize = i), (this.points = e);
          const o = e.length < 65536 ? Uint16Array : Uint32Array,
            u = (this.ids = new o(e.length)),
            l = (this.coords = new n(2 * e.length));
          for (let t = 0; t < e.length; t++)
            (u[t] = t), (l[2 * t] = r(e[t])), (l[2 * t + 1] = s(e[t]));
          t(u, l, i, 0, u.length - 1, 0);
        }
        range(t, e, r, s) {
          return (function (t, e, r, s, i, n, o) {
            const a = [0, t.length - 1, 0],
              h = [];
            let u, l;
            for (; a.length; ) {
              const c = a.pop(),
                p = a.pop(),
                d = a.pop();
              if (p - d <= o) {
                for (let o = d; o <= p; o++)
                  (u = e[2 * o]),
                    (l = e[2 * o + 1]),
                    u >= r && u <= i && l >= s && l <= n && h.push(t[o]);
                continue;
              }
              const f = Math.floor((d + p) / 2);
              (u = e[2 * f]),
                (l = e[2 * f + 1]),
                u >= r && u <= i && l >= s && l <= n && h.push(t[f]);
              const g = (c + 1) % 2;
              (0 === c ? r <= u : s <= l) &&
                (a.push(d), a.push(f - 1), a.push(g)),
                (0 === c ? i >= u : n >= l) &&
                  (a.push(f + 1), a.push(p), a.push(g));
            }
            return h;
          })(this.ids, this.coords, t, e, r, s, this.nodeSize);
        }
        within(t, e, r) {
          return (function (t, e, r, s, i, n) {
            const a = [0, t.length - 1, 0],
              h = [],
              u = i * i;
            for (; a.length; ) {
              const l = a.pop(),
                c = a.pop(),
                p = a.pop();
              if (c - p <= n) {
                for (let i = p; i <= c; i++)
                  o(e[2 * i], e[2 * i + 1], r, s) <= u && h.push(t[i]);
                continue;
              }
              const d = Math.floor((p + c) / 2),
                f = e[2 * d],
                g = e[2 * d + 1];
              o(f, g, r, s) <= u && h.push(t[d]);
              const m = (l + 1) % 2;
              (0 === l ? r - i <= f : s - i <= g) &&
                (a.push(p), a.push(d - 1), a.push(m)),
                (0 === l ? r + i >= f : s + i >= g) &&
                  (a.push(d + 1), a.push(c), a.push(m));
            }
            return h;
          })(this.ids, this.coords, t, e, r, this.nodeSize);
        }
      }
      const l = {
          minZoom: 0,
          maxZoom: 16,
          minPoints: 2,
          radius: 40,
          extent: 512,
          nodeSize: 64,
          log: !1,
          generateId: !1,
          reduce: null,
          map: (t) => t,
        },
        c =
          Math.fround ||
          ((p = new Float32Array(1)), (t) => ((p[0] = +t), p[0]));
      var p;
      class d {
        constructor(t) {
          (this.options = M(Object.create(l), t)),
            (this.trees = new Array(this.options.maxZoom + 1));
        }
        load(t) {
          const { log: e, minZoom: r, maxZoom: s, nodeSize: i } = this.options;
          e && console.time("total time");
          const n = `prepare ${t.length} points`;
          e && console.time(n), (this.points = t);
          let o = [];
          for (let e = 0; e < t.length; e++)
            t[e].geometry && o.push(g(t[e], e));
          (this.trees[s + 1] = new u(o, k, w, i, Float32Array)),
            e && console.timeEnd(n);
          for (let t = s; t >= r; t--) {
            const r = +Date.now();
            (o = this._cluster(o, t)),
              (this.trees[t] = new u(o, k, w, i, Float32Array)),
              e &&
                console.log(
                  "z%d: %d clusters in %dms",
                  t,
                  o.length,
                  +Date.now() - r
                );
          }
          return e && console.timeEnd("total time"), this;
        }
        getClusters(t, e) {
          let r = ((((t[0] + 180) % 360) + 360) % 360) - 180;
          const s = Math.max(-90, Math.min(90, t[1]));
          let i =
            180 === t[2] ? 180 : ((((t[2] + 180) % 360) + 360) % 360) - 180;
          const n = Math.max(-90, Math.min(90, t[3]));
          if (t[2] - t[0] >= 360) (r = -180), (i = 180);
          else if (r > i) {
            const t = this.getClusters([r, s, 180, n], e),
              o = this.getClusters([-180, s, i, n], e);
            return t.concat(o);
          }
          const o = this.trees[this._limitZoom(e)],
            a = o.range(v(r), y(n), v(i), y(s)),
            h = [];
          for (const t of a) {
            const e = o.points[t];
            h.push(e.numPoints ? m(e) : this.points[e.index]);
          }
          return h;
        }
        getChildren(t) {
          const e = this._getOriginId(t),
            r = this._getOriginZoom(t),
            s = "No cluster with the specified id.",
            i = this.trees[r];
          if (!i) throw new Error(s);
          const n = i.points[e];
          if (!n) throw new Error(s);
          const o =
              this.options.radius / (this.options.extent * Math.pow(2, r - 1)),
            a = i.within(n.x, n.y, o),
            h = [];
          for (const e of a) {
            const r = i.points[e];
            r.parentId === t &&
              h.push(r.numPoints ? m(r) : this.points[r.index]);
          }
          if (0 === h.length) throw new Error(s);
          return h;
        }
        getLeaves(t, e, r) {
          (e = e || 10), (r = r || 0);
          const s = [];
          return this._appendLeaves(s, t, e, r, 0), s;
        }
        getTile(t, e, r) {
          const s = this.trees[this._limitZoom(t)],
            i = Math.pow(2, t),
            { extent: n, radius: o } = this.options,
            a = o / n,
            h = (r - a) / i,
            u = (r + 1 + a) / i,
            l = { features: [] };
          return (
            this._addTileFeatures(
              s.range((e - a) / i, h, (e + 1 + a) / i, u),
              s.points,
              e,
              r,
              i,
              l
            ),
            0 === e &&
              this._addTileFeatures(
                s.range(1 - a / i, h, 1, u),
                s.points,
                i,
                r,
                i,
                l
              ),
            e === i - 1 &&
              this._addTileFeatures(
                s.range(0, h, a / i, u),
                s.points,
                -1,
                r,
                i,
                l
              ),
            l.features.length ? l : null
          );
        }
        getClusterExpansionZoom(t) {
          let e = this._getOriginZoom(t) - 1;
          for (; e <= this.options.maxZoom; ) {
            const r = this.getChildren(t);
            if ((e++, 1 !== r.length)) break;
            t = r[0].properties.cluster_id;
          }
          return e;
        }
        _appendLeaves(t, e, r, s, i) {
          const n = this.getChildren(e);
          for (const e of n) {
            const n = e.properties;
            if (
              (n && n.cluster
                ? i + n.point_count <= s
                  ? (i += n.point_count)
                  : (i = this._appendLeaves(t, n.cluster_id, r, s, i))
                : i < s
                ? i++
                : t.push(e),
              t.length === r)
            )
              break;
          }
          return i;
        }
        _addTileFeatures(t, e, r, s, i, n) {
          for (const o of t) {
            const t = e[o],
              a = t.numPoints;
            let h, u, l;
            if (a) (h = _(t)), (u = t.x), (l = t.y);
            else {
              const e = this.points[t.index];
              (h = e.properties),
                (u = v(e.geometry.coordinates[0])),
                (l = y(e.geometry.coordinates[1]));
            }
            const c = {
              type: 1,
              geometry: [
                [
                  Math.round(this.options.extent * (u * i - r)),
                  Math.round(this.options.extent * (l * i - s)),
                ],
              ],
              tags: h,
            };
            let p;
            a
              ? (p = t.id)
              : this.options.generateId
              ? (p = t.index)
              : this.points[t.index].id && (p = this.points[t.index].id),
              void 0 !== p && (c.id = p),
              n.features.push(c);
          }
        }
        _limitZoom(t) {
          return Math.max(
            this.options.minZoom,
            Math.min(+t, this.options.maxZoom + 1)
          );
        }
        _cluster(t, e) {
          const r = [],
            { radius: s, extent: i, reduce: n, minPoints: o } = this.options,
            a = s / (i * Math.pow(2, e));
          for (let s = 0; s < t.length; s++) {
            const i = t[s];
            if (i.zoom <= e) continue;
            i.zoom = e;
            const h = this.trees[e + 1],
              u = h.within(i.x, i.y, a),
              l = i.numPoints || 1;
            let c = l;
            for (const t of u) {
              const r = h.points[t];
              r.zoom > e && (c += r.numPoints || 1);
            }
            if (c > l && c >= o) {
              let t = i.x * l,
                o = i.y * l,
                a = n && l > 1 ? this._map(i, !0) : null;
              const p = (s << 5) + (e + 1) + this.points.length;
              for (const r of u) {
                const s = h.points[r];
                if (s.zoom <= e) continue;
                s.zoom = e;
                const u = s.numPoints || 1;
                (t += s.x * u),
                  (o += s.y * u),
                  (s.parentId = p),
                  n && (a || (a = this._map(i, !0)), n(a, this._map(s)));
              }
              (i.parentId = p), r.push(f(t / c, o / c, p, c, a));
            } else if ((r.push(i), c > 1))
              for (const t of u) {
                const s = h.points[t];
                s.zoom <= e || ((s.zoom = e), r.push(s));
              }
          }
          return r;
        }
        _getOriginId(t) {
          return (t - this.points.length) >> 5;
        }
        _getOriginZoom(t) {
          return (t - this.points.length) % 32;
        }
        _map(t, e) {
          if (t.numPoints) return e ? M({}, t.properties) : t.properties;
          const r = this.points[t.index].properties,
            s = this.options.map(r);
          return e && s === r ? M({}, s) : s;
        }
      }
      function f(t, e, r, s, i) {
        return {
          x: c(t),
          y: c(e),
          zoom: 1 / 0,
          id: r,
          parentId: -1,
          numPoints: s,
          properties: i,
        };
      }
      function g(t, e) {
        const [r, s] = t.geometry.coordinates;
        return { x: c(v(r)), y: c(y(s)), zoom: 1 / 0, index: e, parentId: -1 };
      }
      function m(t) {
        return {
          type: "Feature",
          id: t.id,
          properties: _(t),
          geometry: {
            type: "Point",
            coordinates: [((e = t.x), 360 * (e - 0.5)), x(t.y)],
          },
        };
        var e;
      }
      function _(t) {
        const e = t.numPoints,
          r =
            e >= 1e4
              ? `${Math.round(e / 1e3)}k`
              : e >= 1e3
              ? Math.round(e / 100) / 10 + "k"
              : e;
        return M(M({}, t.properties), {
          cluster: !0,
          cluster_id: t.id,
          point_count: e,
          point_count_abbreviated: r,
        });
      }
      function v(t) {
        return t / 360 + 0.5;
      }
      function y(t) {
        const e = Math.sin((t * Math.PI) / 180),
          r = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
        return r < 0 ? 0 : r > 1 ? 1 : r;
      }
      function x(t) {
        const e = ((180 - 360 * t) * Math.PI) / 180;
        return (360 * Math.atan(Math.exp(e))) / Math.PI - 90;
      }
      function M(t, e) {
        for (const r in e) t[r] = e[r];
        return t;
      }
      function k(t) {
        return t.x;
      }
      function w(t) {
        return t.y;
      }
      var b = r(617),
        C = r.n(b);
      class P {
        constructor({ markers: t, position: e }) {
          (this.markers = t),
            e &&
              (e instanceof google.maps.LatLng
                ? (this._position = e)
                : (this._position = new google.maps.LatLng(e)));
        }
        get bounds() {
          if (0 !== this.markers.length || this._position)
            return this.markers.reduce(
              (t, e) => t.extend(e.getPosition()),
              new google.maps.LatLngBounds(this._position, this._position)
            );
        }
        get position() {
          return this._position || this.bounds.getCenter();
        }
        get count() {
          return this.markers.filter((t) => t.getVisible()).length;
        }
        push(t) {
          this.markers.push(t);
        }
        delete() {
          this.marker && (this.marker.setMap(null), delete this.marker),
            (this.markers.length = 0);
        }
      }
      const E = (t) =>
        t.map((t) => new P({ position: t.getPosition(), markers: [t] }));
      class L extends class {
        constructor({ maxZoom: t = 16 }) {
          this.maxZoom = t;
        }
        noop({ markers: t }) {
          return E(t);
        }
      } {
        constructor(t) {
          var { maxZoom: e, radius: r = 60 } = t,
            s = (function (t, e) {
              var r = {};
              for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) &&
                  e.indexOf(s) < 0 &&
                  (r[s] = t[s]);
              if (
                null != t &&
                "function" == typeof Object.getOwnPropertySymbols
              ) {
                var i = 0;
                for (s = Object.getOwnPropertySymbols(t); i < s.length; i++)
                  e.indexOf(s[i]) < 0 &&
                    Object.prototype.propertyIsEnumerable.call(t, s[i]) &&
                    (r[s[i]] = t[s[i]]);
              }
              return r;
            })(t, ["maxZoom", "radius"]);
          super({ maxZoom: e }),
            (this.superCluster = new d(
              Object.assign({ maxZoom: this.maxZoom, radius: r }, s)
            )),
            (this.state = { zoom: null });
        }
        calculate(t) {
          let e = !1;
          if (!C()(t.markers, this.markers)) {
            (e = !0), (this.markers = [...t.markers]);
            const r = this.markers.map((t) => ({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [t.getPosition().lng(), t.getPosition().lat()],
              },
              properties: { marker: t },
            }));
            this.superCluster.load(r);
          }
          const r = { zoom: t.map.getZoom() };
          return (
            e ||
              (this.state.zoom > this.maxZoom && r.zoom > this.maxZoom) ||
              (e = e || !C()(this.state, r)),
            (this.state = r),
            e && (this.clusters = this.cluster(t)),
            { clusters: this.clusters, changed: e }
          );
        }
        cluster({ map: t }) {
          return this.superCluster
            .getClusters([-180, -90, 180, 90], t.getZoom())
            .map(this.transformCluster.bind(this));
        }
        transformCluster({
          geometry: {
            coordinates: [t, e],
          },
          properties: r,
        }) {
          if (r.cluster)
            return new P({
              markers: this.superCluster
                .getLeaves(r.cluster_id, 1 / 0)
                .map((t) => t.properties.marker),
              position: new google.maps.LatLng({ lat: e, lng: t }),
            });
          {
            const t = r.marker;
            return new P({ markers: [t], position: t.getPosition() });
          }
        }
      }
      class O {
        constructor(t, e) {
          this.markers = { sum: t.length };
          const r = e.map((t) => t.count),
            s = r.reduce((t, e) => t + e, 0);
          this.clusters = {
            count: e.length,
            markers: {
              mean: s / e.length,
              sum: s,
              min: Math.min(...r),
              max: Math.max(...r),
            },
          };
        }
      }
      class S {
        render({ count: t, position: e }, r) {
          const s =
              t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff",
            i = window.btoa(
              `\n  <svg fill="${s}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">\n    <circle cx="120" cy="120" opacity=".6" r="70" />\n    <circle cx="120" cy="120" opacity=".3" r="90" />\n    <circle cx="120" cy="120" opacity=".2" r="110" />\n  </svg>`
            );
          return new google.maps.Marker({
            position: e,
            icon: {
              url: `data:image/svg+xml;base64,${i}`,
              scaledSize: new google.maps.Size(45, 45),
            },
            label: {
              text: String(t),
              color: "rgba(255,255,255,0.9)",
              fontSize: "12px",
            },
            zIndex: Number(google.maps.Marker.MAX_ZINDEX) + t,
          });
        }
      }
      class A {
        constructor() {
          !(function (t, e) {
            for (let r in e.prototype) t.prototype[r] = e.prototype[r];
          })(A, google.maps.OverlayView);
        }
      }
      var z;
      !(function (t) {
        (t.CLUSTERING_BEGIN = "clusteringbegin"),
          (t.CLUSTERING_END = "clusteringend"),
          (t.CLUSTER_CLICK = "click");
      })(z || (z = {}));
      const Z = (t, e, r) => {
        r.fitBounds(e.bounds);
      };
      class I extends A {
        constructor({
          map: t,
          markers: e = [],
          algorithm: r = new L({}),
          renderer: s = new S(),
          onClusterClick: i = Z,
        }) {
          super(),
            (this.markers = [...e]),
            (this.clusters = []),
            (this.algorithm = r),
            (this.renderer = s),
            (this.onClusterClick = i),
            t && this.setMap(t);
        }
        addMarker(t, e) {
          this.markers.includes(t) ||
            (this.markers.push(t), e || this.render());
        }
        addMarkers(t, e) {
          t.forEach((t) => {
            this.addMarker(t, !0);
          }),
            e || this.render();
        }
        removeMarker(t, e) {
          const r = this.markers.indexOf(t);
          return (
            -1 !== r &&
            (t.setMap(null), this.markers.splice(r, 1), e || this.render(), !0)
          );
        }
        removeMarkers(t, e) {
          let r = !1;
          return (
            t.forEach((t) => {
              r = this.removeMarker(t, !0) || r;
            }),
            r && !e && this.render(),
            r
          );
        }
        clearMarkers(t) {
          (this.markers.length = 0), t || this.render();
        }
        render() {
          const t = this.getMap();
          if (t instanceof google.maps.Map && this.getProjection()) {
            google.maps.event.trigger(this, z.CLUSTERING_BEGIN, this);
            const { clusters: e, changed: r } = this.algorithm.calculate({
              markers: this.markers,
              map: t,
              mapCanvasProjection: this.getProjection(),
            });
            (r || null == r) &&
              (this.reset(), (this.clusters = e), this.renderClusters()),
              google.maps.event.trigger(this, z.CLUSTERING_END, this);
          }
        }
        onAdd() {
          (this.idleListener = this.getMap().addListener(
            "idle",
            this.render.bind(this)
          )),
            this.render();
        }
        onRemove() {
          google.maps.event.removeListener(this.idleListener), this.reset();
        }
        reset() {
          this.markers.forEach((t) => t.setMap(null)),
            this.clusters.forEach((t) => t.delete()),
            (this.clusters = []);
        }
        renderClusters() {
          const t = new O(this.markers, this.clusters),
            e = this.getMap();
          this.clusters.forEach((r) => {
            1 === r.markers.length
              ? (r.marker = r.markers[0])
              : ((r.marker = this.renderer.render(r, t)),
                this.onClusterClick &&
                  r.marker.addListener("click", (t) => {
                    google.maps.event.trigger(this, z.CLUSTER_CLICK, r),
                      this.onClusterClick(t, r, e);
                  })),
              r.marker.setMap(e);
          });
        }
      }
      function j() {
        const t = new google.maps.Map(document.getElementById("map"), {
            zoom: 3,
            center: { lat: -28.024, lng: 140.887 },
          }),
          e = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          r = T.map(
            (t, r) =>
              new google.maps.Marker({ position: t, label: e[r % e.length] })
          );
        new I({ markers: r, map: t });
      }
      const T = [
        { lat: -31.56391, lng: 147.154312 },
        { lat: -33.718234, lng: 150.363181 },
        { lat: -33.727111, lng: 150.371124 },
        { lat: -33.848588, lng: 151.209834 },
        { lat: -33.851702, lng: 151.216968 },
        { lat: -34.671264, lng: 150.863657 },
        { lat: -35.304724, lng: 148.662905 },
        { lat: -36.817685, lng: 175.699196 },
        { lat: -36.828611, lng: 175.790222 },
        { lat: -37.75, lng: 145.116667 },
        { lat: -37.759859, lng: 145.128708 },
        { lat: -37.765015, lng: 145.133858 },
        { lat: -37.770104, lng: 145.143299 },
        { lat: -37.7737, lng: 145.145187 },
        { lat: -37.774785, lng: 145.137978 },
        { lat: -37.819616, lng: 144.968119 },
        { lat: -38.330766, lng: 144.695692 },
        { lat: -39.927193, lng: 175.053218 },
        { lat: -41.330162, lng: 174.865694 },
        { lat: -42.734358, lng: 147.439506 },
        { lat: -42.734358, lng: 147.501315 },
        { lat: -42.735258, lng: 147.438 },
        { lat: -43.999792, lng: 170.463352 },
      ];
    })();
    var i = window;
    for (var n in s) i[n] = s[n];
    s.__esModule && Object.defineProperty(i, "__esModule", { value: !0 });
  })();
</script>

<div id="iframe-contents">
  <div id="map"></div>

  <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=weekly&channel=1"
    async
  ></script>
</div>
