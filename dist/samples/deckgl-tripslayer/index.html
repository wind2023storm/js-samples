<!DOCTYPE html>
<html>
  <head>
    <title>deck.gl Trips Layer</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <style type="text/css">
      :root {
        --mdc-theme-primary: #1a73e8;
        --mdc-theme-secondary: #rgb(225, 245, 254);
        --mdc-theme-on-primary: #fff;
        --mdc-theme-on-secondary: rgb(1, 87, 155);
      }

      .mdc-text-field--focused:not(.mdc-text-field--disabled)
        .mdc-floating-label {
        color: var(--mdc-theme-primary);
      }

      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }

      /* Optional: Makes the sample page fill the window. */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
    </style>
    <script>
      /*! For license information please see iframe.js.LICENSE.txt */
      (() => {
        var t = {
            422: (t) => {
              (t.exports = function (t) {
                return t && t.__esModule ? t : { default: t };
              }),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0);
            },
            17: (t) => {
              function e(n) {
                return (
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? ((t.exports = e =
                        function (t) {
                          return typeof t;
                        }),
                      (t.exports.default = t.exports),
                      (t.exports.__esModule = !0))
                    : ((t.exports = e =
                        function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        }),
                      (t.exports.default = t.exports),
                      (t.exports.__esModule = !0)),
                  e(n)
                );
              }
              (t.exports = e),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0);
            },
            377: (t, e, n) => {
              var i;
              !(function (r, s, o, a) {
                "use strict";
                var c,
                  h = ["", "webkit", "Moz", "MS", "ms", "o"],
                  l = s.createElement("div"),
                  u = Math.round,
                  d = Math.abs,
                  f = Date.now;
                function p(t, e, n) {
                  return setTimeout(w(t, n), e);
                }
                function g(t, e, n) {
                  return !!Array.isArray(t) && (m(t, n[e], n), !0);
                }
                function m(t, e, n) {
                  var i;
                  if (t)
                    if (t.forEach) t.forEach(e, n);
                    else if (t.length !== a)
                      for (i = 0; i < t.length; ) e.call(n, t[i], i, t), i++;
                    else
                      for (i in t) t.hasOwnProperty(i) && e.call(n, t[i], i, t);
                }
                function b(t, e, n) {
                  var i = "DEPRECATED METHOD: " + e + "\n" + n + " AT \n";
                  return function () {
                    var e = new Error("get-stack-trace"),
                      n =
                        e && e.stack
                          ? e.stack
                              .replace(/^[^\(]+?[\n$]/gm, "")
                              .replace(/^\s+at\s+/gm, "")
                              .replace(
                                /^Object.<anonymous>\s*\(/gm,
                                "{anonymous}()@"
                              )
                          : "Unknown Stack Trace",
                      s = r.console && (r.console.warn || r.console.log);
                    return (
                      s && s.call(r.console, i, n), t.apply(this, arguments)
                    );
                  };
                }
                c =
                  "function" != typeof Object.assign
                    ? function (t) {
                        if (t === a || null === t)
                          throw new TypeError(
                            "Cannot convert undefined or null to object"
                          );
                        for (
                          var e = Object(t), n = 1;
                          n < arguments.length;
                          n++
                        ) {
                          var i = arguments[n];
                          if (i !== a && null !== i)
                            for (var r in i)
                              i.hasOwnProperty(r) && (e[r] = i[r]);
                        }
                        return e;
                      }
                    : Object.assign;
                var _ = b(
                    function (t, e, n) {
                      for (var i = Object.keys(e), r = 0; r < i.length; )
                        (!n || (n && t[i[r]] === a)) && (t[i[r]] = e[i[r]]),
                          r++;
                      return t;
                    },
                    "extend",
                    "Use `assign`."
                  ),
                  y = b(
                    function (t, e) {
                      return _(t, e, !0);
                    },
                    "merge",
                    "Use `assign`."
                  );
                function v(t, e, n) {
                  var i,
                    r = e.prototype;
                  ((i = t.prototype = Object.create(r)).constructor = t),
                    (i._super = r),
                    n && c(i, n);
                }
                function w(t, e) {
                  return function () {
                    return t.apply(e, arguments);
                  };
                }
                function x(t, e) {
                  return "function" == typeof t
                    ? t.apply((e && e[0]) || a, e)
                    : t;
                }
                function E(t, e) {
                  return t === a ? e : t;
                }
                function P(t, e, n) {
                  m(M(e), function (e) {
                    t.addEventListener(e, n, !1);
                  });
                }
                function T(t, e, n) {
                  m(M(e), function (e) {
                    t.removeEventListener(e, n, !1);
                  });
                }
                function A(t, e) {
                  for (; t; ) {
                    if (t == e) return !0;
                    t = t.parentNode;
                  }
                  return !1;
                }
                function S(t, e) {
                  return t.indexOf(e) > -1;
                }
                function M(t) {
                  return t.trim().split(/\s+/g);
                }
                function C(t, e, n) {
                  if (t.indexOf && !n) return t.indexOf(e);
                  for (var i = 0; i < t.length; ) {
                    if ((n && t[i][n] == e) || (!n && t[i] === e)) return i;
                    i++;
                  }
                  return -1;
                }
                function O(t) {
                  return Array.prototype.slice.call(t, 0);
                }
                function L(t, e, n) {
                  for (var i = [], r = [], s = 0; s < t.length; ) {
                    var o = e ? t[s][e] : t[s];
                    C(r, o) < 0 && i.push(t[s]), (r[s] = o), s++;
                  }
                  return (
                    n &&
                      (i = e
                        ? i.sort(function (t, n) {
                            return t[e] > n[e];
                          })
                        : i.sort()),
                    i
                  );
                }
                function I(t, e) {
                  for (
                    var n, i, r = e[0].toUpperCase() + e.slice(1), s = 0;
                    s < h.length;

                  ) {
                    if ((i = (n = h[s]) ? n + r : e) in t) return i;
                    s++;
                  }
                  return a;
                }
                var R = 1;
                function k(t) {
                  var e = t.ownerDocument || t;
                  return e.defaultView || e.parentWindow || r;
                }
                var j = "ontouchstart" in r,
                  F = I(r, "PointerEvent") !== a,
                  B =
                    j &&
                    /mobile|tablet|ip(ad|hone|od)|android/i.test(
                      navigator.userAgent
                    ),
                  D = "touch",
                  N = "mouse",
                  z = ["x", "y"],
                  V = ["clientX", "clientY"];
                function U(t, e) {
                  var n = this;
                  (this.manager = t),
                    (this.callback = e),
                    (this.element = t.element),
                    (this.target = t.options.inputTarget),
                    (this.domHandler = function (e) {
                      x(t.options.enable, [t]) && n.handler(e);
                    }),
                    this.init();
                }
                function G(t, e, n) {
                  var i = n.pointers.length,
                    r = n.changedPointers.length,
                    s = 1 & e && i - r == 0,
                    o = 12 & e && i - r == 0;
                  (n.isFirst = !!s),
                    (n.isFinal = !!o),
                    s && (t.session = {}),
                    (n.eventType = e),
                    (function (t, e) {
                      var n = t.session,
                        i = e.pointers,
                        r = i.length;
                      n.firstInput || (n.firstInput = $(e)),
                        r > 1 && !n.firstMultiple
                          ? (n.firstMultiple = $(e))
                          : 1 === r && (n.firstMultiple = !1);
                      var s = n.firstInput,
                        o = n.firstMultiple,
                        c = o ? o.center : s.center,
                        h = (e.center = W(i));
                      (e.timeStamp = f()),
                        (e.deltaTime = e.timeStamp - s.timeStamp),
                        (e.angle = Y(c, h)),
                        (e.distance = q(c, h)),
                        (function (t, e) {
                          var n = e.center,
                            i = t.offsetDelta || {},
                            r = t.prevDelta || {},
                            s = t.prevInput || {};
                          (1 !== e.eventType && 4 !== s.eventType) ||
                            ((r = t.prevDelta =
                              { x: s.deltaX || 0, y: s.deltaY || 0 }),
                            (i = t.offsetDelta = { x: n.x, y: n.y })),
                            (e.deltaX = r.x + (n.x - i.x)),
                            (e.deltaY = r.y + (n.y - i.y));
                        })(n, e),
                        (e.offsetDirection = X(e.deltaX, e.deltaY));
                      var l,
                        u,
                        p = H(e.deltaTime, e.deltaX, e.deltaY);
                      (e.overallVelocityX = p.x),
                        (e.overallVelocityY = p.y),
                        (e.overallVelocity = d(p.x) > d(p.y) ? p.x : p.y),
                        (e.scale = o
                          ? ((l = o.pointers),
                            q((u = i)[0], u[1], V) / q(l[0], l[1], V))
                          : 1),
                        (e.rotation = o
                          ? (function (t, e) {
                              return Y(e[1], e[0], V) + Y(t[1], t[0], V);
                            })(o.pointers, i)
                          : 0),
                        (e.maxPointers = n.prevInput
                          ? e.pointers.length > n.prevInput.maxPointers
                            ? e.pointers.length
                            : n.prevInput.maxPointers
                          : e.pointers.length),
                        (function (t, e) {
                          var n,
                            i,
                            r,
                            s,
                            o = t.lastInterval || e,
                            c = e.timeStamp - o.timeStamp;
                          if (
                            8 != e.eventType &&
                            (c > 25 || o.velocity === a)
                          ) {
                            var h = e.deltaX - o.deltaX,
                              l = e.deltaY - o.deltaY,
                              u = H(c, h, l);
                            (i = u.x),
                              (r = u.y),
                              (n = d(u.x) > d(u.y) ? u.x : u.y),
                              (s = X(h, l)),
                              (t.lastInterval = e);
                          } else
                            (n = o.velocity),
                              (i = o.velocityX),
                              (r = o.velocityY),
                              (s = o.direction);
                          (e.velocity = n),
                            (e.velocityX = i),
                            (e.velocityY = r),
                            (e.direction = s);
                        })(n, e);
                      var g = t.element;
                      A(e.srcEvent.target, g) && (g = e.srcEvent.target),
                        (e.target = g);
                    })(t, n),
                    t.emit("hammer.input", n),
                    t.recognize(n),
                    (t.session.prevInput = n);
                }
                function $(t) {
                  for (var e = [], n = 0; n < t.pointers.length; )
                    (e[n] = {
                      clientX: u(t.pointers[n].clientX),
                      clientY: u(t.pointers[n].clientY),
                    }),
                      n++;
                  return {
                    timeStamp: f(),
                    pointers: e,
                    center: W(e),
                    deltaX: t.deltaX,
                    deltaY: t.deltaY,
                  };
                }
                function W(t) {
                  var e = t.length;
                  if (1 === e)
                    return { x: u(t[0].clientX), y: u(t[0].clientY) };
                  for (var n = 0, i = 0, r = 0; r < e; )
                    (n += t[r].clientX), (i += t[r].clientY), r++;
                  return { x: u(n / e), y: u(i / e) };
                }
                function H(t, e, n) {
                  return { x: e / t || 0, y: n / t || 0 };
                }
                function X(t, e) {
                  return t === e
                    ? 1
                    : d(t) >= d(e)
                    ? t < 0
                      ? 2
                      : 4
                    : e < 0
                    ? 8
                    : 16;
                }
                function q(t, e, n) {
                  n || (n = z);
                  var i = e[n[0]] - t[n[0]],
                    r = e[n[1]] - t[n[1]];
                  return Math.sqrt(i * i + r * r);
                }
                function Y(t, e, n) {
                  n || (n = z);
                  var i = e[n[0]] - t[n[0]],
                    r = e[n[1]] - t[n[1]];
                  return (180 * Math.atan2(r, i)) / Math.PI;
                }
                U.prototype = {
                  handler: function () {},
                  init: function () {
                    this.evEl && P(this.element, this.evEl, this.domHandler),
                      this.evTarget &&
                        P(this.target, this.evTarget, this.domHandler),
                      this.evWin &&
                        P(k(this.element), this.evWin, this.domHandler);
                  },
                  destroy: function () {
                    this.evEl && T(this.element, this.evEl, this.domHandler),
                      this.evTarget &&
                        T(this.target, this.evTarget, this.domHandler),
                      this.evWin &&
                        T(k(this.element), this.evWin, this.domHandler);
                  },
                };
                var Z = { mousedown: 1, mousemove: 2, mouseup: 4 },
                  K = "mousedown",
                  Q = "mousemove mouseup";
                function J() {
                  (this.evEl = K),
                    (this.evWin = Q),
                    (this.pressed = !1),
                    U.apply(this, arguments);
                }
                v(J, U, {
                  handler: function (t) {
                    var e = Z[t.type];
                    1 & e && 0 === t.button && (this.pressed = !0),
                      2 & e && 1 !== t.which && (e = 4),
                      this.pressed &&
                        (4 & e && (this.pressed = !1),
                        this.callback(this.manager, e, {
                          pointers: [t],
                          changedPointers: [t],
                          pointerType: N,
                          srcEvent: t,
                        }));
                  },
                });
                var tt = {
                    pointerdown: 1,
                    pointermove: 2,
                    pointerup: 4,
                    pointercancel: 8,
                    pointerout: 8,
                  },
                  et = { 2: D, 3: "pen", 4: N, 5: "kinect" },
                  nt = "pointerdown",
                  it = "pointermove pointerup pointercancel";
                function rt() {
                  (this.evEl = nt),
                    (this.evWin = it),
                    U.apply(this, arguments),
                    (this.store = this.manager.session.pointerEvents = []);
                }
                r.MSPointerEvent &&
                  !r.PointerEvent &&
                  ((nt = "MSPointerDown"),
                  (it = "MSPointerMove MSPointerUp MSPointerCancel")),
                  v(rt, U, {
                    handler: function (t) {
                      var e = this.store,
                        n = !1,
                        i = t.type.toLowerCase().replace("ms", ""),
                        r = tt[i],
                        s = et[t.pointerType] || t.pointerType,
                        o = s == D,
                        a = C(e, t.pointerId, "pointerId");
                      1 & r && (0 === t.button || o)
                        ? a < 0 && (e.push(t), (a = e.length - 1))
                        : 12 & r && (n = !0),
                        a < 0 ||
                          ((e[a] = t),
                          this.callback(this.manager, r, {
                            pointers: e,
                            changedPointers: [t],
                            pointerType: s,
                            srcEvent: t,
                          }),
                          n && e.splice(a, 1));
                    },
                  });
                var st = {
                    touchstart: 1,
                    touchmove: 2,
                    touchend: 4,
                    touchcancel: 8,
                  },
                  ot = "touchstart",
                  at = "touchstart touchmove touchend touchcancel";
                function ct() {
                  (this.evTarget = ot),
                    (this.evWin = at),
                    (this.started = !1),
                    U.apply(this, arguments);
                }
                function ht(t, e) {
                  var n = O(t.touches),
                    i = O(t.changedTouches);
                  return (
                    12 & e && (n = L(n.concat(i), "identifier", !0)), [n, i]
                  );
                }
                v(ct, U, {
                  handler: function (t) {
                    var e = st[t.type];
                    if ((1 === e && (this.started = !0), this.started)) {
                      var n = ht.call(this, t, e);
                      12 & e &&
                        n[0].length - n[1].length == 0 &&
                        (this.started = !1),
                        this.callback(this.manager, e, {
                          pointers: n[0],
                          changedPointers: n[1],
                          pointerType: D,
                          srcEvent: t,
                        });
                    }
                  },
                });
                var lt = {
                    touchstart: 1,
                    touchmove: 2,
                    touchend: 4,
                    touchcancel: 8,
                  },
                  ut = "touchstart touchmove touchend touchcancel";
                function dt() {
                  (this.evTarget = ut),
                    (this.targetIds = {}),
                    U.apply(this, arguments);
                }
                function ft(t, e) {
                  var n = O(t.touches),
                    i = this.targetIds;
                  if (3 & e && 1 === n.length)
                    return (i[n[0].identifier] = !0), [n, n];
                  var r,
                    s,
                    o = O(t.changedTouches),
                    a = [],
                    c = this.target;
                  if (
                    ((s = n.filter(function (t) {
                      return A(t.target, c);
                    })),
                    1 === e)
                  )
                    for (r = 0; r < s.length; ) (i[s[r].identifier] = !0), r++;
                  for (r = 0; r < o.length; )
                    i[o[r].identifier] && a.push(o[r]),
                      12 & e && delete i[o[r].identifier],
                      r++;
                  return a.length
                    ? [L(s.concat(a), "identifier", !0), a]
                    : void 0;
                }
                function pt() {
                  U.apply(this, arguments);
                  var t = w(this.handler, this);
                  (this.touch = new dt(this.manager, t)),
                    (this.mouse = new J(this.manager, t)),
                    (this.primaryTouch = null),
                    (this.lastTouches = []);
                }
                function gt(t, e) {
                  1 & t
                    ? ((this.primaryTouch = e.changedPointers[0].identifier),
                      mt.call(this, e))
                    : 12 & t && mt.call(this, e);
                }
                function mt(t) {
                  var e = t.changedPointers[0];
                  if (e.identifier === this.primaryTouch) {
                    var n = { x: e.clientX, y: e.clientY };
                    this.lastTouches.push(n);
                    var i = this.lastTouches;
                    setTimeout(function () {
                      var t = i.indexOf(n);
                      t > -1 && i.splice(t, 1);
                    }, 2500);
                  }
                }
                function bt(t) {
                  for (
                    var e = t.srcEvent.clientX, n = t.srcEvent.clientY, i = 0;
                    i < this.lastTouches.length;
                    i++
                  ) {
                    var r = this.lastTouches[i],
                      s = Math.abs(e - r.x),
                      o = Math.abs(n - r.y);
                    if (s <= 25 && o <= 25) return !0;
                  }
                  return !1;
                }
                v(dt, U, {
                  handler: function (t) {
                    var e = lt[t.type],
                      n = ft.call(this, t, e);
                    n &&
                      this.callback(this.manager, e, {
                        pointers: n[0],
                        changedPointers: n[1],
                        pointerType: D,
                        srcEvent: t,
                      });
                  },
                }),
                  v(pt, U, {
                    handler: function (t, e, n) {
                      var i = n.pointerType == D,
                        r = n.pointerType == N;
                      if (
                        !(
                          r &&
                          n.sourceCapabilities &&
                          n.sourceCapabilities.firesTouchEvents
                        )
                      ) {
                        if (i) gt.call(this, e, n);
                        else if (r && bt.call(this, n)) return;
                        this.callback(t, e, n);
                      }
                    },
                    destroy: function () {
                      this.touch.destroy(), this.mouse.destroy();
                    },
                  });
                var _t = I(l.style, "touchAction"),
                  yt = _t !== a,
                  vt = "compute",
                  wt = "auto",
                  xt = "manipulation",
                  Et = "none",
                  Pt = "pan-x",
                  Tt = "pan-y",
                  At = (function () {
                    if (!yt) return !1;
                    var t = {},
                      e = r.CSS && r.CSS.supports;
                    return (
                      [
                        "auto",
                        "manipulation",
                        "pan-y",
                        "pan-x",
                        "pan-x pan-y",
                        "none",
                      ].forEach(function (n) {
                        t[n] = !e || r.CSS.supports("touch-action", n);
                      }),
                      t
                    );
                  })();
                function St(t, e) {
                  (this.manager = t), this.set(e);
                }
                St.prototype = {
                  set: function (t) {
                    t == vt && (t = this.compute()),
                      yt &&
                        this.manager.element.style &&
                        At[t] &&
                        (this.manager.element.style[_t] = t),
                      (this.actions = t.toLowerCase().trim());
                  },
                  update: function () {
                    this.set(this.manager.options.touchAction);
                  },
                  compute: function () {
                    var t = [];
                    return (
                      m(this.manager.recognizers, function (e) {
                        x(e.options.enable, [e]) &&
                          (t = t.concat(e.getTouchAction()));
                      }),
                      (function (t) {
                        if (S(t, Et)) return Et;
                        var e = S(t, Pt),
                          n = S(t, Tt);
                        return e && n
                          ? Et
                          : e || n
                          ? e
                            ? Pt
                            : Tt
                          : S(t, xt)
                          ? xt
                          : wt;
                      })(t.join(" "))
                    );
                  },
                  preventDefaults: function (t) {
                    var e = t.srcEvent,
                      n = t.offsetDirection;
                    if (this.manager.session.prevented) e.preventDefault();
                    else {
                      var i = this.actions,
                        r = S(i, Et) && !At.none,
                        s = S(i, Tt) && !At["pan-y"],
                        o = S(i, Pt) && !At["pan-x"];
                      if (r) {
                        var a = 1 === t.pointers.length,
                          c = t.distance < 2,
                          h = t.deltaTime < 250;
                        if (a && c && h) return;
                      }
                      if (!o || !s)
                        return r || (s && 6 & n) || (o && 24 & n)
                          ? this.preventSrc(e)
                          : void 0;
                    }
                  },
                  preventSrc: function (t) {
                    (this.manager.session.prevented = !0), t.preventDefault();
                  },
                };
                var Mt = 32;
                function Ct(t) {
                  (this.options = c({}, this.defaults, t || {})),
                    (this.id = R++),
                    (this.manager = null),
                    (this.options.enable = E(this.options.enable, !0)),
                    (this.state = 1),
                    (this.simultaneous = {}),
                    (this.requireFail = []);
                }
                function Ot(t) {
                  return 16 & t
                    ? "cancel"
                    : 8 & t
                    ? "end"
                    : 4 & t
                    ? "move"
                    : 2 & t
                    ? "start"
                    : "";
                }
                function Lt(t) {
                  return 16 == t
                    ? "down"
                    : 8 == t
                    ? "up"
                    : 2 == t
                    ? "left"
                    : 4 == t
                    ? "right"
                    : "";
                }
                function It(t, e) {
                  var n = e.manager;
                  return n ? n.get(t) : t;
                }
                function Rt() {
                  Ct.apply(this, arguments);
                }
                function kt() {
                  Rt.apply(this, arguments), (this.pX = null), (this.pY = null);
                }
                function jt() {
                  Rt.apply(this, arguments);
                }
                function Ft() {
                  Ct.apply(this, arguments),
                    (this._timer = null),
                    (this._input = null);
                }
                function Bt() {
                  Rt.apply(this, arguments);
                }
                function Dt() {
                  Rt.apply(this, arguments);
                }
                function Nt() {
                  Ct.apply(this, arguments),
                    (this.pTime = !1),
                    (this.pCenter = !1),
                    (this._timer = null),
                    (this._input = null),
                    (this.count = 0);
                }
                function zt(t, e) {
                  return (
                    ((e = e || {}).recognizers = E(
                      e.recognizers,
                      zt.defaults.preset
                    )),
                    new Vt(t, e)
                  );
                }
                function Vt(t, e) {
                  (this.options = c({}, zt.defaults, e || {})),
                    (this.options.inputTarget = this.options.inputTarget || t),
                    (this.handlers = {}),
                    (this.session = {}),
                    (this.recognizers = []),
                    (this.oldCssProps = {}),
                    (this.element = t),
                    (this.input = new (this.options.inputClass ||
                      (F ? rt : B ? dt : j ? pt : J))(this, G)),
                    (this.touchAction = new St(this, this.options.touchAction)),
                    Ut(this, !0),
                    m(
                      this.options.recognizers,
                      function (t) {
                        var e = this.add(new t[0](t[1]));
                        t[2] && e.recognizeWith(t[2]),
                          t[3] && e.requireFailure(t[3]);
                      },
                      this
                    );
                }
                function Ut(t, e) {
                  var n,
                    i = t.element;
                  i.style &&
                    (m(t.options.cssProps, function (r, s) {
                      (n = I(i.style, s)),
                        e
                          ? ((t.oldCssProps[n] = i.style[n]), (i.style[n] = r))
                          : (i.style[n] = t.oldCssProps[n] || "");
                    }),
                    e || (t.oldCssProps = {}));
                }
                (Ct.prototype = {
                  defaults: {},
                  set: function (t) {
                    return (
                      c(this.options, t),
                      this.manager && this.manager.touchAction.update(),
                      this
                    );
                  },
                  recognizeWith: function (t) {
                    if (g(t, "recognizeWith", this)) return this;
                    var e = this.simultaneous;
                    return (
                      e[(t = It(t, this)).id] ||
                        ((e[t.id] = t), t.recognizeWith(this)),
                      this
                    );
                  },
                  dropRecognizeWith: function (t) {
                    return (
                      g(t, "dropRecognizeWith", this) ||
                        ((t = It(t, this)), delete this.simultaneous[t.id]),
                      this
                    );
                  },
                  requireFailure: function (t) {
                    if (g(t, "requireFailure", this)) return this;
                    var e = this.requireFail;
                    return (
                      -1 === C(e, (t = It(t, this))) &&
                        (e.push(t), t.requireFailure(this)),
                      this
                    );
                  },
                  dropRequireFailure: function (t) {
                    if (g(t, "dropRequireFailure", this)) return this;
                    t = It(t, this);
                    var e = C(this.requireFail, t);
                    return e > -1 && this.requireFail.splice(e, 1), this;
                  },
                  hasRequireFailures: function () {
                    return this.requireFail.length > 0;
                  },
                  canRecognizeWith: function (t) {
                    return !!this.simultaneous[t.id];
                  },
                  emit: function (t) {
                    var e = this,
                      n = this.state;
                    function i(n) {
                      e.manager.emit(n, t);
                    }
                    n < 8 && i(e.options.event + Ot(n)),
                      i(e.options.event),
                      t.additionalEvent && i(t.additionalEvent),
                      n >= 8 && i(e.options.event + Ot(n));
                  },
                  tryEmit: function (t) {
                    if (this.canEmit()) return this.emit(t);
                    this.state = Mt;
                  },
                  canEmit: function () {
                    for (var t = 0; t < this.requireFail.length; ) {
                      if (!(33 & this.requireFail[t].state)) return !1;
                      t++;
                    }
                    return !0;
                  },
                  recognize: function (t) {
                    var e = c({}, t);
                    if (!x(this.options.enable, [this, e]))
                      return this.reset(), void (this.state = Mt);
                    56 & this.state && (this.state = 1),
                      (this.state = this.process(e)),
                      30 & this.state && this.tryEmit(e);
                  },
                  process: function (t) {},
                  getTouchAction: function () {},
                  reset: function () {},
                }),
                  v(Rt, Ct, {
                    defaults: { pointers: 1 },
                    attrTest: function (t) {
                      var e = this.options.pointers;
                      return 0 === e || t.pointers.length === e;
                    },
                    process: function (t) {
                      var e = this.state,
                        n = t.eventType,
                        i = 6 & e,
                        r = this.attrTest(t);
                      return i && (8 & n || !r)
                        ? 16 | e
                        : i || r
                        ? 4 & n
                          ? 8 | e
                          : 2 & e
                          ? 4 | e
                          : 2
                        : Mt;
                    },
                  }),
                  v(kt, Rt, {
                    defaults: {
                      event: "pan",
                      threshold: 10,
                      pointers: 1,
                      direction: 30,
                    },
                    getTouchAction: function () {
                      var t = this.options.direction,
                        e = [];
                      return 6 & t && e.push(Tt), 24 & t && e.push(Pt), e;
                    },
                    directionTest: function (t) {
                      var e = this.options,
                        n = !0,
                        i = t.distance,
                        r = t.direction,
                        s = t.deltaX,
                        o = t.deltaY;
                      return (
                        r & e.direction ||
                          (6 & e.direction
                            ? ((r = 0 === s ? 1 : s < 0 ? 2 : 4),
                              (n = s != this.pX),
                              (i = Math.abs(t.deltaX)))
                            : ((r = 0 === o ? 1 : o < 0 ? 8 : 16),
                              (n = o != this.pY),
                              (i = Math.abs(t.deltaY)))),
                        (t.direction = r),
                        n && i > e.threshold && r & e.direction
                      );
                    },
                    attrTest: function (t) {
                      return (
                        Rt.prototype.attrTest.call(this, t) &&
                        (2 & this.state ||
                          (!(2 & this.state) && this.directionTest(t)))
                      );
                    },
                    emit: function (t) {
                      (this.pX = t.deltaX), (this.pY = t.deltaY);
                      var e = Lt(t.direction);
                      e && (t.additionalEvent = this.options.event + e),
                        this._super.emit.call(this, t);
                    },
                  }),
                  v(jt, Rt, {
                    defaults: { event: "pinch", threshold: 0, pointers: 2 },
                    getTouchAction: function () {
                      return [Et];
                    },
                    attrTest: function (t) {
                      return (
                        this._super.attrTest.call(this, t) &&
                        (Math.abs(t.scale - 1) > this.options.threshold ||
                          2 & this.state)
                      );
                    },
                    emit: function (t) {
                      if (1 !== t.scale) {
                        var e = t.scale < 1 ? "in" : "out";
                        t.additionalEvent = this.options.event + e;
                      }
                      this._super.emit.call(this, t);
                    },
                  }),
                  v(Ft, Ct, {
                    defaults: {
                      event: "press",
                      pointers: 1,
                      time: 251,
                      threshold: 9,
                    },
                    getTouchAction: function () {
                      return [wt];
                    },
                    process: function (t) {
                      var e = this.options,
                        n = t.pointers.length === e.pointers,
                        i = t.distance < e.threshold,
                        r = t.deltaTime > e.time;
                      if (
                        ((this._input = t),
                        !i || !n || (12 & t.eventType && !r))
                      )
                        this.reset();
                      else if (1 & t.eventType)
                        this.reset(),
                          (this._timer = p(
                            function () {
                              (this.state = 8), this.tryEmit();
                            },
                            e.time,
                            this
                          ));
                      else if (4 & t.eventType) return 8;
                      return Mt;
                    },
                    reset: function () {
                      clearTimeout(this._timer);
                    },
                    emit: function (t) {
                      8 === this.state &&
                        (t && 4 & t.eventType
                          ? this.manager.emit(this.options.event + "up", t)
                          : ((this._input.timeStamp = f()),
                            this.manager.emit(
                              this.options.event,
                              this._input
                            )));
                    },
                  }),
                  v(Bt, Rt, {
                    defaults: { event: "rotate", threshold: 0, pointers: 2 },
                    getTouchAction: function () {
                      return [Et];
                    },
                    attrTest: function (t) {
                      return (
                        this._super.attrTest.call(this, t) &&
                        (Math.abs(t.rotation) > this.options.threshold ||
                          2 & this.state)
                      );
                    },
                  }),
                  v(Dt, Rt, {
                    defaults: {
                      event: "swipe",
                      threshold: 10,
                      velocity: 0.3,
                      direction: 30,
                      pointers: 1,
                    },
                    getTouchAction: function () {
                      return kt.prototype.getTouchAction.call(this);
                    },
                    attrTest: function (t) {
                      var e,
                        n = this.options.direction;
                      return (
                        30 & n
                          ? (e = t.overallVelocity)
                          : 6 & n
                          ? (e = t.overallVelocityX)
                          : 24 & n && (e = t.overallVelocityY),
                        this._super.attrTest.call(this, t) &&
                          n & t.offsetDirection &&
                          t.distance > this.options.threshold &&
                          t.maxPointers == this.options.pointers &&
                          d(e) > this.options.velocity &&
                          4 & t.eventType
                      );
                    },
                    emit: function (t) {
                      var e = Lt(t.offsetDirection);
                      e && this.manager.emit(this.options.event + e, t),
                        this.manager.emit(this.options.event, t);
                    },
                  }),
                  v(Nt, Ct, {
                    defaults: {
                      event: "tap",
                      pointers: 1,
                      taps: 1,
                      interval: 300,
                      time: 250,
                      threshold: 9,
                      posThreshold: 10,
                    },
                    getTouchAction: function () {
                      return [xt];
                    },
                    process: function (t) {
                      var e = this.options,
                        n = t.pointers.length === e.pointers,
                        i = t.distance < e.threshold,
                        r = t.deltaTime < e.time;
                      if ((this.reset(), 1 & t.eventType && 0 === this.count))
                        return this.failTimeout();
                      if (i && r && n) {
                        if (4 != t.eventType) return this.failTimeout();
                        var s =
                            !this.pTime ||
                            t.timeStamp - this.pTime < e.interval,
                          o =
                            !this.pCenter ||
                            q(this.pCenter, t.center) < e.posThreshold;
                        if (
                          ((this.pTime = t.timeStamp),
                          (this.pCenter = t.center),
                          o && s ? (this.count += 1) : (this.count = 1),
                          (this._input = t),
                          0 == this.count % e.taps)
                        )
                          return this.hasRequireFailures()
                            ? ((this._timer = p(
                                function () {
                                  (this.state = 8), this.tryEmit();
                                },
                                e.interval,
                                this
                              )),
                              2)
                            : 8;
                      }
                      return Mt;
                    },
                    failTimeout: function () {
                      return (
                        (this._timer = p(
                          function () {
                            this.state = Mt;
                          },
                          this.options.interval,
                          this
                        )),
                        Mt
                      );
                    },
                    reset: function () {
                      clearTimeout(this._timer);
                    },
                    emit: function () {
                      8 == this.state &&
                        ((this._input.tapCount = this.count),
                        this.manager.emit(this.options.event, this._input));
                    },
                  }),
                  (zt.VERSION = "2.0.7"),
                  (zt.defaults = {
                    domEvents: !1,
                    touchAction: vt,
                    enable: !0,
                    inputTarget: null,
                    inputClass: null,
                    preset: [
                      [Bt, { enable: !1 }],
                      [jt, { enable: !1 }, ["rotate"]],
                      [Dt, { direction: 6 }],
                      [kt, { direction: 6 }, ["swipe"]],
                      [Nt],
                      [Nt, { event: "doubletap", taps: 2 }, ["tap"]],
                      [Ft],
                    ],
                    cssProps: {
                      userSelect: "none",
                      touchSelect: "none",
                      touchCallout: "none",
                      contentZooming: "none",
                      userDrag: "none",
                      tapHighlightColor: "rgba(0,0,0,0)",
                    },
                  }),
                  (Vt.prototype = {
                    set: function (t) {
                      return (
                        c(this.options, t),
                        t.touchAction && this.touchAction.update(),
                        t.inputTarget &&
                          (this.input.destroy(),
                          (this.input.target = t.inputTarget),
                          this.input.init()),
                        this
                      );
                    },
                    stop: function (t) {
                      this.session.stopped = t ? 2 : 1;
                    },
                    recognize: function (t) {
                      var e = this.session;
                      if (!e.stopped) {
                        var n;
                        this.touchAction.preventDefaults(t);
                        var i = this.recognizers,
                          r = e.curRecognizer;
                        (!r || (r && 8 & r.state)) &&
                          (r = e.curRecognizer = null);
                        for (var s = 0; s < i.length; )
                          (n = i[s]),
                            2 === e.stopped ||
                            (r && n != r && !n.canRecognizeWith(r))
                              ? n.reset()
                              : n.recognize(t),
                            !r && 14 & n.state && (r = e.curRecognizer = n),
                            s++;
                      }
                    },
                    get: function (t) {
                      if (t instanceof Ct) return t;
                      for (var e = this.recognizers, n = 0; n < e.length; n++)
                        if (e[n].options.event == t) return e[n];
                      return null;
                    },
                    add: function (t) {
                      if (g(t, "add", this)) return this;
                      var e = this.get(t.options.event);
                      return (
                        e && this.remove(e),
                        this.recognizers.push(t),
                        (t.manager = this),
                        this.touchAction.update(),
                        t
                      );
                    },
                    remove: function (t) {
                      if (g(t, "remove", this)) return this;
                      if ((t = this.get(t))) {
                        var e = this.recognizers,
                          n = C(e, t);
                        -1 !== n && (e.splice(n, 1), this.touchAction.update());
                      }
                      return this;
                    },
                    on: function (t, e) {
                      if (t !== a && e !== a) {
                        var n = this.handlers;
                        return (
                          m(M(t), function (t) {
                            (n[t] = n[t] || []), n[t].push(e);
                          }),
                          this
                        );
                      }
                    },
                    off: function (t, e) {
                      if (t !== a) {
                        var n = this.handlers;
                        return (
                          m(M(t), function (t) {
                            e
                              ? n[t] && n[t].splice(C(n[t], e), 1)
                              : delete n[t];
                          }),
                          this
                        );
                      }
                    },
                    emit: function (t, e) {
                      this.options.domEvents &&
                        (function (t, e) {
                          var n = s.createEvent("Event");
                          n.initEvent(t, !0, !0),
                            (n.gesture = e),
                            e.target.dispatchEvent(n);
                        })(t, e);
                      var n = this.handlers[t] && this.handlers[t].slice();
                      if (n && n.length) {
                        (e.type = t),
                          (e.preventDefault = function () {
                            e.srcEvent.preventDefault();
                          });
                        for (var i = 0; i < n.length; ) n[i](e), i++;
                      }
                    },
                    destroy: function () {
                      this.element && Ut(this, !1),
                        (this.handlers = {}),
                        (this.session = {}),
                        this.input.destroy(),
                        (this.element = null);
                    },
                  }),
                  c(zt, {
                    INPUT_START: 1,
                    INPUT_MOVE: 2,
                    INPUT_END: 4,
                    INPUT_CANCEL: 8,
                    STATE_POSSIBLE: 1,
                    STATE_BEGAN: 2,
                    STATE_CHANGED: 4,
                    STATE_ENDED: 8,
                    STATE_RECOGNIZED: 8,
                    STATE_CANCELLED: 16,
                    STATE_FAILED: Mt,
                    DIRECTION_NONE: 1,
                    DIRECTION_LEFT: 2,
                    DIRECTION_RIGHT: 4,
                    DIRECTION_UP: 8,
                    DIRECTION_DOWN: 16,
                    DIRECTION_HORIZONTAL: 6,
                    DIRECTION_VERTICAL: 24,
                    DIRECTION_ALL: 30,
                    Manager: Vt,
                    Input: U,
                    TouchAction: St,
                    TouchInput: dt,
                    MouseInput: J,
                    PointerEventInput: rt,
                    TouchMouseInput: pt,
                    SingleTouchInput: ct,
                    Recognizer: Ct,
                    AttrRecognizer: Rt,
                    Tap: Nt,
                    Pan: kt,
                    Swipe: Dt,
                    Pinch: jt,
                    Rotate: Bt,
                    Press: Ft,
                    on: P,
                    off: T,
                    each: m,
                    merge: y,
                    extend: _,
                    assign: c,
                    inherit: v,
                    bindFn: w,
                    prefixed: I,
                  }),
                  ((void 0 !== r
                    ? r
                    : "undefined" != typeof self
                    ? self
                    : {}
                  ).Hammer = zt),
                  (i = function () {
                    return zt;
                  }.call(e, n, e, t)) === a || (t.exports = i);
              })(window, document);
            },
            613: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.isMobile = function () {
                  return void 0 !== r.window.orientation;
                }),
                (e.default = function (t) {
                  if (!t && !(0, s.default)()) return "Node";
                  if ((0, o.default)(t)) return "Electron";
                  var e = "undefined" != typeof navigator ? navigator : {},
                    n = t || e.userAgent || "";
                  if (n.indexOf("Edge") > -1) return "Edge";
                  var i = -1 !== n.indexOf("MSIE "),
                    a = -1 !== n.indexOf("Trident/");
                  return i || a
                    ? "IE"
                    : r.window.chrome
                    ? "Chrome"
                    : r.window.safari
                    ? "Safari"
                    : r.window.mozInnerScreenX
                    ? "Firefox"
                    : "Unknown";
                });
              var r = n(129),
                s = i(n(355)),
                o = i(n(628));
            },
            129: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.console =
                  e.process =
                  e.document =
                  e.global =
                  e.window =
                  e.self =
                    void 0);
              var r = i(n(17)),
                s = {
                  self: "undefined" != typeof self && self,
                  window: "undefined" != typeof window && window,
                  global: void 0 !== n.g && n.g,
                  document: "undefined" != typeof document && document,
                  process:
                    "object" ===
                      ("undefined" == typeof process
                        ? "undefined"
                        : (0, r.default)(process)) && process,
                },
                o = s.self || s.window || s.global;
              e.self = o;
              var a = s.window || s.self || s.global;
              e.window = a;
              var c = s.global || s.self || s.window;
              e.global = c;
              var h = s.document || {};
              e.document = h;
              var l = s.process || {};
              e.process = l;
              var u = console;
              e.console = u;
            },
            395: (t, e, n) => {
              "use strict";
              var i = n(422),
                r = n(17);
              Object.defineProperty(e, "CO", {
                enumerable: !0,
                get: function () {
                  return s.global;
                },
              }),
                Object.defineProperty(e, "jU", {
                  enumerable: !0,
                  get: function () {
                    return o.default;
                  },
                }),
                Object.defineProperty(e, "qs", {
                  enumerable: !0,
                  get: function () {
                    return a.default;
                  },
                });
              var s = n(129),
                o = h(n(355)),
                a = h(n(613));
              i(n(628));
              function c(t) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap(),
                  n = new WeakMap();
                return (c = function (t) {
                  return t ? n : e;
                })(t);
              }
              function h(t, e) {
                if (!e && t && t.__esModule) return t;
                if (null === t || ("object" !== r(t) && "function" != typeof t))
                  return { default: t };
                var n = c(e);
                if (n && n.has(t)) return n.get(t);
                var i = {},
                  s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in t)
                  if (
                    "default" !== o &&
                    Object.prototype.hasOwnProperty.call(t, o)
                  ) {
                    var a = s ? Object.getOwnPropertyDescriptor(t, o) : null;
                    a && (a.get || a.set)
                      ? Object.defineProperty(i, o, a)
                      : (i[o] = t[o]);
                  }
                return (i.default = t), n && n.set(t, i), i;
              }
            },
            355: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.default = o),
                (e.isBrowserMainThread = function () {
                  return o() && "undefined" != typeof document;
                });
              var r = i(n(17)),
                s = i(n(628));
              function o() {
                return (
                  !(
                    "object" ===
                      ("undefined" == typeof process
                        ? "undefined"
                        : (0, r.default)(process)) &&
                    "[object process]" === String(process) &&
                    !process.browser
                  ) || (0, s.default)()
                );
              }
            },
            628: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.default = function (t) {
                  if (
                    "undefined" != typeof window &&
                    "object" === (0, r.default)(window.process) &&
                    "renderer" === window.process.type
                  )
                    return !0;
                  if (
                    "undefined" != typeof process &&
                    "object" === (0, r.default)(process.versions) &&
                    Boolean(process.versions.electron)
                  )
                    return !0;
                  var e =
                      "object" ===
                        ("undefined" == typeof navigator
                          ? "undefined"
                          : (0, r.default)(navigator)) &&
                      "string" == typeof navigator.userAgent &&
                      navigator.userAgent,
                    n = t || e;
                  return !!(n && n.indexOf("Electron") >= 0);
                });
              var r = i(n(17));
            },
            521: () => {},
            307: () => {},
          },
          e = {};
        function n(i) {
          var r = e[i];
          if (void 0 !== r) return r.exports;
          var s = (e[i] = { exports: {} });
          return t[i](s, s.exports, n), s.exports;
        }
        (n.n = (t) => {
          var e = t && t.__esModule ? () => t.default : () => t;
          return n.d(e, { a: e }), e;
        }),
          (n.d = (t, e) => {
            for (var i in e)
              n.o(e, i) &&
                !n.o(t, i) &&
                Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
          }),
          (n.g = (function () {
            if ("object" == typeof globalThis) return globalThis;
            try {
              return this || new Function("return this")();
            } catch (t) {
              if ("object" == typeof window) return window;
            }
          })()),
          (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
          (n.r = (t) => {
            "undefined" != typeof Symbol &&
              Symbol.toStringTag &&
              Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
              Object.defineProperty(t, "__esModule", { value: !0 });
          });
        var i = {};
        (() => {
          "use strict";
          function t(t) {
            if (
              "undefined" != typeof window &&
              "object" == typeof window.process &&
              "renderer" === window.process.type
            )
              return !0;
            if (
              "undefined" != typeof process &&
              "object" == typeof process.versions &&
              Boolean(process.versions.electron)
            )
              return !0;
            const e =
                "object" == typeof navigator &&
                "string" == typeof navigator.userAgent &&
                navigator.userAgent,
              n = t || e;
            return !!(n && n.indexOf("Electron") >= 0);
          }
          function e() {
            return (
              !(
                "object" == typeof process &&
                "[object process]" === String(process) &&
                !process.browser
              ) || t()
            );
          }
          n.r(i), n.d(i, { initMap: () => Xl });
          const r =
              "undefined" != typeof __VERSION__
                ? __VERSION__
                : "untranspiled source",
            s = e();
          class o {
            constructor(t, e, n = "sessionStorage") {
              (this.storage = (function (t) {
                try {
                  const e = window[t],
                    n = "__storage_test__";
                  return e.setItem(n, n), e.removeItem(n), e;
                } catch (t) {
                  return null;
                }
              })(n)),
                (this.id = t),
                (this.config = {}),
                Object.assign(this.config, e),
                this._loadConfiguration();
            }
            getConfiguration() {
              return this.config;
            }
            setConfiguration(t) {
              return (this.config = {}), this.updateConfiguration(t);
            }
            updateConfiguration(t) {
              if ((Object.assign(this.config, t), this.storage)) {
                const t = JSON.stringify(this.config);
                this.storage.setItem(this.id, t);
              }
              return this;
            }
            _loadConfiguration() {
              let t = {};
              if (this.storage) {
                const e = this.storage.getItem(this.id);
                t = e ? JSON.parse(e) : {};
              }
              return Object.assign(this.config, t), this;
            }
          }
          function a(t, e, n, i = 600) {
            const r = t.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
            t.width > i && (n = Math.min(n, i / t.width));
            const s = t.width * n,
              o = t.height * n,
              a = [
                "font-size:1px;",
                "padding:"
                  .concat(Math.floor(o / 2), "px ")
                  .concat(Math.floor(s / 2), "px;"),
                "line-height:".concat(o, "px;"),
                "background:url(".concat(r, ");"),
                "background-size:".concat(s, "px ").concat(o, "px;"),
                "color:transparent;",
              ].join("");
            return ["".concat(e, " %c+"), a];
          }
          const c = {
            BLACK: 30,
            RED: 31,
            GREEN: 32,
            YELLOW: 33,
            BLUE: 34,
            MAGENTA: 35,
            CYAN: 36,
            WHITE: 37,
            BRIGHT_BLACK: 90,
            BRIGHT_RED: 91,
            BRIGHT_GREEN: 92,
            BRIGHT_YELLOW: 93,
            BRIGHT_BLUE: 94,
            BRIGHT_MAGENTA: 95,
            BRIGHT_CYAN: 96,
            BRIGHT_WHITE: 97,
          };
          function h(t) {
            return "string" == typeof t ? c[t.toUpperCase()] || c.WHITE : t;
          }
          function l(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          const u = {
              self: "undefined" != typeof self && self,
              window: "undefined" != typeof window && window,
              global: void 0 !== n.g && n.g,
              document: "undefined" != typeof document && document,
              process: "object" == typeof process && process,
            },
            d = u.window || u.self || u.global,
            f = u.process || {};
          function p() {
            let t;
            if (s && d.performance) t = d.performance.now();
            else if (f.hrtime) {
              const e = f.hrtime();
              t = 1e3 * e[0] + e[1] / 1e6;
            } else t = Date.now();
            return t;
          }
          console;
          const g = {
              debug: (s && console.debug) || console.log,
              log: console.log,
              info: console.info,
              warn: console.warn,
              error: console.error,
            },
            m = { enabled: !0, level: 0 };
          function b() {}
          const _ = {},
            y = { once: !0 };
          function v(t) {
            for (const e in t) for (const n in t[e]) return n || "untitled";
            return "empty";
          }
          class w {
            constructor({ id: t } = { id: "" }) {
              (this.id = t),
                (this.VERSION = r),
                (this._startTs = p()),
                (this._deltaTs = p()),
                (this.LOG_THROTTLE_TIMEOUT = 0),
                (this._storage = new o("__probe-".concat(this.id, "__"), m)),
                (this.userData = {}),
                this.timeStamp("".concat(this.id, " started")),
                (function (t, e = ["constructor"]) {
                  const n = Object.getPrototypeOf(t),
                    i = Object.getOwnPropertyNames(n);
                  for (const n of i)
                    "function" == typeof t[n] &&
                      (e.find((t) => n === t) || (t[n] = t[n].bind(t)));
                })(this),
                Object.seal(this);
            }
            set level(t) {
              this.setLevel(t);
            }
            get level() {
              return this.getLevel();
            }
            isEnabled() {
              return this._storage.config.enabled;
            }
            getLevel() {
              return this._storage.config.level;
            }
            getTotal() {
              return Number((p() - this._startTs).toPrecision(10));
            }
            getDelta() {
              return Number((p() - this._deltaTs).toPrecision(10));
            }
            set priority(t) {
              this.level = t;
            }
            get priority() {
              return this.level;
            }
            getPriority() {
              return this.level;
            }
            enable(t = !0) {
              return this._storage.updateConfiguration({ enabled: t }), this;
            }
            setLevel(t) {
              return this._storage.updateConfiguration({ level: t }), this;
            }
            assert(t, e) {
              l(t, e);
            }
            warn(t) {
              return this._getLogFunction(0, t, g.warn, arguments, y);
            }
            error(t) {
              return this._getLogFunction(0, t, g.error, arguments);
            }
            deprecated(t, e) {
              return this.warn(
                "`"
                  .concat(
                    t,
                    "` is deprecated and will be removed in a later version. Use `"
                  )
                  .concat(e, "` instead")
              );
            }
            removed(t, e) {
              return this.error(
                "`"
                  .concat(t, "` has been removed. Use `")
                  .concat(e, "` instead")
              );
            }
            probe(t, e) {
              return this._getLogFunction(t, e, g.log, arguments, {
                time: !0,
                once: !0,
              });
            }
            log(t, e) {
              return this._getLogFunction(t, e, g.debug, arguments);
            }
            info(t, e) {
              return this._getLogFunction(t, e, console.info, arguments);
            }
            once(t, e) {
              return this._getLogFunction(
                t,
                e,
                g.debug || g.info,
                arguments,
                y
              );
            }
            table(t, e, n) {
              return e
                ? this._getLogFunction(t, e, console.table || b, n && [n], {
                    tag: v(e),
                  })
                : b;
            }
            image({
              logLevel: t,
              priority: e,
              image: i,
              message: r = "",
              scale: o = 1,
            }) {
              return this._shouldLog(t || e)
                ? s
                  ? (function ({ image: t, message: e = "", scale: n = 1 }) {
                      if ("string" == typeof t) {
                        const i = new Image();
                        return (
                          (i.onload = () => {
                            const t = a(i, e, n);
                            console.log(...t);
                          }),
                          (i.src = t),
                          b
                        );
                      }
                      const i = t.nodeName || "";
                      if ("img" === i.toLowerCase())
                        return console.log(...a(t, e, n)), b;
                      if ("canvas" === i.toLowerCase()) {
                        const i = new Image();
                        return (
                          (i.onload = () => console.log(...a(i, e, n))),
                          (i.src = t.toDataURL()),
                          b
                        );
                      }
                      return b;
                    })({ image: i, message: r, scale: o })
                  : (function ({ image: t, message: e = "", scale: i = 1 }) {
                      let r = null;
                      try {
                        r = n(307);
                      } catch (t) {}
                      return r
                        ? () =>
                            r(t, {
                              fit: "box",
                              width: "".concat(Math.round(80 * i), "%"),
                            }).then((t) => console.log(t))
                        : b;
                    })({ image: i, message: r, scale: o })
                : b;
            }
            settings() {
              console.table
                ? console.table(this._storage.config)
                : console.log(this._storage.config);
            }
            get(t) {
              return this._storage.config[t];
            }
            set(t, e) {
              this._storage.updateConfiguration({ [t]: e });
            }
            time(t, e) {
              return this._getLogFunction(
                t,
                e,
                console.time ? console.time : console.info
              );
            }
            timeEnd(t, e) {
              return this._getLogFunction(
                t,
                e,
                console.timeEnd ? console.timeEnd : console.info
              );
            }
            timeStamp(t, e) {
              return this._getLogFunction(t, e, console.timeStamp || b);
            }
            group(t, e, n = { collapsed: !1 }) {
              n = E({ logLevel: t, message: e, opts: n });
              const { collapsed: i } = n;
              return (
                (n.method =
                  (i ? console.groupCollapsed : console.group) || console.info),
                this._getLogFunction(n)
              );
            }
            groupCollapsed(t, e, n = {}) {
              return this.group(t, e, Object.assign({}, n, { collapsed: !0 }));
            }
            groupEnd(t) {
              return this._getLogFunction(t, "", console.groupEnd || b);
            }
            withGroup(t, e, n) {
              this.group(t, e)();
              try {
                n();
              } finally {
                this.groupEnd(t)();
              }
            }
            trace() {
              console.trace && console.trace();
            }
            _shouldLog(t) {
              return this.isEnabled() && this.getLevel() >= x(t);
            }
            _getLogFunction(t, e, n, i = [], r) {
              if (this._shouldLog(t)) {
                (r = E({ logLevel: t, message: e, args: i, opts: r })),
                  l((n = n || r.method)),
                  (r.total = this.getTotal()),
                  (r.delta = this.getDelta()),
                  (this._deltaTs = p());
                const o = r.tag || r.message;
                if (r.once) {
                  if (_[o]) return b;
                  _[o] = p();
                }
                return (
                  (e = (function (t, e, n) {
                    if ("string" == typeof e) {
                      const a = n.time
                        ? (function (t, e = 8) {
                            const n = Math.max(e - t.length, 0);
                            return "".concat(" ".repeat(n)).concat(t);
                          })(
                            (function (t) {
                              let e;
                              return (
                                (e =
                                  t < 10
                                    ? "".concat(t.toFixed(2), "ms")
                                    : t < 100
                                    ? "".concat(t.toFixed(1), "ms")
                                    : t < 1e3
                                    ? "".concat(t.toFixed(0), "ms")
                                    : "".concat((t / 1e3).toFixed(2), "s")),
                                e
                              );
                            })(n.total)
                          )
                        : "";
                      (i = e =
                        n.time
                          ? "".concat(t, ": ").concat(a, "  ").concat(e)
                          : "".concat(t, ": ").concat(e)),
                        (r = n.color),
                        (o = n.background),
                        s ||
                          "string" != typeof i ||
                          (r &&
                            ((r = h(r)),
                            (i = "[".concat(r, "m").concat(i, "[39m"))),
                          o &&
                            ((r = h(o)),
                            (i = "[".concat(o + 10, "m").concat(i, "[49m")))),
                        (e = i);
                    }
                    var i, r, o;
                    return e;
                  })(this.id, r.message, r)),
                  n.bind(console, e, ...r.args)
                );
              }
              return b;
            }
          }
          function x(t) {
            if (!t) return 0;
            let e;
            switch (typeof t) {
              case "number":
                e = t;
                break;
              case "object":
                e = t.logLevel || t.priority || 0;
                break;
              default:
                return 0;
            }
            return l(Number.isFinite(e) && e >= 0), e;
          }
          function E(t) {
            const { logLevel: e, message: n } = t;
            t.logLevel = x(e);
            const i = t.args ? Array.from(t.args) : [];
            for (; i.length && i.shift() !== n; );
            switch (((t.args = i), typeof e)) {
              case "string":
              case "function":
                void 0 !== n && i.unshift(n), (t.message = e);
                break;
              case "object":
                Object.assign(t, e);
            }
            "function" == typeof t.message && (t.message = t.message());
            const r = typeof t.message;
            return (
              l("string" === r || "object" === r), Object.assign(t, t.opts)
            );
          }
          w.VERSION = r;
          const P = new w({ id: "luma.gl" });
          function T(t, e) {
            if (!t) throw new Error(e || "luma.gl: assertion failed.");
          }
          function A(t) {
            return (
              ("undefined" != typeof WebGLRenderingContext &&
                t instanceof WebGLRenderingContext) ||
              ("undefined" != typeof WebGL2RenderingContext &&
                t instanceof WebGL2RenderingContext) ||
              Boolean(t && Number.isFinite(t._version))
            );
          }
          function S(t) {
            return (
              ("undefined" != typeof WebGL2RenderingContext &&
                t instanceof WebGL2RenderingContext) ||
              Boolean(t && 2 === t._version)
            );
          }
          function M(t) {
            return T(A(t), "Invalid WebGLRenderingContext"), t;
          }
          function C(t) {
            return T(S(t), "Requires WebGL2"), t;
          }
          var O = n(395);
          const L = {};
          const I = function t(e) {
            const n = e.gl;
            (this.ext = e),
              (this.isAlive = !0),
              (this.hasBeenBound = !1),
              (this.elementArrayBuffer = null),
              (this.attribs = new Array(e.maxVertexAttribs));
            for (let e = 0; e < this.attribs.length; e++) {
              const i = new t.VertexAttrib(n);
              this.attribs[e] = i;
            }
            this.maxAttrib = 0;
          };
          (I.VertexAttrib = function (t) {
            (this.enabled = !1),
              (this.buffer = null),
              (this.size = 4),
              (this.type = 5126),
              (this.normalized = !1),
              (this.stride = 16),
              (this.offset = 0),
              (this.cached = ""),
              this.recache();
          }).prototype.recache = function () {
            this.cached = [
              this.size,
              this.type,
              this.normalized,
              this.stride,
              this.offset,
            ].join(":");
          };
          const R = function (t) {
            const e = this;
            (this.gl = t),
              (function (t) {
                const e = t.getError;
                t.getError = function () {
                  let n;
                  do {
                    (n = e.apply(t)), 0 !== n && (L[n] = !0);
                  } while (0 !== n);
                  for (n in L) if (L[n]) return delete L[n], parseInt(n, 10);
                  return 0;
                };
              })(t);
            const n = (this.original = {
              getParameter: t.getParameter,
              enableVertexAttribArray: t.enableVertexAttribArray,
              disableVertexAttribArray: t.disableVertexAttribArray,
              bindBuffer: t.bindBuffer,
              getVertexAttrib: t.getVertexAttrib,
              vertexAttribPointer: t.vertexAttribPointer,
            });
            (t.getParameter = function (t) {
              return t === e.VERTEX_ARRAY_BINDING_OES
                ? e.currentVertexArrayObject === e.defaultVertexArrayObject
                  ? null
                  : e.currentVertexArrayObject
                : n.getParameter.apply(this, arguments);
            }),
              (t.enableVertexAttribArray = function (t) {
                const i = e.currentVertexArrayObject;
                i.maxAttrib = Math.max(i.maxAttrib, t);
                const r = i.attribs[t];
                return (
                  (r.enabled = !0),
                  n.enableVertexAttribArray.apply(this, arguments)
                );
              }),
              (t.disableVertexAttribArray = function (t) {
                const i = e.currentVertexArrayObject;
                i.maxAttrib = Math.max(i.maxAttrib, t);
                const r = i.attribs[t];
                return (
                  (r.enabled = !1),
                  n.disableVertexAttribArray.apply(this, arguments)
                );
              }),
              (t.bindBuffer = function (t, i) {
                switch (t) {
                  case 34962:
                    e.currentArrayBuffer = i;
                    break;
                  case 34963:
                    e.currentVertexArrayObject.elementArrayBuffer = i;
                }
                return n.bindBuffer.apply(this, arguments);
              }),
              (t.getVertexAttrib = function (t, i) {
                const r = e.currentVertexArrayObject,
                  s = r.attribs[t];
                switch (i) {
                  case 34975:
                    return s.buffer;
                  case 34338:
                    return s.enabled;
                  case 34339:
                    return s.size;
                  case 34340:
                    return s.stride;
                  case 34341:
                    return s.type;
                  case 34922:
                    return s.normalized;
                  default:
                    return n.getVertexAttrib.apply(this, arguments);
                }
              }),
              (t.vertexAttribPointer = function (t, i, r, s, o, a) {
                const c = e.currentVertexArrayObject;
                c.maxAttrib = Math.max(c.maxAttrib, t);
                const h = c.attribs[t];
                return (
                  (h.buffer = e.currentArrayBuffer),
                  (h.size = i),
                  (h.type = r),
                  (h.normalized = s),
                  (h.stride = o),
                  (h.offset = a),
                  h.recache(),
                  n.vertexAttribPointer.apply(this, arguments)
                );
              }),
              t.instrumentExtension &&
                t.instrumentExtension(this, "OES_vertex_array_object"),
              t.canvas &&
                t.canvas.addEventListener(
                  "webglcontextrestored",
                  () => {
                    O.CO.console &&
                      O.CO.console.log &&
                      O.CO.console.log(
                        "OESVertexArrayObject emulation library context restored"
                      ),
                      e.reset_();
                  },
                  !0
                ),
              this.reset_();
          };
          (R.prototype.VERTEX_ARRAY_BINDING_OES = 34229),
            (R.prototype.reset_ = function () {
              if (void 0 !== this.vertexArrayObjects)
                for (let t = 0; t < this.vertexArrayObjects.length; ++t)
                  this.vertexArrayObjects.isAlive = !1;
              const t = this.gl;
              (this.maxVertexAttribs = t.getParameter(34921)),
                (this.defaultVertexArrayObject = new I(this)),
                (this.currentVertexArrayObject = null),
                (this.currentArrayBuffer = null),
                (this.vertexArrayObjects = [this.defaultVertexArrayObject]),
                this.bindVertexArrayOES(null);
            }),
            (R.prototype.createVertexArrayOES = function () {
              const t = new I(this);
              return this.vertexArrayObjects.push(t), t;
            }),
            (R.prototype.deleteVertexArrayOES = function (t) {
              (t.isAlive = !1),
                this.vertexArrayObjects.splice(
                  this.vertexArrayObjects.indexOf(t),
                  1
                ),
                this.currentVertexArrayObject === t &&
                  this.bindVertexArrayOES(null);
            }),
            (R.prototype.isVertexArrayOES = function (t) {
              return !!(
                t &&
                t instanceof I &&
                t.hasBeenBound &&
                t.ext === this
              );
            }),
            (R.prototype.bindVertexArrayOES = function (t) {
              const e = this.gl;
              if (t && !t.isAlive)
                return (
                  (n =
                    "bindVertexArrayOES: attempt to bind deleted arrayObject"),
                  (L[1282] = !0),
                  void (
                    void 0 !== n &&
                    ((i = n),
                    O.CO.console && O.CO.console.error && O.CO.console.error(i))
                  )
                );
              var n, i;
              const r = this.original,
                s = this.currentVertexArrayObject;
              (this.currentVertexArrayObject =
                t || this.defaultVertexArrayObject),
                (this.currentVertexArrayObject.hasBeenBound = !0);
              const o = this.currentVertexArrayObject;
              if (s === o) return;
              (s && o.elementArrayBuffer === s.elementArrayBuffer) ||
                r.bindBuffer.call(e, 34963, o.elementArrayBuffer);
              let a = this.currentArrayBuffer;
              const c = Math.max(s ? s.maxAttrib : 0, o.maxAttrib);
              for (let t = 0; t <= c; t++) {
                const n = o.attribs[t],
                  i = s ? s.attribs[t] : null;
                if (
                  ((s && n.enabled === i.enabled) ||
                    (n.enabled
                      ? r.enableVertexAttribArray.call(e, t)
                      : r.disableVertexAttribArray.call(e, t)),
                  n.enabled)
                ) {
                  let o = !1;
                  (s && n.buffer === i.buffer) ||
                    (a !== n.buffer &&
                      (r.bindBuffer.call(e, 34962, n.buffer), (a = n.buffer)),
                    (o = !0)),
                    (o || n.cached !== i.cached) &&
                      r.vertexAttribPointer.call(
                        e,
                        t,
                        n.size,
                        n.type,
                        n.normalized,
                        n.stride,
                        n.offset
                      );
                }
              }
              this.currentArrayBuffer !== a &&
                r.bindBuffer.call(e, 34962, this.currentArrayBuffer);
            });
          const k = "OES_element_index",
            j = "WEBGL_draw_buffers",
            F = "WEBGL_debug_renderer_info",
            B = (t) => (S(t) ? void 0 : 0),
            D = {
              3074: (t) => (S(t) ? void 0 : 36064),
              35723: (t) => (S(t) ? void 0 : 4352),
              35977: B,
              32937: B,
              36795: (t, e) => {
                const n = S(t)
                  ? t.getExtension("EXT_disjoint_timer_query_webgl2")
                  : t.getExtension("EXT_disjoint_timer_query");
                return n && n.GPU_DISJOINT_EXT ? e(n.GPU_DISJOINT_EXT) : 0;
              },
              37445: (t, e) => {
                const n = t.getExtension(F);
                return e((n && n.UNMASKED_VENDOR_WEBGL) || 7936);
              },
              37446: (t, e) => {
                const n = t.getExtension(F);
                return e((n && n.UNMASKED_RENDERER_WEBGL) || 7937);
              },
              34047: (t, e) => {
                const n = t.luma.extensions.EXT_texture_filter_anisotropic;
                return n ? e(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
              },
              32883: B,
              35071: B,
              37447: B,
              36063: (t, e) => {
                if (!S(t)) {
                  const n = t.getExtension(j);
                  return n ? e(n.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
                }
              },
              35379: B,
              35374: B,
              35377: B,
              34852: (t) => {
                if (!S(t)) {
                  const e = t.getExtension(j);
                  return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0;
                }
              },
              36203: (t) => (t.getExtension(k) ? 2147483647 : 65535),
              33001: (t) => (t.getExtension(k) ? 16777216 : 65535),
              33e3: (t) => 16777216,
              37157: B,
              35373: B,
              35657: B,
              36183: B,
              37137: B,
              34045: B,
              35978: B,
              35979: B,
              35968: B,
              35376: B,
              35375: B,
              35659: B,
              37154: B,
              35371: B,
              35658: B,
              35076: B,
              35077: B,
              35380: B,
            },
            N = "ANGLE_instanced_arrays",
            z = {
              OES_vertex_array_object: {
                meta: { suffix: "OES" },
                createVertexArray: () => {
                  T(
                    !1,
                    "VertexArray requires WebGL2 or OES_vertex_array_object extension"
                  );
                },
                deleteVertexArray: () => {},
                bindVertexArray: () => {},
                isVertexArray: () => !1,
              },
              [N]: {
                meta: { suffix: "ANGLE" },
                vertexAttribDivisor(t, e) {
                  T(0 === e, "WebGL instanced rendering not supported");
                },
                drawElementsInstanced: () => {},
                drawArraysInstanced: () => {},
              },
              WEBGL_draw_buffers: {
                meta: { suffix: "WEBGL" },
                drawBuffers: () => {
                  T(!1);
                },
              },
              EXT_disjoint_timer_query: {
                meta: { suffix: "EXT" },
                createQuery: () => {
                  T(!1);
                },
                deleteQuery: () => {
                  T(!1);
                },
                beginQuery: () => {
                  T(!1);
                },
                endQuery: () => {},
                getQuery(t, e) {
                  return this.getQueryObject(t, e);
                },
                getQueryParameter(t, e) {
                  return this.getQueryObject(t, e);
                },
                getQueryObject: () => {},
              },
            },
            V = {
              readBuffer: (t, e, n) => {
                S(t) && e(n);
              },
              getVertexAttrib: (t, e, n, i) => {
                const { webgl2: r, ext: s } = (function (t, e) {
                  return {
                    webgl2: S(t),
                    ext: t.getExtension("ANGLE_instanced_arrays"),
                  };
                })(t);
                let o;
                switch (i) {
                  case 35069:
                    o = !!r && void 0;
                    break;
                  case 35070:
                    o = r || s ? void 0 : 0;
                }
                return void 0 !== o ? o : e(n, i);
              },
              getProgramParameter: (t, e, n, i) => {
                if (!S(t))
                  switch (i) {
                    case 35967:
                      return 35981;
                    case 35971:
                    case 35382:
                      return 0;
                  }
                return e(n, i);
              },
              getInternalformatParameter: (t, e, n, i, r) =>
                S(t) || 32937 !== r
                  ? t.getInternalformatParameter(n, i, r)
                  : new Int32Array([0]),
              getTexParameter(t, e, n, i) {
                if (34046 === i) {
                  const { extensions: e } = t.luma,
                    n = e.EXT_texture_filter_anisotropic;
                  i = (n && n.TEXTURE_MAX_ANISOTROPY_EXT) || 34046;
                }
                return e(n, i);
              },
              getParameter: function (t, e, n) {
                const i = D[n],
                  r = "function" == typeof i ? i(t, e, n) : i;
                return void 0 !== r ? r : e(n);
              },
              hint: (t, e, n, i) => e(n, i),
            };
          function U(t, { extension: e, target: n, target2: i }) {
            const r = z[e];
            T(r);
            const { meta: s = {} } = r,
              { suffix: o = "" } = s,
              a = t.getExtension(e);
            for (const e of Object.keys(r)) {
              const s = `${e}${o}`;
              let c = null;
              "meta" === e ||
                "function" == typeof t[e] ||
                (a && "function" == typeof a[s]
                  ? (c = (...t) => a[s](...t))
                  : "function" == typeof r[e] && (c = r[e].bind(n))),
                c && ((n[e] = c), (i[e] = c));
            }
          }
          (void 0 !== n.g ? n.g : window).polyfillContext = function (t) {
            t.luma = t.luma || {};
            const { luma: e } = t;
            return (
              e.polyfilled ||
                ((function (t) {
                  if ("function" == typeof t.createVertexArray) return;
                  const e = t.getSupportedExtensions;
                  t.getSupportedExtensions = function () {
                    const t = e.call(this) || [];
                    return (
                      t.indexOf("OES_vertex_array_object") < 0 &&
                        t.push("OES_vertex_array_object"),
                      t
                    );
                  };
                  const n = t.getExtension;
                  t.getExtension = function (e) {
                    return (
                      n.call(this, e) ||
                      ("OES_vertex_array_object" !== e
                        ? null
                        : (t.__OESVertexArrayObject ||
                            (this.__OESVertexArrayObject = new R(this)),
                          this.__OESVertexArrayObject))
                    );
                  };
                })(t),
                (function (t) {
                  t.luma.extensions = {};
                  const e = t.getSupportedExtensions() || [];
                  for (const n of e) t.luma[n] = t.getExtension(n);
                })(t),
                (function (t, e) {
                  for (const n of Object.getOwnPropertyNames(e))
                    "overrides" !== n &&
                      U(t, { extension: n, target: t.luma, target2: t });
                })(t, z),
                (function (t, { target: e, target2: n }) {
                  Object.keys(V).forEach((i) => {
                    if ("function" == typeof V[i]) {
                      const r = t[i] ? t[i].bind(t) : () => {},
                        s = V[i].bind(null, t, r);
                      (e[i] = s), (n[i] = s);
                    }
                  });
                })(t, { target: e, target2: t }),
                (e.polyfilled = !0)),
              t
            );
          };
          const G = {
              3042: !1,
              32773: new Float32Array([0, 0, 0, 0]),
              32777: 32774,
              34877: 32774,
              32969: 1,
              32968: 0,
              32971: 1,
              32970: 0,
              3106: new Float32Array([0, 0, 0, 0]),
              3107: [!0, !0, !0, !0],
              2884: !1,
              2885: 1029,
              2929: !1,
              2931: 1,
              2932: 513,
              2928: new Float32Array([0, 1]),
              2930: !0,
              3024: !0,
              36006: null,
              2886: 2305,
              33170: 4352,
              2849: 1,
              32823: !1,
              32824: 0,
              10752: 0,
              32938: 1,
              32939: !1,
              3089: !1,
              3088: new Int32Array([0, 0, 1024, 1024]),
              2960: !1,
              2961: 0,
              2968: 4294967295,
              36005: 4294967295,
              2962: 519,
              2967: 0,
              2963: 4294967295,
              34816: 519,
              36003: 0,
              36004: 4294967295,
              2964: 7680,
              2965: 7680,
              2966: 7680,
              34817: 7680,
              34818: 7680,
              34819: 7680,
              2978: [0, 0, 1024, 1024],
              3333: 4,
              3317: 4,
              37440: !1,
              37441: !1,
              37443: 37444,
              35723: 4352,
              36010: null,
              35977: !1,
              3330: 0,
              3332: 0,
              3331: 0,
              3314: 0,
              32878: 0,
              3316: 0,
              3315: 0,
              32877: 0,
            },
            $ = (t, e, n) => (e ? t.enable(n) : t.disable(n)),
            W = (t, e, n) => t.hint(n, e),
            H = (t, e, n) => t.pixelStorei(n, e);
          function X(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t);
          }
          const q = {
            3042: $,
            32773: (t, e) => t.blendColor(...e),
            32777: "blendEquation",
            34877: "blendEquation",
            32969: "blendFunc",
            32968: "blendFunc",
            32971: "blendFunc",
            32970: "blendFunc",
            3106: (t, e) => t.clearColor(...e),
            3107: (t, e) => t.colorMask(...e),
            2884: $,
            2885: (t, e) => t.cullFace(e),
            2929: $,
            2931: (t, e) => t.clearDepth(e),
            2932: (t, e) => t.depthFunc(e),
            2928: (t, e) => t.depthRange(...e),
            2930: (t, e) => t.depthMask(e),
            3024: $,
            35723: W,
            36006: (t, e) => {
              const n = S(t) ? 36009 : 36160;
              return t.bindFramebuffer(n, e);
            },
            2886: (t, e) => t.frontFace(e),
            33170: W,
            2849: (t, e) => t.lineWidth(e),
            32823: $,
            32824: "polygonOffset",
            10752: "polygonOffset",
            35977: $,
            32938: "sampleCoverage",
            32939: "sampleCoverage",
            3089: $,
            3088: (t, e) => t.scissor(...e),
            2960: $,
            2961: (t, e) => t.clearStencil(e),
            2968: (t, e) => t.stencilMaskSeparate(1028, e),
            36005: (t, e) => t.stencilMaskSeparate(1029, e),
            2962: "stencilFuncFront",
            2967: "stencilFuncFront",
            2963: "stencilFuncFront",
            34816: "stencilFuncBack",
            36003: "stencilFuncBack",
            36004: "stencilFuncBack",
            2964: "stencilOpFront",
            2965: "stencilOpFront",
            2966: "stencilOpFront",
            34817: "stencilOpBack",
            34818: "stencilOpBack",
            34819: "stencilOpBack",
            2978: (t, e) => t.viewport(...e),
            3333: H,
            3317: H,
            37440: H,
            37441: H,
            37443: H,
            3330: H,
            3332: H,
            3331: H,
            36010: (t, e) => t.bindFramebuffer(36008, e),
            3314: H,
            32878: H,
            3316: H,
            3315: H,
            32877: H,
            framebuffer: (t, e) => {
              const n = e && "handle" in e ? e.handle : e;
              return t.bindFramebuffer(36160, n);
            },
            blend: (t, e) => (e ? t.enable(3042) : t.disable(3042)),
            blendColor: (t, e) => t.blendColor(...e),
            blendEquation: (t, e) => {
              (e = X(e) ? e : [e, e]), t.blendEquationSeparate(...e);
            },
            blendFunc: (t, e) => {
              (e = X(e) && 2 === e.length ? [...e, ...e] : e),
                t.blendFuncSeparate(...e);
            },
            clearColor: (t, e) => t.clearColor(...e),
            clearDepth: (t, e) => t.clearDepth(e),
            clearStencil: (t, e) => t.clearStencil(e),
            colorMask: (t, e) => t.colorMask(...e),
            cull: (t, e) => (e ? t.enable(2884) : t.disable(2884)),
            cullFace: (t, e) => t.cullFace(e),
            depthTest: (t, e) => (e ? t.enable(2929) : t.disable(2929)),
            depthFunc: (t, e) => t.depthFunc(e),
            depthMask: (t, e) => t.depthMask(e),
            depthRange: (t, e) => t.depthRange(...e),
            dither: (t, e) => (e ? t.enable(3024) : t.disable(3024)),
            derivativeHint: (t, e) => {
              t.hint(35723, e);
            },
            frontFace: (t, e) => t.frontFace(e),
            mipmapHint: (t, e) => t.hint(33170, e),
            lineWidth: (t, e) => t.lineWidth(e),
            polygonOffsetFill: (t, e) =>
              e ? t.enable(32823) : t.disable(32823),
            polygonOffset: (t, e) => t.polygonOffset(...e),
            sampleCoverage: (t, e) => t.sampleCoverage(...e),
            scissorTest: (t, e) => (e ? t.enable(3089) : t.disable(3089)),
            scissor: (t, e) => t.scissor(...e),
            stencilTest: (t, e) => (e ? t.enable(2960) : t.disable(2960)),
            stencilMask: (t, e) => {
              e = X(e) ? e : [e, e];
              const [n, i] = e;
              t.stencilMaskSeparate(1028, n), t.stencilMaskSeparate(1029, i);
            },
            stencilFunc: (t, e) => {
              e = X(e) && 3 === e.length ? [...e, ...e] : e;
              const [n, i, r, s, o, a] = e;
              t.stencilFuncSeparate(1028, n, i, r),
                t.stencilFuncSeparate(1029, s, o, a);
            },
            stencilOp: (t, e) => {
              e = X(e) && 3 === e.length ? [...e, ...e] : e;
              const [n, i, r, s, o, a] = e;
              t.stencilOpSeparate(1028, n, i, r),
                t.stencilOpSeparate(1029, s, o, a);
            },
            viewport: (t, e) => t.viewport(...e),
          };
          function Y(t, e, n) {
            return void 0 !== e[t] ? e[t] : n[t];
          }
          const Z = {
              blendEquation: (t, e, n) =>
                t.blendEquationSeparate(Y(32777, e, n), Y(34877, e, n)),
              blendFunc: (t, e, n) =>
                t.blendFuncSeparate(
                  Y(32969, e, n),
                  Y(32968, e, n),
                  Y(32971, e, n),
                  Y(32970, e, n)
                ),
              polygonOffset: (t, e, n) =>
                t.polygonOffset(Y(32824, e, n), Y(10752, e, n)),
              sampleCoverage: (t, e, n) =>
                t.sampleCoverage(Y(32938, e, n), Y(32939, e, n)),
              stencilFuncFront: (t, e, n) =>
                t.stencilFuncSeparate(
                  1028,
                  Y(2962, e, n),
                  Y(2967, e, n),
                  Y(2963, e, n)
                ),
              stencilFuncBack: (t, e, n) =>
                t.stencilFuncSeparate(
                  1029,
                  Y(34816, e, n),
                  Y(36003, e, n),
                  Y(36004, e, n)
                ),
              stencilOpFront: (t, e, n) =>
                t.stencilOpSeparate(
                  1028,
                  Y(2964, e, n),
                  Y(2965, e, n),
                  Y(2966, e, n)
                ),
              stencilOpBack: (t, e, n) =>
                t.stencilOpSeparate(
                  1029,
                  Y(34817, e, n),
                  Y(34818, e, n),
                  Y(34819, e, n)
                ),
            },
            K = {
              enable: (t, e) => t({ [e]: !0 }),
              disable: (t, e) => t({ [e]: !1 }),
              pixelStorei: (t, e, n) => t({ [e]: n }),
              hint: (t, e, n) => t({ [e]: n }),
              bindFramebuffer: (t, e, n) => {
                switch (e) {
                  case 36160:
                    return t({ 36006: n, 36010: n });
                  case 36009:
                    return t({ 36006: n });
                  case 36008:
                    return t({ 36010: n });
                  default:
                    return null;
                }
              },
              blendColor: (t, e, n, i, r) =>
                t({ 32773: new Float32Array([e, n, i, r]) }),
              blendEquation: (t, e) => t({ 32777: e, 34877: e }),
              blendEquationSeparate: (t, e, n) => t({ 32777: e, 34877: n }),
              blendFunc: (t, e, n) =>
                t({ 32969: e, 32968: n, 32971: e, 32970: n }),
              blendFuncSeparate: (t, e, n, i, r) =>
                t({ 32969: e, 32968: n, 32971: i, 32970: r }),
              clearColor: (t, e, n, i, r) =>
                t({ 3106: new Float32Array([e, n, i, r]) }),
              clearDepth: (t, e) => t({ 2931: e }),
              clearStencil: (t, e) => t({ 2961: e }),
              colorMask: (t, e, n, i, r) => t({ 3107: [e, n, i, r] }),
              cullFace: (t, e) => t({ 2885: e }),
              depthFunc: (t, e) => t({ 2932: e }),
              depthRange: (t, e, n) => t({ 2928: new Float32Array([e, n]) }),
              depthMask: (t, e) => t({ 2930: e }),
              frontFace: (t, e) => t({ 2886: e }),
              lineWidth: (t, e) => t({ 2849: e }),
              polygonOffset: (t, e, n) => t({ 32824: e, 10752: n }),
              sampleCoverage: (t, e, n) => t({ 32938: e, 32939: n }),
              scissor: (t, e, n, i, r) =>
                t({ 3088: new Int32Array([e, n, i, r]) }),
              stencilMask: (t, e) => t({ 2968: e, 36005: e }),
              stencilMaskSeparate: (t, e, n) =>
                t({ [1028 === e ? 2968 : 36005]: n }),
              stencilFunc: (t, e, n, i) =>
                t({ 2962: e, 2967: n, 2963: i, 34816: e, 36003: n, 36004: i }),
              stencilFuncSeparate: (t, e, n, i, r) =>
                t({
                  [1028 === e ? 2962 : 34816]: n,
                  [1028 === e ? 2967 : 36003]: i,
                  [1028 === e ? 2963 : 36004]: r,
                }),
              stencilOp: (t, e, n, i) =>
                t({ 2964: e, 2965: n, 2966: i, 34817: e, 34818: n, 34819: i }),
              stencilOpSeparate: (t, e, n, i, r) =>
                t({
                  [1028 === e ? 2964 : 34817]: n,
                  [1028 === e ? 2965 : 34818]: i,
                  [1028 === e ? 2966 : 34819]: r,
                }),
              viewport: (t, e, n, i, r) => t({ 2978: [e, n, i, r] }),
            },
            Q = (t, e) => t.isEnabled(e),
            J = {
              3042: Q,
              2884: Q,
              2929: Q,
              3024: Q,
              32823: Q,
              32926: Q,
              32928: Q,
              3089: Q,
              2960: Q,
              35977: Q,
            };
          function tt(t) {
            for (const e in t) return !1;
            return !0;
          }
          function et(t, e) {
            if (t === e) return !0;
            const n = Array.isArray(t) || ArrayBuffer.isView(t),
              i = Array.isArray(e) || ArrayBuffer.isView(e);
            if (n && i && t.length === e.length) {
              for (let n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;
              return !0;
            }
            return !1;
          }
          function nt(t, e) {
            const n = t[e].bind(t);
            (t[e] = function (...e) {
              const i = e[0];
              return i in t.state.cache && t.state.enable
                ? t.state.cache[i]
                : n(...e);
            }),
              Object.defineProperty(t[e], "name", {
                value: `${e}-from-cache`,
                configurable: !1,
              });
          }
          function it(t, e, n) {
            const i = t[e].bind(t);
            (t[e] = function (...e) {
              const { valueChanged: r, oldValue: s } = n(
                t.state._updateCache,
                ...e
              );
              return r && i(...e), s;
            }),
              Object.defineProperty(t[e], "name", {
                value: `${e}-to-cache`,
                configurable: !1,
              });
          }
          class rt {
            constructor(t, { copyState: e = !1, log: n = () => {} } = {}) {
              (this.gl = t),
                (this.program = null),
                (this.stateStack = []),
                (this.enable = !0),
                (this.cache = e ? ct(t) : Object.assign({}, G)),
                (this.log = n),
                (this._updateCache = this._updateCache.bind(this)),
                Object.seal(this);
            }
            push(t = {}) {
              this.stateStack.push({});
            }
            pop() {
              T(this.stateStack.length > 0);
              const t = this.stateStack[this.stateStack.length - 1];
              at(this.gl, t), this.stateStack.pop();
            }
            _updateCache(t) {
              let e,
                n = !1;
              const i =
                this.stateStack.length > 0 &&
                this.stateStack[this.stateStack.length - 1];
              for (const r in t) {
                T(void 0 !== r);
                const s = t[r],
                  o = this.cache[r];
                et(s, o) ||
                  ((n = !0),
                  (e = o),
                  i && !(r in i) && (i[r] = o),
                  (this.cache[r] = s));
              }
              return { valueChanged: n, oldValue: e };
            }
          }
          function st(t, e = {}) {
            const { enable: i = !0, copyState: r } = e;
            if ((T(void 0 !== r), !t.state)) {
              const e = void 0 !== n.g ? n.g : window,
                { polyfillContext: i } = e;
              i && i(t),
                (t.state = new rt(t, { copyState: r })),
                (function (t) {
                  const e = t.useProgram.bind(t);
                  t.useProgram = function (n) {
                    t.state.program !== n && (e(n), (t.state.program = n));
                  };
                })(t);
              for (const e in K) it(t, e, K[e]);
              nt(t, "getParameter"), nt(t, "isEnabled");
            }
            return (t.state.enable = i), t;
          }
          function ot(t) {
            T(t.state), t.state.pop();
          }
          function at(t, e) {
            if ((T(A(t), "setParameters requires a WebGL context"), tt(e)))
              return;
            const n = {};
            for (const i in e) {
              const r = Number(i),
                s = q[i];
              s && ("string" == typeof s ? (n[s] = !0) : s(t, e[i], r));
            }
            const i = t.state && t.state.cache;
            if (i) for (const r in n) (0, Z[r])(t, e, i);
          }
          function ct(t, e) {
            if ("number" == typeof (e = e || G)) {
              const n = e,
                i = J[n];
              return i ? i(t, n) : t.getParameter(n);
            }
            const n = Array.isArray(e) ? e : Object.keys(e),
              i = {};
            for (const e of n) {
              const n = J[e];
              i[e] = n ? n(t, Number(e)) : t.getParameter(Number(e));
            }
            return i;
          }
          function ht(t, e, n) {
            if (tt(e)) return n(t);
            const { nocatch: i = !0 } = e;
            let r;
            if (
              ((function (t) {
                t.state || st(t, { copyState: !1 }), t.state.push();
              })(t),
              at(t, e),
              i)
            )
              (r = n(t)), ot(t);
            else
              try {
                r = n(t);
              } finally {
                ot(t);
              }
            return r;
          }
          function lt(t) {
            const { luma: e } = t;
            if (t.canvas && e) {
              const { clientWidth: n } = e.canvasSizeInfo;
              return n ? t.drawingBufferWidth / n : 1;
            }
            return 1;
          }
          function ut(t, e, n = !0) {
            return (function (t, e, n, i, r) {
              const s = dt(t[0], e, n);
              let o = ft(t[1], e, i, r),
                a = dt(t[0] + 1, e, n);
              const c = a === n - 1 ? a : a - 1;
              let h;
              return (
                (a = ft(t[1] + 1, e, i, r)),
                r
                  ? ((a = 0 === a ? a : a + 1), (h = o), (o = a))
                  : (h = a === i - 1 ? a : a - 1),
                {
                  x: s,
                  y: o,
                  width: Math.max(c - s + 1, 1),
                  height: Math.max(h - o + 1, 1),
                }
              );
            })(e, lt(t), t.drawingBufferWidth, t.drawingBufferHeight, n);
          }
          function dt(t, e, n) {
            return Math.min(Math.round(t * e), n - 1);
          }
          function ft(t, e, n, i) {
            return i
              ? Math.max(0, n - 1 - Math.round(t * e))
              : Math.min(Math.round(t * e), n - 1);
          }
          const pt = (0, O.jU)(),
            gt = pt && "undefined" != typeof document,
            mt = {
              webgl2: !0,
              webgl1: !0,
              throwOnError: !0,
              manageState: !0,
              canvas: null,
              debug: !1,
              width: 800,
              height: 600,
            };
          function bt(t = {}) {
            T(
              pt,
              "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"
            ),
              (t = Object.assign({}, mt, t));
            const { width: e, height: n } = t;
            function i(e) {
              if (t.throwOnError) throw new Error(e);
              return console.error(e), null;
            }
            let r;
            t.onError = i;
            const { canvas: s } = t,
              o = (function ({
                canvas: t,
                width: e = 800,
                height: n = 600,
                onError: i,
              }) {
                let r;
                return (
                  "string" == typeof t
                    ? ((gt && "complete" === document.readyState) ||
                        i(
                          `createGLContext called on canvas '${t}' before page was loaded`
                        ),
                      (r = document.getElementById(t)))
                    : t
                    ? (r = t)
                    : ((r = document.createElement("canvas")),
                      (r.id = "lumagl-canvas"),
                      (r.style.width = Number.isFinite(e) ? `${e}px` : "100%"),
                      (r.style.height = Number.isFinite(n) ? `${n}px` : "100%"),
                      document.body.insertBefore(r, document.body.firstChild)),
                  r
                );
              })({ canvas: s, width: e, height: n, onError: i });
            return (
              (r = (function (t, e) {
                const { onError: n } = e;
                let i = null;
                const r = (t) => (i = t.statusMessage || i);
                t.addEventListener("webglcontextcreationerror", r, !1);
                const { webgl1: s = !0, webgl2: o = !0 } = e;
                let a = null;
                return (
                  o &&
                    ((a = a || t.getContext("webgl2", e)),
                    (a = a || t.getContext("experimental-webgl2", e))),
                  s &&
                    ((a = a || t.getContext("webgl", e)),
                    (a = a || t.getContext("experimental-webgl", e))),
                  t.removeEventListener("webglcontextcreationerror", r, !1),
                  a
                    ? (e.onContextLost &&
                        t.addEventListener(
                          "webglcontextlost",
                          e.onContextLost,
                          !1
                        ),
                      e.onContextRestored &&
                        t.addEventListener(
                          "webglcontextrestored",
                          e.onContextRestored,
                          !1
                        ),
                      a)
                    : n(
                        `Failed to create ${
                          o && !s ? "WebGL2" : "WebGL"
                        } context: ${i || "Unknown error"}`
                      )
                );
              })(o, t)),
              r
                ? ((r = _t(r, t)),
                  (function (t) {
                    const e = S(t) ? "WebGL2" : "WebGL1",
                      n = (function (t) {
                        const e = t.getParameter(7936),
                          n = t.getParameter(7937),
                          i = t.getExtension("WEBGL_debug_renderer_info");
                        return {
                          vendor:
                            (i &&
                              t.getParameter(
                                i.UNMASKED_VENDOR_WEBGL || 7936
                              )) ||
                            e,
                          renderer:
                            (i &&
                              t.getParameter(
                                i.UNMASKED_RENDERER_WEBGL || 7937
                              )) ||
                            n,
                          vendorMasked: e,
                          rendererMasked: n,
                          version: t.getParameter(7938),
                          shadingLanguageVersion: t.getParameter(35724),
                        };
                      })(t),
                      i = n ? `(${n.vendor},${n.renderer})` : "",
                      r = t.debug ? " debug" : "";
                    P.info(1, `${e}${r} context ${i}`)();
                  })(r),
                  r)
                : null
            );
          }
          function _t(t, e = {}) {
            if (!t || t._instrumented) return t;
            (t._version =
              t._version ||
              (function (t) {
                return "undefined" != typeof WebGL2RenderingContext &&
                  t instanceof WebGL2RenderingContext
                  ? 2
                  : 1;
              })(t)),
              (t.luma = t.luma || {}),
              (t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {}),
              (e = Object.assign({}, mt, e));
            const { manageState: n, debug: i } = e;
            return (
              n && st(t, { copyState: !1, log: (...t) => P.log(1, ...t)() }),
              pt &&
                i &&
                (O.CO.makeDebugContext
                  ? ((t = O.CO.makeDebugContext(t, e)),
                    (P.level = Math.max(P.level, 1)))
                  : P.warn(
                      'WebGL debug mode not activated. import "@luma.gl/debug" to enable.'
                    )()),
              (t._instrumented = !0),
              t
            );
          }
          let yt = 1,
            vt = 1;
          class wt {
            constructor() {
              (this.time = 0),
                (this.channels = new Map()),
                (this.animations = new Map()),
                (this.playing = !1),
                (this.lastEngineTime = -1);
            }
            addChannel(t) {
              const {
                  delay: e = 0,
                  duration: n = Number.POSITIVE_INFINITY,
                  rate: i = 1,
                  repeat: r = 1,
                } = t,
                s = yt++,
                o = { time: 0, delay: e, duration: n, rate: i, repeat: r };
              return (
                this._setChannelTime(o, this.time), this.channels.set(s, o), s
              );
            }
            removeChannel(t) {
              this.channels.delete(t);
              for (const [e, n] of this.animations)
                n.channel === t && this.detachAnimation(e);
            }
            isFinished(t) {
              const e = this.channels.get(t);
              return (
                void 0 !== e && this.time >= e.delay + e.duration * e.repeat
              );
            }
            getTime(t) {
              if (void 0 === t) return this.time;
              const e = this.channels.get(t);
              return void 0 === e ? -1 : e.time;
            }
            setTime(t) {
              this.time = Math.max(0, t);
              const e = this.channels.values();
              for (const t of e) this._setChannelTime(t, this.time);
              const n = this.animations.values();
              for (const t of n) {
                const { animation: e, channel: n } = t;
                e.setTime(this.getTime(n));
              }
            }
            play() {
              this.playing = !0;
            }
            pause() {
              (this.playing = !1), (this.lastEngineTime = -1);
            }
            reset() {
              this.setTime(0);
            }
            attachAnimation(t, e) {
              const n = vt++;
              return (
                this.animations.set(n, { animation: t, channel: e }),
                t.setTime(this.getTime(e)),
                n
              );
            }
            detachAnimation(t) {
              this.animations.delete(t);
            }
            update(t) {
              this.playing &&
                (-1 === this.lastEngineTime && (this.lastEngineTime = t),
                this.setTime(this.time + (t - this.lastEngineTime)),
                (this.lastEngineTime = t));
            }
            _setChannelTime(t, e) {
              const n = e - t.delay;
              n >= t.duration * t.repeat
                ? (t.time = t.duration * t.rate)
                : ((t.time = Math.max(0, n) % t.duration), (t.time *= t.rate));
            }
          }
          const xt = {
              COMPONENT: Symbol.for("component"),
              ASYNC_DEFAULTS: Symbol.for("asyncPropDefaults"),
              ASYNC_ORIGINAL: Symbol.for("asyncPropOriginal"),
              ASYNC_RESOLVED: Symbol.for("asyncPropResolved"),
            },
            Et = new w({ id: "deck" });
          let Pt = {};
          function Tt(t) {
            Et.level > 0 && Pt[t] && Pt[t].call(...arguments);
          }
          function At(t, e = () => !0) {
            return Array.isArray(t) ? St(t, e, []) : e(t) ? [t] : [];
          }
          function St(t, e, n) {
            let i = -1;
            for (; ++i < t.length; ) {
              const r = t[i];
              Array.isArray(r) ? St(r, e, n) : e(r) && n.push(r);
            }
            return n;
          }
          function Mt({ target: t, source: e, start: n = 0, count: i = 1 }) {
            const r = e.length,
              s = i * r;
            let o = 0;
            for (let i = n; o < r; o++) t[i++] = e[o];
            for (; o < s; )
              o < s - o
                ? (t.copyWithin(n + o, n, n + o), (o *= 2))
                : (t.copyWithin(n + o, n, n + s - o), (o = s));
            return t;
          }
          function Ct() {
            let t;
            if ("undefined" != typeof window && window.performance)
              t = window.performance.now();
            else if ("undefined" != typeof process && process.hrtime) {
              const e = process.hrtime();
              t = 1e3 * e[0] + e[1] / 1e6;
            } else t = Date.now();
            return t;
          }
          class Ot {
            constructor(t, e) {
              (this.name = t),
                (this.type = e),
                (this.sampleSize = 1),
                this.reset();
            }
            setSampleSize(t) {
              return (this.sampleSize = t), this;
            }
            incrementCount() {
              return this.addCount(1), this;
            }
            decrementCount() {
              return this.subtractCount(1), this;
            }
            addCount(t) {
              return (
                (this._count += t), this._samples++, this._checkSampling(), this
              );
            }
            subtractCount(t) {
              return (
                (this._count -= t), this._samples++, this._checkSampling(), this
              );
            }
            addTime(t) {
              return (
                (this._time += t),
                (this.lastTiming = t),
                this._samples++,
                this._checkSampling(),
                this
              );
            }
            timeStart() {
              return (this._startTime = Ct()), (this._timerPending = !0), this;
            }
            timeEnd() {
              return this._timerPending
                ? (this.addTime(Ct() - this._startTime),
                  (this._timerPending = !1),
                  this._checkSampling(),
                  this)
                : this;
            }
            getSampleAverageCount() {
              return this.sampleSize > 0
                ? this.lastSampleCount / this.sampleSize
                : 0;
            }
            getSampleAverageTime() {
              return this.sampleSize > 0
                ? this.lastSampleTime / this.sampleSize
                : 0;
            }
            getSampleHz() {
              return this.lastSampleTime > 0
                ? this.sampleSize / (this.lastSampleTime / 1e3)
                : 0;
            }
            getAverageCount() {
              return this.samples > 0 ? this.count / this.samples : 0;
            }
            getAverageTime() {
              return this.samples > 0 ? this.time / this.samples : 0;
            }
            getHz() {
              return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
            }
            reset() {
              return (
                (this.time = 0),
                (this.count = 0),
                (this.samples = 0),
                (this.lastTiming = 0),
                (this.lastSampleTime = 0),
                (this.lastSampleCount = 0),
                (this._count = 0),
                (this._time = 0),
                (this._samples = 0),
                (this._startTime = 0),
                (this._timerPending = !1),
                this
              );
            }
            _checkSampling() {
              this._samples === this.sampleSize &&
                ((this.lastSampleTime = this._time),
                (this.lastSampleCount = this._count),
                (this.count += this._count),
                (this.time += this._time),
                (this.samples += this._samples),
                (this._time = 0),
                (this._count = 0),
                (this._samples = 0));
            }
          }
          class Lt {
            constructor({ id: t, stats: e }) {
              (this.id = t),
                (this.stats = {}),
                this._initializeStats(e),
                Object.seal(this);
            }
            get(t, e = "count") {
              return this._getOrCreate({ name: t, type: e });
            }
            get size() {
              return Object.keys(this.stats).length;
            }
            reset() {
              for (const t in this.stats) this.stats[t].reset();
              return this;
            }
            forEach(t) {
              for (const e in this.stats) t(this.stats[e]);
            }
            getTable() {
              const t = {};
              return (
                this.forEach((e) => {
                  t[e.name] = {
                    time: e.time || 0,
                    count: e.count || 0,
                    average: e.getAverageTime() || 0,
                    hz: e.getHz() || 0,
                  };
                }),
                t
              );
            }
            _initializeStats(t = []) {
              t.forEach((t) => this._getOrCreate(t));
            }
            _getOrCreate(t) {
              if (!t || !t.name) return null;
              const { name: e, type: n } = t;
              return (
                this.stats[e] ||
                  (this.stats[e] = t instanceof Ot ? t : new Ot(e, n)),
                this.stats[e]
              );
            }
          }
          const It = (t) => "function" == typeof t,
            Rt = (t) => null !== t && "object" == typeof t,
            kt = (t) => Rt(t) && t.constructor === {}.constructor,
            jt = (t) =>
              ("undefined" != typeof Response && t instanceof Response) ||
              (t && t.arrayBuffer && t.text && t.json),
            Ft = (t) => "undefined" != typeof Blob && t instanceof Blob,
            Bt = (t) =>
              ((t) =>
                ("undefined" != typeof ReadableStream &&
                  t instanceof ReadableStream) ||
                (Rt(t) && It(t.tee) && It(t.cancel) && It(t.getReader)))(t) ||
              ((t) =>
                Rt(t) &&
                It(t.read) &&
                It(t.pipe) &&
                ((t) => "boolean" == typeof t)(t.readable))(t);
          function Dt(t, e) {
            if (!t) throw new Error(e || "loader assertion failed.");
          }
          function Nt(t) {
            var e;
            return (
              !!t &&
              (Array.isArray(t) && (t = t[0]),
              Array.isArray(
                null === (e = t) || void 0 === e ? void 0 : e.extensions
              ))
            );
          }
          function zt(t) {
            var e, n;
            let i;
            return (
              Dt(t, "null loader"),
              Dt(Nt(t), "invalid loader"),
              Array.isArray(t) &&
                ((i = t[1]),
                (t = t[0]),
                (t = { ...t, options: { ...t.options, ...i } })),
              ((null !== (e = t) && void 0 !== e && e.parseTextSync) ||
                (null !== (n = t) && void 0 !== n && n.parseText)) &&
                (t.text = !0),
              t.text || (t.binary = !0),
              t
            );
          }
          const Vt = {
              self: "undefined" != typeof self && self,
              window: "undefined" != typeof window && window,
              global: void 0 !== n.g && n.g,
              document: "undefined" != typeof document && document,
            },
            Ut = Vt.global || Vt.self || Vt.window || {},
            Gt =
              "object" != typeof process ||
              "[object process]" !== String(process) ||
              process.browser,
            $t =
              "undefined" != typeof process &&
              process.version &&
              /v([0-9]*)/.exec(process.version);
          $t && parseFloat($t[1]);
          const Wt = {},
            Ht = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
            Xt = /^([-\w.]+\/[-\w.+]+)/;
          function qt(t) {
            const e = Xt.exec(t);
            return e ? e[1] : t;
          }
          function Yt(t) {
            const e = Ht.exec(t);
            return e ? e[1] : "";
          }
          const Zt = /\?.*/;
          function Kt(t) {
            if (jt(t)) {
              const e = Qt(t.url || "");
              return {
                url: e,
                type: qt(t.headers.get("content-type") || "") || Yt(e),
              };
            }
            return Ft(t)
              ? { url: Qt(t.name || ""), type: t.type || "" }
              : "string" == typeof t
              ? { url: Qt(t), type: Yt(t) }
              : { url: "", type: "" };
          }
          function Qt(t) {
            return t.replace(Zt, "");
          }
          async function Jt(t) {
            if (jt(t)) return t;
            const e = {},
              n = (function (t) {
                return jt(t)
                  ? t.headers["content-length"] || -1
                  : Ft(t)
                  ? t.size
                  : "string" == typeof t
                  ? t.length
                  : t instanceof ArrayBuffer || ArrayBuffer.isView(t)
                  ? t.byteLength
                  : -1;
              })(t);
            n >= 0 && (e["content-length"] = String(n));
            const { url: i, type: r } = Kt(t);
            r && (e["content-type"] = r);
            const s = await (async function (t) {
              if ("string" == typeof t) return `data:,${t.slice(0, 5)}`;
              if (t instanceof Blob) {
                const e = t.slice(0, 5);
                return await new Promise((t) => {
                  const n = new FileReader();
                  (n.onload = (e) => {
                    var n;
                    return t(
                      null == e || null === (n = e.target) || void 0 === n
                        ? void 0
                        : n.result
                    );
                  }),
                    n.readAsDataURL(e);
                });
              }
              if (t instanceof ArrayBuffer) {
                const e = (function (t) {
                  let e = "";
                  const n = new Uint8Array(t);
                  for (let t = 0; t < n.byteLength; t++)
                    e += String.fromCharCode(n[t]);
                  return btoa(e);
                })(t.slice(0, 5));
                return `data:base64,${e}`;
              }
              return null;
            })(t);
            s && (e["x-first-bytes"] = s),
              "string" == typeof t && (t = new TextEncoder().encode(t));
            const o = new Response(t, { headers: e });
            return Object.defineProperty(o, "url", { value: i }), o;
          }
          async function te(t, e) {
            if ("string" == typeof t) {
              t = (function (t) {
                for (const e in Wt)
                  if (t.startsWith(e)) {
                    const n = Wt[e];
                    t = t.replace(e, n);
                  }
                return (
                  t.startsWith("http://") ||
                    t.startsWith("https://") ||
                    (t = `${t}`),
                  t
                );
              })(t);
              let n = e;
              return (
                null != e &&
                  e.fetch &&
                  "function" != typeof (null == e ? void 0 : e.fetch) &&
                  (n = e.fetch),
                await fetch(t, n)
              );
            }
            return await Jt(t);
          }
          function ee(t, e, n) {
            return (
              e in t
                ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (t[e] = n),
              t
            );
          }
          const ne = new w({ id: "loaders.gl" });
          class ie {
            log() {
              return () => {};
            }
            info() {
              return () => {};
            }
            warn() {
              return () => {};
            }
            error() {
              return () => {};
            }
          }
          const re = {
              fetch: null,
              mimeType: void 0,
              nothrow: !1,
              log: new (class {
                constructor() {
                  ee(this, "console", void 0), (this.console = console);
                }
                log(...t) {
                  return this.console.log.bind(this.console, ...t);
                }
                info(...t) {
                  return this.console.info.bind(this.console, ...t);
                }
                warn(...t) {
                  return this.console.warn.bind(this.console, ...t);
                }
                error(...t) {
                  return this.console.error.bind(this.console, ...t);
                }
              })(),
              CDN: "https://unpkg.com/@loaders.gl",
              worker: !0,
              maxConcurrency: 3,
              maxMobileConcurrency: 1,
              reuseWorkers: !0,
              _workerType: "",
              limit: 0,
              _limitMB: 0,
              batchSize: "auto",
              batchDebounceMs: 0,
              metadata: !1,
              transforms: [],
            },
            se = {
              throws: "nothrow",
              dataType: "(no longer used)",
              uri: "baseUri",
              method: "fetch.method",
              headers: "fetch.headers",
              body: "fetch.body",
              mode: "fetch.mode",
              credentials: "fetch.credentials",
              cache: "fetch.cache",
              redirect: "fetch.redirect",
              referrer: "fetch.referrer",
              referrerPolicy: "fetch.referrerPolicy",
              integrity: "fetch.integrity",
              keepalive: "fetch.keepalive",
              signal: "fetch.signal",
            };
          function oe() {
            Ut.loaders = Ut.loaders || {};
            const { loaders: t } = Ut;
            return (t._state = t._state || {}), t._state;
          }
          const ae = () => {
            const t = oe();
            return (
              (t.globalOptions = t.globalOptions || { ...re }), t.globalOptions
            );
          };
          function ce(t, e, n, i) {
            return (
              (n = n || []),
              (function (t, e) {
                le(t, null, re, se, e);
                for (const n of e) {
                  const i = (t && t[n.id]) || {},
                    r = (n.options && n.options[n.id]) || {},
                    s =
                      (n.deprecatedOptions && n.deprecatedOptions[n.id]) || {};
                  le(i, n.id, r, s, e);
                }
              })(t, (n = Array.isArray(n) ? n : [n])),
              (function (t, e, n) {
                const i = { ...(t.options || {}) };
                return (
                  (function (t, e) {
                    e && !("baseUri" in t) && (t.baseUri = e);
                  })(i, n),
                  null === i.log && (i.log = new ie()),
                  de(i, ae()),
                  de(i, e),
                  i
                );
              })(e, t, i)
            );
          }
          function he(t, e) {
            const n = ae(),
              i = t || n;
            return "function" == typeof i.fetch
              ? i.fetch
              : Rt(i.fetch)
              ? (t) => te(t, i)
              : null != e && e.fetch
              ? null == e
                ? void 0
                : e.fetch
              : te;
          }
          function le(t, e, n, i, r) {
            const s = e || "Top level",
              o = e ? `${e}.` : "";
            for (const a in t) {
              const c = !e && Rt(t[a]),
                h = "baseUri" === a && !e,
                l = "workerUrl" === a && e;
              if (!(a in n) && !h && !l)
                if (a in i)
                  ne.warn(
                    `${s} loader option '${o}${a}' no longer supported, use '${i[a]}'`
                  )();
                else if (!c) {
                  const t = ue(a, r);
                  ne.warn(
                    `${s} loader option '${o}${a}' not recognized. ${t}`
                  )();
                }
            }
          }
          function ue(t, e) {
            const n = t.toLowerCase();
            let i = "";
            for (const r of e)
              for (const e in r.options) {
                if (t === e) return `Did you mean '${r.id}.${e}'?`;
                const s = e.toLowerCase();
                (n.startsWith(s) || s.startsWith(n)) &&
                  (i = i || `Did you mean '${r.id}.${e}'?`);
              }
            return i;
          }
          function de(t, e) {
            for (const n in e)
              if (n in e) {
                const i = e[n];
                kt(i) && kt(t[n])
                  ? (t[n] = { ...t[n], ...e[n] })
                  : (t[n] = e[n]);
              }
          }
          function fe(t, e) {
            if (!t) throw new Error(e || "loaders.gl assertion failed.");
          }
          "undefined" != typeof self && self,
            "undefined" != typeof window && window,
            void 0 !== n.g && n.g,
            "undefined" != typeof document && document,
            "object" != typeof process ||
              "[object process]" !== String(process) ||
              process.browser;
          const pe =
              "undefined" != typeof window && void 0 !== window.orientation,
            ge =
              "undefined" != typeof process &&
              process.version &&
              /v([0-9]*)/.exec(process.version),
            me = (ge && parseFloat(ge[1]), new Map());
          function be(t) {
            const e = new Blob([t], { type: "application/javascript" });
            return URL.createObjectURL(e);
          }
          function _e(t, e = !0, n) {
            const i = n || new Set();
            if (t)
              if (ye(t)) i.add(t);
              else if (ye(t.buffer)) i.add(t.buffer);
              else if (ArrayBuffer.isView(t));
              else if (e && "object" == typeof t)
                for (const n in t) _e(t[n], e, i);
            return void 0 === n ? Array.from(i) : [];
          }
          function ye(t) {
            return (
              !!t &&
              (t instanceof ArrayBuffer ||
                ("undefined" != typeof MessagePort &&
                  t instanceof MessagePort) ||
                ("undefined" != typeof ImageBitmap &&
                  t instanceof ImageBitmap) ||
                ("undefined" != typeof OffscreenCanvas &&
                  t instanceof OffscreenCanvas))
            );
          }
          const ve = () => {};
          class we {
            static isSupported() {
              return "undefined" != typeof Worker;
            }
            constructor(t) {
              ee(this, "name", void 0),
                ee(this, "source", void 0),
                ee(this, "url", void 0),
                ee(this, "terminated", !1),
                ee(this, "worker", void 0),
                ee(this, "onMessage", void 0),
                ee(this, "onError", void 0),
                ee(this, "_loadableURL", "");
              const { name: e, source: n, url: i } = t;
              fe(n || i),
                (this.name = e),
                (this.source = n),
                (this.url = i),
                (this.onMessage = ve),
                (this.onError = (t) => console.log(t)),
                (this.worker = this._createBrowserWorker());
            }
            destroy() {
              (this.onMessage = ve),
                (this.onError = ve),
                this.worker.terminate(),
                (this.terminated = !0);
            }
            get isRunning() {
              return Boolean(this.onMessage);
            }
            postMessage(t, e) {
              (e = e || _e(t)), this.worker.postMessage(t, e);
            }
            _getErrorFromErrorEvent(t) {
              let e = "Failed to load ";
              return (
                (e += `worker ${this.name}. `),
                t.message && (e += `${t.message} in `),
                t.lineno && (e += `:${t.lineno}:${t.colno}`),
                new Error(e)
              );
            }
            _createBrowserWorker() {
              this._loadableURL = (function (t) {
                fe((t.source && !t.url) || (!t.source && t.url));
                let e = me.get(t.source || t.url);
                return (
                  e ||
                    (t.url &&
                      ((e = (n = t.url).startsWith("http")
                        ? be(
                            `try {\n  importScripts('${n}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`
                          )
                        : n),
                      me.set(t.url, e)),
                    t.source && ((e = be(t.source)), me.set(t.source, e))),
                  fe(e),
                  e
                );
                var n;
              })({ source: this.source, url: this.url });
              const t = new Worker(this._loadableURL, { name: this.name });
              return (
                (t.onmessage = (t) => {
                  t.data
                    ? this.onMessage(t.data)
                    : this.onError(new Error("No data received"));
                }),
                (t.onerror = (t) => {
                  this.onError(this._getErrorFromErrorEvent(t)),
                    (this.terminated = !0);
                }),
                (t.onmessageerror = (t) => console.error(t)),
                t
              );
            }
          }
          class xe {
            constructor(t, e) {
              ee(this, "name", void 0),
                ee(this, "workerThread", void 0),
                ee(this, "isRunning", void 0),
                ee(this, "result", void 0),
                ee(this, "_resolve", void 0),
                ee(this, "_reject", void 0),
                (this.name = t),
                (this.workerThread = e),
                (this.isRunning = !0),
                (this._resolve = () => {}),
                (this._reject = () => {}),
                (this.result = new Promise((t, e) => {
                  (this._resolve = t), (this._reject = e);
                }));
            }
            postMessage(t, e) {
              this.workerThread.postMessage({
                source: "loaders.gl",
                type: t,
                payload: e,
              });
            }
            done(t) {
              fe(this.isRunning), (this.isRunning = !1), this._resolve(t);
            }
            error(t) {
              fe(this.isRunning), (this.isRunning = !1), this._reject(t);
            }
          }
          class Ee {
            constructor(t) {
              ee(this, "name", "unnamed"),
                ee(this, "source", void 0),
                ee(this, "url", void 0),
                ee(this, "maxConcurrency", 1),
                ee(this, "maxMobileConcurrency", 1),
                ee(this, "onDebug", () => {}),
                ee(this, "reuseWorkers", !0),
                ee(this, "props", {}),
                ee(this, "jobQueue", []),
                ee(this, "idleQueue", []),
                ee(this, "count", 0),
                ee(this, "isDestroyed", !1),
                (this.source = t.source),
                (this.url = t.url),
                this.setProps(t);
            }
            destroy() {
              this.idleQueue.forEach((t) => t.destroy()),
                (this.isDestroyed = !0);
            }
            setProps(t) {
              (this.props = { ...this.props, ...t }),
                void 0 !== t.name && (this.name = t.name),
                void 0 !== t.maxConcurrency &&
                  (this.maxConcurrency = t.maxConcurrency),
                void 0 !== t.maxMobileConcurrency &&
                  (this.maxMobileConcurrency = t.maxMobileConcurrency),
                void 0 !== t.reuseWorkers &&
                  (this.reuseWorkers = t.reuseWorkers),
                void 0 !== t.onDebug && (this.onDebug = t.onDebug);
            }
            async startJob(
              t,
              e = (t, e, n) => t.done(n),
              n = (t, e) => t.error(e)
            ) {
              const i = new Promise(
                (i) => (
                  this.jobQueue.push({
                    name: t,
                    onMessage: e,
                    onError: n,
                    onStart: i,
                  }),
                  this
                )
              );
              return this._startQueuedJob(), await i;
            }
            async _startQueuedJob() {
              if (!this.jobQueue.length) return;
              const t = this._getAvailableWorker();
              if (!t) return;
              const e = this.jobQueue.shift();
              if (e) {
                this.onDebug({
                  message: "Starting job",
                  name: e.name,
                  workerThread: t,
                  backlog: this.jobQueue.length,
                });
                const n = new xe(e.name, t);
                (t.onMessage = (t) => e.onMessage(n, t.type, t.payload)),
                  (t.onError = (t) => e.onError(n, t)),
                  e.onStart(n);
                try {
                  await n.result;
                } finally {
                  this.returnWorkerToQueue(t);
                }
              }
            }
            returnWorkerToQueue(t) {
              this.isDestroyed ||
              !this.reuseWorkers ||
              this.count > this._getMaxConcurrency()
                ? (t.destroy(), this.count--)
                : this.idleQueue.push(t),
                this.isDestroyed || this._startQueuedJob();
            }
            _getAvailableWorker() {
              if (this.idleQueue.length > 0)
                return this.idleQueue.shift() || null;
              if (this.count < this._getMaxConcurrency()) {
                this.count++;
                const t = `${this.name.toLowerCase()} (#${this.count} of ${
                  this.maxConcurrency
                })`;
                return new we({ name: t, source: this.source, url: this.url });
              }
              return null;
            }
            _getMaxConcurrency() {
              return pe ? this.maxMobileConcurrency : this.maxConcurrency;
            }
          }
          const Pe = {
            maxConcurrency: 3,
            maxMobileConcurrency: 1,
            onDebug: () => {},
            reuseWorkers: !0,
          };
          class Te {
            static isSupported() {
              return we.isSupported();
            }
            static getWorkerFarm(t = {}) {
              return (
                (Te._workerFarm = Te._workerFarm || new Te({})),
                Te._workerFarm.setProps(t),
                Te._workerFarm
              );
            }
            constructor(t) {
              ee(this, "props", void 0),
                ee(this, "workerPools", new Map()),
                (this.props = { ...Pe }),
                this.setProps(t),
                (this.workerPools = new Map());
            }
            destroy() {
              for (const t of this.workerPools.values()) t.destroy();
            }
            setProps(t) {
              this.props = { ...this.props, ...t };
              for (const t of this.workerPools.values())
                t.setProps(this._getWorkerPoolProps());
            }
            getWorkerPool(t) {
              const { name: e, source: n, url: i } = t;
              let r = this.workerPools.get(e);
              return (
                r ||
                  ((r = new Ee({ name: e, source: n, url: i })),
                  r.setProps(this._getWorkerPoolProps()),
                  this.workerPools.set(e, r)),
                r
              );
            }
            _getWorkerPoolProps() {
              return {
                maxConcurrency: this.props.maxConcurrency,
                maxMobileConcurrency: this.props.maxMobileConcurrency,
                reuseWorkers: this.props.reuseWorkers,
                onDebug: this.props.onDebug,
              };
            }
          }
          async function Ae(t, e, n, i, r) {
            const s = t.id,
              o = (function (t, e = {}) {
                const n = e[t.id] || {},
                  i = `${t.id}-worker.js`;
                let r = n.workerUrl;
                if (
                  ("test" === e._workerType &&
                    (r = `modules/${t.module}/dist/${i}`),
                  !r)
                ) {
                  let e = t.version;
                  "latest" === e && (e = "latest");
                  const n = e ? `@${e}` : "";
                  r = `https://unpkg.com/@loaders.gl/${t.module}${n}/dist/${i}`;
                }
                return fe(r), r;
              })(t, n),
              a = Te.getWorkerFarm(n).getWorkerPool({ name: s, url: o });
            n = JSON.parse(JSON.stringify(n));
            const c = await a.startJob("process-on-worker", Se.bind(null, r));
            c.postMessage("process", { input: e, options: n });
            const h = await c.result;
            return await h.result;
          }
          async function Se(t, e, n, i) {
            switch (n) {
              case "done":
                e.done(i);
                break;
              case "error":
                e.error(i.error);
                break;
              case "process":
                const { id: r, input: s, options: o } = i;
                try {
                  const n = await t(s, o);
                  e.postMessage("done", { id: r, result: n });
                } catch (t) {
                  const n = t instanceof Error ? t.message : "unknown error";
                  e.postMessage("error", { id: r, error: n });
                }
                break;
              default:
                console.warn(`parse-with-worker unknown message ${n}`);
            }
          }
          ee(Te, "_workerFarm", void 0);
          var Me = n(521);
          function Ce(t) {
            var e;
            if (
              ((e = t) &&
                "object" == typeof e &&
                e.isBuffer &&
                (t = (function (t) {
                  return Me.toArrayBuffer ? Me.toArrayBuffer(t) : t;
                })(t)),
              t instanceof ArrayBuffer)
            )
              return t;
            if (ArrayBuffer.isView(t))
              return 0 === t.byteOffset && t.byteLength === t.buffer.byteLength
                ? t.buffer
                : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
            if ("string" == typeof t) {
              const e = t;
              return new TextEncoder().encode(e).buffer;
            }
            if (t && "object" == typeof t && t._toArrayBuffer)
              return t._toArrayBuffer();
            throw new Error("toArrayBuffer");
          }
          const Oe = 262144;
          function Le(t, e) {
            return Gt
              ? (async function* (t, e) {
                  const n = t.getReader();
                  let i;
                  try {
                    for (;;) {
                      const t = i || n.read();
                      null != e && e._streamReadAhead && (i = n.read());
                      const { done: r, value: s } = await t;
                      if (r) return;
                      yield Ce(s);
                    }
                  } catch (t) {
                    n.releaseLock();
                  }
                })(t, e)
              : (async function* (t, e) {
                  for await (const e of t) yield Ce(e);
                })(t);
          }
          const Ie = "Cannot convert supplied data type";
          async function Re(t, e, n) {
            const i = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
            if ("string" == typeof t || i)
              return (function (t, e, n) {
                if (e.text && "string" == typeof t) return t;
                var i;
                if (
                  ((i = t) &&
                    "object" == typeof i &&
                    i.isBuffer &&
                    (t = t.buffer),
                  t instanceof ArrayBuffer)
                ) {
                  const n = t;
                  return e.text && !e.binary
                    ? new TextDecoder("utf8").decode(n)
                    : n;
                }
                if (ArrayBuffer.isView(t)) {
                  if (e.text && !e.binary)
                    return new TextDecoder("utf8").decode(t);
                  let n = t.buffer;
                  const i = t.byteLength || t.length;
                  return (
                    (0 === t.byteOffset && i === n.byteLength) ||
                      (n = n.slice(t.byteOffset, t.byteOffset + i)),
                    n
                  );
                }
                throw new Error(Ie);
              })(t, e);
            if ((Ft(t) && (t = await Jt(t)), jt(t))) {
              const n = t;
              return (
                await (async function (t) {
                  if (!t.ok) {
                    const e = await (async function (t) {
                      let e = `Failed to fetch resource ${t.url} (${t.status}): `;
                      try {
                        const n = t.headers.get("Content-Type");
                        let i = t.statusText;
                        n.includes("application/json") &&
                          (i += ` ${await t.text()}`),
                          (e += i),
                          (e = e.length > 60 ? `${e.slice(60)}...` : e);
                      } catch (t) {}
                      return e;
                    })(t);
                    throw new Error(e);
                  }
                })(n),
                e.binary ? await n.arrayBuffer() : await n.text()
              );
            }
            if (
              (Bt(t) &&
                (t = (function (t, e) {
                  if ("string" == typeof t)
                    return (function* (t, e) {
                      const n = (null == e ? void 0 : e.chunkSize) || 262144;
                      let i = 0;
                      const r = new TextEncoder();
                      for (; i < t.length; ) {
                        const e = Math.min(t.length - i, n),
                          s = t.slice(i, i + e);
                        (i += e), yield r.encode(s);
                      }
                    })(t, e);
                  if (t instanceof ArrayBuffer)
                    return (function* (t, e = {}) {
                      const { chunkSize: n = Oe } = e;
                      let i = 0;
                      for (; i < t.byteLength; ) {
                        const e = Math.min(t.byteLength - i, n),
                          r = new ArrayBuffer(e),
                          s = new Uint8Array(t, i, e);
                        new Uint8Array(r).set(s), (i += e), yield r;
                      }
                    })(t, e);
                  if (Ft(t))
                    return (async function* (t, e) {
                      const n = (null == e ? void 0 : e.chunkSize) || 1048576;
                      let i = 0;
                      for (; i < t.size; ) {
                        const e = i + n,
                          r = await t.slice(i, e).arrayBuffer();
                        (i = e), yield r;
                      }
                    })(t, e);
                  if (Bt(t)) return Le(t, e);
                  if (jt(t)) return Le(t.body, e);
                  throw new Error("makeIterator");
                })(t, n)),
              ((r = t) && "function" == typeof r[Symbol.iterator]) ||
                ((t) => t && "function" == typeof t[Symbol.asyncIterator])(t))
            )
              return (async function (t) {
                const e = [];
                for await (const n of t) e.push(n);
                return (function (...t) {
                  const e = t.map((t) =>
                      t instanceof ArrayBuffer ? new Uint8Array(t) : t
                    ),
                    n = e.reduce((t, e) => t + e.byteLength, 0),
                    i = new Uint8Array(n);
                  let r = 0;
                  for (const t of e) i.set(t, r), (r += t.byteLength);
                  return i.buffer;
                })(...e);
              })(t);
            var r;
            throw new Error(Ie);
          }
          const ke = () => {
              const t = oe();
              return (
                (t.loaderRegistry = t.loaderRegistry || []), t.loaderRegistry
              );
            },
            je = /\.([^.]+)$/;
          function Fe(t, e = [], n, i) {
            if (!Be(t)) return null;
            if (e && !Array.isArray(e)) return zt(e);
            let r = [];
            e && (r = r.concat(e)),
              (null != n && n.ignoreRegisteredLoaders) || r.push(...ke()),
              (function (t) {
                for (const e of t) zt(e);
              })(r);
            const s = (function (t, e, n, i) {
              const { url: r, type: s } = Kt(t),
                o = r || (null == i ? void 0 : i.url);
              let a = null;
              return (
                null != n &&
                  n.mimeType &&
                  (a = Ne(e, null == n ? void 0 : n.mimeType)),
                (a =
                  a ||
                  (function (t, e) {
                    const n = e && je.exec(e),
                      i = n && n[1];
                    return i
                      ? (function (t, e) {
                          e = e.toLowerCase();
                          for (const n of t)
                            for (const t of n.extensions)
                              if (t.toLowerCase() === e) return n;
                          return null;
                        })(t, i)
                      : null;
                  })(e, o)),
                (a = a || Ne(e, s)),
                (a =
                  a ||
                  (function (t, e) {
                    if (!e) return null;
                    for (const n of t)
                      if ("string" == typeof e) {
                        if (ze(e, n)) return n;
                      } else if (ArrayBuffer.isView(e)) {
                        if (Ve(e.buffer, e.byteOffset, n)) return n;
                      } else if (e instanceof ArrayBuffer && Ve(e, 0, n))
                        return n;
                    return null;
                  })(e, t)),
                (a = a || Ne(e, null == n ? void 0 : n.fallbackMimeType)),
                a
              );
            })(t, r, n, i);
            if (!(s || (null != n && n.nothrow))) throw new Error(De(t));
            return s;
          }
          function Be(t) {
            return !(t instanceof Response && 204 === t.status);
          }
          function De(t) {
            const { url: e, type: n } = Kt(t);
            let i = "No valid loader found";
            return (
              t &&
                (i += ` data: "${(function (t, e = 5) {
                  return "string" == typeof t
                    ? t.slice(0, e)
                    : ArrayBuffer.isView(t)
                    ? Ue(t.buffer, t.byteOffset, e)
                    : t instanceof ArrayBuffer
                    ? Ue(t, 0, e)
                    : "";
                })(t)}", contentType: "${n}"`),
              e && (i += ` url: ${e}`),
              i
            );
          }
          function Ne(t, e) {
            for (const n of t) {
              if (n.mimeTypes && n.mimeTypes.includes(e)) return n;
              if (e === `application/x.${n.id}`) return n;
            }
            return null;
          }
          function ze(t, e) {
            return e.testText
              ? e.testText(t)
              : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((e) =>
                  t.startsWith(e)
                );
          }
          function Ve(t, e, n) {
            return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((i) =>
              (function (t, e, n, i) {
                if (i instanceof ArrayBuffer)
                  return (function (t, e, n) {
                    if (
                      ((n = n || t.byteLength),
                      t.byteLength < n || e.byteLength < n)
                    )
                      return !1;
                    const i = new Uint8Array(t),
                      r = new Uint8Array(e);
                    for (let t = 0; t < i.length; ++t)
                      if (i[t] !== r[t]) return !1;
                    return !0;
                  })(i, t, i.byteLength);
                switch (typeof i) {
                  case "function":
                    return i(t, n);
                  case "string":
                    return i === Ue(t, e, i.length);
                  default:
                    return !1;
                }
              })(t, e, n, i)
            );
          }
          function Ue(t, e, n) {
            if (t.byteLength < e + n) return "";
            const i = new DataView(t);
            let r = "";
            for (let t = 0; t < n; t++)
              r += String.fromCharCode(i.getUint8(e + t));
            return r;
          }
          async function Ge(t, e, n, i) {
            fe(!i || "object" == typeof i),
              !e ||
                Array.isArray(e) ||
                Nt(e) ||
                ((i = void 0), (n = e), (e = void 0)),
              (t = await t),
              (n = n || {});
            const { url: r } = Kt(t),
              s = (function (t, e) {
                if (!e && t && !Array.isArray(t)) return t;
                let n;
                if ((t && (n = Array.isArray(t) ? t : [t]), e && e.loaders)) {
                  const t = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
                  n = n ? [...n, ...t] : t;
                }
                return n && n.length ? n : null;
              })(e, i),
              o = await (async function (t, e = [], n, i) {
                if (!Be(t)) return null;
                let r = Fe(t, e, { ...n, nothrow: !0 }, i);
                if (r) return r;
                if (
                  (Ft(t) &&
                    (r = Fe((t = await t.slice(0, 10).arrayBuffer()), e, n, i)),
                  !(r || (null != n && n.nothrow)))
                )
                  throw new Error(De(t));
                return r;
              })(t, s, n);
            return o
              ? ((i = (function (t, e, n = null) {
                  if (n) return n;
                  const i = { fetch: he(e, t), ...t };
                  return Array.isArray(i.loaders) || (i.loaders = null), i;
                })({ url: r, parse: Ge, loaders: s }, (n = ce(n, o, s, r)), i)),
                await (async function (t, e, n, i) {
                  if (
                    ((function (t, e = "3.0.12") {
                      fe(t, "no worker provided");
                      t.version;
                    })(t),
                    (e = await Re(e, t, n)),
                    t.parseTextSync && "string" == typeof e)
                  )
                    return (n.dataType = "text"), t.parseTextSync(e, n, i, t);
                  if (
                    (function (t, e) {
                      return (
                        !!Te.isSupported() &&
                        t.worker &&
                        (null == e ? void 0 : e.worker)
                      );
                    })(t, n)
                  )
                    return await Ae(t, e, n, 0, Ge);
                  if (t.parseText && "string" == typeof e)
                    return await t.parseText(e, n, i, t);
                  if (t.parse) return await t.parse(e, n, i, t);
                  throw (
                    (fe(!t.parseSync),
                    new Error(
                      `${t.id} loader - no parser found and worker is disabled`
                    ))
                  );
                })(o, t, n, i))
              : null;
          }
          async function $e(t, e, n, i) {
            Array.isArray(e) || Nt(e) || ((n = e), (e = void 0));
            const r = he(n);
            let s = t;
            return (
              "string" == typeof t && (s = await r(t)),
              Ft(t) && (s = await r(t)),
              await Ge(s, e, n)
            );
          }
          class We {
            constructor(t, e, n) {
              (this.id = t),
                (this.context = n),
                (this._loadCount = 0),
                (this._subscribers = new Set()),
                this.setData(e);
            }
            subscribe(t) {
              this._subscribers.add(t);
            }
            unsubscribe(t) {
              this._subscribers.delete(t);
            }
            inUse() {
              return this._subscribers.size > 0;
            }
            delete() {}
            getData() {
              return this.isLoaded
                ? this._error
                  ? Promise.reject(this._error)
                  : this._content
                : this._loader.then(() => this.getData());
            }
            setData(t, e) {
              if (t === this._data && !e) return;
              this._data = t;
              const n = ++this._loadCount;
              let i = t;
              "string" == typeof t && (i = $e(t)),
                i instanceof Promise
                  ? ((this.isLoaded = !1),
                    (this._loader = i
                      .then((t) => {
                        this._loadCount === n &&
                          ((this.isLoaded = !0),
                          (this._error = null),
                          (this._content = t));
                      })
                      .catch((t) => {
                        this._loadCount === n &&
                          ((this.isLoaded = !0), (this._error = t || !0));
                      })))
                  : ((this.isLoaded = !0),
                    (this._error = null),
                    (this._content = t));
              for (const t of this._subscribers) t.onChange(this.getData());
            }
          }
          class He {
            constructor({ gl: t, protocol: e }) {
              (this.protocol = e || "resource://"),
                (this._context = { gl: t, resourceManager: this }),
                (this._resources = {}),
                (this._consumers = {}),
                (this._pruneRequest = null);
            }
            contains(t) {
              return !!t.startsWith(this.protocol) || t in this._resources;
            }
            add({
              resourceId: t,
              data: e,
              forceUpdate: n = !1,
              persistent: i = !0,
            }) {
              let r = this._resources[t];
              r
                ? r.setData(e, n)
                : ((r = new We(t, e, this._context)), (this._resources[t] = r)),
                (r.persistent = i);
            }
            remove(t) {
              const e = this._resources[t];
              e && (e.delete(), delete this._resources[t]);
            }
            unsubscribe({ consumerId: t }) {
              const e = this._consumers[t];
              if (e) {
                for (const t in e) {
                  const n = e[t];
                  n.resource && n.resource.unsubscribe(n);
                }
                delete this._consumers[t], this.prune();
              }
            }
            subscribe({
              resourceId: t,
              onChange: e,
              consumerId: n,
              requestId: i = "default",
            }) {
              const { _resources: r, protocol: s } = this;
              t.startsWith(s) &&
                (r[(t = t.replace(s, ""))] ||
                  this.add({ resourceId: t, data: null, persistent: !1 }));
              const o = r[t];
              if ((this._track(n, i, o, e), o)) return o.getData();
            }
            prune() {
              this._pruneRequest ||
                (this._pruneRequest = setTimeout(() => this._prune(), 0));
            }
            finalize() {
              for (const t in this._resources) this._resources[t].delete();
            }
            _track(t, e, n, i) {
              const r = this._consumers,
                s = (r[t] = r[t] || {}),
                o = s[e] || {};
              o.resource &&
                (o.resource.unsubscribe(o), (o.resource = null), this.prune()),
                n &&
                  ((s[e] = o),
                  (o.onChange = i),
                  (o.resource = n),
                  n.subscribe(o));
            }
            _prune() {
              this._pruneRequest = null;
              for (const t of Object.keys(this._resources)) {
                const e = this._resources[t];
                e.persistent ||
                  e.inUse() ||
                  (e.delete(), delete this._resources[t]);
              }
            }
          }
          const Xe = new (class {
              constructor(t) {
                (this._pool = []),
                  (this.props = { overAlloc: 2, poolSize: 100 }),
                  this.setProps(t);
              }
              setProps(t) {
                Object.assign(this.props, t);
              }
              allocate(
                t,
                e,
                {
                  size: n = 1,
                  type: i,
                  padding: r = 0,
                  copy: s = !1,
                  initialize: o = !1,
                  maxCount: a,
                }
              ) {
                const c = i || (t && t.constructor) || Float32Array,
                  h = e * n + r;
                if (ArrayBuffer.isView(t)) {
                  if (h <= t.length) return t;
                  if (h * t.BYTES_PER_ELEMENT <= t.buffer.byteLength)
                    return new c(t.buffer, 0, h);
                }
                let l;
                a && (l = a * n + r);
                const u = this._allocate(c, h, o, l);
                return (
                  t && s ? u.set(t) : o || u.fill(0, 0, 4), this._release(t), u
                );
              }
              release(t) {
                this._release(t);
              }
              _allocate(t, e, n, i) {
                let r = Math.max(Math.ceil(e * this.props.overAlloc), 1);
                r > i && (r = i);
                const s = this._pool,
                  o = t.BYTES_PER_ELEMENT * r,
                  a = s.findIndex((t) => t.byteLength >= o);
                if (a >= 0) {
                  const e = new t(s.splice(a, 1)[0], 0, r);
                  return n && e.fill(0), e;
                }
                return new t(r);
              }
              _release(t) {
                if (!ArrayBuffer.isView(t)) return;
                const e = this._pool,
                  { buffer: n } = t,
                  { byteLength: i } = n,
                  r = e.findIndex((t) => t.byteLength >= i);
                r < 0
                  ? e.push(n)
                  : (r > 0 || e.length < this.props.poolSize) &&
                    e.splice(r, 0, n),
                  e.length > this.props.poolSize && e.shift();
              }
            })(),
            qe = (Math.PI, Math.PI, {});
          function Ye(t, { precision: e = qe.precision || 4 } = {}) {
            return (
              (t = (function (t) {
                return Math.round(t / qe.EPSILON) * qe.EPSILON;
              })(t)),
              "".concat(parseFloat(t.toPrecision(e)))
            );
          }
          function Ze(t) {
            return (
              Array.isArray(t) ||
              (ArrayBuffer.isView(t) && !(t instanceof DataView))
            );
          }
          function Ke(t, e, n) {
            return (function (t, e, n) {
              if (Ze(t)) {
                n = n || ((i = t).clone ? i.clone() : new Array(i.length));
                for (let i = 0; i < n.length && i < t.length; ++i)
                  n[i] = e(t[i], i, n);
                return n;
              }
              var i;
              return e(t);
            })(t, (t) => Math.max(e, Math.min(n, t)));
          }
          function Qe(t, e, n) {
            return Ze(t)
              ? t.map((t, i) => Qe(t, e[i], n))
              : n * e + (1 - n) * t;
          }
          function Je(t, e, n) {
            const i = qe.EPSILON;
            n && (qe.EPSILON = n);
            try {
              if (t === e) return !0;
              if (Ze(t) && Ze(e)) {
                if (t.length !== e.length) return !1;
                for (let n = 0; n < t.length; ++n)
                  if (!Je(t[n], e[n])) return !1;
                return !0;
              }
              return t && t.equals
                ? t.equals(e)
                : e && e.equals
                ? e.equals(t)
                : !(!Number.isFinite(t) || !Number.isFinite(e)) &&
                  Math.abs(t - e) <=
                    qe.EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            } finally {
              qe.EPSILON = i;
            }
          }
          function tn(t, e) {
            if (!t) throw new Error("math.gl assertion ".concat(e));
          }
          (qe.EPSILON = 1e-12),
            (qe.debug = !1),
            (qe.precision = 4),
            (qe.printTypes = !1),
            (qe.printDegrees = !1),
            (qe.printRowMajor = !0);
          class en extends (function (t) {
            function e() {
              var e = Reflect.construct(t, Array.from(arguments));
              return Object.setPrototypeOf(e, Object.getPrototypeOf(this)), e;
            }
            return (
              (e.prototype = Object.create(t.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
              Object.setPrototypeOf
                ? Object.setPrototypeOf(e, t)
                : (e.__proto__ = t),
              e
            );
          })(Array) {
            get ELEMENTS() {
              return tn(!1), 0;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            from(t) {
              return Array.isArray(t) ? this.copy(t) : this.fromObject(t);
            }
            fromArray(t, e = 0) {
              for (let n = 0; n < this.ELEMENTS; ++n) this[n] = t[n + e];
              return this.check();
            }
            to(t) {
              return t === this
                ? this
                : Ze(t)
                ? this.toArray(t)
                : this.toObject(t);
            }
            toTarget(t) {
              return t ? this.to(t) : this;
            }
            toArray(t = [], e = 0) {
              for (let n = 0; n < this.ELEMENTS; ++n) t[e + n] = this[n];
              return t;
            }
            toFloat32Array() {
              return new Float32Array(this);
            }
            toString() {
              return this.formatString(qe);
            }
            formatString(t) {
              let e = "";
              for (let n = 0; n < this.ELEMENTS; ++n)
                e += (n > 0 ? ", " : "") + Ye(this[n], t);
              return ""
                .concat(t.printTypes ? this.constructor.name : "", "[")
                .concat(e, "]");
            }
            equals(t) {
              if (!t || this.length !== t.length) return !1;
              for (let e = 0; e < this.ELEMENTS; ++e)
                if (!Je(this[e], t[e])) return !1;
              return !0;
            }
            exactEquals(t) {
              if (!t || this.length !== t.length) return !1;
              for (let e = 0; e < this.ELEMENTS; ++e)
                if (this[e] !== t[e]) return !1;
              return !0;
            }
            negate() {
              for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];
              return this.check();
            }
            lerp(t, e, n) {
              void 0 === n && ((n = e), (e = t), (t = this));
              for (let i = 0; i < this.ELEMENTS; ++i) {
                const r = t[i];
                this[i] = r + n * (e[i] - r);
              }
              return this.check();
            }
            min(t) {
              for (let e = 0; e < this.ELEMENTS; ++e)
                this[e] = Math.min(t[e], this[e]);
              return this.check();
            }
            max(t) {
              for (let e = 0; e < this.ELEMENTS; ++e)
                this[e] = Math.max(t[e], this[e]);
              return this.check();
            }
            clamp(t, e) {
              for (let n = 0; n < this.ELEMENTS; ++n)
                this[n] = Math.min(Math.max(this[n], t[n]), e[n]);
              return this.check();
            }
            add(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] += e[t];
              return this.check();
            }
            subtract(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] -= e[t];
              return this.check();
            }
            scale(t) {
              if (Array.isArray(t)) return this.multiply(t);
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
              return this.check();
            }
            sub(t) {
              return this.subtract(t);
            }
            setScalar(t) {
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] = t;
              return this.check();
            }
            addScalar(t) {
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] += t;
              return this.check();
            }
            subScalar(t) {
              return this.addScalar(-t);
            }
            multiplyScalar(t) {
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
              return this.check();
            }
            divideScalar(t) {
              return this.scale(1 / t);
            }
            clampScalar(t, e) {
              for (let n = 0; n < this.ELEMENTS; ++n)
                this[n] = Math.min(Math.max(this[n], t), e);
              return this.check();
            }
            multiplyByScalar(t) {
              return this.scale(t);
            }
            get elements() {
              return this;
            }
            check() {
              if (qe.debug && !this.validate())
                throw new Error(
                  "math.gl: ".concat(
                    this.constructor.name,
                    " some fields set to invalid numbers'"
                  )
                );
              return this;
            }
            validate() {
              let t = this.length === this.ELEMENTS;
              for (let e = 0; e < this.ELEMENTS; ++e)
                t = t && Number.isFinite(this[e]);
              return t;
            }
          }
          function nn(t) {
            if (!Number.isFinite(t))
              throw new Error("Invalid number ".concat(t));
            return t;
          }
          function rn(t, e, n = "") {
            if (
              qe.debug &&
              !(function (t, e) {
                if (t.length !== e) return !1;
                for (let e = 0; e < t.length; ++e)
                  if (!Number.isFinite(t[e])) return !1;
                return !0;
              })(t, e)
            )
              throw new Error(
                "math.gl: ".concat(n, " some fields set to invalid numbers'")
              );
            return t;
          }
          const sn = {};
          function on(t, e) {
            sn[t] ||
              ((sn[t] = !0),
              console.warn(
                ""
                  .concat(t, " has been removed in version ")
                  .concat(e, ", see upgrade guide for more information")
              ));
          }
          class an extends en {
            get ELEMENTS() {
              return tn(!1), 0;
            }
            copy(t) {
              return tn(!1), this;
            }
            get x() {
              return this[0];
            }
            set x(t) {
              this[0] = nn(t);
            }
            get y() {
              return this[1];
            }
            set y(t) {
              this[1] = nn(t);
            }
            len() {
              return Math.sqrt(this.lengthSquared());
            }
            magnitude() {
              return this.len();
            }
            lengthSquared() {
              let t = 0;
              for (let e = 0; e < this.ELEMENTS; ++e) t += this[e] * this[e];
              return t;
            }
            magnitudeSquared() {
              return this.lengthSquared();
            }
            distance(t) {
              return Math.sqrt(this.distanceSquared(t));
            }
            distanceSquared(t) {
              let e = 0;
              for (let n = 0; n < this.ELEMENTS; ++n) {
                const i = this[n] - t[n];
                e += i * i;
              }
              return nn(e);
            }
            dot(t) {
              let e = 0;
              for (let n = 0; n < this.ELEMENTS; ++n) e += this[n] * t[n];
              return nn(e);
            }
            normalize() {
              const t = this.magnitude();
              if (0 !== t) for (let e = 0; e < this.ELEMENTS; ++e) this[e] /= t;
              return this.check();
            }
            multiply(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e[t];
              return this.check();
            }
            divide(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] /= e[t];
              return this.check();
            }
            lengthSq() {
              return this.lengthSquared();
            }
            distanceTo(t) {
              return this.distance(t);
            }
            distanceToSquared(t) {
              return this.distanceSquared(t);
            }
            getComponent(t) {
              return (
                tn(t >= 0 && t < this.ELEMENTS, "index is out of range"),
                nn(this[t])
              );
            }
            setComponent(t, e) {
              return (
                tn(t >= 0 && t < this.ELEMENTS, "index is out of range"),
                (this[t] = e),
                this.check()
              );
            }
            addVectors(t, e) {
              return this.copy(t).add(e);
            }
            subVectors(t, e) {
              return this.copy(t).subtract(e);
            }
            multiplyVectors(t, e) {
              return this.copy(t).multiply(e);
            }
            addScaledVector(t, e) {
              return this.add(new this.constructor(t).multiplyScalar(e));
            }
          }
          var cn = 1e-6,
            hn = "undefined" != typeof Float32Array ? Float32Array : Array;
          function ln(t, e, n) {
            var i = e[0],
              r = e[1],
              s = e[2],
              o = n[3] * i + n[7] * r + n[11] * s + n[15];
            return (
              (o = o || 1),
              (t[0] = (n[0] * i + n[4] * r + n[8] * s + n[12]) / o),
              (t[1] = (n[1] * i + n[5] * r + n[9] * s + n[13]) / o),
              (t[2] = (n[2] * i + n[6] * r + n[10] * s + n[14]) / o),
              t
            );
          }
          Math.random,
            Math.PI,
            Math.hypot ||
              (Math.hypot = function () {
                for (var t = 0, e = arguments.length; e--; )
                  t += arguments[e] * arguments[e];
                return Math.sqrt(t);
              });
          var un;
          function dn(t, e, n) {
            const i = e[0],
              r = e[1],
              s = e[2],
              o = n[3] * i + n[7] * r + n[11] * s || 1;
            return (
              (t[0] = (n[0] * i + n[4] * r + n[8] * s) / o),
              (t[1] = (n[1] * i + n[5] * r + n[9] * s) / o),
              (t[2] = (n[2] * i + n[6] * r + n[10] * s) / o),
              t
            );
          }
          (un = new hn(3)),
            hn != Float32Array && ((un[0] = 0), (un[1] = 0), (un[2] = 0));
          const fn = [0, 0, 0],
            pn = {};
          class gn extends an {
            static get ZERO() {
              return (pn.ZERO = pn.ZERO || Object.freeze(new gn(0, 0, 0, 0)));
            }
            constructor(t = 0, e = 0, n = 0) {
              super(-0, -0, -0),
                1 === arguments.length && Ze(t)
                  ? this.copy(t)
                  : (qe.debug && (nn(t), nn(e), nn(n)),
                    (this[0] = t),
                    (this[1] = e),
                    (this[2] = n));
            }
            set(t, e, n) {
              return (this[0] = t), (this[1] = e), (this[2] = n), this.check();
            }
            copy(t) {
              return (
                (this[0] = t[0]),
                (this[1] = t[1]),
                (this[2] = t[2]),
                this.check()
              );
            }
            fromObject(t) {
              return (
                qe.debug && (nn(t.x), nn(t.y), nn(t.z)),
                (this[0] = t.x),
                (this[1] = t.y),
                (this[2] = t.z),
                this.check()
              );
            }
            toObject(t) {
              return (t.x = this[0]), (t.y = this[1]), (t.z = this[2]), t;
            }
            get ELEMENTS() {
              return 3;
            }
            get z() {
              return this[2];
            }
            set z(t) {
              this[2] = nn(t);
            }
            angle(t) {
              return (
                (n = t),
                (i = (e = this)[0]),
                (r = e[1]),
                (s = e[2]),
                (o = n[0]),
                (a = n[1]),
                (c = n[2]),
                (l =
                  (h =
                    Math.sqrt(i * i + r * r + s * s) *
                    Math.sqrt(o * o + a * a + c * c)) &&
                  (function (t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
                  })(e, n) / h),
                Math.acos(Math.min(Math.max(l, -1), 1))
              );
              var e, n, i, r, s, o, a, c, h, l;
            }
            cross(t) {
              return (
                (function (t, e, n) {
                  var i = e[0],
                    r = e[1],
                    s = e[2],
                    o = n[0],
                    a = n[1],
                    c = n[2];
                  (t[0] = r * c - s * a),
                    (t[1] = s * o - i * c),
                    (t[2] = i * a - r * o);
                })(this, this, t),
                this.check()
              );
            }
            rotateX({ radians: t, origin: e = fn }) {
              return (
                (function (t, e, n, i) {
                  var r = [],
                    s = [];
                  (r[0] = e[0] - n[0]),
                    (r[1] = e[1] - n[1]),
                    (r[2] = e[2] - n[2]),
                    (s[0] = r[0]),
                    (s[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i)),
                    (s[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i)),
                    (t[0] = s[0] + n[0]),
                    (t[1] = s[1] + n[1]),
                    (t[2] = s[2] + n[2]);
                })(this, this, e, t),
                this.check()
              );
            }
            rotateY({ radians: t, origin: e = fn }) {
              return (
                (function (t, e, n, i) {
                  var r = [],
                    s = [];
                  (r[0] = e[0] - n[0]),
                    (r[1] = e[1] - n[1]),
                    (r[2] = e[2] - n[2]),
                    (s[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i)),
                    (s[1] = r[1]),
                    (s[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i)),
                    (t[0] = s[0] + n[0]),
                    (t[1] = s[1] + n[1]),
                    (t[2] = s[2] + n[2]);
                })(this, this, e, t),
                this.check()
              );
            }
            rotateZ({ radians: t, origin: e = fn }) {
              return (
                (function (t, e, n, i) {
                  var r = [],
                    s = [];
                  (r[0] = e[0] - n[0]),
                    (r[1] = e[1] - n[1]),
                    (r[2] = e[2] - n[2]),
                    (s[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i)),
                    (s[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i)),
                    (s[2] = r[2]),
                    (t[0] = s[0] + n[0]),
                    (t[1] = s[1] + n[1]),
                    (t[2] = s[2] + n[2]);
                })(this, this, e, t),
                this.check()
              );
            }
            transform(t) {
              return this.transformAsPoint(t);
            }
            transformAsPoint(t) {
              return ln(this, this, t), this.check();
            }
            transformAsVector(t) {
              return dn(this, this, t), this.check();
            }
            transformByMatrix3(t) {
              return (
                (function (t, e, n) {
                  var i = e[0],
                    r = e[1],
                    s = e[2];
                  (t[0] = i * n[0] + r * n[3] + s * n[6]),
                    (t[1] = i * n[1] + r * n[4] + s * n[7]),
                    (t[2] = i * n[2] + r * n[5] + s * n[8]);
                })(this, this, t),
                this.check()
              );
            }
            transformByMatrix2(t) {
              return (
                (function (t, e, n) {
                  const i = e[0],
                    r = e[1];
                  (t[0] = n[0] * i + n[2] * r),
                    (t[1] = n[1] * i + n[3] * r),
                    (t[2] = e[2]);
                })(this, this, t),
                this.check()
              );
            }
            transformByQuaternion(t) {
              return (
                (function (t, e, n) {
                  var i = n[0],
                    r = n[1],
                    s = n[2],
                    o = n[3],
                    a = e[0],
                    c = e[1],
                    h = e[2],
                    l = r * h - s * c,
                    u = s * a - i * h,
                    d = i * c - r * a,
                    f = r * d - s * u,
                    p = s * l - i * d,
                    g = i * u - r * l,
                    m = 2 * o;
                  (l *= m),
                    (u *= m),
                    (d *= m),
                    (f *= 2),
                    (p *= 2),
                    (g *= 2),
                    (t[0] = a + l + f),
                    (t[1] = c + u + p),
                    (t[2] = h + d + g);
                })(this, this, t),
                this.check()
              );
            }
          }
          const mn = new gn();
          function bn(t, e, n, i) {
            mn.set(t, e, n);
            const r = mn.len();
            return { distance: i / r, normal: new gn(-t / r, -e / r, -n / r) };
          }
          let _n;
          function yn(t, { size: e = 1, startIndex: n = 0, endIndex: i }) {
            Number.isFinite(i) || (i = t.length);
            const r = (i - n) / e;
            _n = Xe.allocate(_n, r, { type: Float32Array, size: 2 * e });
            let s = n,
              o = 0;
            for (; s < i; ) {
              for (let n = 0; n < e; n++) {
                const i = t[s++];
                (_n[o + n] = i), (_n[o + n + e] = (a = i) - Math.fround(a));
              }
              o += 2 * e;
            }
            var a;
            return _n.subarray(0, r * e * 2);
          }
          class vn extends en {
            get ELEMENTS() {
              return tn(!1), 0;
            }
            get RANK() {
              return tn(!1), 0;
            }
            toString() {
              let t = "[";
              if (qe.printRowMajor) {
                t += "row-major:";
                for (let e = 0; e < this.RANK; ++e)
                  for (let n = 0; n < this.RANK; ++n)
                    t += " ".concat(this[n * this.RANK + e]);
              } else {
                t += "column-major:";
                for (let e = 0; e < this.ELEMENTS; ++e)
                  t += " ".concat(this[e]);
              }
              return (t += "]"), t;
            }
            getElementIndex(t, e) {
              return e * this.RANK + t;
            }
            getElement(t, e) {
              return this[e * this.RANK + t];
            }
            setElement(t, e, n) {
              return (this[e * this.RANK + t] = nn(n)), this;
            }
            getColumn(t, e = new Array(this.RANK).fill(-0)) {
              const n = t * this.RANK;
              for (let t = 0; t < this.RANK; ++t) e[t] = this[n + t];
              return e;
            }
            setColumn(t, e) {
              const n = t * this.RANK;
              for (let t = 0; t < this.RANK; ++t) this[n + t] = e[t];
              return this;
            }
          }
          function wn(t, e) {
            var n = e[0],
              i = e[1],
              r = e[2],
              s = e[3],
              o = e[4],
              a = e[5],
              c = e[6],
              h = e[7],
              l = e[8],
              u = e[9],
              d = e[10],
              f = e[11],
              p = e[12],
              g = e[13],
              m = e[14],
              b = e[15],
              _ = n * a - i * o,
              y = n * c - r * o,
              v = n * h - s * o,
              w = i * c - r * a,
              x = i * h - s * a,
              E = r * h - s * c,
              P = l * g - u * p,
              T = l * m - d * p,
              A = l * b - f * p,
              S = u * m - d * g,
              M = u * b - f * g,
              C = d * b - f * m,
              O = _ * C - y * M + v * S + w * A - x * T + E * P;
            return O
              ? ((O = 1 / O),
                (t[0] = (a * C - c * M + h * S) * O),
                (t[1] = (r * M - i * C - s * S) * O),
                (t[2] = (g * E - m * x + b * w) * O),
                (t[3] = (d * x - u * E - f * w) * O),
                (t[4] = (c * A - o * C - h * T) * O),
                (t[5] = (n * C - r * A + s * T) * O),
                (t[6] = (m * v - p * E - b * y) * O),
                (t[7] = (l * E - d * v + f * y) * O),
                (t[8] = (o * M - a * A + h * P) * O),
                (t[9] = (i * A - n * M - s * P) * O),
                (t[10] = (p * x - g * v + b * _) * O),
                (t[11] = (u * v - l * x - f * _) * O),
                (t[12] = (a * T - o * S - c * P) * O),
                (t[13] = (n * S - i * T + r * P) * O),
                (t[14] = (g * y - p * w - m * _) * O),
                (t[15] = (l * w - u * y + d * _) * O),
                t)
              : null;
          }
          function xn(t, e, n) {
            var i = e[0],
              r = e[1],
              s = e[2],
              o = e[3],
              a = e[4],
              c = e[5],
              h = e[6],
              l = e[7],
              u = e[8],
              d = e[9],
              f = e[10],
              p = e[11],
              g = e[12],
              m = e[13],
              b = e[14],
              _ = e[15],
              y = n[0],
              v = n[1],
              w = n[2],
              x = n[3];
            return (
              (t[0] = y * i + v * a + w * u + x * g),
              (t[1] = y * r + v * c + w * d + x * m),
              (t[2] = y * s + v * h + w * f + x * b),
              (t[3] = y * o + v * l + w * p + x * _),
              (y = n[4]),
              (v = n[5]),
              (w = n[6]),
              (x = n[7]),
              (t[4] = y * i + v * a + w * u + x * g),
              (t[5] = y * r + v * c + w * d + x * m),
              (t[6] = y * s + v * h + w * f + x * b),
              (t[7] = y * o + v * l + w * p + x * _),
              (y = n[8]),
              (v = n[9]),
              (w = n[10]),
              (x = n[11]),
              (t[8] = y * i + v * a + w * u + x * g),
              (t[9] = y * r + v * c + w * d + x * m),
              (t[10] = y * s + v * h + w * f + x * b),
              (t[11] = y * o + v * l + w * p + x * _),
              (y = n[12]),
              (v = n[13]),
              (w = n[14]),
              (x = n[15]),
              (t[12] = y * i + v * a + w * u + x * g),
              (t[13] = y * r + v * c + w * d + x * m),
              (t[14] = y * s + v * h + w * f + x * b),
              (t[15] = y * o + v * l + w * p + x * _),
              t
            );
          }
          function En(t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              c,
              h,
              l,
              u,
              d,
              f,
              p,
              g = n[0],
              m = n[1],
              b = n[2];
            return (
              e === t
                ? ((t[12] = e[0] * g + e[4] * m + e[8] * b + e[12]),
                  (t[13] = e[1] * g + e[5] * m + e[9] * b + e[13]),
                  (t[14] = e[2] * g + e[6] * m + e[10] * b + e[14]),
                  (t[15] = e[3] * g + e[7] * m + e[11] * b + e[15]))
                : ((i = e[0]),
                  (r = e[1]),
                  (s = e[2]),
                  (o = e[3]),
                  (a = e[4]),
                  (c = e[5]),
                  (h = e[6]),
                  (l = e[7]),
                  (u = e[8]),
                  (d = e[9]),
                  (f = e[10]),
                  (p = e[11]),
                  (t[0] = i),
                  (t[1] = r),
                  (t[2] = s),
                  (t[3] = o),
                  (t[4] = a),
                  (t[5] = c),
                  (t[6] = h),
                  (t[7] = l),
                  (t[8] = u),
                  (t[9] = d),
                  (t[10] = f),
                  (t[11] = p),
                  (t[12] = i * g + a * m + u * b + e[12]),
                  (t[13] = r * g + c * m + d * b + e[13]),
                  (t[14] = s * g + h * m + f * b + e[14]),
                  (t[15] = o * g + l * m + p * b + e[15])),
              t
            );
          }
          function Pn(t, e, n) {
            var i = n[0],
              r = n[1],
              s = n[2];
            return (
              (t[0] = e[0] * i),
              (t[1] = e[1] * i),
              (t[2] = e[2] * i),
              (t[3] = e[3] * i),
              (t[4] = e[4] * r),
              (t[5] = e[5] * r),
              (t[6] = e[6] * r),
              (t[7] = e[7] * r),
              (t[8] = e[8] * s),
              (t[9] = e[9] * s),
              (t[10] = e[10] * s),
              (t[11] = e[11] * s),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15]),
              t
            );
          }
          function Tn(t, e, n) {
            var i = Math.sin(n),
              r = Math.cos(n),
              s = e[4],
              o = e[5],
              a = e[6],
              c = e[7],
              h = e[8],
              l = e[9],
              u = e[10],
              d = e[11];
            return (
              e !== t &&
                ((t[0] = e[0]),
                (t[1] = e[1]),
                (t[2] = e[2]),
                (t[3] = e[3]),
                (t[12] = e[12]),
                (t[13] = e[13]),
                (t[14] = e[14]),
                (t[15] = e[15])),
              (t[4] = s * r + h * i),
              (t[5] = o * r + l * i),
              (t[6] = a * r + u * i),
              (t[7] = c * r + d * i),
              (t[8] = h * r - s * i),
              (t[9] = l * r - o * i),
              (t[10] = u * r - a * i),
              (t[11] = d * r - c * i),
              t
            );
          }
          function An(t, e, n) {
            var i = Math.sin(n),
              r = Math.cos(n),
              s = e[0],
              o = e[1],
              a = e[2],
              c = e[3],
              h = e[4],
              l = e[5],
              u = e[6],
              d = e[7];
            return (
              e !== t &&
                ((t[8] = e[8]),
                (t[9] = e[9]),
                (t[10] = e[10]),
                (t[11] = e[11]),
                (t[12] = e[12]),
                (t[13] = e[13]),
                (t[14] = e[14]),
                (t[15] = e[15])),
              (t[0] = s * r + h * i),
              (t[1] = o * r + l * i),
              (t[2] = a * r + u * i),
              (t[3] = c * r + d * i),
              (t[4] = h * r - s * i),
              (t[5] = l * r - o * i),
              (t[6] = u * r - a * i),
              (t[7] = d * r - c * i),
              t
            );
          }
          function Sn(t, e, n, i, r) {
            var s,
              o = 1 / Math.tan(e / 2);
            return (
              (t[0] = o / n),
              (t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[4] = 0),
              (t[5] = o),
              (t[6] = 0),
              (t[7] = 0),
              (t[8] = 0),
              (t[9] = 0),
              (t[11] = -1),
              (t[12] = 0),
              (t[13] = 0),
              (t[15] = 0),
              null != r && r !== 1 / 0
                ? ((s = 1 / (i - r)),
                  (t[10] = (r + i) * s),
                  (t[14] = 2 * r * i * s))
                : ((t[10] = -1), (t[14] = -2 * i)),
              t
            );
          }
          function Mn(t, e) {
            var n = t[0],
              i = t[1],
              r = t[2],
              s = t[3],
              o = t[4],
              a = t[5],
              c = t[6],
              h = t[7],
              l = t[8],
              u = t[9],
              d = t[10],
              f = t[11],
              p = t[12],
              g = t[13],
              m = t[14],
              b = t[15],
              _ = e[0],
              y = e[1],
              v = e[2],
              w = e[3],
              x = e[4],
              E = e[5],
              P = e[6],
              T = e[7],
              A = e[8],
              S = e[9],
              M = e[10],
              C = e[11],
              O = e[12],
              L = e[13],
              I = e[14],
              R = e[15];
            return (
              Math.abs(n - _) <= cn * Math.max(1, Math.abs(n), Math.abs(_)) &&
              Math.abs(i - y) <= cn * Math.max(1, Math.abs(i), Math.abs(y)) &&
              Math.abs(r - v) <= cn * Math.max(1, Math.abs(r), Math.abs(v)) &&
              Math.abs(s - w) <= cn * Math.max(1, Math.abs(s), Math.abs(w)) &&
              Math.abs(o - x) <= cn * Math.max(1, Math.abs(o), Math.abs(x)) &&
              Math.abs(a - E) <= cn * Math.max(1, Math.abs(a), Math.abs(E)) &&
              Math.abs(c - P) <= cn * Math.max(1, Math.abs(c), Math.abs(P)) &&
              Math.abs(h - T) <= cn * Math.max(1, Math.abs(h), Math.abs(T)) &&
              Math.abs(l - A) <= cn * Math.max(1, Math.abs(l), Math.abs(A)) &&
              Math.abs(u - S) <= cn * Math.max(1, Math.abs(u), Math.abs(S)) &&
              Math.abs(d - M) <= cn * Math.max(1, Math.abs(d), Math.abs(M)) &&
              Math.abs(f - C) <= cn * Math.max(1, Math.abs(f), Math.abs(C)) &&
              Math.abs(p - O) <= cn * Math.max(1, Math.abs(p), Math.abs(O)) &&
              Math.abs(g - L) <= cn * Math.max(1, Math.abs(g), Math.abs(L)) &&
              Math.abs(m - I) <= cn * Math.max(1, Math.abs(m), Math.abs(I)) &&
              Math.abs(b - R) <= cn * Math.max(1, Math.abs(b), Math.abs(R))
            );
          }
          function Cn(t, e, n) {
            return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), t;
          }
          function On(t, e) {
            return (t[0] = -e[0]), (t[1] = -e[1]), t;
          }
          function Ln(t, e, n, i) {
            var r = e[0],
              s = e[1];
            return (t[0] = r + i * (n[0] - r)), (t[1] = s + i * (n[1] - s)), t;
          }
          function In(t, e, n) {
            var i = e[0],
              r = e[1],
              s = e[2],
              o = e[3];
            return (
              (t[0] = n[0] * i + n[4] * r + n[8] * s + n[12] * o),
              (t[1] = n[1] * i + n[5] * r + n[9] * s + n[13] * o),
              (t[2] = n[2] * i + n[6] * r + n[10] * s + n[14] * o),
              (t[3] = n[3] * i + n[7] * r + n[11] * s + n[15] * o),
              t
            );
          }
          !(function () {
            var t = new hn(2);
            hn != Float32Array && ((t[0] = 0), (t[1] = 0));
          })(),
            (function () {
              var t = new hn(4);
              hn != Float32Array &&
                ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0));
            })();
          const Rn = Object.freeze([
              1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ]),
            kn = Object.freeze([
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ]),
            jn = Object.freeze({
              COL0ROW0: 0,
              COL0ROW1: 1,
              COL0ROW2: 2,
              COL0ROW3: 3,
              COL1ROW0: 4,
              COL1ROW1: 5,
              COL1ROW2: 6,
              COL1ROW3: 7,
              COL2ROW0: 8,
              COL2ROW1: 9,
              COL2ROW2: 10,
              COL2ROW3: 11,
              COL3ROW0: 12,
              COL3ROW1: 13,
              COL3ROW2: 14,
              COL3ROW3: 15,
            }),
            Fn = {};
          class Bn extends vn {
            static get IDENTITY() {
              return (
                (Fn.IDENTITY = Fn.IDENTITY || Object.freeze(new Bn(Rn))),
                Fn.IDENTITY
              );
            }
            static get ZERO() {
              return (Fn.ZERO = Fn.ZERO || Object.freeze(new Bn(kn))), Fn.ZERO;
            }
            get INDICES() {
              return jn;
            }
            get ELEMENTS() {
              return 16;
            }
            get RANK() {
              return 4;
            }
            constructor(t) {
              super(
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0
              ),
                1 === arguments.length && Array.isArray(t)
                  ? this.copy(t)
                  : this.identity();
            }
            copy(t) {
              return (
                (this[0] = t[0]),
                (this[1] = t[1]),
                (this[2] = t[2]),
                (this[3] = t[3]),
                (this[4] = t[4]),
                (this[5] = t[5]),
                (this[6] = t[6]),
                (this[7] = t[7]),
                (this[8] = t[8]),
                (this[9] = t[9]),
                (this[10] = t[10]),
                (this[11] = t[11]),
                (this[12] = t[12]),
                (this[13] = t[13]),
                (this[14] = t[14]),
                (this[15] = t[15]),
                this.check()
              );
            }
            set(t, e, n, i, r, s, o, a, c, h, l, u, d, f, p, g) {
              return (
                (this[0] = t),
                (this[1] = e),
                (this[2] = n),
                (this[3] = i),
                (this[4] = r),
                (this[5] = s),
                (this[6] = o),
                (this[7] = a),
                (this[8] = c),
                (this[9] = h),
                (this[10] = l),
                (this[11] = u),
                (this[12] = d),
                (this[13] = f),
                (this[14] = p),
                (this[15] = g),
                this.check()
              );
            }
            setRowMajor(t, e, n, i, r, s, o, a, c, h, l, u, d, f, p, g) {
              return (
                (this[0] = t),
                (this[1] = r),
                (this[2] = c),
                (this[3] = d),
                (this[4] = e),
                (this[5] = s),
                (this[6] = h),
                (this[7] = f),
                (this[8] = n),
                (this[9] = o),
                (this[10] = l),
                (this[11] = p),
                (this[12] = i),
                (this[13] = a),
                (this[14] = u),
                (this[15] = g),
                this.check()
              );
            }
            toRowMajor(t) {
              return (
                (t[0] = this[0]),
                (t[1] = this[4]),
                (t[2] = this[8]),
                (t[3] = this[12]),
                (t[4] = this[1]),
                (t[5] = this[5]),
                (t[6] = this[9]),
                (t[7] = this[13]),
                (t[8] = this[2]),
                (t[9] = this[6]),
                (t[10] = this[10]),
                (t[11] = this[14]),
                (t[12] = this[3]),
                (t[13] = this[7]),
                (t[14] = this[11]),
                (t[15] = this[15]),
                t
              );
            }
            identity() {
              return this.copy(Rn);
            }
            fromQuaternion(t) {
              return (
                (function (t, e) {
                  var n = e[0],
                    i = e[1],
                    r = e[2],
                    s = e[3],
                    o = n + n,
                    a = i + i,
                    c = r + r,
                    h = n * o,
                    l = i * o,
                    u = i * a,
                    d = r * o,
                    f = r * a,
                    p = r * c,
                    g = s * o,
                    m = s * a,
                    b = s * c;
                  (t[0] = 1 - u - p),
                    (t[1] = l + b),
                    (t[2] = d - m),
                    (t[3] = 0),
                    (t[4] = l - b),
                    (t[5] = 1 - h - p),
                    (t[6] = f + g),
                    (t[7] = 0),
                    (t[8] = d + m),
                    (t[9] = f - g),
                    (t[10] = 1 - h - u),
                    (t[11] = 0),
                    (t[12] = 0),
                    (t[13] = 0),
                    (t[14] = 0),
                    (t[15] = 1);
                })(this, t),
                this.check()
              );
            }
            frustum({ left: t, right: e, bottom: n, top: i, near: r, far: s }) {
              return (
                s === 1 / 0
                  ? Bn._computeInfinitePerspectiveOffCenter(this, t, e, n, i, r)
                  : (function (t, e, n, i, r, s, o) {
                      var a = 1 / (n - e),
                        c = 1 / (r - i),
                        h = 1 / (s - o);
                      (t[0] = 2 * s * a),
                        (t[1] = 0),
                        (t[2] = 0),
                        (t[3] = 0),
                        (t[4] = 0),
                        (t[5] = 2 * s * c),
                        (t[6] = 0),
                        (t[7] = 0),
                        (t[8] = (n + e) * a),
                        (t[9] = (r + i) * c),
                        (t[10] = (o + s) * h),
                        (t[11] = -1),
                        (t[12] = 0),
                        (t[13] = 0),
                        (t[14] = o * s * 2 * h),
                        (t[15] = 0);
                    })(this, t, e, n, i, r, s),
                this.check()
              );
            }
            static _computeInfinitePerspectiveOffCenter(t, e, n, i, r, s) {
              const o = (2 * s) / (n - e),
                a = (2 * s) / (r - i),
                c = (n + e) / (n - e),
                h = (r + i) / (r - i),
                l = -2 * s;
              return (
                (t[0] = o),
                (t[1] = 0),
                (t[2] = 0),
                (t[3] = 0),
                (t[4] = 0),
                (t[5] = a),
                (t[6] = 0),
                (t[7] = 0),
                (t[8] = c),
                (t[9] = h),
                (t[10] = -1),
                (t[11] = -1),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = l),
                (t[15] = 0),
                t
              );
            }
            lookAt(t, e, n) {
              return (
                1 === arguments.length && ({ eye: t, center: e, up: n } = t),
                (function (t, e, n, i) {
                  var r,
                    s,
                    o,
                    a,
                    c,
                    h,
                    l,
                    u,
                    d,
                    f,
                    p = e[0],
                    g = e[1],
                    m = e[2],
                    b = i[0],
                    _ = i[1],
                    y = i[2],
                    v = n[0],
                    w = n[1],
                    x = n[2];
                  Math.abs(p - v) < cn &&
                  Math.abs(g - w) < cn &&
                  Math.abs(m - x) < cn
                    ? (function (t) {
                        (t[0] = 1),
                          (t[1] = 0),
                          (t[2] = 0),
                          (t[3] = 0),
                          (t[4] = 0),
                          (t[5] = 1),
                          (t[6] = 0),
                          (t[7] = 0),
                          (t[8] = 0),
                          (t[9] = 0),
                          (t[10] = 1),
                          (t[11] = 0),
                          (t[12] = 0),
                          (t[13] = 0),
                          (t[14] = 0),
                          (t[15] = 1);
                      })(t)
                    : ((l = p - v),
                      (u = g - w),
                      (d = m - x),
                      (r =
                        _ * (d *= f = 1 / Math.hypot(l, u, d)) - y * (u *= f)),
                      (s = y * (l *= f) - b * d),
                      (o = b * u - _ * l),
                      (f = Math.hypot(r, s, o))
                        ? ((r *= f = 1 / f), (s *= f), (o *= f))
                        : ((r = 0), (s = 0), (o = 0)),
                      (a = u * o - d * s),
                      (c = d * r - l * o),
                      (h = l * s - u * r),
                      (f = Math.hypot(a, c, h))
                        ? ((a *= f = 1 / f), (c *= f), (h *= f))
                        : ((a = 0), (c = 0), (h = 0)),
                      (t[0] = r),
                      (t[1] = a),
                      (t[2] = l),
                      (t[3] = 0),
                      (t[4] = s),
                      (t[5] = c),
                      (t[6] = u),
                      (t[7] = 0),
                      (t[8] = o),
                      (t[9] = h),
                      (t[10] = d),
                      (t[11] = 0),
                      (t[12] = -(r * p + s * g + o * m)),
                      (t[13] = -(a * p + c * g + h * m)),
                      (t[14] = -(l * p + u * g + d * m)),
                      (t[15] = 1));
                })(this, t, (e = e || [0, 0, 0]), (n = n || [0, 1, 0])),
                this.check()
              );
            }
            ortho({
              left: t,
              right: e,
              bottom: n,
              top: i,
              near: r = 0.1,
              far: s = 500,
            }) {
              return (
                (function (t, e, n, i, r, s, o) {
                  var a = 1 / (e - n),
                    c = 1 / (i - r),
                    h = 1 / (s - o);
                  (t[0] = -2 * a),
                    (t[1] = 0),
                    (t[2] = 0),
                    (t[3] = 0),
                    (t[4] = 0),
                    (t[5] = -2 * c),
                    (t[6] = 0),
                    (t[7] = 0),
                    (t[8] = 0),
                    (t[9] = 0),
                    (t[10] = 2 * h),
                    (t[11] = 0),
                    (t[12] = (e + n) * a),
                    (t[13] = (r + i) * c),
                    (t[14] = (o + s) * h),
                    (t[15] = 1);
                })(this, t, e, n, i, r, s),
                this.check()
              );
            }
            orthographic({
              fovy: t = (45 * Math.PI) / 180,
              aspect: e = 1,
              focalDistance: n = 1,
              near: i = 0.1,
              far: r = 500,
            }) {
              if (t > 2 * Math.PI) throw Error("radians");
              const s = t / 2,
                o = n * Math.tan(s),
                a = o * e;
              return new Bn().ortho({
                left: -a,
                right: a,
                bottom: -o,
                top: o,
                near: i,
                far: r,
              });
            }
            perspective({
              fovy: t,
              fov: e = (45 * Math.PI) / 180,
              aspect: n = 1,
              near: i = 0.1,
              far: r = 500,
            } = {}) {
              if ((t = t || e) > 2 * Math.PI) throw Error("radians");
              return Sn(this, t, n, i, r), this.check();
            }
            determinant() {
              return (
                (e = (t = this)[0]),
                (n = t[1]),
                (i = t[2]),
                (r = t[3]),
                (s = t[4]),
                (o = t[5]),
                (a = t[6]),
                (c = t[7]),
                (h = t[8]),
                (l = t[9]),
                (u = t[10]),
                (d = t[11]),
                (f = t[12]),
                (p = t[13]),
                (g = t[14]),
                (e * o - n * s) * (u * (m = t[15]) - d * g) -
                  (e * a - i * s) * (l * m - d * p) +
                  (e * c - r * s) * (l * g - u * p) +
                  (n * a - i * o) * (h * m - d * f) -
                  (n * c - r * o) * (h * g - u * f) +
                  (i * c - r * a) * (h * p - l * f)
              );
              var t, e, n, i, r, s, o, a, c, h, l, u, d, f, p, g, m;
            }
            getScale(t = [-0, -0, -0]) {
              return (
                (t[0] = Math.sqrt(
                  this[0] * this[0] + this[1] * this[1] + this[2] * this[2]
                )),
                (t[1] = Math.sqrt(
                  this[4] * this[4] + this[5] * this[5] + this[6] * this[6]
                )),
                (t[2] = Math.sqrt(
                  this[8] * this[8] + this[9] * this[9] + this[10] * this[10]
                )),
                t
              );
            }
            getTranslation(t = [-0, -0, -0]) {
              return (t[0] = this[12]), (t[1] = this[13]), (t[2] = this[14]), t;
            }
            getRotation(
              t = [
                -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,
              ],
              e = null
            ) {
              const n = this.getScale(e || [-0, -0, -0]),
                i = 1 / n[0],
                r = 1 / n[1],
                s = 1 / n[2];
              return (
                (t[0] = this[0] * i),
                (t[1] = this[1] * r),
                (t[2] = this[2] * s),
                (t[3] = 0),
                (t[4] = this[4] * i),
                (t[5] = this[5] * r),
                (t[6] = this[6] * s),
                (t[7] = 0),
                (t[8] = this[8] * i),
                (t[9] = this[9] * r),
                (t[10] = this[10] * s),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                t
              );
            }
            getRotationMatrix3(
              t = [-0, -0, -0, -0, -0, -0, -0, -0, -0],
              e = null
            ) {
              const n = this.getScale(e || [-0, -0, -0]),
                i = 1 / n[0],
                r = 1 / n[1],
                s = 1 / n[2];
              return (
                (t[0] = this[0] * i),
                (t[1] = this[1] * r),
                (t[2] = this[2] * s),
                (t[3] = this[4] * i),
                (t[4] = this[5] * r),
                (t[5] = this[6] * s),
                (t[6] = this[8] * i),
                (t[7] = this[9] * r),
                (t[8] = this[10] * s),
                t
              );
            }
            transpose() {
              return (
                (function (t, e) {
                  if (t === e) {
                    var n = e[1],
                      i = e[2],
                      r = e[3],
                      s = e[6],
                      o = e[7],
                      a = e[11];
                    (t[1] = e[4]),
                      (t[2] = e[8]),
                      (t[3] = e[12]),
                      (t[4] = n),
                      (t[6] = e[9]),
                      (t[7] = e[13]),
                      (t[8] = i),
                      (t[9] = s),
                      (t[11] = e[14]),
                      (t[12] = r),
                      (t[13] = o),
                      (t[14] = a);
                  } else
                    (t[0] = e[0]),
                      (t[1] = e[4]),
                      (t[2] = e[8]),
                      (t[3] = e[12]),
                      (t[4] = e[1]),
                      (t[5] = e[5]),
                      (t[6] = e[9]),
                      (t[7] = e[13]),
                      (t[8] = e[2]),
                      (t[9] = e[6]),
                      (t[10] = e[10]),
                      (t[11] = e[14]),
                      (t[12] = e[3]),
                      (t[13] = e[7]),
                      (t[14] = e[11]),
                      (t[15] = e[15]);
                })(this, this),
                this.check()
              );
            }
            invert() {
              return wn(this, this), this.check();
            }
            multiplyLeft(t) {
              return xn(this, t, this), this.check();
            }
            multiplyRight(t) {
              return xn(this, this, t), this.check();
            }
            rotateX(t) {
              return Tn(this, this, t), this.check();
            }
            rotateY(t) {
              return (
                (function (t, e, n) {
                  var i = Math.sin(n),
                    r = Math.cos(n),
                    s = e[0],
                    o = e[1],
                    a = e[2],
                    c = e[3],
                    h = e[8],
                    l = e[9],
                    u = e[10],
                    d = e[11];
                  e !== t &&
                    ((t[4] = e[4]),
                    (t[5] = e[5]),
                    (t[6] = e[6]),
                    (t[7] = e[7]),
                    (t[12] = e[12]),
                    (t[13] = e[13]),
                    (t[14] = e[14]),
                    (t[15] = e[15])),
                    (t[0] = s * r - h * i),
                    (t[1] = o * r - l * i),
                    (t[2] = a * r - u * i),
                    (t[3] = c * r - d * i),
                    (t[8] = s * i + h * r),
                    (t[9] = o * i + l * r),
                    (t[10] = a * i + u * r),
                    (t[11] = c * i + d * r);
                })(this, this, t),
                this.check()
              );
            }
            rotateZ(t) {
              return An(this, this, t), this.check();
            }
            rotateXYZ([t, e, n]) {
              return this.rotateX(t).rotateY(e).rotateZ(n);
            }
            rotateAxis(t, e) {
              return (
                (function (t, e, n, i) {
                  var r,
                    s,
                    o,
                    a,
                    c,
                    h,
                    l,
                    u,
                    d,
                    f,
                    p,
                    g,
                    m,
                    b,
                    _,
                    y,
                    v,
                    w,
                    x,
                    E,
                    P,
                    T,
                    A,
                    S,
                    M = i[0],
                    C = i[1],
                    O = i[2],
                    L = Math.hypot(M, C, O);
                  L < cn ||
                    ((M *= L = 1 / L),
                    (C *= L),
                    (O *= L),
                    (r = Math.sin(n)),
                    (o = 1 - (s = Math.cos(n))),
                    (a = e[0]),
                    (c = e[1]),
                    (h = e[2]),
                    (l = e[3]),
                    (u = e[4]),
                    (d = e[5]),
                    (f = e[6]),
                    (p = e[7]),
                    (g = e[8]),
                    (m = e[9]),
                    (b = e[10]),
                    (_ = e[11]),
                    (y = M * M * o + s),
                    (v = C * M * o + O * r),
                    (w = O * M * o - C * r),
                    (x = M * C * o - O * r),
                    (E = C * C * o + s),
                    (P = O * C * o + M * r),
                    (T = M * O * o + C * r),
                    (A = C * O * o - M * r),
                    (S = O * O * o + s),
                    (t[0] = a * y + u * v + g * w),
                    (t[1] = c * y + d * v + m * w),
                    (t[2] = h * y + f * v + b * w),
                    (t[3] = l * y + p * v + _ * w),
                    (t[4] = a * x + u * E + g * P),
                    (t[5] = c * x + d * E + m * P),
                    (t[6] = h * x + f * E + b * P),
                    (t[7] = l * x + p * E + _ * P),
                    (t[8] = a * T + u * A + g * S),
                    (t[9] = c * T + d * A + m * S),
                    (t[10] = h * T + f * A + b * S),
                    (t[11] = l * T + p * A + _ * S),
                    e !== t &&
                      ((t[12] = e[12]),
                      (t[13] = e[13]),
                      (t[14] = e[14]),
                      (t[15] = e[15])));
                })(this, this, t, e),
                this.check()
              );
            }
            scale(t) {
              return (
                Array.isArray(t)
                  ? Pn(this, this, t)
                  : Pn(this, this, [t, t, t]),
                this.check()
              );
            }
            translate(t) {
              return En(this, this, t), this.check();
            }
            transform(t, e) {
              return 4 === t.length
                ? (rn((e = In(e || [-0, -0, -0, -0], t, this)), 4), e)
                : this.transformAsPoint(t, e);
            }
            transformAsPoint(t, e) {
              const { length: n } = t;
              switch (n) {
                case 2:
                  e = (function (t, e, n) {
                    var i = e[0],
                      r = e[1];
                    return (
                      (t[0] = n[0] * i + n[4] * r + n[12]),
                      (t[1] = n[1] * i + n[5] * r + n[13]),
                      t
                    );
                  })(e || [-0, -0], t, this);
                  break;
                case 3:
                  e = ln(e || [-0, -0, -0], t, this);
                  break;
                default:
                  throw new Error("Illegal vector");
              }
              return rn(e, t.length), e;
            }
            transformAsVector(t, e) {
              switch (t.length) {
                case 2:
                  e = (function (t, e, n) {
                    const i = e[0],
                      r = e[1],
                      s = n[3] * i + n[7] * r || 1;
                    return (
                      (t[0] = (n[0] * i + n[4] * r) / s),
                      (t[1] = (n[1] * i + n[5] * r) / s),
                      t
                    );
                  })(e || [-0, -0], t, this);
                  break;
                case 3:
                  e = dn(e || [-0, -0, -0], t, this);
                  break;
                default:
                  throw new Error("Illegal vector");
              }
              return rn(e, t.length), e;
            }
            makeRotationX(t) {
              return this.identity().rotateX(t);
            }
            makeTranslation(t, e, n) {
              return this.identity().translate([t, e, n]);
            }
            transformPoint(t, e) {
              return (
                on("Matrix4.transformPoint", "3.0"), this.transformAsPoint(t, e)
              );
            }
            transformVector(t, e) {
              return (
                on("Matrix4.transformVector", "3.0"),
                this.transformAsPoint(t, e)
              );
            }
            transformDirection(t, e) {
              return (
                on("Matrix4.transformDirection", "3.0"),
                this.transformAsVector(t, e)
              );
            }
          }
          function Dn(t, e) {
            const n = In([], e, t);
            return (
              (function (t, e, n) {
                (t[0] = e[0] * n),
                  (t[1] = e[1] * n),
                  (t[2] = e[2] * n),
                  (t[3] = e[3] * n);
              })(n, n, 1 / n[3]),
              n
            );
          }
          function Nn(t, e) {
            const n = t % e;
            return n < 0 ? e + n : n;
          }
          const zn =
            Math.log2 ||
            function (t) {
              return Math.log(t) * Math.LOG2E;
            };
          function Vn(t, e) {
            if (!t)
              throw new Error(e || "@math.gl/web-mercator: assertion failed.");
          }
          const Un = Math.PI,
            Gn = Un / 4,
            $n = Un / 180,
            Wn = 180 / Un,
            Hn = 512;
          function Xn([t, e]) {
            Vn(Number.isFinite(t)),
              Vn(Number.isFinite(e) && e >= -90 && e <= 90, "invalid latitude");
            const n = e * $n;
            return [
              (Hn * (t * $n + Un)) / (2 * Un),
              (Hn * (Un + Math.log(Math.tan(Gn + 0.5 * n)))) / (2 * Un),
            ];
          }
          function qn([t, e]) {
            const n = (t / Hn) * (2 * Un) - Un,
              i = 2 * (Math.atan(Math.exp((e / Hn) * (2 * Un) - Un)) - Gn);
            return [n * Wn, i * Wn];
          }
          function Yn({ latitude: t, longitude: e, highPrecision: n = !1 }) {
            Vn(Number.isFinite(t) && Number.isFinite(e));
            const i = {},
              r = Math.cos(t * $n),
              s = 512 / 360,
              o = s / r,
              a = 12790407194604047e-21 / r;
            if (
              ((i.unitsPerMeter = [a, a, a]),
              (i.metersPerUnit = [1 / a, 1 / a, 1 / a]),
              (i.unitsPerDegree = [s, o, a]),
              (i.degreesPerUnit = [0.703125, 1 / o, 1 / a]),
              n)
            ) {
              const e = ($n * Math.tan(t * $n)) / r,
                n = (s * e) / 2,
                c = 12790407194604047e-21 * e,
                h = (c / o) * a;
              (i.unitsPerDegree2 = [0, n, c]), (i.unitsPerMeter2 = [h, 0, h]);
            }
            return i;
          }
          function Zn(t, e) {
            const [n, i, r] = t,
              [s, o, a] = e,
              { unitsPerMeter: c, unitsPerMeter2: h } = Yn({
                longitude: n,
                latitude: i,
                highPrecision: !0,
              }),
              l = Xn(t);
            (l[0] += s * (c[0] + h[0] * o)), (l[1] += o * (c[1] + h[1] * o));
            const u = qn(l),
              d = (r || 0) + (a || 0);
            return Number.isFinite(r) || Number.isFinite(a)
              ? [u[0], u[1], d]
              : u;
          }
          function Kn({
            height: t,
            pitch: e,
            bearing: n,
            altitude: i,
            scale: r,
            center: s = null,
          }) {
            const o = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            return (
              En(o, o, [0, 0, -i]),
              Tn(o, o, -e * $n),
              An(o, o, n * $n),
              Pn(o, o, [(r /= t), r, r]),
              s &&
                En(
                  o,
                  o,
                  (function (t, e) {
                    return (t[0] = -e[0]), (t[1] = -e[1]), (t[2] = -e[2]), t;
                  })([], s)
                ),
              o
            );
          }
          function Qn({
            width: t,
            height: e,
            fovy: n = Jn(1.5),
            altitude: i,
            pitch: r = 0,
            nearZMultiplier: s = 1,
            farZMultiplier: o = 1,
          }) {
            void 0 !== i && (n = Jn(i));
            const a = 0.5 * n * $n,
              c = ti(n),
              h = r * $n,
              l =
                (Math.sin(a) * c) /
                Math.sin(
                  Math.min(Math.max(Math.PI / 2 - h - a, 0.01), Math.PI - 0.01)
                );
            return {
              fov: 2 * a,
              aspect: t / e,
              focalDistance: c,
              near: s,
              far: (Math.sin(h) * l + c) * o,
            };
          }
          function Jn(t) {
            return 2 * Math.atan(0.5 / t) * Wn;
          }
          function ti(t) {
            return 0.5 / Math.tan(0.5 * t * $n);
          }
          function ei(t, e) {
            const [n, i, r = 0] = t;
            return (
              Vn(
                Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r)
              ),
              Dn(e, [n, i, r, 1])
            );
          }
          function ni(t, e, n = 0) {
            const [i, r, s] = t;
            if (
              (Vn(
                Number.isFinite(i) && Number.isFinite(r),
                "invalid pixel coordinate"
              ),
              Number.isFinite(s))
            )
              return Dn(e, [i, r, s, 1]);
            const o = Dn(e, [i, r, 0, 1]),
              a = Dn(e, [i, r, 1, 1]),
              c = o[2],
              h = a[2];
            return Ln([], o, a, c === h ? 0 : ((n || 0) - c) / (h - c));
          }
          function ii({
            width: t,
            height: e,
            bounds: n,
            minExtent: i = 0,
            maxZoom: r = 24,
            padding: s = 0,
            offset: o = [0, 0],
          }) {
            const [[a, c], [h, l]] = n;
            Number.isFinite(s)
              ? (s = { top: s, bottom: s, left: s, right: s })
              : Vn(
                  Number.isFinite(s.top) &&
                    Number.isFinite(s.bottom) &&
                    Number.isFinite(s.left) &&
                    Number.isFinite(s.right)
                );
            const u = new ai({
                width: t,
                height: e,
                longitude: 0,
                latitude: 0,
                zoom: 0,
              }),
              d = u.project([a, l]),
              f = u.project([h, c]),
              p = [
                Math.max(Math.abs(f[0] - d[0]), i),
                Math.max(Math.abs(f[1] - d[1]), i),
              ],
              g = [
                t - s.left - s.right - 2 * Math.abs(o[0]),
                e - s.top - s.bottom - 2 * Math.abs(o[1]),
              ];
            Vn(g[0] > 0 && g[1] > 0);
            const m = g[0] / p[0],
              b = g[1] / p[1],
              _ = (s.right - s.left) / 2 / m,
              y = (s.bottom - s.top) / 2 / b,
              v = [(f[0] + d[0]) / 2 + _, (f[1] + d[1]) / 2 + y],
              w = u.unproject(v),
              x = Math.min(r, u.zoom + zn(Math.abs(Math.min(m, b))));
            return (
              Vn(Number.isFinite(x)),
              { longitude: w[0], latitude: w[1], zoom: x }
            );
          }
          const ri = Math.PI / 180;
          function si(t, e = 0) {
            const { width: n, height: i, unproject: r } = t,
              s = { targetZ: e },
              o = r([0, i], s),
              a = r([n, i], s);
            let c, h;
            return (
              (t.fovy ? 0.5 * t.fovy * ri : Math.atan(0.5 / t.altitude)) >
              (90 - t.pitch) * ri - 0.01
                ? ((c = oi(t, 0, e)), (h = oi(t, n, e)))
                : ((c = r([0, 0], s)), (h = r([n, 0], s))),
              [o, a, h, c]
            );
          }
          function oi(t, e, n) {
            const { pixelUnprojectionMatrix: i } = t,
              r = Dn(i, [e, 0, 1, 1]),
              s = Dn(i, [e, t.height, 1, 1]),
              o = qn(
                Ln(
                  [],
                  r,
                  s,
                  (n * t.distanceScales.unitsPerMeter[2] - r[2]) / (s[2] - r[2])
                )
              );
            return (o[2] = n), o;
          }
          class ai {
            constructor(
              {
                width: t,
                height: e,
                latitude: n = 0,
                longitude: i = 0,
                zoom: r = 0,
                pitch: s = 0,
                bearing: o = 0,
                altitude: a = null,
                fovy: c = null,
                position: h = null,
                nearZMultiplier: l = 0.02,
                farZMultiplier: u = 1.01,
              } = { width: 1, height: 1 }
            ) {
              (t = t || 1),
                (e = e || 1),
                null === c && null === a
                  ? (c = Jn((a = 1.5)))
                  : null === c
                  ? (c = Jn(a))
                  : null === a && (a = ti(c));
              const d = (function (t) {
                return Math.pow(2, t);
              })(r);
              a = Math.max(0.75, a);
              const f = Yn({ longitude: i, latitude: n }),
                p = Xn([i, n]);
              (p[2] = 0),
                h &&
                  (function (t, e, n) {
                    (t[0] = e[0] + n[0]),
                      (t[1] = e[1] + n[1]),
                      (t[2] = e[2] + n[2]);
                  })(
                    p,
                    p,
                    (function (t, e, n) {
                      return (
                        (t[0] = e[0] * n[0]),
                        (t[1] = e[1] * n[1]),
                        (t[2] = e[2] * n[2]),
                        t
                      );
                    })([], h, f.unitsPerMeter)
                  ),
                (this.projectionMatrix = (function ({
                  width: t,
                  height: e,
                  pitch: n,
                  altitude: i,
                  fovy: r,
                  nearZMultiplier: s,
                  farZMultiplier: o,
                }) {
                  const {
                    fov: a,
                    aspect: c,
                    near: h,
                    far: l,
                  } = Qn({
                    width: t,
                    height: e,
                    altitude: i,
                    fovy: r,
                    pitch: n,
                    nearZMultiplier: s,
                    farZMultiplier: o,
                  });
                  return Sn([], a, c, h, l);
                })({
                  width: t,
                  height: e,
                  pitch: s,
                  fovy: c,
                  nearZMultiplier: l,
                  farZMultiplier: u,
                })),
                (this.viewMatrix = Kn({
                  height: e,
                  scale: d,
                  center: p,
                  pitch: s,
                  bearing: o,
                  altitude: a,
                })),
                (this.width = t),
                (this.height = e),
                (this.scale = d),
                (this.latitude = n),
                (this.longitude = i),
                (this.zoom = r),
                (this.pitch = s),
                (this.bearing = o),
                (this.altitude = a),
                (this.fovy = c),
                (this.center = p),
                (this.meterOffset = h || [0, 0, 0]),
                (this.distanceScales = f),
                this._initMatrices(),
                (this.equals = this.equals.bind(this)),
                (this.project = this.project.bind(this)),
                (this.unproject = this.unproject.bind(this)),
                (this.projectPosition = this.projectPosition.bind(this)),
                (this.unprojectPosition = this.unprojectPosition.bind(this)),
                Object.freeze(this);
            }
            _initMatrices() {
              const {
                  width: t,
                  height: e,
                  projectionMatrix: n,
                  viewMatrix: i,
                } = this,
                r = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              xn(r, r, n), xn(r, r, i), (this.viewProjectionMatrix = r);
              const s = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              Pn(s, s, [t / 2, -e / 2, 1]), En(s, s, [1, -1, 0]), xn(s, s, r);
              const o = wn([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], s);
              if (!o) throw new Error("Pixel project matrix not invertible");
              (this.pixelProjectionMatrix = s),
                (this.pixelUnprojectionMatrix = o);
            }
            equals(t) {
              return (
                t instanceof ai &&
                t.width === this.width &&
                t.height === this.height &&
                Mn(t.projectionMatrix, this.projectionMatrix) &&
                Mn(t.viewMatrix, this.viewMatrix)
              );
            }
            project(t, { topLeft: e = !0 } = {}) {
              const n = ei(this.projectPosition(t), this.pixelProjectionMatrix),
                [i, r] = n,
                s = e ? r : this.height - r;
              return 2 === t.length ? [i, s] : [i, s, n[2]];
            }
            unproject(t, { topLeft: e = !0, targetZ: n } = {}) {
              const [i, r, s] = t,
                o = e ? r : this.height - r,
                a = n && n * this.distanceScales.unitsPerMeter[2],
                c = ni([i, o, s], this.pixelUnprojectionMatrix, a),
                [h, l, u] = this.unprojectPosition(c);
              return Number.isFinite(s)
                ? [h, l, u]
                : Number.isFinite(n)
                ? [h, l, n]
                : [h, l];
            }
            projectPosition(t) {
              const [e, n] = Xn(t);
              return [e, n, (t[2] || 0) * this.distanceScales.unitsPerMeter[2]];
            }
            unprojectPosition(t) {
              const [e, n] = qn(t);
              return [e, n, (t[2] || 0) * this.distanceScales.metersPerUnit[2]];
            }
            projectFlat(t) {
              return Xn(t);
            }
            unprojectFlat(t) {
              return qn(t);
            }
            getMapCenterByLngLatPosition({ lngLat: t, pos: e }) {
              const n = ni(e, this.pixelUnprojectionMatrix),
                i = Cn([], Xn(t), On([], n));
              return qn(Cn([], this.center, i));
            }
            getLocationAtPoint({ lngLat: t, pos: e }) {
              return this.getMapCenterByLngLatPosition({ lngLat: t, pos: e });
            }
            fitBounds(t, e = {}) {
              const { width: n, height: i } = this,
                {
                  longitude: r,
                  latitude: s,
                  zoom: o,
                } = ii(Object.assign({ width: n, height: i, bounds: t }, e));
              return new ai({
                width: n,
                height: i,
                longitude: r,
                latitude: s,
                zoom: o,
              });
            }
            getBounds(t) {
              const e = this.getBoundingRegion(t),
                n = Math.min(...e.map((t) => t[0])),
                i = Math.max(...e.map((t) => t[0]));
              return [
                [n, Math.min(...e.map((t) => t[1]))],
                [i, Math.max(...e.map((t) => t[1]))],
              ];
            }
            getBoundingRegion(t = {}) {
              return si(this, t.z || 0);
            }
          }
          const ci = {
            DEFAULT: -1,
            LNGLAT: 1,
            METER_OFFSETS: 2,
            LNGLAT_OFFSETS: 3,
            CARTESIAN: 0,
          };
          Object.defineProperty(ci, "IDENTITY", {
            get: () =>
              Et.deprecated(
                "COORDINATE_SYSTEM.IDENTITY",
                "COORDINATE_SYSTEM.CARTESIAN"
              )() || 0,
          });
          const hi = {
              WEB_MERCATOR: 1,
              GLOBE: 2,
              WEB_MERCATOR_AUTO_OFFSET: 4,
              IDENTITY: 0,
            },
            li = { common: 0, meters: 1, pixels: 2 },
            ui = {
              click: { handler: "onClick" },
              panstart: { handler: "onDragStart" },
              panmove: { handler: "onDrag" },
              panend: { handler: "onDragEnd" },
            },
            di = Math.PI / 180,
            fi = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            pi = [0, 0, 0],
            gi = { unitsPerMeter: [1, 1, 1], metersPerUnit: [1, 1, 1] };
          class mi {
            constructor(t = {}) {
              const {
                id: e = null,
                x: n = 0,
                y: i = 0,
                width: r = 1,
                height: s = 1,
              } = t;
              (this.id = e || this.constructor.displayName || "viewport"),
                (this.x = n),
                (this.y = i),
                (this.width = r || 1),
                (this.height = s || 1),
                (this._frustumPlanes = {}),
                this._initViewMatrix(t),
                this._initProjectionMatrix(t),
                this._initPixelMatrices(),
                (this.equals = this.equals.bind(this)),
                (this.project = this.project.bind(this)),
                (this.unproject = this.unproject.bind(this)),
                (this.projectPosition = this.projectPosition.bind(this)),
                (this.unprojectPosition = this.unprojectPosition.bind(this)),
                (this.projectFlat = this.projectFlat.bind(this)),
                (this.unprojectFlat = this.unprojectFlat.bind(this));
            }
            get metersPerPixel() {
              return this.distanceScales.metersPerUnit[2] / this.scale;
            }
            get projectionMode() {
              return this.isGeospatial
                ? this.zoom < 12
                  ? hi.WEB_MERCATOR
                  : hi.WEB_MERCATOR_AUTO_OFFSET
                : hi.IDENTITY;
            }
            equals(t) {
              return (
                t instanceof mi &&
                (this === t ||
                  (t.width === this.width &&
                    t.height === this.height &&
                    t.scale === this.scale &&
                    Je(t.projectionMatrix, this.projectionMatrix) &&
                    Je(t.viewMatrix, this.viewMatrix)))
              );
            }
            project(t, { topLeft: e = !0 } = {}) {
              const n = ei(this.projectPosition(t), this.pixelProjectionMatrix),
                [i, r] = n,
                s = e ? r : this.height - r;
              return 2 === t.length ? [i, s] : [i, s, n[2]];
            }
            unproject(t, { topLeft: e = !0, targetZ: n } = {}) {
              const [i, r, s] = t,
                o = e ? r : this.height - r,
                a = n && n * this.distanceScales.unitsPerMeter[2],
                c = ni([i, o, s], this.pixelUnprojectionMatrix, a),
                [h, l, u] = this.unprojectPosition(c);
              return Number.isFinite(s)
                ? [h, l, u]
                : Number.isFinite(n)
                ? [h, l, n]
                : [h, l];
            }
            projectPosition(t) {
              const [e, n] = this.projectFlat(t);
              return [e, n, (t[2] || 0) * this.distanceScales.unitsPerMeter[2]];
            }
            unprojectPosition(t) {
              const [e, n] = this.unprojectFlat(t);
              return [e, n, (t[2] || 0) * this.distanceScales.metersPerUnit[2]];
            }
            projectFlat(t) {
              return this.isGeospatial ? Xn(t) : t;
            }
            unprojectFlat(t) {
              return this.isGeospatial ? qn(t) : t;
            }
            getBounds(t = {}) {
              const e = { targetZ: t.z || 0 },
                n = this.unproject([0, 0], e),
                i = this.unproject([this.width, 0], e),
                r = this.unproject([0, this.height], e),
                s = this.unproject([this.width, this.height], e);
              return [
                Math.min(n[0], i[0], r[0], s[0]),
                Math.min(n[1], i[1], r[1], s[1]),
                Math.max(n[0], i[0], r[0], s[0]),
                Math.max(n[1], i[1], r[1], s[1]),
              ];
            }
            getDistanceScales(t = null) {
              return t
                ? Yn({ longitude: t[0], latitude: t[1], highPrecision: !0 })
                : this.distanceScales;
            }
            containsPixel({ x: t, y: e, width: n = 1, height: i = 1 }) {
              return (
                t < this.x + this.width &&
                this.x < t + n &&
                e < this.y + this.height &&
                this.y < e + i
              );
            }
            getFrustumPlanes() {
              return (
                this._frustumPlanes.near ||
                  Object.assign(
                    this._frustumPlanes,
                    (function (t) {
                      const e = {};
                      return (
                        (e.left = bn(
                          t[3] + t[0],
                          t[7] + t[4],
                          t[11] + t[8],
                          t[15] + t[12]
                        )),
                        (e.right = bn(
                          t[3] - t[0],
                          t[7] - t[4],
                          t[11] - t[8],
                          t[15] - t[12]
                        )),
                        (e.bottom = bn(
                          t[3] + t[1],
                          t[7] + t[5],
                          t[11] + t[9],
                          t[15] + t[13]
                        )),
                        (e.top = bn(
                          t[3] - t[1],
                          t[7] - t[5],
                          t[11] - t[9],
                          t[15] - t[13]
                        )),
                        (e.near = bn(
                          t[3] + t[2],
                          t[7] + t[6],
                          t[11] + t[10],
                          t[15] + t[14]
                        )),
                        (e.far = bn(
                          t[3] - t[2],
                          t[7] - t[6],
                          t[11] - t[10],
                          t[15] - t[14]
                        )),
                        e
                      );
                    })(this.viewProjectionMatrix)
                  ),
                this._frustumPlanes
              );
            }
            panByPosition(t, e) {
              return null;
            }
            getCameraPosition() {
              return this.cameraPosition;
            }
            getCameraDirection() {
              return this.cameraDirection;
            }
            getCameraUp() {
              return this.cameraUp;
            }
            _createProjectionMatrix({
              orthographic: t,
              fovyRadians: e,
              aspect: n,
              focalDistance: i,
              near: r,
              far: s,
            }) {
              return t
                ? new Bn().orthographic({
                    fovy: e,
                    aspect: n,
                    focalDistance: i,
                    near: r,
                    far: s,
                  })
                : new Bn().perspective({ fovy: e, aspect: n, near: r, far: s });
            }
            _initViewMatrix(t) {
              const {
                viewMatrix: e = fi,
                longitude: n = null,
                latitude: i = null,
                zoom: r = null,
                position: s = null,
                modelMatrix: o = null,
                focalDistance: a = 1,
                distanceScales: c = null,
              } = t;
              (this.isGeospatial = Number.isFinite(i) && Number.isFinite(n)),
                (this.zoom = r),
                Number.isFinite(this.zoom) ||
                  (this.zoom = this.isGeospatial
                    ? (function ({ latitude: t }) {
                        Vn(Number.isFinite(t));
                        const e = Math.cos(t * $n);
                        return zn(4003e4 * e) - 9;
                      })({ latitude: i }) + Math.log2(a)
                    : 0);
              const h = Math.pow(2, this.zoom);
              (this.scale = h),
                (this.distanceScales = this.isGeospatial
                  ? Yn({ latitude: i, longitude: n })
                  : c || gi),
                (this.focalDistance = a),
                (this.distanceScales.metersPerUnit = new gn(
                  this.distanceScales.metersPerUnit
                )),
                (this.distanceScales.unitsPerMeter = new gn(
                  this.distanceScales.unitsPerMeter
                )),
                (this.position = pi),
                (this.meterOffset = pi),
                s &&
                  ((this.position = s),
                  (this.modelMatrix = o),
                  (this.meterOffset = o ? o.transformVector(s) : s)),
                this.isGeospatial
                  ? ((this.longitude = n),
                    (this.latitude = i),
                    (this.center = this._getCenterInWorld({
                      longitude: n,
                      latitude: i,
                    })))
                  : (this.center = s ? this.projectPosition(s) : [0, 0, 0]),
                (this.viewMatrixUncentered = e),
                (this.viewMatrix = new Bn()
                  .multiplyRight(this.viewMatrixUncentered)
                  .translate(new gn(this.center || pi).negate()));
            }
            _getCenterInWorld({ longitude: t, latitude: e }) {
              const { meterOffset: n, distanceScales: i } = this,
                r = new gn(this.projectPosition([t, e, 0]));
              if (n) {
                const t = new gn(n).scale(i.unitsPerMeter);
                r.add(t);
              }
              return r;
            }
            _initProjectionMatrix(t) {
              const {
                projectionMatrix: e = null,
                orthographic: n = !1,
                fovyRadians: i,
                fovy: r = 75,
                near: s = 0.1,
                far: o = 1e3,
                focalDistance: a = 1,
              } = t;
              this.projectionMatrix =
                e ||
                this._createProjectionMatrix({
                  orthographic: n,
                  fovyRadians: i || r * di,
                  aspect: this.width / this.height,
                  focalDistance: a,
                  near: s,
                  far: o,
                });
            }
            _initPixelMatrices() {
              const t = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              var e;
              xn(t, t, this.projectionMatrix),
                xn(t, t, this.viewMatrix),
                (this.viewProjectionMatrix = t),
                (this.viewMatrixInverse =
                  wn([], this.viewMatrix) || this.viewMatrix),
                (this.cameraPosition = [
                  (e = this.viewMatrixInverse)[12],
                  e[13],
                  e[14],
                ]);
              const n = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                i = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              Pn(n, n, [this.width / 2, -this.height / 2, 1]),
                En(n, n, [1, -1, 0]),
                xn(i, n, this.viewProjectionMatrix),
                (this.pixelProjectionMatrix = i),
                (this.viewportMatrix = n),
                (this.pixelUnprojectionMatrix = wn(
                  [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                  this.pixelProjectionMatrix
                )),
                this.pixelUnprojectionMatrix ||
                  Et.warn("Pixel project matrix not invertible")();
            }
          }
          mi.displayName = "Viewport";
          const bi = "vs",
            _i = "fs";
          function yi(t, e) {
            if (!t) throw new Error(e || "shadertools: assertion failed.");
          }
          const vi = {
            number: {
              validate: (t, e) =>
                Number.isFinite(t) &&
                (!("max" in e) || t <= e.max) &&
                (!("min" in e) || t >= e.min),
            },
            array: {
              validate: (t, e) => Array.isArray(t) || ArrayBuffer.isView(t),
            },
          };
          function wi(t) {
            let e = xi(t);
            return "object" === e
              ? t
                ? "type" in t
                  ? Object.assign({}, t, vi[t.type])
                  : "value" in t
                  ? ((e = xi(t.value)), Object.assign({ type: e }, t, vi[e]))
                  : { type: "object", value: t }
                : { type: "object", value: null }
              : Object.assign({ type: e, value: t }, vi[e]);
          }
          function xi(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t)
              ? "array"
              : typeof t;
          }
          class Ei {
            constructor({
              name: t,
              vs: e,
              fs: n,
              dependencies: i = [],
              uniforms: r,
              getUniforms: s,
              deprecations: o = [],
              defines: a = {},
              inject: c = {},
              vertexShader: h,
              fragmentShader: l,
            }) {
              yi("string" == typeof t),
                (this.name = t),
                (this.vs = e || h),
                (this.fs = n || l),
                (this.getModuleUniforms = s),
                (this.dependencies = i),
                (this.deprecations = this._parseDeprecationDefinitions(o)),
                (this.defines = a),
                (this.injections = (function (t) {
                  const e = { vs: {}, fs: {} };
                  for (const n in t) {
                    let i = t[n];
                    const r = n.slice(0, 2);
                    "string" == typeof i && (i = { order: 0, injection: i }),
                      (e[r][n] = i);
                  }
                  return e;
                })(c)),
                r &&
                  (this.uniforms = (function (t) {
                    const e = {};
                    for (const n in t) {
                      const i = wi(t[n]);
                      e[n] = i;
                    }
                    return e;
                  })(r));
            }
            getModuleSource(t) {
              let e;
              switch (t) {
                case "vs":
                  e = this.vs || "";
                  break;
                case "fs":
                  e = this.fs || "";
                  break;
                default:
                  yi(!1);
              }
              return `#define MODULE_${this.name
                .toUpperCase()
                .replace(/[^0-9a-z]/gi, "_")}\n${e}// END MODULE_${
                this.name
              }\n\n`;
            }
            getUniforms(t, e) {
              return this.getModuleUniforms
                ? this.getModuleUniforms(t, e)
                : this.uniforms
                ? this._defaultGetUniforms(t)
                : {};
            }
            getDefines() {
              return this.defines;
            }
            checkDeprecations(t, e) {
              this.deprecations.forEach((n) => {
                n.regex.test(t) &&
                  (n.deprecated
                    ? e.deprecated(n.old, n.new)()
                    : e.removed(n.old, n.new)());
              });
            }
            _parseDeprecationDefinitions(t) {
              return (
                t.forEach((t) => {
                  "function" === t.type
                    ? (t.regex = new RegExp(`\\b${t.old}\\(`))
                    : (t.regex = new RegExp(`${t.type} ${t.old};`));
                }),
                t
              );
            }
            _defaultGetUniforms(t = {}) {
              const e = {},
                n = this.uniforms;
              for (const i in n) {
                const r = n[i];
                i in t && !r.private
                  ? (r.validate &&
                      yi(r.validate(t[i], r), `${this.name}: invalid ${i}`),
                    (e[i] = t[i]))
                  : (e[i] = r.value);
              }
              return e;
            }
          }
          function Pi(t) {
            return (function (t) {
              const e = {},
                n = {};
              return (
                Ti({ modules: t, level: 0, moduleMap: e, moduleDepth: n }),
                Object.keys(n)
                  .sort((t, e) => n[e] - n[t])
                  .map((t) => e[t])
              );
            })(Ai(t));
          }
          function Ti({ modules: t, level: e, moduleMap: n, moduleDepth: i }) {
            if (e >= 5)
              throw new Error("Possible loop in shader dependency graph");
            for (const r of t)
              (n[r.name] = r),
                (void 0 === i[r.name] || i[r.name] < e) && (i[r.name] = e);
            for (const r of t)
              r.dependencies &&
                Ti({
                  modules: r.dependencies,
                  level: e + 1,
                  moduleMap: n,
                  moduleDepth: i,
                });
          }
          function Ai(t, e) {
            return t.map(
              (t) => (
                t instanceof Ei ||
                  (yi(
                    "string" != typeof t,
                    `Shader module use by name is deprecated. Import shader module '${t}' and use it directly.`
                  ),
                  yi(t.name, "shader module has no name"),
                  ((t = new Ei(t)).dependencies = Ai(t.dependencies))),
                t
              )
            );
          }
          const Si = {
              GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
              GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
              GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
              GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0],
            },
            Mi = {};
          Object.keys(Si).forEach((t) => {
            Mi[t] = t;
          });
          const Ci = {};
          function Oi(t, e, n = {}) {
            const i = Si[e];
            if (
              (yi(i, e),
              !(function (t = {}) {
                const e =
                    ("undefined" != typeof window && window.navigator) || {},
                  n = t.userAgent || e.userAgent || "",
                  i = -1 !== n.indexOf("MSIE "),
                  r = -1 !== n.indexOf("Trident/");
                return i || r;
              })(n))
            )
              return !0;
            if (e in Ci) return Ci[e];
            const r = `#extension GL_${i[0]} : ${
                n.behavior || "enable"
              }\nvoid main(void) {}`,
              s = t.createShader(35633);
            t.shaderSource(s, r), t.compileShader(s);
            const o = t.getShaderParameter(s, 35713);
            return t.deleteShader(s), (Ci[e] = o), o;
          }
          function Li(t, e) {
            return (e = Array.isArray(e) ? e : [e]).every((e) =>
              (function (t, e) {
                const n = Si[e];
                yi(n, e);
                const i =
                    ((function (t) {
                      return (
                        ("undefined" != typeof WebGL2RenderingContext &&
                          t instanceof WebGL2RenderingContext) ||
                        Boolean(t && 2 === t._version)
                      );
                    })(t) &&
                      n[1]) ||
                    n[0],
                  r = "string" == typeof i ? Boolean(t.getExtension(i)) : i;
                return yi(!1 === r || !0 === r), r;
              })(t, e)
            );
          }
          const Ii = {
              [bi]: "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",
              [_i]: "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n",
            },
            Ri = "__LUMA_INJECT_DECLARATIONS__",
            ki = /void\s+main\s*\([^)]*\)\s*\{\n?/,
            ji = /}\n?[^{}]*$/,
            Fi = [];
          function Bi(t, e, n, i = !1) {
            const r = e === bi;
            for (const e in n) {
              const i = n[e];
              i.sort((t, e) => t.order - e.order), (Fi.length = i.length);
              for (let t = 0, e = i.length; t < e; ++t) Fi[t] = i[t].injection;
              const s = `${Fi.join("\n")}\n`;
              switch (e) {
                case "vs:#decl":
                  r && (t = t.replace(Ri, s));
                  break;
                case "vs:#main-start":
                  r && (t = t.replace(ki, (t) => t + s));
                  break;
                case "vs:#main-end":
                  r && (t = t.replace(ji, (t) => s + t));
                  break;
                case "fs:#decl":
                  r || (t = t.replace(Ri, s));
                  break;
                case "fs:#main-start":
                  r || (t = t.replace(ki, (t) => t + s));
                  break;
                case "fs:#main-end":
                  r || (t = t.replace(ji, (t) => s + t));
                  break;
                default:
                  t = t.replace(e, (t) => t + s);
              }
            }
            return (
              (t = t.replace(Ri, "")),
              i && (t = t.replace(/\}\s*$/, (t) => t + Ii[e])),
              t
            );
          }
          function Di(t) {
            const e = {};
            return (
              yi(Array.isArray(t) && t.length > 1),
              t.forEach((t) => {
                for (const n in t) e[n] = e[n] ? `${e[n]}\n${t[n]}` : t[n];
              }),
              e
            );
          }
          function Ni(t) {
            return new RegExp(
              `\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,
              "g"
            );
          }
          const zi = [
              [
                /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
                "#version 300 es\n",
              ],
              [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
              [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("],
            ],
            Vi = [...zi, [Ni("attribute"), "in $1"], [Ni("varying"), "out $1"]],
            Ui = [...zi, [Ni("varying"), "in $1"]],
            Gi = [
              [/^#version[ \t]+300[ \t]+es/, "#version 100"],
              [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("],
              [/\btexture\(/g, "texture2D("],
              [/\btextureLod\(/g, "texture2DLodEXT("],
            ],
            $i = [...Gi, [Ni("in"), "attribute $1"], [Ni("out"), "varying $1"]],
            Wi = [...Gi, [Ni("in"), "varying $1"]],
            Hi = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,
            Xi = /void\s+main\s*\([^)]*\)\s*\{\n?/;
          function qi(t, e) {
            for (const [n, i] of e) t = t.replace(n, i);
            return t;
          }
          const Yi = { [bi]: "vertex", [_i]: "fragment" };
          function Zi(
            t,
            {
              id: e,
              source: n,
              type: i,
              modules: r,
              defines: s = {},
              hookFunctions: o = [],
              inject: a = {},
              transpileToGLSL100: c = !1,
              prologue: h = !0,
              log: l,
            }
          ) {
            yi("string" == typeof n, "shader source must be a string");
            const u = i === bi,
              d = n.split("\n");
            let f = 100,
              p = "",
              g = n;
            0 === d[0].indexOf("#version ")
              ? ((f = 300), (p = d[0]), (g = d.slice(1).join("\n")))
              : (p = `#version ${f}`);
            const m = {};
            r.forEach((t) => {
              Object.assign(m, t.getDefines());
            }),
              Object.assign(m, s);
            let b = h
              ? `${p}\n${(function ({ id: t, source: e, type: n }) {
                  return t &&
                    "string" == typeof t &&
                    -1 === e.indexOf("SHADER_NAME")
                    ? `\n#define SHADER_NAME ${t}_${Yi[n]}\n\n`
                    : "";
                })({ id: e, source: n, type: i })}\n${(function ({ type: t }) {
                  return `\n#define SHADER_TYPE_${Yi[t].toUpperCase()}\n`;
                })({ type: i })}\n${(function (t) {
                  const e = (function (t) {
                    const e = t.getExtension("WEBGL_debug_renderer_info"),
                      n = t.getParameter(
                        (e && e.UNMASKED_VENDOR_WEBGL) || 7936
                      ),
                      i = t.getParameter(
                        (e && e.UNMASKED_RENDERER_WEBGL) || 7937
                      ),
                      r = (function (t, e) {
                        return t.match(/NVIDIA/i) || e.match(/NVIDIA/i)
                          ? "NVIDIA"
                          : t.match(/INTEL/i) || e.match(/INTEL/i)
                          ? "INTEL"
                          : t.match(/AMD/i) ||
                            e.match(/AMD/i) ||
                            t.match(/ATI/i) ||
                            e.match(/ATI/i)
                          ? "AMD"
                          : "UNKNOWN GPU";
                      })(n, i);
                    return {
                      gpuVendor: r,
                      vendor: n,
                      renderer: i,
                      version: t.getParameter(7938),
                      shadingLanguageVersion: t.getParameter(35724),
                    };
                  })(t);
                  switch (e.gpuVendor.toLowerCase()) {
                    case "nvidia":
                      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
                    case "intel":
                      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
                    case "amd":
                      return "#define AMD_GPU\n";
                    default:
                      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
                  }
                })(t)}\n${(function (t, e, n) {
                  let i =
                    "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
                  return (
                    Li(t, Mi.GLSL_FRAG_DEPTH) &&
                      (i +=
                        "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"),
                    Li(t, Mi.GLSL_DERIVATIVES) &&
                      Oi(t, Mi.GLSL_DERIVATIVES) &&
                      (i +=
                        "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"),
                    Li(t, Mi.GLSL_FRAG_DATA) &&
                      Oi(t, Mi.GLSL_FRAG_DATA, { behavior: "require" }) &&
                      (i +=
                        "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"),
                    Li(t, Mi.GLSL_TEXTURE_LOD) &&
                      (i +=
                        "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"),
                    i
                  );
                })(t)}\n${(function (t = {}) {
                  let e = 0,
                    n = "";
                  for (const i in t) {
                    0 === e && (n += "\n// APPLICATION DEFINES\n"), e++;
                    const r = t[i];
                    (r || Number.isFinite(r)) &&
                      (n += `#define ${i.toUpperCase()} ${t[i]}\n`);
                  }
                  return 0 === e && (n += "\n"), n;
                })(m)}\n${u ? "" : "precision highp float;\n\n"}\n`
              : `${p}\n`;
            const _ = (function (t) {
                const e = { vs: {}, fs: {} };
                return (
                  t.forEach((t) => {
                    let n;
                    "string" != typeof t ? ((n = t), (t = n.hook)) : (n = {}),
                      (t = t.trim());
                    const [i, r] = t.split(":"),
                      s = t.replace(/\(.+/, "");
                    e[i][s] = Object.assign(n, { signature: r });
                  }),
                  e
                );
              })(o),
              y = {},
              v = {},
              w = {};
            for (const t in a) {
              const e =
                  "string" == typeof a[t]
                    ? { injection: a[t], order: 0 }
                    : a[t],
                n = t.match(/^(v|f)s:(#)?([\w-]+)$/);
              if (n) {
                const i = n[2],
                  r = n[3];
                i ? ("decl" === r ? (v[t] = [e]) : (w[t] = [e])) : (y[t] = [e]);
              } else w[t] = [e];
            }
            for (const t of r) {
              l && t.checkDeprecations(g, l), (b += t.getModuleSource(i, f));
              const e = t.injections[i];
              for (const t in e) {
                const n = t.match(/^(v|f)s:#([\w-]+)$/);
                if (n) {
                  const i = "decl" === n[2] ? v : w;
                  (i[t] = i[t] || []), i[t].push(e[t]);
                } else (y[t] = y[t] || []), y[t].push(e[t]);
              }
            }
            return (
              (b += "\n\n__LUMA_INJECT_DECLARATIONS__\n\n"),
              (b = Bi(b, i, v)),
              (b += (function (t, e) {
                let n = "";
                for (const i in t) {
                  const r = t[i];
                  if (
                    ((n += `void ${r.signature} {\n`),
                    r.header && (n += `  ${r.header}`),
                    e[i])
                  ) {
                    const t = e[i];
                    t.sort((t, e) => t.order - e.order);
                    for (const e of t) n += `  ${e.injection}\n`;
                  }
                  r.footer && (n += `  ${r.footer}`), (n += "}\n");
                }
                return n;
              })(_[i], y)),
              (b += g),
              (b = Bi(b, i, w)),
              (b = (function (t, e, n) {
                switch (e) {
                  case 300:
                    return n
                      ? qi(t, Vi)
                      : (function (t) {
                          const e = (t = qi(t, Ui)).match(Hi);
                          if (e) {
                            const n = e[1];
                            t = t.replace(
                              new RegExp("\\bgl_FragColor\\b", "g"),
                              n
                            );
                          } else {
                            const e = "fragmentColor";
                            t = t
                              .replace(Xi, (t) => `out vec4 ${e};\n${t}`)
                              .replace(
                                new RegExp("\\bgl_FragColor\\b", "g"),
                                e
                              );
                          }
                          return t;
                        })(t);
                  case 100:
                    return n
                      ? qi(t, $i)
                      : (function (t) {
                          const e = (t = qi(t, Wi)).match(Hi);
                          if (e) {
                            const n = e[1];
                            t = t
                              .replace(Hi, "")
                              .replace(
                                new RegExp(`\\b${n}\\b`, "g"),
                                "gl_FragColor"
                              );
                          }
                          return t;
                        })(t);
                  default:
                    throw new Error(`unknown GLSL version ${e}`);
                }
              })(b, c ? 100 : f, u)),
              b
            );
          }
          function Ki(t) {
            return function (e) {
              const n = {};
              for (const i of t) {
                const t = i.getUniforms(e, n);
                Object.assign(n, t);
              }
              return n;
            };
          }
          const Qi = "8.5.10",
            Ji = new (class {
              constructor() {
                this.stats = new Map();
              }
              get(t) {
                return (
                  this.stats.has(t) || this.stats.set(t, new Lt({ id: t })),
                  this.stats.get(t)
                );
              }
            })();
          if (O.CO.luma && O.CO.luma.VERSION !== Qi)
            throw new Error(
              `luma.gl - multiple VERSIONs detected: ${O.CO.luma.VERSION} vs 8.5.10`
            );
          function tr(t, e) {
            if (!t) throw new Error(e || "luma.gl: assertion failed.");
          }
          function er(t, e) {
            if ("string" != typeof e) return e;
            const n = Number(e);
            if (!isNaN(n)) return n;
            const i = t[(e = e.replace(/^.*\./, ""))];
            return tr(void 0 !== i, `Accessing undefined constant GL.${e}`), i;
          }
          function nr(t, e) {
            e = Number(e);
            for (const n in t) if (t[n] === e) return `GL.${n}`;
            return String(e);
          }
          O.CO.luma ||
            ((0, O.jU)() &&
              P.log(
                1,
                "luma.gl 8.5.10 - set luma.log.level=1 (or higher) to trace rendering"
              )(),
            (O.CO.luma = O.CO.luma || {
              VERSION: Qi,
              version: Qi,
              log: P,
              stats: Ji,
              globals: { modules: {}, nodeIO: {} },
            })),
            O.CO.luma;
          const ir = {};
          function rr(t = "id") {
            return (ir[t] = ir[t] || 1), `${t}-${ir[t]++}`;
          }
          function sr(t) {
            return (
              tr("number" == typeof t, "Input must be a number"),
              t && 0 == (t & (t - 1))
            );
          }
          function or(t) {
            let e = !0;
            for (const n in t) {
              e = !1;
              break;
            }
            return e;
          }
          function ar(t, e, n, i) {
            const r = `See luma.gl ${n} Upgrade Guide at https://luma.gl/docs/upgrade-guide`,
              s = Object.getPrototypeOf(t);
            i.forEach((t) => {
              s.methodName ||
                (s[t] = () => {
                  throw (
                    (P.removed(`Calling removed method ${e}.${t}: `, r)(),
                    new Error(t))
                  );
                });
            });
          }
          const cr = "Resource subclass must define virtual methods";
          class hr {
            constructor(t, e = {}) {
              M(t);
              const { id: n, userData: i = {} } = e;
              (this.gl = t),
                (this.gl2 = t),
                (this.id = n || rr(this.constructor.name)),
                (this.userData = i),
                (this._bound = !1),
                (this._handle = e.handle),
                void 0 === this._handle &&
                  (this._handle = this._createHandle()),
                (this.byteLength = 0),
                this._addStats();
            }
            toString() {
              return `${this.constructor.name}(${this.id})`;
            }
            get handle() {
              return this._handle;
            }
            delete({ deleteChildren: t = !1 } = {}) {
              const e = this._handle && this._deleteHandle(this._handle);
              return (
                this._handle && this._removeStats(),
                (this._handle = null),
                e && t && e.filter(Boolean).forEach((t) => t.delete()),
                this
              );
            }
            bind(t = this.handle) {
              if ("function" != typeof t) return this._bindHandle(t), this;
              let e;
              return (
                this._bound
                  ? (e = t())
                  : (this._bindHandle(this.handle),
                    (this._bound = !0),
                    (e = t()),
                    (this._bound = !1),
                    this._bindHandle(null)),
                e
              );
            }
            unbind() {
              this.bind(null);
            }
            getParameter(t, e = {}) {
              tr((t = er(this.gl, t)));
              const n = (this.constructor.PARAMETERS || {})[t];
              if (n) {
                const t = S(this.gl);
                if (
                  ("webgl2" in n && !t) ||
                  ("extension" in n && !this.gl.getExtension(n.extension))
                ) {
                  const e = n.webgl1,
                    i = "webgl2" in n ? n.webgl2 : n.webgl1;
                  return t ? i : e;
                }
              }
              return this._getParameter(t, e);
            }
            getParameters(t = {}) {
              const { parameters: e, keys: n } = t,
                i = this.constructor.PARAMETERS || {},
                r = S(this.gl),
                s = {},
                o = e || Object.keys(i);
              for (const e of o) {
                const o = i[e];
                if (
                  o &&
                  (!("webgl2" in o) || r) &&
                  (!("extension" in o) || this.gl.getExtension(o.extension))
                ) {
                  const i = n ? nr(this.gl, e) : e;
                  (s[i] = this.getParameter(e, t)),
                    n && "GLenum" === o.type && (s[i] = nr(this.gl, s[i]));
                }
              }
              return s;
            }
            setParameter(t, e) {
              tr((t = er(this.gl, t)));
              const n = (this.constructor.PARAMETERS || {})[t];
              if (n) {
                const t = S(this.gl);
                if (
                  ("webgl2" in n && !t) ||
                  ("extension" in n && !this.gl.getExtension(n.extension))
                )
                  throw new Error("Parameter not available on this platform");
                "GLenum" === n.type && (e = er(e));
              }
              return this._setParameter(t, e), this;
            }
            setParameters(t) {
              for (const e in t) this.setParameter(e, t[e]);
              return this;
            }
            stubRemovedMethods(t, e, n) {
              return ar(this, t, e, n);
            }
            initialize(t) {}
            _createHandle() {
              throw new Error(cr);
            }
            _deleteHandle() {
              throw new Error(cr);
            }
            _bindHandle(t) {
              throw new Error(cr);
            }
            _getOptsFromHandle() {
              throw new Error(cr);
            }
            _getParameter(t, e) {
              throw new Error(cr);
            }
            _setParameter(t, e) {
              throw new Error(cr);
            }
            _context() {
              return (this.gl.luma = this.gl.luma || {}), this.gl.luma;
            }
            _addStats() {
              const t = this.constructor.name,
                e = Ji.get("Resource Counts");
              e.get("Resources Created").incrementCount(),
                e.get(`${t}s Created`).incrementCount(),
                e.get(`${t}s Active`).incrementCount();
            }
            _removeStats() {
              const t = this.constructor.name;
              Ji.get("Resource Counts").get(`${t}s Active`).decrementCount();
            }
            _trackAllocatedMemory(t, e = this.constructor.name) {
              const n = Ji.get("Memory Usage");
              n.get("GPU Memory").addCount(t),
                n.get(`${e} Memory`).addCount(t),
                (this.byteLength = t);
            }
            _trackDeallocatedMemory(t = this.constructor.name) {
              const e = Ji.get("Memory Usage");
              e.get("GPU Memory").subtractCount(this.byteLength),
                e.get(`${t} Memory`).subtractCount(this.byteLength),
                (this.byteLength = 0);
            }
          }
          function lr(t) {
            switch (ArrayBuffer.isView(t) ? t.constructor : t) {
              case Float32Array:
                return 5126;
              case Uint16Array:
                return 5123;
              case Uint32Array:
                return 5125;
              case Uint8Array:
              case Uint8ClampedArray:
                return 5121;
              case Int8Array:
                return 5120;
              case Int16Array:
                return 5122;
              case Int32Array:
                return 5124;
              default:
                throw new Error(
                  "Failed to deduce GL constant from typed array"
                );
            }
          }
          function ur(t, { clamped: e = !0 } = {}) {
            switch (t) {
              case 5126:
                return Float32Array;
              case 5123:
              case 33635:
              case 32819:
              case 32820:
                return Uint16Array;
              case 5125:
                return Uint32Array;
              case 5121:
                return e ? Uint8ClampedArray : Uint8Array;
              case 5120:
                return Int8Array;
              case 5122:
                return Int16Array;
              case 5124:
                return Int32Array;
              default:
                throw new Error(
                  "Failed to deduce typed array type from GL constant"
                );
            }
          }
          function dr({ data: t, width: e, height: n }) {
            const i = Math.round(e / 2),
              r = Math.round(n / 2),
              s = new Uint8Array(i * r * 4);
            for (let n = 0; n < r; n++)
              for (let r = 0; r < i; r++)
                for (let o = 0; o < 4; o++)
                  s[4 * (n * i + r) + o] = t[4 * (2 * n * e + 2 * r) + o];
            return { data: s, width: i, height: r };
          }
          function fr(t, e, n) {
            const {
              removedProps: i = {},
              deprecatedProps: r = {},
              replacedProps: s = {},
            } = n;
            for (const n in i)
              if (n in e) {
                const e = i[n] ? `${t}.${i[n]}` : "N/A";
                P.removed(`${t}.${n}`, e)();
              }
            for (const n in r)
              if (n in e) {
                const e = r[n];
                P.deprecated(`${t}.${n}`, `${t}.${e}`)();
              }
            let o = null;
            for (const n in s)
              if (n in e) {
                const i = s[n];
                P.deprecated(`${t}.${n}`, `${t}.${i}`)(),
                  (o = o || Object.assign({}, e)),
                  (o[i] = e[n]),
                  delete o[n];
              }
            return o || e;
          }
          const pr = {
              offset: 0,
              stride: 0,
              type: 5126,
              size: 1,
              divisor: 0,
              normalized: !1,
              integer: !1,
            },
            gr = {
              deprecatedProps: { instanced: "divisor", isInstanced: "divisor" },
            };
          class mr {
            static getBytesPerElement(t) {
              return ur(t.type || 5126).BYTES_PER_ELEMENT;
            }
            static getBytesPerVertex(t) {
              return tr(t.size), ur(t.type || 5126).BYTES_PER_ELEMENT * t.size;
            }
            static resolve(...t) {
              return new mr(...[pr, ...t]);
            }
            constructor(...t) {
              t.forEach((t) => this._assign(t)), Object.freeze(this);
            }
            toString() {
              return JSON.stringify(this);
            }
            get BYTES_PER_ELEMENT() {
              return mr.getBytesPerElement(this);
            }
            get BYTES_PER_VERTEX() {
              return mr.getBytesPerVertex(this);
            }
            _assign(t = {}) {
              return (
                void 0 !== (t = fr("Accessor", t, gr)).type &&
                  ((this.type = t.type),
                  (5124 !== t.type && 5125 !== t.type) || (this.integer = !0)),
                void 0 !== t.size && (this.size = t.size),
                void 0 !== t.offset && (this.offset = t.offset),
                void 0 !== t.stride && (this.stride = t.stride),
                void 0 !== t.normalized && (this.normalized = t.normalized),
                void 0 !== t.integer && (this.integer = t.integer),
                void 0 !== t.divisor && (this.divisor = t.divisor),
                void 0 !== t.buffer && (this.buffer = t.buffer),
                void 0 !== t.index &&
                  ("boolean" == typeof t.index
                    ? (this.index = t.index ? 1 : 0)
                    : (this.index = t.index)),
                void 0 !== t.instanced && (this.divisor = t.instanced ? 1 : 0),
                void 0 !== t.isInstanced &&
                  (this.divisor = t.isInstanced ? 1 : 0),
                this
              );
            }
          }
          const br = {
              offset: "accessor.offset",
              stride: "accessor.stride",
              type: "accessor.type",
              size: "accessor.size",
              divisor: "accessor.divisor",
              normalized: "accessor.normalized",
              integer: "accessor.integer",
              instanced: "accessor.divisor",
              isInstanced: "accessor.divisor",
            },
            _r = {
              removedProps: {},
              replacedProps: { bytes: "byteLength" },
              deprecatedProps: br,
            },
            yr = { removedProps: br };
          class vr extends hr {
            constructor(t, e = {}) {
              super(t, e),
                this.stubRemovedMethods("Buffer", "v6.0", [
                  "layout",
                  "setLayout",
                  "getIndexedParameter",
                ]),
                (this.target = e.target || (this.gl.webgl2 ? 36662 : 34962)),
                this.initialize(e),
                Object.seal(this);
            }
            getElementCount(t = this.accessor) {
              return Math.round(this.byteLength / mr.getBytesPerElement(t));
            }
            getVertexCount(t = this.accessor) {
              return Math.round(this.byteLength / mr.getBytesPerVertex(t));
            }
            initialize(t = {}) {
              return (
                ArrayBuffer.isView(t) && (t = { data: t }),
                Number.isFinite(t) && (t = { byteLength: t }),
                (t = fr("Buffer", t, _r)),
                (this.usage = t.usage || 35044),
                (this.debugData = null),
                this.setAccessor(Object.assign({}, t, t.accessor)),
                t.data
                  ? this._setData(t.data, t.offset, t.byteLength)
                  : this._setByteLength(t.byteLength || 0),
                this
              );
            }
            setProps(t) {
              return (
                "accessor" in (t = fr("Buffer", t, yr)) &&
                  this.setAccessor(t.accessor),
                this
              );
            }
            setAccessor(t) {
              return (
                delete (t = Object.assign({}, t)).buffer,
                (this.accessor = new mr(t)),
                this
              );
            }
            reallocate(t) {
              return t > this.byteLength
                ? (this._setByteLength(t), !0)
                : ((this.bytesUsed = t), !1);
            }
            setData(t) {
              return this.initialize(t);
            }
            subData(t) {
              ArrayBuffer.isView(t) && (t = { data: t });
              const { data: e, offset: n = 0, srcOffset: i = 0 } = t,
                r = t.byteLength || t.length;
              tr(e);
              const s = this.gl.webgl2 ? 36663 : this.target;
              return (
                this.gl.bindBuffer(s, this.handle),
                0 !== i || void 0 !== r
                  ? (C(this.gl), this.gl.bufferSubData(this.target, n, e, i, r))
                  : this.gl.bufferSubData(s, n, e),
                this.gl.bindBuffer(s, null),
                (this.debugData = null),
                this._inferType(e),
                this
              );
            }
            copyData({
              sourceBuffer: t,
              readOffset: e = 0,
              writeOffset: n = 0,
              size: i,
            }) {
              const { gl: r } = this;
              return (
                C(r),
                r.bindBuffer(36662, t.handle),
                r.bindBuffer(36663, this.handle),
                r.copyBufferSubData(36662, 36663, e, n, i),
                r.bindBuffer(36662, null),
                r.bindBuffer(36663, null),
                (this.debugData = null),
                this
              );
            }
            getData({
              dstData: t = null,
              srcByteOffset: e = 0,
              dstOffset: n = 0,
              length: i = 0,
            } = {}) {
              C(this.gl);
              const r = ur(this.accessor.type || 5126, { clamped: !1 }),
                s = this._getAvailableElementCount(e),
                o = n;
              let a, c;
              t
                ? ((c = t.length), (a = c - o))
                : ((a = Math.min(s, i || s)), (c = o + a));
              const h = Math.min(s, a);
              return (
                tr((i = i || h) <= h),
                (t = t || new r(c)),
                this.gl.bindBuffer(36662, this.handle),
                this.gl.getBufferSubData(36662, e, t, n, i),
                this.gl.bindBuffer(36662, null),
                t
              );
            }
            bind({
              target: t = this.target,
              index: e = this.accessor && this.accessor.index,
              offset: n = 0,
              size: i,
            } = {}) {
              return (
                35345 === t || 35982 === t
                  ? void 0 !== i
                    ? this.gl.bindBufferRange(t, e, this.handle, n, i)
                    : (tr(0 === n), this.gl.bindBufferBase(t, e, this.handle))
                  : this.gl.bindBuffer(t, this.handle),
                this
              );
            }
            unbind({
              target: t = this.target,
              index: e = this.accessor && this.accessor.index,
            } = {}) {
              return (
                35345 === t || 35982 === t
                  ? this.gl.bindBufferBase(t, e, null)
                  : this.gl.bindBuffer(t, null),
                this
              );
            }
            getDebugData() {
              return this.debugData
                ? { data: this.debugData, changed: !1 }
                : ((this.debugData = this.getData({
                    length: Math.min(10, this.byteLength),
                  })),
                  { data: this.debugData, changed: !0 });
            }
            invalidateDebugData() {
              this.debugData = null;
            }
            _setData(t, e = 0, n = t.byteLength + e) {
              tr(ArrayBuffer.isView(t)), this._trackDeallocatedMemory();
              const i = this._getTarget();
              this.gl.bindBuffer(i, this.handle),
                this.gl.bufferData(i, n, this.usage),
                this.gl.bufferSubData(i, e, t),
                this.gl.bindBuffer(i, null),
                (this.debugData = t.slice(0, 10)),
                (this.bytesUsed = n),
                this._trackAllocatedMemory(n);
              const r = lr(t);
              return (
                tr(r),
                this.setAccessor(new mr(this.accessor, { type: r })),
                this
              );
            }
            _setByteLength(t, e = this.usage) {
              tr(t >= 0), this._trackDeallocatedMemory();
              let n = t;
              0 === t && (n = new Float32Array(0));
              const i = this._getTarget();
              return (
                this.gl.bindBuffer(i, this.handle),
                this.gl.bufferData(i, n, e),
                this.gl.bindBuffer(i, null),
                (this.usage = e),
                (this.debugData = null),
                (this.bytesUsed = t),
                this._trackAllocatedMemory(t),
                this
              );
            }
            _getTarget() {
              return this.gl.webgl2 ? 36663 : this.target;
            }
            _getAvailableElementCount(t) {
              const e =
                t /
                ur(this.accessor.type || 5126, { clamped: !1 })
                  .BYTES_PER_ELEMENT;
              return this.getElementCount() - e;
            }
            _inferType(t) {
              this.accessor.type ||
                this.setAccessor(new mr(this.accessor, { type: lr(t) }));
            }
            _createHandle() {
              return this.gl.createBuffer();
            }
            _deleteHandle() {
              this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory();
            }
            _getParameter(t) {
              this.gl.bindBuffer(this.target, this.handle);
              const e = this.gl.getBufferParameter(this.target, t);
              return this.gl.bindBuffer(this.target, null), e;
            }
            get type() {
              return (
                P.deprecated("Buffer.type", "Buffer.accessor.type")(),
                this.accessor.type
              );
            }
            get bytes() {
              return (
                P.deprecated("Buffer.bytes", "Buffer.byteLength")(),
                this.byteLength
              );
            }
            setByteLength(t) {
              return (
                P.deprecated("setByteLength", "reallocate")(),
                this.reallocate(t)
              );
            }
            updateAccessor(t) {
              return (
                P.deprecated(
                  "updateAccessor(...)",
                  "setAccessor(new Accessor(buffer.accessor, ...)"
                )(),
                (this.accessor = new mr(this.accessor, t)),
                this
              );
            }
          }
          const wr = {
              6407: { dataFormat: 6407, types: [5121, 33635] },
              6408: { dataFormat: 6408, types: [5121, 32819, 32820] },
              6406: { dataFormat: 6406, types: [5121] },
              6409: { dataFormat: 6409, types: [5121] },
              6410: { dataFormat: 6410, types: [5121] },
              33326: { dataFormat: 6403, types: [5126], gl2: !0 },
              33328: { dataFormat: 33319, types: [5126], gl2: !0 },
              34837: { dataFormat: 6407, types: [5126], gl2: !0 },
              34836: { dataFormat: 6408, types: [5126], gl2: !0 },
            },
            xr = {
              6403: 1,
              36244: 1,
              33319: 2,
              33320: 2,
              6407: 3,
              36248: 3,
              6408: 4,
              36249: 4,
              6402: 1,
              34041: 1,
              6406: 1,
              6409: 1,
              6410: 2,
            },
            Er = {
              5126: 4,
              5125: 4,
              5124: 4,
              5123: 2,
              5122: 2,
              5131: 2,
              5120: 1,
              5121: 1,
            },
            Pr = [9729, 9728],
            Tr = O.CO.WebGLBuffer || function () {};
          class Ar extends hr {
            static isSupported(t, e = {}) {
              const { format: n, linearFiltering: i } = e;
              let r = !0;
              return (
                n &&
                  ((r =
                    r &&
                    (function (t, e) {
                      const n = wr[e];
                      if (!n) return !1;
                      if (void 0 === n.gl1 && void 0 === n.gl2) return !0;
                      const i = (S(t) && n.gl2) || n.gl1;
                      return "string" == typeof i ? t.getExtension(i) : i;
                    })(t, n)),
                  (r =
                    r &&
                    (!i ||
                      (function (t, e) {
                        const n = wr[e];
                        switch (n && n.types[0]) {
                          case 5126:
                            return t.getExtension("OES_texture_float_linear");
                          case 5131:
                            return t.getExtension(
                              "OES_texture_half_float_linear"
                            );
                          default:
                            return !0;
                        }
                      })(t, n)))),
                r
              );
            }
            constructor(t, e) {
              const { id: n = rr("texture"), handle: i, target: r } = e;
              super(t, { id: n, handle: i }),
                (this.target = r),
                (this.textureUnit = void 0),
                (this.loaded = !1),
                (this.width = void 0),
                (this.height = void 0),
                (this.depth = void 0),
                (this.format = void 0),
                (this.type = void 0),
                (this.dataFormat = void 0),
                (this.border = void 0),
                (this.textureUnit = void 0),
                (this.mipmaps = void 0);
            }
            toString() {
              return `Texture(${this.id},${this.width}x${this.height})`;
            }
            initialize(t = {}) {
              let e = t.data;
              if (e instanceof Promise)
                return (
                  e.then((e) =>
                    this.initialize(
                      Object.assign({}, t, { pixels: e, data: e })
                    )
                  ),
                  this
                );
              const n =
                "undefined" != typeof HTMLVideoElement &&
                e instanceof HTMLVideoElement;
              if (n && e.readyState < HTMLVideoElement.HAVE_METADATA)
                return (
                  (this._video = null),
                  e.addEventListener("loadeddata", () => this.initialize(t)),
                  this
                );
              const {
                pixels: i = null,
                format: r = 6408,
                border: s = 0,
                recreate: o = !1,
                parameters: a = {},
                pixelStore: c = {},
                textureUnit: h,
              } = t;
              e || (e = i);
              let {
                width: l,
                height: u,
                dataFormat: d,
                type: f,
                compressed: p = !1,
                mipmaps: g = !0,
              } = t;
              const { depth: m = 0 } = t;
              return (
                ({
                  width: l,
                  height: u,
                  compressed: p,
                  dataFormat: d,
                  type: f,
                } = this._deduceParameters({
                  format: r,
                  type: f,
                  dataFormat: d,
                  compressed: p,
                  data: e,
                  width: l,
                  height: u,
                })),
                (this.width = l),
                (this.height = u),
                (this.depth = m),
                (this.format = r),
                (this.type = f),
                (this.dataFormat = d),
                (this.border = s),
                (this.textureUnit = h),
                Number.isFinite(this.textureUnit) &&
                  (this.gl.activeTexture(33984 + this.textureUnit),
                  this.gl.bindTexture(this.target, this.handle)),
                g &&
                  this._isNPOT() &&
                  (P.warn(
                    `texture: ${this} is Non-Power-Of-Two, disabling mipmaping`
                  )(),
                  (g = !1),
                  this._updateForNPOT(a)),
                (this.mipmaps = g),
                this.setImageData({
                  data: e,
                  width: l,
                  height: u,
                  depth: m,
                  format: r,
                  type: f,
                  dataFormat: d,
                  border: s,
                  mipmaps: g,
                  parameters: c,
                  compressed: p,
                }),
                g && this.generateMipmap(),
                this.setParameters(a),
                o && (this.data = e),
                n &&
                  (this._video = {
                    video: e,
                    parameters: a,
                    lastTime:
                      e.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA
                        ? e.currentTime
                        : -1,
                  }),
                this
              );
            }
            update() {
              if (this._video) {
                const { video: t, parameters: e, lastTime: n } = this._video;
                if (
                  n === t.currentTime ||
                  t.readyState < HTMLVideoElement.HAVE_CURRENT_DATA
                )
                  return;
                this.setSubImageData({ data: t, parameters: e }),
                  this.mipmaps && this.generateMipmap(),
                  (this._video.lastTime = t.currentTime);
              }
            }
            resize({ height: t, width: e, mipmaps: n = !1 }) {
              return e !== this.width || t !== this.height
                ? this.initialize({
                    width: e,
                    height: t,
                    format: this.format,
                    type: this.type,
                    dataFormat: this.dataFormat,
                    border: this.border,
                    mipmaps: n,
                  })
                : this;
            }
            generateMipmap(t = {}) {
              return this._isNPOT()
                ? (P.warn(
                    `texture: ${this} is Non-Power-Of-Two, disabling mipmaping`
                  )(),
                  this)
                : ((this.mipmaps = !0),
                  this.gl.bindTexture(this.target, this.handle),
                  ht(this.gl, t, () => {
                    this.gl.generateMipmap(this.target);
                  }),
                  this.gl.bindTexture(this.target, null),
                  this);
            }
            setImageData(t) {
              this._trackDeallocatedMemory("Texture");
              const {
                target: e = this.target,
                pixels: n = null,
                level: i = 0,
                format: r = this.format,
                border: s = this.border,
                offset: o = 0,
                parameters: a = {},
              } = t;
              let {
                data: c = null,
                type: h = this.type,
                width: l = this.width,
                height: u = this.height,
                dataFormat: d = this.dataFormat,
                compressed: f = !1,
              } = t;
              c || (c = n),
                ({
                  type: h,
                  dataFormat: d,
                  compressed: f,
                  width: l,
                  height: u,
                } = this._deduceParameters({
                  format: r,
                  type: h,
                  dataFormat: d,
                  compressed: f,
                  data: c,
                  width: l,
                  height: u,
                }));
              const { gl: p } = this;
              p.bindTexture(this.target, this.handle);
              let g,
                m = null;
              if (
                (({ data: c, dataType: m } = this._getDataType({
                  data: c,
                  compressed: f,
                })),
                ht(this.gl, a, () => {
                  switch (m) {
                    case "null":
                      p.texImage2D(e, i, r, l, u, s, d, h, c);
                      break;
                    case "typed-array":
                      p.texImage2D(e, i, r, l, u, s, d, h, c, o);
                      break;
                    case "buffer":
                      (g = C(p)),
                        g.bindBuffer(35052, c.handle || c),
                        g.texImage2D(e, i, r, l, u, s, d, h, o),
                        g.bindBuffer(35052, null);
                      break;
                    case "browser-object":
                      S(p)
                        ? p.texImage2D(e, i, r, l, u, s, d, h, c)
                        : p.texImage2D(e, i, r, d, h, c);
                      break;
                    case "compressed":
                      for (const [t, n] of c.entries())
                        p.compressedTexImage2D(
                          e,
                          t,
                          n.format,
                          n.width,
                          n.height,
                          s,
                          n.data
                        );
                      break;
                    default:
                      tr(!1, "Unknown image data type");
                  }
                }),
                c && c.byteLength)
              )
                this._trackAllocatedMemory(c.byteLength, "Texture");
              else {
                const t = xr[this.dataFormat] || 4,
                  e = Er[this.type] || 1;
                this._trackAllocatedMemory(
                  this.width * this.height * t * e,
                  "Texture"
                );
              }
              return (this.loaded = !0), this;
            }
            setSubImageData({
              target: t = this.target,
              pixels: e = null,
              data: n = null,
              x: i = 0,
              y: r = 0,
              width: s = this.width,
              height: o = this.height,
              level: a = 0,
              format: c = this.format,
              type: h = this.type,
              dataFormat: l = this.dataFormat,
              compressed: u = !1,
              offset: d = 0,
              border: f = this.border,
              parameters: p = {},
            }) {
              if (
                (({
                  type: h,
                  dataFormat: l,
                  compressed: u,
                  width: s,
                  height: o,
                } = this._deduceParameters({
                  format: c,
                  type: h,
                  dataFormat: l,
                  compressed: u,
                  data: n,
                  width: s,
                  height: o,
                })),
                tr(
                  0 === this.depth,
                  "texSubImage not supported for 3D textures"
                ),
                n || (n = e),
                n && n.data)
              ) {
                const t = n;
                (n = t.data), (s = t.shape[0]), (o = t.shape[1]);
              }
              n instanceof vr && (n = n.handle),
                this.gl.bindTexture(this.target, this.handle),
                ht(this.gl, p, () => {
                  if (u)
                    this.gl.compressedTexSubImage2D(t, a, i, r, s, o, c, n);
                  else if (null === n)
                    this.gl.texSubImage2D(t, a, i, r, s, o, l, h, null);
                  else if (ArrayBuffer.isView(n))
                    this.gl.texSubImage2D(t, a, i, r, s, o, l, h, n, d);
                  else if (n instanceof Tr) {
                    const e = C(this.gl);
                    e.bindBuffer(35052, n),
                      e.texSubImage2D(t, a, i, r, s, o, l, h, d),
                      e.bindBuffer(35052, null);
                  } else
                    S(this.gl)
                      ? C(this.gl).texSubImage2D(t, a, i, r, s, o, l, h, n)
                      : this.gl.texSubImage2D(t, a, i, r, l, h, n);
                }),
                this.gl.bindTexture(this.target, null);
            }
            copyFramebuffer(t = {}) {
              return (
                P.error(
                  "Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})"
                )(),
                null
              );
            }
            getActiveUnit() {
              return this.gl.getParameter(34016) - 33984;
            }
            bind(t = this.textureUnit) {
              const { gl: e } = this;
              return (
                void 0 !== t &&
                  ((this.textureUnit = t), e.activeTexture(33984 + t)),
                e.bindTexture(this.target, this.handle),
                t
              );
            }
            unbind(t = this.textureUnit) {
              const { gl: e } = this;
              return (
                void 0 !== t &&
                  ((this.textureUnit = t), e.activeTexture(33984 + t)),
                e.bindTexture(this.target, null),
                t
              );
            }
            _getDataType({ data: t, compressed: e = !1 }) {
              return e
                ? { data: t, dataType: "compressed" }
                : null === t
                ? { data: t, dataType: "null" }
                : ArrayBuffer.isView(t)
                ? { data: t, dataType: "typed-array" }
                : t instanceof vr
                ? { data: t.handle, dataType: "buffer" }
                : t instanceof Tr
                ? { data: t, dataType: "buffer" }
                : { data: t, dataType: "browser-object" };
            }
            _deduceParameters(t) {
              const { format: e, data: n } = t;
              let {
                width: i,
                height: r,
                dataFormat: s,
                type: o,
                compressed: a,
              } = t;
              const c = wr[e];
              return (
                (s = s || (c && c.dataFormat)),
                (o = o || (c && c.types[0])),
                (a = a || (c && c.compressed)),
                ({ width: i, height: r } = this._deduceImageSize(n, i, r)),
                {
                  dataFormat: s,
                  type: o,
                  compressed: a,
                  width: i,
                  height: r,
                  format: e,
                  data: n,
                }
              );
            }
            _deduceImageSize(t, e, n) {
              let i;
              return (
                (i =
                  "undefined" != typeof ImageData && t instanceof ImageData
                    ? { width: t.width, height: t.height }
                    : "undefined" != typeof HTMLImageElement &&
                      t instanceof HTMLImageElement
                    ? { width: t.naturalWidth, height: t.naturalHeight }
                    : ("undefined" != typeof HTMLCanvasElement &&
                        t instanceof HTMLCanvasElement) ||
                      ("undefined" != typeof ImageBitmap &&
                        t instanceof ImageBitmap)
                    ? { width: t.width, height: t.height }
                    : "undefined" != typeof HTMLVideoElement &&
                      t instanceof HTMLVideoElement
                    ? { width: t.videoWidth, height: t.videoHeight }
                    : t
                    ? { width: e, height: n }
                    : { width: e >= 0 ? e : 1, height: n >= 0 ? n : 1 }),
                tr(i, "Could not deduced texture size"),
                tr(
                  void 0 === e || i.width === e,
                  "Deduced texture width does not match supplied width"
                ),
                tr(
                  void 0 === n || i.height === n,
                  "Deduced texture height does not match supplied height"
                ),
                i
              );
            }
            _createHandle() {
              return this.gl.createTexture();
            }
            _deleteHandle() {
              this.gl.deleteTexture(this.handle),
                this._trackDeallocatedMemory("Texture");
            }
            _getParameter(t) {
              switch (t) {
                case 4096:
                  return this.width;
                case 4097:
                  return this.height;
                default:
                  this.gl.bindTexture(this.target, this.handle);
                  const e = this.gl.getTexParameter(this.target, t);
                  return this.gl.bindTexture(this.target, null), e;
              }
            }
            _setParameter(t, e) {
              switch (
                (this.gl.bindTexture(this.target, this.handle),
                (e = this._getNPOTParam(t, e)),
                t)
              ) {
                case 33082:
                case 33083:
                  this.gl.texParameterf(this.handle, t, e);
                  break;
                case 4096:
                case 4097:
                  tr(!1);
                  break;
                default:
                  this.gl.texParameteri(this.target, t, e);
              }
              return this.gl.bindTexture(this.target, null), this;
            }
            _isNPOT() {
              return !(
                S(this.gl) ||
                !this.width ||
                !this.height ||
                (sr(this.width) && sr(this.height))
              );
            }
            _updateForNPOT(t) {
              void 0 === t[this.gl.TEXTURE_MIN_FILTER] &&
                (t[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR),
                void 0 === t[this.gl.TEXTURE_WRAP_S] &&
                  (t[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE),
                void 0 === t[this.gl.TEXTURE_WRAP_T] &&
                  (t[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE);
            }
            _getNPOTParam(t, e) {
              if (this._isNPOT())
                switch (t) {
                  case 10241:
                    -1 === Pr.indexOf(e) && (e = 9729);
                    break;
                  case 10242:
                  case 10243:
                    33071 !== e && (e = 33071);
                }
              return e;
            }
          }
          class Sr extends Ar {
            static isSupported(t, e) {
              return Ar.isSupported(t, e);
            }
            constructor(t, e = {}) {
              var n;
              M(t),
                (e instanceof Promise || "string" == typeof e) &&
                  (e = { data: e }),
                "string" == typeof e.data &&
                  (e = Object.assign({}, e, {
                    data:
                      ((n = e.data),
                      tr("string" == typeof n),
                      (n = "" + n),
                      new Promise((t, e) => {
                        try {
                          const i = new Image();
                          (i.onload = () => t(i)),
                            (i.onerror = () =>
                              e(new Error(`Could not load image ${n}.`))),
                            (i.crossOrigin = "anonymous"),
                            (i.src = n);
                        } catch (t) {
                          e(t);
                        }
                      })),
                  })),
                super(t, Object.assign({}, e, { target: 3553 })),
                this.initialize(e),
                Object.seal(this);
            }
          }
          const Mr = "EXT_color_buffer_float",
            Cr = {
              33189: { bpp: 2 },
              33190: { gl2: !0, bpp: 3 },
              36012: { gl2: !0, bpp: 4 },
              36168: { bpp: 1 },
              34041: { bpp: 4 },
              35056: { gl2: !0, bpp: 4 },
              36013: { gl2: !0, bpp: 5 },
              32854: { bpp: 2 },
              36194: { bpp: 2 },
              32855: { bpp: 2 },
              33321: { gl2: !0, bpp: 1 },
              33330: { gl2: !0, bpp: 1 },
              33329: { gl2: !0, bpp: 1 },
              33332: { gl2: !0, bpp: 2 },
              33331: { gl2: !0, bpp: 2 },
              33334: { gl2: !0, bpp: 4 },
              33333: { gl2: !0, bpp: 4 },
              33323: { gl2: !0, bpp: 2 },
              33336: { gl2: !0, bpp: 2 },
              33335: { gl2: !0, bpp: 2 },
              33338: { gl2: !0, bpp: 4 },
              33337: { gl2: !0, bpp: 4 },
              33340: { gl2: !0, bpp: 8 },
              33339: { gl2: !0, bpp: 8 },
              32849: { gl2: !0, bpp: 3 },
              32856: { gl2: !0, bpp: 4 },
              32857: { gl2: !0, bpp: 4 },
              36220: { gl2: !0, bpp: 4 },
              36238: { gl2: !0, bpp: 4 },
              36975: { gl2: !0, bpp: 4 },
              36214: { gl2: !0, bpp: 8 },
              36232: { gl2: !0, bpp: 8 },
              36226: { gl2: !0, bpp: 16 },
              36208: { gl2: !0, bpp: 16 },
              33325: { gl2: Mr, bpp: 2 },
              33327: { gl2: Mr, bpp: 4 },
              34842: { gl2: Mr, bpp: 8 },
              33326: { gl2: Mr, bpp: 4 },
              33328: { gl2: Mr, bpp: 8 },
              34836: { gl2: Mr, bpp: 16 },
              35898: { gl2: Mr, bpp: 4 },
            };
          class Or extends hr {
            static isSupported(t, { format: e } = { format: null }) {
              return (
                !e ||
                (function (t, e, n) {
                  const i = n[e];
                  if (!i) return !1;
                  const r = (S(t) && i.gl2) || i.gl1;
                  return "string" == typeof r ? t.getExtension(r) : r;
                })(t, e, Cr)
              );
            }
            static getSamplesForFormat(t, { format: e }) {
              return t.getInternalformatParameter(36161, e, 32937);
            }
            constructor(t, e = {}) {
              super(t, e), this.initialize(e), Object.seal(this);
            }
            initialize({
              format: t,
              width: e = 1,
              height: n = 1,
              samples: i = 0,
            }) {
              return (
                tr(t, "Needs format"),
                this._trackDeallocatedMemory(),
                this.gl.bindRenderbuffer(36161, this.handle),
                0 !== i && S(this.gl)
                  ? this.gl.renderbufferStorageMultisample(36161, i, t, e, n)
                  : this.gl.renderbufferStorage(36161, t, e, n),
                (this.format = t),
                (this.width = e),
                (this.height = n),
                (this.samples = i),
                this._trackAllocatedMemory(
                  this.width *
                    this.height *
                    (this.samples || 1) *
                    Cr[this.format].bpp
                ),
                this
              );
            }
            resize({ width: t, height: e }) {
              return t !== this.width || e !== this.height
                ? this.initialize({
                    width: t,
                    height: e,
                    format: this.format,
                    samples: this.samples,
                  })
                : this;
            }
            _createHandle() {
              return this.gl.createRenderbuffer();
            }
            _deleteHandle() {
              this.gl.deleteRenderbuffer(this.handle),
                this._trackDeallocatedMemory();
            }
            _bindHandle(t) {
              this.gl.bindRenderbuffer(36161, t);
            }
            _syncHandle(t) {
              (this.format = this.getParameter(36164)),
                (this.width = this.getParameter(36162)),
                (this.height = this.getParameter(36163)),
                (this.samples = this.getParameter(36011));
            }
            _getParameter(t) {
              return (
                this.gl.bindRenderbuffer(36161, this.handle),
                this.gl.getRenderbufferParameter(36161, t)
              );
            }
          }
          const Lr = "clear: bad arguments";
          function Ir(
            t,
            {
              framebuffer: e = null,
              color: n = null,
              depth: i = null,
              stencil: r = null,
            } = {}
          ) {
            const s = {};
            e && (s.framebuffer = e);
            let o = 0;
            n && ((o |= 16384), !0 !== n && (s.clearColor = n)),
              i && ((o |= 256), !0 !== i && (s.clearDepth = i)),
              r && ((o |= 1024), !0 !== i && (s.clearStencil = i)),
              tr(0 !== o, Lr),
              ht(t, s, () => {
                t.clear(o);
              });
          }
          const Rr = [34069, 34070, 34071, 34072, 34073, 34074];
          class kr extends Ar {
            constructor(t, e = {}) {
              M(t),
                super(t, Object.assign({}, e, { target: 34067 })),
                this.initialize(e),
                Object.seal(this);
            }
            initialize(t = {}) {
              const { mipmaps: e = !0, parameters: n = {} } = t;
              return (
                (this.opts = t),
                this.setCubeMapImageData(t).then(() => {
                  (this.loaded = !0),
                    e && this.generateMipmap(t),
                    this.setParameters(n);
                }),
                this
              );
            }
            subImage({
              face: t,
              data: e,
              x: n = 0,
              y: i = 0,
              mipmapLevel: r = 0,
            }) {
              return this._subImage({
                target: t,
                data: e,
                x: n,
                y: i,
                mipmapLevel: r,
              });
            }
            async setCubeMapImageData({
              width: t,
              height: e,
              pixels: n,
              data: i,
              border: r = 0,
              format: s = 6408,
              type: o = 5121,
            }) {
              const { gl: a } = this,
                c = n || i,
                h = await Promise.all(
                  Rr.map((t) => {
                    const e = c[t];
                    return Promise.all(Array.isArray(e) ? e : [e]);
                  })
                );
              this.bind(),
                Rr.forEach((n, i) => {
                  h[i].length > 1 &&
                    !1 !== this.opts.mipmaps &&
                    P.warn(`${this.id} has mipmap and multiple LODs.`)(),
                    h[i].forEach((i, c) => {
                      t && e
                        ? a.texImage2D(n, c, s, t, e, r, s, o, i)
                        : a.texImage2D(n, c, s, s, o, i);
                    });
                }),
                this.unbind();
            }
            setImageDataForFace(t) {
              const {
                  face: e,
                  width: n,
                  height: i,
                  pixels: r,
                  data: s,
                  border: o = 0,
                  format: a = 6408,
                  type: c = 5121,
                } = t,
                { gl: h } = this,
                l = r || s;
              return (
                this.bind(),
                l instanceof Promise
                  ? l.then((n) =>
                      this.setImageDataForFace(
                        Object.assign({}, t, { face: e, data: n, pixels: n })
                      )
                    )
                  : this.width || this.height
                  ? h.texImage2D(e, 0, a, n, i, o, a, c, l)
                  : h.texImage2D(e, 0, a, a, c, l),
                this
              );
            }
          }
          kr.FACES = Rr;
          class jr extends Ar {
            static isSupported(t) {
              return S(t);
            }
            constructor(t, e = {}) {
              C(t),
                super(
                  t,
                  (e = Object.assign({ depth: 1 }, e, {
                    target: 32879,
                    unpackFlipY: !1,
                  }))
                ),
                this.initialize(e),
                Object.seal(this);
            }
            setImageData({
              level: t = 0,
              dataFormat: e = 6408,
              width: n,
              height: i,
              depth: r = 1,
              border: s = 0,
              format: o,
              type: a = 5121,
              offset: c = 0,
              data: h,
              parameters: l = {},
            }) {
              if (
                (this._trackDeallocatedMemory("Texture"),
                this.gl.bindTexture(this.target, this.handle),
                ht(this.gl, l, () => {
                  ArrayBuffer.isView(h) &&
                    this.gl.texImage3D(this.target, t, e, n, i, r, s, o, a, h),
                    h instanceof vr &&
                      (this.gl.bindBuffer(35052, h.handle),
                      this.gl.texImage3D(
                        this.target,
                        t,
                        e,
                        n,
                        i,
                        r,
                        s,
                        o,
                        a,
                        c
                      ));
                }),
                h && h.byteLength)
              )
                this._trackAllocatedMemory(h.byteLength, "Texture");
              else {
                const t = xr[this.dataFormat] || 4,
                  e = Er[this.type] || 1;
                this._trackAllocatedMemory(
                  this.width * this.height * this.depth * t * e,
                  "Texture"
                );
              }
              return (this.loaded = !0), this;
            }
          }
          function Fr(t, e) {
            const { gl: n, width: i, height: r, id: s } = t;
            return new Wr(
              n,
              Object.assign({}, e, {
                id: `framebuffer-for-${s}`,
                width: i,
                height: r,
                attachments: { 36064: t },
              })
            );
          }
          function Br(t, e = {}) {
            const {
              sourceX: n = 0,
              sourceY: i = 0,
              sourceFormat: r = 6408,
            } = e;
            let {
              sourceAttachment: s = 36064,
              target: o = null,
              sourceWidth: a,
              sourceHeight: c,
              sourceType: h,
            } = e;
            const { framebuffer: l, deleteFramebuffer: u } = (function (t) {
              return t instanceof Wr
                ? { framebuffer: t, deleteFramebuffer: !1 }
                : { framebuffer: Fr(t), deleteFramebuffer: !0 };
            })(t);
            tr(l);
            const { gl: d, handle: f, attachments: p } = l;
            (a = a || l.width),
              (c = c || l.height),
              36064 === s && null === f && (s = 1028),
              tr(p[s]),
              (h = h || p[s].type),
              (o = (function (t, e, n, i, r) {
                if (t) return t;
                const s = ur((e = e || 5121), { clamped: !1 }),
                  o = (function (t) {
                    switch (t) {
                      case 6406:
                      case 33326:
                      case 6403:
                        return 1;
                      case 33328:
                      case 33319:
                        return 2;
                      case 6407:
                      case 34837:
                        return 3;
                      case 6408:
                      case 34836:
                        return 4;
                      default:
                        return tr(!1), 0;
                    }
                  })(n);
                return new s(i * r * o);
              })(o, h, r, a, c)),
              (h = h || lr(o));
            const g = d.bindFramebuffer(36160, f);
            return (
              d.readPixels(n, i, a, c, r, h, o),
              d.bindFramebuffer(36160, g || null),
              u && l.delete(),
              o
            );
          }
          function Dr(
            t,
            {
              sourceAttachment: e = 36064,
              targetMaxHeight: n = Number.MAX_SAFE_INTEGER,
            } = {}
          ) {
            let i = Br(t, { sourceAttachment: e }),
              { width: r, height: s } = t;
            for (; s > n; )
              ({
                data: i,
                width: r,
                height: s,
              } = dr({ data: i, width: r, height: s }));
            !(function ({
              data: t,
              width: e,
              height: n,
              bytesPerPixel: i = 4,
              temp: r,
            }) {
              const s = e * i;
              r = r || new Uint8Array(s);
              for (let e = 0; e < n / 2; ++e) {
                const i = e * s,
                  o = (n - e - 1) * s;
                r.set(t.subarray(i, i + s)),
                  t.copyWithin(i, o, o + s),
                  t.set(r, o);
              }
            })({ data: i, width: r, height: s });
            const o = document.createElement("canvas");
            (o.width = r), (o.height = s);
            const a = o.getContext("2d"),
              c = a.createImageData(r, s);
            return c.data.set(i), a.putImageData(c, 0, 0), o.toDataURL();
          }
          const Nr = "TIMER_QUERY",
            zr = "ELEMENT_INDEX_UINT32",
            Vr = {
              WEBGL2: [!1, !0],
              VERTEX_ARRAY_OBJECT: ["OES_vertex_array_object", !0],
              [Nr]: [
                "EXT_disjoint_timer_query",
                "EXT_disjoint_timer_query_webgl2",
              ],
              INSTANCED_RENDERING: ["ANGLE_instanced_arrays", !0],
              MULTIPLE_RENDER_TARGETS: ["WEBGL_draw_buffers", !0],
              [zr]: ["OES_element_index_uint", !0],
              BLEND_EQUATION_MINMAX: ["EXT_blend_minmax", !0],
              FLOAT_BLEND: ["EXT_float_blend"],
              COLOR_ENCODING_SRGB: ["EXT_sRGB", !0],
              TEXTURE_DEPTH: ["WEBGL_depth_texture", !0],
              TEXTURE_FLOAT: ["OES_texture_float", !0],
              TEXTURE_HALF_FLOAT: ["OES_texture_half_float", !0],
              TEXTURE_FILTER_LINEAR_FLOAT: ["OES_texture_float_linear"],
              TEXTURE_FILTER_LINEAR_HALF_FLOAT: [
                "OES_texture_half_float_linear",
              ],
              TEXTURE_FILTER_ANISOTROPIC: ["EXT_texture_filter_anisotropic"],
              COLOR_ATTACHMENT_RGBA32F: [
                function (t) {
                  const e = new Sr(t, {
                      format: 6408,
                      type: 5126,
                      dataFormat: 6408,
                    }),
                    n = new Wr(t, {
                      id: "test-framebuffer",
                      check: !1,
                      attachments: { 36064: e },
                    }),
                    i = n.getStatus();
                  return e.delete(), n.delete(), 36053 === i;
                },
                "EXT_color_buffer_float",
              ],
              COLOR_ATTACHMENT_FLOAT: [!1, "EXT_color_buffer_float"],
              COLOR_ATTACHMENT_HALF_FLOAT: ["EXT_color_buffer_half_float"],
              GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
              GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
              GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
              GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0],
            };
          function Ur(t, e) {
            return (e = Array.isArray(e) ? e : [e]).every((e) => Gr(t, e));
          }
          function Gr(t, e) {
            return (
              (t.luma = t.luma || {}),
              (t.luma.caps = t.luma.caps || {}),
              void 0 === t.luma.caps[e] &&
                (t.luma.caps[e] = (function (t, e) {
                  const n = Vr[e];
                  let i;
                  tr(n, e);
                  const r = (S(t) && n[1]) || n[0];
                  if ("function" == typeof r) i = r(t);
                  else if (Array.isArray(r)) {
                    i = !0;
                    for (const e of r) i = i && Boolean(t.getExtension(e));
                  } else
                    "string" == typeof r
                      ? (i = Boolean(t.getExtension(r)))
                      : "boolean" == typeof r
                      ? (i = r)
                      : tr(!1);
                  return i;
                })(t, e)),
              t.luma.caps[e] || P.log(2, `Feature: ${e} not supported`)(),
              t.luma.caps[e]
            );
          }
          const $r = "Multiple render targets not supported";
          class Wr extends hr {
            static isSupported(t, e = {}) {
              const { colorBufferFloat: n, colorBufferHalfFloat: i } = e;
              let r = !0;
              return (
                n &&
                  (r = Boolean(
                    t.getExtension("EXT_color_buffer_float") ||
                      t.getExtension("WEBGL_color_buffer_float") ||
                      t.getExtension("OES_texture_float")
                  )),
                i &&
                  (r =
                    r &&
                    Boolean(
                      t.getExtension("EXT_color_buffer_float") ||
                        t.getExtension("EXT_color_buffer_half_float")
                    )),
                r
              );
            }
            static getDefaultFramebuffer(t) {
              return (
                (t.luma = t.luma || {}),
                (t.luma.defaultFramebuffer =
                  t.luma.defaultFramebuffer ||
                  new Wr(t, {
                    id: "default-framebuffer",
                    handle: null,
                    attachments: {},
                  })),
                t.luma.defaultFramebuffer
              );
            }
            get MAX_COLOR_ATTACHMENTS() {
              const t = C(this.gl);
              return t.getParameter(t.MAX_COLOR_ATTACHMENTS);
            }
            get MAX_DRAW_BUFFERS() {
              const t = C(this.gl);
              return t.getParameter(t.MAX_DRAW_BUFFERS);
            }
            constructor(t, e = {}) {
              super(t, e),
                (this.width = null),
                (this.height = null),
                (this.attachments = {}),
                (this.readBuffer = 36064),
                (this.drawBuffers = [36064]),
                (this.ownResources = []),
                this.initialize(e),
                Object.seal(this);
            }
            get color() {
              return this.attachments[36064] || null;
            }
            get texture() {
              return this.attachments[36064] || null;
            }
            get depth() {
              return this.attachments[36096] || this.attachments[33306] || null;
            }
            get stencil() {
              return this.attachments[36128] || this.attachments[33306] || null;
            }
            initialize({
              width: t = 1,
              height: e = 1,
              attachments: n = null,
              color: i = !0,
              depth: r = !0,
              stencil: s = !1,
              check: o = !0,
              readBuffer: a,
              drawBuffers: c,
            }) {
              if (
                (tr(t >= 0 && e >= 0, "Width and height need to be integers"),
                (this.width = t),
                (this.height = e),
                n)
              )
                for (const i in n) {
                  const r = n[i];
                  (Array.isArray(r) ? r[0] : r).resize({ width: t, height: e });
                }
              else n = this._createDefaultAttachments(i, r, s, t, e);
              this.update({
                clearAttachments: !0,
                attachments: n,
                readBuffer: a,
                drawBuffers: c,
              }),
                n && o && this.checkStatus();
            }
            delete() {
              for (const t of this.ownResources) t.delete();
              return super.delete(), this;
            }
            update({
              attachments: t = {},
              readBuffer: e,
              drawBuffers: n,
              clearAttachments: i = !1,
              resizeAttachments: r = !0,
            }) {
              this.attach(t, { clearAttachments: i, resizeAttachments: r });
              const { gl: s } = this,
                o = s.bindFramebuffer(36160, this.handle);
              return (
                e && this._setReadBuffer(e),
                n && this._setDrawBuffers(n),
                s.bindFramebuffer(36160, o || null),
                this
              );
            }
            resize(t = {}) {
              let { width: e, height: n } = t;
              if (null === this.handle)
                return (
                  tr(void 0 === e && void 0 === n),
                  (this.width = this.gl.drawingBufferWidth),
                  (this.height = this.gl.drawingBufferHeight),
                  this
                );
              void 0 === e && (e = this.gl.drawingBufferWidth),
                void 0 === n && (n = this.gl.drawingBufferHeight),
                e !== this.width &&
                  n !== this.height &&
                  P.log(2, `Resizing framebuffer ${this.id} to ${e}x${n}`)();
              for (const t in this.attachments)
                this.attachments[t].resize({ width: e, height: n });
              return (this.width = e), (this.height = n), this;
            }
            attach(
              t,
              { clearAttachments: e = !1, resizeAttachments: n = !0 } = {}
            ) {
              const i = {};
              e &&
                Object.keys(this.attachments).forEach((t) => {
                  i[t] = null;
                }),
                Object.assign(i, t);
              const r = this.gl.bindFramebuffer(36160, this.handle);
              for (const t in i) {
                tr(void 0 !== t, "Misspelled framebuffer binding point?");
                const e = Number(t),
                  r = i[e];
                let s = r;
                if (s)
                  if (s instanceof Or)
                    this._attachRenderbuffer({
                      attachment: e,
                      renderbuffer: s,
                    });
                  else if (Array.isArray(r)) {
                    const [t, n = 0, i = 0] = r;
                    (s = t),
                      this._attachTexture({
                        attachment: e,
                        texture: t,
                        layer: n,
                        level: i,
                      });
                  } else
                    this._attachTexture({
                      attachment: e,
                      texture: s,
                      layer: 0,
                      level: 0,
                    });
                else this._unattach(e);
                n && s && s.resize({ width: this.width, height: this.height });
              }
              this.gl.bindFramebuffer(36160, r || null),
                Object.assign(this.attachments, t),
                Object.keys(this.attachments)
                  .filter((t) => !this.attachments[t])
                  .forEach((t) => {
                    delete this.attachments[t];
                  });
            }
            checkStatus() {
              const { gl: t } = this,
                e = this.getStatus();
              if (36053 !== e)
                throw new Error(
                  (function (t) {
                    return (Wr.STATUS || {})[t] || `Framebuffer error ${t}`;
                  })(e)
                );
              return this;
            }
            getStatus() {
              const { gl: t } = this,
                e = t.bindFramebuffer(36160, this.handle),
                n = t.checkFramebufferStatus(36160);
              return t.bindFramebuffer(36160, e || null), n;
            }
            clear(t = {}) {
              const { color: e, depth: n, stencil: i, drawBuffers: r = [] } = t,
                s = this.gl.bindFramebuffer(36160, this.handle);
              return (
                (e || n || i) &&
                  Ir(this.gl, { color: e, depth: n, stencil: i }),
                r.forEach((t, e) => {
                  !(function (
                    t,
                    {
                      framebuffer: e = null,
                      buffer: n = 6144,
                      drawBuffer: i = 0,
                      value: r = [0, 0, 0, 0],
                    } = {}
                  ) {
                    C(t),
                      ht(t, { framebuffer: e }, () => {
                        switch (n) {
                          case 6144:
                            switch (r.constructor) {
                              case Int32Array:
                                t.clearBufferiv(n, i, r);
                                break;
                              case Uint32Array:
                                t.clearBufferuiv(n, i, r);
                                break;
                              case Float32Array:
                              default:
                                t.clearBufferfv(n, i, r);
                            }
                            break;
                          case 6145:
                            t.clearBufferfv(6145, 0, [r]);
                            break;
                          case 6146:
                            t.clearBufferiv(6146, 0, [r]);
                            break;
                          case 34041:
                            const [e, s] = r;
                            t.clearBufferfi(34041, 0, e, s);
                            break;
                          default:
                            tr(!1, Lr);
                        }
                      });
                  })(this.gl, { drawBuffer: e, value: t });
                }),
                this.gl.bindFramebuffer(36160, s || null),
                this
              );
            }
            readPixels(t = {}) {
              return (
                P.error(
                  "Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)"
                )(),
                null
              );
            }
            readPixelsToBuffer(t = {}) {
              return (
                P.error(
                  "Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)"
                )(),
                null
              );
            }
            copyToDataUrl(t = {}) {
              return (
                P.error(
                  "Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)"
                )(),
                null
              );
            }
            copyToImage(t = {}) {
              return (
                P.error(
                  "Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)"
                )(),
                null
              );
            }
            copyToTexture(t = {}) {
              return (
                P.error(
                  "Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})"
                )(),
                null
              );
            }
            blit(t = {}) {
              return (
                P.error(
                  "Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)"
                )(),
                null
              );
            }
            invalidate({
              attachments: t = [],
              x: e = 0,
              y: n = 0,
              width: i,
              height: r,
            }) {
              const s = C(this.gl),
                o = s.bindFramebuffer(36008, this.handle);
              return (
                0 === e && 0 === n && void 0 === i && void 0 === r
                  ? s.invalidateFramebuffer(36008, t)
                  : s.invalidateFramebuffer(36008, t, e, n, i, r),
                s.bindFramebuffer(36008, o),
                this
              );
            }
            getAttachmentParameter(t, e, n) {
              let i = this._getAttachmentParameterFallback(e);
              return (
                null === i &&
                  (this.gl.bindFramebuffer(36160, this.handle),
                  (i = this.gl.getFramebufferAttachmentParameter(36160, t, e)),
                  this.gl.bindFramebuffer(36160, null)),
                n && i > 1e3 && (i = nr(this.gl, i)),
                i
              );
            }
            getAttachmentParameters(
              t = 36064,
              e,
              n = this.constructor.ATTACHMENT_PARAMETERS || []
            ) {
              const i = {};
              for (const r of n)
                i[e ? nr(this.gl, r) : r] = this.getAttachmentParameter(
                  t,
                  r,
                  e
                );
              return i;
            }
            getParameters(t = !0) {
              const e = Object.keys(this.attachments),
                n = {};
              for (const i of e) {
                const e = Number(i);
                n[t ? nr(this.gl, e) : e] = this.getAttachmentParameters(e, t);
              }
              return n;
            }
            show() {
              return (
                "undefined" != typeof window &&
                  window.open(Dr(this), "luma-debug-texture"),
                this
              );
            }
            log(t = 0, e = "") {
              if (t > P.level || "undefined" == typeof window) return this;
              e = e || `Framebuffer ${this.id}`;
              const n = Dr(this, { targetMaxHeight: 100 });
              return P.image({ logLevel: t, message: e, image: n }, e)(), this;
            }
            bind({ target: t = 36160 } = {}) {
              return this.gl.bindFramebuffer(t, this.handle), this;
            }
            unbind({ target: t = 36160 } = {}) {
              return this.gl.bindFramebuffer(t, null), this;
            }
            _createDefaultAttachments(t, e, n, i, r) {
              let s = null;
              return (
                t &&
                  ((s = s || {}),
                  (s[36064] = new Sr(this.gl, {
                    id: `${this.id}-color0`,
                    pixels: null,
                    format: 6408,
                    type: 5121,
                    width: i,
                    height: r,
                    mipmaps: !1,
                    parameters: {
                      10241: 9729,
                      10240: 9729,
                      10242: 33071,
                      10243: 33071,
                    },
                  })),
                  this.ownResources.push(s[36064])),
                e && n
                  ? ((s = s || {}),
                    (s[33306] = new Or(this.gl, {
                      id: `${this.id}-depth-stencil`,
                      format: 35056,
                      width: i,
                      height: 111,
                    })),
                    this.ownResources.push(s[33306]))
                  : e
                  ? ((s = s || {}),
                    (s[36096] = new Or(this.gl, {
                      id: `${this.id}-depth`,
                      format: 33189,
                      width: i,
                      height: r,
                    })),
                    this.ownResources.push(s[36096]))
                  : n && tr(!1),
                s
              );
            }
            _unattach(t) {
              const e = this.attachments[t];
              e &&
                (e instanceof Or
                  ? this.gl.framebufferRenderbuffer(36160, t, 36161, null)
                  : this.gl.framebufferTexture2D(36160, t, 3553, null, 0),
                delete this.attachments[t]);
            }
            _attachRenderbuffer({ attachment: t = 36064, renderbuffer: e }) {
              const { gl: n } = this;
              n.framebufferRenderbuffer(36160, t, 36161, e.handle),
                (this.attachments[t] = e);
            }
            _attachTexture({
              attachment: t = 36064,
              texture: e,
              layer: n,
              level: i,
            }) {
              const { gl: r } = this;
              switch ((r.bindTexture(e.target, e.handle), e.target)) {
                case 35866:
                case 32879:
                  C(r).framebufferTextureLayer(36160, t, e.target, i, n);
                  break;
                case 34067:
                  const s = (function (t) {
                    return t < 34069 ? t + 34069 : t;
                  })(n);
                  r.framebufferTexture2D(36160, t, s, e.handle, i);
                  break;
                case 3553:
                  r.framebufferTexture2D(36160, t, 3553, e.handle, i);
                  break;
                default:
                  tr(!1, "Illegal texture type");
              }
              r.bindTexture(e.target, null), (this.attachments[t] = e);
            }
            _setReadBuffer(t) {
              const e = S((n = this.gl)) ? n : null;
              var n;
              e ? e.readBuffer(t) : tr(36064 === t || 1029 === t, $r),
                (this.readBuffer = t);
            }
            _setDrawBuffers(t) {
              const { gl: e } = this,
                n = C(e);
              if (n) n.drawBuffers(t);
              else {
                const n = e.getExtension("WEBGL_draw_buffers");
                n
                  ? n.drawBuffersWEBGL(t)
                  : tr(1 === t.length && (36064 === t[0] || 1029 === t[0]), $r);
              }
              this.drawBuffers = t;
            }
            _getAttachmentParameterFallback(t) {
              const e = (function (t) {
                (t.luma = t.luma || {}), (t.luma.caps = t.luma.caps || {});
                for (const e in Vr)
                  void 0 === t.luma.caps[e] && (t.luma.caps[e] = Gr(t, e));
                return t.luma.caps;
              })(this.gl);
              switch (t) {
                case 36052:
                  return e.WEBGL2 ? null : 0;
                case 33298:
                case 33299:
                case 33300:
                case 33301:
                case 33302:
                case 33303:
                  return e.WEBGL2 ? null : 8;
                case 33297:
                  return e.WEBGL2 ? null : 5125;
                case 33296:
                  return e.WEBGL2 || e.EXT_sRGB ? null : 9729;
                default:
                  return null;
              }
            }
            _createHandle() {
              return this.gl.createFramebuffer();
            }
            _deleteHandle() {
              this.gl.deleteFramebuffer(this.handle);
            }
            _bindHandle(t) {
              return this.gl.bindFramebuffer(36160, t);
            }
          }
          Wr.ATTACHMENT_PARAMETERS = [
            36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303,
          ];
          const Hr = {
              5126: os.bind(null, "uniform1fv", Qr, 1, as),
              35664: os.bind(null, "uniform2fv", Qr, 2, as),
              35665: os.bind(null, "uniform3fv", Qr, 3, as),
              35666: os.bind(null, "uniform4fv", Qr, 4, as),
              5124: os.bind(null, "uniform1iv", Jr, 1, as),
              35667: os.bind(null, "uniform2iv", Jr, 2, as),
              35668: os.bind(null, "uniform3iv", Jr, 3, as),
              35669: os.bind(null, "uniform4iv", Jr, 4, as),
              35670: os.bind(null, "uniform1iv", Jr, 1, as),
              35671: os.bind(null, "uniform2iv", Jr, 2, as),
              35672: os.bind(null, "uniform3iv", Jr, 3, as),
              35673: os.bind(null, "uniform4iv", Jr, 4, as),
              35674: os.bind(null, "uniformMatrix2fv", Qr, 4, cs),
              35675: os.bind(null, "uniformMatrix3fv", Qr, 9, cs),
              35676: os.bind(null, "uniformMatrix4fv", Qr, 16, cs),
              35678: ss,
              35680: ss,
              5125: os.bind(null, "uniform1uiv", ts, 1, as),
              36294: os.bind(null, "uniform2uiv", ts, 2, as),
              36295: os.bind(null, "uniform3uiv", ts, 3, as),
              36296: os.bind(null, "uniform4uiv", ts, 4, as),
              35685: os.bind(null, "uniformMatrix2x3fv", Qr, 6, cs),
              35686: os.bind(null, "uniformMatrix2x4fv", Qr, 8, cs),
              35687: os.bind(null, "uniformMatrix3x2fv", Qr, 6, cs),
              35688: os.bind(null, "uniformMatrix3x4fv", Qr, 12, cs),
              35689: os.bind(null, "uniformMatrix4x2fv", Qr, 8, cs),
              35690: os.bind(null, "uniformMatrix4x3fv", Qr, 12, cs),
              35678: ss,
              35680: ss,
              35679: ss,
              35682: ss,
              36289: ss,
              36292: ss,
              36293: ss,
              36298: ss,
              36299: ss,
              36300: ss,
              36303: ss,
              36306: ss,
              36307: ss,
              36308: ss,
              36311: ss,
            },
            Xr = {},
            qr = {},
            Yr = {},
            Zr = [0];
          function Kr(t, e, n, i) {
            1 === e && "boolean" == typeof t && (t = t ? 1 : 0),
              Number.isFinite(t) && ((Zr[0] = t), (t = Zr));
            const r = t.length;
            if (
              (r % e && P.warn(`Uniform size should be multiples of ${e}`, t)(),
              t instanceof n)
            )
              return t;
            let s = i[r];
            s || ((s = new n(r)), (i[r] = s));
            for (let e = 0; e < r; e++) s[e] = t[e];
            return s;
          }
          function Qr(t, e) {
            return Kr(t, e, Float32Array, Xr);
          }
          function Jr(t, e) {
            return Kr(t, e, Int32Array, qr);
          }
          function ts(t, e) {
            return Kr(t, e, Uint32Array, Yr);
          }
          function es(t, e, n) {
            const i = Hr[n.type];
            if (!i) throw new Error(`Unknown GLSL uniform type ${n.type}`);
            return i().bind(null, t, e);
          }
          function ns(t) {
            if ("]" !== t[t.length - 1])
              return { name: t, length: 1, isArray: !1 };
            const e = t.match(/([^[]*)(\[[0-9]+\])?/);
            if (!e || e.length < 2)
              throw new Error(`Failed to parse GLSL uniform name ${t}`);
            return { name: e[1], length: e[2] || 1, isArray: Boolean(e[2]) };
          }
          function is(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t)
              ? (function (t) {
                  if (0 === t.length) return !1;
                  const e = Math.min(t.length, 16);
                  for (let n = 0; n < e; ++n)
                    if (!Number.isFinite(t[n])) return !1;
                  return !0;
                })(t)
              : !!isFinite(t) ||
                  !0 === t ||
                  !1 === t ||
                  t instanceof Ar ||
                  t instanceof Or ||
                  (t instanceof Wr && Boolean(t.texture));
          }
          function rs(t, e, n) {
            if (Array.isArray(n) || ArrayBuffer.isView(n))
              if (t[e]) {
                const i = t[e];
                for (let t = 0, e = n.length; t < e; ++t) i[t] = n[t];
              } else t[e] = n.slice();
            else t[e] = n;
          }
          function ss() {
            let t = null;
            return (e, n, i) => {
              const r = t !== i;
              return r && (e.uniform1i(n, i), (t = i)), r;
            };
          }
          function os(t, e, n, i) {
            let r = null,
              s = null;
            return (o, a, c) => {
              const h = e(c, n),
                l = h.length;
              let u = !1;
              if (null === r) (r = new Float32Array(l)), (s = l), (u = !0);
              else {
                tr(s === l, "Uniform length cannot change.");
                for (let t = 0; t < l; ++t)
                  if (h[t] !== r[t]) {
                    u = !0;
                    break;
                  }
              }
              return u && (i(o, t, a, h), r.set(h)), u;
            };
          }
          function as(t, e, n, i) {
            t[e](n, i);
          }
          function cs(t, e, n, i) {
            t[e](n, !1, i);
          }
          function hs(t, e = "unnamed") {
            const n = t.match(
              /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/
            );
            return n ? n[1] : e;
          }
          function ls(t, e) {
            let n = "";
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              if (
                (t[i + 3] || t[i + 2] || t[i + 1]) &&
                ((n += `${r}\n`), t[i + 1])
              ) {
                const e = t[i + 1],
                  r = e.split(":", 3),
                  s = r[0],
                  o = parseInt(r[1], 10) || 0;
                n += us(
                  `^^^ ${s}: ${e.substring(r.join(":").length + 1).trim()}\n\n`,
                  o
                );
              }
            }
            return n;
          }
          function us(t, e) {
            let n = "";
            for (let t = 0; t < e; ++t) n += " ";
            return `${n}${t}`;
          }
          class ds extends hr {
            static getTypeName(t) {
              switch (t) {
                case 35633:
                  return "vertex-shader";
                case 35632:
                  return "fragment-shader";
                default:
                  return tr(!1), "unknown";
              }
            }
            constructor(t, e) {
              M(t),
                tr(
                  "string" == typeof e.source,
                  "Shader: GLSL source code must be a JavaScript string"
                ),
                super(t, {
                  id:
                    hs(e.source, null) ||
                    e.id ||
                    rr(`unnamed ${ds.getTypeName(e.shaderType)}`),
                }),
                (this.shaderType = e.shaderType),
                (this.source = e.source),
                this.initialize(e);
            }
            initialize({ source: t }) {
              const e = hs(t, null);
              e && (this.id = rr(e)), this._compile(t);
            }
            getParameter(t) {
              return this.gl.getShaderParameter(this.handle, t);
            }
            toString() {
              return `${ds.getTypeName(this.shaderType)}:${this.id}`;
            }
            getName() {
              return hs(this.source) || "unnamed-shader";
            }
            getSource() {
              return this.gl.getShaderSource(this.handle);
            }
            getTranslatedSource() {
              const t = this.gl.getExtension("WEBGL_debug_shaders");
              return t
                ? t.getTranslatedShaderSource(this.handle)
                : "No translated source available. WEBGL_debug_shaders not implemented";
            }
            _compile(t = this.source) {
              if (
                (t.startsWith("#version ") || (t = `#version 100\n${t}`),
                (this.source = t),
                this.gl.shaderSource(this.handle, this.source),
                this.gl.compileShader(this.handle),
                !this.getParameter(35713))
              ) {
                const t = this.gl.getShaderInfoLog(this.handle),
                  {
                    shaderName: e,
                    errors: n,
                    warnings: i,
                  } = (function (t, e, n, i) {
                    const r = t.split(/\r?\n/),
                      s = {},
                      o = {},
                      a = i || hs(e) || "(unnamed)",
                      c = `${(function (t) {
                        switch (t) {
                          case 35632:
                            return "fragment";
                          case 35633:
                            return "vertex";
                          default:
                            return "unknown type";
                        }
                      })(n)} shader ${a}`;
                    for (let e = 0; e < r.length; e++) {
                      const n = r[e];
                      if (n.length <= 1) continue;
                      const i = n.split(":"),
                        a = i[0],
                        h = parseInt(i[2], 10);
                      if (isNaN(h))
                        throw new Error(`GLSL compilation error in ${c}: ${t}`);
                      "WARNING" !== a ? (s[h] = n) : (o[h] = n);
                    }
                    const h = (function (t, e = 1, n = ": ") {
                      const i = t.split(/\r?\n/),
                        r = String(i.length + e - 1).length;
                      return i.map((t, i) => {
                        const s = String(i + e),
                          o = s.length;
                        return us(s, r - o) + n + t;
                      });
                    })(e);
                    return {
                      shaderName: c,
                      errors: ls(s, h),
                      warnings: ls(o, h),
                    };
                  })(t, this.source, this.shaderType, this.id);
                throw (
                  (P.error(`GLSL compilation errors in ${e}\n${n}`)(),
                  P.warn(`GLSL compilation warnings in ${e}\n${i}`)(),
                  new Error(`GLSL compilation errors in ${e}`))
                );
              }
            }
            _deleteHandle() {
              this.gl.deleteShader(this.handle);
            }
            _getOptsFromHandle() {
              return {
                type: this.getParameter(35663),
                source: this.getSource(),
              };
            }
          }
          class fs extends ds {
            constructor(t, e) {
              "string" == typeof e && (e = { source: e }),
                super(t, Object.assign({}, e, { shaderType: 35633 }));
            }
            _createHandle() {
              return this.gl.createShader(35633);
            }
          }
          class ps extends ds {
            constructor(t, e) {
              "string" == typeof e && (e = { source: e }),
                super(t, Object.assign({}, e, { shaderType: 35632 }));
            }
            _createHandle() {
              return this.gl.createShader(35632);
            }
          }
          const gs = 5126,
            ms = 5124,
            bs = 5125,
            _s = {
              [gs]: [gs, 1, "float"],
              35664: [gs, 2, "vec2"],
              35665: [gs, 3, "vec3"],
              35666: [gs, 4, "vec4"],
              [ms]: [ms, 1, "int"],
              35667: [ms, 2, "ivec2"],
              35668: [ms, 3, "ivec3"],
              35669: [ms, 4, "ivec4"],
              [bs]: [bs, 1, "uint"],
              36294: [bs, 2, "uvec2"],
              36295: [bs, 3, "uvec3"],
              36296: [bs, 4, "uvec4"],
              35670: [gs, 1, "bool"],
              35671: [gs, 2, "bvec2"],
              35672: [gs, 3, "bvec3"],
              35673: [gs, 4, "bvec4"],
              35674: [gs, 8, "mat2"],
              35685: [gs, 8, "mat2x3"],
              35686: [gs, 8, "mat2x4"],
              35675: [gs, 12, "mat3"],
              35687: [gs, 12, "mat3x2"],
              35688: [gs, 12, "mat3x4"],
              35676: [gs, 16, "mat4"],
              35689: [gs, 16, "mat4x2"],
              35690: [gs, 16, "mat4x3"],
            };
          function ys(t) {
            const e = _s[t];
            if (!e) return null;
            const [n, i] = e;
            return { type: n, components: i };
          }
          function vs(t, e) {
            switch (t) {
              case 5120:
              case 5121:
              case 5122:
              case 5123:
                t = gs;
            }
            for (const n in _s) {
              const [i, r, s] = _s[n];
              if (i === t && r === e) return { glType: n, name: s };
            }
            return null;
          }
          class ws {
            constructor(t) {
              (this.id = t.id),
                (this.attributeInfos = []),
                (this.attributeInfosByName = {}),
                (this.attributeInfosByLocation = []),
                (this.varyingInfos = []),
                (this.varyingInfosByName = {}),
                Object.seal(this),
                this._readAttributesFromProgram(t),
                this._readVaryingsFromProgram(t);
            }
            getAttributeInfo(t) {
              const e = Number(t);
              return Number.isFinite(e)
                ? this.attributeInfosByLocation[e]
                : this.attributeInfosByName[t] || null;
            }
            getAttributeLocation(t) {
              const e = this.getAttributeInfo(t);
              return e ? e.location : -1;
            }
            getAttributeAccessor(t) {
              const e = this.getAttributeInfo(t);
              return e ? e.accessor : null;
            }
            getVaryingInfo(t) {
              const e = Number(t);
              return Number.isFinite(e)
                ? this.varyingInfos[e]
                : this.varyingInfosByName[t] || null;
            }
            getVaryingIndex(t) {
              const e = this.getVaryingInfo();
              return e ? e.location : -1;
            }
            getVaryingAccessor(t) {
              const e = this.getVaryingInfo();
              return e ? e.accessor : null;
            }
            _readAttributesFromProgram(t) {
              const { gl: e } = t,
                n = e.getProgramParameter(t.handle, 35721);
              for (let i = 0; i < n; i++) {
                const {
                    name: n,
                    type: r,
                    size: s,
                  } = e.getActiveAttrib(t.handle, i),
                  o = e.getAttribLocation(t.handle, n);
                o >= 0 && this._addAttribute(o, n, r, s);
              }
              this.attributeInfos.sort((t, e) => t.location - e.location);
            }
            _readVaryingsFromProgram(t) {
              const { gl: e } = t;
              if (!S(e)) return;
              const n = e.getProgramParameter(t.handle, 35971);
              for (let i = 0; i < n; i++) {
                const {
                  name: n,
                  type: r,
                  size: s,
                } = e.getTransformFeedbackVarying(t.handle, i);
                this._addVarying(i, n, r, s);
              }
              this.varyingInfos.sort((t, e) => t.location - e.location);
            }
            _addAttribute(t, e, n, i) {
              const { type: r, components: s } = ys(n),
                o = { type: r, size: i * s };
              this._inferProperties(t, e, o);
              const a = { location: t, name: e, accessor: new mr(o) };
              this.attributeInfos.push(a),
                (this.attributeInfosByLocation[t] = a),
                (this.attributeInfosByName[a.name] = a);
            }
            _inferProperties(t, e, n) {
              /instance/i.test(e) && (n.divisor = 1);
            }
            _addVarying(t, e, n, i) {
              const { type: r, components: s } = ys(n),
                o = {
                  location: t,
                  name: e,
                  accessor: new mr({ type: r, size: i * s }),
                };
              this.varyingInfos.push(o), (this.varyingInfosByName[o.name] = o);
            }
          }
          const xs = 35981,
            Es = [
              "setVertexArray",
              "setAttributes",
              "setBuffers",
              "unsetBuffers",
              "use",
              "getUniformCount",
              "getUniformInfo",
              "getUniformLocation",
              "getUniformValue",
              "getVarying",
              "getFragDataLocation",
              "getAttachedShaders",
              "getAttributeCount",
              "getAttributeLocation",
              "getAttributeInfo",
            ];
          class Ps extends hr {
            constructor(t, e = {}) {
              super(t, e),
                this.stubRemovedMethods("Program", "v6.0", Es),
                (this._isCached = !1),
                this.initialize(e),
                Object.seal(this),
                this._setId(e.id);
            }
            initialize(t = {}) {
              const {
                hash: e,
                vs: n,
                fs: i,
                varyings: r,
                bufferMode: s = xs,
              } = t;
              return (
                (this.hash = e || ""),
                (this.vs =
                  "string" == typeof n
                    ? new fs(this.gl, { id: `${t.id}-vs`, source: n })
                    : n),
                (this.fs =
                  "string" == typeof i
                    ? new ps(this.gl, { id: `${t.id}-fs`, source: i })
                    : i),
                tr(this.vs instanceof fs),
                tr(this.fs instanceof ps),
                (this.uniforms = {}),
                (this._textureUniforms = {}),
                r &&
                  r.length > 0 &&
                  (C(this.gl),
                  (this.varyings = r),
                  this.gl2.transformFeedbackVaryings(this.handle, r, s)),
                this._compileAndLink(),
                this._readUniformLocationsFromLinkedProgram(),
                (this.configuration = new ws(this)),
                this.setProps(t)
              );
            }
            delete(t = {}) {
              return this._isCached ? this : super.delete(t);
            }
            setProps(t) {
              return "uniforms" in t && this.setUniforms(t.uniforms), this;
            }
            draw({
              logPriority: t,
              drawMode: e = 4,
              vertexCount: n,
              offset: i = 0,
              start: r,
              end: s,
              isIndexed: o = !1,
              indexType: a = 5123,
              instanceCount: c = 0,
              isInstanced: h = c > 0,
              vertexArray: l = null,
              transformFeedback: u,
              framebuffer: d,
              parameters: f = {},
              uniforms: p,
              samplers: g,
            }) {
              if (
                ((p || g) &&
                  (P.deprecated(
                    "Program.draw({uniforms})",
                    "Program.setUniforms(uniforms)"
                  )(),
                  this.setUniforms(p || {})),
                P.priority >= t)
              ) {
                const i = d ? d.id : "default",
                  r = `mode=${nr(
                    this.gl,
                    e
                  )} verts=${n} instances=${c} indexType=${nr(
                    this.gl,
                    a
                  )} isInstanced=${h} isIndexed=${o} Framebuffer=${i}`;
                P.log(t, r)();
              }
              return (
                tr(l),
                this.gl.useProgram(this.handle),
                !(
                  !this._areTexturesRenderable() ||
                  0 === n ||
                  (h && 0 === c) ||
                  (l.bindForDraw(n, c, () => {
                    if (
                      (void 0 !== d &&
                        (f = Object.assign({}, f, { framebuffer: d })),
                      u)
                    ) {
                      const t = (function (t) {
                        switch (t) {
                          case 0:
                            return 0;
                          case 1:
                          case 3:
                          case 2:
                            return 1;
                          case 4:
                          case 5:
                          case 6:
                            return 4;
                          default:
                            return tr(!1), 0;
                        }
                      })(e);
                      u.begin(t);
                    }
                    this._bindTextures(),
                      ht(this.gl, f, () => {
                        o && h
                          ? this.gl2.drawElementsInstanced(e, n, a, i, c)
                          : o && S(this.gl) && !isNaN(r) && !isNaN(s)
                          ? this.gl2.drawRangeElements(e, r, s, n, a, i)
                          : o
                          ? this.gl.drawElements(e, n, a, i)
                          : h
                          ? this.gl2.drawArraysInstanced(e, i, n, c)
                          : this.gl.drawArrays(e, i, n);
                      }),
                      u && u.end();
                  }),
                  0)
                )
              );
            }
            setUniforms(t = {}) {
              P.priority >= 2 &&
                (function (t, e, n) {
                  for (const i in t) {
                    const r = t[i];
                    if ((!n || Boolean(n[i])) && !is(r))
                      throw (
                        ((e = e ? `${e} ` : ""),
                        console.error(`${e} Bad uniform ${i}`, r),
                        new Error(`${e} Bad uniform ${i}`))
                      );
                  }
                })(t, this.id, this._uniformSetters),
                this.gl.useProgram(this.handle);
              for (const e in t) {
                const n = t[e],
                  i = this._uniformSetters[e];
                if (i) {
                  let t = n,
                    r = !1;
                  if ((t instanceof Wr && (t = t.texture), t instanceof Ar))
                    if (((r = this.uniforms[e] !== n), r)) {
                      void 0 === i.textureIndex &&
                        (i.textureIndex = this._textureIndexCounter++);
                      const n = t,
                        { textureIndex: r } = i;
                      n.bind(r), (t = r), (this._textureUniforms[e] = n);
                    } else t = i.textureIndex;
                  else
                    this._textureUniforms[e] && delete this._textureUniforms[e];
                  (i(t) || r) && rs(this.uniforms, e, n);
                }
              }
              return this;
            }
            _areTexturesRenderable() {
              let t = !0;
              for (const e in this._textureUniforms) {
                const n = this._textureUniforms[e];
                n.update(), (t = t && n.loaded);
              }
              return t;
            }
            _bindTextures() {
              for (const t in this._textureUniforms) {
                const e = this._uniformSetters[t].textureIndex;
                this._textureUniforms[t].bind(e);
              }
            }
            _createHandle() {
              return this.gl.createProgram();
            }
            _deleteHandle() {
              this.gl.deleteProgram(this.handle);
            }
            _getOptionsFromHandle(t) {
              const e = this.gl.getAttachedShaders(t),
                n = {};
              for (const t of e)
                switch (this.gl.getShaderParameter(this.handle, 35663)) {
                  case 35633:
                    n.vs = new fs({ handle: t });
                    break;
                  case 35632:
                    n.fs = new ps({ handle: t });
                }
              return n;
            }
            _getParameter(t) {
              return this.gl.getProgramParameter(this.handle, t);
            }
            _setId(t) {
              if (!t) {
                const t = this._getName();
                this.id = rr(t);
              }
            }
            _getName() {
              let t = this.vs.getName() || this.fs.getName();
              return (
                (t = t.replace(/shader/i, "")),
                (t = t ? `${t}-program` : "program"),
                t
              );
            }
            _compileAndLink() {
              const { gl: t } = this;
              if (
                (t.attachShader(this.handle, this.vs.handle),
                t.attachShader(this.handle, this.fs.handle),
                P.time(4, `linkProgram for ${this._getName()}`)(),
                t.linkProgram(this.handle),
                P.timeEnd(4, `linkProgram for ${this._getName()}`)(),
                t.debug || P.level > 0)
              ) {
                if (!t.getProgramParameter(this.handle, 35714))
                  throw new Error(
                    `Error linking: ${t.getProgramInfoLog(this.handle)}`
                  );
                if (
                  (t.validateProgram(this.handle),
                  !t.getProgramParameter(this.handle, 35715))
                )
                  throw new Error(
                    `Error validating: ${t.getProgramInfoLog(this.handle)}`
                  );
              }
            }
            _readUniformLocationsFromLinkedProgram() {
              const { gl: t } = this;
              (this._uniformSetters = {}),
                (this._uniformCount = this._getParameter(35718));
              for (let e = 0; e < this._uniformCount; e++) {
                const n = this.gl.getActiveUniform(this.handle, e),
                  { name: i } = ns(n.name);
                let r = t.getUniformLocation(this.handle, i);
                if (((this._uniformSetters[i] = es(t, r, n)), n.size > 1))
                  for (let e = 0; e < n.size; e++)
                    (r = t.getUniformLocation(this.handle, `${i}[${e}]`)),
                      (this._uniformSetters[`${i}[${e}]`] = es(t, r, n));
              }
              this._textureIndexCounter = 0;
            }
            getActiveUniforms(t, e) {
              return this.gl2.getActiveUniforms(this.handle, t, e);
            }
            getUniformBlockIndex(t) {
              return this.gl2.getUniformBlockIndex(this.handle, t);
            }
            getActiveUniformBlockParameter(t, e) {
              return this.gl2.getActiveUniformBlockParameter(this.handle, t, e);
            }
            uniformBlockBinding(t, e) {
              this.gl2.uniformBlockBinding(this.handle, t, e);
            }
          }
          class Ts {
            static getDefaultProgramManager(t) {
              return (
                (t.luma = t.luma || {}),
                (t.luma.defaultProgramManager =
                  t.luma.defaultProgramManager || new Ts(t)),
                t.luma.defaultProgramManager
              );
            }
            constructor(t) {
              (this.gl = t),
                (this._programCache = {}),
                (this._getUniforms = {}),
                (this._registeredModules = {}),
                (this._hookFunctions = []),
                (this._defaultModules = []),
                (this._hashes = {}),
                (this._hashCounter = 0),
                (this.stateHash = 0),
                (this._useCounts = {});
            }
            addDefaultModule(t) {
              this._defaultModules.find((e) => e.name === t.name) ||
                this._defaultModules.push(t),
                this.stateHash++;
            }
            removeDefaultModule(t) {
              const e = "string" == typeof t ? t : t.name;
              (this._defaultModules = this._defaultModules.filter(
                (t) => t.name !== e
              )),
                this.stateHash++;
            }
            addShaderHook(t, e) {
              e && (t = Object.assign(e, { hook: t })),
                this._hookFunctions.push(t),
                this.stateHash++;
            }
            get(t = {}) {
              const {
                  vs: e = "",
                  fs: n = "",
                  defines: i = {},
                  inject: r = {},
                  varyings: s = [],
                  bufferMode: o = 35981,
                  transpileToGLSL100: a = !1,
                } = t,
                c = this._getModuleList(t.modules),
                h = this._getHash(e),
                l = this._getHash(n),
                u = c.map((t) => this._getHash(t.name)).sort(),
                d = s.map((t) => this._getHash(t)),
                f = Object.keys(i).sort(),
                p = Object.keys(r).sort(),
                g = [],
                m = [];
              for (const t of f)
                g.push(this._getHash(t)), g.push(this._getHash(i[t]));
              for (const t of p)
                m.push(this._getHash(t)), m.push(this._getHash(r[t]));
              const b = `${h}/${l}D${g.join("/")}M${u.join("/")}I${m.join(
                "/"
              )}V${d.join("/")}H${this.stateHash}B${o}${a ? "T" : ""}`;
              if (!this._programCache[b]) {
                const t = (function (t, e) {
                  const { vs: n, fs: i } = e,
                    r = Pi(e.modules || []);
                  return {
                    gl: t,
                    vs: Zi(
                      t,
                      Object.assign({}, e, { source: n, type: bi, modules: r })
                    ),
                    fs: Zi(
                      t,
                      Object.assign({}, e, { source: i, type: _i, modules: r })
                    ),
                    getUniforms: Ki(r),
                  };
                })(this.gl, {
                  vs: e,
                  fs: n,
                  modules: c,
                  inject: r,
                  defines: i,
                  hookFunctions: this._hookFunctions,
                  transpileToGLSL100: a,
                });
                (this._programCache[b] = new Ps(this.gl, {
                  hash: b,
                  vs: t.vs,
                  fs: t.fs,
                  varyings: s,
                  bufferMode: o,
                })),
                  (this._getUniforms[b] = t.getUniforms || ((t) => {})),
                  (this._useCounts[b] = 0);
              }
              return this._useCounts[b]++, this._programCache[b];
            }
            getUniforms(t) {
              return this._getUniforms[t.hash] || null;
            }
            release(t) {
              const e = t.hash;
              this._useCounts[e]--,
                0 === this._useCounts[e] &&
                  (this._programCache[e].delete(),
                  delete this._programCache[e],
                  delete this._getUniforms[e],
                  delete this._useCounts[e]);
            }
            _getHash(t) {
              return (
                void 0 === this._hashes[t] &&
                  (this._hashes[t] = this._hashCounter++),
                this._hashes[t]
              );
            }
            _getModuleList(t = []) {
              const e = new Array(this._defaultModules.length + t.length),
                n = {};
              let i = 0;
              for (let t = 0, r = this._defaultModules.length; t < r; ++t) {
                const r = this._defaultModules[t],
                  s = r.name;
                (e[i++] = r), (n[s] = !0);
              }
              for (let r = 0, s = t.length; r < s; ++r) {
                const s = t[r],
                  o = s.name;
                n[o] || ((e[i++] = s), (n[o] = !0));
              }
              return (e.length = i), e;
            }
          }
          const As = Object.keys(ci)
              .map((t) =>
                "const int COORDINATE_SYSTEM_"
                  .concat(t, " = ")
                  .concat(ci[t], ";")
              )
              .join(""),
            Ss = Object.keys(hi)
              .map((t) =>
                "const int PROJECTION_MODE_".concat(t, " = ").concat(hi[t], ";")
              )
              .join(""),
            Ms = Object.keys(li)
              .map((t) =>
                "const int UNIT_"
                  .concat(t.toUpperCase(), " = ")
                  .concat(li[t], ";")
              )
              .join(""),
            Cs = ""
              .concat(As, "\n")
              .concat(Ss, "\n")
              .concat(
                Ms,
                "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n"
              );
          function Os(t, e) {
            if (t === e) return !0;
            if (Array.isArray(t)) {
              const n = t.length;
              if (!e || e.length !== n) return !1;
              for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1;
              return !0;
            }
            return !1;
          }
          function Ls(t) {
            let e,
              n = {};
            return (i) => {
              for (const r in i)
                if (!Os(i[r], n[r])) {
                  (e = t(i)), (n = i);
                  break;
                }
              return e;
            };
          }
          const Is = [0, 0, 0, 0],
            Rs = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            ks = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            js = [0, 0, 0],
            Fs = [0, 0, 0],
            Bs = Ls(function ({
              viewport: t,
              devicePixelRatio: e,
              coordinateSystem: n,
              coordinateOrigin: i,
            }) {
              const {
                  projectionCenter: r,
                  viewProjectionMatrix: s,
                  originCommon: o,
                  cameraPosCommon: a,
                  shaderCoordinateOrigin: c,
                  geospatialOrigin: h,
                } = (function (t, e, n) {
                  const { viewMatrixUncentered: i, projectionMatrix: r } = t;
                  let { viewMatrix: s, viewProjectionMatrix: o } = t,
                    a = Is,
                    c = Is,
                    h = t.cameraPosition;
                  const {
                    geospatialOrigin: l,
                    shaderCoordinateOrigin: u,
                    offsetMode: d,
                  } = Ds(t, e, n);
                  return (
                    d &&
                      ((c = t.projectPosition(l || u)),
                      (h = [h[0] - c[0], h[1] - c[1], h[2] - c[2]]),
                      (c[3] = 1),
                      (a = In([], c, o)),
                      (s = i || s),
                      (o = xn([], r, s)),
                      (o = xn([], o, Rs))),
                    {
                      viewMatrix: s,
                      viewProjectionMatrix: o,
                      projectionCenter: a,
                      originCommon: c,
                      cameraPosCommon: h,
                      shaderCoordinateOrigin: u,
                      geospatialOrigin: l,
                    }
                  );
                })(t, n, i),
                l = t.getDistanceScales(),
                u = [t.width * e, t.height * e],
                d =
                  t.projectionMatrix.transform([
                    0,
                    0,
                    -t.focalDistance,
                    1,
                  ])[3] || 1,
                f = {
                  project_uCoordinateSystem: n,
                  project_uProjectionMode: t.projectionMode,
                  project_uCoordinateOrigin: c,
                  project_uCommonOrigin: o.slice(0, 3),
                  project_uCenter: r,
                  project_uPseudoMeters: Boolean(t._pseudoMeters),
                  project_uViewportSize: u,
                  project_uDevicePixelRatio: e,
                  project_uFocalDistance: d,
                  project_uCommonUnitsPerMeter: l.unitsPerMeter,
                  project_uCommonUnitsPerWorldUnit: l.unitsPerMeter,
                  project_uCommonUnitsPerWorldUnit2: js,
                  project_uScale: t.scale,
                  project_uViewProjectionMatrix: s,
                  project_uCameraPosition: a,
                };
              if (h) {
                const e = t.getDistanceScales(h);
                switch (n) {
                  case ci.METER_OFFSETS:
                    (f.project_uCommonUnitsPerWorldUnit = e.unitsPerMeter),
                      (f.project_uCommonUnitsPerWorldUnit2 = e.unitsPerMeter2);
                    break;
                  case ci.LNGLAT:
                  case ci.LNGLAT_OFFSETS:
                    t._pseudoMeters ||
                      (f.project_uCommonUnitsPerMeter = e.unitsPerMeter),
                      (f.project_uCommonUnitsPerWorldUnit = e.unitsPerDegree),
                      (f.project_uCommonUnitsPerWorldUnit2 = e.unitsPerDegree2);
                    break;
                  case ci.CARTESIAN:
                    (f.project_uCommonUnitsPerWorldUnit = [
                      1,
                      1,
                      e.unitsPerMeter[2],
                    ]),
                      (f.project_uCommonUnitsPerWorldUnit2 = [
                        0,
                        0,
                        e.unitsPerMeter2[2],
                      ]);
                }
              }
              return f;
            });
          function Ds(t, e, n = Fs) {
            let i,
              r = n,
              s = !0;
            switch (
              ((i =
                e === ci.LNGLAT_OFFSETS || e === ci.METER_OFFSETS
                  ? n
                  : t.isGeospatial
                  ? [Math.fround(t.longitude), Math.fround(t.latitude), 0]
                  : null),
              t.projectionMode)
            ) {
              case hi.WEB_MERCATOR:
                (e !== ci.LNGLAT && e !== ci.CARTESIAN) ||
                  ((i = [0, 0, 0]), (s = !1));
                break;
              case hi.WEB_MERCATOR_AUTO_OFFSET:
                e === ci.LNGLAT
                  ? (r = i)
                  : e === ci.CARTESIAN &&
                    ((r = [
                      Math.fround(t.center[0]),
                      Math.fround(t.center[1]),
                      0,
                    ]),
                    (i = t.unprojectPosition(r)),
                    (r[0] -= n[0]),
                    (r[1] -= n[1]),
                    (r[2] -= n[2]));
                break;
              case hi.IDENTITY:
                r = t.position.map(Math.fround);
                break;
              case hi.GLOBE:
                (s = !1), (i = null);
                break;
              default:
                s = !1;
            }
            return (
              (r[2] = r[2] || 0),
              { geospatialOrigin: i, shaderCoordinateOrigin: r, offsetMode: s }
            );
          }
          const Ns = {},
            zs = {
              name: "project",
              dependencies: [
                {
                  name: "fp32",
                  vs: "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",
                  fs: null,
                },
                {
                  name: "geometry",
                  vs: "\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n",
                  fs: "\n#define SMOOTH_EDGE_RADIUS 0.5\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n",
                },
              ],
              vs: Cs,
              getUniforms: function (t = Ns) {
                return t.viewport
                  ? (function ({
                      viewport: t,
                      devicePixelRatio: e = 1,
                      modelMatrix: n = null,
                      coordinateSystem: i = ci.DEFAULT,
                      coordinateOrigin: r,
                      autoWrapLongitude: s = !1,
                    } = {}) {
                      i === ci.DEFAULT &&
                        (i = t.isGeospatial ? ci.LNGLAT : ci.CARTESIAN);
                      const o = Bs({
                        viewport: t,
                        devicePixelRatio: e,
                        coordinateSystem: i,
                        coordinateOrigin: r,
                      });
                      return (
                        (o.project_uWrapLongitude = s),
                        (o.project_uModelMatrix = n || ks),
                        o
                      );
                    })(t)
                  : {};
              },
            },
            Vs = [zs],
            Us = [
              "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
              "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
              "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
              "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)",
            ];
          function Gs(t) {
            const e = Ts.getDefaultProgramManager(t);
            for (const t of Vs) e.addDefaultModule(t);
            for (const t of Us) e.addShaderHook(t);
            return e;
          }
          const $s = Object.seal({
            layerManager: null,
            resourceManager: null,
            deck: null,
            gl: null,
            stats: null,
            shaderCache: null,
            pickingFBO: null,
            mousePosition: null,
            userData: {},
          });
          class Ws {
            constructor(
              t,
              { deck: e, stats: n, viewport: i, timeline: r } = {}
            ) {
              (this.lastRenderedLayers = []),
                (this.layers = []),
                (this.resourceManager = new He({ gl: t, protocol: "deck://" })),
                (this.context = {
                  ...$s,
                  layerManager: this,
                  gl: t,
                  deck: e,
                  programManager: t && Gs(t),
                  stats: n || new Lt({ id: "deck.gl" }),
                  viewport: i || new mi({ id: "DEFAULT-INITIAL-VIEWPORT" }),
                  timeline: r || new wt(),
                  resourceManager: this.resourceManager,
                }),
                (this._nextLayers = null),
                (this._needsRedraw = "Initial render"),
                (this._needsUpdate = !1),
                (this._debug = !1),
                (this.activateViewport = this.activateViewport.bind(this)),
                Object.seal(this);
            }
            finalize() {
              this.resourceManager.finalize();
              for (const t of this.layers) this._finalizeLayer(t);
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              let e = this._needsRedraw;
              t.clearRedrawFlags && (this._needsRedraw = !1);
              for (const n of this.layers) {
                const i = n.getNeedsRedraw(t);
                e = e || i;
              }
              return e;
            }
            needsUpdate() {
              return this._nextLayers &&
                this._nextLayers !== this.lastRenderedLayers
                ? "layers changed"
                : this._needsUpdate;
            }
            setNeedsRedraw(t) {
              this._needsRedraw = this._needsRedraw || t;
            }
            setNeedsUpdate(t) {
              this._needsUpdate = this._needsUpdate || t;
            }
            getLayers({ layerIds: t = null } = {}) {
              return t
                ? this.layers.filter((e) =>
                    t.find((t) => 0 === e.id.indexOf(t))
                  )
                : this.layers;
            }
            setProps(t) {
              "debug" in t && (this._debug = t.debug),
                "userData" in t && (this.context.userData = t.userData),
                "layers" in t && (this._nextLayers = t.layers),
                "onError" in t && (this.context.onError = t.onError);
            }
            setLayers(t, e) {
              Tt("layerManager.setLayers", this, e, t),
                (this.lastRenderedLayers = t),
                (t = At(t, Boolean));
              for (const e of t) e.context = this.context;
              return this._updateLayers(this.layers, t), this;
            }
            updateLayers() {
              const t = this.needsUpdate();
              t &&
                (this.setNeedsRedraw("updating layers: ".concat(t)),
                this.setLayers(this._nextLayers || this.lastRenderedLayers, t)),
                (this._nextLayers = null);
            }
            activateViewport(t) {
              return (
                Tt("layerManager.activateViewport", this, t),
                t && (this.context.viewport = t),
                this
              );
            }
            _handleError(t, e, n) {
              n.raiseError(e, "".concat(t, " of ").concat(n));
            }
            _updateLayers(t, e) {
              const n = {};
              for (const e of t)
                n[e.id]
                  ? Et.warn("Multiple old layers with same id ".concat(e.id))()
                  : (n[e.id] = e);
              const i = [];
              this._updateSublayersRecursively(e, n, i),
                this._finalizeOldLayers(n);
              let r = !1;
              for (const t of i)
                if (t.hasUniformTransition()) {
                  r = !0;
                  break;
                }
              (this._needsUpdate = r), (this.layers = i);
            }
            _updateSublayersRecursively(t, e, n) {
              for (const i of t) {
                i.context = this.context;
                const t = e[i.id];
                null === t &&
                  Et.warn("Multiple new layers with same id ".concat(i.id))(),
                  (e[i.id] = null);
                let r = null;
                try {
                  this._debug && t !== i && i.validateProps(),
                    t
                      ? (this._transferLayerState(t, i), this._updateLayer(i))
                      : this._initializeLayer(i),
                    n.push(i),
                    (r = i.isComposite && i.getSubLayers());
                } catch (t) {
                  this._handleError("matching", t, i);
                }
                r && this._updateSublayersRecursively(r, e, n);
              }
            }
            _finalizeOldLayers(t) {
              for (const e in t) {
                const n = t[e];
                n && this._finalizeLayer(n);
              }
            }
            _initializeLayer(t) {
              try {
                t._initialize(), (t.lifecycle = "Initialized");
              } catch (e) {
                this._handleError("initialization", e, t);
              }
            }
            _transferLayerState(t, e) {
              e._transferState(t),
                (e.lifecycle =
                  "Matched. State transferred from previous layer"),
                e !== t &&
                  (t.lifecycle = "Discarded. Awaiting garbage collection");
            }
            _updateLayer(t) {
              try {
                t._update();
              } catch (e) {
                this._handleError("update", e, t);
              }
            }
            _finalizeLayer(t) {
              (this._needsRedraw = this._needsRedraw || "finalized ".concat(t)),
                (t.lifecycle =
                  "No longer matched. Awaiting garbage collection");
              try {
                t._finalize(),
                  (t.lifecycle = "Finalized! Awaiting garbage collection");
              } catch (e) {
                this._handleError("finalization", e, t);
              }
            }
          }
          function Hs(t, e) {
            if (t === e) return !0;
            if (!t || !e) return !1;
            for (const n in t) {
              const i = t[n],
                r = e[n];
              if (
                !(i === r || (Array.isArray(i) && Array.isArray(r) && Hs(i, r)))
              )
                return !1;
            }
            return !0;
          }
          class Xs {
            constructor(t = {}) {
              (this.views = []),
                (this.width = 100),
                (this.height = 100),
                (this.viewState = {}),
                (this.controllers = {}),
                (this.timeline = t.timeline),
                (this._viewports = []),
                (this._viewportMap = {}),
                (this._isUpdating = !1),
                (this._needsRedraw = "Initial render"),
                (this._needsUpdate = !0),
                (this._eventManager = t.eventManager),
                (this._eventCallbacks = {
                  onViewStateChange: t.onViewStateChange,
                  onInteractionStateChange: t.onInteractionStateChange,
                }),
                Object.seal(this),
                this.setProps(t);
            }
            finalize() {
              for (const t in this.controllers)
                this.controllers[t] && this.controllers[t].finalize();
              this.controllers = {};
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this._needsRedraw;
              return t.clearRedrawFlags && (this._needsRedraw = !1), e;
            }
            setNeedsUpdate(t) {
              (this._needsUpdate = this._needsUpdate || t),
                (this._needsRedraw = this._needsRedraw || t);
            }
            updateViewStates() {
              for (const t in this.controllers) {
                const e = this.controllers[t];
                e && e.updateTransition();
              }
            }
            getViewports(t) {
              return t
                ? this._viewports.filter((e) => e.containsPixel(t))
                : this._viewports;
            }
            getViews() {
              const t = {};
              return (
                this.views.forEach((e) => {
                  t[e.id] = e;
                }),
                t
              );
            }
            getView(t) {
              return "string" == typeof t
                ? this.views.find((e) => e.id === t)
                : t;
            }
            getViewState(t) {
              const e = this.getView(t),
                n = (e && this.viewState[e.getViewStateId()]) || this.viewState;
              return e ? e.filterViewState(n) : n;
            }
            getViewport(t) {
              return this._viewportMap[t];
            }
            unproject(t, e) {
              const n = this.getViewports(),
                i = { x: t[0], y: t[1] };
              for (let r = n.length - 1; r >= 0; --r) {
                const s = n[r];
                if (s.containsPixel(i)) {
                  const n = t.slice();
                  return (n[0] -= s.x), (n[1] -= s.y), s.unproject(n, e);
                }
              }
              return null;
            }
            setProps(t) {
              "views" in t && this._setViews(t.views),
                "viewState" in t && this._setViewState(t.viewState),
                ("width" in t || "height" in t) &&
                  this._setSize(t.width, t.height),
                this._isUpdating || this._update();
            }
            _update() {
              (this._isUpdating = !0),
                this._needsUpdate &&
                  ((this._needsUpdate = !1), this._rebuildViewports()),
                this._needsUpdate &&
                  ((this._needsUpdate = !1), this._rebuildViewports()),
                (this._isUpdating = !1);
            }
            _setSize(t, e) {
              (t === this.width && e === this.height) ||
                ((this.width = t),
                (this.height = e),
                this.setNeedsUpdate("Size changed"));
            }
            _setViews(t) {
              (t = At(t, Boolean)),
                this._diffViews(t, this.views) &&
                  this.setNeedsUpdate("views changed"),
                (this.views = t);
            }
            _setViewState(t) {
              t
                ? (!Hs(t, this.viewState) &&
                    this.setNeedsUpdate("viewState changed"),
                  (this.viewState = t))
                : Et.warn("missing `viewState` or `initialViewState`")();
            }
            _onViewStateChange(t, e) {
              (e.viewId = t),
                this._eventCallbacks.onViewStateChange &&
                  this._eventCallbacks.onViewStateChange(e);
            }
            _createController(t, e) {
              return new (0, e.type)({
                timeline: this.timeline,
                eventManager: this._eventManager,
                onViewStateChange: this._onViewStateChange.bind(this, e.id),
                onStateChange: this._eventCallbacks.onInteractionStateChange,
                makeViewport: (e) =>
                  t._getViewport(e, { width: e.width, height: e.height }),
                ...e,
              });
            }
            _updateController(t, e, n, i) {
              let r = t.controller;
              return r
                ? ((r = {
                    ...e,
                    ...t.props,
                    ...r,
                    id: t.id,
                    x: n.x,
                    y: n.y,
                    width: n.width,
                    height: n.height,
                  }),
                  i ? i.setProps(r) : (i = this._createController(t, r)),
                  i)
                : null;
            }
            _rebuildViewports() {
              const { width: t, height: e, views: n } = this,
                i = this.controllers;
              (this._viewports = []), (this.controllers = {});
              let r = !1;
              for (let s = n.length; s--; ) {
                const o = n[s],
                  a = this.getViewState(o),
                  c = o.makeViewport({ width: t, height: e, viewState: a });
                let h = i[o.id];
                o.controller && !h && (r = !0),
                  (!r && o.controller) || !h || (h.finalize(), (h = null)),
                  (this.controllers[o.id] = this._updateController(o, a, c, h)),
                  this._viewports.unshift(c);
              }
              for (const t in i)
                i[t] && !this.controllers[t] && i[t].finalize();
              this._buildViewportMap();
            }
            _buildViewportMap() {
              (this._viewportMap = {}),
                this._viewports.forEach((t) => {
                  t.id &&
                    (this._viewportMap[t.id] = this._viewportMap[t.id] || t);
                });
            }
            _diffViews(t, e) {
              return (
                t.length !== e.length || t.some((n, i) => !t[i].equals(e[i]))
              );
            }
          }
          const qs = /([0-9]+\.?[0-9]*)(%|px)/;
          function Ys(t) {
            switch (typeof t) {
              case "number":
                return { position: t, relative: !1 };
              case "string":
                const e = t.match(qs);
                if (e && e.length >= 3) {
                  const t = "%" === e[2],
                    n = parseFloat(e[1]);
                  return { position: t ? n / 100 : n, relative: t };
                }
              default:
                throw new Error("Could not parse position string ".concat(t));
            }
          }
          function Zs(t, e) {
            return t.relative ? Math.round(t.position * e) : t.position;
          }
          function Ks(t, e) {
            if (!t) throw new Error(e || "deck.gl: assertion failed.");
          }
          const Qs = Math.PI / 180;
          function Js(t) {
            return 512 / 4003e4 / Math.cos(t * Qs);
          }
          class to extends mi {
            constructor(t = {}) {
              const {
                latitude: e = 0,
                longitude: n = 0,
                zoom: i = 11,
                pitch: r = 0,
                bearing: s = 0,
                nearZMultiplier: o = 0.1,
                farZMultiplier: a = 1.01,
                orthographic: c = !1,
                projectionMatrix: h,
                repeat: l = !1,
                worldOffset: u = 0,
                legacyMeterSizes: d = !1,
              } = t;
              let { width: f, height: p, altitude: g = 1.5 } = t;
              const m = Math.pow(2, i);
              let b;
              (f = f || 1), (p = p || 1);
              let _ = null;
              h
                ? ((g = h[5] / 2), (b = Jn(g)))
                : (t.fovy ? ((b = t.fovy), (g = ti(b))) : (b = Jn(g)),
                  (_ = Qn({
                    width: f,
                    height: p,
                    pitch: r,
                    fovy: b,
                    nearZMultiplier: o,
                    farZMultiplier: a,
                  })));
              let y = Kn({
                height: p,
                pitch: r,
                bearing: s,
                scale: m,
                altitude: g,
              });
              u && (y = new Bn().translate([512 * u, 0, 0]).multiplyLeft(y)),
                super({
                  ...t,
                  width: f,
                  height: p,
                  viewMatrix: y,
                  longitude: n,
                  latitude: e,
                  zoom: i,
                  ..._,
                  fovy: b,
                  focalDistance: g,
                }),
                (this.latitude = e),
                (this.longitude = n),
                (this.zoom = i),
                (this.pitch = r),
                (this.bearing = s),
                (this.altitude = g),
                (this.fovy = b),
                (this.orthographic = c),
                (this._subViewports = l ? [] : null),
                (this._pseudoMeters = d),
                Object.freeze(this);
            }
            get subViewports() {
              if (this._subViewports && !this._subViewports.length) {
                const t = this.getBounds(),
                  e = Math.floor((t[0] + 180) / 360),
                  n = Math.ceil((t[2] - 180) / 360);
                for (let t = e; t <= n; t++) {
                  const e = t ? new to({ ...this, worldOffset: t }) : this;
                  this._subViewports.push(e);
                }
              }
              return this._subViewports;
            }
            projectPosition(t) {
              if (this._pseudoMeters) return super.projectPosition(t);
              const [e, n] = this.projectFlat(t);
              return [e, n, (t[2] || 0) * Js(t[1])];
            }
            unprojectPosition(t) {
              if (this._pseudoMeters) return super.unprojectPosition(t);
              const [e, n] = this.unprojectFlat(t);
              return [e, n, (t[2] || 0) / Js(n)];
            }
            addMetersToLngLat(t, e) {
              return Zn(t, e);
            }
            panByPosition(t, e) {
              const n = ni(e, this.pixelUnprojectionMatrix),
                i = Cn([], this.projectFlat(t), On([], n)),
                r = Cn([], this.center, i),
                [s, o] = this.unprojectFlat(r);
              return { longitude: s, latitude: o };
            }
            getBounds(t = {}) {
              const e = si(this, t.z || 0);
              return [
                Math.min(e[0][0], e[1][0], e[2][0], e[3][0]),
                Math.min(e[0][1], e[1][1], e[2][1], e[3][1]),
                Math.max(e[0][0], e[1][0], e[2][0], e[3][0]),
                Math.max(e[0][1], e[1][1], e[2][1], e[3][1]),
              ];
            }
            fitBounds(t, e = {}) {
              const { width: n, height: i } = this,
                {
                  longitude: r,
                  latitude: s,
                  zoom: o,
                } = ii({ width: n, height: i, bounds: t, ...e });
              return new to({
                width: n,
                height: i,
                longitude: r,
                latitude: s,
                zoom: o,
              });
            }
          }
          function eo() {}
          to.displayName = "WebMercatorViewport";
          const no = { onStart: eo, onUpdate: eo, onInterrupt: eo, onEnd: eo };
          class io {
            constructor(t) {
              (this._inProgress = !1),
                (this._handle = null),
                (this.timeline = t),
                (this.settings = {});
            }
            get inProgress() {
              return this._inProgress;
            }
            start(t) {
              this.cancel(),
                (this.settings = { ...no, ...t }),
                (this._inProgress = !0),
                this.settings.onStart(this);
            }
            end() {
              this._inProgress &&
                (this.timeline.removeChannel(this._handle),
                (this._handle = null),
                (this._inProgress = !1),
                this.settings.onEnd(this));
            }
            cancel() {
              this._inProgress &&
                (this.settings.onInterrupt(this),
                this.timeline.removeChannel(this._handle),
                (this._handle = null),
                (this._inProgress = !1));
            }
            update() {
              if (!this._inProgress) return !1;
              if (null === this._handle) {
                const { timeline: t, settings: e } = this;
                this._handle = t.addChannel({
                  delay: t.getTime(),
                  duration: e.duration,
                });
              }
              return (
                (this.time = this.timeline.getTime(this._handle)),
                this._onUpdate(),
                this.settings.onUpdate(this),
                this.timeline.isFinished(this._handle) && this.end(),
                !0
              );
            }
            _onUpdate() {}
          }
          const ro = () => {},
            so = {
              transitionEasing: (t) => t,
              transitionInterruption: 1,
              onTransitionStart: ro,
              onTransitionInterrupt: ro,
              onTransitionEnd: ro,
            };
          class oo {
            constructor(t, e = {}) {
              (this.ControllerState = t),
                (this.props = { ...so, ...e }),
                (this.propsInTransition = null),
                (this.transition = new io(e.timeline)),
                (this.onViewStateChange = e.onViewStateChange || ro),
                (this.onStateChange = e.onStateChange || ro),
                (this._onTransitionUpdate =
                  this._onTransitionUpdate.bind(this));
            }
            finalize() {
              this.transition.cancel();
            }
            getViewportInTransition() {
              return this.propsInTransition;
            }
            processViewStateChange(t) {
              let e = !1;
              const n = this.props;
              if (
                ((t = { ...so, ...t }),
                (this.props = t),
                this._shouldIgnoreViewportChange(n, t))
              )
                return e;
              if (this._isTransitionEnabled(t)) {
                const { interruption: i, endProps: r } =
                    this.transition.settings,
                  s = { ...n, ...(2 === i ? r : this.propsInTransition || n) };
                this._triggerTransition(s, t), (e = !0);
              } else this.transition.cancel();
              return e;
            }
            updateTransition() {
              this.transition.update();
            }
            _isTransitionEnabled(t) {
              const { transitionDuration: e, transitionInterpolator: n } = t;
              return (e > 0 || "auto" === e) && Boolean(n);
            }
            _isUpdateDueToCurrentTransition(t) {
              return (
                !!this.transition.inProgress &&
                this.transition.settings.interpolator.arePropsEqual(
                  t,
                  this.propsInTransition
                )
              );
            }
            _shouldIgnoreViewportChange(t, e) {
              return this.transition.inProgress
                ? 3 === this.transition.settings.interruption ||
                    this._isUpdateDueToCurrentTransition(e)
                : !this._isTransitionEnabled(e) ||
                    e.transitionInterpolator.arePropsEqual(t, e);
            }
            _triggerTransition(t, e) {
              const n = new this.ControllerState(t),
                i = new this.ControllerState(e).shortestPathFrom(n),
                { transitionInterpolator: r } = e,
                s = r.getDuration ? r.getDuration(t, e) : e.transitionDuration;
              if (0 === s) return;
              const o = e.transitionInterpolator.initializeProps(t, i);
              (this.propsInTransition = {}),
                (this.duration = s),
                this.transition.start({
                  duration: s,
                  easing: e.transitionEasing,
                  interpolator: e.transitionInterpolator,
                  interruption: e.transitionInterruption,
                  startProps: o.start,
                  endProps: o.end,
                  onStart: e.onTransitionStart,
                  onUpdate: this._onTransitionUpdate,
                  onInterrupt: this._onTransitionEnd(e.onTransitionInterrupt),
                  onEnd: this._onTransitionEnd(e.onTransitionEnd),
                }),
                this.onStateChange({ inTransition: !0 }),
                this.updateTransition();
            }
            _onTransitionEnd(t) {
              return (e) => {
                (this.propsInTransition = null),
                  this.onStateChange({
                    inTransition: !1,
                    isZooming: !1,
                    isPanning: !1,
                    isRotating: !1,
                  }),
                  t(e);
              };
            }
            _onTransitionUpdate(t) {
              const {
                  time: e,
                  settings: {
                    interpolator: n,
                    startProps: i,
                    endProps: r,
                    duration: s,
                    easing: o,
                  },
                } = t,
                a = o(e / s),
                c = n.interpolateProps(i, r, a);
              (this.propsInTransition = new this.ControllerState({
                ...this.props,
                ...c,
              }).getViewportProps()),
                this.onViewStateChange({
                  viewState: this.propsInTransition,
                  oldViewState: this.props,
                });
            }
          }
          const ao = ["longitude", "latitude", "zoom", "bearing", "pitch"],
            co = ["longitude", "latitude", "zoom"];
          class ho extends class {
            constructor(t = {}) {
              Array.isArray(t) && (t = { compare: t, extract: t, required: t });
              const { compare: e, extract: n, required: i } = t;
              (this._propsToCompare = e),
                (this._propsToExtract = n),
                (this._requiredProps = i);
            }
            arePropsEqual(t, e) {
              for (const n of this._propsToCompare || Object.keys(e))
                if (!(n in t) || !(n in e) || !Je(t[n], e[n])) return !1;
              return !0;
            }
            initializeProps(t, e) {
              let n;
              if (this._propsToExtract) {
                const i = {},
                  r = {};
                for (const n of this._propsToExtract)
                  (i[n] = t[n]), (r[n] = e[n]);
                n = { start: i, end: r };
              } else n = { start: t, end: e };
              return (
                this._checkRequiredProps(n.start),
                this._checkRequiredProps(n.end),
                n
              );
            }
            interpolateProps(t, e, n) {
              return e;
            }
            getDuration(t, e) {
              return e.transitionDuration;
            }
            _checkRequiredProps(t) {
              this._requiredProps &&
                this._requiredProps.forEach((e) => {
                  const n = t[e];
                  Ks(
                    Number.isFinite(n) || Array.isArray(n),
                    "".concat(e, " is required for transition")
                  );
                });
            }
          } {
            constructor(t = {}) {
              super(
                (Array.isArray(t) ? t : t.transitionProps) || {
                  compare: ao,
                  extract: ao,
                  required: co,
                }
              ),
                (this.opts = t);
            }
            initializeProps(t, e) {
              const n = super.initializeProps(t, e),
                { makeViewport: i, around: r } = this.opts;
              if (i && r) {
                const s = i(t),
                  o = i(e),
                  a = s.unproject(r);
                (n.start.around = r),
                  Object.assign(n.end, {
                    around: o.project(a),
                    aroundPosition: a,
                    width: e.width,
                    height: e.height,
                  });
              }
              return n;
            }
            interpolateProps(t, e, n) {
              const i = {};
              for (const r of this._propsToExtract)
                i[r] = Qe(t[r] || 0, e[r] || 0, n);
              if (e.aroundPosition) {
                const r = this.opts.makeViewport({ ...e, ...i });
                Object.assign(
                  i,
                  r.panByPosition(e.aroundPosition, Qe(t.around, e.around, n))
                );
              }
              return i;
            }
          }
          const lo = { transitionDuration: 0 },
            uo = {
              transitionDuration: 300,
              transitionEasing: (t) => t,
              transitionInterruption: 1,
            },
            fo = (t) => 1 - (1 - t) * (1 - t),
            po = ["wheel"],
            go = ["panstart", "panmove", "panend"],
            mo = ["pinchstart", "pinchmove", "pinchend"],
            bo = ["tripanstart", "tripanmove", "tripanend"],
            _o = ["doubletap"],
            yo = ["keydown"];
          class vo extends class {
            constructor(t) {
              this._viewportProps = this._applyConstraints(t);
            }
            getViewportProps() {
              return this._viewportProps;
            }
            getState() {
              return this._state;
            }
            shortestPathFrom(t) {
              return this._viewportProps;
            }
            _applyConstraints(t) {
              return t;
            }
          } {
            constructor({
              makeViewport: t,
              width: e,
              height: n,
              latitude: i,
              longitude: r,
              zoom: s,
              bearing: o = 0,
              pitch: a = 0,
              altitude: c = 1.5,
              maxZoom: h = 20,
              minZoom: l = 0,
              maxPitch: u = 60,
              minPitch: d = 0,
              startPanLngLat: f,
              startZoomLngLat: p,
              startRotatePos: g,
              startBearing: m,
              startPitch: b,
              startZoom: _,
              normalize: y,
            } = {}) {
              Ks(Number.isFinite(r)),
                Ks(Number.isFinite(i)),
                Ks(Number.isFinite(s)),
                super({
                  width: e,
                  height: n,
                  latitude: i,
                  longitude: r,
                  zoom: s,
                  bearing: o,
                  pitch: a,
                  altitude: c,
                  maxZoom: h,
                  minZoom: l,
                  maxPitch: u,
                  minPitch: d,
                  normalize: y,
                }),
                (this._state = {
                  startPanLngLat: f,
                  startZoomLngLat: p,
                  startRotatePos: g,
                  startBearing: m,
                  startPitch: b,
                  startZoom: _,
                }),
                (this.makeViewport = t);
            }
            panStart({ pos: t }) {
              return this._getUpdatedState({
                startPanLngLat: this._unproject(t),
              });
            }
            pan({ pos: t, startPos: e }) {
              const n = this._state.startPanLngLat || this._unproject(e);
              if (!n) return this;
              const i = this.makeViewport(this._viewportProps).panByPosition(
                n,
                t
              );
              return this._getUpdatedState(i);
            }
            panEnd() {
              return this._getUpdatedState({ startPanLngLat: null });
            }
            rotateStart({ pos: t }) {
              return this._getUpdatedState({
                startRotatePos: t,
                startBearing: this._viewportProps.bearing,
                startPitch: this._viewportProps.pitch,
              });
            }
            rotate({ pos: t, deltaAngleX: e = 0, deltaAngleY: n = 0 }) {
              const {
                startRotatePos: i,
                startBearing: r,
                startPitch: s,
              } = this._state;
              if (!i || !Number.isFinite(r) || !Number.isFinite(s)) return this;
              let o;
              return (
                (o = t
                  ? this._calculateNewPitchAndBearing({
                      ...this._getRotationParams(t, i),
                      startBearing: r,
                      startPitch: s,
                    })
                  : { bearing: r + e, pitch: s + n }),
                this._getUpdatedState(o)
              );
            }
            rotateEnd() {
              return this._getUpdatedState({
                startBearing: null,
                startPitch: null,
              });
            }
            zoomStart({ pos: t }) {
              return this._getUpdatedState({
                startZoomLngLat: this._unproject(t),
                startZoom: this._viewportProps.zoom,
              });
            }
            zoom({ pos: t, startPos: e, scale: n }) {
              let { startZoom: i, startZoomLngLat: r } = this._state;
              Number.isFinite(i) ||
                ((i = this._viewportProps.zoom),
                (r = this._unproject(e) || this._unproject(t)));
              const s = this._calculateNewZoom({ scale: n, startZoom: i }),
                o = this.makeViewport({ ...this._viewportProps, zoom: s });
              return this._getUpdatedState({
                zoom: s,
                ...o.panByPosition(r, t),
              });
            }
            zoomEnd() {
              return this._getUpdatedState({
                startZoomLngLat: null,
                startZoom: null,
              });
            }
            zoomIn(t = 2) {
              return this._zoomFromCenter(t);
            }
            zoomOut(t = 2) {
              return this._zoomFromCenter(1 / t);
            }
            moveLeft(t = 100) {
              return this._panFromCenter([t, 0]);
            }
            moveRight(t = 100) {
              return this._panFromCenter([-t, 0]);
            }
            moveUp(t = 100) {
              return this._panFromCenter([0, t]);
            }
            moveDown(t = 100) {
              return this._panFromCenter([0, -t]);
            }
            rotateLeft(t = 15) {
              return this._getUpdatedState({
                bearing: this._viewportProps.bearing - t,
              });
            }
            rotateRight(t = 15) {
              return this._getUpdatedState({
                bearing: this._viewportProps.bearing + t,
              });
            }
            rotateUp(t = 10) {
              return this._getUpdatedState({
                pitch: this._viewportProps.pitch + t,
              });
            }
            rotateDown(t = 10) {
              return this._getUpdatedState({
                pitch: this._viewportProps.pitch - t,
              });
            }
            shortestPathFrom(t) {
              const e = t.getViewportProps(),
                n = { ...this._viewportProps },
                { bearing: i, longitude: r } = n;
              return (
                Math.abs(i - e.bearing) > 180 &&
                  (n.bearing = i < 0 ? i + 360 : i - 360),
                Math.abs(r - e.longitude) > 180 &&
                  (n.longitude = r < 0 ? r + 360 : r - 360),
                n
              );
            }
            _zoomFromCenter(t) {
              const { width: e, height: n } = this._viewportProps;
              return this.zoom({ pos: [e / 2, n / 2], scale: t });
            }
            _panFromCenter(t) {
              const { width: e, height: n } = this._viewportProps;
              return this.pan({
                startPos: [e / 2, n / 2],
                pos: [e / 2 + t[0], n / 2 + t[1]],
              });
            }
            _getUpdatedState(t) {
              return new this.constructor({
                makeViewport: this.makeViewport,
                ...this._viewportProps,
                ...this._state,
                ...t,
              });
            }
            _applyConstraints(t) {
              const { maxZoom: e, minZoom: n, zoom: i } = t;
              t.zoom = Ke(i, n, e);
              const { maxPitch: r, minPitch: s, pitch: o } = t;
              t.pitch = Ke(o, s, r);
              const { normalize: a = !0 } = t;
              return (
                a &&
                  Object.assign(
                    t,
                    (function ({
                      width: t,
                      height: e,
                      longitude: n,
                      latitude: i,
                      zoom: r,
                      pitch: s = 0,
                      bearing: o = 0,
                    }) {
                      (n < -180 || n > 180) && (n = Nn(n + 180, 360) - 180),
                        (o < -180 || o > 180) && (o = Nn(o + 180, 360) - 180);
                      const a = zn(e / 512);
                      if (r <= a) (r = a), (i = 0);
                      else {
                        const t = e / 2 / Math.pow(2, r),
                          n = qn([0, t])[1];
                        if (i < n) i = n;
                        else {
                          const e = qn([0, 512 - t])[1];
                          i > e && (i = e);
                        }
                      }
                      return {
                        width: t,
                        height: e,
                        longitude: n,
                        latitude: i,
                        zoom: r,
                        pitch: s,
                        bearing: o,
                      };
                    })(t)
                  ),
                t
              );
            }
            _unproject(t) {
              const e = this.makeViewport(this._viewportProps);
              return t && e.unproject(t);
            }
            _calculateNewZoom({ scale: t, startZoom: e }) {
              const { maxZoom: n, minZoom: i } = this._viewportProps;
              return Ke(e + Math.log2(t), i, n);
            }
            _calculateNewPitchAndBearing({
              deltaScaleX: t,
              deltaScaleY: e,
              startBearing: n,
              startPitch: i,
            }) {
              e = Ke(e, -1, 1);
              const { minPitch: r, maxPitch: s } = this._viewportProps;
              let o = i;
              return (
                e > 0 ? (o = i + e * (s - i)) : e < 0 && (o = i - e * (r - i)),
                { pitch: o, bearing: n + 180 * t }
              );
            }
            _getRotationParams(t, e) {
              const n = t[0] - e[0],
                i = t[1] - e[1],
                r = t[1],
                s = e[1],
                { width: o, height: a } = this._viewportProps,
                c = n / o;
              let h = 0;
              return (
                i > 0
                  ? Math.abs(a - s) > 5 && (h = (i / (s - a)) * 1.2)
                  : i < 0 && s > 5 && (h = 1 - r / s),
                (h = Math.min(1, Math.max(-1, h))),
                { deltaScaleX: c, deltaScaleY: h }
              );
            }
          }
          class wo extends class {
            constructor(t, e = {}) {
              (this.ControllerState = t),
                (this.controllerState = null),
                (this.controllerStateProps = null),
                (this.eventManager = null),
                (this.transitionManager = new oo(t, {
                  ...e,
                  onViewStateChange: this._onTransition.bind(this),
                  onStateChange: this._setInteractionState.bind(this),
                }));
              const n = this.linearTransitionProps;
              (this._transition = n && {
                ...uo,
                transitionInterpolator: new ho({ transitionProps: n }),
              }),
                (this._events = null),
                (this._interactionState = { isDragging: !1 }),
                (this._customEvents = []),
                (this.onViewStateChange = null),
                (this.onStateChange = null),
                (this.handleEvent = this.handleEvent.bind(this)),
                this.setProps(e);
            }
            get linearTransitionProps() {
              return null;
            }
            set events(t) {
              this.toggleEvents(this._customEvents, !1),
                this.toggleEvents(t, !0),
                (this._customEvents = t),
                this.setProps(this.controllerStateProps);
            }
            finalize() {
              for (const t in this._events)
                this._events[t] && this.eventManager.off(t, this.handleEvent);
              this.transitionManager.finalize();
            }
            handleEvent(t) {
              const { ControllerState: e } = this;
              this.controllerState = new e({
                makeViewport: this.makeViewport,
                ...this.controllerStateProps,
                ...this._state,
              });
              const n = this._eventStartBlocked;
              switch (t.type) {
                case "panstart":
                  return !n && this._onPanStart(t);
                case "panmove":
                  return this._onPan(t);
                case "panend":
                  return this._onPanEnd(t);
                case "pinchstart":
                  return !n && this._onPinchStart(t);
                case "pinchmove":
                  return this._onPinch(t);
                case "pinchend":
                  return this._onPinchEnd(t);
                case "tripanstart":
                  return !n && this._onTriplePanStart(t);
                case "tripanmove":
                  return this._onTriplePan(t);
                case "tripanend":
                  return this._onTriplePanEnd(t);
                case "doubletap":
                  return this._onDoubleTap(t);
                case "wheel":
                  return this._onWheel(t);
                case "keydown":
                  return this._onKeyDown(t);
                default:
                  return !1;
              }
            }
            getCenter(t) {
              const { x: e, y: n } = this.controllerStateProps,
                { offsetCenter: i } = t;
              return [i.x - e, i.y - n];
            }
            isPointInBounds(t, e) {
              const { width: n, height: i } = this.controllerStateProps;
              if (e && e.handled) return !1;
              const r = t[0] >= 0 && t[0] <= n && t[1] >= 0 && t[1] <= i;
              return r && e && e.stopPropagation(), r;
            }
            isFunctionKeyPressed(t) {
              const { srcEvent: e } = t;
              return Boolean(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
            }
            isDragging() {
              return this._interactionState.isDragging;
            }
            blockEvents(t) {
              const e = setTimeout(() => {
                this._eventStartBlocked === e &&
                  (this._eventStartBlocked = null);
              }, t);
              this._eventStartBlocked = e;
            }
            setProps(t) {
              "onViewStateChange" in t &&
                (this.onViewStateChange = t.onViewStateChange),
                "onStateChange" in t && (this.onStateChange = t.onStateChange),
                "makeViewport" in t && (this.makeViewport = t.makeViewport),
                "dragMode" in t && (this.dragMode = t.dragMode),
                (this.controllerStateProps = t),
                "eventManager" in t &&
                  this.eventManager !== t.eventManager &&
                  ((this.eventManager = t.eventManager),
                  (this._events = {}),
                  this.toggleEvents(this._customEvents, !0)),
                "transitionInterpolator" in t ||
                  (t.transitionInterpolator =
                    this._getTransitionProps().transitionInterpolator),
                this.transitionManager.processViewStateChange(t);
              let { inertia: e } = t;
              !0 === e && (e = 300), (this.inertia = e);
              const {
                  scrollZoom: n = !0,
                  dragPan: i = !0,
                  dragRotate: r = !0,
                  doubleClickZoom: s = !0,
                  touchZoom: o = !0,
                  touchRotate: a = !1,
                  keyboard: c = !0,
                } = t,
                h = Boolean(this.onViewStateChange);
              this.toggleEvents(po, h && n),
                this.toggleEvents(go, h && (i || r)),
                this.toggleEvents(mo, h && (o || a)),
                this.toggleEvents(bo, h && a),
                this.toggleEvents(_o, h && s),
                this.toggleEvents(yo, h && c),
                (this.scrollZoom = n),
                (this.dragPan = i),
                (this.dragRotate = r),
                (this.doubleClickZoom = s),
                (this.touchZoom = o),
                (this.touchRotate = a),
                (this.keyboard = c);
            }
            updateTransition() {
              this.transitionManager.updateTransition();
            }
            toggleEvents(t, e) {
              this.eventManager &&
                t.forEach((t) => {
                  this._events[t] !== e &&
                    ((this._events[t] = e),
                    e
                      ? this.eventManager.on(t, this.handleEvent)
                      : this.eventManager.off(t, this.handleEvent));
                });
            }
            updateViewport(t, e = {}, n = {}) {
              const i = { ...t.getViewportProps(), ...e },
                r = this.controllerState !== t;
              if (
                ((this._state = t.getState()), this._setInteractionState(n), r)
              ) {
                const t = this.controllerState
                  ? this.controllerState.getViewportProps()
                  : null;
                this.onViewStateChange &&
                  this.onViewStateChange({
                    viewState: i,
                    interactionState: this._interactionState,
                    oldViewState: t,
                  });
              }
            }
            _onTransition(t) {
              this.onViewStateChange &&
                ((t.interactionState = this._interactionState),
                this.onViewStateChange(t));
            }
            _setInteractionState(t) {
              Object.assign(this._interactionState, t),
                this.onStateChange &&
                  this.onStateChange(this._interactionState);
            }
            _onPanStart(t) {
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              let n = this.isFunctionKeyPressed(t) || t.rightButton;
              (this.invertPan || "pan" === this.dragMode) && (n = !n);
              const i = this.controllerState[n ? "panStart" : "rotateStart"]({
                pos: e,
              });
              return (
                (this._panMove = n),
                this.updateViewport(i, lo, { isDragging: !0 }),
                !0
              );
            }
            _onPan(t) {
              return (
                !!this.isDragging() &&
                (this._panMove ? this._onPanMove(t) : this._onPanRotate(t))
              );
            }
            _onPanEnd(t) {
              return (
                !!this.isDragging() &&
                (this._panMove
                  ? this._onPanMoveEnd(t)
                  : this._onPanRotateEnd(t))
              );
            }
            _onPanMove(t) {
              if (!this.dragPan) return !1;
              const e = this.getCenter(t),
                n = this.controllerState.pan({ pos: e });
              return (
                this.updateViewport(n, lo, { isDragging: !0, isPanning: !0 }),
                !0
              );
            }
            _onPanMoveEnd(t) {
              const { inertia: e } = this;
              if (this.dragPan && e && t.velocity) {
                const n = this.getCenter(t),
                  i = [
                    n[0] + (t.velocityX * e) / 2,
                    n[1] + (t.velocityY * e) / 2,
                  ],
                  r = this.controllerState.pan({ pos: i }).panEnd();
                this.updateViewport(
                  r,
                  {
                    ...this._getTransitionProps(),
                    transitionDuration: e,
                    transitionEasing: fo,
                  },
                  { isDragging: !1, isPanning: !0 }
                );
              } else {
                const t = this.controllerState.panEnd();
                this.updateViewport(t, null, { isDragging: !1, isPanning: !1 });
              }
              return !0;
            }
            _onPanRotate(t) {
              if (!this.dragRotate) return !1;
              const e = this.getCenter(t),
                n = this.controllerState.rotate({ pos: e });
              return (
                this.updateViewport(n, lo, { isDragging: !0, isRotating: !0 }),
                !0
              );
            }
            _onPanRotateEnd(t) {
              const { inertia: e } = this;
              if (this.dragRotate && e && t.velocity) {
                const n = this.getCenter(t),
                  i = [
                    n[0] + (t.velocityX * e) / 2,
                    n[1] + (t.velocityY * e) / 2,
                  ],
                  r = this.controllerState.rotate({ pos: i }).rotateEnd();
                this.updateViewport(
                  r,
                  {
                    ...this._getTransitionProps(),
                    transitionDuration: e,
                    transitionEasing: fo,
                  },
                  { isDragging: !1, isRotating: !0 }
                );
              } else {
                const t = this.controllerState.rotateEnd();
                this.updateViewport(t, null, {
                  isDragging: !1,
                  isRotating: !1,
                });
              }
              return !0;
            }
            _onWheel(t) {
              if (!this.scrollZoom) return !1;
              t.preventDefault();
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const { speed: n = 0.01, smooth: i = !1 } = this.scrollZoom,
                { delta: r } = t;
              let s = 2 / (1 + Math.exp(-Math.abs(r * n)));
              r < 0 && 0 !== s && (s = 1 / s);
              const o = this.controllerState.zoom({ pos: e, scale: s });
              return (
                this.updateViewport(
                  o,
                  {
                    ...this._getTransitionProps({ around: e }),
                    transitionDuration: i ? 250 : 1,
                  },
                  { isZooming: !0, isPanning: !0 }
                ),
                !0
              );
            }
            _onTriplePanStart(t) {
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const n = this.controllerState.rotateStart({ pos: e });
              return this.updateViewport(n, lo, { isDragging: !0 }), !0;
            }
            _onTriplePan(t) {
              if (!this.touchRotate) return !1;
              if (!this.isDragging()) return !1;
              const e = this.getCenter(t);
              e[0] -= t.deltaX;
              const n = this.controllerState.rotate({ pos: e });
              return (
                this.updateViewport(n, lo, { isDragging: !0, isRotating: !0 }),
                !0
              );
            }
            _onTriplePanEnd(t) {
              if (!this.isDragging()) return !1;
              const { inertia: e } = this;
              if (this.touchRotate && e && t.velocityY) {
                const n = this.getCenter(t),
                  i = [n[0], (n[1] += (t.velocityY * e) / 2)],
                  r = this.controllerState.rotate({ pos: i });
                this.updateViewport(
                  r,
                  {
                    ...this._getTransitionProps(),
                    transitionDuration: e,
                    transitionEasing: fo,
                  },
                  { isDragging: !1, isRotating: !0 }
                ),
                  this.blockEvents(e);
              } else {
                const t = this.controllerState.rotateEnd();
                this.updateViewport(t, null, {
                  isDragging: !1,
                  isRotating: !1,
                });
              }
              return !0;
            }
            _onPinchStart(t) {
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const n = this.controllerState
                .zoomStart({ pos: e })
                .rotateStart({ pos: e });
              return (
                (this._startPinchRotation = t.rotation),
                (this._lastPinchEvent = t),
                this.updateViewport(n, lo, { isDragging: !0 }),
                !0
              );
            }
            _onPinch(t) {
              if (!this.touchZoom && !this.touchRotate) return !1;
              if (!this.isDragging()) return !1;
              let e = this.controllerState;
              if (this.touchZoom) {
                const { scale: n } = t,
                  i = this.getCenter(t);
                e = e.zoom({ pos: i, scale: n });
              }
              if (this.touchRotate) {
                const { rotation: n } = t;
                e = e.rotate({ deltaAngleX: this._startPinchRotation - n });
              }
              return (
                this.updateViewport(e, lo, {
                  isDragging: !0,
                  isPanning: this.touchZoom,
                  isZooming: this.touchZoom,
                  isRotating: this.touchRotate,
                }),
                (this._lastPinchEvent = t),
                !0
              );
            }
            _onPinchEnd(t) {
              if (!this.isDragging()) return !1;
              const { inertia: e, _lastPinchEvent: n } = this;
              if (this.touchZoom && e && n && t.scale !== n.scale) {
                const i = this.getCenter(t);
                let r = this.controllerState.rotateEnd();
                const s = Math.log2(t.scale),
                  o = (s - Math.log2(n.scale)) / (t.deltaTime - n.deltaTime),
                  a = Math.pow(2, s + (o * e) / 2);
                (r = r.zoom({ pos: i, scale: a }).zoomEnd()),
                  this.updateViewport(
                    r,
                    {
                      ...this._getTransitionProps({ around: i }),
                      transitionDuration: e,
                      transitionEasing: fo,
                    },
                    {
                      isDragging: !1,
                      isPanning: this.touchZoom,
                      isZooming: this.touchZoom,
                      isRotating: !1,
                    }
                  ),
                  this.blockEvents(e);
              } else {
                const t = this.controllerState.zoomEnd().rotateEnd();
                this.updateViewport(t, null, {
                  isDragging: !1,
                  isPanning: !1,
                  isZooming: !1,
                  isRotating: !1,
                });
              }
              return (
                (this._startPinchRotation = null),
                (this._lastPinchEvent = null),
                !0
              );
            }
            _onDoubleTap(t) {
              if (!this.doubleClickZoom) return !1;
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const n = this.isFunctionKeyPressed(t),
                i = this.controllerState.zoom({ pos: e, scale: n ? 0.5 : 2 });
              return (
                this.updateViewport(
                  i,
                  this._getTransitionProps({ around: e }),
                  { isZooming: !0, isPanning: !0 }
                ),
                this.blockEvents(100),
                !0
              );
            }
            _onKeyDown(t) {
              if (!this.keyboard) return !1;
              const e = this.isFunctionKeyPressed(t),
                {
                  zoomSpeed: n,
                  moveSpeed: i,
                  rotateSpeedX: r,
                  rotateSpeedY: s,
                } = this.keyboard,
                { controllerState: o } = this;
              let a;
              const c = {};
              switch (t.srcEvent.code) {
                case "Minus":
                  (a = e ? o.zoomOut(n).zoomOut(n) : o.zoomOut(n)),
                    (c.isZooming = !0);
                  break;
                case "Equal":
                  (a = e ? o.zoomIn(n).zoomIn(n) : o.zoomIn(n)),
                    (c.isZooming = !0);
                  break;
                case "ArrowLeft":
                  e
                    ? ((a = o.rotateLeft(r)), (c.isRotating = !0))
                    : ((a = o.moveLeft(i)), (c.isPanning = !0));
                  break;
                case "ArrowRight":
                  e
                    ? ((a = o.rotateRight(r)), (c.isRotating = !0))
                    : ((a = o.moveRight(i)), (c.isPanning = !0));
                  break;
                case "ArrowUp":
                  e
                    ? ((a = o.rotateUp(s)), (c.isRotating = !0))
                    : ((a = o.moveUp(i)), (c.isPanning = !0));
                  break;
                case "ArrowDown":
                  e
                    ? ((a = o.rotateDown(s)), (c.isRotating = !0))
                    : ((a = o.moveDown(i)), (c.isPanning = !0));
                  break;
                default:
                  return !1;
              }
              return this.updateViewport(a, this._getTransitionProps(), c), !0;
            }
            _getTransitionProps(t) {
              const { _transition: e } = this;
              return e
                ? t
                  ? {
                      ...e,
                      transitionInterpolator: new ho({
                        ...t,
                        transitionProps: this.linearTransitionProps,
                        makeViewport: this.controllerState.makeViewport,
                      }),
                    }
                  : e
                : lo;
            }
          } {
            constructor(t) {
              (t.dragMode = t.dragMode || "pan"), super(vo, t);
            }
            setProps(t) {
              const e = this.controllerStateProps;
              super.setProps(t),
                (!e || e.height !== t.height) &&
                  this.updateViewport(
                    new this.ControllerState({
                      makeViewport: this.makeViewport,
                      ...this.controllerStateProps,
                      ...this._state,
                    })
                  );
            }
            get linearTransitionProps() {
              return ["longitude", "latitude", "zoom", "bearing", "pitch"];
            }
          }
          class xo extends class {
            constructor(t = {}) {
              const {
                id: e = null,
                x: n = 0,
                y: i = 0,
                width: r = "100%",
                height: s = "100%",
                viewportInstance: o,
                type: a = mi,
              } = t;
              Ks(!o || o instanceof mi),
                (this.viewportInstance = o),
                (this.id = e || this.constructor.displayName || "view"),
                (this.type = a),
                (this.props = { ...t, id: this.id }),
                this._parseDimensions({ x: n, y: i, width: r, height: s }),
                (this.equals = this.equals.bind(this)),
                Object.seal(this);
            }
            equals(t) {
              return (
                this === t ||
                (this.viewportInstance
                  ? t.viewportInstance &&
                    this.viewportInstance.equals(t.viewportInstance)
                  : Hs(this.props, t.props))
              );
            }
            makeViewport({ width: t, height: e, viewState: n }) {
              if (this.viewportInstance) return this.viewportInstance;
              n = this.filterViewState(n);
              const i = this.getDimensions({ width: t, height: e });
              return this._getViewport(n, i);
            }
            getViewStateId() {
              switch (typeof this.props.viewState) {
                case "string":
                  return this.props.viewState;
                case "object":
                  return this.props.viewState && this.props.viewState.id;
                default:
                  return this.id;
              }
            }
            filterViewState(t) {
              if (
                this.props.viewState &&
                "object" == typeof this.props.viewState
              ) {
                if (!this.props.viewState.id) return this.props.viewState;
                const e = { ...t };
                for (const t in this.props.viewState)
                  "id" !== t && (e[t] = this.props.viewState[t]);
                return e;
              }
              return t;
            }
            getDimensions({ width: t, height: e }) {
              return {
                x: Zs(this._x, t),
                y: Zs(this._y, e),
                width: Zs(this._width, t),
                height: Zs(this._height, e),
              };
            }
            _getControllerProps(t) {
              let e = this.props.controller;
              return e
                ? !0 === e
                  ? t
                  : ("function" == typeof e && (e = { type: e }),
                    { ...t, ...e })
                : null;
            }
            _getViewport(t, e) {
              const { type: n } = this;
              return new n({ ...t, ...this.props, ...e });
            }
            _parseDimensions({ x: t, y: e, width: n, height: i }) {
              (this._x = Ys(t)),
                (this._y = Ys(e)),
                (this._width = Ys(n)),
                (this._height = Ys(i));
            }
          } {
            constructor(t) {
              super({ ...t, type: to });
            }
            get controller() {
              return this._getControllerProps({ type: wo });
            }
          }
          xo.displayName = "MapView";
          const Eo = [255, 255, 255],
            Po = 1;
          let To = 0;
          class Ao {
            constructor(t = {}) {
              const { color: e = Eo } = t,
                { intensity: n = Po } = t;
              (this.id = t.id || "ambient-".concat(To++)),
                (this.color = e),
                (this.intensity = n),
                (this.type = "ambient");
            }
          }
          const So = [255, 255, 255],
            Mo = 1,
            Co = [0, 0, -1];
          let Oo = 0;
          class Lo {
            constructor(t = {}) {
              const { color: e = So } = t,
                { intensity: n = Mo } = t,
                { direction: i = Co } = t,
                { _shadow: r = !1 } = t;
              (this.id = t.id || "directional-".concat(Oo++)),
                (this.color = e),
                (this.intensity = n),
                (this.type = "directional"),
                (this.direction = new gn(i).normalize().toArray()),
                (this.shadow = r);
            }
            getProjectedLight() {
              return this;
            }
          }
          class Io {
            constructor(t = {}) {
              const { id: e = "effect" } = t;
              (this.id = e), (this.props = { ...t });
            }
            preRender() {}
            getModuleParameters() {}
            cleanup() {}
          }
          class Ro extends class {
            constructor(t, e = {}) {
              const { id: n = "pass" } = e;
              (this.id = n), (this.gl = t), (this.props = { ...e });
            }
            setProps(t) {
              Object.assign(this.props, t);
            }
            render() {}
            cleanup() {}
          } {
            render(t) {
              return (
                at(this.gl, { framebuffer: t.target }), this._drawLayers(t)
              );
            }
            _drawLayers(t) {
              const {
                viewports: e,
                views: n,
                onViewportActive: i,
                clearCanvas: r = !0,
              } = t;
              t.pass = t.pass || "unknown";
              const s = this.gl;
              r &&
                (function (t) {
                  at(t, {
                    viewport: [
                      0,
                      0,
                      t.drawingBufferWidth,
                      t.drawingBufferHeight,
                    ],
                  }),
                    t.clear(16640);
                })(s);
              const o = [];
              for (const r of e) {
                const e = r.viewport || r,
                  a = n && n[e.id];
                i(e);
                const c = this._getDrawLayerParams(e, t);
                t.view = a;
                const h = e.subViewports || [e];
                for (const e of h) {
                  t.viewport = e;
                  const n = this._drawLayersInViewport(s, t, c);
                  o.push(n);
                }
              }
              return o;
            }
            _getDrawLayerParams(
              t,
              {
                layers: e,
                pass: n,
                layerFilter: i,
                effects: r,
                moduleParameters: s,
              }
            ) {
              const o = [],
                a = ko(),
                c = {
                  viewport: t,
                  isPicking: n.startsWith("picking"),
                  renderPass: n,
                },
                h = {};
              for (let l = 0; l < e.length; l++) {
                const u = e[l],
                  d = this._shouldDrawLayer(u, c, i, h),
                  f = { shouldDrawLayer: d, layerRenderIndex: a(u, d) };
                d &&
                  ((f.moduleParameters = this._getModuleParameters(u, r, n, s)),
                  (f.layerParameters = this.getLayerParameters(u, l, t))),
                  (o[l] = f);
              }
              return o;
            }
            _drawLayersInViewport(
              t,
              { layers: e, pass: n, viewport: i, view: r },
              s
            ) {
              const o = (function (t, { viewport: e }) {
                const n = t.canvas
                    ? t.canvas.clientHeight || t.canvas.height
                    : 100,
                  i = e,
                  r = lt(t);
                return [
                  i.x * r,
                  (n - i.y - i.height) * r,
                  i.width * r,
                  i.height * r,
                ];
              })(t, { viewport: i });
              if (r && r.props.clear) {
                const e =
                  !0 === r.props.clear
                    ? { color: !0, depth: !0 }
                    : r.props.clear;
                ht(t, { scissorTest: !0, scissor: o }, () => Ir(t, e));
              }
              const a = {
                totalCount: e.length,
                visibleCount: 0,
                compositeCount: 0,
                pickableCount: 0,
              };
              at(t, { viewport: o });
              for (let t = 0; t < e.length; t++) {
                const r = e[t],
                  {
                    shouldDrawLayer: o,
                    layerRenderIndex: c,
                    moduleParameters: h,
                    layerParameters: l,
                  } = s[t];
                if ((o && r.props.pickable && a.pickableCount++, r.isComposite))
                  a.compositeCount++;
                else if (o) {
                  a.visibleCount++, (h.viewport = i);
                  try {
                    r.drawLayer({
                      moduleParameters: h,
                      uniforms: { layerIndex: c },
                      parameters: l,
                    });
                  } catch (t) {
                    r.raiseError(t, "drawing ".concat(r, " to ").concat(n));
                  }
                }
              }
              return a;
            }
            shouldDrawLayer(t) {
              return !0;
            }
            getModuleParameters(t, e) {
              return null;
            }
            getLayerParameters(t, e) {
              return t.props.parameters;
            }
            _shouldDrawLayer(t, e, n, i) {
              if (!this.shouldDrawLayer(t) || !t.props.visible) return !1;
              e.layer = t;
              let r = t.parent;
              for (; r; ) {
                if (!r.props.visible || !r.filterSubLayer(e)) return !1;
                (e.layer = r), (r = r.parent);
              }
              if (n) {
                const t = e.layer.id;
                if ((t in i || (i[t] = n(e)), !i[t])) return !1;
              }
              return t.activateViewport(e.viewport), !0;
            }
            _getModuleParameters(t, e, n, i) {
              const r = Object.assign(Object.create(t.props), {
                autoWrapLongitude: t.wrapLongitude,
                viewport: t.context.viewport,
                mousePosition: t.context.mousePosition,
                pickingActive: 0,
                devicePixelRatio: lt(this.gl),
              });
              if (e)
                for (const n of e) Object.assign(r, n.getModuleParameters(t));
              return Object.assign(r, this.getModuleParameters(t, e), i);
            }
          }
          function ko(t = 0, e = {}) {
            const n = {},
              i = (r, s) => {
                const o = r.props._offset,
                  a = r.id,
                  c = r.parent && r.parent.id;
                let h;
                if ((c && !(c in e) && i(r.parent, !1), c in n)) {
                  const t = (n[c] = n[c] || ko(e[c], e));
                  (h = t(r, s)), (n[a] = t);
                } else
                  Number.isFinite(o)
                    ? ((h = o + (e[c] || 0)), (n[a] = null))
                    : (h = t);
                return s && h >= t && (t = h + 1), (e[a] = h), h;
              };
            return i;
          }
          class jo extends Ro {
            constructor(t, e) {
              super(t, e),
                (this.shadowMap = new Sr(t, {
                  width: 1,
                  height: 1,
                  parameters: {
                    10241: 9729,
                    10240: 9729,
                    10242: 33071,
                    10243: 33071,
                  },
                })),
                (this.depthBuffer = new Or(t, {
                  format: 33189,
                  width: 1,
                  height: 1,
                })),
                (this.fbo = new Wr(t, {
                  id: "shadowmap",
                  width: 1,
                  height: 1,
                  attachments: {
                    36064: this.shadowMap,
                    36096: this.depthBuffer,
                  },
                }));
            }
            render(t) {
              const e = this.fbo;
              ht(
                this.gl,
                {
                  depthRange: [0, 1],
                  depthTest: !0,
                  blend: !1,
                  clearColor: [1, 1, 1, 1],
                },
                () => {
                  const n = t.viewports[0],
                    i = lt(this.gl),
                    r = n.width * i,
                    s = n.height * i;
                  (r === e.width && s === e.height) ||
                    e.resize({ width: r, height: s }),
                    super.render({ ...t, target: e, pass: "shadow" });
                }
              );
            }
            shouldDrawLayer(t) {
              return !1 !== t.props.shadowEnabled;
            }
            getModuleParameters() {
              return { drawToShadowMap: !0 };
            }
            delete() {
              this.fbo && (this.fbo.delete(), (this.fbo = null)),
                this.shadowMap &&
                  (this.shadowMap.delete(), (this.shadowMap = null)),
                this.depthBuffer &&
                  (this.depthBuffer.delete(), (this.depthBuffer = null));
            }
          }
          const Fo = Ls(function ({ viewport: t, center: e }) {
              return new Bn(t.viewProjectionMatrix).invert().transform(e);
            }),
            Bo = Ls(function ({ viewport: t, shadowMatrices: e }) {
              const n = [],
                i = t.pixelUnprojectionMatrix,
                r = t.isGeospatial ? void 0 : 1,
                s = [
                  [0, 0, r],
                  [t.width, 0, r],
                  [0, t.height, r],
                  [t.width, t.height, r],
                  [0, 0, -1],
                  [t.width, 0, -1],
                  [0, t.height, -1],
                  [t.width, t.height, -1],
                ].map((t) =>
                  (function (t, e) {
                    const [n, i, r] = t,
                      s = ni([n, i, r], e);
                    return Number.isFinite(r) ? s : [s[0], s[1], 0];
                  })(t, i)
                );
              for (const i of e) {
                const e = i.clone().translate(new gn(t.center).negate()),
                  r = s.map((t) => e.transform(t)),
                  o = new Bn().ortho({
                    left: Math.min(...r.map((t) => t[0])),
                    right: Math.max(...r.map((t) => t[0])),
                    bottom: Math.min(...r.map((t) => t[1])),
                    top: Math.max(...r.map((t) => t[1])),
                    near: Math.min(...r.map((t) => -t[2])),
                    far: Math.max(...r.map((t) => -t[2])),
                  });
                n.push(o.multiplyRight(i));
              }
              return n;
            }),
            Do = [0, 0, 0, 1],
            No = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            zo = {
              name: "shadow",
              dependencies: [zs],
              vs: "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n",
              fs: "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n",
              inject: {
                "vs:DECKGL_FILTER_GL_POSITION":
                  "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
                "fs:DECKGL_FILTER_COLOR":
                  "\n    color = shadow_filterShadowColor(color);\n    ",
              },
              getUniforms: (t = {}, e = {}) => {
                if (
                  t.drawToShadowMap ||
                  (t.shadowMaps && t.shadowMaps.length > 0)
                ) {
                  const { shadowEnabled: n = !0 } = t;
                  return n && t.shadowMatrices && t.shadowMatrices.length > 0
                    ? (function (t = {}, e = {}) {
                        const n = {
                            shadow_uDrawShadowMap: Boolean(t.drawToShadowMap),
                            shadow_uUseShadowMap:
                              !!t.shadowMaps && t.shadowMaps.length > 0,
                            shadow_uColor: t.shadowColor || Do,
                            shadow_uLightId: t.shadowLightId || 0,
                            shadow_uLightCount: t.shadowMatrices.length,
                          },
                          i = Fo({
                            viewport: t.viewport,
                            center: e.project_uCenter,
                          }),
                          r = [],
                          s = Bo({
                            shadowMatrices: t.shadowMatrices,
                            viewport: t.viewport,
                          }).slice();
                        for (let n = 0; n < t.shadowMatrices.length; n++) {
                          const o = s[n],
                            a = o
                              .clone()
                              .translate(new gn(t.viewport.center).negate());
                          e.project_uCoordinateSystem === ci.LNGLAT &&
                          e.project_uProjectionMode === hi.WEB_MERCATOR
                            ? ((s[n] = a), (r[n] = i))
                            : ((s[n] = o.clone().multiplyRight(No)),
                              (r[n] = a.transform(i)));
                        }
                        for (let e = 0; e < s.length; e++)
                          (n["shadow_uViewProjectionMatrices[".concat(e, "]")] =
                            s[e]),
                            (n["shadow_uProjectCenters[".concat(e, "]")] =
                              r[e]),
                            t.shadowMaps && t.shadowMaps.length > 0
                              ? (n["shadow_uShadowMap".concat(e)] =
                                  t.shadowMaps[e])
                              : (n["shadow_uShadowMap".concat(e)] =
                                  t.dummyShadowMap);
                        return n;
                      })(t, e)
                    : { shadow_uDrawShadowMap: !1, shadow_uUseShadowMap: !1 };
                }
                return {};
              },
            },
            Vo = { color: [255, 255, 255], intensity: 1 },
            Uo = [
              { color: [255, 255, 255], intensity: 1, direction: [-1, 3, -1] },
              {
                color: [255, 255, 255],
                intensity: 0.9,
                direction: [1, -8, -2.5],
              },
            ],
            Go = [0, 0, 0, 200 / 255];
          class $o extends Io {
            constructor(t) {
              super(t),
                (this.ambientLight = null),
                (this.directionalLights = []),
                (this.pointLights = []),
                (this.shadowColor = Go),
                (this.shadowPasses = []),
                (this.shadowMaps = []),
                (this.dummyShadowMap = null),
                (this.shadow = !1),
                (this.programManager = null);
              for (const e in t) {
                const n = t[e];
                switch (n.type) {
                  case "ambient":
                    this.ambientLight = n;
                    break;
                  case "directional":
                    this.directionalLights.push(n);
                    break;
                  case "point":
                    this.pointLights.push(n);
                }
              }
              this._applyDefaultLights(),
                (this.shadow = this.directionalLights.some((t) => t.shadow));
            }
            preRender(
              t,
              {
                layers: e,
                layerFilter: n,
                viewports: i,
                onViewportActive: r,
                views: s,
              }
            ) {
              if (this.shadow) {
                (this.shadowMatrices = this._createLightMatrix()),
                  0 === this.shadowPasses.length && this._createShadowPasses(t),
                  this.programManager ||
                    ((this.programManager = Ts.getDefaultProgramManager(t)),
                    zo && this.programManager.addDefaultModule(zo)),
                  this.dummyShadowMap ||
                    (this.dummyShadowMap = new Sr(t, { width: 1, height: 1 }));
                for (let t = 0; t < this.shadowPasses.length; t++)
                  this.shadowPasses[t].render({
                    layers: e,
                    layerFilter: n,
                    viewports: i,
                    onViewportActive: r,
                    views: s,
                    moduleParameters: {
                      shadowLightId: t,
                      dummyShadowMap: this.dummyShadowMap,
                      shadowMatrices: this.shadowMatrices,
                    },
                  });
              }
            }
            getModuleParameters(t) {
              const e = this.shadow
                ? {
                    shadowMaps: this.shadowMaps,
                    dummyShadowMap: this.dummyShadowMap,
                    shadowColor: this.shadowColor,
                    shadowMatrices: this.shadowMatrices,
                  }
                : {};
              return (
                (e.lightSources = {
                  ambientLight: this.ambientLight,
                  directionalLights: this.directionalLights.map((e) =>
                    e.getProjectedLight({ layer: t })
                  ),
                  pointLights: this.pointLights.map((e) =>
                    e.getProjectedLight({ layer: t })
                  ),
                }),
                e
              );
            }
            cleanup() {
              for (const t of this.shadowPasses) t.delete();
              (this.shadowPasses.length = 0),
                (this.shadowMaps.length = 0),
                this.dummyShadowMap &&
                  (this.dummyShadowMap.delete(), (this.dummyShadowMap = null)),
                this.shadow &&
                  this.programManager &&
                  (this.programManager.removeDefaultModule(zo),
                  (this.programManager = null));
            }
            _createLightMatrix() {
              const t = [];
              for (const e of this.directionalLights) {
                const n = new Bn().lookAt({
                  eye: new gn(e.direction).negate(),
                });
                t.push(n);
              }
              return t;
            }
            _createShadowPasses(t) {
              for (let e = 0; e < this.directionalLights.length; e++) {
                const n = new jo(t);
                (this.shadowPasses[e] = n), (this.shadowMaps[e] = n.shadowMap);
              }
            }
            _applyDefaultLights() {
              const {
                ambientLight: t,
                pointLights: e,
                directionalLights: n,
              } = this;
              t ||
                0 !== e.length ||
                0 !== n.length ||
                ((this.ambientLight = new Ao(Vo)),
                this.directionalLights.push(new Lo(Uo[0]), new Lo(Uo[1])));
            }
          }
          const Wo = new $o();
          class Ho {
            constructor() {
              (this.effects = []),
                (this._internalEffects = []),
                (this._needsRedraw = "Initial render"),
                this.setEffects();
            }
            setProps(t) {
              "effects" in t &&
                ((t.effects.length === this.effects.length &&
                  Hs(t.effects, this.effects)) ||
                  (this.setEffects(t.effects),
                  (this._needsRedraw = "effects changed")));
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this._needsRedraw;
              return t.clearRedrawFlags && (this._needsRedraw = !1), e;
            }
            getEffects() {
              return this._internalEffects;
            }
            finalize() {
              this.cleanup();
            }
            setEffects(t = []) {
              this.cleanup(), (this.effects = t), this._createInternalEffects();
            }
            cleanup() {
              for (const t of this.effects) t.cleanup();
              for (const t of this._internalEffects) t.cleanup();
              (this.effects.length = 0), (this._internalEffects.length = 0);
            }
            _createInternalEffects() {
              (this._internalEffects = this.effects.slice()),
                this.effects.some((t) => t instanceof $o) ||
                  this._internalEffects.push(Wo);
            }
          }
          class Xo extends Ro {}
          const qo = { blendFunc: [1, 0, 32771, 0], blendEquation: 32774 };
          class Yo extends Ro {
            render(t) {
              return t.pickingFBO
                ? this._drawPickingBuffer(t)
                : super.render(t);
            }
            _drawPickingBuffer({
              layers: t,
              layerFilter: e,
              views: n,
              viewports: i,
              onViewportActive: r,
              pickingFBO: s,
              deviceRect: { x: o, y: a, width: c, height: h },
              pass: l = "picking",
              redrawReason: u,
              pickZ: d,
            }) {
              const f = this.gl;
              this.pickZ = d;
              const p = !d && { byLayer: new Map(), byAlpha: [] };
              this._colors = p;
              const g = ht(
                f,
                {
                  scissorTest: !0,
                  scissor: [o, a, c, h],
                  clearColor: [0, 0, 0, 0],
                  depthMask: !0,
                  depthTest: !0,
                  depthRange: [0, 1],
                  colorMask: [!0, !0, !0, !0],
                  ...qo,
                  blend: !d,
                },
                () =>
                  super.render({
                    target: s,
                    layers: t,
                    layerFilter: e,
                    views: n,
                    viewports: i,
                    onViewportActive: r,
                    pass: l,
                    redrawReason: u,
                  })
              );
              return (
                (this._colors = null),
                { decodePickingColor: p && Zo.bind(null, p), stats: g }
              );
            }
            shouldDrawLayer(t) {
              return t.props.pickable;
            }
            getModuleParameters() {
              return {
                pickingActive: 1,
                pickingAttribute: this.pickZ,
                lightSources: {},
              };
            }
            getLayerParameters(t, e, n) {
              const i = { ...t.props.parameters };
              return (
                this.pickZ
                  ? (i.blend = !1)
                  : (Object.assign(i, qo),
                    (i.blend = !0),
                    (i.blendColor = (function (t, e, n) {
                      const { byLayer: i, byAlpha: r } = t;
                      let s;
                      if (i.has(e)) {
                        const t = i.get(e);
                        t.viewports.push(n), (s = t.a);
                      } else if (((s = i.size + 1), s <= 255)) {
                        const t = { a: s, layer: e, viewports: [n] };
                        i.set(e, t), (r[s] = t);
                      } else
                        Et.warn(
                          "Too many pickable layers, only picking the first 255"
                        )(),
                          (s = 0);
                      return [0, 0, 0, s / 255];
                    })(this._colors, t, n))),
                i
              );
            }
          }
          function Zo(t, e) {
            const n = t.byAlpha[e[3]];
            return (
              n && {
                pickedLayer: n.layer,
                pickedViewports: n.viewports,
                pickedObjectIndex: n.layer.decodePickingColor(e),
              }
            );
          }
          class Ko {
            constructor(t) {
              (this.gl = t),
                (this.layerFilter = null),
                (this.drawPickingColors = !1),
                (this.drawLayersPass = new Xo(t)),
                (this.pickLayersPass = new Yo(t)),
                (this.renderCount = 0),
                (this._needsRedraw = "Initial render"),
                (this.renderBuffers = []),
                (this.lastPostProcessEffect = null);
            }
            setProps(t) {
              "layerFilter" in t &&
                this.layerFilter !== t.layerFilter &&
                ((this.layerFilter = t.layerFilter),
                (this._needsRedraw = "layerFilter changed")),
                "drawPickingColors" in t &&
                  this.drawPickingColors !== t.drawPickingColors &&
                  ((this.drawPickingColors = t.drawPickingColors),
                  (this._needsRedraw = "drawPickingColors changed"));
            }
            renderLayers(t) {
              const e = this.drawPickingColors
                ? this.pickLayersPass
                : this.drawLayersPass;
              (t.layerFilter = t.layerFilter || this.layerFilter),
                (t.effects = t.effects || []),
                (t.target = t.target || Wr.getDefaultFramebuffer(this.gl)),
                this._preRender(t.effects, t);
              const n = this.lastPostProcessEffect
                  ? this.renderBuffers[0]
                  : t.target,
                i = e.render({ ...t, target: n });
              this._postRender(t.effects, t),
                this.renderCount++,
                Tt("deckRenderer.renderLayers", this, i, t);
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this._needsRedraw;
              return t.clearRedrawFlags && (this._needsRedraw = !1), e;
            }
            finalize() {
              const { renderBuffers: t } = this;
              for (const e of t) e.delete();
              t.length = 0;
            }
            _preRender(t, e) {
              let n = null;
              for (const i of t)
                i.preRender(this.gl, e), i.postRender && (n = i);
              n && this._resizeRenderBuffers(),
                (this.lastPostProcessEffect = n);
            }
            _resizeRenderBuffers() {
              const { renderBuffers: t } = this;
              0 === t.length && t.push(new Wr(this.gl), new Wr(this.gl));
              for (const e of t) e.resize();
            }
            _postRender(t, e) {
              const { renderBuffers: n } = this,
                i = { inputBuffer: n[0], swapBuffer: n[1], target: null };
              for (const r of t)
                if (r.postRender) {
                  if (r === this.lastPostProcessEffect) {
                    (i.target = e.target), r.postRender(this.gl, i);
                    break;
                  }
                  const t = r.postRender(this.gl, i);
                  (i.inputBuffer = t),
                    (i.swapBuffer = t === n[0] ? n[1] : n[0]);
                }
            }
          }
          const Qo = {
            pickedColor: null,
            pickedLayer: null,
            pickedObjectIndex: -1,
          };
          function Jo({
            pickedColors: t,
            decodePickingColor: e,
            deviceX: n,
            deviceY: i,
            deviceRadius: r,
            deviceRect: s,
          }) {
            if (t) {
              const { x: o, y: a, width: c, height: h } = s;
              let l = r * r,
                u = -1,
                d = 0;
              for (let e = 0; e < h; e++) {
                const r = e + a - i,
                  s = r * r;
                if (s > l) d += 4 * c;
                else
                  for (let e = 0; e < c; e++) {
                    if (t[d + 3] - 1 >= 0) {
                      const t = e + o - n,
                        i = t * t + s;
                      i <= l && ((l = i), (u = d));
                    }
                    d += 4;
                  }
              }
              if (u >= 0) {
                const n = t.slice(u, u + 4),
                  i = e(n);
                if (i) {
                  const t = Math.floor(u / 4 / c),
                    e = u / 4 - t * c;
                  return {
                    ...i,
                    pickedColor: n,
                    pickedX: o + e,
                    pickedY: a + t,
                  };
                }
                Et.error(
                  "Picked non-existent layer. Is picking buffer corrupt?"
                )();
              }
            }
            return Qo;
          }
          function ta({
            pickInfo: t,
            viewports: e,
            pixelRatio: n,
            x: i,
            y: r,
            z: s,
          }) {
            let o = e[0];
            e.length > 1 &&
              (o = (function (t, e) {
                for (let n = t.length - 1; n >= 0; n--) {
                  const i = t[n];
                  if (i.containsPixel(e)) return i;
                }
                return t[0];
              })((null == t ? void 0 : t.pickedViewports) || e, {
                x: i,
                y: r,
              }));
            const a = o && o.unproject([i - o.x, r - o.y], { targetZ: s });
            return {
              color: null,
              layer: null,
              viewport: o,
              index: -1,
              picked: !1,
              x: i,
              y: r,
              pixel: [i, r],
              coordinate: a,
              devicePixel: t && [t.pickedX, t.pickedY],
              pixelRatio: n,
            };
          }
          function ea(t) {
            const { pickInfo: e, lastPickedInfo: n, mode: i, layers: r } = t,
              { pickedColor: s, pickedLayer: o, pickedObjectIndex: a } = e,
              c = o ? [o] : [];
            if ("hover" === i) {
              const t = n.index,
                e = n.layerId,
                i = o && o.props.id;
              if (i !== e || a !== t) {
                if (i !== e) {
                  const t = r.find((t) => t.props.id === e);
                  t && c.unshift(t);
                }
                (n.layerId = i), (n.index = a), (n.info = null);
              }
            }
            const h = ta(t),
              l = new Map();
            return (
              l.set(null, h),
              c.forEach((t) => {
                let e = { ...h };
                t === o && ((e.color = s), (e.index = a), (e.picked = !0)),
                  (e = na({ layer: t, info: e, mode: i })),
                  t === o && "hover" === i && (n.info = e),
                  l.set(e.layer.id, e),
                  "hover" === i && e.layer.updateAutoHighlight(e);
              }),
              l
            );
          }
          function na({ layer: t, info: e, mode: n }) {
            for (; t && e; ) {
              const i = e.layer || null;
              (e.sourceLayer = i),
                (e.layer = t),
                (e = t.getPickingInfo({ info: e, mode: n, sourceLayer: i })),
                (t = t.parent);
            }
            return e;
          }
          class ia {
            constructor(t) {
              (this.gl = t),
                (this.pickingFBO = null),
                (this.pickLayersPass = new Yo(t)),
                (this.layerFilter = null),
                (this.lastPickedInfo = {
                  index: -1,
                  layerId: null,
                  info: null,
                });
            }
            setProps(t) {
              "layerFilter" in t && (this.layerFilter = t.layerFilter),
                "_pickable" in t && (this._pickable = t._pickable);
            }
            finalize() {
              this.pickingFBO && this.pickingFBO.delete(),
                this.depthFBO &&
                  (this.depthFBO.color.delete(), this.depthFBO.delete());
            }
            pickObject(t) {
              return this._pickClosestObject(t);
            }
            pickObjects(t) {
              return this._pickVisibleObjects(t);
            }
            getLastPickedObject(
              { x: t, y: e, layers: n, viewports: i },
              r = this.lastPickedInfo.info
            ) {
              const s = r && r.layer && r.layer.id,
                o = r && r.viewport && r.viewport.id,
                a = s ? n.find((t) => t.id === s) : null,
                c = (o && i.find((t) => t.id === o)) || i[0],
                h = c && c.unproject([t - c.x, e - c.y]),
                l = { x: t, y: e, viewport: c, coordinate: h, layer: a };
              return a
                ? { ...r, ...l }
                : Object.assign(l, { color: null, object: null, index: -1 });
            }
            _resizeBuffer() {
              const { gl: t } = this;
              return (
                this.pickingFBO ||
                  ((this.pickingFBO = new Wr(t)),
                  Wr.isSupported(t, { colorBufferFloat: !0 }) &&
                    ((this.depthFBO = new Wr(t)),
                    this.depthFBO.attach({
                      36064: new Sr(t, {
                        format: S(t) ? 34836 : 6408,
                        type: 5126,
                      }),
                    }))),
                this.pickingFBO.resize({
                  width: t.canvas.width,
                  height: t.canvas.height,
                }),
                this.depthFBO &&
                  this.depthFBO.resize({
                    width: t.canvas.width,
                    height: t.canvas.height,
                  }),
                this.pickingFBO
              );
            }
            _getPickable(t) {
              if (!1 === this._pickable) return null;
              const e = t.filter((t) => t.isPickable() && !t.isComposite);
              return e.length ? e : null;
            }
            _pickClosestObject({
              layers: t,
              views: e,
              viewports: n,
              x: i,
              y: r,
              radius: s = 0,
              depth: o = 1,
              mode: a = "query",
              unproject3D: c,
              onViewportActive: h,
            }) {
              if (!(t = this._getPickable(t)))
                return {
                  result: [],
                  emptyInfo: ta({ viewports: n, x: i, y: r }),
                };
              this._resizeBuffer();
              const l = lt(this.gl),
                u = ut(this.gl, [i, r], !0),
                d = [
                  u.x + Math.floor(u.width / 2),
                  u.y + Math.floor(u.height / 2),
                ],
                f = Math.round(s * l),
                { width: p, height: g } = this.pickingFBO,
                m = this._getPickingRect({
                  deviceX: d[0],
                  deviceY: d[1],
                  deviceRadius: f,
                  deviceWidth: p,
                  deviceHeight: g,
                });
              let b;
              const _ = [],
                y = {};
              for (let s = 0; s < o; s++) {
                const u = Jo({
                  ...(m &&
                    this._drawAndSample({
                      layers: t,
                      views: e,
                      viewports: n,
                      onViewportActive: h,
                      deviceRect: m,
                      pass: "picking:".concat(a),
                      redrawReason: a,
                    })),
                  deviceX: d[0],
                  deviceY: d[1],
                  deviceRadius: f,
                  deviceRect: m,
                });
                let p;
                if (
                  (u.pickedLayer &&
                    c &&
                    this.depthFBO &&
                    (p =
                      this._drawAndSample({
                        layers: [u.pickedLayer],
                        views: e,
                        viewports: n,
                        onViewportActive: h,
                        deviceRect: {
                          x: u.pickedX,
                          y: u.pickedY,
                          width: 1,
                          height: 1,
                        },
                        pass: "picking:".concat(a),
                        redrawReason: "pick-z",
                        pickZ: !0,
                      }).pickedColors[0] *
                        n[0].distanceScales.metersPerUnit[2] +
                      n[0].position[2]),
                  u.pickedColor && s + 1 < o)
                ) {
                  const e = u.pickedColor[3] - 1;
                  (y[e] = !0), t[e].disablePickingIndex(u.pickedObjectIndex);
                }
                b = ea({
                  pickInfo: u,
                  lastPickedInfo: this.lastPickedInfo,
                  mode: a,
                  layers: t,
                  viewports: n,
                  x: i,
                  y: r,
                  z: p,
                  pixelRatio: l,
                });
                for (const t of b.values()) t.layer && _.push(t);
                if (!u.pickedColor) break;
              }
              for (const e in y) t[e].restorePickingColors();
              return { result: _, emptyInfo: b && b.get(null) };
            }
            _pickVisibleObjects({
              layers: t,
              views: e,
              viewports: n,
              x: i,
              y: r,
              width: s = 1,
              height: o = 1,
              mode: a = "query",
              maxObjects: c = null,
              onViewportActive: h,
            }) {
              if (!(t = this._getPickable(t))) return [];
              this._resizeBuffer();
              const l = lt(this.gl),
                u = ut(this.gl, [i, r], !0),
                d = u.x,
                f = u.y + u.height,
                p = ut(this.gl, [i + s, r + o], !0),
                g = p.x + p.width,
                m = p.y,
                b = { x: d, y: m, width: g - d, height: f - m },
                _ = (function ({ pickedColors: t, decodePickingColor: e }) {
                  const n = new Map();
                  if (t)
                    for (let i = 0; i < t.length; i += 4)
                      if (t[i + 3] - 1 >= 0) {
                        const r = t.slice(i, i + 4),
                          s = r.join(",");
                        if (!n.has(s)) {
                          const t = e(r);
                          t
                            ? n.set(s, { ...t, pickedColor: r })
                            : Et.error(
                                "Picked non-existent layer. Is picking buffer corrupt?"
                              )();
                        }
                      }
                  return Array.from(n.values());
                })(
                  this._drawAndSample({
                    layers: t,
                    views: e,
                    viewports: n,
                    onViewportActive: h,
                    deviceRect: b,
                    pass: "picking:".concat(a),
                    redrawReason: a,
                  })
                ),
                y = new Map(),
                v = Number.isFinite(c);
              for (let t = 0; t < _.length && !(v && y.size >= c); t++) {
                const e = _[t];
                let n = {
                  color: e.pickedColor,
                  layer: null,
                  index: e.pickedObjectIndex,
                  picked: !0,
                  x: i,
                  y: r,
                  width: s,
                  height: o,
                  pixelRatio: l,
                };
                (n = na({ layer: e.pickedLayer, info: n, mode: a })),
                  y.has(n.object) || y.set(n.object, n);
              }
              return Array.from(y.values());
            }
            _drawAndSample({
              layers: t,
              views: e,
              viewports: n,
              onViewportActive: i,
              deviceRect: r,
              pass: s,
              redrawReason: o,
              pickZ: a,
            }) {
              const c = a ? this.depthFBO : this.pickingFBO,
                { decodePickingColor: h } = this.pickLayersPass.render({
                  layers: t,
                  layerFilter: this.layerFilter,
                  views: e,
                  viewports: n,
                  onViewportActive: i,
                  pickingFBO: c,
                  deviceRect: r,
                  pass: s,
                  redrawReason: o,
                  pickZ: a,
                }),
                { x: l, y: u, width: d, height: f } = r,
                p = new (a ? Float32Array : Uint8Array)(d * f * 4);
              return (
                Br(c, {
                  sourceX: l,
                  sourceY: u,
                  sourceWidth: d,
                  sourceHeight: f,
                  target: p,
                }),
                { pickedColors: p, decodePickingColor: h }
              );
            }
            _getPickingRect({
              deviceX: t,
              deviceY: e,
              deviceRadius: n,
              deviceWidth: i,
              deviceHeight: r,
            }) {
              const s = Math.max(0, t - n),
                o = Math.max(0, e - n),
                a = Math.min(i, t + n + 1) - s,
                c = Math.min(r, e + n + 1) - o;
              return a <= 0 || c <= 0
                ? null
                : { x: s, y: o, width: a, height: c };
            }
          }
          const ra = {
            zIndex: 1,
            position: "absolute",
            pointerEvents: "none",
            color: "#a0a7b4",
            backgroundColor: "#29323c",
            padding: "10px",
            top: 0,
            left: 0,
            display: "none",
          };
          class sa {
            constructor(t) {
              const e = t.parentElement;
              e &&
                ((this.el = document.createElement("div")),
                (this.el.className = "deck-tooltip"),
                Object.assign(this.el.style, ra),
                e.appendChild(this.el)),
                (this.isVisible = !1);
            }
            setTooltip(t, e, n) {
              const i = this.el;
              if ("string" == typeof t) i.innerText = t;
              else {
                if (!t)
                  return (this.isVisible = !1), void (i.style.display = "none");
                "text" in t && (i.innerText = t.text),
                  "html" in t && (i.innerHTML = t.html),
                  "className" in t && (i.className = t.className),
                  Object.assign(i.style, t.style);
              }
              (this.isVisible = !0),
                (i.style.display = "block"),
                (i.style.transform = "translate("
                  .concat(e, "px, ")
                  .concat(n, "px)"));
            }
            remove() {
              this.el && this.el.remove();
            }
          }
          function oa(t, e) {
            if (!t) throw new Error(e);
          }
          const aa = {
              self: "undefined" != typeof self && self,
              window: "undefined" != typeof window && window,
              global: void 0 !== n.g && n.g,
              document: "undefined" != typeof document && document,
            },
            ca = aa.global || aa.self || aa.window,
            ha =
              "object" != typeof process ||
              "[object process]" !== String(process) ||
              process.browser,
            la =
              "undefined" != typeof process &&
              process.version &&
              /v([0-9]*)/.exec(process.version),
            { _parseImageNode: ua } = (la && parseFloat(la[1]), ca),
            da = "undefined" != typeof Image,
            fa = "undefined" != typeof ImageBitmap,
            pa = Boolean(ua),
            ga = !!ha || pa;
          function ma(t) {
            const e = (function (t) {
              return "undefined" != typeof ImageBitmap &&
                t instanceof ImageBitmap
                ? "imagebitmap"
                : "undefined" != typeof Image && t instanceof Image
                ? "image"
                : t && "object" == typeof t && t.data && t.width && t.height
                ? "data"
                : null;
            })(t);
            if (!e) throw new Error("Not an image");
            return e;
          }
          const ba = /^data:image\/svg\+xml/,
            _a = /\.svg((\?|#).*)?$/;
          function ya(t) {
            return t && (ba.test(t) || _a.test(t));
          }
          function va(t, e) {
            if (ya(e))
              throw new Error("SVG cannot be parsed directly to imagebitmap");
            return new Blob([new Uint8Array(t)]);
          }
          async function wa(t, e, n) {
            const i = (function (t, e) {
                if (ya(e)) {
                  let e = new TextDecoder().decode(t);
                  try {
                    "function" == typeof unescape &&
                      "function" == typeof encodeURIComponent &&
                      (e = unescape(encodeURIComponent(e)));
                  } catch (t) {
                    throw new Error(t.message);
                  }
                  return `data:image/svg+xml;base64,${btoa(e)}`;
                }
                return va(t, e);
              })(t, n),
              r = self.URL || self.webkitURL,
              s = "string" != typeof i && r.createObjectURL(i);
            try {
              return await (async function (t, e) {
                const n = new Image();
                return (
                  (n.src = t),
                  e.image && e.image.decode && n.decode
                    ? (await n.decode(), n)
                    : await new Promise((e, i) => {
                        try {
                          (n.onload = () => e(n)),
                            (n.onerror = (e) =>
                              i(new Error(`Could not load image ${t}: ${e}`)));
                        } catch (t) {
                          i(t);
                        }
                      })
                );
              })(s || i, e);
            } finally {
              s && r.revokeObjectURL(s);
            }
          }
          const xa = {};
          let Ea = !0;
          const Pa = !1,
            Ta = !0;
          function Aa(t) {
            const e = Sa(t);
            return (
              (function (t) {
                const e = Sa(t);
                return e.byteLength >= 24 && 2303741511 === e.getUint32(0, Pa)
                  ? {
                      mimeType: "image/png",
                      width: e.getUint32(16, Pa),
                      height: e.getUint32(20, Pa),
                    }
                  : null;
              })(e) ||
              (function (t) {
                const e = Sa(t);
                if (
                  !(
                    e.byteLength >= 3 &&
                    65496 === e.getUint16(0, Pa) &&
                    255 === e.getUint8(2)
                  )
                )
                  return null;
                const { tableMarkers: n, sofMarkers: i } = (function () {
                  const t = new Set([65499, 65476, 65484, 65501, 65534]);
                  for (let e = 65504; e < 65520; ++e) t.add(e);
                  return {
                    tableMarkers: t,
                    sofMarkers: new Set([
                      65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481,
                      65482, 65483, 65485, 65486, 65487, 65502,
                    ]),
                  };
                })();
                let r = 2;
                for (; r + 9 < e.byteLength; ) {
                  const t = e.getUint16(r, Pa);
                  if (i.has(t))
                    return {
                      mimeType: "image/jpeg",
                      height: e.getUint16(r + 5, Pa),
                      width: e.getUint16(r + 7, Pa),
                    };
                  if (!n.has(t)) return null;
                  (r += 2), (r += e.getUint16(r, Pa));
                }
                return null;
              })(e) ||
              (function (t) {
                const e = Sa(t);
                return e.byteLength >= 10 && 1195984440 === e.getUint32(0, Pa)
                  ? {
                      mimeType: "image/gif",
                      width: e.getUint16(6, Ta),
                      height: e.getUint16(8, Ta),
                    }
                  : null;
              })(e) ||
              (function (t) {
                const e = Sa(t);
                return e.byteLength >= 14 &&
                  16973 === e.getUint16(0, Pa) &&
                  e.getUint32(2, Ta) === e.byteLength
                  ? {
                      mimeType: "image/bmp",
                      width: e.getUint32(18, Ta),
                      height: e.getUint32(22, Ta),
                    }
                  : null;
              })(e)
            );
          }
          function Sa(t) {
            if (t instanceof DataView) return t;
            if (ArrayBuffer.isView(t)) return new DataView(t.buffer);
            if (t instanceof ArrayBuffer) return new DataView(t);
            throw new Error("toDataView");
          }
          const Ma = {
              id: "image",
              module: "images",
              name: "Images",
              version: "3.0.12",
              mimeTypes: [
                "image/png",
                "image/jpeg",
                "image/gif",
                "image/webp",
                "image/bmp",
                "image/vnd.microsoft.icon",
                "image/svg+xml",
              ],
              extensions: [
                "png",
                "jpg",
                "jpeg",
                "gif",
                "webp",
                "bmp",
                "ico",
                "svg",
              ],
              parse: async function (t, e, n) {
                const i = ((e = e || {}).image || {}).type || "auto",
                  { url: r } = n || {};
                let s;
                switch (
                  (function (t) {
                    switch (t) {
                      case "auto":
                      case "data":
                        return (function () {
                          if (fa) return "imagebitmap";
                          if (da) return "image";
                          if (ga) return "data";
                          throw new Error(
                            "Install '@loaders.gl/polyfills' to parse images under Node.js"
                          );
                        })();
                      default:
                        return (
                          (function (t) {
                            switch (t) {
                              case "auto":
                                return fa || da || ga;
                              case "imagebitmap":
                                return fa;
                              case "image":
                                return da;
                              case "data":
                                return ga;
                              default:
                                throw new Error(
                                  `@loaders.gl/images: image ${t} not supported in this environment`
                                );
                            }
                          })(t),
                          t
                        );
                    }
                  })(i)
                ) {
                  case "imagebitmap":
                    s = await (async function (t, e, n) {
                      let i;
                      i = ya(n) ? await wa(t, e, n) : va(t, n);
                      const r = e && e.imagebitmap;
                      return await (async function (t, e = null) {
                        if (
                          ((!(function (t) {
                            for (const e in t || xa) return !1;
                            return !0;
                          })(e) &&
                            Ea) ||
                            (e = null),
                          e)
                        )
                          try {
                            return await createImageBitmap(t, e);
                          } catch (t) {
                            console.warn(t), (Ea = !1);
                          }
                        return await createImageBitmap(t);
                      })(i, r);
                    })(t, e, r);
                    break;
                  case "image":
                    s = await wa(t, e, r);
                    break;
                  case "data":
                    s = await (function (t, e) {
                      const { mimeType: n } = Aa(t) || {},
                        { _parseImageNode: i } = ca;
                      return oa(i), i(t, n, e);
                    })(t, e);
                    break;
                  default:
                    oa(!1);
                }
                return (
                  "data" === i &&
                    (s = (function (t) {
                      switch (ma(t)) {
                        case "data":
                          return t;
                        case "image":
                        case "imagebitmap":
                          const e = document.createElement("canvas"),
                            n = e.getContext("2d");
                          if (!n) throw new Error("getImageData");
                          return (
                            (e.width = t.width),
                            (e.height = t.height),
                            n.drawImage(t, 0, 0),
                            n.getImageData(0, 0, t.width, t.height)
                          );
                        default:
                          throw new Error("getImageData");
                      }
                    })(s)),
                  s
                );
              },
              tests: [(t) => Boolean(Aa(new DataView(t)))],
              options: { image: { type: "auto", decode: !0 } },
            },
            Ca = {
              name: "JSON",
              extensions: ["json", "geojson"],
              mimeTypes: ["application/json", "application/geo+json"],
              testText: function (t) {
                const e = t[0],
                  n = t[t.length - 1];
                return ("{" === e && "}" === n) || ("[" === e && "]" === n);
              },
              parseTextSync: JSON.parse,
            },
            Oa = "8.6.0-beta.1",
            La = O.CO.deck && O.CO.deck.VERSION;
          if (La && La !== Oa)
            throw new Error(
              "deck.gl - multiple versions detected: "
                .concat(La, " vs ")
                .concat(Oa)
            );
          La ||
            (Et.log(1, "deck.gl ".concat(Oa))(),
            (O.CO.deck = Object.assign(O.CO.deck || {}, {
              VERSION: Oa,
              version: Oa,
              log: Et,
              _registerLoggers: function (t) {
                Pt = t;
              },
            })),
            (function (t) {
              const e = ke();
              t = Array.isArray(t) ? t : [t];
              for (const n of t) {
                const t = zt(n);
                e.find((e) => t === e) || e.unshift(t);
              }
            })([Ca, [Ma, { imagebitmap: { premultiplyAlpha: "none" } }]]));
          const Ia = O.CO.deck;
          class Ra extends hr {
            static isSupported(t, e = []) {
              const n = S(t),
                i = Ur(t, Nr);
              let r = n || i;
              for (const t of e)
                switch (t) {
                  case "queries":
                    r = r && n;
                    break;
                  case "timers":
                    r = r && i;
                    break;
                  default:
                    tr(!1);
                }
              return r;
            }
            constructor(t, e = {}) {
              super(t, e),
                (this.target = null),
                (this._queryPending = !1),
                (this._pollingPromise = null),
                Object.seal(this);
            }
            beginTimeElapsedQuery() {
              return this.begin(35007);
            }
            beginOcclusionQuery({ conservative: t = !1 } = {}) {
              return this.begin(t ? 36202 : 35887);
            }
            beginTransformFeedbackQuery() {
              return this.begin(35976);
            }
            begin(t) {
              return (
                this._queryPending ||
                  ((this.target = t),
                  this.gl2.beginQuery(this.target, this.handle)),
                this
              );
            }
            end() {
              return (
                this._queryPending ||
                  (this.target &&
                    (this.gl2.endQuery(this.target),
                    (this.target = null),
                    (this._queryPending = !0))),
                this
              );
            }
            isResultAvailable() {
              if (!this._queryPending) return !1;
              const t = this.gl2.getQueryParameter(this.handle, 34919);
              return t && (this._queryPending = !1), t;
            }
            isTimerDisjoint() {
              return this.gl2.getParameter(36795);
            }
            getResult() {
              return this.gl2.getQueryParameter(this.handle, 34918);
            }
            getTimerMilliseconds() {
              return this.getResult() / 1e6;
            }
            createPoll(t = Number.POSITIVE_INFINITY) {
              if (this._pollingPromise) return this._pollingPromise;
              let e = 0;
              return (
                (this._pollingPromise = new Promise((n, i) => {
                  const r = () => {
                    this.isResultAvailable()
                      ? (n(this.getResult()), (this._pollingPromise = null))
                      : e++ > t
                      ? (i("Timed out"), (this._pollingPromise = null))
                      : requestAnimationFrame(r);
                  };
                  requestAnimationFrame(r);
                })),
                this._pollingPromise
              );
            }
            _createHandle() {
              return Ra.isSupported(this.gl) ? this.gl2.createQuery() : null;
            }
            _deleteHandle() {
              this.gl2.deleteQuery(this.handle);
            }
          }
          const ka = (0, O.jU)() && "undefined" != typeof document;
          let ja = 0;
          class Fa {
            constructor(t = {}) {
              const {
                onCreateContext: e = (t) => bt(t),
                onAddHTML: n = null,
                onInitialize: i = () => {},
                onRender: r = () => {},
                onFinalize: s = () => {},
                onError: o,
                gl: a = null,
                glOptions: c = {},
                debug: h = !1,
                createFramebuffer: l = !1,
                autoResizeViewport: u = !0,
                autoResizeDrawingBuffer: d = !0,
                stats: f = Ji.get("animation-loop-" + ja++),
              } = t;
              let { useDevicePixels: p = !0 } = t;
              "useDevicePixelRatio" in t &&
                (P.deprecated("useDevicePixelRatio", "useDevicePixels")(),
                (p = t.useDevicePixelRatio)),
                (this.props = {
                  onCreateContext: e,
                  onAddHTML: n,
                  onInitialize: i,
                  onRender: r,
                  onFinalize: s,
                  onError: o,
                  gl: a,
                  glOptions: c,
                  debug: h,
                  createFramebuffer: l,
                }),
                (this.gl = a),
                (this.needsRedraw = null),
                (this.timeline = null),
                (this.stats = f),
                (this.cpuTime = this.stats.get("CPU Time")),
                (this.gpuTime = this.stats.get("GPU Time")),
                (this.frameRate = this.stats.get("Frame Rate")),
                (this._initialized = !1),
                (this._running = !1),
                (this._animationFrameId = null),
                (this._nextFramePromise = null),
                (this._resolveNextFrame = null),
                (this._cpuStartTime = 0),
                this.setProps({
                  autoResizeViewport: u,
                  autoResizeDrawingBuffer: d,
                  useDevicePixels: p,
                }),
                (this.start = this.start.bind(this)),
                (this.stop = this.stop.bind(this)),
                (this._pageLoadPromise = null),
                (this._onMousemove = this._onMousemove.bind(this)),
                (this._onMouseleave = this._onMouseleave.bind(this));
            }
            delete() {
              this.stop(), this._setDisplay(null);
            }
            setNeedsRedraw(t) {
              return (
                tr("string" == typeof t),
                (this.needsRedraw = this.needsRedraw || t),
                this
              );
            }
            setProps(t) {
              return (
                "autoResizeViewport" in t &&
                  (this.autoResizeViewport = t.autoResizeViewport),
                "autoResizeDrawingBuffer" in t &&
                  (this.autoResizeDrawingBuffer = t.autoResizeDrawingBuffer),
                "useDevicePixels" in t &&
                  (this.useDevicePixels = t.useDevicePixels),
                this
              );
            }
            start(t = {}) {
              if (this._running) return this;
              this._running = !0;
              const e = this._getPageLoadPromise()
                .then(() =>
                  !this._running || this._initialized
                    ? null
                    : (this._createWebGLContext(t),
                      this._createFramebuffer(),
                      this._startEventHandling(),
                      this._initializeCallbackData(),
                      this._updateCallbackData(),
                      this._resizeCanvasDrawingBuffer(),
                      this._resizeViewport(),
                      (this._gpuTimeQuery = Ra.isSupported(this.gl, ["timers"])
                        ? new Ra(this.gl)
                        : null),
                      (this._initialized = !0),
                      this.onInitialize(this.animationProps))
                )
                .then((t) => {
                  this._running &&
                    (this._addCallbackData(t || {}),
                    !1 !== t && this._startLoop());
                });
              return this.props.onError && e.catch(this.props.onError), this;
            }
            redraw() {
              return (
                this.isContextLost() ||
                  (this._beginTimers(),
                  this._setupFrame(),
                  this._updateCallbackData(),
                  this._renderFrame(this.animationProps),
                  this._clearNeedsRedraw(),
                  this.offScreen && this.gl.commit && this.gl.commit(),
                  this._resolveNextFrame &&
                    (this._resolveNextFrame(this),
                    (this._nextFramePromise = null),
                    (this._resolveNextFrame = null)),
                  this._endTimers()),
                this
              );
            }
            stop() {
              return (
                this._running &&
                  (this._finalizeCallbackData(),
                  this._cancelAnimationFrame(this._animationFrameId),
                  (this._nextFramePromise = null),
                  (this._resolveNextFrame = null),
                  (this._animationFrameId = null),
                  (this._running = !1)),
                this
              );
            }
            attachTimeline(t) {
              return (this.timeline = t), this.timeline;
            }
            detachTimeline() {
              this.timeline = null;
            }
            waitForRender() {
              return (
                this.setNeedsRedraw("waitForRender"),
                this._nextFramePromise ||
                  (this._nextFramePromise = new Promise((t) => {
                    this._resolveNextFrame = t;
                  })),
                this._nextFramePromise
              );
            }
            async toDataURL() {
              return (
                this.setNeedsRedraw("toDataURL"),
                await this.waitForRender(),
                this.gl.canvas.toDataURL()
              );
            }
            isContextLost() {
              return this.gl.isContextLost();
            }
            onCreateContext(...t) {
              return this.props.onCreateContext(...t);
            }
            onInitialize(...t) {
              return this.props.onInitialize(...t);
            }
            onRender(...t) {
              return this.props.onRender(...t);
            }
            onFinalize(...t) {
              return this.props.onFinalize(...t);
            }
            getHTMLControlValue(t, e = 1) {
              const n = document.getElementById(t);
              return n ? Number(n.value) : e;
            }
            setViewParameters() {
              return (
                P.removed(
                  "AnimationLoop.setViewParameters",
                  "AnimationLoop.setProps"
                )(),
                this
              );
            }
            _startLoop() {
              const t = () => {
                this._running &&
                  (this.redraw(),
                  (this._animationFrameId = this._requestAnimationFrame(t)));
              };
              this._cancelAnimationFrame(this._animationFrameId),
                (this._animationFrameId = this._requestAnimationFrame(t));
            }
            _getPageLoadPromise() {
              return (
                this._pageLoadPromise ||
                  (this._pageLoadPromise = ka
                    ? new Promise((t, e) => {
                        ka && "complete" === document.readyState
                          ? t(document)
                          : window.addEventListener("load", () => {
                              t(document);
                            });
                      })
                    : Promise.resolve({})),
                this._pageLoadPromise
              );
            }
            _setDisplay(t) {
              this.display &&
                (this.display.delete(), (this.display.animationLoop = null)),
                t && (t.animationLoop = this),
                (this.display = t);
            }
            _cancelAnimationFrame(t) {
              return this.display && this.display.cancelAnimationFrame
                ? this.display.cancelAnimationFrame(t)
                : ((e = t),
                  "undefined" != typeof window && window.cancelAnimationFrame
                    ? window.cancelAnimationFrame(e)
                    : clearTimeout(e));
              var e;
            }
            _requestAnimationFrame(t) {
              if (this._running)
                return this.display && this.display.requestAnimationFrame
                  ? this.display.requestAnimationFrame(t)
                  : ((e = t),
                    "undefined" != typeof window && window.requestAnimationFrame
                      ? window.requestAnimationFrame(e)
                      : setTimeout(e, 1e3 / 60));
              var e;
            }
            _renderFrame(...t) {
              this.display
                ? this.display._renderFrame(...t)
                : this.onRender(...t);
            }
            _clearNeedsRedraw() {
              this.needsRedraw = null;
            }
            _setupFrame() {
              this._resizeCanvasDrawingBuffer(),
                this._resizeViewport(),
                this._resizeFramebuffer();
            }
            _initializeCallbackData() {
              this.animationProps = {
                gl: this.gl,
                stop: this.stop,
                canvas: this.gl.canvas,
                framebuffer: this.framebuffer,
                useDevicePixels: this.useDevicePixels,
                needsRedraw: null,
                startTime: Date.now(),
                engineTime: 0,
                tick: 0,
                tock: 0,
                time: 0,
                _timeline: this.timeline,
                _loop: this,
                _animationLoop: this,
                _mousePosition: null,
              };
            }
            _updateCallbackData() {
              const {
                width: t,
                height: e,
                aspect: n,
              } = this._getSizeAndAspect();
              (t === this.animationProps.width &&
                e === this.animationProps.height) ||
                this.setNeedsRedraw("drawing buffer resized"),
                n !== this.animationProps.aspect &&
                  this.setNeedsRedraw("drawing buffer aspect changed"),
                (this.animationProps.width = t),
                (this.animationProps.height = e),
                (this.animationProps.aspect = n),
                (this.animationProps.needsRedraw = this.needsRedraw),
                (this.animationProps.engineTime =
                  Date.now() - this.animationProps.startTime),
                this.timeline &&
                  this.timeline.update(this.animationProps.engineTime),
                (this.animationProps.tick = Math.floor(
                  (this.animationProps.time / 1e3) * 60
                )),
                this.animationProps.tock++,
                (this.animationProps.time = this.timeline
                  ? this.timeline.getTime()
                  : this.animationProps.engineTime),
                (this.animationProps._offScreen = this.offScreen);
            }
            _finalizeCallbackData() {
              this.onFinalize(this.animationProps);
            }
            _addCallbackData(t) {
              "object" == typeof t &&
                null !== t &&
                (this.animationProps = Object.assign(
                  {},
                  this.animationProps,
                  t
                ));
            }
            _createWebGLContext(t) {
              if (
                ((this.offScreen =
                  t.canvas &&
                  "undefined" != typeof OffscreenCanvas &&
                  t.canvas instanceof OffscreenCanvas),
                (t = Object.assign({}, t, this.props.glOptions)),
                (this.gl = this.props.gl
                  ? _t(this.props.gl, t)
                  : this.onCreateContext(t)),
                !A(this.gl))
              )
                throw new Error(
                  "AnimationLoop.onCreateContext - illegal context returned"
                );
              at(this.gl, G), this._createInfoDiv();
            }
            _createInfoDiv() {
              if (this.gl.canvas && this.props.onAddHTML) {
                const t = document.createElement("div");
                document.body.appendChild(t), (t.style.position = "relative");
                const e = document.createElement("div");
                (e.style.position = "absolute"),
                  (e.style.left = "10px"),
                  (e.style.bottom = "10px"),
                  (e.style.width = "300px"),
                  (e.style.background = "white"),
                  t.appendChild(this.gl.canvas),
                  t.appendChild(e);
                const n = this.props.onAddHTML(e);
                n && (e.innerHTML = n);
              }
            }
            _getSizeAndAspect() {
              const t = this.gl.drawingBufferWidth,
                e = this.gl.drawingBufferHeight;
              let n = 1;
              const { canvas: i } = this.gl;
              return (
                i && i.clientHeight
                  ? (n = i.clientWidth / i.clientHeight)
                  : t > 0 && e > 0 && (n = t / e),
                { width: t, height: e, aspect: n }
              );
            }
            _resizeViewport() {
              this.autoResizeViewport &&
                this.gl.viewport(
                  0,
                  0,
                  this.gl.drawingBufferWidth,
                  this.gl.drawingBufferHeight
                );
            }
            _resizeCanvasDrawingBuffer() {
              this.autoResizeDrawingBuffer &&
                (function (t, e = {}) {
                  if (t.canvas)
                    return void (function (t, e, n) {
                      let i = "width" in n ? n.width : t.canvas.clientWidth,
                        r = "height" in n ? n.height : t.canvas.clientHeight;
                      (i && r) ||
                        (P.log(1, "Canvas clientWidth/clientHeight is 0")(),
                        (e = 1),
                        (i = t.canvas.width || 1),
                        (r = t.canvas.height || 1)),
                        (t.luma = t.luma || {}),
                        (t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {});
                      const s = t.luma.canvasSizeInfo;
                      if (
                        s.clientWidth !== i ||
                        s.clientHeight !== r ||
                        s.devicePixelRatio !== e
                      ) {
                        let n = e;
                        const s = Math.floor(i * n),
                          o = Math.floor(r * n);
                        (t.canvas.width = s),
                          (t.canvas.height = o),
                          (t.drawingBufferWidth === s &&
                            t.drawingBufferHeight === o) ||
                            (P.warn("Device pixel ratio clamped")(),
                            (n = Math.min(
                              t.drawingBufferWidth / i,
                              t.drawingBufferHeight / r
                            )),
                            (t.canvas.width = Math.floor(i * n)),
                            (t.canvas.height = Math.floor(r * n))),
                          Object.assign(t.luma.canvasSizeInfo, {
                            clientWidth: i,
                            clientHeight: r,
                            devicePixelRatio: e,
                          });
                      }
                    })(
                      t,
                      (function (t) {
                        const e =
                          "undefined" == typeof window
                            ? 1
                            : window.devicePixelRatio || 1;
                        return Number.isFinite(t)
                          ? t <= 0
                            ? 1
                            : t
                          : t
                          ? e
                          : 1;
                      })(e.useDevicePixels),
                      e
                    );
                  const n = t.getExtension("STACKGL_resize_drawingbuffer");
                  n &&
                    "width" in e &&
                    "height" in e &&
                    n.resize(e.width, e.height);
                })(this.gl, { useDevicePixels: this.useDevicePixels });
            }
            _createFramebuffer() {
              this.props.createFramebuffer &&
                (this.framebuffer = new Wr(this.gl));
            }
            _resizeFramebuffer() {
              this.framebuffer &&
                this.framebuffer.resize({
                  width: this.gl.drawingBufferWidth,
                  height: this.gl.drawingBufferHeight,
                });
            }
            _beginTimers() {
              this.frameRate.timeEnd(),
                this.frameRate.timeStart(),
                this._gpuTimeQuery &&
                  this._gpuTimeQuery.isResultAvailable() &&
                  !this._gpuTimeQuery.isTimerDisjoint() &&
                  this.stats
                    .get("GPU Time")
                    .addTime(this._gpuTimeQuery.getTimerMilliseconds()),
                this._gpuTimeQuery &&
                  this._gpuTimeQuery.beginTimeElapsedQuery(),
                this.cpuTime.timeStart();
            }
            _endTimers() {
              this.cpuTime.timeEnd(),
                this._gpuTimeQuery && this._gpuTimeQuery.end();
            }
            _startEventHandling() {
              const { canvas: t } = this.gl;
              t &&
                (t.addEventListener("mousemove", this._onMousemove),
                t.addEventListener("mouseleave", this._onMouseleave));
            }
            _onMousemove(t) {
              this.animationProps._mousePosition = [t.offsetX, t.offsetY];
            }
            _onMouseleave(t) {
              this.animationProps._mousePosition = null;
            }
          }
          var Ba = n(377),
            Da = n.n(Ba);
          const Na = { mousedown: 1, mousemove: 2, mouseup: 4 };
          !(function (t) {
            const e = t.prototype.handler;
            t.prototype.handler = function (t) {
              const n = this.store;
              t.button > 0 &&
                "pointerdown" === t.type &&
                ((function (e, n) {
                  for (let n = 0; n < e.length; n++)
                    if (e[n].pointerId === t.pointerId) return !0;
                  return !1;
                })(n) ||
                  n.push(t)),
                e.call(this, t);
            };
          })(Da().PointerEventInput),
            (Da().MouseInput.prototype.handler = function (t) {
              let e = Na[t.type];
              1 & e && t.button >= 0 && (this.pressed = !0),
                2 & e && 0 === t.which && (e = 4),
                this.pressed &&
                  (4 & e && (this.pressed = !1),
                  this.callback(this.manager, e, {
                    pointers: [t],
                    changedPointers: [t],
                    pointerType: "mouse",
                    srcEvent: t,
                  }));
            });
          const za = Da().Manager,
            Va = Da(),
            Ua = Va
              ? [
                  [
                    Va.Pan,
                    { event: "tripan", pointers: 3, threshold: 0, enable: !1 },
                  ],
                  [Va.Rotate, { enable: !1 }],
                  [Va.Pinch, { enable: !1 }],
                  [Va.Swipe, { enable: !1 }],
                  [Va.Pan, { threshold: 0, enable: !1 }],
                  [Va.Press, { enable: !1 }],
                  [Va.Tap, { event: "doubletap", taps: 2, enable: !1 }],
                  [Va.Tap, { event: "anytap", enable: !1 }],
                  [Va.Tap, { enable: !1 }],
                ]
              : null,
            Ga = {
              tripan: ["rotate", "pinch", "pan"],
              rotate: ["pinch"],
              pinch: ["pan"],
              pan: ["press", "doubletap", "anytap", "tap"],
              doubletap: ["anytap"],
              anytap: ["tap"],
            },
            $a = { doubletap: ["tap"] },
            Wa = {
              pointerdown: "pointerdown",
              pointermove: "pointermove",
              pointerup: "pointerup",
              touchstart: "pointerdown",
              touchmove: "pointermove",
              touchend: "pointerup",
              mousedown: "pointerdown",
              mousemove: "pointermove",
              mouseup: "pointerup",
            },
            Ha = {
              KEY_EVENTS: ["keydown", "keyup"],
              MOUSE_EVENTS: [
                "mousedown",
                "mousemove",
                "mouseup",
                "mouseover",
                "mouseout",
                "mouseleave",
              ],
              WHEEL_EVENTS: ["wheel", "mousewheel"],
            },
            Xa = {
              tap: "tap",
              anytap: "anytap",
              doubletap: "doubletap",
              press: "press",
              pinch: "pinch",
              pinchin: "pinch",
              pinchout: "pinch",
              pinchstart: "pinch",
              pinchmove: "pinch",
              pinchend: "pinch",
              pinchcancel: "pinch",
              rotate: "rotate",
              rotatestart: "rotate",
              rotatemove: "rotate",
              rotateend: "rotate",
              rotatecancel: "rotate",
              tripan: "tripan",
              tripanstart: "tripan",
              tripanmove: "tripan",
              tripanup: "tripan",
              tripandown: "tripan",
              tripanleft: "tripan",
              tripanright: "tripan",
              tripanend: "tripan",
              tripancancel: "tripan",
              pan: "pan",
              panstart: "pan",
              panmove: "pan",
              panup: "pan",
              pandown: "pan",
              panleft: "pan",
              panright: "pan",
              panend: "pan",
              pancancel: "pan",
              swipe: "swipe",
              swipeleft: "swipe",
              swiperight: "swipe",
              swipeup: "swipe",
              swipedown: "swipe",
            },
            qa = {
              click: "tap",
              anyclick: "anytap",
              dblclick: "doubletap",
              mousedown: "pointerdown",
              mousemove: "pointermove",
              mouseup: "pointerup",
              mouseover: "pointerover",
              mouseout: "pointerout",
              mouseleave: "pointerleave",
            },
            Ya =
              "undefined" != typeof navigator && navigator.userAgent
                ? navigator.userAgent.toLowerCase()
                : "",
            Za = "undefined" != typeof window ? window : n.g;
          void 0 !== n.g ? n.g : window,
            "undefined" != typeof document && document;
          let Ka = !1;
          try {
            const t = {
              get passive() {
                return (Ka = !0), !0;
              },
            };
            Za.addEventListener("test", t, t),
              Za.removeEventListener("test", t, t);
          } catch (t) {}
          const Qa = -1 !== Ya.indexOf("firefox"),
            { WHEEL_EVENTS: Ja } = Ha,
            tc = "wheel",
            ec = 4.000244140625;
          class nc {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.events = Ja.concat(n.events || [])),
                (this.handleEvent = this.handleEvent.bind(this)),
                this.events.forEach((e) =>
                  t.addEventListener(
                    e,
                    this.handleEvent,
                    !!Ka && { passive: !1 }
                  )
                );
            }
            destroy() {
              this.events.forEach((t) =>
                this.element.removeEventListener(t, this.handleEvent)
              );
            }
            enableEventType(t, e) {
              t === tc && (this.options.enable = e);
            }
            handleEvent(t) {
              if (!this.options.enable) return;
              let e = t.deltaY;
              Za.WheelEvent &&
                (Qa &&
                  t.deltaMode === Za.WheelEvent.DOM_DELTA_PIXEL &&
                  (e /= Za.devicePixelRatio),
                t.deltaMode === Za.WheelEvent.DOM_DELTA_LINE && (e *= 40));
              const n = { x: t.clientX, y: t.clientY };
              0 !== e && e % ec == 0 && (e = Math.floor(e / ec)),
                t.shiftKey && e && (e *= 0.25),
                this._onWheel(t, -e, n);
            }
            _onWheel(t, e, n) {
              this.callback({
                type: tc,
                center: n,
                delta: e,
                srcEvent: t,
                pointerType: "mouse",
                target: t.target,
              });
            }
          }
          const { MOUSE_EVENTS: ic } = Ha,
            rc = "pointermove",
            sc = "pointerover",
            oc = "pointerout",
            ac = "pointerleave";
          class cc {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.pressed = !1),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.enableMoveEvent = this.options.enable),
                (this.enableLeaveEvent = this.options.enable),
                (this.enableOutEvent = this.options.enable),
                (this.enableOverEvent = this.options.enable),
                (this.events = ic.concat(n.events || [])),
                (this.handleEvent = this.handleEvent.bind(this)),
                this.events.forEach((e) =>
                  t.addEventListener(e, this.handleEvent)
                );
            }
            destroy() {
              this.events.forEach((t) =>
                this.element.removeEventListener(t, this.handleEvent)
              );
            }
            enableEventType(t, e) {
              t === rc && (this.enableMoveEvent = e),
                t === sc && (this.enableOverEvent = e),
                t === oc && (this.enableOutEvent = e),
                t === ac && (this.enableLeaveEvent = e);
            }
            handleEvent(t) {
              this.handleOverEvent(t),
                this.handleOutEvent(t),
                this.handleLeaveEvent(t),
                this.handleMoveEvent(t);
            }
            handleOverEvent(t) {
              this.enableOverEvent &&
                "mouseover" === t.type &&
                this.callback({
                  type: sc,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
            handleOutEvent(t) {
              this.enableOutEvent &&
                "mouseout" === t.type &&
                this.callback({
                  type: oc,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
            handleLeaveEvent(t) {
              this.enableLeaveEvent &&
                "mouseleave" === t.type &&
                this.callback({
                  type: ac,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
            handleMoveEvent(t) {
              if (this.enableMoveEvent)
                switch (t.type) {
                  case "mousedown":
                    t.button >= 0 && (this.pressed = !0);
                    break;
                  case "mousemove":
                    0 === t.which && (this.pressed = !1),
                      this.pressed ||
                        this.callback({
                          type: rc,
                          srcEvent: t,
                          pointerType: "mouse",
                          target: t.target,
                        });
                    break;
                  case "mouseup":
                    this.pressed = !1;
                }
            }
          }
          const { KEY_EVENTS: hc } = Ha,
            lc = "keydown",
            uc = "keyup";
          class dc {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.enableDownEvent = this.options.enable),
                (this.enableUpEvent = this.options.enable),
                (this.events = hc.concat(n.events || [])),
                (this.handleEvent = this.handleEvent.bind(this)),
                (t.tabIndex = n.tabIndex || 0),
                (t.style.outline = "none"),
                this.events.forEach((e) =>
                  t.addEventListener(e, this.handleEvent)
                );
            }
            destroy() {
              this.events.forEach((t) =>
                this.element.removeEventListener(t, this.handleEvent)
              );
            }
            enableEventType(t, e) {
              t === lc && (this.enableDownEvent = e),
                t === uc && (this.enableUpEvent = e);
            }
            handleEvent(t) {
              const e = t.target || t.srcElement;
              ("INPUT" === e.tagName && "text" === e.type) ||
                "TEXTAREA" === e.tagName ||
                (this.enableDownEvent &&
                  "keydown" === t.type &&
                  this.callback({
                    type: lc,
                    srcEvent: t,
                    key: t.key,
                    target: t.target,
                  }),
                this.enableUpEvent &&
                  "keyup" === t.type &&
                  this.callback({
                    type: uc,
                    srcEvent: t,
                    key: t.key,
                    target: t.target,
                  }));
            }
          }
          const fc = "contextmenu";
          class pc {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.handleEvent = this.handleEvent.bind(this)),
                t.addEventListener("contextmenu", this.handleEvent);
            }
            destroy() {
              this.element.removeEventListener("contextmenu", this.handleEvent);
            }
            enableEventType(t, e) {
              t === fc && (this.options.enable = e);
            }
            handleEvent(t) {
              this.options.enable &&
                this.callback({
                  type: fc,
                  center: { x: t.clientX, y: t.clientY },
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
          }
          const gc = {
              pointerdown: 1,
              pointermove: 2,
              pointerup: 4,
              mousedown: 1,
              mousemove: 2,
              mouseup: 4,
            },
            mc = { srcElement: "root", priority: 0 };
          class bc {
            constructor(t) {
              (this.eventManager = t),
                (this.handlers = []),
                (this.handlersByElement = new Map()),
                (this.handleEvent = this.handleEvent.bind(this)),
                (this._active = !1);
            }
            isEmpty() {
              return !this._active;
            }
            add(t, e, n, i = !1, r = !1) {
              const { handlers: s, handlersByElement: o } = this;
              n &&
                ("object" != typeof n || n.addEventListener) &&
                (n = { srcElement: n }),
                (n = n ? Object.assign({}, mc, n) : mc);
              let a = o.get(n.srcElement);
              a || ((a = []), o.set(n.srcElement, a));
              const c = {
                type: t,
                handler: e,
                srcElement: n.srcElement,
                priority: n.priority,
              };
              i && (c.once = !0),
                r && (c.passive = !0),
                s.push(c),
                (this._active = this._active || !c.passive);
              let h = a.length - 1;
              for (; h >= 0 && !(a[h].priority >= c.priority); ) h--;
              a.splice(h + 1, 0, c);
            }
            remove(t, e) {
              const { handlers: n, handlersByElement: i } = this;
              for (let r = n.length - 1; r >= 0; r--) {
                const s = n[r];
                if (s.type === t && s.handler === e) {
                  n.splice(r, 1);
                  const t = i.get(s.srcElement);
                  t.splice(t.indexOf(s), 1),
                    0 === t.length && i.delete(s.srcElement);
                }
              }
              this._active = n.some((t) => !t.passive);
            }
            handleEvent(t) {
              if (this.isEmpty()) return;
              const e = this._normalizeEvent(t);
              let n = t.srcEvent.target;
              for (; n && n !== e.rootElement; ) {
                if ((this._emit(e, n), e.handled)) return;
                n = n.parentNode;
              }
              this._emit(e, "root");
            }
            _emit(t, e) {
              const n = this.handlersByElement.get(e);
              if (n) {
                let e = !1;
                const i = () => {
                    t.handled = !0;
                  },
                  r = () => {
                    (t.handled = !0), (e = !0);
                  },
                  s = [];
                for (let o = 0; o < n.length; o++) {
                  const { type: a, handler: c, once: h } = n[o];
                  if (
                    (c(
                      Object.assign({}, t, {
                        type: a,
                        stopPropagation: i,
                        stopImmediatePropagation: r,
                      })
                    ),
                    h && s.push(n[o]),
                    e)
                  )
                    break;
                }
                for (let t = 0; t < s.length; t++) {
                  const { type: e, handler: n } = s[t];
                  this.remove(e, n);
                }
              }
            }
            _normalizeEvent(t) {
              const e = this.eventManager.element;
              return Object.assign(
                {},
                t,
                (function (t) {
                  const e = gc[t.srcEvent.type];
                  if (!e) return null;
                  const { buttons: n, button: i, which: r } = t.srcEvent;
                  let s = !1,
                    o = !1,
                    a = !1;
                  return (
                    4 === e || (2 === e && !Number.isFinite(n))
                      ? ((s = 1 === r), (o = 2 === r), (a = 3 === r))
                      : 2 === e
                      ? ((s = Boolean(1 & n)),
                        (o = Boolean(4 & n)),
                        (a = Boolean(2 & n)))
                      : 1 === e &&
                        ((s = 0 === i), (o = 1 === i), (a = 2 === i)),
                    { leftButton: s, middleButton: o, rightButton: a }
                  );
                })(t),
                (function (t, e) {
                  const { srcEvent: n } = t;
                  if (!t.center && !Number.isFinite(n.clientX)) return null;
                  const i = t.center || { x: n.clientX, y: n.clientY },
                    r = e.getBoundingClientRect(),
                    s = r.width / e.offsetWidth || 1,
                    o = r.height / e.offsetHeight || 1;
                  return {
                    center: i,
                    offsetCenter: {
                      x: (i.x - r.left - e.clientLeft) / s,
                      y: (i.y - r.top - e.clientTop) / o,
                    },
                  };
                })(t, e),
                { handled: !1, rootElement: e }
              );
            }
          }
          const _c = {
            events: null,
            recognizers: null,
            recognizerOptions: {},
            Manager: za,
            touchAction: "none",
            tabIndex: 0,
          };
          class yc {
            constructor(t = null, e = {}) {
              (this.options = Object.assign({}, _c, e)),
                (this.events = new Map()),
                (this._onBasicInput = this._onBasicInput.bind(this)),
                (this._onOtherEvent = this._onOtherEvent.bind(this)),
                this.setElement(t);
              const { events: n } = e;
              n && this.on(n);
            }
            setElement(t) {
              if ((this.element && this.destroy(), (this.element = t), !t))
                return;
              const { options: e } = this,
                n = e.Manager;
              (this.manager = new n(t, {
                touchAction: e.touchAction,
                recognizers: e.recognizers || Ua,
              }).on("hammer.input", this._onBasicInput)),
                e.recognizers ||
                  Object.keys(Ga).forEach((t) => {
                    const e = this.manager.get(t);
                    e &&
                      Ga[t].forEach((t) => {
                        e.recognizeWith(t);
                      });
                  });
              for (const t in e.recognizerOptions) {
                const n = this.manager.get(t);
                if (n) {
                  const i = e.recognizerOptions[t];
                  delete i.enable, n.set(i);
                }
              }
              (this.wheelInput = new nc(t, this._onOtherEvent, { enable: !1 })),
                (this.moveInput = new cc(t, this._onOtherEvent, {
                  enable: !1,
                })),
                (this.keyInput = new dc(t, this._onOtherEvent, {
                  enable: !1,
                  tabIndex: e.tabIndex,
                })),
                (this.contextmenuInput = new pc(t, this._onOtherEvent, {
                  enable: !1,
                }));
              for (const [t, e] of this.events)
                e.isEmpty() ||
                  (this._toggleRecognizer(e.recognizerName, !0),
                  this.manager.on(t, e.handleEvent));
            }
            destroy() {
              this.element &&
                (this.wheelInput.destroy(),
                this.moveInput.destroy(),
                this.keyInput.destroy(),
                this.contextmenuInput.destroy(),
                this.manager.destroy(),
                (this.wheelInput = null),
                (this.moveInput = null),
                (this.keyInput = null),
                (this.contextmenuInput = null),
                (this.manager = null),
                (this.element = null));
            }
            on(t, e, n) {
              this._addEventHandler(t, e, n, !1);
            }
            once(t, e, n) {
              this._addEventHandler(t, e, n, !0);
            }
            watch(t, e, n) {
              this._addEventHandler(t, e, n, !1, !0);
            }
            off(t, e) {
              this._removeEventHandler(t, e);
            }
            _toggleRecognizer(t, e) {
              const { manager: n } = this;
              if (!n) return;
              const i = n.get(t);
              if (i && i.options.enable !== e) {
                i.set({ enable: e });
                const r = $a[t];
                r &&
                  !this.options.recognizers &&
                  r.forEach((r) => {
                    const s = n.get(r);
                    e
                      ? (s.requireFailure(t), i.dropRequireFailure(r))
                      : s.dropRequireFailure(t);
                  });
              }
              this.wheelInput.enableEventType(t, e),
                this.moveInput.enableEventType(t, e),
                this.keyInput.enableEventType(t, e),
                this.contextmenuInput.enableEventType(t, e);
            }
            _addEventHandler(t, e, n, i, r) {
              if ("string" != typeof t) {
                n = e;
                for (const e in t) this._addEventHandler(e, t[e], n, i, r);
                return;
              }
              const { manager: s, events: o } = this,
                a = qa[t] || t;
              let c = o.get(a);
              c ||
                ((c = new bc(this)),
                o.set(a, c),
                (c.recognizerName = Xa[a] || a),
                s && s.on(a, c.handleEvent)),
                c.add(t, e, n, i, r),
                c.isEmpty() || this._toggleRecognizer(c.recognizerName, !0);
            }
            _removeEventHandler(t, e) {
              if ("string" != typeof t) {
                for (const e in t) this._removeEventHandler(e, t[e]);
                return;
              }
              const { events: n } = this,
                i = qa[t] || t,
                r = n.get(i);
              if (r && (r.remove(t, e), r.isEmpty())) {
                const { recognizerName: t } = r;
                let e = !1;
                for (const i of n.values())
                  if (i.recognizerName === t && !i.isEmpty()) {
                    e = !0;
                    break;
                  }
                e || this._toggleRecognizer(t, !1);
              }
            }
            _onBasicInput(t) {
              const { srcEvent: e } = t,
                n = Wa[e.type];
              n && this.manager.emit(n, t);
            }
            _onOtherEvent(t) {
              this.manager.emit(t.type, t);
            }
          }
          function vc() {}
          const wc = {
            id: "",
            width: "100%",
            height: "100%",
            pickingRadius: 0,
            layerFilter: null,
            glOptions: {},
            gl: null,
            layers: [],
            effects: [],
            views: null,
            controller: null,
            useDevicePixels: !0,
            touchAction: "none",
            eventRecognizerOptions: {},
            _framebuffer: null,
            _animate: !1,
            _pickable: !0,
            _typedArrayManagerProps: {},
            onWebGLInitialized: vc,
            onResize: vc,
            onViewStateChange: vc,
            onInteractionStateChange: vc,
            onBeforeRender: vc,
            onAfterRender: vc,
            onLoad: vc,
            onError: (t, e) => Et.error(t)(),
            _onMetrics: null,
            getCursor: ({ isDragging: t }) => (t ? "grabbing" : "grab"),
            debug: !1,
            drawPickingColors: !1,
          };
          class xc {
            constructor(t) {
              (t = { ...wc, ...t }),
                (this.props = {}),
                (this.width = 0),
                (this.height = 0),
                (this.viewManager = null),
                (this.layerManager = null),
                (this.effectManager = null),
                (this.deckRenderer = null),
                (this.deckPicker = null),
                (this._needsRedraw = !0),
                (this._pickRequest = {}),
                (this._lastPointerDownInfo = null),
                (this.viewState = null),
                (this.interactiveState = { isHovering: !1, isDragging: !1 }),
                (this._onEvent = this._onEvent.bind(this)),
                (this._onPointerDown = this._onPointerDown.bind(this)),
                (this._onPointerMove = this._onPointerMove.bind(this)),
                t.viewState &&
                  t.initialViewState &&
                  Et.warn(
                    "View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update."
                  )(),
                "IE" === (0, O.qs)() &&
                  Et.warn("IE 11 support will be deprecated in v8.0")(),
                t.gl ||
                  ("undefined" != typeof document &&
                    (this.canvas = this._createCanvas(t))),
                (this.animationLoop = this._createAnimationLoop(t)),
                (this.stats = new Lt({ id: "deck.gl" })),
                (this.metrics = {
                  fps: 0,
                  setPropsTime: 0,
                  updateAttributesTime: 0,
                  framesRedrawn: 0,
                  pickTime: 0,
                  pickCount: 0,
                  gpuTime: 0,
                  gpuTimePerFrame: 0,
                  cpuTime: 0,
                  cpuTimePerFrame: 0,
                  bufferMemory: 0,
                  textureMemory: 0,
                  renderbufferMemory: 0,
                  gpuMemory: 0,
                }),
                (this._metricsCounter = 0),
                this.setProps(t),
                t._typedArrayManagerProps &&
                  Xe.setProps(t._typedArrayManagerProps),
                this.animationLoop.start();
            }
            finalize() {
              this.animationLoop.stop(),
                (this.animationLoop = null),
                (this._lastPointerDownInfo = null),
                this.layerManager &&
                  (this.layerManager.finalize(),
                  (this.layerManager = null),
                  this.viewManager.finalize(),
                  (this.viewManager = null),
                  this.effectManager.finalize(),
                  (this.effectManager = null),
                  this.deckRenderer.finalize(),
                  (this.deckRenderer = null),
                  this.deckPicker.finalize(),
                  (this.deckPicker = null),
                  this.eventManager.destroy(),
                  (this.eventManager = null),
                  this.tooltip.remove(),
                  (this.tooltip = null)),
                this.props.canvas ||
                  this.props.gl ||
                  !this.canvas ||
                  (this.canvas.parentElement.removeChild(this.canvas),
                  (this.canvas = null));
            }
            setProps(t) {
              this.stats.get("setProps Time").timeStart(),
                "onLayerHover" in t && Et.removed("onLayerHover", "onHover")(),
                "onLayerClick" in t && Et.removed("onLayerClick", "onClick")(),
                t.initialViewState &&
                  !Hs(this.props.initialViewState, t.initialViewState) &&
                  (this.viewState = t.initialViewState),
                Object.assign(this.props, t),
                this._setCanvasSize(this.props);
              const e = Object.create(this.props);
              Object.assign(e, {
                views: this._getViews(),
                width: this.width,
                height: this.height,
                viewState: this._getViewState(),
              }),
                this.animationLoop.setProps(e),
                this.layerManager &&
                  (this.viewManager.setProps(e),
                  this.layerManager.activateViewport(this.getViewports()[0]),
                  this.layerManager.setProps(e),
                  this.effectManager.setProps(e),
                  this.deckRenderer.setProps(e),
                  this.deckPicker.setProps(e)),
                this.stats.get("setProps Time").timeEnd();
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              if (this.props._animate) return "Deck._animate";
              let e = this._needsRedraw;
              t.clearRedrawFlags && (this._needsRedraw = !1);
              const n = this.viewManager.needsRedraw(t),
                i = this.layerManager.needsRedraw(t),
                r = this.effectManager.needsRedraw(t),
                s = this.deckRenderer.needsRedraw(t);
              return (e = e || n || i || r || s), e;
            }
            redraw(t) {
              if (!this.layerManager) return;
              const e = t || this.needsRedraw({ clearRedrawFlags: !0 });
              e &&
                (this.stats.get("Redraw Count").incrementCount(),
                this.props._customRender
                  ? this.props._customRender(e)
                  : this._drawLayers(e));
            }
            getViews() {
              return this.viewManager.views;
            }
            getViewports(t) {
              return this.viewManager.getViewports(t);
            }
            pickObject(t) {
              const e = this._pick("pickObject", "pickObject Time", t).result;
              return e.length ? e[0] : null;
            }
            pickMultipleObjects(t) {
              return (
                (t.depth = t.depth || 10),
                this._pick("pickObject", "pickMultipleObjects Time", t).result
              );
            }
            pickObjects(t) {
              return this._pick("pickObjects", "pickObjects Time", t);
            }
            _addResources(t, e = !1) {
              for (const n in t)
                this.layerManager.resourceManager.add({
                  resourceId: n,
                  data: t[n],
                  forceUpdate: e,
                });
            }
            _removeResources(t) {
              for (const e of t) this.layerManager.resourceManager.remove(e);
            }
            _pick(t, e, n) {
              const { stats: i } = this;
              i.get("Pick Count").incrementCount(), i.get(e).timeStart();
              const r = this.deckPicker[t]({
                layers: this.layerManager.getLayers(n),
                views: this.viewManager.getViews(),
                viewports: this.getViewports(n),
                onViewportActive: this.layerManager.activateViewport,
                ...n,
              });
              return i.get(e).timeEnd(), r;
            }
            _createCanvas(t) {
              let e = t.canvas;
              return (
                "string" == typeof e &&
                  ((e = document.getElementById(e)), Ks(e)),
                e ||
                  ((e = document.createElement("canvas")),
                  (e.id = t.id || "deckgl-overlay"),
                  (t.parent || document.body).appendChild(e)),
                Object.assign(e.style, t.style),
                e
              );
            }
            _setCanvasSize(t) {
              if (!this.canvas) return;
              let { width: e, height: n } = t;
              (e || 0 === e) &&
                ((e = Number.isFinite(e) ? "".concat(e, "px") : e),
                (this.canvas.style.width = e)),
                (n || 0 === n) &&
                  ((n = Number.isFinite(n) ? "".concat(n, "px") : n),
                  (this.canvas.style.position = "absolute"),
                  (this.canvas.style.height = n));
            }
            _updateCanvasSize() {
              if (this._checkForCanvasSizeChange()) {
                const { width: t, height: e } = this;
                this.viewManager.setProps({ width: t, height: e }),
                  this.props.onResize({
                    width: this.width,
                    height: this.height,
                  });
              }
            }
            _checkForCanvasSizeChange() {
              const { canvas: t } = this;
              if (!t) return !1;
              const e = t.clientWidth || t.width,
                n = t.clientHeight || t.height;
              return (
                (e !== this.width || n !== this.height) &&
                ((this.width = e), (this.height = n), !0)
              );
            }
            _createAnimationLoop(t) {
              const {
                width: e,
                height: n,
                gl: i,
                glOptions: r,
                debug: s,
                onError: o,
                onBeforeRender: a,
                onAfterRender: c,
                useDevicePixels: h,
                autoResizeDrawingBuffer: l,
              } = t;
              return new Fa({
                width: e,
                height: n,
                useDevicePixels: h,
                autoResizeDrawingBuffer: l,
                autoResizeViewport: !1,
                gl: i,
                onCreateContext: (t) =>
                  bt({
                    ...r,
                    ...t,
                    canvas: this.canvas,
                    debug: s,
                    onContextLost: () => this._onContextLost(),
                  }),
                onInitialize: (t) => this._setGLContext(t.gl),
                onRender: this._onRenderFrame.bind(this),
                onBeforeRender: a,
                onAfterRender: c,
                onError: o,
              });
            }
            _getViewState() {
              return this.props.viewState || this.viewState;
            }
            _getViews() {
              let t = this.props.views || [new xo({ id: "default-view" })];
              return (
                (t = Array.isArray(t) ? t : [t]),
                t.length &&
                  this.props.controller &&
                  (t[0].props.controller = this.props.controller),
                t
              );
            }
            _onContextLost() {
              const { onError: t } = this.props;
              this.animationLoop && t && t(new Error("WebGL context is lost"));
            }
            _onPointerMove(t) {
              const { _pickRequest: e } = this;
              if ("pointerleave" === t.type)
                (e.x = -1), (e.y = -1), (e.radius = 0);
              else {
                if (t.leftButton || t.rightButton) return;
                {
                  const n = t.offsetCenter;
                  if (!n) return;
                  (e.x = n.x),
                    (e.y = n.y),
                    (e.radius = this.props.pickingRadius);
                }
              }
              this.layerManager &&
                (this.layerManager.context.mousePosition = { x: e.x, y: e.y }),
                (e.event = t),
                (e.mode = "hover");
            }
            _pickAndCallback() {
              const { _pickRequest: t } = this;
              if (t.event) {
                const { result: e, emptyInfo: n } = this._pick(
                  "pickObject",
                  "pickObject Time",
                  t
                );
                this.interactiveState.isHovering = e.length > 0;
                let i = n,
                  r = !1;
                for (const n of e) (i = n), (r = n.layer.onHover(n, t.event));
                if (
                  (!r && this.props.onHover && this.props.onHover(i, t.event),
                  this.props.getTooltip)
                ) {
                  const t = this.props.getTooltip(i);
                  this.tooltip.setTooltip(t, i.x, i.y);
                }
                t.event = null;
              }
            }
            _updateCursor() {
              const t = this.props.parent || this.canvas;
              t &&
                (t.style.cursor = this.props.getCursor(this.interactiveState));
            }
            _setGLContext(t) {
              if (this.layerManager) return;
              this.canvas ||
                ((this.canvas = t.canvas),
                _t(t, { enable: !0, copyState: !0 })),
                (this.tooltip = new sa(this.canvas)),
                at(t, {
                  blend: !0,
                  blendFunc: [770, 771, 1, 771],
                  polygonOffsetFill: !0,
                  depthTest: !0,
                  depthFunc: 515,
                }),
                this.props.onWebGLInitialized(t);
              const e = new wt();
              e.play(),
                this.animationLoop.attachTimeline(e),
                (this.eventManager = new yc(this.props.parent || t.canvas, {
                  touchAction: this.props.touchAction,
                  recognizerOptions: this.props.eventRecognizerOptions,
                  events: {
                    pointerdown: this._onPointerDown,
                    pointermove: this._onPointerMove,
                    pointerleave: this._onPointerMove,
                  },
                }));
              for (const t in ui) this.eventManager.on(t, this._onEvent);
              this.viewManager = new Xs({
                timeline: e,
                eventManager: this.eventManager,
                onViewStateChange: this._onViewStateChange.bind(this),
                onInteractionStateChange:
                  this._onInteractionStateChange.bind(this),
                views: this._getViews(),
                viewState: this._getViewState(),
                width: this.width,
                height: this.height,
              });
              const n = this.viewManager.getViewports()[0];
              (this.layerManager = new Ws(t, {
                deck: this,
                stats: this.stats,
                viewport: n,
                timeline: e,
              })),
                (this.effectManager = new Ho()),
                (this.deckRenderer = new Ko(t)),
                (this.deckPicker = new ia(t)),
                this.setProps(this.props),
                this._updateCanvasSize(),
                this.props.onLoad();
            }
            _drawLayers(t, e) {
              const { gl: n } = this.layerManager.context;
              at(n, this.props.parameters),
                this.props.onBeforeRender({ gl: n }),
                this.deckRenderer.renderLayers({
                  target: this.props._framebuffer,
                  layers: this.layerManager.getLayers(),
                  viewports: this.viewManager.getViewports(),
                  onViewportActive: this.layerManager.activateViewport,
                  views: this.viewManager.getViews(),
                  pass: "screen",
                  redrawReason: t,
                  effects: this.effectManager.getEffects(),
                  ...e,
                }),
                this.props.onAfterRender({ gl: n });
            }
            _onRenderFrame(t) {
              this._getFrameStats(),
                this._metricsCounter++ % 60 == 0 &&
                  (this._getMetrics(),
                  this.stats.reset(),
                  Et.table(4, this.metrics)(),
                  this.props._onMetrics && this.props._onMetrics(this.metrics)),
                this._updateCanvasSize(),
                this._updateCursor(),
                this.tooltip.isVisible &&
                  this.viewManager.needsRedraw() &&
                  this.tooltip.setTooltip(null),
                this.layerManager.updateLayers(),
                this._pickAndCallback(),
                this.redraw(!1),
                this.viewManager && this.viewManager.updateViewStates();
            }
            _onViewStateChange(t) {
              const e = this.props.onViewStateChange(t) || t.viewState;
              this.viewState &&
                ((this.viewState = { ...this.viewState, [t.viewId]: e }),
                this.props.viewState ||
                  (this.viewManager &&
                    this.viewManager.setProps({ viewState: this.viewState })));
            }
            _onInteractionStateChange(t) {
              (this.interactiveState.isDragging = t.isDragging),
                this.props.onInteractionStateChange(t);
            }
            _onEvent(t) {
              const e = ui[t.type],
                n = t.offsetCenter;
              if (!e || !n) return;
              const i = this.layerManager.getLayers(),
                r = this.deckPicker.getLastPickedObject(
                  {
                    x: n.x,
                    y: n.y,
                    layers: i,
                    viewports: this.getViewports(n),
                  },
                  this._lastPointerDownInfo
                ),
                { layer: s } = r,
                o = s && (s[e.handler] || s.props[e.handler]),
                a = this.props[e.handler];
              let c = !1;
              o && (c = o.call(s, r, t)), !c && a && a(r, t);
            }
            _onPointerDown(t) {
              const e = t.offsetCenter;
              this._lastPointerDownInfo = this.pickObject({
                x: e.x,
                y: e.y,
                radius: this.props.pickingRadius,
              });
            }
            _getFrameStats() {
              const { stats: t } = this;
              t.get("frameRate").timeEnd(), t.get("frameRate").timeStart();
              const e = this.animationLoop.stats;
              t.get("GPU Time").addTime(e.get("GPU Time").lastTiming),
                t.get("CPU Time").addTime(e.get("CPU Time").lastTiming);
            }
            _getMetrics() {
              const { metrics: t, stats: e } = this;
              (t.fps = e.get("frameRate").getHz()),
                (t.setPropsTime = e.get("setProps Time").time),
                (t.updateAttributesTime = e.get("Update Attributes").time),
                (t.framesRedrawn = e.get("Redraw Count").count),
                (t.pickTime =
                  e.get("pickObject Time").time +
                  e.get("pickMultipleObjects Time").time +
                  e.get("pickObjects Time").time),
                (t.pickCount = e.get("Pick Count").count),
                (t.gpuTime = e.get("GPU Time").time),
                (t.cpuTime = e.get("CPU Time").time),
                (t.gpuTimePerFrame = e.get("GPU Time").getAverageTime()),
                (t.cpuTimePerFrame = e.get("CPU Time").getAverageTime());
              const n = Ji.get("Memory Usage");
              (t.bufferMemory = n.get("Buffer Memory").count),
                (t.textureMemory = n.get("Texture Memory").count),
                (t.renderbufferMemory = n.get("Renderbuffer Memory").count),
                (t.gpuMemory = n.get("GPU Memory").count);
            }
          }
          (xc.getPropTypes = function (t) {
            return {
              id: t.string,
              width: t.oneOfType([t.number, t.string]),
              height: t.oneOfType([t.number, t.string]),
              layers: t.oneOfType([t.object, t.array]),
              layerFilter: t.func,
              views: t.oneOfType([t.object, t.array]),
              viewState: t.object,
              effects: t.arrayOf(t.instanceOf(Io)),
              controller: t.oneOfType([t.func, t.bool, t.object]),
              gl: t.object,
              glOptions: t.object,
              parameters: t.object,
              pickingRadius: t.number,
              useDevicePixels: t.oneOfType([t.bool, t.number]),
              touchAction: t.string,
              eventRecognizerOptions: t.object,
              onWebGLInitialized: t.func,
              onResize: t.func,
              onViewStateChange: t.func,
              onInteractionStateChange: t.func,
              onBeforeRender: t.func,
              onAfterRender: t.func,
              onLoad: t.func,
              onError: t.func,
              debug: t.bool,
              drawPickingColors: t.bool,
              _framebuffer: t.object,
              _animate: t.bool,
              _pickable: t.bool,
              _typedArrayManagerProps: t.object,
            };
          }),
            (xc.defaultProps = wc),
            (xc.VERSION = Ia.VERSION);
          const Ec = 85.05113;
          function Pc(t, e, n, i) {
            if (n) {
              if (n.props.userData._googleMap === t) return n;
              Ac(n);
            }
            const r = {
              click: null,
              dblclick: null,
              mousemove: null,
              mouseout: null,
            };
            n = new xc({
              ...i,
              style: null,
              parent: Tc(e, i.style),
              initialViewState: { longitude: 0, latitude: 0, zoom: 1 },
              controller: !1,
              userData: { _googleMap: t, _eventListeners: r },
            });
            for (const e in r) r[e] = t.addListener(e, (t) => Oc(n, e, t));
            return n;
          }
          function Tc(t, e) {
            const n = document.createElement("div");
            return (
              (n.style.position = "absolute"),
              Object.assign(n.style, e),
              t.getPanes
                ? t.getPanes().overlayLayer.appendChild(n)
                : t.getMap().getDiv().appendChild(n),
              n
            );
          }
          function Ac(t) {
            const { _eventListeners: e } = t.props.userData;
            for (const t in e) e[t].remove();
            t.finalize();
          }
          function Sc(t, e) {
            const { width: n, height: i } = Mc(t),
              {
                lat: r,
                lng: s,
                heading: o,
                tilt: a,
                zoom: c,
              } = e.getCameraParams(),
              h = n / i,
              l = new Bn().perspective({
                fovy: (25 * Math.PI) / 180,
                aspect: h,
                near: 0.75,
                far: 3e14,
              });
            return {
              width: !1,
              height: !1,
              viewState: {
                altitude: 0.5 * l[5],
                bearing: o,
                latitude: r,
                longitude: s,
                pitch: a,
                projectionMatrix: l,
                repeat: !0,
                zoom: c - 1,
              },
            };
          }
          function Mc(t) {
            const e = t.getDiv().firstChild;
            return { width: e.offsetWidth, height: e.offsetHeight };
          }
          function Cc(t, e) {
            if (t.pixel) return t.pixel;
            const n = e
              .getViewports()[0]
              .project([t.latLng.lng(), t.latLng.lat()]);
            return { x: n[0], y: n[1] };
          }
          function Oc(t, e, n) {
            const i = { type: e, offsetCenter: Cc(n, t), srcEvent: n };
            switch (e) {
              case "click":
                (t._lastPointerDownInfo = t.pickObject({
                  ...i.offsetCenter,
                  radius: t.props.pickingRadius,
                })),
                  (i.tapCount = 1),
                  t._onEvent(i);
                break;
              case "dblclick":
                (i.type = "click"), (i.tapCount = 2), t._onEvent(i);
                break;
              case "mousemove":
                (i.type = "pointermove"), t._onPointerMove(i);
                break;
              case "mouseout":
                (i.type = "pointerleave"), t._onPointerMove(i);
                break;
              default:
                return;
            }
          }
          const Lc = () => !1,
            Ic = {
              depthMask: !0,
              depthTest: !0,
              blend: !0,
              blendFunc: [770, 771, 1, 771],
              blendEquation: 32774,
            };
          class Rc {
            constructor(t) {
              (this.props = {}), (this._map = null), this.setProps(t);
            }
            setMap(t) {
              if (
                t !== this._map &&
                (this._map && (this._overlay.setMap(null), (this._map = null)),
                t)
              ) {
                this._map = t;
                const { UNINITIALIZED: e } = google.maps.RenderingType;
                t.getRenderingType() !== e
                  ? this._createOverlay(t)
                  : t.addListener("renderingtype_changed", () => {
                      this._createOverlay(t);
                    });
              }
            }
            setProps(t) {
              Object.assign(this.props, t),
                this._deck &&
                  (t.style &&
                    (Object.assign(
                      this._deck.canvas.parentElement.style,
                      t.style
                    ),
                    (t.style = null)),
                  this._deck.setProps(t));
            }
            pickObject(t) {
              return this._deck && this._deck.pickObject(t);
            }
            pickMultipleObjects(t) {
              return this._deck && this._deck.pickMultipleObjects(t);
            }
            pickObjects(t) {
              return this._deck && this._deck.pickObjects(t);
            }
            finalize() {
              this.setMap(null),
                this._deck && (Ac(this._deck), (this._deck = null));
            }
            _createOverlay(t) {
              const { VECTOR: e, UNINITIALIZED: n } = google.maps.RenderingType,
                i = t.getRenderingType();
              if (i === n) return;
              const r = i === e && google.maps.WebglOverlayView,
                s = new (
                  r ? google.maps.WebglOverlayView : google.maps.OverlayView
                )();
              r
                ? ((s.onAdd = () => {}),
                  (s.onContextLost = this._onContextLost.bind(this)),
                  (s.onContextRestored = this._onContextRestored.bind(this)),
                  (s.onDraw = this._onDrawVector.bind(this)))
                : ((s.onAdd = this._onAdd.bind(this)),
                  (s.draw = this._onDrawRaster.bind(this))),
                (s.onRemove = this._onRemove.bind(this)),
                (this._overlay = s),
                this._overlay.setMap(t);
            }
            _onAdd() {
              this._deck = Pc(this._map, this._overlay, this._deck, this.props);
            }
            _onContextRestored(t) {
              const e = Pc(this._map, this._overlay, this._deck, {
                gl: t,
                _customRender: () => {
                  this._overlay.requestRedraw();
                },
                ...this.props,
              });
              (this._deck = e),
                (e.animationLoop._renderFrame = () => {
                  const n = t.getParameter(34964);
                  ht(t, {}, () => {
                    e.animationLoop.onRender();
                  }),
                    t.bindBuffer(34962, n);
                });
            }
            _onContextLost() {
              this._deck && (Ac(this._deck), (this._deck = null));
            }
            _onRemove() {
              this._deck.setProps({ layerFilter: Lc });
            }
            _onDrawRaster() {
              const t = this._deck,
                {
                  width: e,
                  height: n,
                  left: i,
                  top: r,
                  zoom: s,
                  pitch: o,
                  latitude: a,
                  longitude: c,
                } = (function (t, e) {
                  const { width: n, height: i } = Mc(t),
                    r = e.getProjection(),
                    s = t.getBounds(),
                    o = s.getNorthEast(),
                    a = s.getSouthWest(),
                    c = r.fromLatLngToDivPixel(o),
                    h = r.fromLatLngToDivPixel(a),
                    l = new google.maps.Point(0, 0),
                    u = r.fromContainerPixelToLatLng(l),
                    d = r.fromLatLngToDivPixel(u);
                  let f = d.x,
                    p = d.y;
                  const g = r.getWorldWidth(),
                    m = Math.ceil(n / g);
                  f -= Math.floor(m / 2) * g;
                  const b = i ? (h.y - c.y) / i : 1,
                    _ = Math.log2(b || 1) + t.getZoom() - 1;
                  let y = new google.maps.Point(n / 2, i / 2);
                  const v = r.fromContainerPixelToLatLng(y);
                  let w = v.lat();
                  const x = v.lng();
                  if (Math.abs(w) > Ec) {
                    w = w > 0 ? Ec : -85.05113;
                    const t = new google.maps.LatLng(w, x);
                    (y = r.fromLatLngToContainerPixel(t)), (p += y.y - i / 2);
                  }
                  return {
                    width: n,
                    height: i,
                    left: f,
                    top: p,
                    zoom: _,
                    pitch: t.getTilt(),
                    latitude: w,
                    longitude: x,
                  };
                })(this._map, this._overlay),
                h = 0 === o,
                l = t.canvas.parentElement.style;
              (l.left = "".concat(i, "px")),
                (l.top = "".concat(r, "px")),
                t.setProps({
                  width: e,
                  height: n,
                  viewState: { latitude: a, longitude: c, zoom: s, repeat: !0 },
                  layerFilter: h ? this.props.layerFilter : Lc,
                }),
                t.redraw();
            }
            _onDrawVector(t, e) {
              const n = this._deck;
              if ((n.setProps({ ...Sc(this._map, e) }), n.layerManager)) {
                const e = ct(t, 36006);
                n.setProps({ _framebuffer: e }),
                  n.needsRedraw({ clearRedrawFlags: !0 }),
                  at(t, {
                    viewport: [0, 0, t.canvas.width, t.canvas.height],
                    scissor: [0, 0, t.canvas.width, t.canvas.height],
                    stencilFunc: [519, 0, 255, 519, 0, 255],
                  }),
                  ht(t, Ic, () => {
                    n._drawLayers("google-vector", { clearCanvas: !1 });
                  });
              }
            }
          }
          class kc {
            constructor(t, e) {
              (this.opts = e), (this.source = t);
            }
            get value() {
              return this.source.value;
            }
            getValue() {
              const t = this.source.getBuffer(),
                e = this.getAccessor();
              if (t) return [t, e];
              const { value: n } = this.source,
                { size: i } = e;
              let r = n;
              if (n && n.length !== i) {
                r = new Float32Array(i);
                const t = e.elementOffset || 0;
                for (let e = 0; e < i; ++e) r[e] = n[t + e];
              }
              return r;
            }
            getAccessor() {
              return { ...this.source.getAccessor(), ...this.opts };
            }
          }
          function jc(t) {
            return t.stride || t.size * t.bytesPerElement;
          }
          function Fc(t, e) {
            e.offset &&
              Et.removed(
                "shaderAttribute.offset",
                "vertexOffset, elementOffset"
              )();
            const n = jc(t),
              i =
                ("vertexOffset" in e ? e.vertexOffset : t.vertexOffset || 0) *
                  n +
                (e.elementOffset || 0) * t.bytesPerElement +
                (t.offset || 0);
            return { ...e, offset: i, stride: n };
          }
          const Bc = [],
            Dc = [];
          function Nc(t, e = 0, n = 1 / 0) {
            let i = Bc;
            const r = { index: -1, data: t, target: [] };
            return (
              t
                ? "function" == typeof t[Symbol.iterator]
                  ? (i = t)
                  : t.length > 0 && ((Dc.length = t.length), (i = Dc))
                : (i = Bc),
              (e > 0 || Number.isFinite(n)) &&
                ((i = (Array.isArray(i) ? i : Array.from(i)).slice(e, n)),
                (r.index = e - 1)),
              { iterable: i, objectInfo: r }
            );
          }
          function zc(t) {
            return t && t[Symbol.asyncIterator];
          }
          function Vc(
            t,
            { size: e, stride: n, offset: i, startIndices: r, nested: s }
          ) {
            const o = t.BYTES_PER_ELEMENT,
              a = n ? n / o : e,
              c = i ? i / o : 0,
              h = Math.floor((t.length - c) / a);
            return (n, { index: i, target: o }) => {
              if (!r) {
                const n = i * a + c;
                for (let i = 0; i < e; i++) o[i] = t[n + i];
                return o;
              }
              const l = r[i],
                u = r[i + 1] || h;
              let d;
              if (s) {
                d = new Array(u - l);
                for (let n = l; n < u; n++) {
                  const i = n * a + c;
                  o = new Array(e);
                  for (let n = 0; n < e; n++) o[n] = t[i + n];
                  d[n - l] = o;
                }
              } else if (a === e) d = t.subarray(l * e + c, u * e + c);
              else {
                d = new t.constructor((u - l) * e);
                let n = 0;
                for (let i = l; i < u; i++) {
                  const r = i * a + c;
                  for (let i = 0; i < e; i++) d[n++] = t[r + i];
                }
              }
              return d;
            };
          }
          const Uc = [],
            Gc = [[0, 1 / 0]];
          function $c({
            source: t,
            target: e,
            start: n = 0,
            end: i,
            size: r,
            getData: s,
          }) {
            i = i || e.length;
            const o = t.length,
              a = i - n;
            if (o > a) return void e.set(t.subarray(0, a), n);
            if ((e.set(t, n), !s)) return;
            let c = o;
            for (; c < a; ) {
              const i = s(c, t);
              for (let t = 0; t < r; t++) (e[n + c] = i[t] || 0), c++;
            }
          }
          const Wc = {
            interpolation: { duration: 0, easing: (t) => t },
            spring: { stiffness: 0.05, damping: 0.5 },
          };
          function Hc(t, e) {
            return t
              ? (Number.isFinite(t) && (t = { duration: t }),
                (t.type = t.type || "interpolation"),
                { ...Wc[t.type], ...e, ...t })
              : null;
          }
          function Xc(t, e) {
            return e.getBuffer()
              ? [
                  e.getBuffer(),
                  {
                    divisor: 0,
                    size: e.size,
                    normalized: e.settings.normalized,
                  },
                ]
              : e.value;
          }
          function qc(t) {
            switch (t) {
              case 1:
                return "float";
              case 2:
                return "vec2";
              case 3:
                return "vec3";
              case 4:
                return "vec4";
              default:
                throw new Error(
                  'No defined attribute type for size "'.concat(t, '"')
                );
            }
          }
          function Yc(t) {
            t.push(t.shift());
          }
          function Zc(t, e) {
            const { doublePrecision: n, settings: i, value: r, size: s } = t,
              o = n && r instanceof Float64Array ? 2 : 1;
            return (i.noAlloc ? r.length : e * s) * o;
          }
          function Kc({
            buffer: t,
            numInstances: e,
            attribute: n,
            fromLength: i,
            fromStartIndices: r,
            getData: s = (t) => t,
          }) {
            const o =
                n.doublePrecision && n.value instanceof Float64Array ? 2 : 1,
              a = n.size * o,
              c = n.byteOffset,
              h = n.startIndices,
              l = r && h,
              u = Zc(n, e),
              d = n.state.constant;
            if (!l && i >= u) return;
            const f = d ? n.value : n.getBuffer().getData({ srcByteOffset: c });
            if (n.settings.normalized && !d) {
              const t = s;
              s = (e, i) => n._normalizeConstant(t(e, i));
            }
            const p = d
                ? (t, e) => s(f, e)
                : (t, e) => s(f.subarray(t, t + a), e),
              g = t.getData({ length: i }),
              m = new Float32Array(u);
            !(function ({
              source: t,
              target: e,
              size: n,
              getData: i,
              sourceStartIndices: r,
              targetStartIndices: s,
            }) {
              if (!Array.isArray(s))
                return $c({ source: t, target: e, size: n, getData: i }), e;
              let o = 0,
                a = 0;
              const c = i && ((t, e) => i(t + a, e)),
                h = Math.min(r.length, s.length);
              for (let i = 1; i < h; i++) {
                const h = r[i] * n,
                  l = s[i] * n;
                $c({
                  source: t.subarray(o, h),
                  target: e,
                  start: a,
                  end: l,
                  size: n,
                  getData: c,
                }),
                  (o = h),
                  (a = l);
              }
              a < e.length &&
                $c({ source: [], target: e, start: a, size: n, getData: c });
            })({
              source: g,
              target: m,
              sourceStartIndices: r,
              targetStartIndices: h,
              size: a,
              getData: p,
            }),
              t.byteLength < m.byteLength + c && t.reallocate(m.byteLength + c),
              t.subData({ data: m, offset: c });
          }
          class Qc extends class {
            constructor(t, e) {
              (this.gl = t), (this.id = e.id), (this.size = e.size);
              const n = e.logicalType || e.type,
                i = 5130 === n;
              let { defaultValue: r } = e;
              (r = Number.isFinite(r)
                ? [r]
                : r || new Array(this.size).fill(0)),
                (e.defaultValue = r);
              let s = n;
              i
                ? (s = 5126)
                : !s && e.isIndexed
                ? (s =
                    t &&
                    (function (t, e) {
                      return Ur(t, "ELEMENT_INDEX_UINT32");
                    })(t)
                      ? 5125
                      : 5123)
                : s || (s = 5126),
                (e.logicalType = n),
                (e.type = s);
              let o = (function (t) {
                switch (t) {
                  case 5126:
                    return Float32Array;
                  case 5130:
                    return Float64Array;
                  case 5123:
                  case 33635:
                  case 32819:
                  case 32820:
                    return Uint16Array;
                  case 5125:
                    return Uint32Array;
                  case 5121:
                    return Uint8ClampedArray;
                  case 5120:
                    return Int8Array;
                  case 5122:
                    return Int16Array;
                  case 5124:
                    return Int32Array;
                  default:
                    throw new Error("Unknown GL type");
                }
              })(n || s || 5126);
              (this.shaderAttributes = {}),
                (this.doublePrecision = i),
                i && !1 === e.fp64 && (o = Float32Array),
                (e.bytesPerElement = o.BYTES_PER_ELEMENT),
                (this.defaultType = o),
                (this.value = null),
                (this.settings = e),
                (this.state = {
                  externalBuffer: null,
                  bufferAccessor: e,
                  allocatedValue: null,
                  constant: !1,
                }),
                (this._buffer = null),
                this.setData(e);
            }
            get buffer() {
              if (!this._buffer) {
                const { isIndexed: t, type: e } = this.settings;
                this._buffer = new vr(this.gl, {
                  id: this.id,
                  target: t ? 34963 : 34962,
                  accessor: { type: e },
                });
              }
              return this._buffer;
            }
            get byteOffset() {
              const t = this.getAccessor();
              return t.vertexOffset ? t.vertexOffset * jc(t) : 0;
            }
            delete() {
              this._buffer && (this._buffer.delete(), (this._buffer = null)),
                Xe.release(this.state.allocatedValue);
            }
            getShaderAttributes(t, e) {
              if (this.doublePrecision) {
                const n = {},
                  i = this.value instanceof Float64Array,
                  r = (function (t, e) {
                    const n = Fc(t, e);
                    return {
                      high: n,
                      low: { ...n, offset: n.offset + 4 * t.size },
                    };
                  })(this.getAccessor(), e || {});
                return (
                  (n[t] = new kc(this, r.high)),
                  (n["".concat(t, "64Low")] = i
                    ? new kc(this, r.low)
                    : new Float32Array(this.size)),
                  n
                );
              }
              if (e) {
                const n = Fc(this.getAccessor(), e);
                return { [t]: new kc(this, n) };
              }
              return { [t]: this };
            }
            getBuffer() {
              return this.state.constant
                ? null
                : this.state.externalBuffer || this._buffer;
            }
            getValue() {
              return this.state.constant
                ? this.value
                : [this.getBuffer(), this.getAccessor()];
            }
            getAccessor() {
              return this.state.bufferAccessor;
            }
            setData(t) {
              const { state: e } = this;
              ArrayBuffer.isView(t)
                ? (t = { value: t })
                : t instanceof vr && (t = { buffer: t });
              const n = { ...this.settings, ...t };
              if (((e.bufferAccessor = n), t.constant)) {
                let n = t.value;
                if (
                  ((n = this._normalizeValue(n, [], 0)),
                  this.settings.normalized && (n = this._normalizeConstant(n)),
                  e.constant && this._areValuesEqual(n, this.value))
                )
                  return !1;
                (e.externalBuffer = null), (e.constant = !0), (this.value = n);
              } else if (t.buffer) {
                const i = t.buffer;
                (e.externalBuffer = i),
                  (e.constant = !1),
                  (this.value = t.value);
                const r = t.value instanceof Float64Array;
                (n.type = t.type || i.accessor.type),
                  (n.bytesPerElement =
                    i.accessor.BYTES_PER_ELEMENT * (r ? 2 : 1)),
                  (n.stride = jc(n));
              } else if (t.value) {
                this._checkExternalBuffer(t);
                let i = t.value;
                (e.externalBuffer = null),
                  (e.constant = !1),
                  (this.value = i),
                  (n.bytesPerElement = i.BYTES_PER_ELEMENT),
                  (n.stride = jc(n));
                const { buffer: r, byteOffset: s } = this;
                this.doublePrecision &&
                  i instanceof Float64Array &&
                  (i = yn(i, n));
                const o = i.byteLength + s + 2 * n.stride;
                r.byteLength < o && r.reallocate(o),
                  r.setAccessor(null),
                  r.subData({ data: i, offset: s }),
                  (n.type = t.type || r.accessor.type);
              }
              return !0;
            }
            updateSubBuffer(t = {}) {
              const { value: e } = this,
                { startOffset: n = 0, endOffset: i } = t;
              this.buffer.subData({
                data:
                  this.doublePrecision && e instanceof Float64Array
                    ? yn(e, { size: this.size, startIndex: n, endIndex: i })
                    : e.subarray(n, i),
                offset: n * e.BYTES_PER_ELEMENT + this.byteOffset,
              });
            }
            allocate({ numInstances: t, copy: e = !1 }) {
              const { state: n } = this,
                i = n.allocatedValue,
                r = Xe.allocate(i, t + 1, {
                  size: this.size,
                  type: this.defaultType,
                  copy: e,
                });
              this.value = r;
              const { buffer: s, byteOffset: o } = this;
              return (
                s.byteLength < r.byteLength + o &&
                  (s.reallocate(r.byteLength + o),
                  e &&
                    i &&
                    s.subData({
                      data: i instanceof Float64Array ? yn(i, this) : i,
                      offset: o,
                    })),
                (n.allocatedValue = r),
                (n.constant = !1),
                (n.externalBuffer = null),
                (n.bufferAccessor = this.settings),
                !0
              );
            }
            _checkExternalBuffer(t) {
              const { value: e } = t;
              if (!t.constant && e) {
                const n = this.defaultType;
                let i = !1;
                if ((this.doublePrecision && (i = e.BYTES_PER_ELEMENT < 4), i))
                  throw new Error(
                    "Attribute "
                      .concat(this.id, " does not support ")
                      .concat(e.constructor.name)
                  );
                e instanceof n ||
                  !this.settings.normalized ||
                  "normalized" in t ||
                  Et.warn("Attribute ".concat(this.id, " is normalized"))();
              }
            }
            _normalizeConstant(t) {
              switch (this.settings.type) {
                case 5120:
                  return new Float32Array(t).map(
                    (t) => ((t + 128) / 255) * 2 - 1
                  );
                case 5122:
                  return new Float32Array(t).map(
                    (t) => ((t + 32768) / 65535) * 2 - 1
                  );
                case 5121:
                  return new Float32Array(t).map((t) => t / 255);
                case 5123:
                  return new Float32Array(t).map((t) => t / 65535);
                default:
                  return t;
              }
            }
            _normalizeValue(t, e, n) {
              const { defaultValue: i, size: r } = this.settings;
              if (Number.isFinite(t)) return (e[n] = t), e;
              if (!t) return (e[n] = i[0]), e;
              switch (r) {
                case 4:
                  e[n + 3] = Number.isFinite(t[3]) ? t[3] : i[3];
                case 3:
                  e[n + 2] = Number.isFinite(t[2]) ? t[2] : i[2];
                case 2:
                  e[n + 1] = Number.isFinite(t[1]) ? t[1] : i[1];
                case 1:
                  e[n + 0] = Number.isFinite(t[0]) ? t[0] : i[0];
                  break;
                default:
                  let s = r;
                  for (; --s >= 0; )
                    e[n + s] = Number.isFinite(t[s]) ? t[s] : i[s];
              }
              return e;
            }
            _areValuesEqual(t, e) {
              if (!t || !e) return !1;
              const { size: n } = this;
              for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1;
              return !0;
            }
          } {
            constructor(t, e = {}) {
              super(t, e);
              const {
                transition: n = !1,
                noAlloc: i = !1,
                update: r = null,
                accessor: s = null,
                transform: o = null,
                startIndices: a = null,
              } = e;
              Object.assign(this.settings, {
                transition: n,
                noAlloc: i,
                update: r || (s && this._autoUpdater),
                accessor: s,
                transform: o,
              }),
                Object.assign(this.state, {
                  lastExternalBuffer: null,
                  binaryValue: null,
                  binaryAccessor: null,
                  needsUpdate: !0,
                  needsRedraw: !1,
                  updateRanges: Gc,
                  startIndices: a,
                }),
                Object.seal(this.settings),
                Object.seal(this.state),
                this._validateAttributeUpdaters();
            }
            get startIndices() {
              return this.state.startIndices;
            }
            set startIndices(t) {
              this.state.startIndices = t;
            }
            needsUpdate() {
              return this.state.needsUpdate;
            }
            needsRedraw({ clearChangedFlags: t = !1 } = {}) {
              const e = this.state.needsRedraw;
              return (this.state.needsRedraw = e && !t), e;
            }
            getUpdateTriggers() {
              const { accessor: t } = this.settings;
              return [this.id].concat(("function" != typeof t && t) || []);
            }
            supportsTransition() {
              return Boolean(this.settings.transition);
            }
            getTransitionSetting(t) {
              if (!t || !this.supportsTransition()) return null;
              const { accessor: e } = this.settings,
                n = this.settings.transition;
              return Hc(Array.isArray(e) ? t[e.find((e) => t[e])] : t[e], n);
            }
            setNeedsUpdate(t = this.id, e) {
              if (
                ((this.state.needsUpdate = this.state.needsUpdate || t),
                this.setNeedsRedraw(t),
                e)
              ) {
                const { startRow: t = 0, endRow: n = 1 / 0 } = e;
                this.state.updateRanges = (function (t, e) {
                  if (t === Gc) return t;
                  if ((e[0] < 0 && (e[0] = 0), e[0] >= e[1])) return t;
                  const n = [],
                    i = t.length;
                  let r = 0;
                  for (let s = 0; s < i; s++) {
                    const i = t[s];
                    i[1] < e[0]
                      ? (n.push(i), (r = s + 1))
                      : i[0] > e[1]
                      ? n.push(i)
                      : (e = [Math.min(i[0], e[0]), Math.max(i[1], e[1])]);
                  }
                  return n.splice(r, 0, e), n;
                })(this.state.updateRanges, [t, n]);
              } else this.state.updateRanges = Gc;
            }
            clearNeedsUpdate() {
              (this.state.needsUpdate = !1), (this.state.updateRanges = Uc);
            }
            setNeedsRedraw(t = this.id) {
              this.state.needsRedraw = this.state.needsRedraw || t;
            }
            update(t) {
              this.setData(t);
            }
            allocate(t) {
              const { state: e, settings: n } = this;
              return (
                !n.noAlloc &&
                !!n.update &&
                (super.allocate({
                  numInstances: t,
                  copy: e.updateRanges !== Gc,
                }),
                !0)
              );
            }
            updateBuffer({ numInstances: t, data: e, props: n, context: i }) {
              if (!this.needsUpdate()) return !1;
              const {
                state: { updateRanges: r },
                settings: { update: s, noAlloc: o },
              } = this;
              let a = !0;
              if (s) {
                for (const [o, a] of r)
                  s.call(i, this, {
                    data: e,
                    startRow: o,
                    endRow: a,
                    props: n,
                    numInstances: t,
                  });
                if (this.value)
                  if (
                    this.constant ||
                    this.buffer.byteLength <
                      this.value.byteLength + this.byteOffset
                  )
                    this.setData({
                      value: this.value,
                      constant: this.constant,
                    }),
                      (this.constant = !1);
                  else
                    for (const [e, n] of r) {
                      const i = Number.isFinite(e)
                          ? this.getVertexOffset(e)
                          : 0,
                        r = Number.isFinite(n)
                          ? this.getVertexOffset(n)
                          : o || !Number.isFinite(t)
                          ? this.value.length
                          : t * this.size;
                      super.updateSubBuffer({ startOffset: i, endOffset: r });
                    }
                this._checkAttributeArray();
              } else a = !1;
              return this.clearNeedsUpdate(), this.setNeedsRedraw(), a;
            }
            setConstantValue(t) {
              return (
                void 0 !== t &&
                "function" != typeof t &&
                (this.setData({ constant: !0, value: t }) &&
                  this.setNeedsRedraw(),
                this.clearNeedsUpdate(),
                !0)
              );
            }
            setExternalBuffer(t) {
              const { state: e } = this;
              return t
                ? (this.clearNeedsUpdate(),
                  e.lastExternalBuffer === t ||
                    ((e.lastExternalBuffer = t),
                    this.setNeedsRedraw(),
                    this.setData(t)),
                  !0)
                : ((e.lastExternalBuffer = null), !1);
            }
            setBinaryValue(t, e = null) {
              const { state: n, settings: i } = this;
              if (!t)
                return (n.binaryValue = null), (n.binaryAccessor = null), !1;
              if (i.noAlloc) return !1;
              if (n.binaryValue === t) return this.clearNeedsUpdate(), !0;
              if (
                ((n.binaryValue = t),
                this.setNeedsRedraw(),
                ArrayBuffer.isView(t) && (t = { value: t }),
                i.transform || e !== this.startIndices)
              ) {
                Ks(ArrayBuffer.isView(t.value), "invalid ".concat(i.accessor));
                const r = t.size && t.size !== this.size;
                return (
                  (n.binaryAccessor = Vc(t.value, {
                    size: t.size || this.size,
                    stride: t.stride,
                    offset: t.offset,
                    startIndices: e,
                    nested: r,
                  })),
                  !1
                );
              }
              return this.clearNeedsUpdate(), this.setData(t), !0;
            }
            getVertexOffset(t) {
              const { startIndices: e } = this;
              return (e ? e[t] : t) * this.size;
            }
            getShaderAttributes() {
              const t = this.settings.shaderAttributes || { [this.id]: null },
                e = {};
              for (const n in t)
                Object.assign(e, super.getShaderAttributes(n, t[n]));
              return e;
            }
            _autoUpdater(
              t,
              { data: e, startRow: n, endRow: i, props: r, numInstances: s }
            ) {
              if (t.constant) return;
              const {
                  settings: o,
                  state: a,
                  value: c,
                  size: h,
                  startIndices: l,
                } = t,
                { accessor: u, transform: d } = o,
                f = a.binaryAccessor || ("function" == typeof u ? u : r[u]);
              Ks(
                "function" == typeof f,
                'accessor "'.concat(u, '" is not a function')
              );
              let p = t.getVertexOffset(n);
              const { iterable: g, objectInfo: m } = Nc(e, n, i);
              for (const e of g) {
                m.index++;
                let n = f(e, m);
                if ((d && (n = d.call(this, n)), l)) {
                  const e =
                    (m.index < l.length - 1 ? l[m.index + 1] : s) - l[m.index];
                  if (n && Array.isArray(n[0])) {
                    let e = p;
                    for (const i of n) t._normalizeValue(i, c, e), (e += h);
                  } else
                    n && n.length > h
                      ? c.set(n, p)
                      : (t._normalizeValue(n, m.target, 0),
                        Mt({
                          target: c,
                          source: m.target,
                          start: p,
                          count: e,
                        }));
                  p += e * h;
                } else t._normalizeValue(n, c, p), (p += h);
              }
            }
            _validateAttributeUpdaters() {
              const { settings: t } = this;
              if (!t.noAlloc && "function" != typeof t.update)
                throw new Error(
                  "Attribute ".concat(this.id, " missing update or accessor")
                );
            }
            _checkAttributeArray() {
              const { value: t } = this,
                e = Math.min(4, this.size);
              if (t && t.length >= e) {
                let n = !0;
                switch (e) {
                  case 4:
                    n = n && Number.isFinite(t[3]);
                  case 3:
                    n = n && Number.isFinite(t[2]);
                  case 2:
                    n = n && Number.isFinite(t[1]);
                  case 1:
                    n = n && Number.isFinite(t[0]);
                    break;
                  default:
                    n = !1;
                }
                if (!n)
                  throw new Error(
                    "Illegal attribute generated for ".concat(this.id)
                  );
              }
            }
          }
          const Jc =
              "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}",
            th = `#version 300 es\n${Jc}`;
          function eh(t, e) {
            e = Array.isArray(e) ? e : [e];
            const n = t.replace(/^\s+/, "").split(/\s+/),
              [i, r, s] = n;
            return e.includes(i) && r && s
              ? { qualifier: i, type: r, name: s.split(";")[0] }
              : null;
          }
          function nh(t = {}) {
            const { version: e = 100, input: n, inputType: i, output: r } = t;
            if (!n)
              return 300 === e
                ? th
                : e > 300
                ? `#version ${e}\n${Jc}`
                : "void main() {gl_FragColor = vec4(0);}";
            const s = (function (t, e) {
              switch (e) {
                case "float":
                  return `vec4(${t}, 0.0, 0.0, 1.0)`;
                case "vec2":
                  return `vec4(${t}, 0.0, 1.0)`;
                case "vec3":
                  return `vec4(${t}, 1.0)`;
                case "vec4":
                  return t;
                default:
                  return yi(!1), null;
              }
            })(n, i);
            return e >= 300
              ? `#version ${e} ${
                  300 === e ? "es" : ""
                }\nin ${i} ${n};\nout vec4 ${r};\nvoid main() {\n  ${r} = ${s};\n}`
              : `varying ${i} ${n};\nvoid main() {\n  gl_FragColor = ${s};\n}`;
          }
          class ih extends hr {
            static isSupported(t) {
              return S(t);
            }
            constructor(t, e = {}) {
              C(t),
                super(t, e),
                this.initialize(e),
                this.stubRemovedMethods("TransformFeedback", "v6.0", [
                  "pause",
                  "resume",
                ]),
                Object.seal(this);
            }
            initialize(t = {}) {
              return (
                (this.buffers = {}),
                (this.unused = {}),
                (this.configuration = null),
                (this.bindOnUse = !0),
                or(this.buffers) || this.bind(() => this._unbindBuffers()),
                this.setProps(t),
                this
              );
            }
            setProps(t) {
              "program" in t &&
                (this.configuration = t.program && t.program.configuration),
                "configuration" in t && (this.configuration = t.configuration),
                "bindOnUse" in t && (t = t.bindOnUse),
                "buffers" in t && this.setBuffers(t.buffers);
            }
            setBuffers(t = {}) {
              return (
                this.bind(() => {
                  for (const e in t) this.setBuffer(e, t[e]);
                }),
                this
              );
            }
            setBuffer(t, e) {
              const n = this._getVaryingIndex(t),
                {
                  buffer: i,
                  byteSize: r,
                  byteOffset: s,
                } = this._getBufferParams(e);
              return n < 0
                ? ((this.unused[t] = i),
                  P.warn(() => `${this.id} unused varying buffer ${t}`)(),
                  this)
                : ((this.buffers[n] = e),
                  this.bindOnUse || this._bindBuffer(n, i, s, r),
                  this);
            }
            begin(t = 0) {
              return (
                this.gl.bindTransformFeedback(36386, this.handle),
                this._bindBuffers(),
                this.gl.beginTransformFeedback(t),
                this
              );
            }
            end() {
              return (
                this.gl.endTransformFeedback(),
                this._unbindBuffers(),
                this.gl.bindTransformFeedback(36386, null),
                this
              );
            }
            _getBufferParams(t) {
              let e, n, i;
              return (
                t instanceof vr == 0
                  ? ((i = t.buffer), (n = t.byteSize), (e = t.byteOffset))
                  : (i = t),
                (void 0 === e && void 0 === n) ||
                  ((e = e || 0), (n = n || i.byteLength - e)),
                { buffer: i, byteOffset: e, byteSize: n }
              );
            }
            _getVaryingInfo(t) {
              return this.configuration && this.configuration.getVaryingInfo(t);
            }
            _getVaryingIndex(t) {
              if (this.configuration)
                return this.configuration.getVaryingInfo(t).location;
              const e = Number(t);
              return Number.isFinite(e) ? e : -1;
            }
            _bindBuffers() {
              if (this.bindOnUse)
                for (const t in this.buffers) {
                  const {
                    buffer: e,
                    byteSize: n,
                    byteOffset: i,
                  } = this._getBufferParams(this.buffers[t]);
                  this._bindBuffer(t, e, i, n);
                }
            }
            _unbindBuffers() {
              if (this.bindOnUse)
                for (const t in this.buffers) this._bindBuffer(t, null);
            }
            _bindBuffer(t, e, n = 0, i) {
              const r = e && e.handle;
              return (
                r && void 0 !== i
                  ? this.gl.bindBufferRange(35982, t, r, n, i)
                  : this.gl.bindBufferBase(35982, t, r),
                this
              );
            }
            _createHandle() {
              return this.gl.createTransformFeedback();
            }
            _deleteHandle() {
              this.gl.deleteTransformFeedback(this.handle);
            }
            _bindHandle(t) {
              this.gl.bindTransformFeedback(36386, this.handle);
            }
          }
          class rh {
            constructor(t, e = {}) {
              (this.gl = t),
                (this.currentIndex = 0),
                (this.feedbackMap = {}),
                (this.varyings = null),
                (this.bindings = []),
                (this.resources = {}),
                this._initialize(e),
                Object.seal(this);
            }
            setupResources(t) {
              for (const e of this.bindings) this._setupTransformFeedback(e, t);
            }
            updateModelProps(t = {}) {
              const { varyings: e } = this;
              return (
                e.length > 0 && (t = Object.assign({}, t, { varyings: e })), t
              );
            }
            getDrawOptions(t = {}) {
              const e = this.bindings[this.currentIndex],
                { sourceBuffers: n, transformFeedback: i } = e;
              return {
                attributes: Object.assign({}, n, t.attributes),
                transformFeedback: i,
              };
            }
            swap() {
              return (
                !!this.feedbackMap &&
                ((this.currentIndex = this._getNextIndex()), !0)
              );
            }
            update(t = {}) {
              this._setupBuffers(t);
            }
            getBuffer(t) {
              const { feedbackBuffers: e } = this.bindings[this.currentIndex],
                n = t ? e[t] : null;
              return n ? (n instanceof vr ? n : n.buffer) : null;
            }
            getData(t = {}) {
              const { varyingName: e } = t,
                n = this.getBuffer(e);
              return n ? n.getData() : null;
            }
            delete() {
              for (const t in this.resources) this.resources[t].delete();
            }
            _initialize(t = {}) {
              this._setupBuffers(t),
                (this.varyings =
                  t.varyings ||
                  Object.keys(
                    this.bindings[this.currentIndex].feedbackBuffers
                  )),
                this.varyings.length > 0 && tr(S(this.gl));
            }
            _getFeedbackBuffers(t) {
              const { sourceBuffers: e = {} } = t,
                n = {};
              if (
                (this.bindings[this.currentIndex] &&
                  Object.assign(
                    n,
                    this.bindings[this.currentIndex].feedbackBuffers
                  ),
                this.feedbackMap)
              )
                for (const t in this.feedbackMap) {
                  const i = this.feedbackMap[t];
                  t in e && (n[i] = t);
                }
              Object.assign(n, t.feedbackBuffers);
              for (const t in n) {
                const i = n[t];
                if ("string" == typeof i) {
                  const r = e[i],
                    { byteLength: s, usage: o, accessor: a } = r;
                  n[t] = this._createNewBuffer(t, {
                    byteLength: s,
                    usage: o,
                    accessor: a,
                  });
                }
              }
              return n;
            }
            _setupBuffers(t = {}) {
              const { sourceBuffers: e = null } = t;
              Object.assign(this.feedbackMap, t.feedbackMap);
              const n = this._getFeedbackBuffers(t);
              this._updateBindings({ sourceBuffers: e, feedbackBuffers: n });
            }
            _setupTransformFeedback(t, { model: e }) {
              const { program: n } = e;
              t.transformFeedback = new ih(this.gl, {
                program: n,
                buffers: t.feedbackBuffers,
              });
            }
            _updateBindings(t) {
              if (
                ((this.bindings[this.currentIndex] = this._updateBinding(
                  this.bindings[this.currentIndex],
                  t
                )),
                this.feedbackMap)
              ) {
                const { sourceBuffers: t, feedbackBuffers: e } =
                    this._swapBuffers(this.bindings[this.currentIndex]),
                  n = this._getNextIndex();
                this.bindings[n] = this._updateBinding(this.bindings[n], {
                  sourceBuffers: t,
                  feedbackBuffers: e,
                });
              }
            }
            _updateBinding(t, e) {
              return t
                ? (Object.assign(t.sourceBuffers, e.sourceBuffers),
                  Object.assign(t.feedbackBuffers, e.feedbackBuffers),
                  t.transformFeedback &&
                    t.transformFeedback.setBuffers(t.feedbackBuffers),
                  t)
                : {
                    sourceBuffers: Object.assign({}, e.sourceBuffers),
                    feedbackBuffers: Object.assign({}, e.feedbackBuffers),
                  };
            }
            _swapBuffers(t) {
              if (!this.feedbackMap) return null;
              const e = Object.assign({}, t.sourceBuffers),
                n = Object.assign({}, t.feedbackBuffers);
              for (const i in this.feedbackMap) {
                const r = this.feedbackMap[i];
                (e[i] = t.feedbackBuffers[r]),
                  (n[r] = t.sourceBuffers[i]),
                  tr(n[r] instanceof vr);
              }
              return { sourceBuffers: e, feedbackBuffers: n };
            }
            _createNewBuffer(t, e) {
              const n = new vr(this.gl, e);
              return (
                this.resources[t] && this.resources[t].delete(),
                (this.resources[t] = n),
                n
              );
            }
            _getNextIndex() {
              return (this.currentIndex + 1) % 2;
            }
          }
          function sh(t) {
            let e = 100;
            const n = t.match(/[^\s]+/g);
            if (n.length >= 2 && "#version" === n[0]) {
              const t = parseInt(n[1], 10);
              Number.isFinite(t) && (e = t);
            }
            return e;
          }
          const oh = {
            name: "transform",
            vs: "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",
            fs: null,
          };
          const ah = { 10241: 9728, 10240: 9728, 10242: 33071, 10243: 33071 };
          class ch {
            constructor(t, e = {}) {
              (this.gl = t),
                (this.id = this.currentIndex = 0),
                (this._swapTexture = null),
                (this.targetTextureVarying = null),
                (this.targetTextureType = null),
                (this.samplerTextureMap = null),
                (this.bindings = []),
                (this.resources = {}),
                this._initialize(e),
                Object.seal(this);
            }
            updateModelProps(t = {}) {
              const e = this._processVertexShader(t);
              return Object.assign({}, t, e);
            }
            getDrawOptions(t = {}) {
              const {
                  sourceBuffers: e,
                  sourceTextures: n,
                  framebuffer: i,
                  targetTexture: r,
                } = this.bindings[this.currentIndex],
                s = Object.assign({}, e, t.attributes),
                o = Object.assign({}, t.uniforms),
                a = Object.assign({}, t.parameters);
              let c = t.discard;
              if (this.hasSourceTextures || this.hasTargetTexture) {
                s.transform_elementID = this.elementIDBuffer;
                for (const t in this.samplerTextureMap) {
                  const e = this.samplerTextureMap[t];
                  o[t] = n[e];
                }
                this._setSourceTextureParameters();
                const t = (function ({
                  sourceTextureMap: t,
                  targetTextureVarying: e,
                  targetTexture: n,
                }) {
                  const i = {};
                  let r, s;
                  e &&
                    (({ width: r, height: s } = n),
                    (i[`transform_uSize_${e}`] = [r, s]));
                  for (const e in t)
                    ({ width: r, height: s } = t[e]),
                      (i[`transform_uSize_${e}`] = [r, s]);
                  return i;
                })({
                  sourceTextureMap: n,
                  targetTextureVarying: this.targetTextureVarying,
                  targetTexture: r,
                });
                Object.assign(o, t);
              }
              return (
                this.hasTargetTexture &&
                  ((c = !1), (a.viewport = [0, 0, i.width, i.height])),
                {
                  attributes: s,
                  framebuffer: i,
                  uniforms: o,
                  discard: c,
                  parameters: a,
                }
              );
            }
            swap() {
              return (
                !!this._swapTexture &&
                ((this.currentIndex = this._getNextIndex()), !0)
              );
            }
            update(t = {}) {
              this._setupTextures(t);
            }
            getTargetTexture() {
              const { targetTexture: t } = this.bindings[this.currentIndex];
              return t;
            }
            getData({ packed: t = !1 } = {}) {
              const { framebuffer: e } = this.bindings[this.currentIndex],
                n = Br(e);
              if (!t) return n;
              const i = n.constructor,
                r = (function (t) {
                  switch (t) {
                    case "float":
                      return 1;
                    case "vec2":
                      return 2;
                    case "vec3":
                      return 3;
                    case "vec4":
                      return 4;
                    default:
                      return yi(!1), null;
                  }
                })(this.targetTextureType),
                s = new i((n.length * r) / 4);
              let o = 0;
              for (let t = 0; t < n.length; t += 4)
                for (let e = 0; e < r; e++) s[o++] = n[t + e];
              return s;
            }
            getFramebuffer() {
              return this.bindings[this.currentIndex].framebuffer;
            }
            delete() {
              this.ownTexture && this.ownTexture.delete(),
                this.elementIDBuffer && this.elementIDBuffer.delete();
            }
            _initialize(t = {}) {
              const { _targetTextureVarying: e, _swapTexture: n } = t;
              (this._swapTexture = n),
                (this.targetTextureVarying = e),
                (this.hasTargetTexture = e),
                this._setupTextures(t);
            }
            _createTargetTexture(t) {
              const { sourceTextures: e, textureOrReference: n } = t;
              if (n instanceof Sr) return n;
              const i = e[n];
              return i
                ? ((this._targetRefTexName = n), this._createNewTexture(i))
                : null;
            }
            _setupTextures(t = {}) {
              const {
                  sourceBuffers: e,
                  _sourceTextures: n = {},
                  _targetTexture: i,
                } = t,
                r = this._createTargetTexture({
                  sourceTextures: n,
                  textureOrReference: i,
                });
              (this.hasSourceTextures =
                this.hasSourceTextures || (n && Object.keys(n).length > 0)),
                this._updateBindings({
                  sourceBuffers: e,
                  sourceTextures: n,
                  targetTexture: r,
                }),
                "elementCount" in t &&
                  this._updateElementIDBuffer(t.elementCount);
            }
            _updateElementIDBuffer(t) {
              if ("number" != typeof t || this.elementCount >= t) return;
              const e = new Float32Array(t);
              e.forEach((t, e, n) => {
                n[e] = e;
              }),
                this.elementIDBuffer
                  ? this.elementIDBuffer.setData({ data: e })
                  : (this.elementIDBuffer = new vr(this.gl, {
                      data: e,
                      accessor: { size: 1 },
                    })),
                (this.elementCount = t);
            }
            _updateBindings(t) {
              if (
                ((this.bindings[this.currentIndex] = this._updateBinding(
                  this.bindings[this.currentIndex],
                  t
                )),
                this._swapTexture)
              ) {
                const { sourceTextures: t, targetTexture: e } =
                    this._swapTextures(this.bindings[this.currentIndex]),
                  n = this._getNextIndex();
                this.bindings[n] = this._updateBinding(this.bindings[n], {
                  sourceTextures: t,
                  targetTexture: e,
                });
              }
            }
            _updateBinding(t, e) {
              const {
                sourceBuffers: n,
                sourceTextures: i,
                targetTexture: r,
              } = e;
              if (
                (t ||
                  (t = {
                    sourceBuffers: {},
                    sourceTextures: {},
                    targetTexture: null,
                  }),
                Object.assign(t.sourceTextures, i),
                Object.assign(t.sourceBuffers, n),
                r)
              ) {
                t.targetTexture = r;
                const { width: e, height: n } = r,
                  { framebuffer: i } = t;
                i
                  ? (i.update({
                      attachments: { 36064: r },
                      resizeAttachments: !1,
                    }),
                    i.resize({ width: e, height: n }))
                  : (t.framebuffer = new Wr(this.gl, {
                      id: "transform-framebuffer",
                      width: e,
                      height: n,
                      attachments: { 36064: r },
                    }));
              }
              return t;
            }
            _setSourceTextureParameters() {
              const t = this.currentIndex,
                { sourceTextures: e } = this.bindings[t];
              for (const t in e) e[t].setParameters(ah);
            }
            _swapTextures(t) {
              if (!this._swapTexture) return null;
              const e = Object.assign({}, t.sourceTextures);
              return (
                (e[this._swapTexture] = t.targetTexture),
                {
                  sourceTextures: e,
                  targetTexture: t.sourceTextures[this._swapTexture],
                }
              );
            }
            _createNewTexture(t) {
              const e = (function (t, e) {
                tr(t instanceof Sr || t instanceof kr || t instanceof jr);
                const n = t.constructor,
                  {
                    gl: i,
                    width: r,
                    height: s,
                    format: o,
                    type: a,
                    dataFormat: c,
                    border: h,
                    mipmaps: l,
                  } = t;
                return new n(
                  i,
                  Object.assign(
                    {
                      width: r,
                      height: s,
                      format: o,
                      type: a,
                      dataFormat: c,
                      border: h,
                      mipmaps: l,
                    },
                    {
                      parameters: {
                        10241: 9728,
                        10240: 9728,
                        10242: 33071,
                        10243: 33071,
                      },
                      pixelStore: { 37440: !1 },
                    }
                  )
                );
              })(t);
              return (
                this.ownTexture && this.ownTexture.delete(),
                (this.ownTexture = e),
                e
              );
            }
            _getNextIndex() {
              return (this.currentIndex + 1) % 2;
            }
            _processVertexShader(t = {}) {
              const { sourceTextures: e, targetTexture: n } =
                  this.bindings[this.currentIndex],
                {
                  vs: i,
                  uniforms: r,
                  targetTextureType: s,
                  inject: o,
                  samplerTextureMap: a,
                } = (function ({
                  vs: t,
                  sourceTextureMap: e,
                  targetTextureVarying: n,
                  targetTexture: i,
                }) {
                  let r = Object.keys(e).length,
                    s = null;
                  const o = {};
                  let a = t,
                    c = {};
                  if (r > 0 || n) {
                    const t = a.split("\n"),
                      h = t.slice();
                    if (
                      (t.forEach((t, i, a) => {
                        if (r > 0) {
                          const n = (function (t, e) {
                            const n = {},
                              i = (function (t) {
                                return eh(t, ["attribute", "in"]);
                              })(t);
                            if (!i) return null;
                            const { type: r, name: s } = i;
                            if (s && e[s]) {
                              const e = `// ${t} => Replaced by Transform with a sampler`,
                                {
                                  samplerName: i,
                                  sizeName: o,
                                  uniformDeclerations: a,
                                } = (function (t) {
                                  const e = `transform_uSampler_${t}`,
                                    n = `transform_uSize_${t}`;
                                  return {
                                    samplerName: e,
                                    sizeName: n,
                                    uniformDeclerations: `  uniform sampler2D ${e};\n  uniform vec2 ${n};`,
                                  };
                                })(s),
                                c = (function (t) {
                                  switch (t) {
                                    case "float":
                                      return "x";
                                    case "vec2":
                                      return "xy";
                                    case "vec3":
                                      return "xyz";
                                    case "vec4":
                                      return "xyzw";
                                    default:
                                      return yi(!1), null;
                                  }
                                })(r),
                                h = `  ${r} ${s} = transform_getInput(${i}, ${o}).${c};\n`;
                              return (
                                (n[i] = s),
                                {
                                  updatedLine: e,
                                  inject: {
                                    "vs:#decl": a,
                                    "vs:#main-start": h,
                                  },
                                  samplerTextureMap: n,
                                }
                              );
                            }
                            return null;
                          })(t, e);
                          if (n) {
                            const { updatedLine: t, inject: e } = n;
                            (h[i] = t),
                              (c = Di([c, e])),
                              Object.assign(o, n.samplerTextureMap),
                              r--;
                          }
                        }
                        n &&
                          !s &&
                          (s = (function (t, e) {
                            const n = eh(t, ["varying", "out"]);
                            return n && n.name === e ? n.type : null;
                          })(t, n));
                      }),
                      n)
                    ) {
                      tr(i);
                      const t = `transform_uSize_${n}`;
                      c = Di([
                        c,
                        {
                          "vs:#decl": `uniform vec2 ${t};\n`,
                          "vs:#main-start": `     vec2 transform_position = transform_getPos(${t});\n     gl_Position = vec4(transform_position, 0, 1.);\n`,
                        },
                      ]);
                    }
                    a = h.join("\n");
                  }
                  return {
                    vs: a,
                    targetTextureType: s,
                    inject: c,
                    samplerTextureMap: o,
                  };
                })({
                  vs: t.vs,
                  sourceTextureMap: e,
                  targetTextureVarying: this.targetTextureVarying,
                  targetTexture: n,
                }),
                c = Di([t.inject || {}, o]);
              return (
                (this.targetTextureType = s),
                (this.samplerTextureMap = a),
                {
                  vs: i,
                  fs:
                    t._fs ||
                    nh({
                      version: sh(i),
                      input: this.targetTextureVarying,
                      inputType: s,
                      output: "transform_output",
                    }),
                  modules:
                    this.hasSourceTextures || this.targetTextureVarying
                      ? [oh].concat(t.modules || [])
                      : t.modules,
                  uniforms: r,
                  inject: c,
                }
              );
            }
          }
          let hh = null;
          class lh extends hr {
            static isSupported(n, i = {}) {
              return (
                !i.constantAttributeZero ||
                S(n) ||
                "Chrome" ===
                  (function (n) {
                    if (!e()) return "Node";
                    if (t(n)) return "Electron";
                    const i =
                      ("undefined" != typeof navigator ? navigator : {})
                        .userAgent || "";
                    if (i.indexOf("Edge") > -1) return "Edge";
                    const r = -1 !== i.indexOf("MSIE "),
                      s = -1 !== i.indexOf("Trident/");
                    return r || s
                      ? "IE"
                      : d.chrome
                      ? "Chrome"
                      : d.safari
                      ? "Safari"
                      : d.mozInnerScreenX
                      ? "Firefox"
                      : "Unknown";
                  })()
              );
            }
            static getDefaultArray(t) {
              return (
                (t.luma = t.luma || {}),
                t.luma.defaultVertexArray ||
                  (t.luma.defaultVertexArray = new lh(t, {
                    handle: null,
                    isDefaultArray: !0,
                  })),
                t.luma.defaultVertexArray
              );
            }
            static getMaxAttributes(t) {
              return (
                (lh.MAX_ATTRIBUTES =
                  lh.MAX_ATTRIBUTES || t.getParameter(34921)),
                lh.MAX_ATTRIBUTES
              );
            }
            static setConstant(t, e, n) {
              switch (n.constructor) {
                case Float32Array:
                  lh._setConstantFloatArray(t, e, n);
                  break;
                case Int32Array:
                  lh._setConstantIntArray(t, e, n);
                  break;
                case Uint32Array:
                  lh._setConstantUintArray(t, e, n);
                  break;
                default:
                  tr(!1);
              }
            }
            constructor(t, e = {}) {
              const n = e.id || (e.program && e.program.id);
              super(t, Object.assign({}, e, { id: n })),
                (this.buffer = null),
                (this.bufferValue = null),
                (this.isDefaultArray = e.isDefaultArray || !1),
                (this.gl2 = t),
                this.initialize(e),
                Object.seal(this);
            }
            delete() {
              return super.delete(), this.buffer && this.buffer.delete(), this;
            }
            get MAX_ATTRIBUTES() {
              return lh.getMaxAttributes(this.gl);
            }
            initialize(t = {}) {
              return this.setProps(t);
            }
            setProps(t) {
              return this;
            }
            setElementBuffer(t = null, e = {}) {
              return (
                tr(
                  !t || 34963 === t.target,
                  "elements must be GL.ELEMENT_ARRAY_BUFFER"
                ),
                this.bind(() => {
                  this.gl.bindBuffer(34963, t ? t.handle : null);
                }),
                this
              );
            }
            setBuffer(t, e, n) {
              if (34963 === e.target) return this.setElementBuffer(e, n);
              const {
                  size: i,
                  type: r,
                  stride: s,
                  offset: o,
                  normalized: a,
                  integer: c,
                  divisor: h,
                } = n,
                { gl: l, gl2: u } = this;
              return (
                (t = Number(t)),
                this.bind(() => {
                  l.bindBuffer(34962, e.handle),
                    c
                      ? (tr(S(l)), u.vertexAttribIPointer(t, i, r, s, o))
                      : l.vertexAttribPointer(t, i, r, a, s, o),
                    l.enableVertexAttribArray(t),
                    u.vertexAttribDivisor(t, h || 0);
                }),
                this
              );
            }
            enable(t, e = !0) {
              return (
                (!e &&
                  0 === t &&
                  !lh.isSupported(this.gl, { constantAttributeZero: !0 })) ||
                  ((t = Number(t)),
                  this.bind(() =>
                    e
                      ? this.gl.enableVertexAttribArray(t)
                      : this.gl.disableVertexAttribArray(t)
                  )),
                this
              );
            }
            getConstantBuffer(t, e) {
              const n = this._normalizeConstantArrayValue(e),
                i = n.byteLength * t,
                r = n.length * t;
              let s = !this.buffer;
              if (
                ((this.buffer = this.buffer || new vr(this.gl, i)),
                (s = s || this.buffer.reallocate(i)),
                (s =
                  s || !this._compareConstantArrayValues(n, this.bufferValue)),
                s)
              ) {
                const t = (function (t, e) {
                  var n;
                  return new t(
                    ((n = t.BYTES_PER_ELEMENT * e),
                    (!hh || hh.byteLength < n) && (hh = new ArrayBuffer(n)),
                    hh),
                    0,
                    e
                  );
                })(e.constructor, r);
                !(function ({
                  target: t,
                  source: e,
                  start: n = 0,
                  count: i = 1,
                }) {
                  const r = e.length,
                    s = i * r;
                  let o = 0;
                  for (let i = n; o < r; o++) t[i++] = e[o];
                  for (; o < s; )
                    o < s - o
                      ? (t.copyWithin(n + o, n, n + o), (o *= 2))
                      : (t.copyWithin(n + o, n, n + s - o), (o = s));
                })({ target: t, source: n, start: 0, count: r }),
                  this.buffer.subData(t),
                  (this.bufferValue = e);
              }
              return this.buffer;
            }
            _normalizeConstantArrayValue(t) {
              return Array.isArray(t) ? new Float32Array(t) : t;
            }
            _compareConstantArrayValues(t, e) {
              if (
                !t ||
                !e ||
                t.length !== e.length ||
                t.constructor !== e.constructor
              )
                return !1;
              for (let n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;
              return !0;
            }
            static _setConstantFloatArray(t, e, n) {
              switch (n.length) {
                case 1:
                  t.vertexAttrib1fv(e, n);
                  break;
                case 2:
                  t.vertexAttrib2fv(e, n);
                  break;
                case 3:
                  t.vertexAttrib3fv(e, n);
                  break;
                case 4:
                  t.vertexAttrib4fv(e, n);
                  break;
                default:
                  tr(!1);
              }
            }
            static _setConstantIntArray(t, e, n) {
              switch ((tr(S(t)), n.length)) {
                case 1:
                  t.vertexAttribI1iv(e, n);
                  break;
                case 2:
                  t.vertexAttribI2iv(e, n);
                  break;
                case 3:
                  t.vertexAttribI3iv(e, n);
                  break;
                case 4:
                  t.vertexAttribI4iv(e, n);
                  break;
                default:
                  tr(!1);
              }
            }
            static _setConstantUintArray(t, e, n) {
              switch ((tr(S(t)), n.length)) {
                case 1:
                  t.vertexAttribI1uiv(e, n);
                  break;
                case 2:
                  t.vertexAttribI2uiv(e, n);
                  break;
                case 3:
                  t.vertexAttribI3uiv(e, n);
                  break;
                case 4:
                  t.vertexAttribI4uiv(e, n);
                  break;
                default:
                  tr(!1);
              }
            }
            _createHandle() {
              return this.gl.createVertexArray();
            }
            _deleteHandle(t) {
              return this.gl2.deleteVertexArray(t), [this.elements];
            }
            _bindHandle(t) {
              this.gl2.bindVertexArray(t);
            }
            _getParameter(t, { location: e }) {
              return (
                tr(Number.isFinite(e)),
                this.bind(() =>
                  34373 === t
                    ? this.gl.getVertexAttribOffset(e, t)
                    : this.gl.getVertexAttrib(e, t)
                )
              );
            }
          }
          const uh = /^(.+)__LOCATION_([0-9]+)$/,
            dh = [
              "setBuffers",
              "setGeneric",
              "clearBindings",
              "setLocations",
              "setGenericValues",
              "setDivisor",
              "enable",
              "disable",
            ];
          class fh {
            constructor(t, e = {}) {
              const n = e.id || (e.program && e.program.id);
              (this.id = n),
                (this.gl = t),
                (this.configuration = null),
                (this.elements = null),
                (this.elementsAccessor = null),
                (this.values = null),
                (this.accessors = null),
                (this.unused = null),
                (this.drawParams = null),
                (this.buffer = null),
                (this.attributes = {}),
                (this.vertexArrayObject = new lh(t)),
                ar(this, "VertexArray", "v6.0", dh),
                this.initialize(e),
                Object.seal(this);
            }
            delete() {
              this.buffer && this.buffer.delete(),
                this.vertexArrayObject.delete();
            }
            initialize(t = {}) {
              return (
                this.reset(),
                (this.configuration = null),
                (this.bindOnUse = !1),
                this.setProps(t)
              );
            }
            reset() {
              (this.elements = null), (this.elementsAccessor = null);
              const { MAX_ATTRIBUTES: t } = this.vertexArrayObject;
              return (
                (this.values = new Array(t).fill(null)),
                (this.accessors = new Array(t).fill(null)),
                (this.unused = {}),
                (this.drawParams = null),
                this
              );
            }
            setProps(t) {
              return (
                "program" in t &&
                  (this.configuration = t.program && t.program.configuration),
                "configuration" in t && (this.configuration = t.configuration),
                "attributes" in t && this.setAttributes(t.attributes),
                "elements" in t && this.setElementBuffer(t.elements),
                "bindOnUse" in t && (t = t.bindOnUse),
                this
              );
            }
            clearDrawParams() {
              this.drawParams = null;
            }
            getDrawParams() {
              return (
                (this.drawParams = this.drawParams || this._updateDrawParams()),
                this.drawParams
              );
            }
            setAttributes(t) {
              return (
                Object.assign(this.attributes, t),
                this.vertexArrayObject.bind(() => {
                  for (const e in t) {
                    const n = t[e];
                    this._setAttribute(e, n);
                  }
                  this.gl.bindBuffer(34962, null);
                }),
                this
              );
            }
            setElementBuffer(t = null, e = {}) {
              return (
                (this.elements = t),
                (this.elementsAccessor = e),
                this.clearDrawParams(),
                this.vertexArrayObject.setElementBuffer(t, e),
                this
              );
            }
            setBuffer(t, e, n = {}) {
              if (34963 === e.target) return this.setElementBuffer(e, n);
              const { location: i, accessor: r } =
                this._resolveLocationAndAccessor(t, e, e.accessor, n);
              return (
                i >= 0 &&
                  ((this.values[i] = e),
                  (this.accessors[i] = r),
                  this.clearDrawParams(),
                  this.vertexArrayObject.setBuffer(i, e, r)),
                this
              );
            }
            setConstant(t, e, n = {}) {
              const { location: i, accessor: r } =
                this._resolveLocationAndAccessor(
                  t,
                  e,
                  Object.assign({ size: e.length }, n)
                );
              return (
                i >= 0 &&
                  ((e = this.vertexArrayObject._normalizeConstantArrayValue(e)),
                  (this.values[i] = e),
                  (this.accessors[i] = r),
                  this.clearDrawParams(),
                  this.vertexArrayObject.enable(i, !1)),
                this
              );
            }
            unbindBuffers() {
              return (
                this.vertexArrayObject.bind(() => {
                  this.elements &&
                    this.vertexArrayObject.setElementBuffer(null),
                    (this.buffer =
                      this.buffer ||
                      new vr(this.gl, { accessor: { size: 4 } }));
                  for (
                    let t = 0;
                    t < this.vertexArrayObject.MAX_ATTRIBUTES;
                    t++
                  )
                    this.values[t] instanceof vr &&
                      (this.gl.disableVertexAttribArray(t),
                      this.gl.bindBuffer(34962, this.buffer.handle),
                      this.gl.vertexAttribPointer(t, 1, 5126, !1, 0, 0));
                }),
                this
              );
            }
            bindBuffers() {
              return (
                this.vertexArrayObject.bind(() => {
                  this.elements && this.setElementBuffer(this.elements);
                  for (
                    let t = 0;
                    t < this.vertexArrayObject.MAX_ATTRIBUTES;
                    t++
                  ) {
                    const e = this.values[t];
                    e instanceof vr && this.setBuffer(t, e);
                  }
                }),
                this
              );
            }
            bindForDraw(t, e, n) {
              let i;
              return (
                this.vertexArrayObject.bind(() => {
                  this._setConstantAttributes(t, e), (i = n());
                }),
                i
              );
            }
            _resolveLocationAndAccessor(t, e, n, i) {
              const r = { location: -1, accessor: null },
                { location: s, name: o } = this._getAttributeIndex(t);
              if (!Number.isFinite(s) || s < 0)
                return (
                  (this.unused[t] = e),
                  P.once(3, () => `unused value ${t} in ${this.id}`)(),
                  r
                );
              const a = this._getAttributeInfo(o || s);
              if (!a) return r;
              const c = this.accessors[s] || {},
                h = mr.resolve(a.accessor, c, n, i),
                { size: l, type: u } = h;
              return (
                tr(Number.isFinite(l) && Number.isFinite(u)),
                { location: s, accessor: h }
              );
            }
            _getAttributeInfo(t) {
              return (
                this.configuration && this.configuration.getAttributeInfo(t)
              );
            }
            _getAttributeIndex(t) {
              const e = Number(t);
              if (Number.isFinite(e)) return { location: e };
              const n = uh.exec(t),
                i = n ? n[1] : t,
                r = n ? Number(n[2]) : 0;
              return this.configuration
                ? {
                    location: this.configuration.getAttributeLocation(i) + r,
                    name: i,
                  }
                : { location: -1 };
            }
            _setAttribute(t, e) {
              if (e instanceof vr) this.setBuffer(t, e);
              else if (Array.isArray(e) && e.length && e[0] instanceof vr) {
                const n = e[0],
                  i = e[1];
                this.setBuffer(t, n, i);
              } else if (ArrayBuffer.isView(e) || Array.isArray(e)) {
                const n = e;
                this.setConstant(t, n);
              } else {
                if (!(e.buffer instanceof vr))
                  throw new Error(
                    "VertexArray: attributes must be Buffers or constants (i.e. typed array)"
                  );
                {
                  const n = e;
                  this.setBuffer(t, n.buffer, n);
                }
              }
            }
            _setConstantAttributes(t, e) {
              const n = Math.max(0 | t, 0 | e);
              let i = this.values[0];
              ArrayBuffer.isView(i) && this._setConstantAttributeZero(i, n);
              for (let t = 1; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++)
                (i = this.values[t]),
                  ArrayBuffer.isView(i) && this._setConstantAttribute(t, i);
            }
            _setConstantAttributeZero(t, e) {
              if (lh.isSupported(this.gl, { constantAttributeZero: !0 }))
                return void this._setConstantAttribute(0, t);
              const n = this.vertexArrayObject.getConstantBuffer(e, t);
              this.vertexArrayObject.setBuffer(0, n, this.accessors[0]);
            }
            _setConstantAttribute(t, e) {
              lh.setConstant(this.gl, t, e);
            }
            _updateDrawParams() {
              const t = {
                isIndexed: !1,
                isInstanced: !1,
                indexCount: 1 / 0,
                vertexCount: 1 / 0,
                instanceCount: 1 / 0,
              };
              for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++)
                this._updateDrawParamsForLocation(t, e);
              return (
                this.elements &&
                  ((t.elementCount = this.elements.getElementCount(
                    this.elements.accessor
                  )),
                  (t.isIndexed = !0),
                  (t.indexType =
                    this.elementsAccessor.type || this.elements.accessor.type),
                  (t.indexOffset = this.elementsAccessor.offset || 0)),
                t.indexCount === 1 / 0 && (t.indexCount = 0),
                t.vertexCount === 1 / 0 && (t.vertexCount = 0),
                t.instanceCount === 1 / 0 && (t.instanceCount = 0),
                t
              );
            }
            _updateDrawParamsForLocation(t, e) {
              const n = this.values[e],
                i = this.accessors[e];
              if (!n) return;
              const { divisor: r } = i,
                s = r > 0;
              if (((t.isInstanced = t.isInstanced || s), n instanceof vr)) {
                const e = n;
                if (s) {
                  const n = e.getVertexCount(i);
                  t.instanceCount = Math.min(t.instanceCount, n);
                } else {
                  const n = e.getVertexCount(i);
                  t.vertexCount = Math.min(t.vertexCount, n);
                }
              }
            }
            setElements(t = null, e = {}) {
              return (
                P.deprecated("setElements", "setElementBuffer")(),
                this.setElementBuffer(t, e)
              );
            }
          }
          function ph(t, e = {}) {
            const { isInteger: n = !1 } = e;
            if (Array.isArray(t) || ArrayBuffer.isView(t))
              return (function (t, e) {
                const { maxElts: n = 16, size: i = 1 } = e;
                let r = "[";
                for (let s = 0; s < t.length && s < n; ++s)
                  s > 0 && (r += "," + (s % i == 0 ? " " : "")),
                    (r += ph(t[s], e));
                return `${r}${t.length > n ? "..." : "]"}`;
              })(t, e);
            if (!Number.isFinite(t)) return String(t);
            if (Math.abs(t) < 1e-16) return n ? "0" : "0.";
            if (n) return t.toFixed(0);
            if (Math.abs(t) > 100 && Math.abs(t) < 1e4) return t.toFixed(0);
            const i = t.toPrecision(2);
            return i.indexOf(".0") === i.length - 2 ? i.slice(0, -1) : i;
          }
          function gh(t, e, n, i) {
            const { gl: r } = t;
            if (!e) return { [i]: "null", "Format ": "N/A" };
            let s,
              o,
              a,
              c = "NOT PROVIDED",
              h = 1,
              l = 0,
              u = 0;
            if (
              (n &&
                ((c = n.type),
                (h = n.size),
                (c = String(c).replace("Array", "")),
                (s = -1 !== c.indexOf("nt"))),
              e instanceof vr)
            ) {
              const t = e,
                { data: d, changed: f } = t.getDebugData();
              let p;
              return (
                (o = f ? "*" : ""),
                (a = d),
                (u = t.byteLength),
                (l = u / d.BYTES_PER_ELEMENT / h),
                n
                  ? (p = `${
                      n.divisor > 0 ? "I " : "P "
                    } ${l} (x${h}=${u} bytes ${nr(r, c)})`)
                  : ((s = !0), (p = `${u} bytes`)),
                { [i]: `${o}${ph(a, { size: h, isInteger: s })}`, "Format ": p }
              );
            }
            return (
              (a = e),
              (h = e.length),
              (c = String(e.constructor.name).replace("Array", "")),
              (s = -1 !== c.indexOf("nt")),
              {
                [i]: `${ph(a, { size: h, isInteger: s })} (constant)`,
                "Format ": `${h}x${c} (constant)`,
              }
            );
          }
          function mh(t, e) {
            const { type: n, size: i } = e,
              r = vs(n, i);
            return r ? `${t} (${r.name})` : t;
          }
          function bh({
            header: t = "Uniforms",
            program: e,
            uniforms: n,
            undefinedOnly: i = !1,
          }) {
            tr(e);
            const r = ".*Matrix",
              s = e._uniformSetters,
              o = {},
              a = Object.keys(s).sort();
            let c = 0;
            for (const e of a)
              e.match(".*_.*") ||
                e.match(r) ||
                (_h({
                  table: o,
                  header: t,
                  uniforms: n,
                  uniformName: e,
                  undefinedOnly: i,
                }) &&
                  c++);
            for (const e of a)
              e.match(r) &&
                _h({
                  table: o,
                  header: t,
                  uniforms: n,
                  uniformName: e,
                  undefinedOnly: i,
                }) &&
                c++;
            for (const e of a)
              o[e] ||
                (_h({
                  table: o,
                  header: t,
                  uniforms: n,
                  uniformName: e,
                  undefinedOnly: i,
                }) &&
                  c++);
            let h = 0;
            const l = {};
            if (!i)
              for (const e in n) {
                const i = n[e];
                o[e] || (h++, (l[e] = { Type: `NOT USED: ${i}`, [t]: ph(i) }));
              }
            return { table: o, count: c, unusedTable: l, unusedCount: h };
          }
          function _h({
            table: t,
            header: e,
            uniforms: n,
            uniformName: i,
            undefinedOnly: r,
          }) {
            const s = n[i],
              o = (function (t) {
                return null != t;
              })(s);
            return !(
              (r && o) ||
              ((t[i] = {
                [e]: o ? ph(s) : "N/A",
                "Uniform Type": o ? s : "NOT PROVIDED",
              }),
              0)
            );
          }
          function yh(t) {
            const { type: e, size: n } = t.accessor,
              i = vs(e, n);
            return i ? `${i.name} ${t.name}` : t.name;
          }
          const vh = {
            POSITION: "positions",
            NORMAL: "normals",
            COLOR_0: "colors",
            TEXCOORD_0: "texCoords",
            TEXCOORD_1: "texCoords1",
            TEXCOORD_2: "texCoords2",
          };
          function wh(t, e) {
            const { attributeMap: n = vh } = e || {};
            return (n && n[t]) || t;
          }
          function xh(t, e) {
            let n;
            switch (t) {
              case "texCoords":
              case "texCoord1":
              case "texCoord2":
              case "texCoord3":
                n = "uvs";
                break;
              case "vertices":
              case "positions":
              case "normals":
              case "pickingColors":
                n = "vectors";
            }
            switch (n) {
              case "vectors":
                e.size = e.size || 3;
                break;
              case "uvs":
                e.size = e.size || 2;
            }
            tr(Number.isFinite(e.size), `attribute ${t} needs size`);
          }
          const Eh = () => {},
            Ph = {};
          class Th {
            constructor(t, e = {}) {
              const { id: n = rr("model") } = e;
              tr(A(t)),
                (this.id = n),
                (this.gl = t),
                (this.id = e.id || rr("Model")),
                (this.lastLogTime = 0),
                (this.animated = !1),
                this.initialize(e);
            }
            initialize(t) {
              (this.props = {}),
                (this.programManager =
                  t.programManager || Ts.getDefaultProgramManager(this.gl)),
                (this._programManagerState = -1),
                (this._managedProgram = !1);
              const {
                program: e = null,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: h,
              } = t;
              (this.programProps = {
                program: e,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: h,
              }),
                (this.program = null),
                (this.vertexArray = null),
                (this._programDirty = !0),
                (this.userData = {}),
                (this.needsRedraw = !0),
                (this._attributes = {}),
                (this.attributes = {}),
                (this.uniforms = {}),
                (this.pickable = !0),
                this._checkProgram(),
                this.setUniforms(
                  Object.assign({}, this.getModuleUniforms(t.moduleSettings))
                ),
                (this.drawMode = void 0 !== t.drawMode ? t.drawMode : 4),
                (this.vertexCount = t.vertexCount || 0),
                (this.geometryBuffers = {}),
                (this.isInstanced =
                  t.isInstanced || t.instanced || t.instanceCount > 0),
                this._setModelProps(t),
                (this.geometry = {}),
                tr(
                  void 0 !== this.drawMode && Number.isFinite(this.vertexCount),
                  "Model needs drawMode and vertexCount"
                );
            }
            setProps(t) {
              this._setModelProps(t);
            }
            delete() {
              for (const t in this._attributes)
                this._attributes[t] !== this.attributes[t] &&
                  this._attributes[t].delete();
              this._managedProgram &&
                (this.programManager.release(this.program),
                (this._managedProgram = !1)),
                this.vertexArray.delete(),
                this._deleteGeometryBuffers();
            }
            getDrawMode() {
              return this.drawMode;
            }
            getVertexCount() {
              return this.vertexCount;
            }
            getInstanceCount() {
              return this.instanceCount;
            }
            getAttributes() {
              return this.attributes;
            }
            getProgram() {
              return this.program;
            }
            setProgram(t) {
              const {
                program: e,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: h,
              } = t;
              (this.programProps = {
                program: e,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: h,
              }),
                (this._programDirty = !0);
            }
            getUniforms() {
              return this.uniforms;
            }
            setDrawMode(t) {
              return (this.drawMode = t), this;
            }
            setVertexCount(t) {
              return tr(Number.isFinite(t)), (this.vertexCount = t), this;
            }
            setInstanceCount(t) {
              return tr(Number.isFinite(t)), (this.instanceCount = t), this;
            }
            setGeometry(t) {
              return (
                (this.drawMode = t.drawMode),
                (this.vertexCount = t.getVertexCount()),
                this._deleteGeometryBuffers(),
                (this.geometryBuffers = (function (t, e, n) {
                  const i = {};
                  let r = e.indices;
                  for (const n in e.attributes) {
                    const s = e.attributes[n],
                      o = wh(n, undefined);
                    if ("indices" === n) r = s;
                    else if (s.constant) i[o] = s.value;
                    else {
                      const e = s.value,
                        r = { ...s };
                      delete r.value, (i[o] = [new vr(t, e), r]), xh(n, r);
                    }
                  }
                  if (r) {
                    const e = r.value || r;
                    tr(
                      e instanceof Uint16Array || e instanceof Uint32Array,
                      'attribute array for "indices" must be of integer type'
                    );
                    const n = {
                      size: 1,
                      isIndexed: void 0 === r.isIndexed || r.isIndexed,
                    };
                    i.indices = [new vr(t, { data: e, target: 34963 }), n];
                  }
                  return i;
                })(this.gl, t)),
                this.vertexArray.setAttributes(this.geometryBuffers),
                this
              );
            }
            setAttributes(t = {}) {
              if (or(t)) return this;
              const e = {};
              for (const n in t) {
                const i = t[n];
                e[n] = i.getValue ? i.getValue() : i;
              }
              return this.vertexArray.setAttributes(e), this;
            }
            setUniforms(t = {}) {
              return Object.assign(this.uniforms, t), this;
            }
            getModuleUniforms(t) {
              this._checkProgram();
              const e = this.programManager.getUniforms(this.program);
              return e ? e(t) : {};
            }
            updateModuleSettings(t) {
              const e = this.getModuleUniforms(t || {});
              return this.setUniforms(e);
            }
            clear(t) {
              return Ir(this.program.gl, t), this;
            }
            draw(t = {}) {
              this._checkProgram();
              const {
                moduleSettings: e = null,
                framebuffer: n,
                uniforms: i = {},
                attributes: r = {},
                transformFeedback: s = this.transformFeedback,
                parameters: o = {},
                vertexArray: a = this.vertexArray,
              } = t;
              let c;
              this.setAttributes(r),
                this.updateModuleSettings(e),
                this.setUniforms(i),
                P.priority >= 2 && (c = this._logDrawCallStart(2));
              const h = this.vertexArray.getDrawParams(),
                {
                  isIndexed: l = h.isIndexed,
                  indexType: u = h.indexType,
                  indexOffset: d = h.indexOffset,
                  vertexArrayInstanced: f = h.isInstanced,
                } = this.props;
              f &&
                !this.isInstanced &&
                P.warn(
                  "Found instanced attributes on non-instanced model",
                  this.id
                )();
              const { isInstanced: p, instanceCount: g } = this,
                { onBeforeRender: m = Eh, onAfterRender: b = Eh } = this.props;
              m(), this.program.setUniforms(this.uniforms);
              const _ = this.program.draw(
                Object.assign(Ph, t, {
                  logPriority: c,
                  uniforms: null,
                  framebuffer: n,
                  parameters: o,
                  drawMode: this.getDrawMode(),
                  vertexCount: this.getVertexCount(),
                  vertexArray: a,
                  transformFeedback: s,
                  isIndexed: l,
                  indexType: u,
                  isInstanced: p,
                  instanceCount: g,
                  offset: l ? d : 0,
                })
              );
              return b(), P.priority >= 2 && this._logDrawCallEnd(c, a, n), _;
            }
            transform(t = {}) {
              const {
                discard: e = !0,
                feedbackBuffers: n,
                unbindModels: i = [],
              } = t;
              let { parameters: r } = t;
              n && this._setFeedbackBuffers(n),
                e && (r = Object.assign({}, r, { 35977: e })),
                i.forEach((t) => t.vertexArray.unbindBuffers());
              try {
                this.draw(Object.assign({}, t, { parameters: r }));
              } finally {
                i.forEach((t) => t.vertexArray.bindBuffers());
              }
              return this;
            }
            render(t = {}) {
              return (
                P.warn(
                  "Model.render() is deprecated. Use Model.setUniforms() and Model.draw()"
                )(),
                this.setUniforms(t).draw()
              );
            }
            _setModelProps(t) {
              Object.assign(this.props, t),
                "uniforms" in t && this.setUniforms(t.uniforms),
                "pickable" in t && (this.pickable = t.pickable),
                "instanceCount" in t && (this.instanceCount = t.instanceCount),
                "geometry" in t && this.setGeometry(t.geometry),
                "attributes" in t && this.setAttributes(t.attributes),
                "_feedbackBuffers" in t &&
                  this._setFeedbackBuffers(t._feedbackBuffers);
            }
            _checkProgram() {
              if (
                !this._programDirty &&
                this.programManager.stateHash === this._programManagerState
              )
                return;
              let { program: t } = this.programProps;
              if (t) this._managedProgram = !1;
              else {
                const {
                  vs: e,
                  fs: n,
                  modules: i,
                  inject: r,
                  defines: s,
                  varyings: o,
                  bufferMode: a,
                  transpileToGLSL100: c,
                } = this.programProps;
                (t = this.programManager.get({
                  vs: e,
                  fs: n,
                  modules: i,
                  inject: r,
                  defines: s,
                  varyings: o,
                  bufferMode: a,
                  transpileToGLSL100: c,
                })),
                  this.program &&
                    this._managedProgram &&
                    this.programManager.release(this.program),
                  (this._programManagerState = this.programManager.stateHash),
                  (this._managedProgram = !0);
              }
              tr(t instanceof Ps, "Model needs a program"),
                (this._programDirty = !1),
                t !== this.program &&
                  ((this.program = t),
                  this.vertexArray
                    ? this.vertexArray.setProps({
                        program: this.program,
                        attributes: this.vertexArray.attributes,
                      })
                    : (this.vertexArray = new fh(this.gl, {
                        program: this.program,
                      })),
                  this.setUniforms(
                    Object.assign({}, this.getModuleUniforms())
                  ));
            }
            _deleteGeometryBuffers() {
              for (const t in this.geometryBuffers) {
                const e = this.geometryBuffers[t][0] || this.geometryBuffers[t];
                e instanceof vr && e.delete();
              }
            }
            _setAnimationProps(t) {
              this.animated &&
                tr(t, "Model.draw(): animated uniforms but no animationProps");
            }
            _setFeedbackBuffers(t = {}) {
              if (or(t)) return this;
              const { gl: e } = this.program;
              return (
                (this.transformFeedback =
                  this.transformFeedback ||
                  new ih(e, { program: this.program })),
                this.transformFeedback.setBuffers(t),
                this
              );
            }
            _logDrawCallStart(t) {
              const e = t > 3 ? 0 : 1e4;
              if (!(Date.now() - this.lastLogTime < e))
                return (
                  (this.lastLogTime = Date.now()),
                  P.group(2, `>>> DRAWING MODEL ${this.id}`, {
                    collapsed: P.level <= 2,
                  })(),
                  t
                );
            }
            _logDrawCallEnd(t, e, n, i) {
              if (void 0 === t) return;
              const r = (function ({
                  vertexArray: t,
                  header: e = "Attributes",
                }) {
                  if (!t.configuration) return {};
                  const n = {};
                  t.elements &&
                    (n.ELEMENT_ARRAY_BUFFER = gh(t, t.elements, null, e));
                  const i = t.values;
                  for (const r in i) {
                    const s = t._getAttributeInfo(r);
                    if (s) {
                      let o = `${r}: ${s.name}`;
                      const a = t.accessors[s.location];
                      a && (o = `${r}: ${mh(s.name, a)}`),
                        (n[o] = gh(t, i[r], a, e));
                    }
                  }
                  return n;
                })({
                  vertexArray: e,
                  header: `${this.id} attributes`,
                  attributes: this._attributes,
                }),
                {
                  table: s,
                  unusedTable: o,
                  unusedCount: a,
                } = bh({
                  header: `${this.id} uniforms`,
                  program: this.program,
                  uniforms: Object.assign({}, this.program.uniforms, n),
                }),
                { table: c, count: h } = bh({
                  header: `${this.id} uniforms`,
                  program: this.program,
                  uniforms: Object.assign({}, this.program.uniforms, n),
                  undefinedOnly: !0,
                });
              h > 0 && P.log("MISSING UNIFORMS", Object.keys(c))(),
                a > 0 && P.log("UNUSED UNIFORMS", Object.keys(o))();
              const l = (function (t) {
                const e = {},
                  n = `Accessors for ${t.id}`;
                for (const i of t.attributeInfos)
                  i && (e[`in ${yh(i)}`] = { [n]: JSON.stringify(i.accessor) });
                for (const i of t.varyingInfos)
                  i &&
                    (e[`out ${yh(i)}`] = { [n]: JSON.stringify(i.accessor) });
                return e;
              })(this.vertexArray.configuration);
              P.table(t, r)(),
                P.table(t, s)(),
                P.table(t + 1, l)(),
                i && i.log({ logLevel: 2, message: `Rendered to ${i.id}` }),
                P.groupEnd(2, `>>> DRAWING MODEL ${this.id}`)();
            }
          }
          class Ah {
            static isSupported(t) {
              return S(t);
            }
            constructor(t, e = {}) {
              (this.gl = t),
                (this.model = null),
                (this.elementCount = 0),
                (this.bufferTransform = null),
                (this.textureTransform = null),
                (this.elementIDBuffer = null),
                this._initialize(e),
                Object.seal(this);
            }
            delete() {
              const {
                model: t,
                bufferTransform: e,
                textureTransform: n,
              } = this;
              t && t.delete(), e && e.delete(), n && n.delete();
            }
            run(t = {}) {
              const { clearRenderTarget: e = !0 } = t,
                n = this._updateDrawOptions(t);
              e && n.framebuffer && n.framebuffer.clear({ color: !0 }),
                this.model.transform(n);
            }
            swap() {
              let t = !1;
              const e = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const n of e) t = t || n.swap();
              tr(t, "Nothing to swap");
            }
            getBuffer(t = null) {
              return this.bufferTransform && this.bufferTransform.getBuffer(t);
            }
            getData(t = {}) {
              const e = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const n of e) {
                const e = n.getData(t);
                if (e) return e;
              }
              return null;
            }
            getFramebuffer() {
              return (
                this.textureTransform && this.textureTransform.getFramebuffer()
              );
            }
            update(t = {}) {
              "elementCount" in t && this.model.setVertexCount(t.elementCount);
              const e = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const n of e) n.update(t);
            }
            _initialize(t = {}) {
              const { gl: e } = this;
              this._buildResourceTransforms(e, t),
                (t = this._updateModelProps(t)),
                (this.model = new Th(
                  e,
                  Object.assign({}, t, {
                    fs: t.fs || nh({ version: sh(t.vs) }),
                    id: t.id || "transform-model",
                    drawMode: t.drawMode || 0,
                    vertexCount: t.elementCount,
                  })
                )),
                this.bufferTransform &&
                  this.bufferTransform.setupResources({ model: this.model });
            }
            _updateModelProps(t) {
              let e = Object.assign({}, t);
              const n = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const t of n) e = t.updateModelProps(e);
              return e;
            }
            _buildResourceTransforms(t, e) {
              (function (t) {
                return !(
                  or(t.feedbackBuffers) &&
                  or(t.feedbackMap) &&
                  !(t.varyings && t.varyings.length > 0)
                );
              })(e) && (this.bufferTransform = new rh(t, e)),
                (function (t) {
                  return !(
                    or(t._sourceTextures) &&
                    !t._targetTexture &&
                    !t._targetTextureVarying
                  );
                })(e) && (this.textureTransform = new ch(t, e)),
                tr(
                  this.bufferTransform || this.textureTransform,
                  "must provide source/feedback buffers or source/target textures"
                );
            }
            _updateDrawOptions(t) {
              let e = Object.assign({}, t);
              const n = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const t of n) e = Object.assign(e, t.getDrawOptions(e));
              return e;
            }
          }
          const Sh = {
            interpolation: class {
              constructor({ gl: t, attribute: e, timeline: n }) {
                (this.gl = t),
                  (this.type = "interpolation"),
                  (this.transition = new io(n)),
                  (this.attribute = e),
                  (this.attributeInTransition = new Qc(t, e.settings)),
                  (this.currentStartIndices = e.startIndices),
                  (this.currentLength = 0),
                  (this.transform = (function (t, e) {
                    const n = qc(e.size);
                    return new Ah(t, {
                      vs: "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n",
                      defines: { ATTRIBUTE_TYPE: n },
                      varyings: ["vCurrent"],
                    });
                  })(t, e));
                const i = { byteLength: 0, usage: 35050 };
                this.buffers = [new vr(t, i), new vr(t, i)];
              }
              get inProgress() {
                return this.transition.inProgress;
              }
              start(t, e) {
                if (t.duration <= 0) return void this.transition.cancel();
                const { gl: n, buffers: i, attribute: r } = this;
                Yc(i);
                const s = {
                  numInstances: e,
                  attribute: r,
                  fromLength: this.currentLength,
                  fromStartIndices: this.currentStartIndices,
                  getData: t.enter,
                };
                for (const t of i) Kc({ buffer: t, ...s });
                (this.currentStartIndices = r.startIndices),
                  (this.currentLength = Zc(r, e)),
                  this.attributeInTransition.update({
                    buffer: i[1],
                    value: r.value,
                  }),
                  this.transition.start(t),
                  this.transform.update({
                    elementCount: Math.floor(this.currentLength / r.size),
                    sourceBuffers: { aFrom: i[0], aTo: Xc(0, r) },
                    feedbackBuffers: { vCurrent: i[1] },
                  });
              }
              update() {
                const t = this.transition.update();
                if (t) {
                  const {
                      time: t,
                      settings: { duration: e, easing: n },
                    } = this.transition,
                    i = n(t / e);
                  this.transform.run({ uniforms: { time: i } });
                }
                return t;
              }
              cancel() {
                for (
                  this.transition.cancel(), this.transform.delete();
                  this.buffers.length;

                )
                  this.buffers.pop().delete();
              }
            },
            spring: class {
              constructor({ gl: t, attribute: e, timeline: n }) {
                (this.gl = t),
                  (this.type = "spring"),
                  (this.transition = new io(n)),
                  (this.attribute = e),
                  (this.attributeInTransition = new Qc(t, {
                    ...e.settings,
                    normalized: !1,
                  })),
                  (this.currentStartIndices = e.startIndices),
                  (this.currentLength = 0),
                  (this.texture = (function (t) {
                    return new Sr(t, {
                      data: new Uint8Array(4),
                      format: 6408,
                      type: 5121,
                      border: 0,
                      mipmaps: !1,
                      dataFormat: 6408,
                      width: 1,
                      height: 1,
                    });
                  })(t)),
                  (this.framebuffer = (function (t, e) {
                    return new Wr(t, {
                      id: "spring-transition-is-transitioning-framebuffer",
                      width: 1,
                      height: 1,
                      attachments: { 36064: e },
                    });
                  })(t, this.texture)),
                  (this.transform = (function (t, e, n) {
                    const i = qc(e.size);
                    return new Ah(t, {
                      framebuffer: n,
                      vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
                      fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
                      defines: { ATTRIBUTE_TYPE: i },
                      varyings: ["vNext"],
                    });
                  })(t, e, this.framebuffer));
                const i = { byteLength: 0, usage: 35050 };
                this.buffers = [new vr(t, i), new vr(t, i), new vr(t, i)];
              }
              get inProgress() {
                return this.transition.inProgress;
              }
              start(t, e) {
                const { gl: n, buffers: i, attribute: r } = this,
                  s = {
                    numInstances: e,
                    attribute: r,
                    fromLength: this.currentLength,
                    fromStartIndices: this.currentStartIndices,
                    getData: t.enter,
                  };
                for (const t of i) Kc({ buffer: t, ...s });
                (this.currentStartIndices = r.startIndices),
                  (this.currentLength = Zc(r, e)),
                  this.attributeInTransition.update({
                    buffer: i[1],
                    value: r.value,
                  }),
                  this.transition.start(t),
                  this.transform.update({
                    elementCount: Math.floor(this.currentLength / r.size),
                    sourceBuffers: { aTo: Xc(0, r) },
                  });
              }
              update() {
                const {
                  buffers: t,
                  transform: e,
                  framebuffer: n,
                  transition: i,
                } = this;
                return (
                  !!i.update() &&
                  (e.update({
                    sourceBuffers: { aPrev: t[0], aCur: t[1] },
                    feedbackBuffers: { vNext: t[2] },
                  }),
                  e.run({
                    framebuffer: n,
                    discard: !1,
                    clearRenderTarget: !0,
                    uniforms: {
                      stiffness: i.settings.stiffness,
                      damping: i.settings.damping,
                    },
                    parameters: {
                      depthTest: !1,
                      blend: !0,
                      viewport: [0, 0, 1, 1],
                      blendFunc: [1, 1],
                      blendEquation: [32776, 32776],
                    },
                  }),
                  Yc(t),
                  this.attributeInTransition.update({
                    buffer: t[1],
                    value: this.attribute.value,
                  }),
                  Br(n)[0] > 0 || i.end(),
                  !0)
                );
              }
              cancel() {
                for (
                  this.transition.cancel(), this.transform.delete();
                  this.buffers.length;

                )
                  this.buffers.pop().delete();
                this.texture.delete(),
                  (this.texture = null),
                  this.framebuffer.delete(),
                  (this.framebuffer = null);
              }
            },
          };
          class Mh {
            constructor(t, { id: e, timeline: n }) {
              (this.id = e),
                (this.gl = t),
                (this.timeline = n),
                (this.transitions = {}),
                (this.needsRedraw = !1),
                (this.numInstances = 1),
                (this.isSupported = Ah.isSupported(t));
            }
            finalize() {
              for (const t in this.transitions) this._removeTransition(t);
            }
            update({ attributes: t, transitions: e, numInstances: n }) {
              this.numInstances = n || 1;
              for (const n in t) {
                const i = t[n],
                  r = i.getTransitionSetting(e);
                r && this._updateAttribute(n, i, r);
              }
              for (const n in this.transitions) {
                const i = t[n];
                (i && i.getTransitionSetting(e)) || this._removeTransition(n);
              }
            }
            hasAttribute(t) {
              const e = this.transitions[t];
              return e && e.inProgress;
            }
            getAttributes() {
              const t = {};
              for (const e in this.transitions) {
                const n = this.transitions[e];
                n.inProgress && (t[e] = n.attributeInTransition);
              }
              return t;
            }
            run() {
              if (!this.isSupported || 0 === this.numInstances) return !1;
              for (const t in this.transitions)
                this.transitions[t].update() && (this.needsRedraw = !0);
              const t = this.needsRedraw;
              return (this.needsRedraw = !1), t;
            }
            _removeTransition(t) {
              this.transitions[t].cancel(), delete this.transitions[t];
            }
            _updateAttribute(t, e, n) {
              const i = this.transitions[t];
              let r = !i || i.type !== n.type;
              if (r) {
                if (!this.isSupported)
                  return void Et.warn(
                    "WebGL2 not supported by this browser. Transition for ".concat(
                      t,
                      " is disabled."
                    )
                  )();
                i && this._removeTransition(t);
                const s = Sh[n.type];
                s
                  ? (this.transitions[t] = new s({
                      attribute: e,
                      timeline: this.timeline,
                      gl: this.gl,
                    }))
                  : (Et.error(
                      "unsupported transition type '".concat(n.type, "'")
                    )(),
                    (r = !1));
              }
              (r || e.needsRedraw()) &&
                ((this.needsRedraw = !0),
                this.transitions[t].start(n, this.numInstances));
            }
          }
          const Ch = "attributeManager.invalidate";
          class Oh {
            constructor(
              t,
              { id: e = "attribute-manager", stats: n, timeline: i } = {}
            ) {
              (this.id = e),
                (this.gl = t),
                (this.attributes = {}),
                (this.updateTriggers = {}),
                (this.accessors = {}),
                (this.needsRedraw = !0),
                (this.userData = {}),
                (this.stats = n),
                (this.attributeTransitionManager = new Mh(t, {
                  id: "".concat(e, "-transitions"),
                  timeline: i,
                })),
                Object.seal(this);
            }
            finalize() {
              for (const t in this.attributes) this.attributes[t].delete();
              this.attributeTransitionManager.finalize();
            }
            getNeedsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this.needsRedraw;
              return (
                (this.needsRedraw = this.needsRedraw && !t.clearRedrawFlags),
                e && this.id
              );
            }
            setNeedsRedraw(t = !0) {
              return (this.needsRedraw = !0), this;
            }
            add(t, e) {
              this._add(t, e);
            }
            addInstanced(t, e) {
              this._add(t, e, { instanced: 1 });
            }
            remove(t) {
              for (let e = 0; e < t.length; e++) {
                const n = t[e];
                void 0 !== this.attributes[n] &&
                  (this.attributes[n].delete(), delete this.attributes[n]);
              }
            }
            invalidate(t, e) {
              const n = this._invalidateTrigger(t, e);
              Tt(Ch, this, t, n);
            }
            invalidateAll(t) {
              for (const e in this.attributes)
                this.attributes[e].setNeedsUpdate(e, t);
              Tt(Ch, this, "all");
            }
            update({
              data: t,
              numInstances: e,
              startIndices: n = null,
              transitions: i,
              props: r = {},
              buffers: s = {},
              context: o = {},
            } = {}) {
              let a = !1;
              Tt("attributeManager.updateStart", this),
                this.stats && this.stats.get("Update Attributes").timeStart();
              for (const i in this.attributes) {
                const c = this.attributes[i],
                  h = c.settings.accessor;
                (c.startIndices = n),
                  r[i] &&
                    Et.removed(
                      "props.".concat(i),
                      "data.attributes.".concat(i)
                    )(),
                  c.setExternalBuffer(s[i]) ||
                    c.setBinaryValue(s[h], t.startIndices) ||
                    (!s[h] && c.setConstantValue(r[h])) ||
                    (c.needsUpdate() &&
                      ((a = !0),
                      this._updateAttribute({
                        attribute: c,
                        numInstances: e,
                        data: t,
                        props: r,
                        context: o,
                      }))),
                  (this.needsRedraw |= c.needsRedraw());
              }
              a && Tt("attributeManager.updateEnd", this, e),
                this.stats && this.stats.get("Update Attributes").timeEnd(),
                this.attributeTransitionManager.update({
                  attributes: this.attributes,
                  numInstances: e,
                  transitions: i,
                });
            }
            updateTransition() {
              const { attributeTransitionManager: t } = this,
                e = t.run();
              return (this.needsRedraw = this.needsRedraw || e), e;
            }
            getAttributes() {
              return this.attributes;
            }
            getChangedAttributes(t = { clearChangedFlags: !1 }) {
              const { attributes: e, attributeTransitionManager: n } = this,
                i = { ...n.getAttributes() };
              for (const r in e) {
                const s = e[r];
                s.needsRedraw(t) && !n.hasAttribute(r) && (i[r] = s);
              }
              return i;
            }
            getShaderAttributes(t, e = {}) {
              t || (t = this.getAttributes());
              const n = {};
              for (const i in t)
                e[i] || Object.assign(n, t[i].getShaderAttributes());
              return n;
            }
            getAccessors() {
              return this.updateTriggers;
            }
            _add(t, e, n = {}) {
              e &&
                Et.warn(
                  "AttributeManager.add({updaters}) - updater map no longer supported"
                )();
              for (const e in t) {
                const i = t[e];
                this.attributes[e] = this._createAttribute(e, i, n);
              }
              this._mapUpdateTriggersToAttributes();
            }
            _createAttribute(t, e, n) {
              const i = {
                ...e,
                id: t,
                isIndexed: e.isIndexed || e.elements || !1,
                constant: e.constant || !1,
                size: (e.elements ? 1 : e.size) || 1,
                value: e.value || null,
                divisor: e.instanced || n.instanced ? 1 : e.divisor || 0,
              };
              return new Qc(this.gl, i);
            }
            _mapUpdateTriggersToAttributes() {
              const t = {};
              for (const e in this.attributes)
                this.attributes[e].getUpdateTriggers().forEach((n) => {
                  t[n] || (t[n] = []), t[n].push(e);
                });
              this.updateTriggers = t;
            }
            _invalidateTrigger(t, e) {
              const { attributes: n, updateTriggers: i } = this,
                r = i[t];
              return (
                r &&
                  r.forEach((t) => {
                    const i = n[t];
                    i && i.setNeedsUpdate(i.id, e);
                  }),
                r
              );
            }
            _updateAttribute(t) {
              const { attribute: e, numInstances: n } = t;
              Tt("attribute.updateStart", e),
                e.constant
                  ? e.setConstantValue(e.value)
                  : (e.allocate(n) && Tt("attribute.allocate", e, n),
                    e.updateBuffer(t) &&
                      ((this.needsRedraw = !0),
                      Tt("attribute.updateEnd", e, n)));
            }
          }
          const Lh = 1e-5;
          function Ih(t, e, n, i, r) {
            const s = e - t;
            return (n - e) * r + -s * i + s + e;
          }
          function Rh(t, e) {
            if (Array.isArray(t)) {
              let n = 0;
              for (let i = 0; i < t.length; i++) {
                const r = t[i] - e[i];
                n += r * r;
              }
              return Math.sqrt(n);
            }
            return Math.abs(t - e);
          }
          const kh = {
            interpolation: class extends io {
              get value() {
                return this._value;
              }
              _onUpdate() {
                const {
                    time: t,
                    settings: {
                      fromValue: e,
                      toValue: n,
                      duration: i,
                      easing: r,
                    },
                  } = this,
                  s = r(t / i);
                this._value = Qe(e, n, s);
              }
            },
            spring: class extends io {
              get value() {
                return this._currValue;
              }
              _onUpdate() {
                const {
                    fromValue: t,
                    toValue: e,
                    damping: n,
                    stiffness: i,
                  } = this.settings,
                  { _prevValue: r = t, _currValue: s = t } = this;
                let o = (function (t, e, n, i, r) {
                  if (Array.isArray(n)) {
                    const s = [];
                    for (let o = 0; o < n.length; o++)
                      s[o] = Ih(t[o], e[o], n[o], i, r);
                    return s;
                  }
                  return Ih(t, e, n, i, r);
                })(r, s, e, n, i);
                const a = Rh(o, e),
                  c = Rh(o, s);
                a < Lh && c < Lh && ((o = e), this.end()),
                  (this._prevValue = s),
                  (this._currValue = o);
              }
            },
          };
          class jh {
            constructor(t) {
              (this.transitions = new Map()), (this.timeline = t);
            }
            get active() {
              return this.transitions.size > 0;
            }
            add(t, e, n, i) {
              const { transitions: r } = this;
              if (r.has(t)) {
                const n = r.get(t),
                  { value: i = n.settings.fromValue } = n;
                (e = i), this.remove(t);
              }
              if (!(i = Hc(i))) return;
              const s = kh[i.type];
              if (!s)
                return void Et.error(
                  "unsupported transition type '".concat(i.type, "'")
                )();
              const o = new s(this.timeline);
              o.start({ ...i, fromValue: e, toValue: n }), r.set(t, o);
            }
            remove(t) {
              const { transitions: e } = this;
              e.has(t) && (e.get(t).cancel(), e.delete(t));
            }
            update() {
              const t = {};
              for (const [e, n] of this.transitions)
                n.update(), (t[e] = n.value), n.inProgress || this.remove(e);
              return t;
            }
            clear() {
              for (const t of this.transitions.keys()) this.remove(t);
            }
          }
          const { COMPONENT: Fh } = xt;
          function Bh(t, e) {
            if (!t.transitions) return null;
            const n = {},
              i = Uh(t);
            for (const r in t.transitions) {
              const s = i[r],
                o = s && s.type;
              ("number" === o || "color" === o || "array" === o) &&
                Nh(t[r], e[r], s) &&
                (n[r] = !0);
            }
            return n;
          }
          function Dh({
            newProps: t,
            oldProps: e,
            ignoreProps: n = {},
            propTypes: i = {},
            triggerName: r = "props",
          } = {}) {
            if (e === t) return null;
            if ("object" != typeof t || null === t)
              return "".concat(r, " changed shallowly");
            if ("object" != typeof e || null === e)
              return "".concat(r, " changed shallowly");
            for (const s of Object.keys(t))
              if (!(s in n)) {
                if (!(s in e)) return "".concat(r, ".").concat(s, " added");
                const n = Nh(t[s], e[s], i[s]);
                if (n) return "".concat(r, ".").concat(s, " ").concat(n);
              }
            for (const s of Object.keys(e))
              if (!(s in n)) {
                if (!(s in t)) return "".concat(r, ".").concat(s, " dropped");
                if (!Object.hasOwnProperty.call(t, s)) {
                  const n = Nh(t[s], e[s], i[s]);
                  if (n) return "".concat(r, ".").concat(s, " ").concat(n);
                }
              }
            return null;
          }
          function Nh(t, e, n) {
            let i = n && n.equal;
            return i && !i(t, e, n)
              ? "changed deeply"
              : i || ((i = t && e && t.equals), !i || i.call(t, e))
              ? i || e === t
                ? null
                : "changed shallowly"
              : "changed deeply";
          }
          function zh(t, e) {
            if (null === e) return "oldProps is null, initial diff";
            const n = e.extensions,
              { extensions: i } = t;
            if (i === n) return !1;
            if (i.length !== n.length) return !0;
            for (let t = 0; t < i.length; t++)
              if (!i[t].equals(n[t])) return !0;
            return !1;
          }
          function Vh(t, e, n) {
            let i = t.updateTriggers[n];
            i = null == i ? {} : i;
            let r = e.updateTriggers[n];
            return (
              (r = null == r ? {} : r),
              Dh({ oldProps: r, newProps: i, triggerName: n })
            );
          }
          function Uh(t) {
            const e = t[Fh],
              n = e && e.constructor;
            return n ? n._propTypes : {};
          }
          function Gh(t, e) {
            if (!e) return t;
            const n = { ...t, ...e };
            if (
              ("defines" in e && (n.defines = { ...t.defines, ...e.defines }),
              "modules" in e &&
                ((n.modules = (t.modules || []).concat(e.modules)),
                e.modules.some((t) => "project64" === t.name)))
            ) {
              const t = n.modules.findIndex((t) => "project32" === t.name);
              t >= 0 && n.modules.splice(t, 1);
            }
            if ("inject" in e)
              if (t.inject) {
                const i = { ...t.inject };
                for (const t in e.inject) i[t] = (i[t] || "") + e.inject[t];
                n.inject = i;
              } else n.inject = e.inject;
            return n;
          }
          function $h(t, e, n = !1) {
            const i = e.projectPosition(t);
            if (n && e instanceof to) {
              const [n, r, s = 0] = t,
                o = e.getDistanceScales([n, r]);
              i[2] = s * o.unitsPerMeter[2];
            }
            return i;
          }
          function Wh(
            t,
            {
              viewport: e,
              modelMatrix: n,
              coordinateSystem: i,
              coordinateOrigin: r,
              offsetMode: s,
            }
          ) {
            let [o, a, c = 0] = t;
            switch ((n && ([o, a, c] = In([], [o, a, c, 1], n)), i)) {
              case ci.LNGLAT:
                return $h([o, a, c], e, s);
              case ci.LNGLAT_OFFSETS:
                return $h([o + r[0], a + r[1], c + (r[2] || 0)], e, s);
              case ci.METER_OFFSETS:
                return $h(Zn(r, [o, a, c]), e, s);
              default:
                return e.isGeospatial
                  ? [o + r[0], a + r[1], c + r[2]]
                  : e.projectPosition([o, a, c]);
            }
          }
          const Hh = { 10241: 9987, 10240: 9729, 10242: 33071, 10243: 33071 },
            Xh = {},
            qh = {
              boolean: {
                validate: (t, e) => !0,
                equal: (t, e, n) => Boolean(t) === Boolean(e),
              },
              number: {
                validate: (t, e) =>
                  Number.isFinite(t) &&
                  (!("max" in e) || t <= e.max) &&
                  (!("min" in e) || t >= e.min),
              },
              color: {
                validate: (t, e) =>
                  (e.optional && !t) ||
                  (Qh(t) && (3 === t.length || 4 === t.length)),
                equal: (t, e, n) => Yh(t, e),
              },
              accessor: {
                validate(t, e) {
                  const n = Jh(t);
                  return "function" === n || n === Jh(e.value);
                },
                equal: (t, e, n) => "function" == typeof e || Yh(t, e),
              },
              array: {
                validate: (t, e) => (e.optional && !t) || Qh(t),
                equal: (t, e, n) => (n.compare ? Yh(t, e) : t === e),
              },
              function: {
                validate: (t, e) =>
                  (e.optional && !t) || "function" == typeof t,
                equal: (t, e, n) => !n.compare || t === e,
              },
              data: {
                transform: (t, e, n) => {
                  const { dataTransform: i } = n ? n.props : {};
                  return i && t ? i(t) : t;
                },
              },
              image: {
                transform: (t, e, n) =>
                  (function (t, e) {
                    const n = t.context && t.context.gl;
                    if (!n || !e) return null;
                    if (e instanceof Sr) return e;
                    e.constructor &&
                      "Object" !== e.constructor.name &&
                      (e = { data: e });
                    let i = null;
                    e.compressed &&
                      (i = { 10241: e.data.length > 1 ? 9985 : 9729 });
                    const r = new Sr(n, {
                      ...e,
                      parameters: { ...Hh, ...i, ...t.props.textureParameters },
                    });
                    return (Xh[r.id] = !0), r;
                  })(n, t),
                release: (t) => {
                  var e;
                  (e = t) &&
                    e instanceof Sr &&
                    Xh[e.id] &&
                    (e.delete(), delete Xh[e.id]);
                },
              },
            };
          function Yh(t, e) {
            if (t === e) return !0;
            if (!Qh(t) || !Qh(e)) return !1;
            const n = t.length;
            if (n !== e.length) return !1;
            for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1;
            return !0;
          }
          function Zh(t, e) {
            switch (Jh(e)) {
              case "object":
                return Kh(t, e);
              case "array":
                return Kh(t, { type: "array", value: e, compare: !1 });
              case "boolean":
                return Kh(t, { type: "boolean", value: e });
              case "number":
                return Kh(t, { type: "number", value: e });
              case "function":
                return Kh(t, { type: "function", value: e, compare: !0 });
              default:
                return { name: t, type: "unknown", value: e };
            }
          }
          function Kh(t, e) {
            return "type" in e
              ? { name: t, ...qh[e.type], ...e }
              : "value" in e
              ? { name: t, type: Jh(e.value), ...e }
              : { name: t, type: "object", value: e };
          }
          function Qh(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t);
          }
          function Jh(t) {
            return Qh(t) ? "array" : null === t ? "null" : typeof t;
          }
          const {
            COMPONENT: tl,
            ASYNC_ORIGINAL: el,
            ASYNC_RESOLVED: nl,
            ASYNC_DEFAULTS: il,
          } = xt;
          function rl() {
            const t = this,
              e = sl(t.constructor),
              n = Object.create(e);
            (n[tl] = t), (n[el] = {}), (n[nl] = {});
            for (let t = 0; t < arguments.length; ++t) {
              const e = arguments[t];
              for (const t in e) n[t] = e[t];
            }
            return Object.freeze(n), n;
          }
          function sl(t) {
            return (
              cl(t, "_mergedDefaultProps") ||
              ((function (t) {
                if (!t.prototype) return;
                const e = Object.getPrototypeOf(t),
                  n = sl(e),
                  i = (function (t) {
                    const e = {},
                      n = {},
                      i = {};
                    for (const [r, s] of Object.entries(t))
                      if (s && s.deprecatedFor)
                        i[r] = Array.isArray(s.deprecatedFor)
                          ? s.deprecatedFor
                          : [s.deprecatedFor];
                      else {
                        const t = Zh(r, s);
                        (e[r] = t), (n[r] = t.value);
                      }
                    return {
                      propTypes: e,
                      defaultProps: n,
                      deprecatedProps: i,
                    };
                  })(cl(t, "defaultProps") || {}),
                  r = (function (t, e, n) {
                    const i = Object.create(null);
                    Object.assign(i, e, t);
                    const r = (function (t) {
                      const e = cl(t, "layerName") || cl(t, "componentName");
                      return (
                        e ||
                          Et.once(
                            0,
                            "".concat(t.name, ".componentName not specified")
                          )(),
                        e || t.name
                      );
                    })(n);
                    return (
                      delete t.id,
                      Object.defineProperties(i, {
                        id: { writable: !0, value: r },
                      }),
                      i
                    );
                  })(i.defaultProps, n, t),
                  s = { ...e._propTypes, ...i.propTypes };
                !(function (t, e) {
                  const n = {},
                    i = {};
                  for (const t in e) {
                    const r = e[t],
                      { name: s, value: o } = r;
                    r.async && ((n[s] = o), (i[s] = ol(s)));
                  }
                  (t[il] = n), (t[el] = {}), Object.defineProperties(t, i);
                })(r, s);
                const o = { ...e._deprecatedProps, ...i.deprecatedProps };
                (function (t, e) {
                  for (const n in e)
                    Object.defineProperty(t, n, {
                      enumerable: !1,
                      set(t) {
                        const i = "".concat(this.id, ": ").concat(n);
                        for (const i of e[n]) al(this, i) || (this[i] = t);
                        Et.deprecated(i, e[n].join("/"))();
                      },
                    });
                })(r, o),
                  (t._mergedDefaultProps = r),
                  (t._propTypes = s),
                  (t._deprecatedProps = o);
              })(t),
              t._mergedDefaultProps)
            );
          }
          function ol(t) {
            return {
              enumerable: !0,
              set(e) {
                "string" == typeof e || e instanceof Promise || zc(e)
                  ? (this[el][t] = e)
                  : (this[nl][t] = e);
              },
              get() {
                if (this[nl]) {
                  if (t in this[nl]) return this[nl][t] || this[il][t];
                  if (t in this[el]) {
                    const e = this[tl] && this[tl].internalState;
                    if (e && e.hasAsyncProp(t))
                      return e.getAsyncProp(t) || this[il][t];
                  }
                }
                return this[il][t];
              },
            };
          }
          function al(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
          }
          function cl(t, e) {
            return al(t, e) && t[e];
          }
          const {
              ASYNC_ORIGINAL: hl,
              ASYNC_RESOLVED: ll,
              ASYNC_DEFAULTS: ul,
            } = xt,
            dl = Object.freeze({});
          class fl {
            constructor(t = null) {
              (this.component = t),
                (this.asyncProps = {}),
                (this.onAsyncPropUpdated = () => {}),
                (this.oldProps = dl),
                (this.oldAsyncProps = null);
            }
            finalize() {
              for (const t in this.asyncProps) {
                const e = this.asyncProps[t];
                e.type &&
                  e.type.release &&
                  e.type.release(e.resolvedValue, e.type, this.component);
              }
            }
            getOldProps() {
              return this.oldAsyncProps || this.oldProps;
            }
            resetOldProps() {
              (this.oldAsyncProps = null),
                (this.oldProps = this.component.props);
            }
            freezeAsyncOldProps() {
              if (!this.oldAsyncProps) {
                (this.oldProps = this.oldProps || this.component.props),
                  (this.oldAsyncProps = Object.create(this.oldProps));
                for (const t in this.asyncProps)
                  Object.defineProperty(this.oldAsyncProps, t, {
                    enumerable: !0,
                    value: this.oldProps[t],
                  });
              }
            }
            hasAsyncProp(t) {
              return t in this.asyncProps;
            }
            getAsyncProp(t) {
              const e = this.asyncProps[t];
              return e && e.resolvedValue;
            }
            isAsyncPropLoading(t) {
              if (t) {
                const e = this.asyncProps[t];
                return Boolean(
                  e &&
                    e.pendingLoadCount > 0 &&
                    e.pendingLoadCount !== e.resolvedLoadCount
                );
              }
              for (const t in this.asyncProps)
                if (this.isAsyncPropLoading(t)) return !0;
              return !1;
            }
            reloadAsyncProp(t, e) {
              this._watchPromise(t, Promise.resolve(e));
            }
            setAsyncProps(t) {
              const e = t[ll] || {},
                n = t[hl] || t,
                i = t[ul] || {};
              for (const t in e) {
                const n = e[t];
                this._createAsyncPropData(t, i[t]),
                  this._updateAsyncProp(t, n),
                  (e[t] = this.getAsyncProp(t));
              }
              for (const t in n) {
                const e = n[t];
                this._createAsyncPropData(t, i[t]), this._updateAsyncProp(t, e);
              }
            }
            _updateAsyncProp(t, e) {
              if (this._didAsyncInputValueChange(t, e)) {
                if ("string" == typeof e) {
                  var n;
                  const i =
                      null === (n = this.layer) || void 0 === n
                        ? void 0
                        : n.props.fetch,
                    r = e;
                  i && (e = i(r, { propName: t, layer: this.layer }));
                }
                e instanceof Promise
                  ? this._watchPromise(t, e)
                  : zc(e)
                  ? this._resolveAsyncIterable(t, e)
                  : this._setPropValue(t, e);
              }
            }
            _didAsyncInputValueChange(t, e) {
              const n = this.asyncProps[t];
              return (
                e !== n.resolvedValue &&
                e !== n.lastValue &&
                ((n.lastValue = e), !0)
              );
            }
            _setPropValue(t, e) {
              this.freezeAsyncOldProps();
              const n = this.asyncProps[t];
              (e = this._postProcessValue(n, e)),
                (n.resolvedValue = e),
                n.pendingLoadCount++,
                (n.resolvedLoadCount = n.pendingLoadCount);
            }
            _setAsyncPropValue(t, e, n) {
              const i = this.asyncProps[t];
              i &&
                n >= i.resolvedLoadCount &&
                void 0 !== e &&
                (this.freezeAsyncOldProps(),
                (i.resolvedValue = e),
                (i.resolvedLoadCount = n),
                this.onAsyncPropUpdated(t, e));
            }
            _watchPromise(t, e) {
              const n = this.asyncProps[t];
              n.pendingLoadCount++;
              const i = n.pendingLoadCount;
              e.then((e) => {
                var r;
                (e = this._postProcessValue(n, e)),
                  this._setAsyncPropValue(t, e, i);
                const s =
                  null === (r = this.layer) || void 0 === r
                    ? void 0
                    : r.props.onDataLoad;
                "data" === t && s && s(e, { propName: t, layer: this.layer });
              }).catch((e) => {
                var n;
                null === (n = this.layer) ||
                  void 0 === n ||
                  n.raiseError(
                    e,
                    "loading ".concat(t, " of ").concat(this.layer)
                  );
              });
            }
            async _resolveAsyncIterable(t, e) {
              var n;
              "data" !== t && this._setPropValue(t, e);
              const i = this.asyncProps[t];
              i.pendingLoadCount++;
              const r = i.pendingLoadCount;
              let s = [],
                o = 0;
              for await (const n of e) {
                const { dataTransform: e } = this.component
                  ? this.component.props
                  : {};
                (s = e ? e(n, s) : s.concat(n)),
                  Object.defineProperty(s, "__diff", {
                    enumerable: !1,
                    value: [{ startRow: o, endRow: s.length }],
                  }),
                  (o = s.length),
                  this._setAsyncPropValue(t, s, r);
              }
              const a =
                null === (n = this.layer) || void 0 === n
                  ? void 0
                  : n.props.onDataLoad;
              a && a(s, { propName: t, layer: this.layer });
            }
            _postProcessValue(t, e) {
              const n = t.type;
              return n &&
                (n.release && n.release(t.resolvedValue, n, this.component),
                n.transform)
                ? n.transform(e, n, this.component)
                : e;
            }
            _createAsyncPropData(t, e) {
              if (!this.asyncProps[t]) {
                const n =
                  this.component && this.component.constructor._propTypes;
                this.asyncProps[t] = {
                  type: n && n[t],
                  lastValue: null,
                  resolvedValue: e,
                  pendingLoadCount: 0,
                  resolvedLoadCount: 0,
                };
              }
            }
          }
          const {
            ASYNC_ORIGINAL: pl,
            ASYNC_RESOLVED: gl,
            ASYNC_DEFAULTS: ml,
          } = xt;
          let bl = 0;
          class _l {
            constructor() {
              (this.props = rl.apply(this, arguments)),
                (this.id = this.props.id),
                (this.count = bl++),
                (this.lifecycle = "Awaiting state"),
                (this.parent = null),
                (this.context = null),
                (this.state = null),
                (this.internalState = null),
                Object.seal(this);
            }
            get root() {
              let t = this;
              for (; t.parent; ) t = t.parent;
              return t;
            }
            clone(t) {
              const { props: e } = this,
                n = {};
              for (const t in e[ml])
                t in e[gl]
                  ? (n[t] = e[gl][t])
                  : t in e[pl] && (n[t] = e[pl][t]);
              return new this.constructor({ ...e, ...n, ...t });
            }
            get stats() {
              return this.internalState.stats;
            }
            _initState() {
              this.internalState = new fl({});
            }
          }
          (_l.componentName = "Component"), (_l.defaultProps = {});
          class yl extends fl {
            constructor({ attributeManager: t, layer: e }) {
              super(e),
                (this.attributeManager = t),
                (this.model = null),
                (this.needsRedraw = !0),
                (this.subLayers = null),
                (this.usesPickingColorCache = !1);
            }
            get layer() {
              return this.component;
            }
            set layer(t) {
              this.component = t;
            }
          }
          const vl = 2 ** 24 - 1,
            wl = Object.freeze([]),
            xl = Ls(({ oldViewport: t, viewport: e }) => t.equals(e));
          let El = new Uint8ClampedArray(0);
          const Pl = {
            data: { type: "data", value: wl, async: !0 },
            dataComparator: null,
            _dataDiff: {
              type: "function",
              value: (t) => t && t.__diff,
              compare: !1,
              optional: !0,
            },
            dataTransform: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDataLoad: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onError: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            fetch: {
              type: "function",
              value: (
                t,
                { propName: e, layer: n, loaders: i, loadOptions: r, signal: s }
              ) => {
                const { resourceManager: o } = n.context;
                var a;
                (r = r || n.getLoadOptions()),
                  (i = i || n.props.loaders),
                  s &&
                    (r = {
                      ...r,
                      fetch: {
                        ...(null === (a = r) || void 0 === a
                          ? void 0
                          : a.fetch),
                        signal: s,
                      },
                    });
                let c = o.contains(t);
                return (
                  c ||
                    r ||
                    (o.add({ resourceId: t, data: $e(t, i), persistent: !1 }),
                    (c = !0)),
                  c
                    ? o.subscribe({
                        resourceId: t,
                        onChange: (t) => n.internalState.reloadAsyncProp(e, t),
                        consumerId: n.id,
                        requestId: e,
                      })
                    : $e(t, i, r)
                );
              },
              compare: !1,
            },
            updateTriggers: {},
            visible: !0,
            pickable: !1,
            opacity: { type: "number", min: 0, max: 1, value: 1 },
            onHover: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onClick: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDragStart: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDrag: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDragEnd: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            coordinateSystem: ci.DEFAULT,
            coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
            modelMatrix: {
              type: "array",
              value: null,
              compare: !0,
              optional: !0,
            },
            wrapLongitude: !1,
            positionFormat: "XYZ",
            colorFormat: "RGBA",
            parameters: {},
            transitions: null,
            extensions: [],
            loaders: { type: "array", value: [], optional: !0, compare: !0 },
            getPolygonOffset: {
              type: "function",
              value: ({ layerIndex: t }) => [0, 100 * -t],
              compare: !1,
            },
            highlightedObjectIndex: -1,
            autoHighlight: !1,
            highlightColor: { type: "accessor", value: [0, 0, 128, 128] },
          };
          class Tl extends _l {
            toString() {
              const t = this.constructor.layerName || this.constructor.name;
              return "".concat(t, "({id: '").concat(this.props.id, "'})");
            }
            raiseError(t, e) {
              var n, i, r, s;
              e && (t.message = "".concat(e, ": ").concat(t.message)),
                (null === (n = (i = this.props).onError) || void 0 === n
                  ? void 0
                  : n.call(i, t)) ||
                  null === (r = this.context) ||
                  void 0 === r ||
                  null === (s = r.onError) ||
                  void 0 === s ||
                  s.call(r, t, this);
            }
            setState(t) {
              this.setChangeFlags({ stateChanged: !0 }),
                Object.assign(this.state, t),
                this.setNeedsRedraw();
            }
            setNeedsRedraw(t = !0) {
              this.internalState && (this.internalState.needsRedraw = t);
            }
            setNeedsUpdate() {
              this.context.layerManager.setNeedsUpdate(String(this)),
                (this.internalState.needsUpdate = !0);
            }
            getNeedsRedraw(t = { clearRedrawFlags: !1 }) {
              return this._getNeedsRedraw(t);
            }
            needsUpdate() {
              return (
                this.internalState.needsUpdate ||
                this.hasUniformTransition() ||
                this.shouldUpdateState(this._getUpdateParams())
              );
            }
            hasUniformTransition() {
              return this.internalState.uniformTransitions.active;
            }
            get isLoaded() {
              return (
                this.internalState && !this.internalState.isAsyncPropLoading()
              );
            }
            get wrapLongitude() {
              return this.props.wrapLongitude;
            }
            isPickable() {
              return this.props.pickable && this.props.visible;
            }
            getModels() {
              return (
                this.state &&
                (this.state.models ||
                  (this.state.model ? [this.state.model] : []))
              );
            }
            getAttributeManager() {
              return this.internalState && this.internalState.attributeManager;
            }
            getCurrentLayer() {
              return this.internalState && this.internalState.layer;
            }
            getLoadOptions() {
              return this.props.loadOptions;
            }
            project(t) {
              const { viewport: e } = this.context,
                n = Wh(t, {
                  viewport: e,
                  modelMatrix: this.props.modelMatrix,
                  coordinateOrigin: this.props.coordinateOrigin,
                  coordinateSystem: this.props.coordinateSystem,
                }),
                [i, r, s] = ei(n, e.pixelProjectionMatrix);
              return 2 === t.length ? [i, r] : [i, r, s];
            }
            unproject(t) {
              const { viewport: e } = this.context;
              return e.unproject(t);
            }
            projectPosition(t) {
              return (function (t, e) {
                const {
                    viewport: n,
                    coordinateSystem: i,
                    coordinateOrigin: r,
                    modelMatrix: s,
                    fromCoordinateSystem: o,
                    fromCoordinateOrigin: a,
                  } = (function (t) {
                    const e = { ...t };
                    let { coordinateSystem: n } = t;
                    const {
                      viewport: i,
                      coordinateOrigin: r,
                      fromCoordinateSystem: s,
                      fromCoordinateOrigin: o,
                    } = t;
                    return (
                      n === ci.DEFAULT &&
                        (n = i.isGeospatial ? ci.LNGLAT : ci.CARTESIAN),
                      void 0 === s && (e.fromCoordinateSystem = n),
                      void 0 === o && (e.fromCoordinateOrigin = r),
                      (e.coordinateSystem = n),
                      e
                    );
                  })(e),
                  {
                    geospatialOrigin: c,
                    shaderCoordinateOrigin: h,
                    offsetMode: l,
                  } = Ds(n, i, r),
                  u = Wh(t, {
                    viewport: n,
                    modelMatrix: s,
                    coordinateSystem: o,
                    coordinateOrigin: a,
                    offsetMode: l,
                  });
                l &&
                  (function (t, e, n) {
                    (t[0] = e[0] - n[0]),
                      (t[1] = e[1] - n[1]),
                      (t[2] = e[2] - n[2]);
                  })(u, u, n.projectPosition(c || h));
                return u;
              })(t, {
                viewport: this.context.viewport,
                modelMatrix: this.props.modelMatrix,
                coordinateOrigin: this.props.coordinateOrigin,
                coordinateSystem: this.props.coordinateSystem,
              });
            }
            use64bitPositions() {
              const { coordinateSystem: t } = this.props;
              return t === ci.DEFAULT || t === ci.LNGLAT || t === ci.CARTESIAN;
            }
            onHover(t, e) {
              return !!this.props.onHover && this.props.onHover(t, e);
            }
            onClick(t, e) {
              return !!this.props.onClick && this.props.onClick(t, e);
            }
            nullPickingColor() {
              return [0, 0, 0];
            }
            encodePickingColor(t, e = []) {
              return (
                (e[0] = (t + 1) & 255),
                (e[1] = ((t + 1) >> 8) & 255),
                (e[2] = (((t + 1) >> 8) >> 8) & 255),
                e
              );
            }
            decodePickingColor(t) {
              Ks(t instanceof Uint8Array);
              const [e, n, i] = t;
              return e + 256 * n + 65536 * i - 1;
            }
            initializeState() {
              throw new Error(
                "Layer ".concat(this, " has not defined initializeState")
              );
            }
            getShaders(t) {
              for (const e of this.props.extensions)
                t = Gh(t, e.getShaders.call(this, e));
              return t;
            }
            shouldUpdateState({
              oldProps: t,
              props: e,
              context: n,
              changeFlags: i,
            }) {
              return i.propsOrDataChanged;
            }
            updateState({ oldProps: t, props: e, context: n, changeFlags: i }) {
              const r = this.getAttributeManager();
              if (i.dataChanged && r) {
                const { dataChanged: t } = i;
                if (Array.isArray(t)) for (const e of t) r.invalidateAll(e);
                else r.invalidateAll();
              }
              const s = t.highlightedObjectIndex >= 0 || t.pickable,
                o = e.highlightedObjectIndex >= 0 || e.pickable;
              if (s !== o && r) {
                const { pickingColors: t, instancePickingColors: e } =
                    r.attributes,
                  n = t || e;
                n &&
                  (o && n.constant && ((n.constant = !1), r.invalidate(n.id)),
                  n.value || o || ((n.constant = !0), (n.value = [0, 0, 0])));
              }
            }
            finalizeState() {
              for (const t of this.getModels()) t.delete();
              const t = this.getAttributeManager();
              t && t.finalize(),
                this.context.resourceManager.unsubscribe({
                  consumerId: this.id,
                }),
                this.internalState.uniformTransitions.clear(),
                this.internalState.finalize();
            }
            draw(t) {
              for (const e of this.getModels()) e.draw(t);
            }
            getPickingInfo({ info: t, mode: e }) {
              const { index: n } = t;
              return (
                n >= 0 &&
                  Array.isArray(this.props.data) &&
                  (t.object = this.props.data[n]),
                t
              );
            }
            activateViewport(t) {
              const e = this.internalState.viewport;
              (this.internalState.viewport = t),
                (e && xl({ oldViewport: e, viewport: t })) ||
                  (this.setChangeFlags({ viewportChanged: !0 }),
                  this.isComposite
                    ? this.needsUpdate() && this.setNeedsUpdate()
                    : this._update());
            }
            invalidateAttribute(t = "all", e = "") {
              const n = this.getAttributeManager();
              n && ("all" === t ? n.invalidateAll() : n.invalidate(t));
            }
            updateAttributes(t) {
              for (const e of this.getModels()) this._setModelAttributes(e, t);
            }
            _updateAttributes(t) {
              const e = this.getAttributeManager();
              if (!e) return;
              const n = this.getNumInstances(t),
                i = this.getStartIndices(t);
              e.update({
                data: t.data,
                numInstances: n,
                startIndices: i,
                props: t,
                transitions: t.transitions,
                buffers: t.data.attributes,
                context: this,
                ignoreUnknownAttributes: !0,
              });
              const r = e.getChangedAttributes({ clearChangedFlags: !0 });
              this.updateAttributes(r);
            }
            _updateAttributeTransition() {
              const t = this.getAttributeManager();
              t && t.updateTransition();
            }
            _updateUniformTransition() {
              const { uniformTransitions: t } = this.internalState;
              if (t.active) {
                const e = t.update(),
                  n = Object.create(this.props);
                for (const t in e) Object.defineProperty(n, t, { value: e[t] });
                return n;
              }
              return this.props;
            }
            calculateInstancePickingColors(t, { numInstances: e }) {
              if (t.constant) return;
              const n = Math.floor(El.length / 3);
              if (((this.internalState.usesPickingColorCache = !0), n < e)) {
                e > vl &&
                  Et.warn(
                    "Layer has too many data objects. Picking might not be able to distinguish all objects."
                  )(),
                  (El = Xe.allocate(El, e, {
                    size: 3,
                    copy: !0,
                    maxCount: Math.max(e, vl),
                  }));
                const t = Math.floor(El.length / 3),
                  i = [];
                for (let e = n; e < t; e++)
                  this.encodePickingColor(e, i),
                    (El[3 * e + 0] = i[0]),
                    (El[3 * e + 1] = i[1]),
                    (El[3 * e + 2] = i[2]);
              }
              t.value = El.subarray(0, 3 * e);
            }
            _setModelAttributes(t, e) {
              const n = this.getAttributeManager(),
                i = t.userData.excludeAttributes || {},
                r = n.getShaderAttributes(e, i);
              t.setAttributes(r);
            }
            disablePickingIndex(t) {
              this._disablePickingIndex(t);
            }
            _disablePickingIndex(t) {
              const { pickingColors: e, instancePickingColors: n } =
                  this.getAttributeManager().attributes,
                i = e || n,
                r = i.getVertexOffset(t),
                s = i.getVertexOffset(t + 1);
              i.buffer.subData({ data: new Uint8Array(s - r), offset: r });
            }
            restorePickingColors() {
              const { pickingColors: t, instancePickingColors: e } =
                  this.getAttributeManager().attributes,
                n = t || e;
              this.internalState.usesPickingColorCache &&
                n.value.buffer !== El.buffer &&
                (n.value = El.subarray(0, n.value.length)),
                n.updateSubBuffer({ startOffset: 0 });
            }
            getNumInstances(t) {
              return void 0 !== (t = t || this.props).numInstances
                ? t.numInstances
                : this.state && void 0 !== this.state.numInstances
                ? this.state.numInstances
                : (function (t) {
                    if (null === (e = t) || "object" != typeof e)
                      throw new Error("count(): argument not an object");
                    var e;
                    if ("function" == typeof t.count) return t.count();
                    if (Number.isFinite(t.size)) return t.size;
                    if (Number.isFinite(t.length)) return t.length;
                    if (
                      (function (t) {
                        return (
                          null !== t &&
                          "object" == typeof t &&
                          t.constructor === Object
                        );
                      })(t)
                    )
                      return Object.keys(t).length;
                    throw new Error("count(): argument not a container");
                  })(t.data);
            }
            getStartIndices(t) {
              return void 0 !== (t = t || this.props).startIndices
                ? t.startIndices
                : this.state && this.state.startIndices
                ? this.state.startIndices
                : null;
            }
            _initialize() {
              Tt("layer.initialize", this),
                this._initState(),
                this.initializeState(this.context);
              for (const t of this.props.extensions)
                t.initializeState.call(this, this.context, t);
              this.setChangeFlags({
                dataChanged: !0,
                propsChanged: !0,
                viewportChanged: !0,
                extensionsChanged: !0,
              }),
                this._updateState();
            }
            _update() {
              const t = this.needsUpdate();
              Tt("layer.update", this, t), t && this._updateState();
            }
            _updateState() {
              const t = this.props,
                e = this.context.viewport,
                n = this._updateUniformTransition();
              (this.internalState.propsInTransition = n),
                (this.context.viewport = this.internalState.viewport || e),
                (this.props = n);
              try {
                const n = this._getUpdateParams(),
                  i = this.getModels();
                if (this.context.gl) this.updateState(n);
                else
                  try {
                    this.updateState(n);
                  } catch (t) {}
                for (const t of this.props.extensions)
                  t.updateState.call(this, n, t);
                const r = this.getModels()[0] !== i[0];
                this._updateModules(n, r),
                  this.isComposite
                    ? this._renderLayers(n)
                    : (this.setNeedsRedraw(),
                      this._updateAttributes(this.props),
                      this.state.model &&
                        this.state.model.setInstanceCount(
                          this.getNumInstances()
                        ));
              } finally {
                (this.context.viewport = e),
                  (this.props = t),
                  this.clearChangeFlags(),
                  (this.internalState.needsUpdate = !1),
                  this.internalState.resetOldProps();
              }
            }
            _finalize() {
              Tt("layer.finalize", this), this.finalizeState(this.context);
              for (const t of this.props.extensions)
                t.finalizeState.call(this, t);
            }
            drawLayer({
              moduleParameters: t = null,
              uniforms: e = {},
              parameters: n = {},
            }) {
              this._updateAttributeTransition();
              const i = this.props;
              this.props = this.internalState.propsInTransition || i;
              const { opacity: r } = this.props;
              e.opacity = Math.pow(r, 1 / 2.2);
              try {
                t && this.setModuleParameters(t);
                const { getPolygonOffset: r } = this.props,
                  s = (r && r(e)) || [0, 0];
                at(this.context.gl, { polygonOffset: s }),
                  ht(this.context.gl, n, () => {
                    const i = {
                      moduleParameters: t,
                      uniforms: e,
                      parameters: n,
                      context: this.context,
                    };
                    for (const t of this.props.extensions)
                      t.draw.call(this, i, t);
                    this.draw(i);
                  });
              } finally {
                this.props = i;
              }
            }
            getChangeFlags() {
              return this.internalState.changeFlags;
            }
            setChangeFlags(t) {
              const { changeFlags: e } = this.internalState;
              for (const n in t)
                if (t[n]) {
                  let i = !1;
                  "dataChanged" === n &&
                    Array.isArray(e[n]) &&
                    ((e[n] = Array.isArray(t[n]) ? e[n].concat(t[n]) : t[n]),
                    (i = !0)),
                    e[n] || ((e[n] = t[n]), (i = !0)),
                    i && Tt("layer.changeFlag", this, n, t);
                }
              const n =
                e.dataChanged ||
                e.updateTriggersChanged ||
                e.propsChanged ||
                e.extensionsChanged;
              (e.propsOrDataChanged = n),
                (e.somethingChanged = n || t.viewportChanged || t.stateChanged);
            }
            clearChangeFlags() {
              this.internalState.changeFlags = {
                dataChanged: !1,
                propsChanged: !1,
                updateTriggersChanged: !1,
                viewportChanged: !1,
                stateChanged: !1,
                extensionsChanged: !1,
                propsOrDataChanged: !1,
                somethingChanged: !1,
              };
            }
            diffProps(t, e) {
              const n = (function (t, e) {
                const n = Dh({
                    newProps: t,
                    oldProps: e,
                    propTypes: Uh(t),
                    ignoreProps: {
                      data: null,
                      updateTriggers: null,
                      extensions: null,
                      transitions: null,
                    },
                  }),
                  i = (function (t, e) {
                    if (null === e) return "oldProps is null, initial diff";
                    let n = null;
                    const { dataComparator: i, _dataDiff: r } = t;
                    return (
                      i
                        ? i(t.data, e.data) ||
                          (n = "Data comparator detected a change")
                        : t.data !== e.data &&
                          (n = "A new data container was supplied"),
                      n && r && (n = r(t.data, e.data) || n),
                      n
                    );
                  })(t, e);
                let r = !1;
                return (
                  i ||
                    (r = (function (t, e) {
                      if (null === e) return "oldProps is null, initial diff";
                      if ("all" in t.updateTriggers && Vh(t, e, "all"))
                        return { all: !0 };
                      const n = {};
                      let i = !1;
                      for (const r in t.updateTriggers)
                        "all" !== r && Vh(t, e, r) && ((n[r] = !0), (i = n));
                      return i;
                    })(t, e)),
                  {
                    dataChanged: i,
                    propsChanged: n,
                    updateTriggersChanged: r,
                    extensionsChanged: zh(t, e),
                    transitionsChanged: Bh(t, e),
                  }
                );
              })(t, e);
              if (n.updateTriggersChanged)
                for (const t in n.updateTriggersChanged)
                  n.updateTriggersChanged[t] && this.invalidateAttribute(t);
              if (n.transitionsChanged)
                for (const i in n.transitionsChanged)
                  this.internalState.uniformTransitions.add(
                    i,
                    e[i],
                    t[i],
                    t.transitions[i]
                  );
              return this.setChangeFlags(n);
            }
            validateProps() {
              !(function (t) {
                const e = Uh(t);
                for (const n in e) {
                  const i = e[n],
                    { validate: r } = i;
                  if (r && !r(t[n], i))
                    throw new Error(
                      "Invalid prop ".concat(n, ": ").concat(t[n])
                    );
                }
              })(this.props);
            }
            setModuleParameters(t) {
              for (const e of this.getModels()) e.updateModuleSettings(t);
            }
            updateAutoHighlight(t) {
              this.props.autoHighlight && this._updateAutoHighlight(t);
            }
            _updateAutoHighlight(t) {
              const e = { pickingSelectedColor: t.picked ? t.color : null },
                { highlightColor: n } = this.props;
              t.picked &&
                "function" == typeof n &&
                (e.pickingHighlightColor = n(t)),
                this.setModuleParameters(e),
                this.setNeedsRedraw();
            }
            _updateModules({ props: t, oldProps: e }, n) {
              const {
                autoHighlight: i,
                highlightedObjectIndex: r,
                highlightColor: s,
              } = t;
              if (
                n ||
                e.autoHighlight !== i ||
                e.highlightedObjectIndex !== r ||
                e.highlightColor !== s
              ) {
                const t = {};
                i || (t.pickingSelectedColor = null),
                  Array.isArray(s) && (t.pickingHighlightColor = s),
                  Number.isInteger(r) &&
                    (t.pickingSelectedColor =
                      r >= 0 ? this.encodePickingColor(r) : null),
                  this.setModuleParameters(t);
              }
            }
            _getUpdateParams() {
              return {
                props: this.props,
                oldProps: this.internalState.getOldProps(),
                context: this.context,
                changeFlags: this.internalState.changeFlags,
              };
            }
            _getNeedsRedraw(t) {
              if (!this.internalState) return !1;
              let e = !1;
              (e = e || (this.internalState.needsRedraw && this.id)),
                (this.internalState.needsRedraw =
                  this.internalState.needsRedraw && !t.clearRedrawFlags);
              const n = this.getAttributeManager(),
                i = n && n.getNeedsRedraw(t);
              return (e = e || i), e;
            }
            _getAttributeManager() {
              return new Oh(this.context.gl, {
                id: this.props.id,
                stats: this.context.stats,
                timeline: this.context.timeline,
              });
            }
            _initState() {
              Ks(!this.internalState && !this.state),
                Ks(isFinite(this.props.coordinateSystem));
              const t = this._getAttributeManager();
              t &&
                t.addInstanced({
                  instancePickingColors: {
                    type: 5121,
                    size: 3,
                    noAlloc: !0,
                    update: this.calculateInstancePickingColors,
                  },
                }),
                (this.internalState = new yl({
                  attributeManager: t,
                  layer: this,
                })),
                this.clearChangeFlags(),
                (this.state = {}),
                Object.defineProperty(this.state, "attributeManager", {
                  get: () => (
                    Et.deprecated(
                      "layer.state.attributeManager",
                      "layer.getAttributeManager()"
                    ),
                    t
                  ),
                }),
                (this.internalState.layer = this),
                (this.internalState.uniformTransitions = new jh(
                  this.context.timeline
                )),
                (this.internalState.onAsyncPropUpdated =
                  this._onAsyncPropUpdated.bind(this)),
                this.internalState.setAsyncProps(this.props);
            }
            _transferState(t) {
              Tt("layer.matched", this, this === t);
              const { state: e, internalState: n } = t;
              this !== t &&
                ((this.internalState = n),
                (this.internalState.layer = this),
                (this.state = e),
                this.internalState.setAsyncProps(this.props),
                this.diffProps(this.props, this.internalState.getOldProps()));
            }
            _onAsyncPropUpdated() {
              this.diffProps(this.props, this.internalState.getOldProps()),
                this.setNeedsUpdate();
            }
          }
          (Tl.layerName = "Layer"), (Tl.defaultProps = Pl);
          const Al = {
              name: "project32",
              dependencies: [zs],
              vs: "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    mat3 rotation = project_get_orientation_matrix(projectedPosition);\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n",
            },
            Sl = {
              pickingSelectedColor: null,
              pickingHighlightColor: new Uint8Array([0, 255, 255, 255]),
              pickingActive: !1,
              pickingAttribute: !1,
            },
            Ml = {
              inject: {
                "vs:DECKGL_FILTER_COLOR":
                  "\n  picking_setPickingColor(geometry.pickingColor);\n  // for picking depth values\n  picking_setPickingAttribute(geometry.position.z);\n  ",
                "fs:DECKGL_FILTER_COLOR": {
                  order: 99,
                  injection:
                    "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    ",
                },
              },
              name: "picking",
              vs: "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",
              fs: "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",
              getUniforms: function (t = Sl) {
                const e = {};
                if (void 0 !== t.pickingSelectedColor)
                  if (t.pickingSelectedColor) {
                    const n = t.pickingSelectedColor.slice(0, 3);
                    (e.picking_uSelectedColorValid = 1),
                      (e.picking_uSelectedColor = n);
                  } else e.picking_uSelectedColorValid = 0;
                if (t.pickingHighlightColor) {
                  const n = Array.from(t.pickingHighlightColor, (t) => t / 255);
                  Number.isFinite(n[3]) || (n[3] = 1),
                    (e.picking_uHighlightColor = n);
                }
                return (
                  void 0 !== t.pickingActive &&
                    ((e.picking_uActive = Boolean(t.pickingActive)),
                    (e.picking_uAttribute = Boolean(t.pickingAttribute))),
                  e
                );
              },
            },
            Cl = {
              POINTS: 0,
              LINES: 1,
              LINE_LOOP: 2,
              LINE_STRIP: 3,
              TRIANGLES: 4,
              TRIANGLE_STRIP: 5,
              TRIANGLE_FAN: 6,
            };
          class Ol {
            static get DRAW_MODE() {
              return Cl;
            }
            constructor(t = {}) {
              const {
                id: e = rr("geometry"),
                drawMode: n = Cl.TRIANGLES,
                attributes: i = {},
                indices: r = null,
                vertexCount: s = null,
              } = t;
              (this.id = e),
                (this.drawMode = 0 | n),
                (this.attributes = {}),
                (this.userData = {}),
                this._setAttributes(i, r),
                (this.vertexCount =
                  s ||
                  this._calculateVertexCount(this.attributes, this.indices));
            }
            get mode() {
              return this.drawMode;
            }
            getVertexCount() {
              return this.vertexCount;
            }
            getAttributes() {
              return this.indices
                ? { indices: this.indices, ...this.attributes }
                : this.attributes;
            }
            _print(t) {
              return `Geometry ${this.id} attribute ${t}`;
            }
            _setAttributes(t, e) {
              e &&
                (this.indices = ArrayBuffer.isView(e)
                  ? { value: e, size: 1 }
                  : e);
              for (const e in t) {
                let n = t[e];
                (n = ArrayBuffer.isView(n) ? { value: n } : n),
                  tr(
                    ArrayBuffer.isView(n.value),
                    `${this._print(
                      e
                    )}: must be typed array or object with value as typed array`
                  ),
                  ("POSITION" !== e && "positions" !== e) ||
                    n.size ||
                    (n.size = 3),
                  "indices" === e
                    ? (tr(!this.indices), (this.indices = n))
                    : (this.attributes[e] = n);
              }
              return (
                this.indices &&
                  void 0 !== this.indices.isIndexed &&
                  ((this.indices = Object.assign({}, this.indices)),
                  delete this.indices.isIndexed),
                this
              );
            }
            _calculateVertexCount(t, e) {
              if (e) return e.value.length;
              let n = 1 / 0;
              for (const e in t) {
                const i = t[e],
                  { value: r, size: s, constant: o } = i;
                !o && r && s >= 1 && (n = Math.min(n, r.length / s));
              }
              return tr(Number.isFinite(n)), n;
            }
          }
          function Ll(t, e, n, i, r = []) {
            let s, o;
            if (8 & n) (s = (i[3] - t[1]) / (e[1] - t[1])), (o = 3);
            else if (4 & n) (s = (i[1] - t[1]) / (e[1] - t[1])), (o = 1);
            else if (2 & n) (s = (i[2] - t[0]) / (e[0] - t[0])), (o = 2);
            else {
              if (!(1 & n)) return null;
              (s = (i[0] - t[0]) / (e[0] - t[0])), (o = 0);
            }
            for (let n = 0; n < t.length; n++)
              r[n] = (1 & o) === n ? i[o] : s * (e[n] - t[n]) + t[n];
            return r;
          }
          function Il(t, e) {
            let n = 0;
            return (
              t[0] < e[0] ? (n |= 1) : t[0] > e[2] && (n |= 2),
              t[1] < e[1] ? (n |= 4) : t[1] > e[3] && (n |= 8),
              n
            );
          }
          function Rl(t, e) {
            const n = e.length,
              i = t.length;
            if (i > 0) {
              let r = !0;
              for (let s = 0; s < n; s++)
                if (t[i - n + s] !== e[s]) {
                  r = !1;
                  break;
                }
              if (r) return !1;
            }
            for (let r = 0; r < n; r++) t[i + r] = e[r];
            return !0;
          }
          function kl(t, e) {
            const n = e.length;
            for (let i = 0; i < n; i++) t[i] = e[i];
          }
          function jl(t, e, n, i, r = []) {
            const s = i + e * n;
            for (let e = 0; e < n; e++) r[e] = t[s + e];
            return r;
          }
          function Fl(t, e = {}) {
            const {
                size: n = 2,
                broken: i = !1,
                gridResolution: r = 10,
                gridOffset: s = [0, 0],
                startIndex: o = 0,
                endIndex: a = t.length,
              } = e,
              c = (a - o) / n;
            let h = [];
            const l = [h],
              u = jl(t, 0, n, o);
            let d, f;
            const p = (function (t, e, n, i) {
                const r = Math.floor((t[0] - n[0]) / e) * e + n[0],
                  s = Math.floor((t[1] - n[1]) / e) * e + n[1];
                return (
                  (i[0] = r), (i[1] = s), (i[2] = r + e), (i[3] = s + e), i
                );
              })(u, r, s, []),
              g = [];
            Rl(h, u);
            for (let e = 1; e < c; e++) {
              for (d = jl(t, e, n, o, d), f = Il(d, p); f; ) {
                Ll(u, d, f, p, g);
                const t = Il(g, p);
                t && (Ll(u, g, t, p, g), (f = t)),
                  Rl(h, g),
                  kl(u, g),
                  Bl(p, r, f),
                  i && h.length > n && ((h = []), l.push(h), Rl(h, u)),
                  (f = Il(d, p));
              }
              Rl(h, d), kl(u, d);
            }
            return i ? l : l[0];
          }
          function Bl(t, e, n) {
            8 & n
              ? ((t[1] += e), (t[3] += e))
              : 4 & n
              ? ((t[1] -= e), (t[3] -= e))
              : 2 & n
              ? ((t[0] += e), (t[2] += e))
              : 1 & n && ((t[0] -= e), (t[2] -= e));
          }
          function Dl(t, e) {
            let n;
            const i = t.length / e;
            for (
              let r = 0;
              r < i && ((n = t[r * e]), (n + 180) % 360 == 0);
              r++
            );
            const r = 360 * -Math.round(n / 360);
            if (0 !== r) for (let n = 0; n < i; n++) t[n * e] += r;
          }
          function Nl(t, e, n, i) {
            let r = t;
            if (Array.isArray(t[0])) {
              const n = t.length * e;
              r = new Array(n);
              for (let n = 0; n < t.length; n++)
                for (let i = 0; i < e; i++) r[n * e + i] = t[n][i] || 0;
            }
            return n
              ? Fl(r, { size: e, gridResolution: n })
              : i
              ? (function (t, e = {}) {
                  const {
                      size: n = 2,
                      startIndex: i = 0,
                      endIndex: r = t.length,
                      normalize: s = !0,
                    } = e,
                    o = t.slice(i, r);
                  !(function (t, e, n, i) {
                    let r,
                      s = t[0];
                    for (let o = n; o < i; o += e) {
                      r = t[o];
                      const e = r - s;
                      (e > 180 || e < -180) && (r -= 360 * Math.round(e / 360)),
                        (t[o] = s = r);
                    }
                  })(o, n, 0, r - i);
                  const a = Fl(o, {
                    size: n,
                    broken: !0,
                    gridResolution: 360,
                    gridOffset: [-180, -180],
                  });
                  if (s) for (const t of a) Dl(t, n);
                  return a;
                })(r, { size: e })
              : r;
          }
          class zl extends class {
            constructor(t = {}) {
              const { attributes: e = {} } = t;
              (this.typedArrayManager = Xe),
                (this.indexStarts = null),
                (this.vertexStarts = null),
                (this.vertexCount = 0),
                (this.instanceCount = 0),
                (this.attributes = {}),
                (this._attributeDefs = e),
                (this.opts = t),
                this.updateGeometry(t),
                Object.seal(this);
            }
            updateGeometry(t) {
              Object.assign(this.opts, t);
              const {
                data: e,
                buffers: n = {},
                getGeometry: i,
                geometryBuffer: r,
                positionFormat: s,
                dataChanged: o,
                normalize: a = !0,
              } = this.opts;
              if (
                ((this.data = e),
                (this.getGeometry = i),
                (this.positionSize = (r && r.size) || ("XY" === s ? 2 : 3)),
                (this.buffers = n),
                (this.normalize = a),
                r &&
                  (Ks(e.startIndices),
                  (this.getGeometry = this.getGeometryFromBuffer(r)),
                  a || (n.positions = r)),
                (this.geometryBuffer = n.positions),
                Array.isArray(o))
              )
                for (const t of o) this._rebuildGeometry(t);
              else this._rebuildGeometry();
            }
            updatePartialGeometry({ startRow: t, endRow: e }) {
              this._rebuildGeometry({ startRow: t, endRow: e });
            }
            normalizeGeometry(t) {
              return t;
            }
            updateGeometryAttributes(t, e, n) {
              throw new Error("Not implemented");
            }
            getGeometrySize(t) {
              throw new Error("Not implemented");
            }
            getGeometryFromBuffer(t) {
              const e = t.value || t;
              return (
                Ks(ArrayBuffer.isView(e)),
                Vc(e, {
                  size: this.positionSize,
                  offset: t.offset,
                  stride: t.stride,
                  startIndices: this.data.startIndices,
                })
              );
            }
            _allocate(t, e) {
              const {
                attributes: n,
                buffers: i,
                _attributeDefs: r,
                typedArrayManager: s,
              } = this;
              for (const o in r)
                if (o in i) s.release(n[o]), (n[o] = null);
                else {
                  const i = r[o];
                  (i.copy = e), (n[o] = s.allocate(n[o], t, i));
                }
            }
            _forEachGeometry(t, e, n) {
              const { data: i, getGeometry: r } = this,
                { iterable: s, objectInfo: o } = Nc(i, e, n);
              for (const e of s) o.index++, t(r(e, o), o.index);
            }
            _rebuildGeometry(t) {
              if (!this.data || !this.getGeometry) return;
              let { indexStarts: e, vertexStarts: n, instanceCount: i } = this;
              const { data: r, geometryBuffer: s } = this,
                { startRow: o = 0, endRow: a = 1 / 0 } = t || {},
                c = {};
              if ((t || ((e = [0]), (n = [0])), this.normalize || !s))
                this._forEachGeometry(
                  (t, e) => {
                    (t = this.normalizeGeometry(t)),
                      (c[e] = t),
                      (n[e + 1] = n[e] + this.getGeometrySize(t));
                  },
                  o,
                  a
                ),
                  (i = n[n.length - 1]);
              else if (s.buffer instanceof vr) {
                const t = s.stride || 4 * this.positionSize;
                (n = r.startIndices),
                  (i = n[r.length] || s.buffer.byteLength / t);
              } else {
                const t = s.value || s,
                  e = s.stride / t.BYTES_PER_ELEMENT || this.positionSize;
                (n = r.startIndices), (i = n[r.length] || t.length / e);
              }
              this._allocate(i, Boolean(t)),
                (this.indexStarts = e),
                (this.vertexStarts = n),
                (this.instanceCount = i);
              const h = {};
              this._forEachGeometry(
                (t, r) => {
                  (t = c[r] || t),
                    (h.vertexStart = n[r]),
                    (h.indexStart = e[r]);
                  const s = r < n.length - 1 ? n[r + 1] : i;
                  (h.geometrySize = s - n[r]),
                    (h.geometryIndex = r),
                    this.updateGeometryAttributes(t, h);
                },
                o,
                a
              ),
                (this.vertexCount = e[e.length - 1]);
            }
          } {
            constructor(t) {
              super({
                ...t,
                attributes: {
                  positions: {
                    size: 3,
                    padding: 18,
                    initialize: !0,
                    type: t.fp64 ? Float64Array : Float32Array,
                  },
                  segmentTypes: { size: 1, type: Uint8ClampedArray },
                },
              });
            }
            getGeometryFromBuffer(t) {
              return this.normalize
                ? super.getGeometryFromBuffer(t)
                : () => null;
            }
            normalizeGeometry(t) {
              return this.normalize
                ? Nl(
                    t,
                    this.positionSize,
                    this.opts.resolution,
                    this.opts.wrapLongitude
                  )
                : t;
            }
            get(t) {
              return this.attributes[t];
            }
            getGeometrySize(t) {
              if (Array.isArray(t[0])) {
                let e = 0;
                for (const n of t) e += this.getGeometrySize(n);
                return e;
              }
              const e = this.getPathLength(t);
              return e < 2 ? 0 : this.isClosed(t) ? (e < 3 ? 0 : e + 2) : e;
            }
            updateGeometryAttributes(t, e) {
              if (0 !== e.geometrySize)
                if (t && Array.isArray(t[0]))
                  for (const n of t) {
                    const t = this.getGeometrySize(n);
                    (e.geometrySize = t),
                      this.updateGeometryAttributes(n, e),
                      (e.vertexStart += t);
                  }
                else
                  this._updateSegmentTypes(t, e), this._updatePositions(t, e);
            }
            _updateSegmentTypes(t, e) {
              const { segmentTypes: n } = this.attributes,
                i = this.isClosed(t),
                { vertexStart: r, geometrySize: s } = e;
              n.fill(0, r, r + s),
                i
                  ? ((n[r] = 4), (n[r + s - 2] = 4))
                  : ((n[r] += 1), (n[r + s - 2] += 2)),
                (n[r + s - 1] = 4);
            }
            _updatePositions(t, e) {
              const { positions: n } = this.attributes;
              if (!n) return;
              const { vertexStart: i, geometrySize: r } = e,
                s = new Array(3);
              for (let e = i, o = 0; o < r; e++, o++)
                this.getPointOnPath(t, o, s),
                  (n[3 * e] = s[0]),
                  (n[3 * e + 1] = s[1]),
                  (n[3 * e + 2] = s[2]);
            }
            getPathLength(t) {
              return t.length / this.positionSize;
            }
            getPointOnPath(t, e, n = []) {
              const { positionSize: i } = this;
              e * i >= t.length && (e += 1 - t.length / i);
              const r = e * i;
              return (
                (n[0] = t[r]),
                (n[1] = t[r + 1]),
                (n[2] = (3 === i && t[r + 2]) || 0),
                n
              );
            }
            isClosed(t) {
              if (!this.normalize) return this.opts.loop;
              const { positionSize: e } = this,
                n = t.length - e;
              return (
                t[0] === t[n] &&
                t[1] === t[n + 1] &&
                (2 === e || t[2] === t[n + 2])
              );
            }
          }
          const Vl = [0, 0, 0, 255],
            Ul = {
              widthUnits: "meters",
              widthScale: { type: "number", min: 0, value: 1 },
              widthMinPixels: { type: "number", min: 0, value: 0 },
              widthMaxPixels: {
                type: "number",
                min: 0,
                value: Number.MAX_SAFE_INTEGER,
              },
              jointRounded: !1,
              capRounded: !1,
              miterLimit: { type: "number", min: 0, value: 4 },
              billboard: !1,
              _pathType: null,
              getPath: { type: "accessor", value: (t) => t.path },
              getColor: { type: "accessor", value: Vl },
              getWidth: { type: "accessor", value: 1 },
              rounded: { deprecatedFor: ["jointRounded", "capRounded"] },
            },
            Gl = {
              enter: (t, e) => (e.length ? e.subarray(e.length - t.length) : t),
            };
          class $l extends Tl {
            getShaders() {
              return super.getShaders({
                vs: "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
                fs: "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                modules: [Al, Ml],
              });
            }
            get wrapLongitude() {
              return !1;
            }
            initializeState() {
              this.getAttributeManager().addInstanced({
                positions: {
                  size: 3,
                  vertexOffset: 1,
                  type: 5130,
                  fp64: this.use64bitPositions(),
                  transition: Gl,
                  accessor: "getPath",
                  update: this.calculatePositions,
                  noAlloc: !0,
                  shaderAttributes: {
                    instanceLeftPositions: { vertexOffset: 0 },
                    instanceStartPositions: { vertexOffset: 1 },
                    instanceEndPositions: { vertexOffset: 2 },
                    instanceRightPositions: { vertexOffset: 3 },
                  },
                },
                instanceTypes: {
                  size: 1,
                  type: 5121,
                  update: this.calculateSegmentTypes,
                  noAlloc: !0,
                },
                instanceStrokeWidths: {
                  size: 1,
                  accessor: "getWidth",
                  transition: Gl,
                  defaultValue: 1,
                },
                instanceColors: {
                  size: this.props.colorFormat.length,
                  type: 5121,
                  normalized: !0,
                  accessor: "getColor",
                  transition: Gl,
                  defaultValue: Vl,
                },
                instancePickingColors: {
                  size: 3,
                  type: 5121,
                  accessor: (t, { index: e, target: n }) =>
                    this.encodePickingColor(
                      t && t.__source ? t.__source.index : e,
                      n
                    ),
                },
              }),
                this.setState({
                  pathTesselator: new zl({ fp64: this.use64bitPositions() }),
                }),
                this.props.getDashArray &&
                  !this.props.extensions.length &&
                  Et.removed("getDashArray", "PathStyleExtension")();
            }
            updateState({ oldProps: t, props: e, changeFlags: n }) {
              super.updateState({ props: e, oldProps: t, changeFlags: n });
              const i = this.getAttributeManager();
              if (
                n.dataChanged ||
                (n.updateTriggersChanged &&
                  (n.updateTriggersChanged.all ||
                    n.updateTriggersChanged.getPath))
              ) {
                const { pathTesselator: t } = this.state,
                  r = e.data.attributes || {};
                t.updateGeometry({
                  data: e.data,
                  geometryBuffer: r.getPath,
                  buffers: r,
                  normalize: !e._pathType,
                  loop: "loop" === e._pathType,
                  getGeometry: e.getPath,
                  positionFormat: e.positionFormat,
                  wrapLongitude: e.wrapLongitude,
                  resolution: this.context.viewport.resolution,
                  dataChanged: n.dataChanged,
                }),
                  this.setState({
                    numInstances: t.instanceCount,
                    startIndices: t.vertexStarts,
                  }),
                  n.dataChanged || i.invalidateAll();
              }
              if (n.extensionsChanged) {
                var r;
                const { gl: t } = this.context;
                null === (r = this.state.model) || void 0 === r || r.delete(),
                  (this.state.model = this._getModel(t)),
                  i.invalidateAll();
              }
            }
            getPickingInfo(t) {
              const e = super.getPickingInfo(t),
                { index: n } = e,
                { data: i } = this.props;
              return (
                i[0] &&
                  i[0].__source &&
                  (e.object = i.find((t) => t.__source.index === n)),
                e
              );
            }
            disablePickingIndex(t) {
              const { data: e } = this.props;
              if (e[0] && e[0].__source)
                for (let n = 0; n < e.length; n++)
                  e[n].__source.index === t && this._disablePickingIndex(n);
              else this._disablePickingIndex(t);
            }
            draw({ uniforms: t }) {
              const {
                jointRounded: e,
                capRounded: n,
                billboard: i,
                miterLimit: r,
                widthUnits: s,
                widthScale: o,
                widthMinPixels: a,
                widthMaxPixels: c,
              } = this.props;
              this.state.model
                .setUniforms(t)
                .setUniforms({
                  jointType: Number(e),
                  capType: Number(n),
                  billboard: i,
                  widthUnits: li[s],
                  widthScale: o,
                  miterLimit: r,
                  widthMinPixels: a,
                  widthMaxPixels: c,
                })
                .draw();
            }
            _getModel(t) {
              return new Th(t, {
                ...this.getShaders(),
                id: this.props.id,
                geometry: new Ol({
                  drawMode: 4,
                  attributes: {
                    indices: new Uint16Array([
                      0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4,
                    ]),
                    positions: {
                      value: new Float32Array([
                        0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0,
                      ]),
                      size: 2,
                    },
                  },
                }),
                isInstanced: !0,
              });
            }
            calculatePositions(t) {
              const { pathTesselator: e } = this.state;
              (t.startIndices = e.vertexStarts), (t.value = e.get("positions"));
            }
            calculateSegmentTypes(t) {
              const { pathTesselator: e } = this.state;
              (t.startIndices = e.vertexStarts),
                (t.value = e.get("segmentTypes"));
            }
          }
          ($l.layerName = "PathLayer"), ($l.defaultProps = Ul);
          class Wl extends $l {
            getShaders() {
              const t = super.getShaders();
              return (
                (t.inject = {
                  "vs:#decl":
                    "uniform float trailLength;\nattribute float instanceTimestamps;\nattribute float instanceNextTimestamps;\nvarying float vTime;\n",
                  "vs:#main-end":
                    "vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;\n",
                  "fs:#decl":
                    "uniform bool fadeTrail;\nuniform float trailLength;\nuniform float currentTime;\nvarying float vTime;\n",
                  "fs:#main-start":
                    "if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {\n  discard;\n}\n",
                  "fs:DECKGL_FILTER_COLOR":
                    "if(fadeTrail) {\n  color.a *= 1.0 - (currentTime - vTime) / trailLength;\n}\n",
                }),
                t
              );
            }
            initializeState(t) {
              super.initializeState(t),
                this.getAttributeManager().addInstanced({
                  timestamps: {
                    size: 1,
                    accessor: "getTimestamps",
                    shaderAttributes: {
                      instanceTimestamps: { vertexOffset: 0 },
                      instanceNextTimestamps: { vertexOffset: 1 },
                    },
                  },
                });
            }
            draw(t) {
              const {
                fadeTrail: e,
                trailLength: n,
                currentTime: i,
              } = this.props;
              (t.uniforms = {
                ...t.uniforms,
                fadeTrail: e,
                trailLength: n,
                currentTime: i,
              }),
                super.draw(t);
            }
          }
          (Wl.layerName = "TripsLayer"),
            (Wl.defaultProps = {
              fadeTrail: !0,
              trailLength: { type: "number", value: 120, min: 0 },
              currentTime: { type: "number", value: 0, min: 0 },
              getTimestamps: { type: "accessor", value: null },
            });
          const Hl = [
            [255, 0, 0],
            [0, 0, 255],
          ];
          function Xl() {
            const t = new google.maps.Map(document.getElementById("map"), {
              center: { lat: 40.72, lng: -74 },
              mapId: "fae05836df2dc8bb",
              tilt: 45,
              zoom: 15,
            });
            let e = 0;
            const n = {
                id: "trips",
                data: "https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/trips/trips-v7.json",
                getPath: (t) => t.path,
                getTimestamps: (t) => t.timestamps,
                getColor: (t) => Hl[t.vendor],
                opacity: 1,
                widthMinPixels: 2,
                trailLength: 180,
                currentTime: e,
                shadowEnabled: !1,
              },
              i = new Rc({}),
              r = () => {
                e = (e + 1) % 1800;
                const t = new Wl({ ...n, currentTime: e });
                i.setProps({ layers: [t] }), window.requestAnimationFrame(r);
              };
            window.requestAnimationFrame(r), i.setMap(t);
          }
        })();
        var r = window;
        for (var s in i) r[s] = i[s];
        i.__esModule && Object.defineProperty(r, "__esModule", { value: !0 });
      })();
    </script>
  </head>
  <body>
    <div id="map"></div>

    <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=beta"
      async
    ></script>
  </body>
</html>
