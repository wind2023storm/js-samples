<!DOCTYPE html>
<html>
  <head>
    <title>deck.gl and Google Maps Platform</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <!-- Use Material Design Progress indicator -->
    <link
      href="https://unpkg.com/material-components-web@6.0.0/dist/material-components-web.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/material-components-web@6.0.0/dist/material-components-web.min.js"></script>

    <style type="text/css">
      :root {
        --mdc-theme-primary: #1a73e8;
        --mdc-theme-secondary: #rgb(225, 245, 254);
        --mdc-theme-on-primary: #fff;
        --mdc-theme-on-secondary: rgb(1, 87, 155);
      }

      .mdc-text-field--focused:not(.mdc-text-field--disabled)
        .mdc-floating-label {
        color: var(--mdc-theme-primary);
      }

      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }

      /* Optional: Makes the sample page fill the window. */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
    </style>
    <script>
      /*! For license information please see iframe.js.LICENSE.txt */
      (() => {
        var t = {
            422: (t) => {
              (t.exports = function (t) {
                return t && t.__esModule ? t : { default: t };
              }),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0);
            },
            17: (t) => {
              function e(n) {
                return (
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? ((t.exports = e =
                        function (t) {
                          return typeof t;
                        }),
                      (t.exports.default = t.exports),
                      (t.exports.__esModule = !0))
                    : ((t.exports = e =
                        function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        }),
                      (t.exports.default = t.exports),
                      (t.exports.__esModule = !0)),
                  e(n)
                );
              }
              (t.exports = e),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0);
            },
            823: (t) => {
              "use strict";
              (t.exports = n), (t.exports.default = n);
              var e = 1e20;
              function n(t, e, n, i, r, s) {
                (this.fontSize = t || 24),
                  (this.buffer = void 0 === e ? 3 : e),
                  (this.cutoff = i || 0.25),
                  (this.fontFamily = r || "sans-serif"),
                  (this.fontWeight = s || "normal"),
                  (this.radius = n || 8);
                var o = (this.size = this.fontSize + 2 * this.buffer),
                  a = o + 2 * this.buffer;
                (this.canvas = document.createElement("canvas")),
                  (this.canvas.width = this.canvas.height = o),
                  (this.ctx = this.canvas.getContext("2d")),
                  (this.ctx.font =
                    this.fontWeight +
                    " " +
                    this.fontSize +
                    "px " +
                    this.fontFamily),
                  (this.ctx.textAlign = "left"),
                  (this.ctx.fillStyle = "black"),
                  (this.gridOuter = new Float64Array(a * a)),
                  (this.gridInner = new Float64Array(a * a)),
                  (this.f = new Float64Array(a)),
                  (this.z = new Float64Array(a + 1)),
                  (this.v = new Uint16Array(a)),
                  (this.useMetrics =
                    void 0 !== this.ctx.measureText("A").actualBoundingBoxLeft),
                  (this.middle = Math.round(
                    (o / 2) *
                      (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1)
                  ));
              }
              function i(t, e, n, i, s, o) {
                for (var a = 0; a < e; a++) r(t, a, e, n, i, s, o);
                for (var c = 0; c < n; c++) r(t, c * e, 1, e, i, s, o);
              }
              function r(t, n, i, r, s, o, a) {
                var c, l, h, u;
                for (o[0] = 0, a[0] = -e, a[1] = e, c = 0; c < r; c++)
                  s[c] = t[n + c * i];
                for (c = 1, l = 0, h = 0; c < r; c++) {
                  do {
                    (u = o[l]),
                      (h = (s[c] - s[u] + c * c - u * u) / (c - u) / 2);
                  } while (h <= a[l] && --l > -1);
                  (o[++l] = c), (a[l] = h), (a[l + 1] = e);
                }
                for (c = 0, l = 0; c < r; c++) {
                  for (; a[l + 1] < c; ) l++;
                  (u = o[l]), (t[n + c * i] = s[u] + (c - u) * (c - u));
                }
              }
              (n.prototype._draw = function (t, n) {
                var r,
                  s,
                  o,
                  a,
                  c,
                  l,
                  h,
                  u,
                  d,
                  f = this.ctx.measureText(t),
                  p = f.width,
                  g = 2 * this.buffer;
                n && this.useMetrics
                  ? ((c = Math.floor(f.actualBoundingBoxAscent)),
                    (u = this.buffer + Math.ceil(f.actualBoundingBoxAscent)),
                    (l = this.buffer),
                    (h = this.buffer),
                    (r =
                      (s = Math.min(
                        this.size,
                        Math.ceil(
                          f.actualBoundingBoxRight - f.actualBoundingBoxLeft
                        )
                      )) + g),
                    (o =
                      (a = Math.min(
                        this.size - l,
                        Math.ceil(
                          f.actualBoundingBoxAscent + f.actualBoundingBoxDescent
                        )
                      )) + g),
                    (this.ctx.textBaseline = "alphabetic"))
                  : ((r = s = this.size),
                    (o = a = this.size),
                    (c = (19 * this.fontSize) / 24),
                    (l = h = 0),
                    (u = this.middle),
                    (this.ctx.textBaseline = "middle")),
                  s &&
                    a &&
                    (this.ctx.clearRect(h, l, s, a),
                    this.ctx.fillText(t, this.buffer, u),
                    (d = this.ctx.getImageData(h, l, s, a)));
                var m = new Uint8ClampedArray(r * o);
                return (
                  (function (t, n, i, r, s, o, a) {
                    o.fill(e, 0, n * i), a.fill(0, 0, n * i);
                    for (var c = (n - r) / 2, l = 0; l < s; l++)
                      for (var h = 0; h < r; h++) {
                        var u = (l + c) * n + h + c,
                          d = t.data[4 * (l * r + h) + 3] / 255;
                        if (1 === d) (o[u] = 0), (a[u] = e);
                        else if (0 === d) (o[u] = e), (a[u] = 0);
                        else {
                          var f = Math.max(0, 0.5 - d),
                            p = Math.max(0, d - 0.5);
                          (o[u] = f * f), (a[u] = p * p);
                        }
                      }
                  })(d, r, o, s, a, this.gridOuter, this.gridInner),
                  i(this.gridOuter, r, o, this.f, this.v, this.z),
                  i(this.gridInner, r, o, this.f, this.v, this.z),
                  (function (t, e, n, i, r, s, o) {
                    for (var a = 0; a < e * n; a++) {
                      var c = Math.sqrt(i[a]) - Math.sqrt(r[a]);
                      t[a] = Math.round(255 - 255 * (c / s + o));
                    }
                  })(
                    m,
                    r,
                    o,
                    this.gridOuter,
                    this.gridInner,
                    this.radius,
                    this.cutoff
                  ),
                  {
                    data: m,
                    metrics: {
                      width: s,
                      height: a,
                      sdfWidth: r,
                      sdfHeight: o,
                      top: c,
                      left: 0,
                      advance: p,
                    },
                  }
                );
              }),
                (n.prototype.draw = function (t) {
                  return this._draw(t, !1).data;
                }),
                (n.prototype.drawWithMetrics = function (t) {
                  return this._draw(t, !0);
                });
            },
            282: (t) => {
              "use strict";
              function e(t, e, s) {
                s = s || 2;
                var o,
                  a,
                  c,
                  u,
                  d,
                  p,
                  g,
                  m = e && e.length,
                  y = m ? e[0] * s : t.length,
                  _ = n(t, 0, y, s, !0),
                  v = [];
                if (!_ || _.next === _.prev) return v;
                if (
                  (m &&
                    (_ = (function (t, e, r, s) {
                      var o,
                        a,
                        c,
                        u = [];
                      for (o = 0, a = e.length; o < a; o++)
                        (c = n(
                          t,
                          e[o] * s,
                          o < a - 1 ? e[o + 1] * s : t.length,
                          s,
                          !1
                        )) === c.next && (c.steiner = !0),
                          u.push(f(c));
                      for (u.sort(l), o = 0; o < u.length; o++)
                        r = i((r = h(u[o], r)), r.next);
                      return r;
                    })(t, e, _, s)),
                  t.length > 80 * s)
                ) {
                  (o = c = t[0]), (a = u = t[1]);
                  for (var b = s; b < y; b += s)
                    (d = t[b]) < o && (o = d),
                      (p = t[b + 1]) < a && (a = p),
                      d > c && (c = d),
                      p > u && (u = p);
                  g = 0 !== (g = Math.max(c - o, u - a)) ? 1 / g : 0;
                }
                return r(_, v, s, o, a, g), v;
              }
              function n(t, e, n, i, r) {
                var s, o;
                if (r === T(t, e, n, i) > 0)
                  for (s = e; s < n; s += i) o = P(s, t[s], t[s + 1], o);
                else
                  for (s = n - i; s >= e; s -= i) o = P(s, t[s], t[s + 1], o);
                return o && y(o, o.next) && (E(o), (o = o.next)), o;
              }
              function i(t, e) {
                if (!t) return t;
                e || (e = t);
                var n,
                  i = t;
                do {
                  if (
                    ((n = !1),
                    i.steiner || (!y(i, i.next) && 0 !== m(i.prev, i, i.next)))
                  )
                    i = i.next;
                  else {
                    if ((E(i), (i = e = i.prev) === i.next)) break;
                    n = !0;
                  }
                } while (n || i !== e);
                return e;
              }
              function r(t, e, n, l, h, u, f) {
                if (t) {
                  !f &&
                    u &&
                    (function (t, e, n, i) {
                      var r = t;
                      do {
                        null === r.z && (r.z = d(r.x, r.y, e, n, i)),
                          (r.prevZ = r.prev),
                          (r.nextZ = r.next),
                          (r = r.next);
                      } while (r !== t);
                      (r.prevZ.nextZ = null),
                        (r.prevZ = null),
                        (function (t) {
                          var e,
                            n,
                            i,
                            r,
                            s,
                            o,
                            a,
                            c,
                            l = 1;
                          do {
                            for (n = t, t = null, s = null, o = 0; n; ) {
                              for (
                                o++, i = n, a = 0, e = 0;
                                e < l && (a++, (i = i.nextZ));
                                e++
                              );
                              for (c = l; a > 0 || (c > 0 && i); )
                                0 !== a && (0 === c || !i || n.z <= i.z)
                                  ? ((r = n), (n = n.nextZ), a--)
                                  : ((r = i), (i = i.nextZ), c--),
                                  s ? (s.nextZ = r) : (t = r),
                                  (r.prevZ = s),
                                  (s = r);
                              n = i;
                            }
                            (s.nextZ = null), (l *= 2);
                          } while (o > 1);
                        })(r);
                    })(t, l, h, u);
                  for (var p, g, m = t; t.prev !== t.next; )
                    if (((p = t.prev), (g = t.next), u ? o(t, l, h, u) : s(t)))
                      e.push(p.i / n),
                        e.push(t.i / n),
                        e.push(g.i / n),
                        E(t),
                        (t = g.next),
                        (m = g.next);
                    else if ((t = g) === m) {
                      f
                        ? 1 === f
                          ? r((t = a(i(t), e, n)), e, n, l, h, u, 2)
                          : 2 === f && c(t, e, n, l, h, u)
                        : r(i(t), e, n, l, h, u, 1);
                      break;
                    }
                }
              }
              function s(t) {
                var e = t.prev,
                  n = t,
                  i = t.next;
                if (m(e, n, i) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev; ) {
                  if (
                    p(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
                    m(r.prev, r, r.next) >= 0
                  )
                    return !1;
                  r = r.next;
                }
                return !0;
              }
              function o(t, e, n, i) {
                var r = t.prev,
                  s = t,
                  o = t.next;
                if (m(r, s, o) >= 0) return !1;
                for (
                  var a =
                      r.x < s.x
                        ? r.x < o.x
                          ? r.x
                          : o.x
                        : s.x < o.x
                        ? s.x
                        : o.x,
                    c =
                      r.y < s.y
                        ? r.y < o.y
                          ? r.y
                          : o.y
                        : s.y < o.y
                        ? s.y
                        : o.y,
                    l =
                      r.x > s.x
                        ? r.x > o.x
                          ? r.x
                          : o.x
                        : s.x > o.x
                        ? s.x
                        : o.x,
                    h =
                      r.y > s.y
                        ? r.y > o.y
                          ? r.y
                          : o.y
                        : s.y > o.y
                        ? s.y
                        : o.y,
                    u = d(a, c, e, n, i),
                    f = d(l, h, e, n, i),
                    g = t.prevZ,
                    y = t.nextZ;
                  g && g.z >= u && y && y.z <= f;

                ) {
                  if (
                    g !== t.prev &&
                    g !== t.next &&
                    p(r.x, r.y, s.x, s.y, o.x, o.y, g.x, g.y) &&
                    m(g.prev, g, g.next) >= 0
                  )
                    return !1;
                  if (
                    ((g = g.prevZ),
                    y !== t.prev &&
                      y !== t.next &&
                      p(r.x, r.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
                      m(y.prev, y, y.next) >= 0)
                  )
                    return !1;
                  y = y.nextZ;
                }
                for (; g && g.z >= u; ) {
                  if (
                    g !== t.prev &&
                    g !== t.next &&
                    p(r.x, r.y, s.x, s.y, o.x, o.y, g.x, g.y) &&
                    m(g.prev, g, g.next) >= 0
                  )
                    return !1;
                  g = g.prevZ;
                }
                for (; y && y.z <= f; ) {
                  if (
                    y !== t.prev &&
                    y !== t.next &&
                    p(r.x, r.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
                    m(y.prev, y, y.next) >= 0
                  )
                    return !1;
                  y = y.nextZ;
                }
                return !0;
              }
              function a(t, e, n) {
                var r = t;
                do {
                  var s = r.prev,
                    o = r.next.next;
                  !y(s, o) &&
                    _(s, r, r.next, o) &&
                    w(s, o) &&
                    w(o, s) &&
                    (e.push(s.i / n),
                    e.push(r.i / n),
                    e.push(o.i / n),
                    E(r),
                    E(r.next),
                    (r = t = o)),
                    (r = r.next);
                } while (r !== t);
                return i(r);
              }
              function c(t, e, n, s, o, a) {
                var c = t;
                do {
                  for (var l = c.next.next; l !== c.prev; ) {
                    if (c.i !== l.i && g(c, l)) {
                      var h = x(c, l);
                      return (
                        (c = i(c, c.next)),
                        (h = i(h, h.next)),
                        r(c, e, n, s, o, a),
                        void r(h, e, n, s, o, a)
                      );
                    }
                    l = l.next;
                  }
                  c = c.next;
                } while (c !== t);
              }
              function l(t, e) {
                return t.x - e.x;
              }
              function h(t, e) {
                var n = (function (t, e) {
                  var n,
                    i = e,
                    r = t.x,
                    s = t.y,
                    o = -1 / 0;
                  do {
                    if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                      var a =
                        i.x + ((s - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                      if (a <= r && a > o) {
                        if (((o = a), a === r)) {
                          if (s === i.y) return i;
                          if (s === i.next.y) return i.next;
                        }
                        n = i.x < i.next.x ? i : i.next;
                      }
                    }
                    i = i.next;
                  } while (i !== e);
                  if (!n) return null;
                  if (r === o) return n;
                  var c,
                    l = n,
                    h = n.x,
                    d = n.y,
                    f = 1 / 0;
                  i = n;
                  do {
                    r >= i.x &&
                      i.x >= h &&
                      r !== i.x &&
                      p(s < d ? r : o, s, h, d, s < d ? o : r, s, i.x, i.y) &&
                      ((c = Math.abs(s - i.y) / (r - i.x)),
                      w(i, t) &&
                        (c < f ||
                          (c === f &&
                            (i.x > n.x || (i.x === n.x && u(n, i))))) &&
                        ((n = i), (f = c))),
                      (i = i.next);
                  } while (i !== l);
                  return n;
                })(t, e);
                if (!n) return e;
                var r = x(n, t),
                  s = i(n, n.next);
                return i(r, r.next), e === n ? s : e;
              }
              function u(t, e) {
                return m(t.prev, t, e.prev) < 0 && m(e.next, t, t.next) < 0;
              }
              function d(t, e, n, i, r) {
                return (
                  (t =
                    1431655765 &
                    ((t =
                      858993459 &
                      ((t =
                        252645135 &
                        ((t =
                          16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                          (t << 4))) |
                        (t << 2))) |
                      (t << 1))) |
                  ((e =
                    1431655765 &
                    ((e =
                      858993459 &
                      ((e =
                        252645135 &
                        ((e =
                          16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                          (e << 4))) |
                        (e << 2))) |
                      (e << 1))) <<
                    1)
                );
              }
              function f(t) {
                var e = t,
                  n = t;
                do {
                  (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e),
                    (e = e.next);
                } while (e !== t);
                return n;
              }
              function p(t, e, n, i, r, s, o, a) {
                return (
                  (r - o) * (e - a) - (t - o) * (s - a) >= 0 &&
                  (t - o) * (i - a) - (n - o) * (e - a) >= 0 &&
                  (n - o) * (s - a) - (r - o) * (i - a) >= 0
                );
              }
              function g(t, e) {
                return (
                  t.next.i !== e.i &&
                  t.prev.i !== e.i &&
                  !(function (t, e) {
                    var n = t;
                    do {
                      if (
                        n.i !== t.i &&
                        n.next.i !== t.i &&
                        n.i !== e.i &&
                        n.next.i !== e.i &&
                        _(n, n.next, t, e)
                      )
                        return !0;
                      n = n.next;
                    } while (n !== t);
                    return !1;
                  })(t, e) &&
                  ((w(t, e) &&
                    w(e, t) &&
                    (function (t, e) {
                      var n = t,
                        i = !1,
                        r = (t.x + e.x) / 2,
                        s = (t.y + e.y) / 2;
                      do {
                        n.y > s != n.next.y > s &&
                          n.next.y !== n.y &&
                          r <
                            ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) +
                              n.x &&
                          (i = !i),
                          (n = n.next);
                      } while (n !== t);
                      return i;
                    })(t, e) &&
                    (m(t.prev, t, e.prev) || m(t, e.prev, e))) ||
                    (y(t, e) &&
                      m(t.prev, t, t.next) > 0 &&
                      m(e.prev, e, e.next) > 0))
                );
              }
              function m(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
              }
              function y(t, e) {
                return t.x === e.x && t.y === e.y;
              }
              function _(t, e, n, i) {
                var r = b(m(t, e, n)),
                  s = b(m(t, e, i)),
                  o = b(m(n, i, t)),
                  a = b(m(n, i, e));
                return (
                  (r !== s && o !== a) ||
                  !(0 !== r || !v(t, n, e)) ||
                  !(0 !== s || !v(t, i, e)) ||
                  !(0 !== o || !v(n, t, i)) ||
                  !(0 !== a || !v(n, e, i))
                );
              }
              function v(t, e, n) {
                return (
                  e.x <= Math.max(t.x, n.x) &&
                  e.x >= Math.min(t.x, n.x) &&
                  e.y <= Math.max(t.y, n.y) &&
                  e.y >= Math.min(t.y, n.y)
                );
              }
              function b(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0;
              }
              function w(t, e) {
                return m(t.prev, t, t.next) < 0
                  ? m(t, e, t.next) >= 0 && m(t, t.prev, e) >= 0
                  : m(t, e, t.prev) < 0 || m(t, t.next, e) < 0;
              }
              function x(t, e) {
                var n = new A(t.i, t.x, t.y),
                  i = new A(e.i, e.x, e.y),
                  r = t.next,
                  s = e.prev;
                return (
                  (t.next = e),
                  (e.prev = t),
                  (n.next = r),
                  (r.prev = n),
                  (i.next = n),
                  (n.prev = i),
                  (s.next = i),
                  (i.prev = s),
                  i
                );
              }
              function P(t, e, n, i) {
                var r = new A(t, e, n);
                return (
                  i
                    ? ((r.next = i.next),
                      (r.prev = i),
                      (i.next.prev = r),
                      (i.next = r))
                    : ((r.prev = r), (r.next = r)),
                  r
                );
              }
              function E(t) {
                (t.next.prev = t.prev),
                  (t.prev.next = t.next),
                  t.prevZ && (t.prevZ.nextZ = t.nextZ),
                  t.nextZ && (t.nextZ.prevZ = t.prevZ);
              }
              function A(t, e, n) {
                (this.i = t),
                  (this.x = e),
                  (this.y = n),
                  (this.prev = null),
                  (this.next = null),
                  (this.z = null),
                  (this.prevZ = null),
                  (this.nextZ = null),
                  (this.steiner = !1);
              }
              function T(t, e, n, i) {
                for (var r = 0, s = e, o = n - i; s < n; s += i)
                  (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
                return r;
              }
              (t.exports = e),
                (t.exports.default = e),
                (e.deviation = function (t, e, n, i) {
                  var r = e && e.length,
                    s = r ? e[0] * n : t.length,
                    o = Math.abs(T(t, 0, s, n));
                  if (r)
                    for (var a = 0, c = e.length; a < c; a++) {
                      var l = e[a] * n,
                        h = a < c - 1 ? e[a + 1] * n : t.length;
                      o -= Math.abs(T(t, l, h, n));
                    }
                  var u = 0;
                  for (a = 0; a < i.length; a += 3) {
                    var d = i[a] * n,
                      f = i[a + 1] * n,
                      p = i[a + 2] * n;
                    u += Math.abs(
                      (t[d] - t[p]) * (t[f + 1] - t[d + 1]) -
                        (t[d] - t[f]) * (t[p + 1] - t[d + 1])
                    );
                  }
                  return 0 === o && 0 === u ? 0 : Math.abs((u - o) / o);
                }),
                (e.flatten = function (t) {
                  for (
                    var e = t[0][0].length,
                      n = { vertices: [], holes: [], dimensions: e },
                      i = 0,
                      r = 0;
                    r < t.length;
                    r++
                  ) {
                    for (var s = 0; s < t[r].length; s++)
                      for (var o = 0; o < e; o++) n.vertices.push(t[r][s][o]);
                    r > 0 && ((i += t[r - 1].length), n.holes.push(i));
                  }
                  return n;
                });
            },
            377: (t, e, n) => {
              var i;
              !(function (r, s, o, a) {
                "use strict";
                var c,
                  l = ["", "webkit", "Moz", "MS", "ms", "o"],
                  h = s.createElement("div"),
                  u = Math.round,
                  d = Math.abs,
                  f = Date.now;
                function p(t, e, n) {
                  return setTimeout(w(t, n), e);
                }
                function g(t, e, n) {
                  return !!Array.isArray(t) && (m(t, n[e], n), !0);
                }
                function m(t, e, n) {
                  var i;
                  if (t)
                    if (t.forEach) t.forEach(e, n);
                    else if (t.length !== a)
                      for (i = 0; i < t.length; ) e.call(n, t[i], i, t), i++;
                    else
                      for (i in t) t.hasOwnProperty(i) && e.call(n, t[i], i, t);
                }
                function y(t, e, n) {
                  var i = "DEPRECATED METHOD: " + e + "\n" + n + " AT \n";
                  return function () {
                    var e = new Error("get-stack-trace"),
                      n =
                        e && e.stack
                          ? e.stack
                              .replace(/^[^\(]+?[\n$]/gm, "")
                              .replace(/^\s+at\s+/gm, "")
                              .replace(
                                /^Object.<anonymous>\s*\(/gm,
                                "{anonymous}()@"
                              )
                          : "Unknown Stack Trace",
                      s = r.console && (r.console.warn || r.console.log);
                    return (
                      s && s.call(r.console, i, n), t.apply(this, arguments)
                    );
                  };
                }
                c =
                  "function" != typeof Object.assign
                    ? function (t) {
                        if (t === a || null === t)
                          throw new TypeError(
                            "Cannot convert undefined or null to object"
                          );
                        for (
                          var e = Object(t), n = 1;
                          n < arguments.length;
                          n++
                        ) {
                          var i = arguments[n];
                          if (i !== a && null !== i)
                            for (var r in i)
                              i.hasOwnProperty(r) && (e[r] = i[r]);
                        }
                        return e;
                      }
                    : Object.assign;
                var _ = y(
                    function (t, e, n) {
                      for (var i = Object.keys(e), r = 0; r < i.length; )
                        (!n || (n && t[i[r]] === a)) && (t[i[r]] = e[i[r]]),
                          r++;
                      return t;
                    },
                    "extend",
                    "Use `assign`."
                  ),
                  v = y(
                    function (t, e) {
                      return _(t, e, !0);
                    },
                    "merge",
                    "Use `assign`."
                  );
                function b(t, e, n) {
                  var i,
                    r = e.prototype;
                  ((i = t.prototype = Object.create(r)).constructor = t),
                    (i._super = r),
                    n && c(i, n);
                }
                function w(t, e) {
                  return function () {
                    return t.apply(e, arguments);
                  };
                }
                function x(t, e) {
                  return "function" == typeof t
                    ? t.apply((e && e[0]) || a, e)
                    : t;
                }
                function P(t, e) {
                  return t === a ? e : t;
                }
                function E(t, e, n) {
                  m(M(e), function (e) {
                    t.addEventListener(e, n, !1);
                  });
                }
                function A(t, e, n) {
                  m(M(e), function (e) {
                    t.removeEventListener(e, n, !1);
                  });
                }
                function T(t, e) {
                  for (; t; ) {
                    if (t == e) return !0;
                    t = t.parentNode;
                  }
                  return !1;
                }
                function S(t, e) {
                  return t.indexOf(e) > -1;
                }
                function M(t) {
                  return t.trim().split(/\s+/g);
                }
                function C(t, e, n) {
                  if (t.indexOf && !n) return t.indexOf(e);
                  for (var i = 0; i < t.length; ) {
                    if ((n && t[i][n] == e) || (!n && t[i] === e)) return i;
                    i++;
                  }
                  return -1;
                }
                function L(t) {
                  return Array.prototype.slice.call(t, 0);
                }
                function O(t, e, n) {
                  for (var i = [], r = [], s = 0; s < t.length; ) {
                    var o = e ? t[s][e] : t[s];
                    C(r, o) < 0 && i.push(t[s]), (r[s] = o), s++;
                  }
                  return (
                    n &&
                      (i = e
                        ? i.sort(function (t, n) {
                            return t[e] > n[e];
                          })
                        : i.sort()),
                    i
                  );
                }
                function I(t, e) {
                  for (
                    var n, i, r = e[0].toUpperCase() + e.slice(1), s = 0;
                    s < l.length;

                  ) {
                    if ((i = (n = l[s]) ? n + r : e) in t) return i;
                    s++;
                  }
                  return a;
                }
                var R = 1;
                function k(t) {
                  var e = t.ownerDocument || t;
                  return e.defaultView || e.parentWindow || r;
                }
                var F = "ontouchstart" in r,
                  z = I(r, "PointerEvent") !== a,
                  j =
                    F &&
                    /mobile|tablet|ip(ad|hone|od)|android/i.test(
                      navigator.userAgent
                    ),
                  B = "touch",
                  D = "mouse",
                  N = ["x", "y"],
                  U = ["clientX", "clientY"];
                function V(t, e) {
                  var n = this;
                  (this.manager = t),
                    (this.callback = e),
                    (this.element = t.element),
                    (this.target = t.options.inputTarget),
                    (this.domHandler = function (e) {
                      x(t.options.enable, [t]) && n.handler(e);
                    }),
                    this.init();
                }
                function G(t, e, n) {
                  var i = n.pointers.length,
                    r = n.changedPointers.length,
                    s = 1 & e && i - r == 0,
                    o = 12 & e && i - r == 0;
                  (n.isFirst = !!s),
                    (n.isFinal = !!o),
                    s && (t.session = {}),
                    (n.eventType = e),
                    (function (t, e) {
                      var n = t.session,
                        i = e.pointers,
                        r = i.length;
                      n.firstInput || (n.firstInput = W(e)),
                        r > 1 && !n.firstMultiple
                          ? (n.firstMultiple = W(e))
                          : 1 === r && (n.firstMultiple = !1);
                      var s = n.firstInput,
                        o = n.firstMultiple,
                        c = o ? o.center : s.center,
                        l = (e.center = H(i));
                      (e.timeStamp = f()),
                        (e.deltaTime = e.timeStamp - s.timeStamp),
                        (e.angle = q(c, l)),
                        (e.distance = Y(c, l)),
                        (function (t, e) {
                          var n = e.center,
                            i = t.offsetDelta || {},
                            r = t.prevDelta || {},
                            s = t.prevInput || {};
                          (1 !== e.eventType && 4 !== s.eventType) ||
                            ((r = t.prevDelta =
                              { x: s.deltaX || 0, y: s.deltaY || 0 }),
                            (i = t.offsetDelta = { x: n.x, y: n.y })),
                            (e.deltaX = r.x + (n.x - i.x)),
                            (e.deltaY = r.y + (n.y - i.y));
                        })(n, e),
                        (e.offsetDirection = X(e.deltaX, e.deltaY));
                      var h,
                        u,
                        p = $(e.deltaTime, e.deltaX, e.deltaY);
                      (e.overallVelocityX = p.x),
                        (e.overallVelocityY = p.y),
                        (e.overallVelocity = d(p.x) > d(p.y) ? p.x : p.y),
                        (e.scale = o
                          ? ((h = o.pointers),
                            Y((u = i)[0], u[1], U) / Y(h[0], h[1], U))
                          : 1),
                        (e.rotation = o
                          ? (function (t, e) {
                              return q(e[1], e[0], U) + q(t[1], t[0], U);
                            })(o.pointers, i)
                          : 0),
                        (e.maxPointers = n.prevInput
                          ? e.pointers.length > n.prevInput.maxPointers
                            ? e.pointers.length
                            : n.prevInput.maxPointers
                          : e.pointers.length),
                        (function (t, e) {
                          var n,
                            i,
                            r,
                            s,
                            o = t.lastInterval || e,
                            c = e.timeStamp - o.timeStamp;
                          if (
                            8 != e.eventType &&
                            (c > 25 || o.velocity === a)
                          ) {
                            var l = e.deltaX - o.deltaX,
                              h = e.deltaY - o.deltaY,
                              u = $(c, l, h);
                            (i = u.x),
                              (r = u.y),
                              (n = d(u.x) > d(u.y) ? u.x : u.y),
                              (s = X(l, h)),
                              (t.lastInterval = e);
                          } else
                            (n = o.velocity),
                              (i = o.velocityX),
                              (r = o.velocityY),
                              (s = o.direction);
                          (e.velocity = n),
                            (e.velocityX = i),
                            (e.velocityY = r),
                            (e.direction = s);
                        })(n, e);
                      var g = t.element;
                      T(e.srcEvent.target, g) && (g = e.srcEvent.target),
                        (e.target = g);
                    })(t, n),
                    t.emit("hammer.input", n),
                    t.recognize(n),
                    (t.session.prevInput = n);
                }
                function W(t) {
                  for (var e = [], n = 0; n < t.pointers.length; )
                    (e[n] = {
                      clientX: u(t.pointers[n].clientX),
                      clientY: u(t.pointers[n].clientY),
                    }),
                      n++;
                  return {
                    timeStamp: f(),
                    pointers: e,
                    center: H(e),
                    deltaX: t.deltaX,
                    deltaY: t.deltaY,
                  };
                }
                function H(t) {
                  var e = t.length;
                  if (1 === e)
                    return { x: u(t[0].clientX), y: u(t[0].clientY) };
                  for (var n = 0, i = 0, r = 0; r < e; )
                    (n += t[r].clientX), (i += t[r].clientY), r++;
                  return { x: u(n / e), y: u(i / e) };
                }
                function $(t, e, n) {
                  return { x: e / t || 0, y: n / t || 0 };
                }
                function X(t, e) {
                  return t === e
                    ? 1
                    : d(t) >= d(e)
                    ? t < 0
                      ? 2
                      : 4
                    : e < 0
                    ? 8
                    : 16;
                }
                function Y(t, e, n) {
                  n || (n = N);
                  var i = e[n[0]] - t[n[0]],
                    r = e[n[1]] - t[n[1]];
                  return Math.sqrt(i * i + r * r);
                }
                function q(t, e, n) {
                  n || (n = N);
                  var i = e[n[0]] - t[n[0]],
                    r = e[n[1]] - t[n[1]];
                  return (180 * Math.atan2(r, i)) / Math.PI;
                }
                V.prototype = {
                  handler: function () {},
                  init: function () {
                    this.evEl && E(this.element, this.evEl, this.domHandler),
                      this.evTarget &&
                        E(this.target, this.evTarget, this.domHandler),
                      this.evWin &&
                        E(k(this.element), this.evWin, this.domHandler);
                  },
                  destroy: function () {
                    this.evEl && A(this.element, this.evEl, this.domHandler),
                      this.evTarget &&
                        A(this.target, this.evTarget, this.domHandler),
                      this.evWin &&
                        A(k(this.element), this.evWin, this.domHandler);
                  },
                };
                var Z = { mousedown: 1, mousemove: 2, mouseup: 4 },
                  K = "mousedown",
                  J = "mousemove mouseup";
                function Q() {
                  (this.evEl = K),
                    (this.evWin = J),
                    (this.pressed = !1),
                    V.apply(this, arguments);
                }
                b(Q, V, {
                  handler: function (t) {
                    var e = Z[t.type];
                    1 & e && 0 === t.button && (this.pressed = !0),
                      2 & e && 1 !== t.which && (e = 4),
                      this.pressed &&
                        (4 & e && (this.pressed = !1),
                        this.callback(this.manager, e, {
                          pointers: [t],
                          changedPointers: [t],
                          pointerType: D,
                          srcEvent: t,
                        }));
                  },
                });
                var tt = {
                    pointerdown: 1,
                    pointermove: 2,
                    pointerup: 4,
                    pointercancel: 8,
                    pointerout: 8,
                  },
                  et = { 2: B, 3: "pen", 4: D, 5: "kinect" },
                  nt = "pointerdown",
                  it = "pointermove pointerup pointercancel";
                function rt() {
                  (this.evEl = nt),
                    (this.evWin = it),
                    V.apply(this, arguments),
                    (this.store = this.manager.session.pointerEvents = []);
                }
                r.MSPointerEvent &&
                  !r.PointerEvent &&
                  ((nt = "MSPointerDown"),
                  (it = "MSPointerMove MSPointerUp MSPointerCancel")),
                  b(rt, V, {
                    handler: function (t) {
                      var e = this.store,
                        n = !1,
                        i = t.type.toLowerCase().replace("ms", ""),
                        r = tt[i],
                        s = et[t.pointerType] || t.pointerType,
                        o = s == B,
                        a = C(e, t.pointerId, "pointerId");
                      1 & r && (0 === t.button || o)
                        ? a < 0 && (e.push(t), (a = e.length - 1))
                        : 12 & r && (n = !0),
                        a < 0 ||
                          ((e[a] = t),
                          this.callback(this.manager, r, {
                            pointers: e,
                            changedPointers: [t],
                            pointerType: s,
                            srcEvent: t,
                          }),
                          n && e.splice(a, 1));
                    },
                  });
                var st = {
                    touchstart: 1,
                    touchmove: 2,
                    touchend: 4,
                    touchcancel: 8,
                  },
                  ot = "touchstart",
                  at = "touchstart touchmove touchend touchcancel";
                function ct() {
                  (this.evTarget = ot),
                    (this.evWin = at),
                    (this.started = !1),
                    V.apply(this, arguments);
                }
                function lt(t, e) {
                  var n = L(t.touches),
                    i = L(t.changedTouches);
                  return (
                    12 & e && (n = O(n.concat(i), "identifier", !0)), [n, i]
                  );
                }
                b(ct, V, {
                  handler: function (t) {
                    var e = st[t.type];
                    if ((1 === e && (this.started = !0), this.started)) {
                      var n = lt.call(this, t, e);
                      12 & e &&
                        n[0].length - n[1].length == 0 &&
                        (this.started = !1),
                        this.callback(this.manager, e, {
                          pointers: n[0],
                          changedPointers: n[1],
                          pointerType: B,
                          srcEvent: t,
                        });
                    }
                  },
                });
                var ht = {
                    touchstart: 1,
                    touchmove: 2,
                    touchend: 4,
                    touchcancel: 8,
                  },
                  ut = "touchstart touchmove touchend touchcancel";
                function dt() {
                  (this.evTarget = ut),
                    (this.targetIds = {}),
                    V.apply(this, arguments);
                }
                function ft(t, e) {
                  var n = L(t.touches),
                    i = this.targetIds;
                  if (3 & e && 1 === n.length)
                    return (i[n[0].identifier] = !0), [n, n];
                  var r,
                    s,
                    o = L(t.changedTouches),
                    a = [],
                    c = this.target;
                  if (
                    ((s = n.filter(function (t) {
                      return T(t.target, c);
                    })),
                    1 === e)
                  )
                    for (r = 0; r < s.length; ) (i[s[r].identifier] = !0), r++;
                  for (r = 0; r < o.length; )
                    i[o[r].identifier] && a.push(o[r]),
                      12 & e && delete i[o[r].identifier],
                      r++;
                  return a.length
                    ? [O(s.concat(a), "identifier", !0), a]
                    : void 0;
                }
                function pt() {
                  V.apply(this, arguments);
                  var t = w(this.handler, this);
                  (this.touch = new dt(this.manager, t)),
                    (this.mouse = new Q(this.manager, t)),
                    (this.primaryTouch = null),
                    (this.lastTouches = []);
                }
                function gt(t, e) {
                  1 & t
                    ? ((this.primaryTouch = e.changedPointers[0].identifier),
                      mt.call(this, e))
                    : 12 & t && mt.call(this, e);
                }
                function mt(t) {
                  var e = t.changedPointers[0];
                  if (e.identifier === this.primaryTouch) {
                    var n = { x: e.clientX, y: e.clientY };
                    this.lastTouches.push(n);
                    var i = this.lastTouches;
                    setTimeout(function () {
                      var t = i.indexOf(n);
                      t > -1 && i.splice(t, 1);
                    }, 2500);
                  }
                }
                function yt(t) {
                  for (
                    var e = t.srcEvent.clientX, n = t.srcEvent.clientY, i = 0;
                    i < this.lastTouches.length;
                    i++
                  ) {
                    var r = this.lastTouches[i],
                      s = Math.abs(e - r.x),
                      o = Math.abs(n - r.y);
                    if (s <= 25 && o <= 25) return !0;
                  }
                  return !1;
                }
                b(dt, V, {
                  handler: function (t) {
                    var e = ht[t.type],
                      n = ft.call(this, t, e);
                    n &&
                      this.callback(this.manager, e, {
                        pointers: n[0],
                        changedPointers: n[1],
                        pointerType: B,
                        srcEvent: t,
                      });
                  },
                }),
                  b(pt, V, {
                    handler: function (t, e, n) {
                      var i = n.pointerType == B,
                        r = n.pointerType == D;
                      if (
                        !(
                          r &&
                          n.sourceCapabilities &&
                          n.sourceCapabilities.firesTouchEvents
                        )
                      ) {
                        if (i) gt.call(this, e, n);
                        else if (r && yt.call(this, n)) return;
                        this.callback(t, e, n);
                      }
                    },
                    destroy: function () {
                      this.touch.destroy(), this.mouse.destroy();
                    },
                  });
                var _t = I(h.style, "touchAction"),
                  vt = _t !== a,
                  bt = "compute",
                  wt = "auto",
                  xt = "manipulation",
                  Pt = "none",
                  Et = "pan-x",
                  At = "pan-y",
                  Tt = (function () {
                    if (!vt) return !1;
                    var t = {},
                      e = r.CSS && r.CSS.supports;
                    return (
                      [
                        "auto",
                        "manipulation",
                        "pan-y",
                        "pan-x",
                        "pan-x pan-y",
                        "none",
                      ].forEach(function (n) {
                        t[n] = !e || r.CSS.supports("touch-action", n);
                      }),
                      t
                    );
                  })();
                function St(t, e) {
                  (this.manager = t), this.set(e);
                }
                St.prototype = {
                  set: function (t) {
                    t == bt && (t = this.compute()),
                      vt &&
                        this.manager.element.style &&
                        Tt[t] &&
                        (this.manager.element.style[_t] = t),
                      (this.actions = t.toLowerCase().trim());
                  },
                  update: function () {
                    this.set(this.manager.options.touchAction);
                  },
                  compute: function () {
                    var t = [];
                    return (
                      m(this.manager.recognizers, function (e) {
                        x(e.options.enable, [e]) &&
                          (t = t.concat(e.getTouchAction()));
                      }),
                      (function (t) {
                        if (S(t, Pt)) return Pt;
                        var e = S(t, Et),
                          n = S(t, At);
                        return e && n
                          ? Pt
                          : e || n
                          ? e
                            ? Et
                            : At
                          : S(t, xt)
                          ? xt
                          : wt;
                      })(t.join(" "))
                    );
                  },
                  preventDefaults: function (t) {
                    var e = t.srcEvent,
                      n = t.offsetDirection;
                    if (this.manager.session.prevented) e.preventDefault();
                    else {
                      var i = this.actions,
                        r = S(i, Pt) && !Tt.none,
                        s = S(i, At) && !Tt["pan-y"],
                        o = S(i, Et) && !Tt["pan-x"];
                      if (r) {
                        var a = 1 === t.pointers.length,
                          c = t.distance < 2,
                          l = t.deltaTime < 250;
                        if (a && c && l) return;
                      }
                      if (!o || !s)
                        return r || (s && 6 & n) || (o && 24 & n)
                          ? this.preventSrc(e)
                          : void 0;
                    }
                  },
                  preventSrc: function (t) {
                    (this.manager.session.prevented = !0), t.preventDefault();
                  },
                };
                var Mt = 32;
                function Ct(t) {
                  (this.options = c({}, this.defaults, t || {})),
                    (this.id = R++),
                    (this.manager = null),
                    (this.options.enable = P(this.options.enable, !0)),
                    (this.state = 1),
                    (this.simultaneous = {}),
                    (this.requireFail = []);
                }
                function Lt(t) {
                  return 16 & t
                    ? "cancel"
                    : 8 & t
                    ? "end"
                    : 4 & t
                    ? "move"
                    : 2 & t
                    ? "start"
                    : "";
                }
                function Ot(t) {
                  return 16 == t
                    ? "down"
                    : 8 == t
                    ? "up"
                    : 2 == t
                    ? "left"
                    : 4 == t
                    ? "right"
                    : "";
                }
                function It(t, e) {
                  var n = e.manager;
                  return n ? n.get(t) : t;
                }
                function Rt() {
                  Ct.apply(this, arguments);
                }
                function kt() {
                  Rt.apply(this, arguments), (this.pX = null), (this.pY = null);
                }
                function Ft() {
                  Rt.apply(this, arguments);
                }
                function zt() {
                  Ct.apply(this, arguments),
                    (this._timer = null),
                    (this._input = null);
                }
                function jt() {
                  Rt.apply(this, arguments);
                }
                function Bt() {
                  Rt.apply(this, arguments);
                }
                function Dt() {
                  Ct.apply(this, arguments),
                    (this.pTime = !1),
                    (this.pCenter = !1),
                    (this._timer = null),
                    (this._input = null),
                    (this.count = 0);
                }
                function Nt(t, e) {
                  return (
                    ((e = e || {}).recognizers = P(
                      e.recognizers,
                      Nt.defaults.preset
                    )),
                    new Ut(t, e)
                  );
                }
                function Ut(t, e) {
                  (this.options = c({}, Nt.defaults, e || {})),
                    (this.options.inputTarget = this.options.inputTarget || t),
                    (this.handlers = {}),
                    (this.session = {}),
                    (this.recognizers = []),
                    (this.oldCssProps = {}),
                    (this.element = t),
                    (this.input = new (this.options.inputClass ||
                      (z ? rt : j ? dt : F ? pt : Q))(this, G)),
                    (this.touchAction = new St(this, this.options.touchAction)),
                    Vt(this, !0),
                    m(
                      this.options.recognizers,
                      function (t) {
                        var e = this.add(new t[0](t[1]));
                        t[2] && e.recognizeWith(t[2]),
                          t[3] && e.requireFailure(t[3]);
                      },
                      this
                    );
                }
                function Vt(t, e) {
                  var n,
                    i = t.element;
                  i.style &&
                    (m(t.options.cssProps, function (r, s) {
                      (n = I(i.style, s)),
                        e
                          ? ((t.oldCssProps[n] = i.style[n]), (i.style[n] = r))
                          : (i.style[n] = t.oldCssProps[n] || "");
                    }),
                    e || (t.oldCssProps = {}));
                }
                (Ct.prototype = {
                  defaults: {},
                  set: function (t) {
                    return (
                      c(this.options, t),
                      this.manager && this.manager.touchAction.update(),
                      this
                    );
                  },
                  recognizeWith: function (t) {
                    if (g(t, "recognizeWith", this)) return this;
                    var e = this.simultaneous;
                    return (
                      e[(t = It(t, this)).id] ||
                        ((e[t.id] = t), t.recognizeWith(this)),
                      this
                    );
                  },
                  dropRecognizeWith: function (t) {
                    return (
                      g(t, "dropRecognizeWith", this) ||
                        ((t = It(t, this)), delete this.simultaneous[t.id]),
                      this
                    );
                  },
                  requireFailure: function (t) {
                    if (g(t, "requireFailure", this)) return this;
                    var e = this.requireFail;
                    return (
                      -1 === C(e, (t = It(t, this))) &&
                        (e.push(t), t.requireFailure(this)),
                      this
                    );
                  },
                  dropRequireFailure: function (t) {
                    if (g(t, "dropRequireFailure", this)) return this;
                    t = It(t, this);
                    var e = C(this.requireFail, t);
                    return e > -1 && this.requireFail.splice(e, 1), this;
                  },
                  hasRequireFailures: function () {
                    return this.requireFail.length > 0;
                  },
                  canRecognizeWith: function (t) {
                    return !!this.simultaneous[t.id];
                  },
                  emit: function (t) {
                    var e = this,
                      n = this.state;
                    function i(n) {
                      e.manager.emit(n, t);
                    }
                    n < 8 && i(e.options.event + Lt(n)),
                      i(e.options.event),
                      t.additionalEvent && i(t.additionalEvent),
                      n >= 8 && i(e.options.event + Lt(n));
                  },
                  tryEmit: function (t) {
                    if (this.canEmit()) return this.emit(t);
                    this.state = Mt;
                  },
                  canEmit: function () {
                    for (var t = 0; t < this.requireFail.length; ) {
                      if (!(33 & this.requireFail[t].state)) return !1;
                      t++;
                    }
                    return !0;
                  },
                  recognize: function (t) {
                    var e = c({}, t);
                    if (!x(this.options.enable, [this, e]))
                      return this.reset(), void (this.state = Mt);
                    56 & this.state && (this.state = 1),
                      (this.state = this.process(e)),
                      30 & this.state && this.tryEmit(e);
                  },
                  process: function (t) {},
                  getTouchAction: function () {},
                  reset: function () {},
                }),
                  b(Rt, Ct, {
                    defaults: { pointers: 1 },
                    attrTest: function (t) {
                      var e = this.options.pointers;
                      return 0 === e || t.pointers.length === e;
                    },
                    process: function (t) {
                      var e = this.state,
                        n = t.eventType,
                        i = 6 & e,
                        r = this.attrTest(t);
                      return i && (8 & n || !r)
                        ? 16 | e
                        : i || r
                        ? 4 & n
                          ? 8 | e
                          : 2 & e
                          ? 4 | e
                          : 2
                        : Mt;
                    },
                  }),
                  b(kt, Rt, {
                    defaults: {
                      event: "pan",
                      threshold: 10,
                      pointers: 1,
                      direction: 30,
                    },
                    getTouchAction: function () {
                      var t = this.options.direction,
                        e = [];
                      return 6 & t && e.push(At), 24 & t && e.push(Et), e;
                    },
                    directionTest: function (t) {
                      var e = this.options,
                        n = !0,
                        i = t.distance,
                        r = t.direction,
                        s = t.deltaX,
                        o = t.deltaY;
                      return (
                        r & e.direction ||
                          (6 & e.direction
                            ? ((r = 0 === s ? 1 : s < 0 ? 2 : 4),
                              (n = s != this.pX),
                              (i = Math.abs(t.deltaX)))
                            : ((r = 0 === o ? 1 : o < 0 ? 8 : 16),
                              (n = o != this.pY),
                              (i = Math.abs(t.deltaY)))),
                        (t.direction = r),
                        n && i > e.threshold && r & e.direction
                      );
                    },
                    attrTest: function (t) {
                      return (
                        Rt.prototype.attrTest.call(this, t) &&
                        (2 & this.state ||
                          (!(2 & this.state) && this.directionTest(t)))
                      );
                    },
                    emit: function (t) {
                      (this.pX = t.deltaX), (this.pY = t.deltaY);
                      var e = Ot(t.direction);
                      e && (t.additionalEvent = this.options.event + e),
                        this._super.emit.call(this, t);
                    },
                  }),
                  b(Ft, Rt, {
                    defaults: { event: "pinch", threshold: 0, pointers: 2 },
                    getTouchAction: function () {
                      return [Pt];
                    },
                    attrTest: function (t) {
                      return (
                        this._super.attrTest.call(this, t) &&
                        (Math.abs(t.scale - 1) > this.options.threshold ||
                          2 & this.state)
                      );
                    },
                    emit: function (t) {
                      if (1 !== t.scale) {
                        var e = t.scale < 1 ? "in" : "out";
                        t.additionalEvent = this.options.event + e;
                      }
                      this._super.emit.call(this, t);
                    },
                  }),
                  b(zt, Ct, {
                    defaults: {
                      event: "press",
                      pointers: 1,
                      time: 251,
                      threshold: 9,
                    },
                    getTouchAction: function () {
                      return [wt];
                    },
                    process: function (t) {
                      var e = this.options,
                        n = t.pointers.length === e.pointers,
                        i = t.distance < e.threshold,
                        r = t.deltaTime > e.time;
                      if (
                        ((this._input = t),
                        !i || !n || (12 & t.eventType && !r))
                      )
                        this.reset();
                      else if (1 & t.eventType)
                        this.reset(),
                          (this._timer = p(
                            function () {
                              (this.state = 8), this.tryEmit();
                            },
                            e.time,
                            this
                          ));
                      else if (4 & t.eventType) return 8;
                      return Mt;
                    },
                    reset: function () {
                      clearTimeout(this._timer);
                    },
                    emit: function (t) {
                      8 === this.state &&
                        (t && 4 & t.eventType
                          ? this.manager.emit(this.options.event + "up", t)
                          : ((this._input.timeStamp = f()),
                            this.manager.emit(
                              this.options.event,
                              this._input
                            )));
                    },
                  }),
                  b(jt, Rt, {
                    defaults: { event: "rotate", threshold: 0, pointers: 2 },
                    getTouchAction: function () {
                      return [Pt];
                    },
                    attrTest: function (t) {
                      return (
                        this._super.attrTest.call(this, t) &&
                        (Math.abs(t.rotation) > this.options.threshold ||
                          2 & this.state)
                      );
                    },
                  }),
                  b(Bt, Rt, {
                    defaults: {
                      event: "swipe",
                      threshold: 10,
                      velocity: 0.3,
                      direction: 30,
                      pointers: 1,
                    },
                    getTouchAction: function () {
                      return kt.prototype.getTouchAction.call(this);
                    },
                    attrTest: function (t) {
                      var e,
                        n = this.options.direction;
                      return (
                        30 & n
                          ? (e = t.overallVelocity)
                          : 6 & n
                          ? (e = t.overallVelocityX)
                          : 24 & n && (e = t.overallVelocityY),
                        this._super.attrTest.call(this, t) &&
                          n & t.offsetDirection &&
                          t.distance > this.options.threshold &&
                          t.maxPointers == this.options.pointers &&
                          d(e) > this.options.velocity &&
                          4 & t.eventType
                      );
                    },
                    emit: function (t) {
                      var e = Ot(t.offsetDirection);
                      e && this.manager.emit(this.options.event + e, t),
                        this.manager.emit(this.options.event, t);
                    },
                  }),
                  b(Dt, Ct, {
                    defaults: {
                      event: "tap",
                      pointers: 1,
                      taps: 1,
                      interval: 300,
                      time: 250,
                      threshold: 9,
                      posThreshold: 10,
                    },
                    getTouchAction: function () {
                      return [xt];
                    },
                    process: function (t) {
                      var e = this.options,
                        n = t.pointers.length === e.pointers,
                        i = t.distance < e.threshold,
                        r = t.deltaTime < e.time;
                      if ((this.reset(), 1 & t.eventType && 0 === this.count))
                        return this.failTimeout();
                      if (i && r && n) {
                        if (4 != t.eventType) return this.failTimeout();
                        var s =
                            !this.pTime ||
                            t.timeStamp - this.pTime < e.interval,
                          o =
                            !this.pCenter ||
                            Y(this.pCenter, t.center) < e.posThreshold;
                        if (
                          ((this.pTime = t.timeStamp),
                          (this.pCenter = t.center),
                          o && s ? (this.count += 1) : (this.count = 1),
                          (this._input = t),
                          0 == this.count % e.taps)
                        )
                          return this.hasRequireFailures()
                            ? ((this._timer = p(
                                function () {
                                  (this.state = 8), this.tryEmit();
                                },
                                e.interval,
                                this
                              )),
                              2)
                            : 8;
                      }
                      return Mt;
                    },
                    failTimeout: function () {
                      return (
                        (this._timer = p(
                          function () {
                            this.state = Mt;
                          },
                          this.options.interval,
                          this
                        )),
                        Mt
                      );
                    },
                    reset: function () {
                      clearTimeout(this._timer);
                    },
                    emit: function () {
                      8 == this.state &&
                        ((this._input.tapCount = this.count),
                        this.manager.emit(this.options.event, this._input));
                    },
                  }),
                  (Nt.VERSION = "2.0.7"),
                  (Nt.defaults = {
                    domEvents: !1,
                    touchAction: bt,
                    enable: !0,
                    inputTarget: null,
                    inputClass: null,
                    preset: [
                      [jt, { enable: !1 }],
                      [Ft, { enable: !1 }, ["rotate"]],
                      [Bt, { direction: 6 }],
                      [kt, { direction: 6 }, ["swipe"]],
                      [Dt],
                      [Dt, { event: "doubletap", taps: 2 }, ["tap"]],
                      [zt],
                    ],
                    cssProps: {
                      userSelect: "none",
                      touchSelect: "none",
                      touchCallout: "none",
                      contentZooming: "none",
                      userDrag: "none",
                      tapHighlightColor: "rgba(0,0,0,0)",
                    },
                  }),
                  (Ut.prototype = {
                    set: function (t) {
                      return (
                        c(this.options, t),
                        t.touchAction && this.touchAction.update(),
                        t.inputTarget &&
                          (this.input.destroy(),
                          (this.input.target = t.inputTarget),
                          this.input.init()),
                        this
                      );
                    },
                    stop: function (t) {
                      this.session.stopped = t ? 2 : 1;
                    },
                    recognize: function (t) {
                      var e = this.session;
                      if (!e.stopped) {
                        var n;
                        this.touchAction.preventDefaults(t);
                        var i = this.recognizers,
                          r = e.curRecognizer;
                        (!r || (r && 8 & r.state)) &&
                          (r = e.curRecognizer = null);
                        for (var s = 0; s < i.length; )
                          (n = i[s]),
                            2 === e.stopped ||
                            (r && n != r && !n.canRecognizeWith(r))
                              ? n.reset()
                              : n.recognize(t),
                            !r && 14 & n.state && (r = e.curRecognizer = n),
                            s++;
                      }
                    },
                    get: function (t) {
                      if (t instanceof Ct) return t;
                      for (var e = this.recognizers, n = 0; n < e.length; n++)
                        if (e[n].options.event == t) return e[n];
                      return null;
                    },
                    add: function (t) {
                      if (g(t, "add", this)) return this;
                      var e = this.get(t.options.event);
                      return (
                        e && this.remove(e),
                        this.recognizers.push(t),
                        (t.manager = this),
                        this.touchAction.update(),
                        t
                      );
                    },
                    remove: function (t) {
                      if (g(t, "remove", this)) return this;
                      if ((t = this.get(t))) {
                        var e = this.recognizers,
                          n = C(e, t);
                        -1 !== n && (e.splice(n, 1), this.touchAction.update());
                      }
                      return this;
                    },
                    on: function (t, e) {
                      if (t !== a && e !== a) {
                        var n = this.handlers;
                        return (
                          m(M(t), function (t) {
                            (n[t] = n[t] || []), n[t].push(e);
                          }),
                          this
                        );
                      }
                    },
                    off: function (t, e) {
                      if (t !== a) {
                        var n = this.handlers;
                        return (
                          m(M(t), function (t) {
                            e
                              ? n[t] && n[t].splice(C(n[t], e), 1)
                              : delete n[t];
                          }),
                          this
                        );
                      }
                    },
                    emit: function (t, e) {
                      this.options.domEvents &&
                        (function (t, e) {
                          var n = s.createEvent("Event");
                          n.initEvent(t, !0, !0),
                            (n.gesture = e),
                            e.target.dispatchEvent(n);
                        })(t, e);
                      var n = this.handlers[t] && this.handlers[t].slice();
                      if (n && n.length) {
                        (e.type = t),
                          (e.preventDefault = function () {
                            e.srcEvent.preventDefault();
                          });
                        for (var i = 0; i < n.length; ) n[i](e), i++;
                      }
                    },
                    destroy: function () {
                      this.element && Vt(this, !1),
                        (this.handlers = {}),
                        (this.session = {}),
                        this.input.destroy(),
                        (this.element = null);
                    },
                  }),
                  c(Nt, {
                    INPUT_START: 1,
                    INPUT_MOVE: 2,
                    INPUT_END: 4,
                    INPUT_CANCEL: 8,
                    STATE_POSSIBLE: 1,
                    STATE_BEGAN: 2,
                    STATE_CHANGED: 4,
                    STATE_ENDED: 8,
                    STATE_RECOGNIZED: 8,
                    STATE_CANCELLED: 16,
                    STATE_FAILED: Mt,
                    DIRECTION_NONE: 1,
                    DIRECTION_LEFT: 2,
                    DIRECTION_RIGHT: 4,
                    DIRECTION_UP: 8,
                    DIRECTION_DOWN: 16,
                    DIRECTION_HORIZONTAL: 6,
                    DIRECTION_VERTICAL: 24,
                    DIRECTION_ALL: 30,
                    Manager: Ut,
                    Input: V,
                    TouchAction: St,
                    TouchInput: dt,
                    MouseInput: Q,
                    PointerEventInput: rt,
                    TouchMouseInput: pt,
                    SingleTouchInput: ct,
                    Recognizer: Ct,
                    AttrRecognizer: Rt,
                    Tap: Dt,
                    Pan: kt,
                    Swipe: Bt,
                    Pinch: Ft,
                    Rotate: jt,
                    Press: zt,
                    on: E,
                    off: A,
                    each: m,
                    merge: v,
                    extend: _,
                    assign: c,
                    inherit: b,
                    bindFn: w,
                    prefixed: I,
                  }),
                  ((void 0 !== r
                    ? r
                    : "undefined" != typeof self
                    ? self
                    : {}
                  ).Hammer = Nt),
                  (i = function () {
                    return Nt;
                  }.call(e, n, e, t)) === a || (t.exports = i);
              })(window, document);
            },
            613: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.isMobile = function () {
                  return void 0 !== r.window.orientation;
                }),
                (e.default = function (t) {
                  if (!t && !(0, s.default)()) return "Node";
                  if ((0, o.default)(t)) return "Electron";
                  var e = "undefined" != typeof navigator ? navigator : {},
                    n = t || e.userAgent || "";
                  if (n.indexOf("Edge") > -1) return "Edge";
                  var i = -1 !== n.indexOf("MSIE "),
                    a = -1 !== n.indexOf("Trident/");
                  return i || a
                    ? "IE"
                    : r.window.chrome
                    ? "Chrome"
                    : r.window.safari
                    ? "Safari"
                    : r.window.mozInnerScreenX
                    ? "Firefox"
                    : "Unknown";
                });
              var r = n(129),
                s = i(n(355)),
                o = i(n(628));
            },
            129: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.console =
                  e.process =
                  e.document =
                  e.global =
                  e.window =
                  e.self =
                    void 0);
              var r = i(n(17)),
                s = {
                  self: "undefined" != typeof self && self,
                  window: "undefined" != typeof window && window,
                  global: void 0 !== n.g && n.g,
                  document: "undefined" != typeof document && document,
                  process:
                    "object" ===
                      ("undefined" == typeof process
                        ? "undefined"
                        : (0, r.default)(process)) && process,
                },
                o = s.self || s.window || s.global;
              e.self = o;
              var a = s.window || s.self || s.global;
              e.window = a;
              var c = s.global || s.self || s.window;
              e.global = c;
              var l = s.document || {};
              e.document = l;
              var h = s.process || {};
              e.process = h;
              var u = console;
              e.console = u;
            },
            395: (t, e, n) => {
              "use strict";
              var i = n(422),
                r = n(17);
              Object.defineProperty(e, "CO", {
                enumerable: !0,
                get: function () {
                  return s.global;
                },
              }),
                Object.defineProperty(e, "jU", {
                  enumerable: !0,
                  get: function () {
                    return o.default;
                  },
                }),
                Object.defineProperty(e, "qs", {
                  enumerable: !0,
                  get: function () {
                    return a.default;
                  },
                });
              var s = n(129),
                o = l(n(355)),
                a = l(n(613));
              i(n(628));
              function c(t) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap(),
                  n = new WeakMap();
                return (c = function (t) {
                  return t ? n : e;
                })(t);
              }
              function l(t, e) {
                if (!e && t && t.__esModule) return t;
                if (null === t || ("object" !== r(t) && "function" != typeof t))
                  return { default: t };
                var n = c(e);
                if (n && n.has(t)) return n.get(t);
                var i = {},
                  s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in t)
                  if (
                    "default" !== o &&
                    Object.prototype.hasOwnProperty.call(t, o)
                  ) {
                    var a = s ? Object.getOwnPropertyDescriptor(t, o) : null;
                    a && (a.get || a.set)
                      ? Object.defineProperty(i, o, a)
                      : (i[o] = t[o]);
                  }
                return (i.default = t), n && n.set(t, i), i;
              }
            },
            355: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.default = o),
                (e.isBrowserMainThread = function () {
                  return o() && "undefined" != typeof document;
                });
              var r = i(n(17)),
                s = i(n(628));
              function o() {
                return (
                  !(
                    "object" ===
                      ("undefined" == typeof process
                        ? "undefined"
                        : (0, r.default)(process)) &&
                    "[object process]" === String(process) &&
                    !process.browser
                  ) || (0, s.default)()
                );
              }
            },
            628: (t, e, n) => {
              "use strict";
              var i = n(422);
              Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.default = function (t) {
                  if (
                    "undefined" != typeof window &&
                    "object" === (0, r.default)(window.process) &&
                    "renderer" === window.process.type
                  )
                    return !0;
                  if (
                    "undefined" != typeof process &&
                    "object" === (0, r.default)(process.versions) &&
                    Boolean(process.versions.electron)
                  )
                    return !0;
                  var e =
                      "object" ===
                        ("undefined" == typeof navigator
                          ? "undefined"
                          : (0, r.default)(navigator)) &&
                      "string" == typeof navigator.userAgent &&
                      navigator.userAgent,
                    n = t || e;
                  return !!(n && n.indexOf("Electron") >= 0);
                });
              var r = i(n(17));
            },
            521: () => {},
            307: () => {},
          },
          e = {};
        function n(i) {
          var r = e[i];
          if (void 0 !== r) return r.exports;
          var s = (e[i] = { exports: {} });
          return t[i](s, s.exports, n), s.exports;
        }
        (n.n = (t) => {
          var e = t && t.__esModule ? () => t.default : () => t;
          return n.d(e, { a: e }), e;
        }),
          (n.d = (t, e) => {
            for (var i in e)
              n.o(e, i) &&
                !n.o(t, i) &&
                Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
          }),
          (n.g = (function () {
            if ("object" == typeof globalThis) return globalThis;
            try {
              return this || new Function("return this")();
            } catch (t) {
              if ("object" == typeof window) return window;
            }
          })()),
          (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
          (n.r = (t) => {
            "undefined" != typeof Symbol &&
              Symbol.toStringTag &&
              Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
              Object.defineProperty(t, "__esModule", { value: !0 });
          });
        var i = {};
        (() => {
          "use strict";
          function t(t) {
            if (
              "undefined" != typeof window &&
              "object" == typeof window.process &&
              "renderer" === window.process.type
            )
              return !0;
            if (
              "undefined" != typeof process &&
              "object" == typeof process.versions &&
              Boolean(process.versions.electron)
            )
              return !0;
            const e =
                "object" == typeof navigator &&
                "string" == typeof navigator.userAgent &&
                navigator.userAgent,
              n = t || e;
            return !!(n && n.indexOf("Electron") >= 0);
          }
          function e() {
            return (
              !(
                "object" == typeof process &&
                "[object process]" === String(process) &&
                !process.browser
              ) || t()
            );
          }
          n.r(i), n.d(i, { initMap: () => _d });
          const r =
              "undefined" != typeof __VERSION__
                ? __VERSION__
                : "untranspiled source",
            s = e();
          class o {
            constructor(t, e, n = "sessionStorage") {
              (this.storage = (function (t) {
                try {
                  const e = window[t],
                    n = "__storage_test__";
                  return e.setItem(n, n), e.removeItem(n), e;
                } catch (t) {
                  return null;
                }
              })(n)),
                (this.id = t),
                (this.config = {}),
                Object.assign(this.config, e),
                this._loadConfiguration();
            }
            getConfiguration() {
              return this.config;
            }
            setConfiguration(t) {
              return (this.config = {}), this.updateConfiguration(t);
            }
            updateConfiguration(t) {
              if ((Object.assign(this.config, t), this.storage)) {
                const t = JSON.stringify(this.config);
                this.storage.setItem(this.id, t);
              }
              return this;
            }
            _loadConfiguration() {
              let t = {};
              if (this.storage) {
                const e = this.storage.getItem(this.id);
                t = e ? JSON.parse(e) : {};
              }
              return Object.assign(this.config, t), this;
            }
          }
          function a(t, e, n, i = 600) {
            const r = t.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
            t.width > i && (n = Math.min(n, i / t.width));
            const s = t.width * n,
              o = t.height * n,
              a = [
                "font-size:1px;",
                "padding:"
                  .concat(Math.floor(o / 2), "px ")
                  .concat(Math.floor(s / 2), "px;"),
                "line-height:".concat(o, "px;"),
                "background:url(".concat(r, ");"),
                "background-size:".concat(s, "px ").concat(o, "px;"),
                "color:transparent;",
              ].join("");
            return ["".concat(e, " %c+"), a];
          }
          const c = {
            BLACK: 30,
            RED: 31,
            GREEN: 32,
            YELLOW: 33,
            BLUE: 34,
            MAGENTA: 35,
            CYAN: 36,
            WHITE: 37,
            BRIGHT_BLACK: 90,
            BRIGHT_RED: 91,
            BRIGHT_GREEN: 92,
            BRIGHT_YELLOW: 93,
            BRIGHT_BLUE: 94,
            BRIGHT_MAGENTA: 95,
            BRIGHT_CYAN: 96,
            BRIGHT_WHITE: 97,
          };
          function l(t) {
            return "string" == typeof t ? c[t.toUpperCase()] || c.WHITE : t;
          }
          function h(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          const u = {
              self: "undefined" != typeof self && self,
              window: "undefined" != typeof window && window,
              global: void 0 !== n.g && n.g,
              document: "undefined" != typeof document && document,
              process: "object" == typeof process && process,
            },
            d = u.window || u.self || u.global,
            f = u.process || {};
          function p() {
            let t;
            if (s && d.performance) t = d.performance.now();
            else if (f.hrtime) {
              const e = f.hrtime();
              t = 1e3 * e[0] + e[1] / 1e6;
            } else t = Date.now();
            return t;
          }
          console;
          const g = {
              debug: (s && console.debug) || console.log,
              log: console.log,
              info: console.info,
              warn: console.warn,
              error: console.error,
            },
            m = { enabled: !0, level: 0 };
          function y() {}
          const _ = {},
            v = { once: !0 };
          function b(t) {
            for (const e in t) for (const n in t[e]) return n || "untitled";
            return "empty";
          }
          class w {
            constructor({ id: t } = { id: "" }) {
              (this.id = t),
                (this.VERSION = r),
                (this._startTs = p()),
                (this._deltaTs = p()),
                (this.LOG_THROTTLE_TIMEOUT = 0),
                (this._storage = new o("__probe-".concat(this.id, "__"), m)),
                (this.userData = {}),
                this.timeStamp("".concat(this.id, " started")),
                (function (t, e = ["constructor"]) {
                  const n = Object.getPrototypeOf(t),
                    i = Object.getOwnPropertyNames(n);
                  for (const n of i)
                    "function" == typeof t[n] &&
                      (e.find((t) => n === t) || (t[n] = t[n].bind(t)));
                })(this),
                Object.seal(this);
            }
            set level(t) {
              this.setLevel(t);
            }
            get level() {
              return this.getLevel();
            }
            isEnabled() {
              return this._storage.config.enabled;
            }
            getLevel() {
              return this._storage.config.level;
            }
            getTotal() {
              return Number((p() - this._startTs).toPrecision(10));
            }
            getDelta() {
              return Number((p() - this._deltaTs).toPrecision(10));
            }
            set priority(t) {
              this.level = t;
            }
            get priority() {
              return this.level;
            }
            getPriority() {
              return this.level;
            }
            enable(t = !0) {
              return this._storage.updateConfiguration({ enabled: t }), this;
            }
            setLevel(t) {
              return this._storage.updateConfiguration({ level: t }), this;
            }
            assert(t, e) {
              h(t, e);
            }
            warn(t) {
              return this._getLogFunction(0, t, g.warn, arguments, v);
            }
            error(t) {
              return this._getLogFunction(0, t, g.error, arguments);
            }
            deprecated(t, e) {
              return this.warn(
                "`"
                  .concat(
                    t,
                    "` is deprecated and will be removed in a later version. Use `"
                  )
                  .concat(e, "` instead")
              );
            }
            removed(t, e) {
              return this.error(
                "`"
                  .concat(t, "` has been removed. Use `")
                  .concat(e, "` instead")
              );
            }
            probe(t, e) {
              return this._getLogFunction(t, e, g.log, arguments, {
                time: !0,
                once: !0,
              });
            }
            log(t, e) {
              return this._getLogFunction(t, e, g.debug, arguments);
            }
            info(t, e) {
              return this._getLogFunction(t, e, console.info, arguments);
            }
            once(t, e) {
              return this._getLogFunction(
                t,
                e,
                g.debug || g.info,
                arguments,
                v
              );
            }
            table(t, e, n) {
              return e
                ? this._getLogFunction(t, e, console.table || y, n && [n], {
                    tag: b(e),
                  })
                : y;
            }
            image({
              logLevel: t,
              priority: e,
              image: i,
              message: r = "",
              scale: o = 1,
            }) {
              return this._shouldLog(t || e)
                ? s
                  ? (function ({ image: t, message: e = "", scale: n = 1 }) {
                      if ("string" == typeof t) {
                        const i = new Image();
                        return (
                          (i.onload = () => {
                            const t = a(i, e, n);
                            console.log(...t);
                          }),
                          (i.src = t),
                          y
                        );
                      }
                      const i = t.nodeName || "";
                      if ("img" === i.toLowerCase())
                        return console.log(...a(t, e, n)), y;
                      if ("canvas" === i.toLowerCase()) {
                        const i = new Image();
                        return (
                          (i.onload = () => console.log(...a(i, e, n))),
                          (i.src = t.toDataURL()),
                          y
                        );
                      }
                      return y;
                    })({ image: i, message: r, scale: o })
                  : (function ({ image: t, message: e = "", scale: i = 1 }) {
                      let r = null;
                      try {
                        r = n(307);
                      } catch (t) {}
                      return r
                        ? () =>
                            r(t, {
                              fit: "box",
                              width: "".concat(Math.round(80 * i), "%"),
                            }).then((t) => console.log(t))
                        : y;
                    })({ image: i, message: r, scale: o })
                : y;
            }
            settings() {
              console.table
                ? console.table(this._storage.config)
                : console.log(this._storage.config);
            }
            get(t) {
              return this._storage.config[t];
            }
            set(t, e) {
              this._storage.updateConfiguration({ [t]: e });
            }
            time(t, e) {
              return this._getLogFunction(
                t,
                e,
                console.time ? console.time : console.info
              );
            }
            timeEnd(t, e) {
              return this._getLogFunction(
                t,
                e,
                console.timeEnd ? console.timeEnd : console.info
              );
            }
            timeStamp(t, e) {
              return this._getLogFunction(t, e, console.timeStamp || y);
            }
            group(t, e, n = { collapsed: !1 }) {
              n = P({ logLevel: t, message: e, opts: n });
              const { collapsed: i } = n;
              return (
                (n.method =
                  (i ? console.groupCollapsed : console.group) || console.info),
                this._getLogFunction(n)
              );
            }
            groupCollapsed(t, e, n = {}) {
              return this.group(t, e, Object.assign({}, n, { collapsed: !0 }));
            }
            groupEnd(t) {
              return this._getLogFunction(t, "", console.groupEnd || y);
            }
            withGroup(t, e, n) {
              this.group(t, e)();
              try {
                n();
              } finally {
                this.groupEnd(t)();
              }
            }
            trace() {
              console.trace && console.trace();
            }
            _shouldLog(t) {
              return this.isEnabled() && this.getLevel() >= x(t);
            }
            _getLogFunction(t, e, n, i = [], r) {
              if (this._shouldLog(t)) {
                (r = P({ logLevel: t, message: e, args: i, opts: r })),
                  h((n = n || r.method)),
                  (r.total = this.getTotal()),
                  (r.delta = this.getDelta()),
                  (this._deltaTs = p());
                const o = r.tag || r.message;
                if (r.once) {
                  if (_[o]) return y;
                  _[o] = p();
                }
                return (
                  (e = (function (t, e, n) {
                    if ("string" == typeof e) {
                      const a = n.time
                        ? (function (t, e = 8) {
                            const n = Math.max(e - t.length, 0);
                            return "".concat(" ".repeat(n)).concat(t);
                          })(
                            (function (t) {
                              let e;
                              return (
                                (e =
                                  t < 10
                                    ? "".concat(t.toFixed(2), "ms")
                                    : t < 100
                                    ? "".concat(t.toFixed(1), "ms")
                                    : t < 1e3
                                    ? "".concat(t.toFixed(0), "ms")
                                    : "".concat((t / 1e3).toFixed(2), "s")),
                                e
                              );
                            })(n.total)
                          )
                        : "";
                      (i = e =
                        n.time
                          ? "".concat(t, ": ").concat(a, "  ").concat(e)
                          : "".concat(t, ": ").concat(e)),
                        (r = n.color),
                        (o = n.background),
                        s ||
                          "string" != typeof i ||
                          (r &&
                            ((r = l(r)),
                            (i = "[".concat(r, "m").concat(i, "[39m"))),
                          o &&
                            ((r = l(o)),
                            (i = "[".concat(o + 10, "m").concat(i, "[49m")))),
                        (e = i);
                    }
                    var i, r, o;
                    return e;
                  })(this.id, r.message, r)),
                  n.bind(console, e, ...r.args)
                );
              }
              return y;
            }
          }
          function x(t) {
            if (!t) return 0;
            let e;
            switch (typeof t) {
              case "number":
                e = t;
                break;
              case "object":
                e = t.logLevel || t.priority || 0;
                break;
              default:
                return 0;
            }
            return h(Number.isFinite(e) && e >= 0), e;
          }
          function P(t) {
            const { logLevel: e, message: n } = t;
            t.logLevel = x(e);
            const i = t.args ? Array.from(t.args) : [];
            for (; i.length && i.shift() !== n; );
            switch (((t.args = i), typeof e)) {
              case "string":
              case "function":
                void 0 !== n && i.unshift(n), (t.message = e);
                break;
              case "object":
                Object.assign(t, e);
            }
            "function" == typeof t.message && (t.message = t.message());
            const r = typeof t.message;
            return (
              h("string" === r || "object" === r), Object.assign(t, t.opts)
            );
          }
          w.VERSION = r;
          const E = new w({ id: "deck" }),
            A = {
              DEFAULT: -1,
              LNGLAT: 1,
              METER_OFFSETS: 2,
              LNGLAT_OFFSETS: 3,
              CARTESIAN: 0,
            };
          Object.defineProperty(A, "IDENTITY", {
            get: () =>
              E.deprecated(
                "COORDINATE_SYSTEM.IDENTITY",
                "COORDINATE_SYSTEM.CARTESIAN"
              )() || 0,
          });
          const T = {
              WEB_MERCATOR: 1,
              GLOBE: 2,
              WEB_MERCATOR_AUTO_OFFSET: 4,
              IDENTITY: 0,
            },
            S = { common: 0, meters: 1, pixels: 2 },
            M = {
              click: { handler: "onClick" },
              panstart: { handler: "onDragStart" },
              panmove: { handler: "onDrag" },
              panend: { handler: "onDragEnd" },
            },
            C = new w({ id: "luma.gl" });
          function L(t, e) {
            if (!t) throw new Error(e || "luma.gl: assertion failed.");
          }
          function O(t) {
            return (
              ("undefined" != typeof WebGLRenderingContext &&
                t instanceof WebGLRenderingContext) ||
              ("undefined" != typeof WebGL2RenderingContext &&
                t instanceof WebGL2RenderingContext) ||
              Boolean(t && Number.isFinite(t._version))
            );
          }
          function I(t) {
            return (
              ("undefined" != typeof WebGL2RenderingContext &&
                t instanceof WebGL2RenderingContext) ||
              Boolean(t && 2 === t._version)
            );
          }
          function R(t) {
            return L(O(t), "Invalid WebGLRenderingContext"), t;
          }
          function k(t) {
            return L(I(t), "Requires WebGL2"), t;
          }
          var F = n(395);
          const z = {};
          const j = function t(e) {
            const n = e.gl;
            (this.ext = e),
              (this.isAlive = !0),
              (this.hasBeenBound = !1),
              (this.elementArrayBuffer = null),
              (this.attribs = new Array(e.maxVertexAttribs));
            for (let e = 0; e < this.attribs.length; e++) {
              const i = new t.VertexAttrib(n);
              this.attribs[e] = i;
            }
            this.maxAttrib = 0;
          };
          (j.VertexAttrib = function (t) {
            (this.enabled = !1),
              (this.buffer = null),
              (this.size = 4),
              (this.type = 5126),
              (this.normalized = !1),
              (this.stride = 16),
              (this.offset = 0),
              (this.cached = ""),
              this.recache();
          }).prototype.recache = function () {
            this.cached = [
              this.size,
              this.type,
              this.normalized,
              this.stride,
              this.offset,
            ].join(":");
          };
          const B = function (t) {
            const e = this;
            (this.gl = t),
              (function (t) {
                const e = t.getError;
                t.getError = function () {
                  let n;
                  do {
                    (n = e.apply(t)), 0 !== n && (z[n] = !0);
                  } while (0 !== n);
                  for (n in z) if (z[n]) return delete z[n], parseInt(n, 10);
                  return 0;
                };
              })(t);
            const n = (this.original = {
              getParameter: t.getParameter,
              enableVertexAttribArray: t.enableVertexAttribArray,
              disableVertexAttribArray: t.disableVertexAttribArray,
              bindBuffer: t.bindBuffer,
              getVertexAttrib: t.getVertexAttrib,
              vertexAttribPointer: t.vertexAttribPointer,
            });
            (t.getParameter = function (t) {
              return t === e.VERTEX_ARRAY_BINDING_OES
                ? e.currentVertexArrayObject === e.defaultVertexArrayObject
                  ? null
                  : e.currentVertexArrayObject
                : n.getParameter.apply(this, arguments);
            }),
              (t.enableVertexAttribArray = function (t) {
                const i = e.currentVertexArrayObject;
                i.maxAttrib = Math.max(i.maxAttrib, t);
                const r = i.attribs[t];
                return (
                  (r.enabled = !0),
                  n.enableVertexAttribArray.apply(this, arguments)
                );
              }),
              (t.disableVertexAttribArray = function (t) {
                const i = e.currentVertexArrayObject;
                i.maxAttrib = Math.max(i.maxAttrib, t);
                const r = i.attribs[t];
                return (
                  (r.enabled = !1),
                  n.disableVertexAttribArray.apply(this, arguments)
                );
              }),
              (t.bindBuffer = function (t, i) {
                switch (t) {
                  case 34962:
                    e.currentArrayBuffer = i;
                    break;
                  case 34963:
                    e.currentVertexArrayObject.elementArrayBuffer = i;
                }
                return n.bindBuffer.apply(this, arguments);
              }),
              (t.getVertexAttrib = function (t, i) {
                const r = e.currentVertexArrayObject,
                  s = r.attribs[t];
                switch (i) {
                  case 34975:
                    return s.buffer;
                  case 34338:
                    return s.enabled;
                  case 34339:
                    return s.size;
                  case 34340:
                    return s.stride;
                  case 34341:
                    return s.type;
                  case 34922:
                    return s.normalized;
                  default:
                    return n.getVertexAttrib.apply(this, arguments);
                }
              }),
              (t.vertexAttribPointer = function (t, i, r, s, o, a) {
                const c = e.currentVertexArrayObject;
                c.maxAttrib = Math.max(c.maxAttrib, t);
                const l = c.attribs[t];
                return (
                  (l.buffer = e.currentArrayBuffer),
                  (l.size = i),
                  (l.type = r),
                  (l.normalized = s),
                  (l.stride = o),
                  (l.offset = a),
                  l.recache(),
                  n.vertexAttribPointer.apply(this, arguments)
                );
              }),
              t.instrumentExtension &&
                t.instrumentExtension(this, "OES_vertex_array_object"),
              t.canvas &&
                t.canvas.addEventListener(
                  "webglcontextrestored",
                  () => {
                    F.CO.console &&
                      F.CO.console.log &&
                      F.CO.console.log(
                        "OESVertexArrayObject emulation library context restored"
                      ),
                      e.reset_();
                  },
                  !0
                ),
              this.reset_();
          };
          (B.prototype.VERTEX_ARRAY_BINDING_OES = 34229),
            (B.prototype.reset_ = function () {
              if (void 0 !== this.vertexArrayObjects)
                for (let t = 0; t < this.vertexArrayObjects.length; ++t)
                  this.vertexArrayObjects.isAlive = !1;
              const t = this.gl;
              (this.maxVertexAttribs = t.getParameter(34921)),
                (this.defaultVertexArrayObject = new j(this)),
                (this.currentVertexArrayObject = null),
                (this.currentArrayBuffer = null),
                (this.vertexArrayObjects = [this.defaultVertexArrayObject]),
                this.bindVertexArrayOES(null);
            }),
            (B.prototype.createVertexArrayOES = function () {
              const t = new j(this);
              return this.vertexArrayObjects.push(t), t;
            }),
            (B.prototype.deleteVertexArrayOES = function (t) {
              (t.isAlive = !1),
                this.vertexArrayObjects.splice(
                  this.vertexArrayObjects.indexOf(t),
                  1
                ),
                this.currentVertexArrayObject === t &&
                  this.bindVertexArrayOES(null);
            }),
            (B.prototype.isVertexArrayOES = function (t) {
              return !!(
                t &&
                t instanceof j &&
                t.hasBeenBound &&
                t.ext === this
              );
            }),
            (B.prototype.bindVertexArrayOES = function (t) {
              const e = this.gl;
              if (t && !t.isAlive)
                return (
                  (n =
                    "bindVertexArrayOES: attempt to bind deleted arrayObject"),
                  (z[1282] = !0),
                  void (
                    void 0 !== n &&
                    ((i = n),
                    F.CO.console && F.CO.console.error && F.CO.console.error(i))
                  )
                );
              var n, i;
              const r = this.original,
                s = this.currentVertexArrayObject;
              (this.currentVertexArrayObject =
                t || this.defaultVertexArrayObject),
                (this.currentVertexArrayObject.hasBeenBound = !0);
              const o = this.currentVertexArrayObject;
              if (s === o) return;
              (s && o.elementArrayBuffer === s.elementArrayBuffer) ||
                r.bindBuffer.call(e, 34963, o.elementArrayBuffer);
              let a = this.currentArrayBuffer;
              const c = Math.max(s ? s.maxAttrib : 0, o.maxAttrib);
              for (let t = 0; t <= c; t++) {
                const n = o.attribs[t],
                  i = s ? s.attribs[t] : null;
                if (
                  ((s && n.enabled === i.enabled) ||
                    (n.enabled
                      ? r.enableVertexAttribArray.call(e, t)
                      : r.disableVertexAttribArray.call(e, t)),
                  n.enabled)
                ) {
                  let o = !1;
                  (s && n.buffer === i.buffer) ||
                    (a !== n.buffer &&
                      (r.bindBuffer.call(e, 34962, n.buffer), (a = n.buffer)),
                    (o = !0)),
                    (o || n.cached !== i.cached) &&
                      r.vertexAttribPointer.call(
                        e,
                        t,
                        n.size,
                        n.type,
                        n.normalized,
                        n.stride,
                        n.offset
                      );
                }
              }
              this.currentArrayBuffer !== a &&
                r.bindBuffer.call(e, 34962, this.currentArrayBuffer);
            });
          const D = "OES_element_index",
            N = "WEBGL_draw_buffers",
            U = "WEBGL_debug_renderer_info",
            V = (t) => (I(t) ? void 0 : 0),
            G = {
              3074: (t) => (I(t) ? void 0 : 36064),
              35723: (t) => (I(t) ? void 0 : 4352),
              35977: V,
              32937: V,
              36795: (t, e) => {
                const n = I(t)
                  ? t.getExtension("EXT_disjoint_timer_query_webgl2")
                  : t.getExtension("EXT_disjoint_timer_query");
                return n && n.GPU_DISJOINT_EXT ? e(n.GPU_DISJOINT_EXT) : 0;
              },
              37445: (t, e) => {
                const n = t.getExtension(U);
                return e((n && n.UNMASKED_VENDOR_WEBGL) || 7936);
              },
              37446: (t, e) => {
                const n = t.getExtension(U);
                return e((n && n.UNMASKED_RENDERER_WEBGL) || 7937);
              },
              34047: (t, e) => {
                const n = t.luma.extensions.EXT_texture_filter_anisotropic;
                return n ? e(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
              },
              32883: V,
              35071: V,
              37447: V,
              36063: (t, e) => {
                if (!I(t)) {
                  const n = t.getExtension(N);
                  return n ? e(n.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
                }
              },
              35379: V,
              35374: V,
              35377: V,
              34852: (t) => {
                if (!I(t)) {
                  const e = t.getExtension(N);
                  return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0;
                }
              },
              36203: (t) => (t.getExtension(D) ? 2147483647 : 65535),
              33001: (t) => (t.getExtension(D) ? 16777216 : 65535),
              33e3: (t) => 16777216,
              37157: V,
              35373: V,
              35657: V,
              36183: V,
              37137: V,
              34045: V,
              35978: V,
              35979: V,
              35968: V,
              35376: V,
              35375: V,
              35659: V,
              37154: V,
              35371: V,
              35658: V,
              35076: V,
              35077: V,
              35380: V,
            },
            W = "ANGLE_instanced_arrays",
            H = {
              OES_vertex_array_object: {
                meta: { suffix: "OES" },
                createVertexArray: () => {
                  L(
                    !1,
                    "VertexArray requires WebGL2 or OES_vertex_array_object extension"
                  );
                },
                deleteVertexArray: () => {},
                bindVertexArray: () => {},
                isVertexArray: () => !1,
              },
              [W]: {
                meta: { suffix: "ANGLE" },
                vertexAttribDivisor(t, e) {
                  L(0 === e, "WebGL instanced rendering not supported");
                },
                drawElementsInstanced: () => {},
                drawArraysInstanced: () => {},
              },
              WEBGL_draw_buffers: {
                meta: { suffix: "WEBGL" },
                drawBuffers: () => {
                  L(!1);
                },
              },
              EXT_disjoint_timer_query: {
                meta: { suffix: "EXT" },
                createQuery: () => {
                  L(!1);
                },
                deleteQuery: () => {
                  L(!1);
                },
                beginQuery: () => {
                  L(!1);
                },
                endQuery: () => {},
                getQuery(t, e) {
                  return this.getQueryObject(t, e);
                },
                getQueryParameter(t, e) {
                  return this.getQueryObject(t, e);
                },
                getQueryObject: () => {},
              },
            },
            $ = {
              readBuffer: (t, e, n) => {
                I(t) && e(n);
              },
              getVertexAttrib: (t, e, n, i) => {
                const { webgl2: r, ext: s } = (function (t, e) {
                  return {
                    webgl2: I(t),
                    ext: t.getExtension("ANGLE_instanced_arrays"),
                  };
                })(t);
                let o;
                switch (i) {
                  case 35069:
                    o = !!r && void 0;
                    break;
                  case 35070:
                    o = r || s ? void 0 : 0;
                }
                return void 0 !== o ? o : e(n, i);
              },
              getProgramParameter: (t, e, n, i) => {
                if (!I(t))
                  switch (i) {
                    case 35967:
                      return 35981;
                    case 35971:
                    case 35382:
                      return 0;
                  }
                return e(n, i);
              },
              getInternalformatParameter: (t, e, n, i, r) =>
                I(t) || 32937 !== r
                  ? t.getInternalformatParameter(n, i, r)
                  : new Int32Array([0]),
              getTexParameter(t, e, n, i) {
                if (34046 === i) {
                  const { extensions: e } = t.luma,
                    n = e.EXT_texture_filter_anisotropic;
                  i = (n && n.TEXTURE_MAX_ANISOTROPY_EXT) || 34046;
                }
                return e(n, i);
              },
              getParameter: function (t, e, n) {
                const i = G[n],
                  r = "function" == typeof i ? i(t, e, n) : i;
                return void 0 !== r ? r : e(n);
              },
              hint: (t, e, n, i) => e(n, i),
            };
          function X(t, { extension: e, target: n, target2: i }) {
            const r = H[e];
            L(r);
            const { meta: s = {} } = r,
              { suffix: o = "" } = s,
              a = t.getExtension(e);
            for (const e of Object.keys(r)) {
              const s = `${e}${o}`;
              let c = null;
              "meta" === e ||
                "function" == typeof t[e] ||
                (a && "function" == typeof a[s]
                  ? (c = (...t) => a[s](...t))
                  : "function" == typeof r[e] && (c = r[e].bind(n))),
                c && ((n[e] = c), (i[e] = c));
            }
          }
          (void 0 !== n.g ? n.g : window).polyfillContext = function (t) {
            t.luma = t.luma || {};
            const { luma: e } = t;
            return (
              e.polyfilled ||
                ((function (t) {
                  if ("function" == typeof t.createVertexArray) return;
                  const e = t.getSupportedExtensions;
                  t.getSupportedExtensions = function () {
                    const t = e.call(this) || [];
                    return (
                      t.indexOf("OES_vertex_array_object") < 0 &&
                        t.push("OES_vertex_array_object"),
                      t
                    );
                  };
                  const n = t.getExtension;
                  t.getExtension = function (e) {
                    return (
                      n.call(this, e) ||
                      ("OES_vertex_array_object" !== e
                        ? null
                        : (t.__OESVertexArrayObject ||
                            (this.__OESVertexArrayObject = new B(this)),
                          this.__OESVertexArrayObject))
                    );
                  };
                })(t),
                (function (t) {
                  t.luma.extensions = {};
                  const e = t.getSupportedExtensions() || [];
                  for (const n of e) t.luma[n] = t.getExtension(n);
                })(t),
                (function (t, e) {
                  for (const n of Object.getOwnPropertyNames(e))
                    "overrides" !== n &&
                      X(t, { extension: n, target: t.luma, target2: t });
                })(t, H),
                (function (t, { target: e, target2: n }) {
                  Object.keys($).forEach((i) => {
                    if ("function" == typeof $[i]) {
                      const r = t[i] ? t[i].bind(t) : () => {},
                        s = $[i].bind(null, t, r);
                      (e[i] = s), (n[i] = s);
                    }
                  });
                })(t, { target: e, target2: t }),
                (e.polyfilled = !0)),
              t
            );
          };
          const Y = {
              3042: !1,
              32773: new Float32Array([0, 0, 0, 0]),
              32777: 32774,
              34877: 32774,
              32969: 1,
              32968: 0,
              32971: 1,
              32970: 0,
              3106: new Float32Array([0, 0, 0, 0]),
              3107: [!0, !0, !0, !0],
              2884: !1,
              2885: 1029,
              2929: !1,
              2931: 1,
              2932: 513,
              2928: new Float32Array([0, 1]),
              2930: !0,
              3024: !0,
              36006: null,
              2886: 2305,
              33170: 4352,
              2849: 1,
              32823: !1,
              32824: 0,
              10752: 0,
              32938: 1,
              32939: !1,
              3089: !1,
              3088: new Int32Array([0, 0, 1024, 1024]),
              2960: !1,
              2961: 0,
              2968: 4294967295,
              36005: 4294967295,
              2962: 519,
              2967: 0,
              2963: 4294967295,
              34816: 519,
              36003: 0,
              36004: 4294967295,
              2964: 7680,
              2965: 7680,
              2966: 7680,
              34817: 7680,
              34818: 7680,
              34819: 7680,
              2978: [0, 0, 1024, 1024],
              3333: 4,
              3317: 4,
              37440: !1,
              37441: !1,
              37443: 37444,
              35723: 4352,
              36010: null,
              35977: !1,
              3330: 0,
              3332: 0,
              3331: 0,
              3314: 0,
              32878: 0,
              3316: 0,
              3315: 0,
              32877: 0,
            },
            q = (t, e, n) => (e ? t.enable(n) : t.disable(n)),
            Z = (t, e, n) => t.hint(n, e),
            K = (t, e, n) => t.pixelStorei(n, e);
          function J(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t);
          }
          const Q = {
            3042: q,
            32773: (t, e) => t.blendColor(...e),
            32777: "blendEquation",
            34877: "blendEquation",
            32969: "blendFunc",
            32968: "blendFunc",
            32971: "blendFunc",
            32970: "blendFunc",
            3106: (t, e) => t.clearColor(...e),
            3107: (t, e) => t.colorMask(...e),
            2884: q,
            2885: (t, e) => t.cullFace(e),
            2929: q,
            2931: (t, e) => t.clearDepth(e),
            2932: (t, e) => t.depthFunc(e),
            2928: (t, e) => t.depthRange(...e),
            2930: (t, e) => t.depthMask(e),
            3024: q,
            35723: Z,
            36006: (t, e) => {
              const n = I(t) ? 36009 : 36160;
              return t.bindFramebuffer(n, e);
            },
            2886: (t, e) => t.frontFace(e),
            33170: Z,
            2849: (t, e) => t.lineWidth(e),
            32823: q,
            32824: "polygonOffset",
            10752: "polygonOffset",
            35977: q,
            32938: "sampleCoverage",
            32939: "sampleCoverage",
            3089: q,
            3088: (t, e) => t.scissor(...e),
            2960: q,
            2961: (t, e) => t.clearStencil(e),
            2968: (t, e) => t.stencilMaskSeparate(1028, e),
            36005: (t, e) => t.stencilMaskSeparate(1029, e),
            2962: "stencilFuncFront",
            2967: "stencilFuncFront",
            2963: "stencilFuncFront",
            34816: "stencilFuncBack",
            36003: "stencilFuncBack",
            36004: "stencilFuncBack",
            2964: "stencilOpFront",
            2965: "stencilOpFront",
            2966: "stencilOpFront",
            34817: "stencilOpBack",
            34818: "stencilOpBack",
            34819: "stencilOpBack",
            2978: (t, e) => t.viewport(...e),
            3333: K,
            3317: K,
            37440: K,
            37441: K,
            37443: K,
            3330: K,
            3332: K,
            3331: K,
            36010: (t, e) => t.bindFramebuffer(36008, e),
            3314: K,
            32878: K,
            3316: K,
            3315: K,
            32877: K,
            framebuffer: (t, e) => {
              const n = e && "handle" in e ? e.handle : e;
              return t.bindFramebuffer(36160, n);
            },
            blend: (t, e) => (e ? t.enable(3042) : t.disable(3042)),
            blendColor: (t, e) => t.blendColor(...e),
            blendEquation: (t, e) => {
              (e = J(e) ? e : [e, e]), t.blendEquationSeparate(...e);
            },
            blendFunc: (t, e) => {
              (e = J(e) && 2 === e.length ? [...e, ...e] : e),
                t.blendFuncSeparate(...e);
            },
            clearColor: (t, e) => t.clearColor(...e),
            clearDepth: (t, e) => t.clearDepth(e),
            clearStencil: (t, e) => t.clearStencil(e),
            colorMask: (t, e) => t.colorMask(...e),
            cull: (t, e) => (e ? t.enable(2884) : t.disable(2884)),
            cullFace: (t, e) => t.cullFace(e),
            depthTest: (t, e) => (e ? t.enable(2929) : t.disable(2929)),
            depthFunc: (t, e) => t.depthFunc(e),
            depthMask: (t, e) => t.depthMask(e),
            depthRange: (t, e) => t.depthRange(...e),
            dither: (t, e) => (e ? t.enable(3024) : t.disable(3024)),
            derivativeHint: (t, e) => {
              t.hint(35723, e);
            },
            frontFace: (t, e) => t.frontFace(e),
            mipmapHint: (t, e) => t.hint(33170, e),
            lineWidth: (t, e) => t.lineWidth(e),
            polygonOffsetFill: (t, e) =>
              e ? t.enable(32823) : t.disable(32823),
            polygonOffset: (t, e) => t.polygonOffset(...e),
            sampleCoverage: (t, e) => t.sampleCoverage(...e),
            scissorTest: (t, e) => (e ? t.enable(3089) : t.disable(3089)),
            scissor: (t, e) => t.scissor(...e),
            stencilTest: (t, e) => (e ? t.enable(2960) : t.disable(2960)),
            stencilMask: (t, e) => {
              e = J(e) ? e : [e, e];
              const [n, i] = e;
              t.stencilMaskSeparate(1028, n), t.stencilMaskSeparate(1029, i);
            },
            stencilFunc: (t, e) => {
              e = J(e) && 3 === e.length ? [...e, ...e] : e;
              const [n, i, r, s, o, a] = e;
              t.stencilFuncSeparate(1028, n, i, r),
                t.stencilFuncSeparate(1029, s, o, a);
            },
            stencilOp: (t, e) => {
              e = J(e) && 3 === e.length ? [...e, ...e] : e;
              const [n, i, r, s, o, a] = e;
              t.stencilOpSeparate(1028, n, i, r),
                t.stencilOpSeparate(1029, s, o, a);
            },
            viewport: (t, e) => t.viewport(...e),
          };
          function tt(t, e, n) {
            return void 0 !== e[t] ? e[t] : n[t];
          }
          const et = {
              blendEquation: (t, e, n) =>
                t.blendEquationSeparate(tt(32777, e, n), tt(34877, e, n)),
              blendFunc: (t, e, n) =>
                t.blendFuncSeparate(
                  tt(32969, e, n),
                  tt(32968, e, n),
                  tt(32971, e, n),
                  tt(32970, e, n)
                ),
              polygonOffset: (t, e, n) =>
                t.polygonOffset(tt(32824, e, n), tt(10752, e, n)),
              sampleCoverage: (t, e, n) =>
                t.sampleCoverage(tt(32938, e, n), tt(32939, e, n)),
              stencilFuncFront: (t, e, n) =>
                t.stencilFuncSeparate(
                  1028,
                  tt(2962, e, n),
                  tt(2967, e, n),
                  tt(2963, e, n)
                ),
              stencilFuncBack: (t, e, n) =>
                t.stencilFuncSeparate(
                  1029,
                  tt(34816, e, n),
                  tt(36003, e, n),
                  tt(36004, e, n)
                ),
              stencilOpFront: (t, e, n) =>
                t.stencilOpSeparate(
                  1028,
                  tt(2964, e, n),
                  tt(2965, e, n),
                  tt(2966, e, n)
                ),
              stencilOpBack: (t, e, n) =>
                t.stencilOpSeparate(
                  1029,
                  tt(34817, e, n),
                  tt(34818, e, n),
                  tt(34819, e, n)
                ),
            },
            nt = {
              enable: (t, e) => t({ [e]: !0 }),
              disable: (t, e) => t({ [e]: !1 }),
              pixelStorei: (t, e, n) => t({ [e]: n }),
              hint: (t, e, n) => t({ [e]: n }),
              bindFramebuffer: (t, e, n) => {
                switch (e) {
                  case 36160:
                    return t({ 36006: n, 36010: n });
                  case 36009:
                    return t({ 36006: n });
                  case 36008:
                    return t({ 36010: n });
                  default:
                    return null;
                }
              },
              blendColor: (t, e, n, i, r) =>
                t({ 32773: new Float32Array([e, n, i, r]) }),
              blendEquation: (t, e) => t({ 32777: e, 34877: e }),
              blendEquationSeparate: (t, e, n) => t({ 32777: e, 34877: n }),
              blendFunc: (t, e, n) =>
                t({ 32969: e, 32968: n, 32971: e, 32970: n }),
              blendFuncSeparate: (t, e, n, i, r) =>
                t({ 32969: e, 32968: n, 32971: i, 32970: r }),
              clearColor: (t, e, n, i, r) =>
                t({ 3106: new Float32Array([e, n, i, r]) }),
              clearDepth: (t, e) => t({ 2931: e }),
              clearStencil: (t, e) => t({ 2961: e }),
              colorMask: (t, e, n, i, r) => t({ 3107: [e, n, i, r] }),
              cullFace: (t, e) => t({ 2885: e }),
              depthFunc: (t, e) => t({ 2932: e }),
              depthRange: (t, e, n) => t({ 2928: new Float32Array([e, n]) }),
              depthMask: (t, e) => t({ 2930: e }),
              frontFace: (t, e) => t({ 2886: e }),
              lineWidth: (t, e) => t({ 2849: e }),
              polygonOffset: (t, e, n) => t({ 32824: e, 10752: n }),
              sampleCoverage: (t, e, n) => t({ 32938: e, 32939: n }),
              scissor: (t, e, n, i, r) =>
                t({ 3088: new Int32Array([e, n, i, r]) }),
              stencilMask: (t, e) => t({ 2968: e, 36005: e }),
              stencilMaskSeparate: (t, e, n) =>
                t({ [1028 === e ? 2968 : 36005]: n }),
              stencilFunc: (t, e, n, i) =>
                t({ 2962: e, 2967: n, 2963: i, 34816: e, 36003: n, 36004: i }),
              stencilFuncSeparate: (t, e, n, i, r) =>
                t({
                  [1028 === e ? 2962 : 34816]: n,
                  [1028 === e ? 2967 : 36003]: i,
                  [1028 === e ? 2963 : 36004]: r,
                }),
              stencilOp: (t, e, n, i) =>
                t({ 2964: e, 2965: n, 2966: i, 34817: e, 34818: n, 34819: i }),
              stencilOpSeparate: (t, e, n, i, r) =>
                t({
                  [1028 === e ? 2964 : 34817]: n,
                  [1028 === e ? 2965 : 34818]: i,
                  [1028 === e ? 2966 : 34819]: r,
                }),
              viewport: (t, e, n, i, r) => t({ 2978: [e, n, i, r] }),
            },
            it = (t, e) => t.isEnabled(e),
            rt = {
              3042: it,
              2884: it,
              2929: it,
              3024: it,
              32823: it,
              32926: it,
              32928: it,
              3089: it,
              2960: it,
              35977: it,
            };
          function st(t) {
            for (const e in t) return !1;
            return !0;
          }
          function ot(t, e) {
            if (t === e) return !0;
            const n = Array.isArray(t) || ArrayBuffer.isView(t),
              i = Array.isArray(e) || ArrayBuffer.isView(e);
            if (n && i && t.length === e.length) {
              for (let n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;
              return !0;
            }
            return !1;
          }
          function at(t, e) {
            const n = t[e].bind(t);
            (t[e] = function (...e) {
              const i = e[0];
              return i in t.state.cache && t.state.enable
                ? t.state.cache[i]
                : n(...e);
            }),
              Object.defineProperty(t[e], "name", {
                value: `${e}-from-cache`,
                configurable: !1,
              });
          }
          function ct(t, e, n) {
            const i = t[e].bind(t);
            (t[e] = function (...e) {
              const { valueChanged: r, oldValue: s } = n(
                t.state._updateCache,
                ...e
              );
              return r && i(...e), s;
            }),
              Object.defineProperty(t[e], "name", {
                value: `${e}-to-cache`,
                configurable: !1,
              });
          }
          class lt {
            constructor(t, { copyState: e = !1, log: n = () => {} } = {}) {
              (this.gl = t),
                (this.program = null),
                (this.stateStack = []),
                (this.enable = !0),
                (this.cache = e ? ft(t) : Object.assign({}, Y)),
                (this.log = n),
                (this._updateCache = this._updateCache.bind(this)),
                Object.seal(this);
            }
            push(t = {}) {
              this.stateStack.push({});
            }
            pop() {
              L(this.stateStack.length > 0);
              const t = this.stateStack[this.stateStack.length - 1];
              dt(this.gl, t), this.stateStack.pop();
            }
            _updateCache(t) {
              let e,
                n = !1;
              const i =
                this.stateStack.length > 0 &&
                this.stateStack[this.stateStack.length - 1];
              for (const r in t) {
                L(void 0 !== r);
                const s = t[r],
                  o = this.cache[r];
                ot(s, o) ||
                  ((n = !0),
                  (e = o),
                  i && !(r in i) && (i[r] = o),
                  (this.cache[r] = s));
              }
              return { valueChanged: n, oldValue: e };
            }
          }
          function ht(t, e = {}) {
            const { enable: i = !0, copyState: r } = e;
            if ((L(void 0 !== r), !t.state)) {
              const e = void 0 !== n.g ? n.g : window,
                { polyfillContext: i } = e;
              i && i(t),
                (t.state = new lt(t, { copyState: r })),
                (function (t) {
                  const e = t.useProgram.bind(t);
                  t.useProgram = function (n) {
                    t.state.program !== n && (e(n), (t.state.program = n));
                  };
                })(t);
              for (const e in nt) ct(t, e, nt[e]);
              at(t, "getParameter"), at(t, "isEnabled");
            }
            return (t.state.enable = i), t;
          }
          function ut(t) {
            L(t.state), t.state.pop();
          }
          function dt(t, e) {
            if ((L(O(t), "setParameters requires a WebGL context"), st(e)))
              return;
            const n = {};
            for (const i in e) {
              const r = Number(i),
                s = Q[i];
              s && ("string" == typeof s ? (n[s] = !0) : s(t, e[i], r));
            }
            const i = t.state && t.state.cache;
            if (i) for (const r in n) (0, et[r])(t, e, i);
          }
          function ft(t, e) {
            if ("number" == typeof (e = e || Y)) {
              const n = e,
                i = rt[n];
              return i ? i(t, n) : t.getParameter(n);
            }
            const n = Array.isArray(e) ? e : Object.keys(e),
              i = {};
            for (const e of n) {
              const n = rt[e];
              i[e] = n ? n(t, Number(e)) : t.getParameter(Number(e));
            }
            return i;
          }
          function pt(t, e, n) {
            if (st(e)) return n(t);
            const { nocatch: i = !0 } = e;
            let r;
            if (
              ((function (t) {
                t.state || ht(t, { copyState: !1 }), t.state.push();
              })(t),
              dt(t, e),
              i)
            )
              (r = n(t)), ut(t);
            else
              try {
                r = n(t);
              } finally {
                ut(t);
              }
            return r;
          }
          function gt(t) {
            const { luma: e } = t;
            if (t.canvas && e) {
              const { clientWidth: n } = e.canvasSizeInfo;
              return n ? t.drawingBufferWidth / n : 1;
            }
            return 1;
          }
          function mt(t, e, n = !0) {
            return (function (t, e, n, i, r) {
              const s = yt(t[0], e, n);
              let o = _t(t[1], e, i, r),
                a = yt(t[0] + 1, e, n);
              const c = a === n - 1 ? a : a - 1;
              let l;
              return (
                (a = _t(t[1] + 1, e, i, r)),
                r
                  ? ((a = 0 === a ? a : a + 1), (l = o), (o = a))
                  : (l = a === i - 1 ? a : a - 1),
                {
                  x: s,
                  y: o,
                  width: Math.max(c - s + 1, 1),
                  height: Math.max(l - o + 1, 1),
                }
              );
            })(e, gt(t), t.drawingBufferWidth, t.drawingBufferHeight, n);
          }
          function yt(t, e, n) {
            return Math.min(Math.round(t * e), n - 1);
          }
          function _t(t, e, n, i) {
            return i
              ? Math.max(0, n - 1 - Math.round(t * e))
              : Math.min(Math.round(t * e), n - 1);
          }
          const vt = (0, F.jU)(),
            bt = vt && "undefined" != typeof document,
            wt = {
              webgl2: !0,
              webgl1: !0,
              throwOnError: !0,
              manageState: !0,
              canvas: null,
              debug: !1,
              width: 800,
              height: 600,
            };
          function xt(t = {}) {
            L(
              vt,
              "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"
            ),
              (t = Object.assign({}, wt, t));
            const { width: e, height: n } = t;
            function i(e) {
              if (t.throwOnError) throw new Error(e);
              return console.error(e), null;
            }
            let r;
            t.onError = i;
            const { canvas: s } = t,
              o = (function ({
                canvas: t,
                width: e = 800,
                height: n = 600,
                onError: i,
              }) {
                let r;
                return (
                  "string" == typeof t
                    ? ((bt && "complete" === document.readyState) ||
                        i(
                          `createGLContext called on canvas '${t}' before page was loaded`
                        ),
                      (r = document.getElementById(t)))
                    : t
                    ? (r = t)
                    : ((r = document.createElement("canvas")),
                      (r.id = "lumagl-canvas"),
                      (r.style.width = Number.isFinite(e) ? `${e}px` : "100%"),
                      (r.style.height = Number.isFinite(n) ? `${n}px` : "100%"),
                      document.body.insertBefore(r, document.body.firstChild)),
                  r
                );
              })({ canvas: s, width: e, height: n, onError: i });
            return (
              (r = (function (t, e) {
                const { onError: n } = e;
                let i = null;
                const r = (t) => (i = t.statusMessage || i);
                t.addEventListener("webglcontextcreationerror", r, !1);
                const { webgl1: s = !0, webgl2: o = !0 } = e;
                let a = null;
                return (
                  o &&
                    ((a = a || t.getContext("webgl2", e)),
                    (a = a || t.getContext("experimental-webgl2", e))),
                  s &&
                    ((a = a || t.getContext("webgl", e)),
                    (a = a || t.getContext("experimental-webgl", e))),
                  t.removeEventListener("webglcontextcreationerror", r, !1),
                  a
                    ? (e.onContextLost &&
                        t.addEventListener(
                          "webglcontextlost",
                          e.onContextLost,
                          !1
                        ),
                      e.onContextRestored &&
                        t.addEventListener(
                          "webglcontextrestored",
                          e.onContextRestored,
                          !1
                        ),
                      a)
                    : n(
                        `Failed to create ${
                          o && !s ? "WebGL2" : "WebGL"
                        } context: ${i || "Unknown error"}`
                      )
                );
              })(o, t)),
              r
                ? ((r = Pt(r, t)),
                  (function (t) {
                    const e = I(t) ? "WebGL2" : "WebGL1",
                      n = (function (t) {
                        const e = t.getParameter(7936),
                          n = t.getParameter(7937),
                          i = t.getExtension("WEBGL_debug_renderer_info");
                        return {
                          vendor:
                            (i &&
                              t.getParameter(
                                i.UNMASKED_VENDOR_WEBGL || 7936
                              )) ||
                            e,
                          renderer:
                            (i &&
                              t.getParameter(
                                i.UNMASKED_RENDERER_WEBGL || 7937
                              )) ||
                            n,
                          vendorMasked: e,
                          rendererMasked: n,
                          version: t.getParameter(7938),
                          shadingLanguageVersion: t.getParameter(35724),
                        };
                      })(t),
                      i = n ? `(${n.vendor},${n.renderer})` : "",
                      r = t.debug ? " debug" : "";
                    C.info(1, `${e}${r} context ${i}`)();
                  })(r),
                  r)
                : null
            );
          }
          function Pt(t, e = {}) {
            if (!t || t._instrumented) return t;
            (t._version =
              t._version ||
              (function (t) {
                return "undefined" != typeof WebGL2RenderingContext &&
                  t instanceof WebGL2RenderingContext
                  ? 2
                  : 1;
              })(t)),
              (t.luma = t.luma || {}),
              (t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {}),
              (e = Object.assign({}, wt, e));
            const { manageState: n, debug: i } = e;
            return (
              n && ht(t, { copyState: !1, log: (...t) => C.log(1, ...t)() }),
              vt &&
                i &&
                (F.CO.makeDebugContext
                  ? ((t = F.CO.makeDebugContext(t, e)),
                    (C.level = Math.max(C.level, 1)))
                  : C.warn(
                      'WebGL debug mode not activated. import "@luma.gl/debug" to enable.'
                    )()),
              (t._instrumented = !0),
              t
            );
          }
          function Et() {
            let t;
            if ("undefined" != typeof window && window.performance)
              t = window.performance.now();
            else if ("undefined" != typeof process && process.hrtime) {
              const e = process.hrtime();
              t = 1e3 * e[0] + e[1] / 1e6;
            } else t = Date.now();
            return t;
          }
          class At {
            constructor(t, e) {
              (this.name = t),
                (this.type = e),
                (this.sampleSize = 1),
                this.reset();
            }
            setSampleSize(t) {
              return (this.sampleSize = t), this;
            }
            incrementCount() {
              return this.addCount(1), this;
            }
            decrementCount() {
              return this.subtractCount(1), this;
            }
            addCount(t) {
              return (
                (this._count += t), this._samples++, this._checkSampling(), this
              );
            }
            subtractCount(t) {
              return (
                (this._count -= t), this._samples++, this._checkSampling(), this
              );
            }
            addTime(t) {
              return (
                (this._time += t),
                (this.lastTiming = t),
                this._samples++,
                this._checkSampling(),
                this
              );
            }
            timeStart() {
              return (this._startTime = Et()), (this._timerPending = !0), this;
            }
            timeEnd() {
              return this._timerPending
                ? (this.addTime(Et() - this._startTime),
                  (this._timerPending = !1),
                  this._checkSampling(),
                  this)
                : this;
            }
            getSampleAverageCount() {
              return this.sampleSize > 0
                ? this.lastSampleCount / this.sampleSize
                : 0;
            }
            getSampleAverageTime() {
              return this.sampleSize > 0
                ? this.lastSampleTime / this.sampleSize
                : 0;
            }
            getSampleHz() {
              return this.lastSampleTime > 0
                ? this.sampleSize / (this.lastSampleTime / 1e3)
                : 0;
            }
            getAverageCount() {
              return this.samples > 0 ? this.count / this.samples : 0;
            }
            getAverageTime() {
              return this.samples > 0 ? this.time / this.samples : 0;
            }
            getHz() {
              return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
            }
            reset() {
              return (
                (this.time = 0),
                (this.count = 0),
                (this.samples = 0),
                (this.lastTiming = 0),
                (this.lastSampleTime = 0),
                (this.lastSampleCount = 0),
                (this._count = 0),
                (this._time = 0),
                (this._samples = 0),
                (this._startTime = 0),
                (this._timerPending = !1),
                this
              );
            }
            _checkSampling() {
              this._samples === this.sampleSize &&
                ((this.lastSampleTime = this._time),
                (this.lastSampleCount = this._count),
                (this.count += this._count),
                (this.time += this._time),
                (this.samples += this._samples),
                (this._time = 0),
                (this._count = 0),
                (this._samples = 0));
            }
          }
          class Tt {
            constructor({ id: t, stats: e }) {
              (this.id = t),
                (this.stats = {}),
                this._initializeStats(e),
                Object.seal(this);
            }
            get(t, e = "count") {
              return this._getOrCreate({ name: t, type: e });
            }
            get size() {
              return Object.keys(this.stats).length;
            }
            reset() {
              for (const t in this.stats) this.stats[t].reset();
              return this;
            }
            forEach(t) {
              for (const e in this.stats) t(this.stats[e]);
            }
            getTable() {
              const t = {};
              return (
                this.forEach((e) => {
                  t[e.name] = {
                    time: e.time || 0,
                    count: e.count || 0,
                    average: e.getAverageTime() || 0,
                    hz: e.getHz() || 0,
                  };
                }),
                t
              );
            }
            _initializeStats(t = []) {
              t.forEach((t) => this._getOrCreate(t));
            }
            _getOrCreate(t) {
              if (!t || !t.name) return null;
              const { name: e, type: n } = t;
              return (
                this.stats[e] ||
                  (this.stats[e] = t instanceof At ? t : new At(e, n)),
                this.stats[e]
              );
            }
          }
          const St = "8.5.10",
            Mt = new (class {
              constructor() {
                this.stats = new Map();
              }
              get(t) {
                return (
                  this.stats.has(t) || this.stats.set(t, new Tt({ id: t })),
                  this.stats.get(t)
                );
              }
            })();
          if (F.CO.luma && F.CO.luma.VERSION !== St)
            throw new Error(
              `luma.gl - multiple VERSIONs detected: ${F.CO.luma.VERSION} vs 8.5.10`
            );
          function Ct(t, e) {
            if (!t) throw new Error(e || "luma.gl: assertion failed.");
          }
          function Lt(t, e) {
            if ("string" != typeof e) return e;
            const n = Number(e);
            if (!isNaN(n)) return n;
            const i = t[(e = e.replace(/^.*\./, ""))];
            return Ct(void 0 !== i, `Accessing undefined constant GL.${e}`), i;
          }
          function Ot(t, e) {
            e = Number(e);
            for (const n in t) if (t[n] === e) return `GL.${n}`;
            return String(e);
          }
          F.CO.luma ||
            ((0, F.jU)() &&
              C.log(
                1,
                "luma.gl 8.5.10 - set luma.log.level=1 (or higher) to trace rendering"
              )(),
            (F.CO.luma = F.CO.luma || {
              VERSION: St,
              version: St,
              log: C,
              stats: Mt,
              globals: { modules: {}, nodeIO: {} },
            })),
            F.CO.luma;
          const It = {};
          function Rt(t = "id") {
            return (It[t] = It[t] || 1), `${t}-${It[t]++}`;
          }
          function kt(t) {
            return (
              Ct("number" == typeof t, "Input must be a number"),
              t && 0 == (t & (t - 1))
            );
          }
          function Ft(t) {
            let e = !0;
            for (const n in t) {
              e = !1;
              break;
            }
            return e;
          }
          function zt(t, e, n, i) {
            const r = `See luma.gl ${n} Upgrade Guide at https://luma.gl/docs/upgrade-guide`,
              s = Object.getPrototypeOf(t);
            i.forEach((t) => {
              s.methodName ||
                (s[t] = () => {
                  throw (
                    (C.removed(`Calling removed method ${e}.${t}: `, r)(),
                    new Error(t))
                  );
                });
            });
          }
          const jt = "Resource subclass must define virtual methods";
          class Bt {
            constructor(t, e = {}) {
              R(t);
              const { id: n, userData: i = {} } = e;
              (this.gl = t),
                (this.gl2 = t),
                (this.id = n || Rt(this.constructor.name)),
                (this.userData = i),
                (this._bound = !1),
                (this._handle = e.handle),
                void 0 === this._handle &&
                  (this._handle = this._createHandle()),
                (this.byteLength = 0),
                this._addStats();
            }
            toString() {
              return `${this.constructor.name}(${this.id})`;
            }
            get handle() {
              return this._handle;
            }
            delete({ deleteChildren: t = !1 } = {}) {
              const e = this._handle && this._deleteHandle(this._handle);
              return (
                this._handle && this._removeStats(),
                (this._handle = null),
                e && t && e.filter(Boolean).forEach((t) => t.delete()),
                this
              );
            }
            bind(t = this.handle) {
              if ("function" != typeof t) return this._bindHandle(t), this;
              let e;
              return (
                this._bound
                  ? (e = t())
                  : (this._bindHandle(this.handle),
                    (this._bound = !0),
                    (e = t()),
                    (this._bound = !1),
                    this._bindHandle(null)),
                e
              );
            }
            unbind() {
              this.bind(null);
            }
            getParameter(t, e = {}) {
              Ct((t = Lt(this.gl, t)));
              const n = (this.constructor.PARAMETERS || {})[t];
              if (n) {
                const t = I(this.gl);
                if (
                  ("webgl2" in n && !t) ||
                  ("extension" in n && !this.gl.getExtension(n.extension))
                ) {
                  const e = n.webgl1,
                    i = "webgl2" in n ? n.webgl2 : n.webgl1;
                  return t ? i : e;
                }
              }
              return this._getParameter(t, e);
            }
            getParameters(t = {}) {
              const { parameters: e, keys: n } = t,
                i = this.constructor.PARAMETERS || {},
                r = I(this.gl),
                s = {},
                o = e || Object.keys(i);
              for (const e of o) {
                const o = i[e];
                if (
                  o &&
                  (!("webgl2" in o) || r) &&
                  (!("extension" in o) || this.gl.getExtension(o.extension))
                ) {
                  const i = n ? Ot(this.gl, e) : e;
                  (s[i] = this.getParameter(e, t)),
                    n && "GLenum" === o.type && (s[i] = Ot(this.gl, s[i]));
                }
              }
              return s;
            }
            setParameter(t, e) {
              Ct((t = Lt(this.gl, t)));
              const n = (this.constructor.PARAMETERS || {})[t];
              if (n) {
                const t = I(this.gl);
                if (
                  ("webgl2" in n && !t) ||
                  ("extension" in n && !this.gl.getExtension(n.extension))
                )
                  throw new Error("Parameter not available on this platform");
                "GLenum" === n.type && (e = Lt(e));
              }
              return this._setParameter(t, e), this;
            }
            setParameters(t) {
              for (const e in t) this.setParameter(e, t[e]);
              return this;
            }
            stubRemovedMethods(t, e, n) {
              return zt(this, t, e, n);
            }
            initialize(t) {}
            _createHandle() {
              throw new Error(jt);
            }
            _deleteHandle() {
              throw new Error(jt);
            }
            _bindHandle(t) {
              throw new Error(jt);
            }
            _getOptsFromHandle() {
              throw new Error(jt);
            }
            _getParameter(t, e) {
              throw new Error(jt);
            }
            _setParameter(t, e) {
              throw new Error(jt);
            }
            _context() {
              return (this.gl.luma = this.gl.luma || {}), this.gl.luma;
            }
            _addStats() {
              const t = this.constructor.name,
                e = Mt.get("Resource Counts");
              e.get("Resources Created").incrementCount(),
                e.get(`${t}s Created`).incrementCount(),
                e.get(`${t}s Active`).incrementCount();
            }
            _removeStats() {
              const t = this.constructor.name;
              Mt.get("Resource Counts").get(`${t}s Active`).decrementCount();
            }
            _trackAllocatedMemory(t, e = this.constructor.name) {
              const n = Mt.get("Memory Usage");
              n.get("GPU Memory").addCount(t),
                n.get(`${e} Memory`).addCount(t),
                (this.byteLength = t);
            }
            _trackDeallocatedMemory(t = this.constructor.name) {
              const e = Mt.get("Memory Usage");
              e.get("GPU Memory").subtractCount(this.byteLength),
                e.get(`${t} Memory`).subtractCount(this.byteLength),
                (this.byteLength = 0);
            }
          }
          function Dt(t) {
            switch (ArrayBuffer.isView(t) ? t.constructor : t) {
              case Float32Array:
                return 5126;
              case Uint16Array:
                return 5123;
              case Uint32Array:
                return 5125;
              case Uint8Array:
              case Uint8ClampedArray:
                return 5121;
              case Int8Array:
                return 5120;
              case Int16Array:
                return 5122;
              case Int32Array:
                return 5124;
              default:
                throw new Error(
                  "Failed to deduce GL constant from typed array"
                );
            }
          }
          function Nt(t, { clamped: e = !0 } = {}) {
            switch (t) {
              case 5126:
                return Float32Array;
              case 5123:
              case 33635:
              case 32819:
              case 32820:
                return Uint16Array;
              case 5125:
                return Uint32Array;
              case 5121:
                return e ? Uint8ClampedArray : Uint8Array;
              case 5120:
                return Int8Array;
              case 5122:
                return Int16Array;
              case 5124:
                return Int32Array;
              default:
                throw new Error(
                  "Failed to deduce typed array type from GL constant"
                );
            }
          }
          function Ut({ data: t, width: e, height: n }) {
            const i = Math.round(e / 2),
              r = Math.round(n / 2),
              s = new Uint8Array(i * r * 4);
            for (let n = 0; n < r; n++)
              for (let r = 0; r < i; r++)
                for (let o = 0; o < 4; o++)
                  s[4 * (n * i + r) + o] = t[4 * (2 * n * e + 2 * r) + o];
            return { data: s, width: i, height: r };
          }
          function Vt(t, e, n) {
            const {
              removedProps: i = {},
              deprecatedProps: r = {},
              replacedProps: s = {},
            } = n;
            for (const n in i)
              if (n in e) {
                const e = i[n] ? `${t}.${i[n]}` : "N/A";
                C.removed(`${t}.${n}`, e)();
              }
            for (const n in r)
              if (n in e) {
                const e = r[n];
                C.deprecated(`${t}.${n}`, `${t}.${e}`)();
              }
            let o = null;
            for (const n in s)
              if (n in e) {
                const i = s[n];
                C.deprecated(`${t}.${n}`, `${t}.${i}`)(),
                  (o = o || Object.assign({}, e)),
                  (o[i] = e[n]),
                  delete o[n];
              }
            return o || e;
          }
          const Gt = {
              offset: 0,
              stride: 0,
              type: 5126,
              size: 1,
              divisor: 0,
              normalized: !1,
              integer: !1,
            },
            Wt = {
              deprecatedProps: { instanced: "divisor", isInstanced: "divisor" },
            };
          class Ht {
            static getBytesPerElement(t) {
              return Nt(t.type || 5126).BYTES_PER_ELEMENT;
            }
            static getBytesPerVertex(t) {
              return Ct(t.size), Nt(t.type || 5126).BYTES_PER_ELEMENT * t.size;
            }
            static resolve(...t) {
              return new Ht(...[Gt, ...t]);
            }
            constructor(...t) {
              t.forEach((t) => this._assign(t)), Object.freeze(this);
            }
            toString() {
              return JSON.stringify(this);
            }
            get BYTES_PER_ELEMENT() {
              return Ht.getBytesPerElement(this);
            }
            get BYTES_PER_VERTEX() {
              return Ht.getBytesPerVertex(this);
            }
            _assign(t = {}) {
              return (
                void 0 !== (t = Vt("Accessor", t, Wt)).type &&
                  ((this.type = t.type),
                  (5124 !== t.type && 5125 !== t.type) || (this.integer = !0)),
                void 0 !== t.size && (this.size = t.size),
                void 0 !== t.offset && (this.offset = t.offset),
                void 0 !== t.stride && (this.stride = t.stride),
                void 0 !== t.normalized && (this.normalized = t.normalized),
                void 0 !== t.integer && (this.integer = t.integer),
                void 0 !== t.divisor && (this.divisor = t.divisor),
                void 0 !== t.buffer && (this.buffer = t.buffer),
                void 0 !== t.index &&
                  ("boolean" == typeof t.index
                    ? (this.index = t.index ? 1 : 0)
                    : (this.index = t.index)),
                void 0 !== t.instanced && (this.divisor = t.instanced ? 1 : 0),
                void 0 !== t.isInstanced &&
                  (this.divisor = t.isInstanced ? 1 : 0),
                this
              );
            }
          }
          const $t = {
              offset: "accessor.offset",
              stride: "accessor.stride",
              type: "accessor.type",
              size: "accessor.size",
              divisor: "accessor.divisor",
              normalized: "accessor.normalized",
              integer: "accessor.integer",
              instanced: "accessor.divisor",
              isInstanced: "accessor.divisor",
            },
            Xt = {
              removedProps: {},
              replacedProps: { bytes: "byteLength" },
              deprecatedProps: $t,
            },
            Yt = { removedProps: $t };
          class qt extends Bt {
            constructor(t, e = {}) {
              super(t, e),
                this.stubRemovedMethods("Buffer", "v6.0", [
                  "layout",
                  "setLayout",
                  "getIndexedParameter",
                ]),
                (this.target = e.target || (this.gl.webgl2 ? 36662 : 34962)),
                this.initialize(e),
                Object.seal(this);
            }
            getElementCount(t = this.accessor) {
              return Math.round(this.byteLength / Ht.getBytesPerElement(t));
            }
            getVertexCount(t = this.accessor) {
              return Math.round(this.byteLength / Ht.getBytesPerVertex(t));
            }
            initialize(t = {}) {
              return (
                ArrayBuffer.isView(t) && (t = { data: t }),
                Number.isFinite(t) && (t = { byteLength: t }),
                (t = Vt("Buffer", t, Xt)),
                (this.usage = t.usage || 35044),
                (this.debugData = null),
                this.setAccessor(Object.assign({}, t, t.accessor)),
                t.data
                  ? this._setData(t.data, t.offset, t.byteLength)
                  : this._setByteLength(t.byteLength || 0),
                this
              );
            }
            setProps(t) {
              return (
                "accessor" in (t = Vt("Buffer", t, Yt)) &&
                  this.setAccessor(t.accessor),
                this
              );
            }
            setAccessor(t) {
              return (
                delete (t = Object.assign({}, t)).buffer,
                (this.accessor = new Ht(t)),
                this
              );
            }
            reallocate(t) {
              return t > this.byteLength
                ? (this._setByteLength(t), !0)
                : ((this.bytesUsed = t), !1);
            }
            setData(t) {
              return this.initialize(t);
            }
            subData(t) {
              ArrayBuffer.isView(t) && (t = { data: t });
              const { data: e, offset: n = 0, srcOffset: i = 0 } = t,
                r = t.byteLength || t.length;
              Ct(e);
              const s = this.gl.webgl2 ? 36663 : this.target;
              return (
                this.gl.bindBuffer(s, this.handle),
                0 !== i || void 0 !== r
                  ? (k(this.gl), this.gl.bufferSubData(this.target, n, e, i, r))
                  : this.gl.bufferSubData(s, n, e),
                this.gl.bindBuffer(s, null),
                (this.debugData = null),
                this._inferType(e),
                this
              );
            }
            copyData({
              sourceBuffer: t,
              readOffset: e = 0,
              writeOffset: n = 0,
              size: i,
            }) {
              const { gl: r } = this;
              return (
                k(r),
                r.bindBuffer(36662, t.handle),
                r.bindBuffer(36663, this.handle),
                r.copyBufferSubData(36662, 36663, e, n, i),
                r.bindBuffer(36662, null),
                r.bindBuffer(36663, null),
                (this.debugData = null),
                this
              );
            }
            getData({
              dstData: t = null,
              srcByteOffset: e = 0,
              dstOffset: n = 0,
              length: i = 0,
            } = {}) {
              k(this.gl);
              const r = Nt(this.accessor.type || 5126, { clamped: !1 }),
                s = this._getAvailableElementCount(e),
                o = n;
              let a, c;
              t
                ? ((c = t.length), (a = c - o))
                : ((a = Math.min(s, i || s)), (c = o + a));
              const l = Math.min(s, a);
              return (
                Ct((i = i || l) <= l),
                (t = t || new r(c)),
                this.gl.bindBuffer(36662, this.handle),
                this.gl.getBufferSubData(36662, e, t, n, i),
                this.gl.bindBuffer(36662, null),
                t
              );
            }
            bind({
              target: t = this.target,
              index: e = this.accessor && this.accessor.index,
              offset: n = 0,
              size: i,
            } = {}) {
              return (
                35345 === t || 35982 === t
                  ? void 0 !== i
                    ? this.gl.bindBufferRange(t, e, this.handle, n, i)
                    : (Ct(0 === n), this.gl.bindBufferBase(t, e, this.handle))
                  : this.gl.bindBuffer(t, this.handle),
                this
              );
            }
            unbind({
              target: t = this.target,
              index: e = this.accessor && this.accessor.index,
            } = {}) {
              return (
                35345 === t || 35982 === t
                  ? this.gl.bindBufferBase(t, e, null)
                  : this.gl.bindBuffer(t, null),
                this
              );
            }
            getDebugData() {
              return this.debugData
                ? { data: this.debugData, changed: !1 }
                : ((this.debugData = this.getData({
                    length: Math.min(10, this.byteLength),
                  })),
                  { data: this.debugData, changed: !0 });
            }
            invalidateDebugData() {
              this.debugData = null;
            }
            _setData(t, e = 0, n = t.byteLength + e) {
              Ct(ArrayBuffer.isView(t)), this._trackDeallocatedMemory();
              const i = this._getTarget();
              this.gl.bindBuffer(i, this.handle),
                this.gl.bufferData(i, n, this.usage),
                this.gl.bufferSubData(i, e, t),
                this.gl.bindBuffer(i, null),
                (this.debugData = t.slice(0, 10)),
                (this.bytesUsed = n),
                this._trackAllocatedMemory(n);
              const r = Dt(t);
              return (
                Ct(r),
                this.setAccessor(new Ht(this.accessor, { type: r })),
                this
              );
            }
            _setByteLength(t, e = this.usage) {
              Ct(t >= 0), this._trackDeallocatedMemory();
              let n = t;
              0 === t && (n = new Float32Array(0));
              const i = this._getTarget();
              return (
                this.gl.bindBuffer(i, this.handle),
                this.gl.bufferData(i, n, e),
                this.gl.bindBuffer(i, null),
                (this.usage = e),
                (this.debugData = null),
                (this.bytesUsed = t),
                this._trackAllocatedMemory(t),
                this
              );
            }
            _getTarget() {
              return this.gl.webgl2 ? 36663 : this.target;
            }
            _getAvailableElementCount(t) {
              const e =
                t /
                Nt(this.accessor.type || 5126, { clamped: !1 })
                  .BYTES_PER_ELEMENT;
              return this.getElementCount() - e;
            }
            _inferType(t) {
              this.accessor.type ||
                this.setAccessor(new Ht(this.accessor, { type: Dt(t) }));
            }
            _createHandle() {
              return this.gl.createBuffer();
            }
            _deleteHandle() {
              this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory();
            }
            _getParameter(t) {
              this.gl.bindBuffer(this.target, this.handle);
              const e = this.gl.getBufferParameter(this.target, t);
              return this.gl.bindBuffer(this.target, null), e;
            }
            get type() {
              return (
                C.deprecated("Buffer.type", "Buffer.accessor.type")(),
                this.accessor.type
              );
            }
            get bytes() {
              return (
                C.deprecated("Buffer.bytes", "Buffer.byteLength")(),
                this.byteLength
              );
            }
            setByteLength(t) {
              return (
                C.deprecated("setByteLength", "reallocate")(),
                this.reallocate(t)
              );
            }
            updateAccessor(t) {
              return (
                C.deprecated(
                  "updateAccessor(...)",
                  "setAccessor(new Accessor(buffer.accessor, ...)"
                )(),
                (this.accessor = new Ht(this.accessor, t)),
                this
              );
            }
          }
          const Zt = {
              6407: { dataFormat: 6407, types: [5121, 33635] },
              6408: { dataFormat: 6408, types: [5121, 32819, 32820] },
              6406: { dataFormat: 6406, types: [5121] },
              6409: { dataFormat: 6409, types: [5121] },
              6410: { dataFormat: 6410, types: [5121] },
              33326: { dataFormat: 6403, types: [5126], gl2: !0 },
              33328: { dataFormat: 33319, types: [5126], gl2: !0 },
              34837: { dataFormat: 6407, types: [5126], gl2: !0 },
              34836: { dataFormat: 6408, types: [5126], gl2: !0 },
            },
            Kt = {
              6403: 1,
              36244: 1,
              33319: 2,
              33320: 2,
              6407: 3,
              36248: 3,
              6408: 4,
              36249: 4,
              6402: 1,
              34041: 1,
              6406: 1,
              6409: 1,
              6410: 2,
            },
            Jt = {
              5126: 4,
              5125: 4,
              5124: 4,
              5123: 2,
              5122: 2,
              5131: 2,
              5120: 1,
              5121: 1,
            },
            Qt = [9729, 9728],
            te = F.CO.WebGLBuffer || function () {};
          class ee extends Bt {
            static isSupported(t, e = {}) {
              const { format: n, linearFiltering: i } = e;
              let r = !0;
              return (
                n &&
                  ((r =
                    r &&
                    (function (t, e) {
                      const n = Zt[e];
                      if (!n) return !1;
                      if (void 0 === n.gl1 && void 0 === n.gl2) return !0;
                      const i = (I(t) && n.gl2) || n.gl1;
                      return "string" == typeof i ? t.getExtension(i) : i;
                    })(t, n)),
                  (r =
                    r &&
                    (!i ||
                      (function (t, e) {
                        const n = Zt[e];
                        switch (n && n.types[0]) {
                          case 5126:
                            return t.getExtension("OES_texture_float_linear");
                          case 5131:
                            return t.getExtension(
                              "OES_texture_half_float_linear"
                            );
                          default:
                            return !0;
                        }
                      })(t, n)))),
                r
              );
            }
            constructor(t, e) {
              const { id: n = Rt("texture"), handle: i, target: r } = e;
              super(t, { id: n, handle: i }),
                (this.target = r),
                (this.textureUnit = void 0),
                (this.loaded = !1),
                (this.width = void 0),
                (this.height = void 0),
                (this.depth = void 0),
                (this.format = void 0),
                (this.type = void 0),
                (this.dataFormat = void 0),
                (this.border = void 0),
                (this.textureUnit = void 0),
                (this.mipmaps = void 0);
            }
            toString() {
              return `Texture(${this.id},${this.width}x${this.height})`;
            }
            initialize(t = {}) {
              let e = t.data;
              if (e instanceof Promise)
                return (
                  e.then((e) =>
                    this.initialize(
                      Object.assign({}, t, { pixels: e, data: e })
                    )
                  ),
                  this
                );
              const n =
                "undefined" != typeof HTMLVideoElement &&
                e instanceof HTMLVideoElement;
              if (n && e.readyState < HTMLVideoElement.HAVE_METADATA)
                return (
                  (this._video = null),
                  e.addEventListener("loadeddata", () => this.initialize(t)),
                  this
                );
              const {
                pixels: i = null,
                format: r = 6408,
                border: s = 0,
                recreate: o = !1,
                parameters: a = {},
                pixelStore: c = {},
                textureUnit: l,
              } = t;
              e || (e = i);
              let {
                width: h,
                height: u,
                dataFormat: d,
                type: f,
                compressed: p = !1,
                mipmaps: g = !0,
              } = t;
              const { depth: m = 0 } = t;
              return (
                ({
                  width: h,
                  height: u,
                  compressed: p,
                  dataFormat: d,
                  type: f,
                } = this._deduceParameters({
                  format: r,
                  type: f,
                  dataFormat: d,
                  compressed: p,
                  data: e,
                  width: h,
                  height: u,
                })),
                (this.width = h),
                (this.height = u),
                (this.depth = m),
                (this.format = r),
                (this.type = f),
                (this.dataFormat = d),
                (this.border = s),
                (this.textureUnit = l),
                Number.isFinite(this.textureUnit) &&
                  (this.gl.activeTexture(33984 + this.textureUnit),
                  this.gl.bindTexture(this.target, this.handle)),
                g &&
                  this._isNPOT() &&
                  (C.warn(
                    `texture: ${this} is Non-Power-Of-Two, disabling mipmaping`
                  )(),
                  (g = !1),
                  this._updateForNPOT(a)),
                (this.mipmaps = g),
                this.setImageData({
                  data: e,
                  width: h,
                  height: u,
                  depth: m,
                  format: r,
                  type: f,
                  dataFormat: d,
                  border: s,
                  mipmaps: g,
                  parameters: c,
                  compressed: p,
                }),
                g && this.generateMipmap(),
                this.setParameters(a),
                o && (this.data = e),
                n &&
                  (this._video = {
                    video: e,
                    parameters: a,
                    lastTime:
                      e.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA
                        ? e.currentTime
                        : -1,
                  }),
                this
              );
            }
            update() {
              if (this._video) {
                const { video: t, parameters: e, lastTime: n } = this._video;
                if (
                  n === t.currentTime ||
                  t.readyState < HTMLVideoElement.HAVE_CURRENT_DATA
                )
                  return;
                this.setSubImageData({ data: t, parameters: e }),
                  this.mipmaps && this.generateMipmap(),
                  (this._video.lastTime = t.currentTime);
              }
            }
            resize({ height: t, width: e, mipmaps: n = !1 }) {
              return e !== this.width || t !== this.height
                ? this.initialize({
                    width: e,
                    height: t,
                    format: this.format,
                    type: this.type,
                    dataFormat: this.dataFormat,
                    border: this.border,
                    mipmaps: n,
                  })
                : this;
            }
            generateMipmap(t = {}) {
              return this._isNPOT()
                ? (C.warn(
                    `texture: ${this} is Non-Power-Of-Two, disabling mipmaping`
                  )(),
                  this)
                : ((this.mipmaps = !0),
                  this.gl.bindTexture(this.target, this.handle),
                  pt(this.gl, t, () => {
                    this.gl.generateMipmap(this.target);
                  }),
                  this.gl.bindTexture(this.target, null),
                  this);
            }
            setImageData(t) {
              this._trackDeallocatedMemory("Texture");
              const {
                target: e = this.target,
                pixels: n = null,
                level: i = 0,
                format: r = this.format,
                border: s = this.border,
                offset: o = 0,
                parameters: a = {},
              } = t;
              let {
                data: c = null,
                type: l = this.type,
                width: h = this.width,
                height: u = this.height,
                dataFormat: d = this.dataFormat,
                compressed: f = !1,
              } = t;
              c || (c = n),
                ({
                  type: l,
                  dataFormat: d,
                  compressed: f,
                  width: h,
                  height: u,
                } = this._deduceParameters({
                  format: r,
                  type: l,
                  dataFormat: d,
                  compressed: f,
                  data: c,
                  width: h,
                  height: u,
                }));
              const { gl: p } = this;
              p.bindTexture(this.target, this.handle);
              let g,
                m = null;
              if (
                (({ data: c, dataType: m } = this._getDataType({
                  data: c,
                  compressed: f,
                })),
                pt(this.gl, a, () => {
                  switch (m) {
                    case "null":
                      p.texImage2D(e, i, r, h, u, s, d, l, c);
                      break;
                    case "typed-array":
                      p.texImage2D(e, i, r, h, u, s, d, l, c, o);
                      break;
                    case "buffer":
                      (g = k(p)),
                        g.bindBuffer(35052, c.handle || c),
                        g.texImage2D(e, i, r, h, u, s, d, l, o),
                        g.bindBuffer(35052, null);
                      break;
                    case "browser-object":
                      I(p)
                        ? p.texImage2D(e, i, r, h, u, s, d, l, c)
                        : p.texImage2D(e, i, r, d, l, c);
                      break;
                    case "compressed":
                      for (const [t, n] of c.entries())
                        p.compressedTexImage2D(
                          e,
                          t,
                          n.format,
                          n.width,
                          n.height,
                          s,
                          n.data
                        );
                      break;
                    default:
                      Ct(!1, "Unknown image data type");
                  }
                }),
                c && c.byteLength)
              )
                this._trackAllocatedMemory(c.byteLength, "Texture");
              else {
                const t = Kt[this.dataFormat] || 4,
                  e = Jt[this.type] || 1;
                this._trackAllocatedMemory(
                  this.width * this.height * t * e,
                  "Texture"
                );
              }
              return (this.loaded = !0), this;
            }
            setSubImageData({
              target: t = this.target,
              pixels: e = null,
              data: n = null,
              x: i = 0,
              y: r = 0,
              width: s = this.width,
              height: o = this.height,
              level: a = 0,
              format: c = this.format,
              type: l = this.type,
              dataFormat: h = this.dataFormat,
              compressed: u = !1,
              offset: d = 0,
              border: f = this.border,
              parameters: p = {},
            }) {
              if (
                (({
                  type: l,
                  dataFormat: h,
                  compressed: u,
                  width: s,
                  height: o,
                } = this._deduceParameters({
                  format: c,
                  type: l,
                  dataFormat: h,
                  compressed: u,
                  data: n,
                  width: s,
                  height: o,
                })),
                Ct(
                  0 === this.depth,
                  "texSubImage not supported for 3D textures"
                ),
                n || (n = e),
                n && n.data)
              ) {
                const t = n;
                (n = t.data), (s = t.shape[0]), (o = t.shape[1]);
              }
              n instanceof qt && (n = n.handle),
                this.gl.bindTexture(this.target, this.handle),
                pt(this.gl, p, () => {
                  if (u)
                    this.gl.compressedTexSubImage2D(t, a, i, r, s, o, c, n);
                  else if (null === n)
                    this.gl.texSubImage2D(t, a, i, r, s, o, h, l, null);
                  else if (ArrayBuffer.isView(n))
                    this.gl.texSubImage2D(t, a, i, r, s, o, h, l, n, d);
                  else if (n instanceof te) {
                    const e = k(this.gl);
                    e.bindBuffer(35052, n),
                      e.texSubImage2D(t, a, i, r, s, o, h, l, d),
                      e.bindBuffer(35052, null);
                  } else
                    I(this.gl)
                      ? k(this.gl).texSubImage2D(t, a, i, r, s, o, h, l, n)
                      : this.gl.texSubImage2D(t, a, i, r, h, l, n);
                }),
                this.gl.bindTexture(this.target, null);
            }
            copyFramebuffer(t = {}) {
              return (
                C.error(
                  "Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})"
                )(),
                null
              );
            }
            getActiveUnit() {
              return this.gl.getParameter(34016) - 33984;
            }
            bind(t = this.textureUnit) {
              const { gl: e } = this;
              return (
                void 0 !== t &&
                  ((this.textureUnit = t), e.activeTexture(33984 + t)),
                e.bindTexture(this.target, this.handle),
                t
              );
            }
            unbind(t = this.textureUnit) {
              const { gl: e } = this;
              return (
                void 0 !== t &&
                  ((this.textureUnit = t), e.activeTexture(33984 + t)),
                e.bindTexture(this.target, null),
                t
              );
            }
            _getDataType({ data: t, compressed: e = !1 }) {
              return e
                ? { data: t, dataType: "compressed" }
                : null === t
                ? { data: t, dataType: "null" }
                : ArrayBuffer.isView(t)
                ? { data: t, dataType: "typed-array" }
                : t instanceof qt
                ? { data: t.handle, dataType: "buffer" }
                : t instanceof te
                ? { data: t, dataType: "buffer" }
                : { data: t, dataType: "browser-object" };
            }
            _deduceParameters(t) {
              const { format: e, data: n } = t;
              let {
                width: i,
                height: r,
                dataFormat: s,
                type: o,
                compressed: a,
              } = t;
              const c = Zt[e];
              return (
                (s = s || (c && c.dataFormat)),
                (o = o || (c && c.types[0])),
                (a = a || (c && c.compressed)),
                ({ width: i, height: r } = this._deduceImageSize(n, i, r)),
                {
                  dataFormat: s,
                  type: o,
                  compressed: a,
                  width: i,
                  height: r,
                  format: e,
                  data: n,
                }
              );
            }
            _deduceImageSize(t, e, n) {
              let i;
              return (
                (i =
                  "undefined" != typeof ImageData && t instanceof ImageData
                    ? { width: t.width, height: t.height }
                    : "undefined" != typeof HTMLImageElement &&
                      t instanceof HTMLImageElement
                    ? { width: t.naturalWidth, height: t.naturalHeight }
                    : ("undefined" != typeof HTMLCanvasElement &&
                        t instanceof HTMLCanvasElement) ||
                      ("undefined" != typeof ImageBitmap &&
                        t instanceof ImageBitmap)
                    ? { width: t.width, height: t.height }
                    : "undefined" != typeof HTMLVideoElement &&
                      t instanceof HTMLVideoElement
                    ? { width: t.videoWidth, height: t.videoHeight }
                    : t
                    ? { width: e, height: n }
                    : { width: e >= 0 ? e : 1, height: n >= 0 ? n : 1 }),
                Ct(i, "Could not deduced texture size"),
                Ct(
                  void 0 === e || i.width === e,
                  "Deduced texture width does not match supplied width"
                ),
                Ct(
                  void 0 === n || i.height === n,
                  "Deduced texture height does not match supplied height"
                ),
                i
              );
            }
            _createHandle() {
              return this.gl.createTexture();
            }
            _deleteHandle() {
              this.gl.deleteTexture(this.handle),
                this._trackDeallocatedMemory("Texture");
            }
            _getParameter(t) {
              switch (t) {
                case 4096:
                  return this.width;
                case 4097:
                  return this.height;
                default:
                  this.gl.bindTexture(this.target, this.handle);
                  const e = this.gl.getTexParameter(this.target, t);
                  return this.gl.bindTexture(this.target, null), e;
              }
            }
            _setParameter(t, e) {
              switch (
                (this.gl.bindTexture(this.target, this.handle),
                (e = this._getNPOTParam(t, e)),
                t)
              ) {
                case 33082:
                case 33083:
                  this.gl.texParameterf(this.handle, t, e);
                  break;
                case 4096:
                case 4097:
                  Ct(!1);
                  break;
                default:
                  this.gl.texParameteri(this.target, t, e);
              }
              return this.gl.bindTexture(this.target, null), this;
            }
            _isNPOT() {
              return !(
                I(this.gl) ||
                !this.width ||
                !this.height ||
                (kt(this.width) && kt(this.height))
              );
            }
            _updateForNPOT(t) {
              void 0 === t[this.gl.TEXTURE_MIN_FILTER] &&
                (t[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR),
                void 0 === t[this.gl.TEXTURE_WRAP_S] &&
                  (t[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE),
                void 0 === t[this.gl.TEXTURE_WRAP_T] &&
                  (t[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE);
            }
            _getNPOTParam(t, e) {
              if (this._isNPOT())
                switch (t) {
                  case 10241:
                    -1 === Qt.indexOf(e) && (e = 9729);
                    break;
                  case 10242:
                  case 10243:
                    33071 !== e && (e = 33071);
                }
              return e;
            }
          }
          class ne extends ee {
            static isSupported(t, e) {
              return ee.isSupported(t, e);
            }
            constructor(t, e = {}) {
              var n;
              R(t),
                (e instanceof Promise || "string" == typeof e) &&
                  (e = { data: e }),
                "string" == typeof e.data &&
                  (e = Object.assign({}, e, {
                    data:
                      ((n = e.data),
                      Ct("string" == typeof n),
                      (n = "" + n),
                      new Promise((t, e) => {
                        try {
                          const i = new Image();
                          (i.onload = () => t(i)),
                            (i.onerror = () =>
                              e(new Error(`Could not load image ${n}.`))),
                            (i.crossOrigin = "anonymous"),
                            (i.src = n);
                        } catch (t) {
                          e(t);
                        }
                      })),
                  })),
                super(t, Object.assign({}, e, { target: 3553 })),
                this.initialize(e),
                Object.seal(this);
            }
          }
          const ie = "EXT_color_buffer_float",
            re = {
              33189: { bpp: 2 },
              33190: { gl2: !0, bpp: 3 },
              36012: { gl2: !0, bpp: 4 },
              36168: { bpp: 1 },
              34041: { bpp: 4 },
              35056: { gl2: !0, bpp: 4 },
              36013: { gl2: !0, bpp: 5 },
              32854: { bpp: 2 },
              36194: { bpp: 2 },
              32855: { bpp: 2 },
              33321: { gl2: !0, bpp: 1 },
              33330: { gl2: !0, bpp: 1 },
              33329: { gl2: !0, bpp: 1 },
              33332: { gl2: !0, bpp: 2 },
              33331: { gl2: !0, bpp: 2 },
              33334: { gl2: !0, bpp: 4 },
              33333: { gl2: !0, bpp: 4 },
              33323: { gl2: !0, bpp: 2 },
              33336: { gl2: !0, bpp: 2 },
              33335: { gl2: !0, bpp: 2 },
              33338: { gl2: !0, bpp: 4 },
              33337: { gl2: !0, bpp: 4 },
              33340: { gl2: !0, bpp: 8 },
              33339: { gl2: !0, bpp: 8 },
              32849: { gl2: !0, bpp: 3 },
              32856: { gl2: !0, bpp: 4 },
              32857: { gl2: !0, bpp: 4 },
              36220: { gl2: !0, bpp: 4 },
              36238: { gl2: !0, bpp: 4 },
              36975: { gl2: !0, bpp: 4 },
              36214: { gl2: !0, bpp: 8 },
              36232: { gl2: !0, bpp: 8 },
              36226: { gl2: !0, bpp: 16 },
              36208: { gl2: !0, bpp: 16 },
              33325: { gl2: ie, bpp: 2 },
              33327: { gl2: ie, bpp: 4 },
              34842: { gl2: ie, bpp: 8 },
              33326: { gl2: ie, bpp: 4 },
              33328: { gl2: ie, bpp: 8 },
              34836: { gl2: ie, bpp: 16 },
              35898: { gl2: ie, bpp: 4 },
            };
          class se extends Bt {
            static isSupported(t, { format: e } = { format: null }) {
              return (
                !e ||
                (function (t, e, n) {
                  const i = n[e];
                  if (!i) return !1;
                  const r = (I(t) && i.gl2) || i.gl1;
                  return "string" == typeof r ? t.getExtension(r) : r;
                })(t, e, re)
              );
            }
            static getSamplesForFormat(t, { format: e }) {
              return t.getInternalformatParameter(36161, e, 32937);
            }
            constructor(t, e = {}) {
              super(t, e), this.initialize(e), Object.seal(this);
            }
            initialize({
              format: t,
              width: e = 1,
              height: n = 1,
              samples: i = 0,
            }) {
              return (
                Ct(t, "Needs format"),
                this._trackDeallocatedMemory(),
                this.gl.bindRenderbuffer(36161, this.handle),
                0 !== i && I(this.gl)
                  ? this.gl.renderbufferStorageMultisample(36161, i, t, e, n)
                  : this.gl.renderbufferStorage(36161, t, e, n),
                (this.format = t),
                (this.width = e),
                (this.height = n),
                (this.samples = i),
                this._trackAllocatedMemory(
                  this.width *
                    this.height *
                    (this.samples || 1) *
                    re[this.format].bpp
                ),
                this
              );
            }
            resize({ width: t, height: e }) {
              return t !== this.width || e !== this.height
                ? this.initialize({
                    width: t,
                    height: e,
                    format: this.format,
                    samples: this.samples,
                  })
                : this;
            }
            _createHandle() {
              return this.gl.createRenderbuffer();
            }
            _deleteHandle() {
              this.gl.deleteRenderbuffer(this.handle),
                this._trackDeallocatedMemory();
            }
            _bindHandle(t) {
              this.gl.bindRenderbuffer(36161, t);
            }
            _syncHandle(t) {
              (this.format = this.getParameter(36164)),
                (this.width = this.getParameter(36162)),
                (this.height = this.getParameter(36163)),
                (this.samples = this.getParameter(36011));
            }
            _getParameter(t) {
              return (
                this.gl.bindRenderbuffer(36161, this.handle),
                this.gl.getRenderbufferParameter(36161, t)
              );
            }
          }
          const oe = "clear: bad arguments";
          function ae(
            t,
            {
              framebuffer: e = null,
              color: n = null,
              depth: i = null,
              stencil: r = null,
            } = {}
          ) {
            const s = {};
            e && (s.framebuffer = e);
            let o = 0;
            n && ((o |= 16384), !0 !== n && (s.clearColor = n)),
              i && ((o |= 256), !0 !== i && (s.clearDepth = i)),
              r && ((o |= 1024), !0 !== i && (s.clearStencil = i)),
              Ct(0 !== o, oe),
              pt(t, s, () => {
                t.clear(o);
              });
          }
          const ce = [34069, 34070, 34071, 34072, 34073, 34074];
          class le extends ee {
            constructor(t, e = {}) {
              R(t),
                super(t, Object.assign({}, e, { target: 34067 })),
                this.initialize(e),
                Object.seal(this);
            }
            initialize(t = {}) {
              const { mipmaps: e = !0, parameters: n = {} } = t;
              return (
                (this.opts = t),
                this.setCubeMapImageData(t).then(() => {
                  (this.loaded = !0),
                    e && this.generateMipmap(t),
                    this.setParameters(n);
                }),
                this
              );
            }
            subImage({
              face: t,
              data: e,
              x: n = 0,
              y: i = 0,
              mipmapLevel: r = 0,
            }) {
              return this._subImage({
                target: t,
                data: e,
                x: n,
                y: i,
                mipmapLevel: r,
              });
            }
            async setCubeMapImageData({
              width: t,
              height: e,
              pixels: n,
              data: i,
              border: r = 0,
              format: s = 6408,
              type: o = 5121,
            }) {
              const { gl: a } = this,
                c = n || i,
                l = await Promise.all(
                  ce.map((t) => {
                    const e = c[t];
                    return Promise.all(Array.isArray(e) ? e : [e]);
                  })
                );
              this.bind(),
                ce.forEach((n, i) => {
                  l[i].length > 1 &&
                    !1 !== this.opts.mipmaps &&
                    C.warn(`${this.id} has mipmap and multiple LODs.`)(),
                    l[i].forEach((i, c) => {
                      t && e
                        ? a.texImage2D(n, c, s, t, e, r, s, o, i)
                        : a.texImage2D(n, c, s, s, o, i);
                    });
                }),
                this.unbind();
            }
            setImageDataForFace(t) {
              const {
                  face: e,
                  width: n,
                  height: i,
                  pixels: r,
                  data: s,
                  border: o = 0,
                  format: a = 6408,
                  type: c = 5121,
                } = t,
                { gl: l } = this,
                h = r || s;
              return (
                this.bind(),
                h instanceof Promise
                  ? h.then((n) =>
                      this.setImageDataForFace(
                        Object.assign({}, t, { face: e, data: n, pixels: n })
                      )
                    )
                  : this.width || this.height
                  ? l.texImage2D(e, 0, a, n, i, o, a, c, h)
                  : l.texImage2D(e, 0, a, a, c, h),
                this
              );
            }
          }
          le.FACES = ce;
          class he extends ee {
            static isSupported(t) {
              return I(t);
            }
            constructor(t, e = {}) {
              k(t),
                super(
                  t,
                  (e = Object.assign({ depth: 1 }, e, {
                    target: 32879,
                    unpackFlipY: !1,
                  }))
                ),
                this.initialize(e),
                Object.seal(this);
            }
            setImageData({
              level: t = 0,
              dataFormat: e = 6408,
              width: n,
              height: i,
              depth: r = 1,
              border: s = 0,
              format: o,
              type: a = 5121,
              offset: c = 0,
              data: l,
              parameters: h = {},
            }) {
              if (
                (this._trackDeallocatedMemory("Texture"),
                this.gl.bindTexture(this.target, this.handle),
                pt(this.gl, h, () => {
                  ArrayBuffer.isView(l) &&
                    this.gl.texImage3D(this.target, t, e, n, i, r, s, o, a, l),
                    l instanceof qt &&
                      (this.gl.bindBuffer(35052, l.handle),
                      this.gl.texImage3D(
                        this.target,
                        t,
                        e,
                        n,
                        i,
                        r,
                        s,
                        o,
                        a,
                        c
                      ));
                }),
                l && l.byteLength)
              )
                this._trackAllocatedMemory(l.byteLength, "Texture");
              else {
                const t = Kt[this.dataFormat] || 4,
                  e = Jt[this.type] || 1;
                this._trackAllocatedMemory(
                  this.width * this.height * this.depth * t * e,
                  "Texture"
                );
              }
              return (this.loaded = !0), this;
            }
          }
          function ue(t, e) {
            Ct(t instanceof ne || t instanceof le || t instanceof he);
            const n = t.constructor,
              {
                gl: i,
                width: r,
                height: s,
                format: o,
                type: a,
                dataFormat: c,
                border: l,
                mipmaps: h,
              } = t;
            return new n(
              i,
              Object.assign(
                {
                  width: r,
                  height: s,
                  format: o,
                  type: a,
                  dataFormat: c,
                  border: l,
                  mipmaps: h,
                },
                e
              )
            );
          }
          function de(t, e) {
            const { gl: n, width: i, height: r, id: s } = t;
            return new ye(
              n,
              Object.assign({}, e, {
                id: `framebuffer-for-${s}`,
                width: i,
                height: r,
                attachments: { 36064: t },
              })
            );
          }
          function fe(t, e = {}) {
            const {
              sourceX: n = 0,
              sourceY: i = 0,
              sourceFormat: r = 6408,
            } = e;
            let {
              sourceAttachment: s = 36064,
              target: o = null,
              sourceWidth: a,
              sourceHeight: c,
              sourceType: l,
            } = e;
            const { framebuffer: h, deleteFramebuffer: u } = ge(t);
            Ct(h);
            const { gl: d, handle: f, attachments: p } = h;
            (a = a || h.width),
              (c = c || h.height),
              36064 === s && null === f && (s = 1028),
              Ct(p[s]),
              (l = l || p[s].type),
              (o = (function (t, e, n, i, r) {
                if (t) return t;
                const s = Nt((e = e || 5121), { clamped: !1 }),
                  o = (function (t) {
                    switch (t) {
                      case 6406:
                      case 33326:
                      case 6403:
                        return 1;
                      case 33328:
                      case 33319:
                        return 2;
                      case 6407:
                      case 34837:
                        return 3;
                      case 6408:
                      case 34836:
                        return 4;
                      default:
                        return Ct(!1), 0;
                    }
                  })(n);
                return new s(i * r * o);
              })(o, l, r, a, c)),
              (l = l || Dt(o));
            const g = d.bindFramebuffer(36160, f);
            return (
              d.readPixels(n, i, a, c, r, l, o),
              d.bindFramebuffer(36160, g || null),
              u && h.delete(),
              o
            );
          }
          function pe(
            t,
            {
              sourceAttachment: e = 36064,
              targetMaxHeight: n = Number.MAX_SAFE_INTEGER,
            } = {}
          ) {
            let i = fe(t, { sourceAttachment: e }),
              { width: r, height: s } = t;
            for (; s > n; )
              ({
                data: i,
                width: r,
                height: s,
              } = Ut({ data: i, width: r, height: s }));
            !(function ({
              data: t,
              width: e,
              height: n,
              bytesPerPixel: i = 4,
              temp: r,
            }) {
              const s = e * i;
              r = r || new Uint8Array(s);
              for (let e = 0; e < n / 2; ++e) {
                const i = e * s,
                  o = (n - e - 1) * s;
                r.set(t.subarray(i, i + s)),
                  t.copyWithin(i, o, o + s),
                  t.set(r, o);
              }
            })({ data: i, width: r, height: s });
            const o = document.createElement("canvas");
            (o.width = r), (o.height = s);
            const a = o.getContext("2d"),
              c = a.createImageData(r, s);
            return c.data.set(i), a.putImageData(c, 0, 0), o.toDataURL();
          }
          function ge(t) {
            return t instanceof ye
              ? { framebuffer: t, deleteFramebuffer: !1 }
              : { framebuffer: de(t), deleteFramebuffer: !0 };
          }
          const me = "Multiple render targets not supported";
          class ye extends Bt {
            static isSupported(t, e = {}) {
              const { colorBufferFloat: n, colorBufferHalfFloat: i } = e;
              let r = !0;
              return (
                n &&
                  (r = Boolean(
                    t.getExtension("EXT_color_buffer_float") ||
                      t.getExtension("WEBGL_color_buffer_float") ||
                      t.getExtension("OES_texture_float")
                  )),
                i &&
                  (r =
                    r &&
                    Boolean(
                      t.getExtension("EXT_color_buffer_float") ||
                        t.getExtension("EXT_color_buffer_half_float")
                    )),
                r
              );
            }
            static getDefaultFramebuffer(t) {
              return (
                (t.luma = t.luma || {}),
                (t.luma.defaultFramebuffer =
                  t.luma.defaultFramebuffer ||
                  new ye(t, {
                    id: "default-framebuffer",
                    handle: null,
                    attachments: {},
                  })),
                t.luma.defaultFramebuffer
              );
            }
            get MAX_COLOR_ATTACHMENTS() {
              const t = k(this.gl);
              return t.getParameter(t.MAX_COLOR_ATTACHMENTS);
            }
            get MAX_DRAW_BUFFERS() {
              const t = k(this.gl);
              return t.getParameter(t.MAX_DRAW_BUFFERS);
            }
            constructor(t, e = {}) {
              super(t, e),
                (this.width = null),
                (this.height = null),
                (this.attachments = {}),
                (this.readBuffer = 36064),
                (this.drawBuffers = [36064]),
                (this.ownResources = []),
                this.initialize(e),
                Object.seal(this);
            }
            get color() {
              return this.attachments[36064] || null;
            }
            get texture() {
              return this.attachments[36064] || null;
            }
            get depth() {
              return this.attachments[36096] || this.attachments[33306] || null;
            }
            get stencil() {
              return this.attachments[36128] || this.attachments[33306] || null;
            }
            initialize({
              width: t = 1,
              height: e = 1,
              attachments: n = null,
              color: i = !0,
              depth: r = !0,
              stencil: s = !1,
              check: o = !0,
              readBuffer: a,
              drawBuffers: c,
            }) {
              if (
                (Ct(t >= 0 && e >= 0, "Width and height need to be integers"),
                (this.width = t),
                (this.height = e),
                n)
              )
                for (const i in n) {
                  const r = n[i];
                  (Array.isArray(r) ? r[0] : r).resize({ width: t, height: e });
                }
              else n = this._createDefaultAttachments(i, r, s, t, e);
              this.update({
                clearAttachments: !0,
                attachments: n,
                readBuffer: a,
                drawBuffers: c,
              }),
                n && o && this.checkStatus();
            }
            delete() {
              for (const t of this.ownResources) t.delete();
              return super.delete(), this;
            }
            update({
              attachments: t = {},
              readBuffer: e,
              drawBuffers: n,
              clearAttachments: i = !1,
              resizeAttachments: r = !0,
            }) {
              this.attach(t, { clearAttachments: i, resizeAttachments: r });
              const { gl: s } = this,
                o = s.bindFramebuffer(36160, this.handle);
              return (
                e && this._setReadBuffer(e),
                n && this._setDrawBuffers(n),
                s.bindFramebuffer(36160, o || null),
                this
              );
            }
            resize(t = {}) {
              let { width: e, height: n } = t;
              if (null === this.handle)
                return (
                  Ct(void 0 === e && void 0 === n),
                  (this.width = this.gl.drawingBufferWidth),
                  (this.height = this.gl.drawingBufferHeight),
                  this
                );
              void 0 === e && (e = this.gl.drawingBufferWidth),
                void 0 === n && (n = this.gl.drawingBufferHeight),
                e !== this.width &&
                  n !== this.height &&
                  C.log(2, `Resizing framebuffer ${this.id} to ${e}x${n}`)();
              for (const t in this.attachments)
                this.attachments[t].resize({ width: e, height: n });
              return (this.width = e), (this.height = n), this;
            }
            attach(
              t,
              { clearAttachments: e = !1, resizeAttachments: n = !0 } = {}
            ) {
              const i = {};
              e &&
                Object.keys(this.attachments).forEach((t) => {
                  i[t] = null;
                }),
                Object.assign(i, t);
              const r = this.gl.bindFramebuffer(36160, this.handle);
              for (const t in i) {
                Ct(void 0 !== t, "Misspelled framebuffer binding point?");
                const e = Number(t),
                  r = i[e];
                let s = r;
                if (s)
                  if (s instanceof se)
                    this._attachRenderbuffer({
                      attachment: e,
                      renderbuffer: s,
                    });
                  else if (Array.isArray(r)) {
                    const [t, n = 0, i = 0] = r;
                    (s = t),
                      this._attachTexture({
                        attachment: e,
                        texture: t,
                        layer: n,
                        level: i,
                      });
                  } else
                    this._attachTexture({
                      attachment: e,
                      texture: s,
                      layer: 0,
                      level: 0,
                    });
                else this._unattach(e);
                n && s && s.resize({ width: this.width, height: this.height });
              }
              this.gl.bindFramebuffer(36160, r || null),
                Object.assign(this.attachments, t),
                Object.keys(this.attachments)
                  .filter((t) => !this.attachments[t])
                  .forEach((t) => {
                    delete this.attachments[t];
                  });
            }
            checkStatus() {
              const { gl: t } = this,
                e = this.getStatus();
              if (36053 !== e)
                throw new Error(
                  (function (t) {
                    return (ye.STATUS || {})[t] || `Framebuffer error ${t}`;
                  })(e)
                );
              return this;
            }
            getStatus() {
              const { gl: t } = this,
                e = t.bindFramebuffer(36160, this.handle),
                n = t.checkFramebufferStatus(36160);
              return t.bindFramebuffer(36160, e || null), n;
            }
            clear(t = {}) {
              const { color: e, depth: n, stencil: i, drawBuffers: r = [] } = t,
                s = this.gl.bindFramebuffer(36160, this.handle);
              return (
                (e || n || i) &&
                  ae(this.gl, { color: e, depth: n, stencil: i }),
                r.forEach((t, e) => {
                  !(function (
                    t,
                    {
                      framebuffer: e = null,
                      buffer: n = 6144,
                      drawBuffer: i = 0,
                      value: r = [0, 0, 0, 0],
                    } = {}
                  ) {
                    k(t),
                      pt(t, { framebuffer: e }, () => {
                        switch (n) {
                          case 6144:
                            switch (r.constructor) {
                              case Int32Array:
                                t.clearBufferiv(n, i, r);
                                break;
                              case Uint32Array:
                                t.clearBufferuiv(n, i, r);
                                break;
                              case Float32Array:
                              default:
                                t.clearBufferfv(n, i, r);
                            }
                            break;
                          case 6145:
                            t.clearBufferfv(6145, 0, [r]);
                            break;
                          case 6146:
                            t.clearBufferiv(6146, 0, [r]);
                            break;
                          case 34041:
                            const [e, s] = r;
                            t.clearBufferfi(34041, 0, e, s);
                            break;
                          default:
                            Ct(!1, oe);
                        }
                      });
                  })(this.gl, { drawBuffer: e, value: t });
                }),
                this.gl.bindFramebuffer(36160, s || null),
                this
              );
            }
            readPixels(t = {}) {
              return (
                C.error(
                  "Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)"
                )(),
                null
              );
            }
            readPixelsToBuffer(t = {}) {
              return (
                C.error(
                  "Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)"
                )(),
                null
              );
            }
            copyToDataUrl(t = {}) {
              return (
                C.error(
                  "Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)"
                )(),
                null
              );
            }
            copyToImage(t = {}) {
              return (
                C.error(
                  "Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)"
                )(),
                null
              );
            }
            copyToTexture(t = {}) {
              return (
                C.error(
                  "Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})"
                )(),
                null
              );
            }
            blit(t = {}) {
              return (
                C.error(
                  "Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)"
                )(),
                null
              );
            }
            invalidate({
              attachments: t = [],
              x: e = 0,
              y: n = 0,
              width: i,
              height: r,
            }) {
              const s = k(this.gl),
                o = s.bindFramebuffer(36008, this.handle);
              return (
                0 === e && 0 === n && void 0 === i && void 0 === r
                  ? s.invalidateFramebuffer(36008, t)
                  : s.invalidateFramebuffer(36008, t, e, n, i, r),
                s.bindFramebuffer(36008, o),
                this
              );
            }
            getAttachmentParameter(t, e, n) {
              let i = this._getAttachmentParameterFallback(e);
              return (
                null === i &&
                  (this.gl.bindFramebuffer(36160, this.handle),
                  (i = this.gl.getFramebufferAttachmentParameter(36160, t, e)),
                  this.gl.bindFramebuffer(36160, null)),
                n && i > 1e3 && (i = Ot(this.gl, i)),
                i
              );
            }
            getAttachmentParameters(
              t = 36064,
              e,
              n = this.constructor.ATTACHMENT_PARAMETERS || []
            ) {
              const i = {};
              for (const r of n)
                i[e ? Ot(this.gl, r) : r] = this.getAttachmentParameter(
                  t,
                  r,
                  e
                );
              return i;
            }
            getParameters(t = !0) {
              const e = Object.keys(this.attachments),
                n = {};
              for (const i of e) {
                const e = Number(i);
                n[t ? Ot(this.gl, e) : e] = this.getAttachmentParameters(e, t);
              }
              return n;
            }
            show() {
              return (
                "undefined" != typeof window &&
                  window.open(pe(this), "luma-debug-texture"),
                this
              );
            }
            log(t = 0, e = "") {
              if (t > C.level || "undefined" == typeof window) return this;
              e = e || `Framebuffer ${this.id}`;
              const n = pe(this, { targetMaxHeight: 100 });
              return C.image({ logLevel: t, message: e, image: n }, e)(), this;
            }
            bind({ target: t = 36160 } = {}) {
              return this.gl.bindFramebuffer(t, this.handle), this;
            }
            unbind({ target: t = 36160 } = {}) {
              return this.gl.bindFramebuffer(t, null), this;
            }
            _createDefaultAttachments(t, e, n, i, r) {
              let s = null;
              return (
                t &&
                  ((s = s || {}),
                  (s[36064] = new ne(this.gl, {
                    id: `${this.id}-color0`,
                    pixels: null,
                    format: 6408,
                    type: 5121,
                    width: i,
                    height: r,
                    mipmaps: !1,
                    parameters: {
                      10241: 9729,
                      10240: 9729,
                      10242: 33071,
                      10243: 33071,
                    },
                  })),
                  this.ownResources.push(s[36064])),
                e && n
                  ? ((s = s || {}),
                    (s[33306] = new se(this.gl, {
                      id: `${this.id}-depth-stencil`,
                      format: 35056,
                      width: i,
                      height: 111,
                    })),
                    this.ownResources.push(s[33306]))
                  : e
                  ? ((s = s || {}),
                    (s[36096] = new se(this.gl, {
                      id: `${this.id}-depth`,
                      format: 33189,
                      width: i,
                      height: r,
                    })),
                    this.ownResources.push(s[36096]))
                  : n && Ct(!1),
                s
              );
            }
            _unattach(t) {
              const e = this.attachments[t];
              e &&
                (e instanceof se
                  ? this.gl.framebufferRenderbuffer(36160, t, 36161, null)
                  : this.gl.framebufferTexture2D(36160, t, 3553, null, 0),
                delete this.attachments[t]);
            }
            _attachRenderbuffer({ attachment: t = 36064, renderbuffer: e }) {
              const { gl: n } = this;
              n.framebufferRenderbuffer(36160, t, 36161, e.handle),
                (this.attachments[t] = e);
            }
            _attachTexture({
              attachment: t = 36064,
              texture: e,
              layer: n,
              level: i,
            }) {
              const { gl: r } = this;
              switch ((r.bindTexture(e.target, e.handle), e.target)) {
                case 35866:
                case 32879:
                  k(r).framebufferTextureLayer(36160, t, e.target, i, n);
                  break;
                case 34067:
                  const s = (function (t) {
                    return t < 34069 ? t + 34069 : t;
                  })(n);
                  r.framebufferTexture2D(36160, t, s, e.handle, i);
                  break;
                case 3553:
                  r.framebufferTexture2D(36160, t, 3553, e.handle, i);
                  break;
                default:
                  Ct(!1, "Illegal texture type");
              }
              r.bindTexture(e.target, null), (this.attachments[t] = e);
            }
            _setReadBuffer(t) {
              const e = I((n = this.gl)) ? n : null;
              var n;
              e ? e.readBuffer(t) : Ct(36064 === t || 1029 === t, me),
                (this.readBuffer = t);
            }
            _setDrawBuffers(t) {
              const { gl: e } = this,
                n = k(e);
              if (n) n.drawBuffers(t);
              else {
                const n = e.getExtension("WEBGL_draw_buffers");
                n
                  ? n.drawBuffersWEBGL(t)
                  : Ct(1 === t.length && (36064 === t[0] || 1029 === t[0]), me);
              }
              this.drawBuffers = t;
            }
            _getAttachmentParameterFallback(t) {
              const e = (function (t) {
                (t.luma = t.luma || {}), (t.luma.caps = t.luma.caps || {});
                for (const e in be)
                  void 0 === t.luma.caps[e] && (t.luma.caps[e] = xe(t, e));
                return t.luma.caps;
              })(this.gl);
              switch (t) {
                case 36052:
                  return e.WEBGL2 ? null : 0;
                case 33298:
                case 33299:
                case 33300:
                case 33301:
                case 33302:
                case 33303:
                  return e.WEBGL2 ? null : 8;
                case 33297:
                  return e.WEBGL2 ? null : 5125;
                case 33296:
                  return e.WEBGL2 || e.EXT_sRGB ? null : 9729;
                default:
                  return null;
              }
            }
            _createHandle() {
              return this.gl.createFramebuffer();
            }
            _deleteHandle() {
              this.gl.deleteFramebuffer(this.handle);
            }
            _bindHandle(t) {
              return this.gl.bindFramebuffer(36160, t);
            }
          }
          ye.ATTACHMENT_PARAMETERS = [
            36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303,
          ];
          const _e = "TIMER_QUERY",
            ve = "ELEMENT_INDEX_UINT32",
            be = {
              WEBGL2: [!1, !0],
              VERTEX_ARRAY_OBJECT: ["OES_vertex_array_object", !0],
              [_e]: [
                "EXT_disjoint_timer_query",
                "EXT_disjoint_timer_query_webgl2",
              ],
              INSTANCED_RENDERING: ["ANGLE_instanced_arrays", !0],
              MULTIPLE_RENDER_TARGETS: ["WEBGL_draw_buffers", !0],
              [ve]: ["OES_element_index_uint", !0],
              BLEND_EQUATION_MINMAX: ["EXT_blend_minmax", !0],
              FLOAT_BLEND: ["EXT_float_blend"],
              COLOR_ENCODING_SRGB: ["EXT_sRGB", !0],
              TEXTURE_DEPTH: ["WEBGL_depth_texture", !0],
              TEXTURE_FLOAT: ["OES_texture_float", !0],
              TEXTURE_HALF_FLOAT: ["OES_texture_half_float", !0],
              TEXTURE_FILTER_LINEAR_FLOAT: ["OES_texture_float_linear"],
              TEXTURE_FILTER_LINEAR_HALF_FLOAT: [
                "OES_texture_half_float_linear",
              ],
              TEXTURE_FILTER_ANISOTROPIC: ["EXT_texture_filter_anisotropic"],
              COLOR_ATTACHMENT_RGBA32F: [
                function (t) {
                  const e = new ne(t, {
                      format: 6408,
                      type: 5126,
                      dataFormat: 6408,
                    }),
                    n = new ye(t, {
                      id: "test-framebuffer",
                      check: !1,
                      attachments: { 36064: e },
                    }),
                    i = n.getStatus();
                  return e.delete(), n.delete(), 36053 === i;
                },
                "EXT_color_buffer_float",
              ],
              COLOR_ATTACHMENT_FLOAT: [!1, "EXT_color_buffer_float"],
              COLOR_ATTACHMENT_HALF_FLOAT: ["EXT_color_buffer_half_float"],
              GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
              GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
              GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
              GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0],
            };
          function we(t, e) {
            return (e = Array.isArray(e) ? e : [e]).every((e) => xe(t, e));
          }
          function xe(t, e) {
            return (
              (t.luma = t.luma || {}),
              (t.luma.caps = t.luma.caps || {}),
              void 0 === t.luma.caps[e] &&
                (t.luma.caps[e] = (function (t, e) {
                  const n = be[e];
                  let i;
                  Ct(n, e);
                  const r = (I(t) && n[1]) || n[0];
                  if ("function" == typeof r) i = r(t);
                  else if (Array.isArray(r)) {
                    i = !0;
                    for (const e of r) i = i && Boolean(t.getExtension(e));
                  } else
                    "string" == typeof r
                      ? (i = Boolean(t.getExtension(r)))
                      : "boolean" == typeof r
                      ? (i = r)
                      : Ct(!1);
                  return i;
                })(t, e)),
              t.luma.caps[e] || C.log(2, `Feature: ${e} not supported`)(),
              t.luma.caps[e]
            );
          }
          class Pe {
            constructor(t, e) {
              (this.opts = e), (this.source = t);
            }
            get value() {
              return this.source.value;
            }
            getValue() {
              const t = this.source.getBuffer(),
                e = this.getAccessor();
              if (t) return [t, e];
              const { value: n } = this.source,
                { size: i } = e;
              let r = n;
              if (n && n.length !== i) {
                r = new Float32Array(i);
                const t = e.elementOffset || 0;
                for (let e = 0; e < i; ++e) r[e] = n[t + e];
              }
              return r;
            }
            getAccessor() {
              return { ...this.source.getAccessor(), ...this.opts };
            }
          }
          const Ee = new (class {
              constructor(t) {
                (this._pool = []),
                  (this.props = { overAlloc: 2, poolSize: 100 }),
                  this.setProps(t);
              }
              setProps(t) {
                Object.assign(this.props, t);
              }
              allocate(
                t,
                e,
                {
                  size: n = 1,
                  type: i,
                  padding: r = 0,
                  copy: s = !1,
                  initialize: o = !1,
                  maxCount: a,
                }
              ) {
                const c = i || (t && t.constructor) || Float32Array,
                  l = e * n + r;
                if (ArrayBuffer.isView(t)) {
                  if (l <= t.length) return t;
                  if (l * t.BYTES_PER_ELEMENT <= t.buffer.byteLength)
                    return new c(t.buffer, 0, l);
                }
                let h;
                a && (h = a * n + r);
                const u = this._allocate(c, l, o, h);
                return (
                  t && s ? u.set(t) : o || u.fill(0, 0, 4), this._release(t), u
                );
              }
              release(t) {
                this._release(t);
              }
              _allocate(t, e, n, i) {
                let r = Math.max(Math.ceil(e * this.props.overAlloc), 1);
                r > i && (r = i);
                const s = this._pool,
                  o = t.BYTES_PER_ELEMENT * r,
                  a = s.findIndex((t) => t.byteLength >= o);
                if (a >= 0) {
                  const e = new t(s.splice(a, 1)[0], 0, r);
                  return n && e.fill(0), e;
                }
                return new t(r);
              }
              _release(t) {
                if (!ArrayBuffer.isView(t)) return;
                const e = this._pool,
                  { buffer: n } = t,
                  { byteLength: i } = n,
                  r = e.findIndex((t) => t.byteLength >= i);
                r < 0
                  ? e.push(n)
                  : (r > 0 || e.length < this.props.poolSize) &&
                    e.splice(r, 0, n),
                  e.length > this.props.poolSize && e.shift();
              }
            })(),
            Ae = (Math.PI, Math.PI, {});
          function Te(t, { precision: e = Ae.precision || 4 } = {}) {
            return (
              (t = (function (t) {
                return Math.round(t / Ae.EPSILON) * Ae.EPSILON;
              })(t)),
              "".concat(parseFloat(t.toPrecision(e)))
            );
          }
          function Se(t) {
            return (
              Array.isArray(t) ||
              (ArrayBuffer.isView(t) && !(t instanceof DataView))
            );
          }
          function Me(t, e, n) {
            return (function (t, e, n) {
              if (Se(t)) {
                n = n || ((i = t).clone ? i.clone() : new Array(i.length));
                for (let i = 0; i < n.length && i < t.length; ++i)
                  n[i] = e(t[i], i, n);
                return n;
              }
              var i;
              return e(t);
            })(t, (t) => Math.max(e, Math.min(n, t)));
          }
          function Ce(t, e, n) {
            return Se(t)
              ? t.map((t, i) => Ce(t, e[i], n))
              : n * e + (1 - n) * t;
          }
          function Le(t, e, n) {
            const i = Ae.EPSILON;
            n && (Ae.EPSILON = n);
            try {
              if (t === e) return !0;
              if (Se(t) && Se(e)) {
                if (t.length !== e.length) return !1;
                for (let n = 0; n < t.length; ++n)
                  if (!Le(t[n], e[n])) return !1;
                return !0;
              }
              return t && t.equals
                ? t.equals(e)
                : e && e.equals
                ? e.equals(t)
                : !(!Number.isFinite(t) || !Number.isFinite(e)) &&
                  Math.abs(t - e) <=
                    Ae.EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            } finally {
              Ae.EPSILON = i;
            }
          }
          function Oe(t, e) {
            if (!t) throw new Error("math.gl assertion ".concat(e));
          }
          (Ae.EPSILON = 1e-12),
            (Ae.debug = !1),
            (Ae.precision = 4),
            (Ae.printTypes = !1),
            (Ae.printDegrees = !1),
            (Ae.printRowMajor = !0);
          class Ie extends (function (t) {
            function e() {
              var e = Reflect.construct(t, Array.from(arguments));
              return Object.setPrototypeOf(e, Object.getPrototypeOf(this)), e;
            }
            return (
              (e.prototype = Object.create(t.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
              Object.setPrototypeOf
                ? Object.setPrototypeOf(e, t)
                : (e.__proto__ = t),
              e
            );
          })(Array) {
            get ELEMENTS() {
              return Oe(!1), 0;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            from(t) {
              return Array.isArray(t) ? this.copy(t) : this.fromObject(t);
            }
            fromArray(t, e = 0) {
              for (let n = 0; n < this.ELEMENTS; ++n) this[n] = t[n + e];
              return this.check();
            }
            to(t) {
              return t === this
                ? this
                : Se(t)
                ? this.toArray(t)
                : this.toObject(t);
            }
            toTarget(t) {
              return t ? this.to(t) : this;
            }
            toArray(t = [], e = 0) {
              for (let n = 0; n < this.ELEMENTS; ++n) t[e + n] = this[n];
              return t;
            }
            toFloat32Array() {
              return new Float32Array(this);
            }
            toString() {
              return this.formatString(Ae);
            }
            formatString(t) {
              let e = "";
              for (let n = 0; n < this.ELEMENTS; ++n)
                e += (n > 0 ? ", " : "") + Te(this[n], t);
              return ""
                .concat(t.printTypes ? this.constructor.name : "", "[")
                .concat(e, "]");
            }
            equals(t) {
              if (!t || this.length !== t.length) return !1;
              for (let e = 0; e < this.ELEMENTS; ++e)
                if (!Le(this[e], t[e])) return !1;
              return !0;
            }
            exactEquals(t) {
              if (!t || this.length !== t.length) return !1;
              for (let e = 0; e < this.ELEMENTS; ++e)
                if (this[e] !== t[e]) return !1;
              return !0;
            }
            negate() {
              for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];
              return this.check();
            }
            lerp(t, e, n) {
              void 0 === n && ((n = e), (e = t), (t = this));
              for (let i = 0; i < this.ELEMENTS; ++i) {
                const r = t[i];
                this[i] = r + n * (e[i] - r);
              }
              return this.check();
            }
            min(t) {
              for (let e = 0; e < this.ELEMENTS; ++e)
                this[e] = Math.min(t[e], this[e]);
              return this.check();
            }
            max(t) {
              for (let e = 0; e < this.ELEMENTS; ++e)
                this[e] = Math.max(t[e], this[e]);
              return this.check();
            }
            clamp(t, e) {
              for (let n = 0; n < this.ELEMENTS; ++n)
                this[n] = Math.min(Math.max(this[n], t[n]), e[n]);
              return this.check();
            }
            add(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] += e[t];
              return this.check();
            }
            subtract(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] -= e[t];
              return this.check();
            }
            scale(t) {
              if (Array.isArray(t)) return this.multiply(t);
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
              return this.check();
            }
            sub(t) {
              return this.subtract(t);
            }
            setScalar(t) {
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] = t;
              return this.check();
            }
            addScalar(t) {
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] += t;
              return this.check();
            }
            subScalar(t) {
              return this.addScalar(-t);
            }
            multiplyScalar(t) {
              for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t;
              return this.check();
            }
            divideScalar(t) {
              return this.scale(1 / t);
            }
            clampScalar(t, e) {
              for (let n = 0; n < this.ELEMENTS; ++n)
                this[n] = Math.min(Math.max(this[n], t), e);
              return this.check();
            }
            multiplyByScalar(t) {
              return this.scale(t);
            }
            get elements() {
              return this;
            }
            check() {
              if (Ae.debug && !this.validate())
                throw new Error(
                  "math.gl: ".concat(
                    this.constructor.name,
                    " some fields set to invalid numbers'"
                  )
                );
              return this;
            }
            validate() {
              let t = this.length === this.ELEMENTS;
              for (let e = 0; e < this.ELEMENTS; ++e)
                t = t && Number.isFinite(this[e]);
              return t;
            }
          }
          function Re(t) {
            if (!Number.isFinite(t))
              throw new Error("Invalid number ".concat(t));
            return t;
          }
          function ke(t, e, n = "") {
            if (
              Ae.debug &&
              !(function (t, e) {
                if (t.length !== e) return !1;
                for (let e = 0; e < t.length; ++e)
                  if (!Number.isFinite(t[e])) return !1;
                return !0;
              })(t, e)
            )
              throw new Error(
                "math.gl: ".concat(n, " some fields set to invalid numbers'")
              );
            return t;
          }
          const Fe = {};
          function ze(t, e) {
            Fe[t] ||
              ((Fe[t] = !0),
              console.warn(
                ""
                  .concat(t, " has been removed in version ")
                  .concat(e, ", see upgrade guide for more information")
              ));
          }
          class je extends Ie {
            get ELEMENTS() {
              return Oe(!1), 0;
            }
            copy(t) {
              return Oe(!1), this;
            }
            get x() {
              return this[0];
            }
            set x(t) {
              this[0] = Re(t);
            }
            get y() {
              return this[1];
            }
            set y(t) {
              this[1] = Re(t);
            }
            len() {
              return Math.sqrt(this.lengthSquared());
            }
            magnitude() {
              return this.len();
            }
            lengthSquared() {
              let t = 0;
              for (let e = 0; e < this.ELEMENTS; ++e) t += this[e] * this[e];
              return t;
            }
            magnitudeSquared() {
              return this.lengthSquared();
            }
            distance(t) {
              return Math.sqrt(this.distanceSquared(t));
            }
            distanceSquared(t) {
              let e = 0;
              for (let n = 0; n < this.ELEMENTS; ++n) {
                const i = this[n] - t[n];
                e += i * i;
              }
              return Re(e);
            }
            dot(t) {
              let e = 0;
              for (let n = 0; n < this.ELEMENTS; ++n) e += this[n] * t[n];
              return Re(e);
            }
            normalize() {
              const t = this.magnitude();
              if (0 !== t) for (let e = 0; e < this.ELEMENTS; ++e) this[e] /= t;
              return this.check();
            }
            multiply(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e[t];
              return this.check();
            }
            divide(...t) {
              for (const e of t)
                for (let t = 0; t < this.ELEMENTS; ++t) this[t] /= e[t];
              return this.check();
            }
            lengthSq() {
              return this.lengthSquared();
            }
            distanceTo(t) {
              return this.distance(t);
            }
            distanceToSquared(t) {
              return this.distanceSquared(t);
            }
            getComponent(t) {
              return (
                Oe(t >= 0 && t < this.ELEMENTS, "index is out of range"),
                Re(this[t])
              );
            }
            setComponent(t, e) {
              return (
                Oe(t >= 0 && t < this.ELEMENTS, "index is out of range"),
                (this[t] = e),
                this.check()
              );
            }
            addVectors(t, e) {
              return this.copy(t).add(e);
            }
            subVectors(t, e) {
              return this.copy(t).subtract(e);
            }
            multiplyVectors(t, e) {
              return this.copy(t).multiply(e);
            }
            addScaledVector(t, e) {
              return this.add(new this.constructor(t).multiplyScalar(e));
            }
          }
          var Be = 1e-6,
            De = "undefined" != typeof Float32Array ? Float32Array : Array;
          function Ne(t, e, n) {
            var i = e[0],
              r = e[1],
              s = e[2],
              o = n[3] * i + n[7] * r + n[11] * s + n[15];
            return (
              (o = o || 1),
              (t[0] = (n[0] * i + n[4] * r + n[8] * s + n[12]) / o),
              (t[1] = (n[1] * i + n[5] * r + n[9] * s + n[13]) / o),
              (t[2] = (n[2] * i + n[6] * r + n[10] * s + n[14]) / o),
              t
            );
          }
          Math.random,
            Math.PI,
            Math.hypot ||
              (Math.hypot = function () {
                for (var t = 0, e = arguments.length; e--; )
                  t += arguments[e] * arguments[e];
                return Math.sqrt(t);
              });
          var Ue;
          function Ve(t, e, n) {
            const i = e[0],
              r = e[1],
              s = e[2],
              o = n[3] * i + n[7] * r + n[11] * s || 1;
            return (
              (t[0] = (n[0] * i + n[4] * r + n[8] * s) / o),
              (t[1] = (n[1] * i + n[5] * r + n[9] * s) / o),
              (t[2] = (n[2] * i + n[6] * r + n[10] * s) / o),
              t
            );
          }
          (Ue = new De(3)),
            De != Float32Array && ((Ue[0] = 0), (Ue[1] = 0), (Ue[2] = 0));
          const Ge = [0, 0, 0],
            We = {};
          class He extends je {
            static get ZERO() {
              return (We.ZERO = We.ZERO || Object.freeze(new He(0, 0, 0, 0)));
            }
            constructor(t = 0, e = 0, n = 0) {
              super(-0, -0, -0),
                1 === arguments.length && Se(t)
                  ? this.copy(t)
                  : (Ae.debug && (Re(t), Re(e), Re(n)),
                    (this[0] = t),
                    (this[1] = e),
                    (this[2] = n));
            }
            set(t, e, n) {
              return (this[0] = t), (this[1] = e), (this[2] = n), this.check();
            }
            copy(t) {
              return (
                (this[0] = t[0]),
                (this[1] = t[1]),
                (this[2] = t[2]),
                this.check()
              );
            }
            fromObject(t) {
              return (
                Ae.debug && (Re(t.x), Re(t.y), Re(t.z)),
                (this[0] = t.x),
                (this[1] = t.y),
                (this[2] = t.z),
                this.check()
              );
            }
            toObject(t) {
              return (t.x = this[0]), (t.y = this[1]), (t.z = this[2]), t;
            }
            get ELEMENTS() {
              return 3;
            }
            get z() {
              return this[2];
            }
            set z(t) {
              this[2] = Re(t);
            }
            angle(t) {
              return (
                (n = t),
                (i = (e = this)[0]),
                (r = e[1]),
                (s = e[2]),
                (o = n[0]),
                (a = n[1]),
                (c = n[2]),
                (h =
                  (l =
                    Math.sqrt(i * i + r * r + s * s) *
                    Math.sqrt(o * o + a * a + c * c)) &&
                  (function (t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
                  })(e, n) / l),
                Math.acos(Math.min(Math.max(h, -1), 1))
              );
              var e, n, i, r, s, o, a, c, l, h;
            }
            cross(t) {
              return (
                (function (t, e, n) {
                  var i = e[0],
                    r = e[1],
                    s = e[2],
                    o = n[0],
                    a = n[1],
                    c = n[2];
                  (t[0] = r * c - s * a),
                    (t[1] = s * o - i * c),
                    (t[2] = i * a - r * o);
                })(this, this, t),
                this.check()
              );
            }
            rotateX({ radians: t, origin: e = Ge }) {
              return (
                (function (t, e, n, i) {
                  var r = [],
                    s = [];
                  (r[0] = e[0] - n[0]),
                    (r[1] = e[1] - n[1]),
                    (r[2] = e[2] - n[2]),
                    (s[0] = r[0]),
                    (s[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i)),
                    (s[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i)),
                    (t[0] = s[0] + n[0]),
                    (t[1] = s[1] + n[1]),
                    (t[2] = s[2] + n[2]);
                })(this, this, e, t),
                this.check()
              );
            }
            rotateY({ radians: t, origin: e = Ge }) {
              return (
                (function (t, e, n, i) {
                  var r = [],
                    s = [];
                  (r[0] = e[0] - n[0]),
                    (r[1] = e[1] - n[1]),
                    (r[2] = e[2] - n[2]),
                    (s[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i)),
                    (s[1] = r[1]),
                    (s[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i)),
                    (t[0] = s[0] + n[0]),
                    (t[1] = s[1] + n[1]),
                    (t[2] = s[2] + n[2]);
                })(this, this, e, t),
                this.check()
              );
            }
            rotateZ({ radians: t, origin: e = Ge }) {
              return (
                (function (t, e, n, i) {
                  var r = [],
                    s = [];
                  (r[0] = e[0] - n[0]),
                    (r[1] = e[1] - n[1]),
                    (r[2] = e[2] - n[2]),
                    (s[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i)),
                    (s[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i)),
                    (s[2] = r[2]),
                    (t[0] = s[0] + n[0]),
                    (t[1] = s[1] + n[1]),
                    (t[2] = s[2] + n[2]);
                })(this, this, e, t),
                this.check()
              );
            }
            transform(t) {
              return this.transformAsPoint(t);
            }
            transformAsPoint(t) {
              return Ne(this, this, t), this.check();
            }
            transformAsVector(t) {
              return Ve(this, this, t), this.check();
            }
            transformByMatrix3(t) {
              return (
                (function (t, e, n) {
                  var i = e[0],
                    r = e[1],
                    s = e[2];
                  (t[0] = i * n[0] + r * n[3] + s * n[6]),
                    (t[1] = i * n[1] + r * n[4] + s * n[7]),
                    (t[2] = i * n[2] + r * n[5] + s * n[8]);
                })(this, this, t),
                this.check()
              );
            }
            transformByMatrix2(t) {
              return (
                (function (t, e, n) {
                  const i = e[0],
                    r = e[1];
                  (t[0] = n[0] * i + n[2] * r),
                    (t[1] = n[1] * i + n[3] * r),
                    (t[2] = e[2]);
                })(this, this, t),
                this.check()
              );
            }
            transformByQuaternion(t) {
              return (
                (function (t, e, n) {
                  var i = n[0],
                    r = n[1],
                    s = n[2],
                    o = n[3],
                    a = e[0],
                    c = e[1],
                    l = e[2],
                    h = r * l - s * c,
                    u = s * a - i * l,
                    d = i * c - r * a,
                    f = r * d - s * u,
                    p = s * h - i * d,
                    g = i * u - r * h,
                    m = 2 * o;
                  (h *= m),
                    (u *= m),
                    (d *= m),
                    (f *= 2),
                    (p *= 2),
                    (g *= 2),
                    (t[0] = a + h + f),
                    (t[1] = c + u + p),
                    (t[2] = l + d + g);
                })(this, this, t),
                this.check()
              );
            }
          }
          const $e = new He();
          function Xe(t, e, n, i) {
            $e.set(t, e, n);
            const r = $e.len();
            return { distance: i / r, normal: new He(-t / r, -e / r, -n / r) };
          }
          let Ye;
          function qe(t, { size: e = 1, startIndex: n = 0, endIndex: i }) {
            Number.isFinite(i) || (i = t.length);
            const r = (i - n) / e;
            Ye = Ee.allocate(Ye, r, { type: Float32Array, size: 2 * e });
            let s = n,
              o = 0;
            for (; s < i; ) {
              for (let n = 0; n < e; n++) {
                const i = t[s++];
                (Ye[o + n] = i), (Ye[o + n + e] = (a = i) - Math.fround(a));
              }
              o += 2 * e;
            }
            var a;
            return Ye.subarray(0, r * e * 2);
          }
          function Ze(t) {
            return t.stride || t.size * t.bytesPerElement;
          }
          function Ke(t, e) {
            e.offset &&
              E.removed(
                "shaderAttribute.offset",
                "vertexOffset, elementOffset"
              )();
            const n = Ze(t),
              i =
                ("vertexOffset" in e ? e.vertexOffset : t.vertexOffset || 0) *
                  n +
                (e.elementOffset || 0) * t.bytesPerElement +
                (t.offset || 0);
            return { ...e, offset: i, stride: n };
          }
          function Je(t, e) {
            if (!t) throw new Error(e || "deck.gl: assertion failed.");
          }
          const Qe = [],
            tn = [];
          function en(t, e = 0, n = 1 / 0) {
            let i = Qe;
            const r = { index: -1, data: t, target: [] };
            return (
              t
                ? "function" == typeof t[Symbol.iterator]
                  ? (i = t)
                  : t.length > 0 && ((tn.length = t.length), (i = tn))
                : (i = Qe),
              (e > 0 || Number.isFinite(n)) &&
                ((i = (Array.isArray(i) ? i : Array.from(i)).slice(e, n)),
                (r.index = e - 1)),
              { iterable: i, objectInfo: r }
            );
          }
          function nn(t) {
            return t && t[Symbol.asyncIterator];
          }
          function rn(
            t,
            { size: e, stride: n, offset: i, startIndices: r, nested: s }
          ) {
            const o = t.BYTES_PER_ELEMENT,
              a = n ? n / o : e,
              c = i ? i / o : 0,
              l = Math.floor((t.length - c) / a);
            return (n, { index: i, target: o }) => {
              if (!r) {
                const n = i * a + c;
                for (let i = 0; i < e; i++) o[i] = t[n + i];
                return o;
              }
              const h = r[i],
                u = r[i + 1] || l;
              let d;
              if (s) {
                d = new Array(u - h);
                for (let n = h; n < u; n++) {
                  const i = n * a + c;
                  o = new Array(e);
                  for (let n = 0; n < e; n++) o[n] = t[i + n];
                  d[n - h] = o;
                }
              } else if (a === e) d = t.subarray(h * e + c, u * e + c);
              else {
                d = new t.constructor((u - h) * e);
                let n = 0;
                for (let i = h; i < u; i++) {
                  const r = i * a + c;
                  for (let i = 0; i < e; i++) d[n++] = t[r + i];
                }
              }
              return d;
            };
          }
          function sn(t, e = () => !0) {
            return Array.isArray(t) ? on(t, e, []) : e(t) ? [t] : [];
          }
          function on(t, e, n) {
            let i = -1;
            for (; ++i < t.length; ) {
              const r = t[i];
              Array.isArray(r) ? on(r, e, n) : e(r) && n.push(r);
            }
            return n;
          }
          function an({ target: t, source: e, start: n = 0, count: i = 1 }) {
            const r = e.length,
              s = i * r;
            let o = 0;
            for (let i = n; o < r; o++) t[i++] = e[o];
            for (; o < s; )
              o < s - o
                ? (t.copyWithin(n + o, n, n + o), (o *= 2))
                : (t.copyWithin(n + o, n, n + s - o), (o = s));
            return t;
          }
          const cn = [],
            ln = [[0, 1 / 0]];
          function hn({
            source: t,
            target: e,
            start: n = 0,
            end: i,
            size: r,
            getData: s,
          }) {
            i = i || e.length;
            const o = t.length,
              a = i - n;
            if (o > a) return void e.set(t.subarray(0, a), n);
            if ((e.set(t, n), !s)) return;
            let c = o;
            for (; c < a; ) {
              const i = s(c, t);
              for (let t = 0; t < r; t++) (e[n + c] = i[t] || 0), c++;
            }
          }
          const un = {
            interpolation: { duration: 0, easing: (t) => t },
            spring: { stiffness: 0.05, damping: 0.5 },
          };
          function dn(t, e) {
            return t
              ? (Number.isFinite(t) && (t = { duration: t }),
                (t.type = t.type || "interpolation"),
                { ...un[t.type], ...e, ...t })
              : null;
          }
          function fn(t, e) {
            return e.getBuffer()
              ? [
                  e.getBuffer(),
                  {
                    divisor: 0,
                    size: e.size,
                    normalized: e.settings.normalized,
                  },
                ]
              : e.value;
          }
          function pn(t) {
            switch (t) {
              case 1:
                return "float";
              case 2:
                return "vec2";
              case 3:
                return "vec3";
              case 4:
                return "vec4";
              default:
                throw new Error(
                  'No defined attribute type for size "'.concat(t, '"')
                );
            }
          }
          function gn(t) {
            t.push(t.shift());
          }
          function mn(t, e) {
            const { doublePrecision: n, settings: i, value: r, size: s } = t,
              o = n && r instanceof Float64Array ? 2 : 1;
            return (i.noAlloc ? r.length : e * s) * o;
          }
          function yn({
            buffer: t,
            numInstances: e,
            attribute: n,
            fromLength: i,
            fromStartIndices: r,
            getData: s = (t) => t,
          }) {
            const o =
                n.doublePrecision && n.value instanceof Float64Array ? 2 : 1,
              a = n.size * o,
              c = n.byteOffset,
              l = n.startIndices,
              h = r && l,
              u = mn(n, e),
              d = n.state.constant;
            if (!h && i >= u) return;
            const f = d ? n.value : n.getBuffer().getData({ srcByteOffset: c });
            if (n.settings.normalized && !d) {
              const t = s;
              s = (e, i) => n._normalizeConstant(t(e, i));
            }
            const p = d
                ? (t, e) => s(f, e)
                : (t, e) => s(f.subarray(t, t + a), e),
              g = t.getData({ length: i }),
              m = new Float32Array(u);
            !(function ({
              source: t,
              target: e,
              size: n,
              getData: i,
              sourceStartIndices: r,
              targetStartIndices: s,
            }) {
              if (!Array.isArray(s))
                return hn({ source: t, target: e, size: n, getData: i }), e;
              let o = 0,
                a = 0;
              const c = i && ((t, e) => i(t + a, e)),
                l = Math.min(r.length, s.length);
              for (let i = 1; i < l; i++) {
                const l = r[i] * n,
                  h = s[i] * n;
                hn({
                  source: t.subarray(o, l),
                  target: e,
                  start: a,
                  end: h,
                  size: n,
                  getData: c,
                }),
                  (o = l),
                  (a = h);
              }
              a < e.length &&
                hn({ source: [], target: e, start: a, size: n, getData: c });
            })({
              source: g,
              target: m,
              sourceStartIndices: r,
              targetStartIndices: l,
              size: a,
              getData: p,
            }),
              t.byteLength < m.byteLength + c && t.reallocate(m.byteLength + c),
              t.subData({ data: m, offset: c });
          }
          class _n extends class {
            constructor(t, e) {
              (this.gl = t), (this.id = e.id), (this.size = e.size);
              const n = e.logicalType || e.type,
                i = 5130 === n;
              let { defaultValue: r } = e;
              (r = Number.isFinite(r)
                ? [r]
                : r || new Array(this.size).fill(0)),
                (e.defaultValue = r);
              let s = n;
              i
                ? (s = 5126)
                : !s && e.isIndexed
                ? (s =
                    t &&
                    (function (t, e) {
                      return we(t, "ELEMENT_INDEX_UINT32");
                    })(t)
                      ? 5125
                      : 5123)
                : s || (s = 5126),
                (e.logicalType = n),
                (e.type = s);
              let o = (function (t) {
                switch (t) {
                  case 5126:
                    return Float32Array;
                  case 5130:
                    return Float64Array;
                  case 5123:
                  case 33635:
                  case 32819:
                  case 32820:
                    return Uint16Array;
                  case 5125:
                    return Uint32Array;
                  case 5121:
                    return Uint8ClampedArray;
                  case 5120:
                    return Int8Array;
                  case 5122:
                    return Int16Array;
                  case 5124:
                    return Int32Array;
                  default:
                    throw new Error("Unknown GL type");
                }
              })(n || s || 5126);
              (this.shaderAttributes = {}),
                (this.doublePrecision = i),
                i && !1 === e.fp64 && (o = Float32Array),
                (e.bytesPerElement = o.BYTES_PER_ELEMENT),
                (this.defaultType = o),
                (this.value = null),
                (this.settings = e),
                (this.state = {
                  externalBuffer: null,
                  bufferAccessor: e,
                  allocatedValue: null,
                  constant: !1,
                }),
                (this._buffer = null),
                this.setData(e);
            }
            get buffer() {
              if (!this._buffer) {
                const { isIndexed: t, type: e } = this.settings;
                this._buffer = new qt(this.gl, {
                  id: this.id,
                  target: t ? 34963 : 34962,
                  accessor: { type: e },
                });
              }
              return this._buffer;
            }
            get byteOffset() {
              const t = this.getAccessor();
              return t.vertexOffset ? t.vertexOffset * Ze(t) : 0;
            }
            delete() {
              this._buffer && (this._buffer.delete(), (this._buffer = null)),
                Ee.release(this.state.allocatedValue);
            }
            getShaderAttributes(t, e) {
              if (this.doublePrecision) {
                const n = {},
                  i = this.value instanceof Float64Array,
                  r = (function (t, e) {
                    const n = Ke(t, e);
                    return {
                      high: n,
                      low: { ...n, offset: n.offset + 4 * t.size },
                    };
                  })(this.getAccessor(), e || {});
                return (
                  (n[t] = new Pe(this, r.high)),
                  (n["".concat(t, "64Low")] = i
                    ? new Pe(this, r.low)
                    : new Float32Array(this.size)),
                  n
                );
              }
              if (e) {
                const n = Ke(this.getAccessor(), e);
                return { [t]: new Pe(this, n) };
              }
              return { [t]: this };
            }
            getBuffer() {
              return this.state.constant
                ? null
                : this.state.externalBuffer || this._buffer;
            }
            getValue() {
              return this.state.constant
                ? this.value
                : [this.getBuffer(), this.getAccessor()];
            }
            getAccessor() {
              return this.state.bufferAccessor;
            }
            setData(t) {
              const { state: e } = this;
              ArrayBuffer.isView(t)
                ? (t = { value: t })
                : t instanceof qt && (t = { buffer: t });
              const n = { ...this.settings, ...t };
              if (((e.bufferAccessor = n), t.constant)) {
                let n = t.value;
                if (
                  ((n = this._normalizeValue(n, [], 0)),
                  this.settings.normalized && (n = this._normalizeConstant(n)),
                  e.constant && this._areValuesEqual(n, this.value))
                )
                  return !1;
                (e.externalBuffer = null), (e.constant = !0), (this.value = n);
              } else if (t.buffer) {
                const i = t.buffer;
                (e.externalBuffer = i),
                  (e.constant = !1),
                  (this.value = t.value);
                const r = t.value instanceof Float64Array;
                (n.type = t.type || i.accessor.type),
                  (n.bytesPerElement =
                    i.accessor.BYTES_PER_ELEMENT * (r ? 2 : 1)),
                  (n.stride = Ze(n));
              } else if (t.value) {
                this._checkExternalBuffer(t);
                let i = t.value;
                (e.externalBuffer = null),
                  (e.constant = !1),
                  (this.value = i),
                  (n.bytesPerElement = i.BYTES_PER_ELEMENT),
                  (n.stride = Ze(n));
                const { buffer: r, byteOffset: s } = this;
                this.doublePrecision &&
                  i instanceof Float64Array &&
                  (i = qe(i, n));
                const o = i.byteLength + s + 2 * n.stride;
                r.byteLength < o && r.reallocate(o),
                  r.setAccessor(null),
                  r.subData({ data: i, offset: s }),
                  (n.type = t.type || r.accessor.type);
              }
              return !0;
            }
            updateSubBuffer(t = {}) {
              const { value: e } = this,
                { startOffset: n = 0, endOffset: i } = t;
              this.buffer.subData({
                data:
                  this.doublePrecision && e instanceof Float64Array
                    ? qe(e, { size: this.size, startIndex: n, endIndex: i })
                    : e.subarray(n, i),
                offset: n * e.BYTES_PER_ELEMENT + this.byteOffset,
              });
            }
            allocate({ numInstances: t, copy: e = !1 }) {
              const { state: n } = this,
                i = n.allocatedValue,
                r = Ee.allocate(i, t + 1, {
                  size: this.size,
                  type: this.defaultType,
                  copy: e,
                });
              this.value = r;
              const { buffer: s, byteOffset: o } = this;
              return (
                s.byteLength < r.byteLength + o &&
                  (s.reallocate(r.byteLength + o),
                  e &&
                    i &&
                    s.subData({
                      data: i instanceof Float64Array ? qe(i, this) : i,
                      offset: o,
                    })),
                (n.allocatedValue = r),
                (n.constant = !1),
                (n.externalBuffer = null),
                (n.bufferAccessor = this.settings),
                !0
              );
            }
            _checkExternalBuffer(t) {
              const { value: e } = t;
              if (!t.constant && e) {
                const n = this.defaultType;
                let i = !1;
                if ((this.doublePrecision && (i = e.BYTES_PER_ELEMENT < 4), i))
                  throw new Error(
                    "Attribute "
                      .concat(this.id, " does not support ")
                      .concat(e.constructor.name)
                  );
                e instanceof n ||
                  !this.settings.normalized ||
                  "normalized" in t ||
                  E.warn("Attribute ".concat(this.id, " is normalized"))();
              }
            }
            _normalizeConstant(t) {
              switch (this.settings.type) {
                case 5120:
                  return new Float32Array(t).map(
                    (t) => ((t + 128) / 255) * 2 - 1
                  );
                case 5122:
                  return new Float32Array(t).map(
                    (t) => ((t + 32768) / 65535) * 2 - 1
                  );
                case 5121:
                  return new Float32Array(t).map((t) => t / 255);
                case 5123:
                  return new Float32Array(t).map((t) => t / 65535);
                default:
                  return t;
              }
            }
            _normalizeValue(t, e, n) {
              const { defaultValue: i, size: r } = this.settings;
              if (Number.isFinite(t)) return (e[n] = t), e;
              if (!t) return (e[n] = i[0]), e;
              switch (r) {
                case 4:
                  e[n + 3] = Number.isFinite(t[3]) ? t[3] : i[3];
                case 3:
                  e[n + 2] = Number.isFinite(t[2]) ? t[2] : i[2];
                case 2:
                  e[n + 1] = Number.isFinite(t[1]) ? t[1] : i[1];
                case 1:
                  e[n + 0] = Number.isFinite(t[0]) ? t[0] : i[0];
                  break;
                default:
                  let s = r;
                  for (; --s >= 0; )
                    e[n + s] = Number.isFinite(t[s]) ? t[s] : i[s];
              }
              return e;
            }
            _areValuesEqual(t, e) {
              if (!t || !e) return !1;
              const { size: n } = this;
              for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1;
              return !0;
            }
          } {
            constructor(t, e = {}) {
              super(t, e);
              const {
                transition: n = !1,
                noAlloc: i = !1,
                update: r = null,
                accessor: s = null,
                transform: o = null,
                startIndices: a = null,
              } = e;
              Object.assign(this.settings, {
                transition: n,
                noAlloc: i,
                update: r || (s && this._autoUpdater),
                accessor: s,
                transform: o,
              }),
                Object.assign(this.state, {
                  lastExternalBuffer: null,
                  binaryValue: null,
                  binaryAccessor: null,
                  needsUpdate: !0,
                  needsRedraw: !1,
                  updateRanges: ln,
                  startIndices: a,
                }),
                Object.seal(this.settings),
                Object.seal(this.state),
                this._validateAttributeUpdaters();
            }
            get startIndices() {
              return this.state.startIndices;
            }
            set startIndices(t) {
              this.state.startIndices = t;
            }
            needsUpdate() {
              return this.state.needsUpdate;
            }
            needsRedraw({ clearChangedFlags: t = !1 } = {}) {
              const e = this.state.needsRedraw;
              return (this.state.needsRedraw = e && !t), e;
            }
            getUpdateTriggers() {
              const { accessor: t } = this.settings;
              return [this.id].concat(("function" != typeof t && t) || []);
            }
            supportsTransition() {
              return Boolean(this.settings.transition);
            }
            getTransitionSetting(t) {
              if (!t || !this.supportsTransition()) return null;
              const { accessor: e } = this.settings,
                n = this.settings.transition;
              return dn(Array.isArray(e) ? t[e.find((e) => t[e])] : t[e], n);
            }
            setNeedsUpdate(t = this.id, e) {
              if (
                ((this.state.needsUpdate = this.state.needsUpdate || t),
                this.setNeedsRedraw(t),
                e)
              ) {
                const { startRow: t = 0, endRow: n = 1 / 0 } = e;
                this.state.updateRanges = (function (t, e) {
                  if (t === ln) return t;
                  if ((e[0] < 0 && (e[0] = 0), e[0] >= e[1])) return t;
                  const n = [],
                    i = t.length;
                  let r = 0;
                  for (let s = 0; s < i; s++) {
                    const i = t[s];
                    i[1] < e[0]
                      ? (n.push(i), (r = s + 1))
                      : i[0] > e[1]
                      ? n.push(i)
                      : (e = [Math.min(i[0], e[0]), Math.max(i[1], e[1])]);
                  }
                  return n.splice(r, 0, e), n;
                })(this.state.updateRanges, [t, n]);
              } else this.state.updateRanges = ln;
            }
            clearNeedsUpdate() {
              (this.state.needsUpdate = !1), (this.state.updateRanges = cn);
            }
            setNeedsRedraw(t = this.id) {
              this.state.needsRedraw = this.state.needsRedraw || t;
            }
            update(t) {
              this.setData(t);
            }
            allocate(t) {
              const { state: e, settings: n } = this;
              return (
                !n.noAlloc &&
                !!n.update &&
                (super.allocate({
                  numInstances: t,
                  copy: e.updateRanges !== ln,
                }),
                !0)
              );
            }
            updateBuffer({ numInstances: t, data: e, props: n, context: i }) {
              if (!this.needsUpdate()) return !1;
              const {
                state: { updateRanges: r },
                settings: { update: s, noAlloc: o },
              } = this;
              let a = !0;
              if (s) {
                for (const [o, a] of r)
                  s.call(i, this, {
                    data: e,
                    startRow: o,
                    endRow: a,
                    props: n,
                    numInstances: t,
                  });
                if (this.value)
                  if (
                    this.constant ||
                    this.buffer.byteLength <
                      this.value.byteLength + this.byteOffset
                  )
                    this.setData({
                      value: this.value,
                      constant: this.constant,
                    }),
                      (this.constant = !1);
                  else
                    for (const [e, n] of r) {
                      const i = Number.isFinite(e)
                          ? this.getVertexOffset(e)
                          : 0,
                        r = Number.isFinite(n)
                          ? this.getVertexOffset(n)
                          : o || !Number.isFinite(t)
                          ? this.value.length
                          : t * this.size;
                      super.updateSubBuffer({ startOffset: i, endOffset: r });
                    }
                this._checkAttributeArray();
              } else a = !1;
              return this.clearNeedsUpdate(), this.setNeedsRedraw(), a;
            }
            setConstantValue(t) {
              return (
                void 0 !== t &&
                "function" != typeof t &&
                (this.setData({ constant: !0, value: t }) &&
                  this.setNeedsRedraw(),
                this.clearNeedsUpdate(),
                !0)
              );
            }
            setExternalBuffer(t) {
              const { state: e } = this;
              return t
                ? (this.clearNeedsUpdate(),
                  e.lastExternalBuffer === t ||
                    ((e.lastExternalBuffer = t),
                    this.setNeedsRedraw(),
                    this.setData(t)),
                  !0)
                : ((e.lastExternalBuffer = null), !1);
            }
            setBinaryValue(t, e = null) {
              const { state: n, settings: i } = this;
              if (!t)
                return (n.binaryValue = null), (n.binaryAccessor = null), !1;
              if (i.noAlloc) return !1;
              if (n.binaryValue === t) return this.clearNeedsUpdate(), !0;
              if (
                ((n.binaryValue = t),
                this.setNeedsRedraw(),
                ArrayBuffer.isView(t) && (t = { value: t }),
                i.transform || e !== this.startIndices)
              ) {
                Je(ArrayBuffer.isView(t.value), "invalid ".concat(i.accessor));
                const r = t.size && t.size !== this.size;
                return (
                  (n.binaryAccessor = rn(t.value, {
                    size: t.size || this.size,
                    stride: t.stride,
                    offset: t.offset,
                    startIndices: e,
                    nested: r,
                  })),
                  !1
                );
              }
              return this.clearNeedsUpdate(), this.setData(t), !0;
            }
            getVertexOffset(t) {
              const { startIndices: e } = this;
              return (e ? e[t] : t) * this.size;
            }
            getShaderAttributes() {
              const t = this.settings.shaderAttributes || { [this.id]: null },
                e = {};
              for (const n in t)
                Object.assign(e, super.getShaderAttributes(n, t[n]));
              return e;
            }
            _autoUpdater(
              t,
              { data: e, startRow: n, endRow: i, props: r, numInstances: s }
            ) {
              if (t.constant) return;
              const {
                  settings: o,
                  state: a,
                  value: c,
                  size: l,
                  startIndices: h,
                } = t,
                { accessor: u, transform: d } = o,
                f = a.binaryAccessor || ("function" == typeof u ? u : r[u]);
              Je(
                "function" == typeof f,
                'accessor "'.concat(u, '" is not a function')
              );
              let p = t.getVertexOffset(n);
              const { iterable: g, objectInfo: m } = en(e, n, i);
              for (const e of g) {
                m.index++;
                let n = f(e, m);
                if ((d && (n = d.call(this, n)), h)) {
                  const e =
                    (m.index < h.length - 1 ? h[m.index + 1] : s) - h[m.index];
                  if (n && Array.isArray(n[0])) {
                    let e = p;
                    for (const i of n) t._normalizeValue(i, c, e), (e += l);
                  } else
                    n && n.length > l
                      ? c.set(n, p)
                      : (t._normalizeValue(n, m.target, 0),
                        an({
                          target: c,
                          source: m.target,
                          start: p,
                          count: e,
                        }));
                  p += e * l;
                } else t._normalizeValue(n, c, p), (p += l);
              }
            }
            _validateAttributeUpdaters() {
              const { settings: t } = this;
              if (!t.noAlloc && "function" != typeof t.update)
                throw new Error(
                  "Attribute ".concat(this.id, " missing update or accessor")
                );
            }
            _checkAttributeArray() {
              const { value: t } = this,
                e = Math.min(4, this.size);
              if (t && t.length >= e) {
                let n = !0;
                switch (e) {
                  case 4:
                    n = n && Number.isFinite(t[3]);
                  case 3:
                    n = n && Number.isFinite(t[2]);
                  case 2:
                    n = n && Number.isFinite(t[1]);
                  case 1:
                    n = n && Number.isFinite(t[0]);
                    break;
                  default:
                    n = !1;
                }
                if (!n)
                  throw new Error(
                    "Illegal attribute generated for ".concat(this.id)
                  );
              }
            }
          }
          let vn = {};
          function bn(t) {
            E.level > 0 && vn[t] && vn[t].call(...arguments);
          }
          function wn(t, e) {
            if (!t) throw new Error(e || "shadertools: assertion failed.");
          }
          const xn =
              "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}",
            Pn = `#version 300 es\n${xn}`;
          function En(t, e) {
            e = Array.isArray(e) ? e : [e];
            const n = t.replace(/^\s+/, "").split(/\s+/),
              [i, r, s] = n;
            return e.includes(i) && r && s
              ? { qualifier: i, type: r, name: s.split(";")[0] }
              : null;
          }
          function An(t = {}) {
            const { version: e = 100, input: n, inputType: i, output: r } = t;
            if (!n)
              return 300 === e
                ? Pn
                : e > 300
                ? `#version ${e}\n${xn}`
                : "void main() {gl_FragColor = vec4(0);}";
            const s = (function (t, e) {
              switch (e) {
                case "float":
                  return `vec4(${t}, 0.0, 0.0, 1.0)`;
                case "vec2":
                  return `vec4(${t}, 0.0, 1.0)`;
                case "vec3":
                  return `vec4(${t}, 1.0)`;
                case "vec4":
                  return t;
                default:
                  return wn(!1), null;
              }
            })(n, i);
            return e >= 300
              ? `#version ${e} ${
                  300 === e ? "es" : ""
                }\nin ${i} ${n};\nout vec4 ${r};\nvoid main() {\n  ${r} = ${s};\n}`
              : `varying ${i} ${n};\nvoid main() {\n  gl_FragColor = ${s};\n}`;
          }
          class Tn extends Bt {
            static isSupported(t) {
              return I(t);
            }
            constructor(t, e = {}) {
              k(t),
                super(t, e),
                this.initialize(e),
                this.stubRemovedMethods("TransformFeedback", "v6.0", [
                  "pause",
                  "resume",
                ]),
                Object.seal(this);
            }
            initialize(t = {}) {
              return (
                (this.buffers = {}),
                (this.unused = {}),
                (this.configuration = null),
                (this.bindOnUse = !0),
                Ft(this.buffers) || this.bind(() => this._unbindBuffers()),
                this.setProps(t),
                this
              );
            }
            setProps(t) {
              "program" in t &&
                (this.configuration = t.program && t.program.configuration),
                "configuration" in t && (this.configuration = t.configuration),
                "bindOnUse" in t && (t = t.bindOnUse),
                "buffers" in t && this.setBuffers(t.buffers);
            }
            setBuffers(t = {}) {
              return (
                this.bind(() => {
                  for (const e in t) this.setBuffer(e, t[e]);
                }),
                this
              );
            }
            setBuffer(t, e) {
              const n = this._getVaryingIndex(t),
                {
                  buffer: i,
                  byteSize: r,
                  byteOffset: s,
                } = this._getBufferParams(e);
              return n < 0
                ? ((this.unused[t] = i),
                  C.warn(() => `${this.id} unused varying buffer ${t}`)(),
                  this)
                : ((this.buffers[n] = e),
                  this.bindOnUse || this._bindBuffer(n, i, s, r),
                  this);
            }
            begin(t = 0) {
              return (
                this.gl.bindTransformFeedback(36386, this.handle),
                this._bindBuffers(),
                this.gl.beginTransformFeedback(t),
                this
              );
            }
            end() {
              return (
                this.gl.endTransformFeedback(),
                this._unbindBuffers(),
                this.gl.bindTransformFeedback(36386, null),
                this
              );
            }
            _getBufferParams(t) {
              let e, n, i;
              return (
                t instanceof qt == 0
                  ? ((i = t.buffer), (n = t.byteSize), (e = t.byteOffset))
                  : (i = t),
                (void 0 === e && void 0 === n) ||
                  ((e = e || 0), (n = n || i.byteLength - e)),
                { buffer: i, byteOffset: e, byteSize: n }
              );
            }
            _getVaryingInfo(t) {
              return this.configuration && this.configuration.getVaryingInfo(t);
            }
            _getVaryingIndex(t) {
              if (this.configuration)
                return this.configuration.getVaryingInfo(t).location;
              const e = Number(t);
              return Number.isFinite(e) ? e : -1;
            }
            _bindBuffers() {
              if (this.bindOnUse)
                for (const t in this.buffers) {
                  const {
                    buffer: e,
                    byteSize: n,
                    byteOffset: i,
                  } = this._getBufferParams(this.buffers[t]);
                  this._bindBuffer(t, e, i, n);
                }
            }
            _unbindBuffers() {
              if (this.bindOnUse)
                for (const t in this.buffers) this._bindBuffer(t, null);
            }
            _bindBuffer(t, e, n = 0, i) {
              const r = e && e.handle;
              return (
                r && void 0 !== i
                  ? this.gl.bindBufferRange(35982, t, r, n, i)
                  : this.gl.bindBufferBase(35982, t, r),
                this
              );
            }
            _createHandle() {
              return this.gl.createTransformFeedback();
            }
            _deleteHandle() {
              this.gl.deleteTransformFeedback(this.handle);
            }
            _bindHandle(t) {
              this.gl.bindTransformFeedback(36386, this.handle);
            }
          }
          class Sn {
            constructor(t, e = {}) {
              (this.gl = t),
                (this.currentIndex = 0),
                (this.feedbackMap = {}),
                (this.varyings = null),
                (this.bindings = []),
                (this.resources = {}),
                this._initialize(e),
                Object.seal(this);
            }
            setupResources(t) {
              for (const e of this.bindings) this._setupTransformFeedback(e, t);
            }
            updateModelProps(t = {}) {
              const { varyings: e } = this;
              return (
                e.length > 0 && (t = Object.assign({}, t, { varyings: e })), t
              );
            }
            getDrawOptions(t = {}) {
              const e = this.bindings[this.currentIndex],
                { sourceBuffers: n, transformFeedback: i } = e;
              return {
                attributes: Object.assign({}, n, t.attributes),
                transformFeedback: i,
              };
            }
            swap() {
              return (
                !!this.feedbackMap &&
                ((this.currentIndex = this._getNextIndex()), !0)
              );
            }
            update(t = {}) {
              this._setupBuffers(t);
            }
            getBuffer(t) {
              const { feedbackBuffers: e } = this.bindings[this.currentIndex],
                n = t ? e[t] : null;
              return n ? (n instanceof qt ? n : n.buffer) : null;
            }
            getData(t = {}) {
              const { varyingName: e } = t,
                n = this.getBuffer(e);
              return n ? n.getData() : null;
            }
            delete() {
              for (const t in this.resources) this.resources[t].delete();
            }
            _initialize(t = {}) {
              this._setupBuffers(t),
                (this.varyings =
                  t.varyings ||
                  Object.keys(
                    this.bindings[this.currentIndex].feedbackBuffers
                  )),
                this.varyings.length > 0 && Ct(I(this.gl));
            }
            _getFeedbackBuffers(t) {
              const { sourceBuffers: e = {} } = t,
                n = {};
              if (
                (this.bindings[this.currentIndex] &&
                  Object.assign(
                    n,
                    this.bindings[this.currentIndex].feedbackBuffers
                  ),
                this.feedbackMap)
              )
                for (const t in this.feedbackMap) {
                  const i = this.feedbackMap[t];
                  t in e && (n[i] = t);
                }
              Object.assign(n, t.feedbackBuffers);
              for (const t in n) {
                const i = n[t];
                if ("string" == typeof i) {
                  const r = e[i],
                    { byteLength: s, usage: o, accessor: a } = r;
                  n[t] = this._createNewBuffer(t, {
                    byteLength: s,
                    usage: o,
                    accessor: a,
                  });
                }
              }
              return n;
            }
            _setupBuffers(t = {}) {
              const { sourceBuffers: e = null } = t;
              Object.assign(this.feedbackMap, t.feedbackMap);
              const n = this._getFeedbackBuffers(t);
              this._updateBindings({ sourceBuffers: e, feedbackBuffers: n });
            }
            _setupTransformFeedback(t, { model: e }) {
              const { program: n } = e;
              t.transformFeedback = new Tn(this.gl, {
                program: n,
                buffers: t.feedbackBuffers,
              });
            }
            _updateBindings(t) {
              if (
                ((this.bindings[this.currentIndex] = this._updateBinding(
                  this.bindings[this.currentIndex],
                  t
                )),
                this.feedbackMap)
              ) {
                const { sourceBuffers: t, feedbackBuffers: e } =
                    this._swapBuffers(this.bindings[this.currentIndex]),
                  n = this._getNextIndex();
                this.bindings[n] = this._updateBinding(this.bindings[n], {
                  sourceBuffers: t,
                  feedbackBuffers: e,
                });
              }
            }
            _updateBinding(t, e) {
              return t
                ? (Object.assign(t.sourceBuffers, e.sourceBuffers),
                  Object.assign(t.feedbackBuffers, e.feedbackBuffers),
                  t.transformFeedback &&
                    t.transformFeedback.setBuffers(t.feedbackBuffers),
                  t)
                : {
                    sourceBuffers: Object.assign({}, e.sourceBuffers),
                    feedbackBuffers: Object.assign({}, e.feedbackBuffers),
                  };
            }
            _swapBuffers(t) {
              if (!this.feedbackMap) return null;
              const e = Object.assign({}, t.sourceBuffers),
                n = Object.assign({}, t.feedbackBuffers);
              for (const i in this.feedbackMap) {
                const r = this.feedbackMap[i];
                (e[i] = t.feedbackBuffers[r]),
                  (n[r] = t.sourceBuffers[i]),
                  Ct(n[r] instanceof qt);
              }
              return { sourceBuffers: e, feedbackBuffers: n };
            }
            _createNewBuffer(t, e) {
              const n = new qt(this.gl, e);
              return (
                this.resources[t] && this.resources[t].delete(),
                (this.resources[t] = n),
                n
              );
            }
            _getNextIndex() {
              return (this.currentIndex + 1) % 2;
            }
          }
          function Mn(t) {
            let e = 100;
            const n = t.match(/[^\s]+/g);
            if (n.length >= 2 && "#version" === n[0]) {
              const t = parseInt(n[1], 10);
              Number.isFinite(t) && (e = t);
            }
            return e;
          }
          const Cn = "vs",
            Ln = "fs",
            On = {
              [Cn]: "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",
              [Ln]: "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n",
            },
            In = "__LUMA_INJECT_DECLARATIONS__",
            Rn = /void\s+main\s*\([^)]*\)\s*\{\n?/,
            kn = /}\n?[^{}]*$/,
            Fn = [];
          function zn(t, e, n, i = !1) {
            const r = e === Cn;
            for (const e in n) {
              const i = n[e];
              i.sort((t, e) => t.order - e.order), (Fn.length = i.length);
              for (let t = 0, e = i.length; t < e; ++t) Fn[t] = i[t].injection;
              const s = `${Fn.join("\n")}\n`;
              switch (e) {
                case "vs:#decl":
                  r && (t = t.replace(In, s));
                  break;
                case "vs:#main-start":
                  r && (t = t.replace(Rn, (t) => t + s));
                  break;
                case "vs:#main-end":
                  r && (t = t.replace(kn, (t) => s + t));
                  break;
                case "fs:#decl":
                  r || (t = t.replace(In, s));
                  break;
                case "fs:#main-start":
                  r || (t = t.replace(Rn, (t) => t + s));
                  break;
                case "fs:#main-end":
                  r || (t = t.replace(kn, (t) => s + t));
                  break;
                default:
                  t = t.replace(e, (t) => t + s);
              }
            }
            return (
              (t = t.replace(In, "")),
              i && (t = t.replace(/\}\s*$/, (t) => t + On[e])),
              t
            );
          }
          function jn(t) {
            const e = {};
            return (
              wn(Array.isArray(t) && t.length > 1),
              t.forEach((t) => {
                for (const n in t) e[n] = e[n] ? `${e[n]}\n${t[n]}` : t[n];
              }),
              e
            );
          }
          const Bn = {
            name: "transform",
            vs: "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",
            fs: null,
          };
          const Dn = { 10241: 9728, 10240: 9728, 10242: 33071, 10243: 33071 };
          class Nn {
            constructor(t, e = {}) {
              (this.gl = t),
                (this.id = this.currentIndex = 0),
                (this._swapTexture = null),
                (this.targetTextureVarying = null),
                (this.targetTextureType = null),
                (this.samplerTextureMap = null),
                (this.bindings = []),
                (this.resources = {}),
                this._initialize(e),
                Object.seal(this);
            }
            updateModelProps(t = {}) {
              const e = this._processVertexShader(t);
              return Object.assign({}, t, e);
            }
            getDrawOptions(t = {}) {
              const {
                  sourceBuffers: e,
                  sourceTextures: n,
                  framebuffer: i,
                  targetTexture: r,
                } = this.bindings[this.currentIndex],
                s = Object.assign({}, e, t.attributes),
                o = Object.assign({}, t.uniforms),
                a = Object.assign({}, t.parameters);
              let c = t.discard;
              if (this.hasSourceTextures || this.hasTargetTexture) {
                s.transform_elementID = this.elementIDBuffer;
                for (const t in this.samplerTextureMap) {
                  const e = this.samplerTextureMap[t];
                  o[t] = n[e];
                }
                this._setSourceTextureParameters();
                const t = (function ({
                  sourceTextureMap: t,
                  targetTextureVarying: e,
                  targetTexture: n,
                }) {
                  const i = {};
                  let r, s;
                  e &&
                    (({ width: r, height: s } = n),
                    (i[`transform_uSize_${e}`] = [r, s]));
                  for (const e in t)
                    ({ width: r, height: s } = t[e]),
                      (i[`transform_uSize_${e}`] = [r, s]);
                  return i;
                })({
                  sourceTextureMap: n,
                  targetTextureVarying: this.targetTextureVarying,
                  targetTexture: r,
                });
                Object.assign(o, t);
              }
              return (
                this.hasTargetTexture &&
                  ((c = !1), (a.viewport = [0, 0, i.width, i.height])),
                {
                  attributes: s,
                  framebuffer: i,
                  uniforms: o,
                  discard: c,
                  parameters: a,
                }
              );
            }
            swap() {
              return (
                !!this._swapTexture &&
                ((this.currentIndex = this._getNextIndex()), !0)
              );
            }
            update(t = {}) {
              this._setupTextures(t);
            }
            getTargetTexture() {
              const { targetTexture: t } = this.bindings[this.currentIndex];
              return t;
            }
            getData({ packed: t = !1 } = {}) {
              const { framebuffer: e } = this.bindings[this.currentIndex],
                n = fe(e);
              if (!t) return n;
              const i = n.constructor,
                r = (function (t) {
                  switch (t) {
                    case "float":
                      return 1;
                    case "vec2":
                      return 2;
                    case "vec3":
                      return 3;
                    case "vec4":
                      return 4;
                    default:
                      return wn(!1), null;
                  }
                })(this.targetTextureType),
                s = new i((n.length * r) / 4);
              let o = 0;
              for (let t = 0; t < n.length; t += 4)
                for (let e = 0; e < r; e++) s[o++] = n[t + e];
              return s;
            }
            getFramebuffer() {
              return this.bindings[this.currentIndex].framebuffer;
            }
            delete() {
              this.ownTexture && this.ownTexture.delete(),
                this.elementIDBuffer && this.elementIDBuffer.delete();
            }
            _initialize(t = {}) {
              const { _targetTextureVarying: e, _swapTexture: n } = t;
              (this._swapTexture = n),
                (this.targetTextureVarying = e),
                (this.hasTargetTexture = e),
                this._setupTextures(t);
            }
            _createTargetTexture(t) {
              const { sourceTextures: e, textureOrReference: n } = t;
              if (n instanceof ne) return n;
              const i = e[n];
              return i
                ? ((this._targetRefTexName = n), this._createNewTexture(i))
                : null;
            }
            _setupTextures(t = {}) {
              const {
                  sourceBuffers: e,
                  _sourceTextures: n = {},
                  _targetTexture: i,
                } = t,
                r = this._createTargetTexture({
                  sourceTextures: n,
                  textureOrReference: i,
                });
              (this.hasSourceTextures =
                this.hasSourceTextures || (n && Object.keys(n).length > 0)),
                this._updateBindings({
                  sourceBuffers: e,
                  sourceTextures: n,
                  targetTexture: r,
                }),
                "elementCount" in t &&
                  this._updateElementIDBuffer(t.elementCount);
            }
            _updateElementIDBuffer(t) {
              if ("number" != typeof t || this.elementCount >= t) return;
              const e = new Float32Array(t);
              e.forEach((t, e, n) => {
                n[e] = e;
              }),
                this.elementIDBuffer
                  ? this.elementIDBuffer.setData({ data: e })
                  : (this.elementIDBuffer = new qt(this.gl, {
                      data: e,
                      accessor: { size: 1 },
                    })),
                (this.elementCount = t);
            }
            _updateBindings(t) {
              if (
                ((this.bindings[this.currentIndex] = this._updateBinding(
                  this.bindings[this.currentIndex],
                  t
                )),
                this._swapTexture)
              ) {
                const { sourceTextures: t, targetTexture: e } =
                    this._swapTextures(this.bindings[this.currentIndex]),
                  n = this._getNextIndex();
                this.bindings[n] = this._updateBinding(this.bindings[n], {
                  sourceTextures: t,
                  targetTexture: e,
                });
              }
            }
            _updateBinding(t, e) {
              const {
                sourceBuffers: n,
                sourceTextures: i,
                targetTexture: r,
              } = e;
              if (
                (t ||
                  (t = {
                    sourceBuffers: {},
                    sourceTextures: {},
                    targetTexture: null,
                  }),
                Object.assign(t.sourceTextures, i),
                Object.assign(t.sourceBuffers, n),
                r)
              ) {
                t.targetTexture = r;
                const { width: e, height: n } = r,
                  { framebuffer: i } = t;
                i
                  ? (i.update({
                      attachments: { 36064: r },
                      resizeAttachments: !1,
                    }),
                    i.resize({ width: e, height: n }))
                  : (t.framebuffer = new ye(this.gl, {
                      id: "transform-framebuffer",
                      width: e,
                      height: n,
                      attachments: { 36064: r },
                    }));
              }
              return t;
            }
            _setSourceTextureParameters() {
              const t = this.currentIndex,
                { sourceTextures: e } = this.bindings[t];
              for (const t in e) e[t].setParameters(Dn);
            }
            _swapTextures(t) {
              if (!this._swapTexture) return null;
              const e = Object.assign({}, t.sourceTextures);
              return (
                (e[this._swapTexture] = t.targetTexture),
                {
                  sourceTextures: e,
                  targetTexture: t.sourceTextures[this._swapTexture],
                }
              );
            }
            _createNewTexture(t) {
              const e = ue(t, {
                parameters: {
                  10241: 9728,
                  10240: 9728,
                  10242: 33071,
                  10243: 33071,
                },
                pixelStore: { 37440: !1 },
              });
              return (
                this.ownTexture && this.ownTexture.delete(),
                (this.ownTexture = e),
                e
              );
            }
            _getNextIndex() {
              return (this.currentIndex + 1) % 2;
            }
            _processVertexShader(t = {}) {
              const { sourceTextures: e, targetTexture: n } =
                  this.bindings[this.currentIndex],
                {
                  vs: i,
                  uniforms: r,
                  targetTextureType: s,
                  inject: o,
                  samplerTextureMap: a,
                } = (function ({
                  vs: t,
                  sourceTextureMap: e,
                  targetTextureVarying: n,
                  targetTexture: i,
                }) {
                  let r = Object.keys(e).length,
                    s = null;
                  const o = {};
                  let a = t,
                    c = {};
                  if (r > 0 || n) {
                    const t = a.split("\n"),
                      l = t.slice();
                    if (
                      (t.forEach((t, i, a) => {
                        if (r > 0) {
                          const n = (function (t, e) {
                            const n = {},
                              i = (function (t) {
                                return En(t, ["attribute", "in"]);
                              })(t);
                            if (!i) return null;
                            const { type: r, name: s } = i;
                            if (s && e[s]) {
                              const e = `// ${t} => Replaced by Transform with a sampler`,
                                {
                                  samplerName: i,
                                  sizeName: o,
                                  uniformDeclerations: a,
                                } = (function (t) {
                                  const e = `transform_uSampler_${t}`,
                                    n = `transform_uSize_${t}`;
                                  return {
                                    samplerName: e,
                                    sizeName: n,
                                    uniformDeclerations: `  uniform sampler2D ${e};\n  uniform vec2 ${n};`,
                                  };
                                })(s),
                                c = (function (t) {
                                  switch (t) {
                                    case "float":
                                      return "x";
                                    case "vec2":
                                      return "xy";
                                    case "vec3":
                                      return "xyz";
                                    case "vec4":
                                      return "xyzw";
                                    default:
                                      return wn(!1), null;
                                  }
                                })(r),
                                l = `  ${r} ${s} = transform_getInput(${i}, ${o}).${c};\n`;
                              return (
                                (n[i] = s),
                                {
                                  updatedLine: e,
                                  inject: {
                                    "vs:#decl": a,
                                    "vs:#main-start": l,
                                  },
                                  samplerTextureMap: n,
                                }
                              );
                            }
                            return null;
                          })(t, e);
                          if (n) {
                            const { updatedLine: t, inject: e } = n;
                            (l[i] = t),
                              (c = jn([c, e])),
                              Object.assign(o, n.samplerTextureMap),
                              r--;
                          }
                        }
                        n &&
                          !s &&
                          (s = (function (t, e) {
                            const n = En(t, ["varying", "out"]);
                            return n && n.name === e ? n.type : null;
                          })(t, n));
                      }),
                      n)
                    ) {
                      Ct(i);
                      const t = `transform_uSize_${n}`;
                      c = jn([
                        c,
                        {
                          "vs:#decl": `uniform vec2 ${t};\n`,
                          "vs:#main-start": `     vec2 transform_position = transform_getPos(${t});\n     gl_Position = vec4(transform_position, 0, 1.);\n`,
                        },
                      ]);
                    }
                    a = l.join("\n");
                  }
                  return {
                    vs: a,
                    targetTextureType: s,
                    inject: c,
                    samplerTextureMap: o,
                  };
                })({
                  vs: t.vs,
                  sourceTextureMap: e,
                  targetTextureVarying: this.targetTextureVarying,
                  targetTexture: n,
                }),
                c = jn([t.inject || {}, o]);
              return (
                (this.targetTextureType = s),
                (this.samplerTextureMap = a),
                {
                  vs: i,
                  fs:
                    t._fs ||
                    An({
                      version: Mn(i),
                      input: this.targetTextureVarying,
                      inputType: s,
                      output: "transform_output",
                    }),
                  modules:
                    this.hasSourceTextures || this.targetTextureVarying
                      ? [Bn].concat(t.modules || [])
                      : t.modules,
                  uniforms: r,
                  inject: c,
                }
              );
            }
          }
          const Un = {
            number: {
              validate: (t, e) =>
                Number.isFinite(t) &&
                (!("max" in e) || t <= e.max) &&
                (!("min" in e) || t >= e.min),
            },
            array: {
              validate: (t, e) => Array.isArray(t) || ArrayBuffer.isView(t),
            },
          };
          function Vn(t) {
            let e = Gn(t);
            return "object" === e
              ? t
                ? "type" in t
                  ? Object.assign({}, t, Un[t.type])
                  : "value" in t
                  ? ((e = Gn(t.value)), Object.assign({ type: e }, t, Un[e]))
                  : { type: "object", value: t }
                : { type: "object", value: null }
              : Object.assign({ type: e, value: t }, Un[e]);
          }
          function Gn(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t)
              ? "array"
              : typeof t;
          }
          class Wn {
            constructor({
              name: t,
              vs: e,
              fs: n,
              dependencies: i = [],
              uniforms: r,
              getUniforms: s,
              deprecations: o = [],
              defines: a = {},
              inject: c = {},
              vertexShader: l,
              fragmentShader: h,
            }) {
              wn("string" == typeof t),
                (this.name = t),
                (this.vs = e || l),
                (this.fs = n || h),
                (this.getModuleUniforms = s),
                (this.dependencies = i),
                (this.deprecations = this._parseDeprecationDefinitions(o)),
                (this.defines = a),
                (this.injections = (function (t) {
                  const e = { vs: {}, fs: {} };
                  for (const n in t) {
                    let i = t[n];
                    const r = n.slice(0, 2);
                    "string" == typeof i && (i = { order: 0, injection: i }),
                      (e[r][n] = i);
                  }
                  return e;
                })(c)),
                r &&
                  (this.uniforms = (function (t) {
                    const e = {};
                    for (const n in t) {
                      const i = Vn(t[n]);
                      e[n] = i;
                    }
                    return e;
                  })(r));
            }
            getModuleSource(t) {
              let e;
              switch (t) {
                case "vs":
                  e = this.vs || "";
                  break;
                case "fs":
                  e = this.fs || "";
                  break;
                default:
                  wn(!1);
              }
              return `#define MODULE_${this.name
                .toUpperCase()
                .replace(/[^0-9a-z]/gi, "_")}\n${e}// END MODULE_${
                this.name
              }\n\n`;
            }
            getUniforms(t, e) {
              return this.getModuleUniforms
                ? this.getModuleUniforms(t, e)
                : this.uniforms
                ? this._defaultGetUniforms(t)
                : {};
            }
            getDefines() {
              return this.defines;
            }
            checkDeprecations(t, e) {
              this.deprecations.forEach((n) => {
                n.regex.test(t) &&
                  (n.deprecated
                    ? e.deprecated(n.old, n.new)()
                    : e.removed(n.old, n.new)());
              });
            }
            _parseDeprecationDefinitions(t) {
              return (
                t.forEach((t) => {
                  "function" === t.type
                    ? (t.regex = new RegExp(`\\b${t.old}\\(`))
                    : (t.regex = new RegExp(`${t.type} ${t.old};`));
                }),
                t
              );
            }
            _defaultGetUniforms(t = {}) {
              const e = {},
                n = this.uniforms;
              for (const i in n) {
                const r = n[i];
                i in t && !r.private
                  ? (r.validate &&
                      wn(r.validate(t[i], r), `${this.name}: invalid ${i}`),
                    (e[i] = t[i]))
                  : (e[i] = r.value);
              }
              return e;
            }
          }
          function Hn(t) {
            return (function (t) {
              const e = {},
                n = {};
              return (
                $n({ modules: t, level: 0, moduleMap: e, moduleDepth: n }),
                Object.keys(n)
                  .sort((t, e) => n[e] - n[t])
                  .map((t) => e[t])
              );
            })(Xn(t));
          }
          function $n({ modules: t, level: e, moduleMap: n, moduleDepth: i }) {
            if (e >= 5)
              throw new Error("Possible loop in shader dependency graph");
            for (const r of t)
              (n[r.name] = r),
                (void 0 === i[r.name] || i[r.name] < e) && (i[r.name] = e);
            for (const r of t)
              r.dependencies &&
                $n({
                  modules: r.dependencies,
                  level: e + 1,
                  moduleMap: n,
                  moduleDepth: i,
                });
          }
          function Xn(t, e) {
            return t.map(
              (t) => (
                t instanceof Wn ||
                  (wn(
                    "string" != typeof t,
                    `Shader module use by name is deprecated. Import shader module '${t}' and use it directly.`
                  ),
                  wn(t.name, "shader module has no name"),
                  ((t = new Wn(t)).dependencies = Xn(t.dependencies))),
                t
              )
            );
          }
          const Yn = {
              GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
              GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
              GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
              GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0],
            },
            qn = {};
          Object.keys(Yn).forEach((t) => {
            qn[t] = t;
          });
          const Zn = {};
          function Kn(t, e, n = {}) {
            const i = Yn[e];
            if (
              (wn(i, e),
              !(function (t = {}) {
                const e =
                    ("undefined" != typeof window && window.navigator) || {},
                  n = t.userAgent || e.userAgent || "",
                  i = -1 !== n.indexOf("MSIE "),
                  r = -1 !== n.indexOf("Trident/");
                return i || r;
              })(n))
            )
              return !0;
            if (e in Zn) return Zn[e];
            const r = `#extension GL_${i[0]} : ${
                n.behavior || "enable"
              }\nvoid main(void) {}`,
              s = t.createShader(35633);
            t.shaderSource(s, r), t.compileShader(s);
            const o = t.getShaderParameter(s, 35713);
            return t.deleteShader(s), (Zn[e] = o), o;
          }
          function Jn(t, e) {
            return (e = Array.isArray(e) ? e : [e]).every((e) =>
              (function (t, e) {
                const n = Yn[e];
                wn(n, e);
                const i =
                    ((function (t) {
                      return (
                        ("undefined" != typeof WebGL2RenderingContext &&
                          t instanceof WebGL2RenderingContext) ||
                        Boolean(t && 2 === t._version)
                      );
                    })(t) &&
                      n[1]) ||
                    n[0],
                  r = "string" == typeof i ? Boolean(t.getExtension(i)) : i;
                return wn(!1 === r || !0 === r), r;
              })(t, e)
            );
          }
          function Qn(t) {
            return new RegExp(
              `\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,
              "g"
            );
          }
          const ti = [
              [
                /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
                "#version 300 es\n",
              ],
              [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
              [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("],
            ],
            ei = [...ti, [Qn("attribute"), "in $1"], [Qn("varying"), "out $1"]],
            ni = [...ti, [Qn("varying"), "in $1"]],
            ii = [
              [/^#version[ \t]+300[ \t]+es/, "#version 100"],
              [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("],
              [/\btexture\(/g, "texture2D("],
              [/\btextureLod\(/g, "texture2DLodEXT("],
            ],
            ri = [...ii, [Qn("in"), "attribute $1"], [Qn("out"), "varying $1"]],
            si = [...ii, [Qn("in"), "varying $1"]],
            oi = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,
            ai = /void\s+main\s*\([^)]*\)\s*\{\n?/;
          function ci(t, e) {
            for (const [n, i] of e) t = t.replace(n, i);
            return t;
          }
          const li = { [Cn]: "vertex", [Ln]: "fragment" };
          function hi(
            t,
            {
              id: e,
              source: n,
              type: i,
              modules: r,
              defines: s = {},
              hookFunctions: o = [],
              inject: a = {},
              transpileToGLSL100: c = !1,
              prologue: l = !0,
              log: h,
            }
          ) {
            wn("string" == typeof n, "shader source must be a string");
            const u = i === Cn,
              d = n.split("\n");
            let f = 100,
              p = "",
              g = n;
            0 === d[0].indexOf("#version ")
              ? ((f = 300), (p = d[0]), (g = d.slice(1).join("\n")))
              : (p = `#version ${f}`);
            const m = {};
            r.forEach((t) => {
              Object.assign(m, t.getDefines());
            }),
              Object.assign(m, s);
            let y = l
              ? `${p}\n${(function ({ id: t, source: e, type: n }) {
                  return t &&
                    "string" == typeof t &&
                    -1 === e.indexOf("SHADER_NAME")
                    ? `\n#define SHADER_NAME ${t}_${li[n]}\n\n`
                    : "";
                })({ id: e, source: n, type: i })}\n${(function ({ type: t }) {
                  return `\n#define SHADER_TYPE_${li[t].toUpperCase()}\n`;
                })({ type: i })}\n${(function (t) {
                  const e = (function (t) {
                    const e = t.getExtension("WEBGL_debug_renderer_info"),
                      n = t.getParameter(
                        (e && e.UNMASKED_VENDOR_WEBGL) || 7936
                      ),
                      i = t.getParameter(
                        (e && e.UNMASKED_RENDERER_WEBGL) || 7937
                      ),
                      r = (function (t, e) {
                        return t.match(/NVIDIA/i) || e.match(/NVIDIA/i)
                          ? "NVIDIA"
                          : t.match(/INTEL/i) || e.match(/INTEL/i)
                          ? "INTEL"
                          : t.match(/AMD/i) ||
                            e.match(/AMD/i) ||
                            t.match(/ATI/i) ||
                            e.match(/ATI/i)
                          ? "AMD"
                          : "UNKNOWN GPU";
                      })(n, i);
                    return {
                      gpuVendor: r,
                      vendor: n,
                      renderer: i,
                      version: t.getParameter(7938),
                      shadingLanguageVersion: t.getParameter(35724),
                    };
                  })(t);
                  switch (e.gpuVendor.toLowerCase()) {
                    case "nvidia":
                      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
                    case "intel":
                      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
                    case "amd":
                      return "#define AMD_GPU\n";
                    default:
                      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
                  }
                })(t)}\n${(function (t, e, n) {
                  let i =
                    "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
                  return (
                    Jn(t, qn.GLSL_FRAG_DEPTH) &&
                      (i +=
                        "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"),
                    Jn(t, qn.GLSL_DERIVATIVES) &&
                      Kn(t, qn.GLSL_DERIVATIVES) &&
                      (i +=
                        "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"),
                    Jn(t, qn.GLSL_FRAG_DATA) &&
                      Kn(t, qn.GLSL_FRAG_DATA, { behavior: "require" }) &&
                      (i +=
                        "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"),
                    Jn(t, qn.GLSL_TEXTURE_LOD) &&
                      (i +=
                        "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"),
                    i
                  );
                })(t)}\n${(function (t = {}) {
                  let e = 0,
                    n = "";
                  for (const i in t) {
                    0 === e && (n += "\n// APPLICATION DEFINES\n"), e++;
                    const r = t[i];
                    (r || Number.isFinite(r)) &&
                      (n += `#define ${i.toUpperCase()} ${t[i]}\n`);
                  }
                  return 0 === e && (n += "\n"), n;
                })(m)}\n${u ? "" : "precision highp float;\n\n"}\n`
              : `${p}\n`;
            const _ = (function (t) {
                const e = { vs: {}, fs: {} };
                return (
                  t.forEach((t) => {
                    let n;
                    "string" != typeof t ? ((n = t), (t = n.hook)) : (n = {}),
                      (t = t.trim());
                    const [i, r] = t.split(":"),
                      s = t.replace(/\(.+/, "");
                    e[i][s] = Object.assign(n, { signature: r });
                  }),
                  e
                );
              })(o),
              v = {},
              b = {},
              w = {};
            for (const t in a) {
              const e =
                  "string" == typeof a[t]
                    ? { injection: a[t], order: 0 }
                    : a[t],
                n = t.match(/^(v|f)s:(#)?([\w-]+)$/);
              if (n) {
                const i = n[2],
                  r = n[3];
                i ? ("decl" === r ? (b[t] = [e]) : (w[t] = [e])) : (v[t] = [e]);
              } else w[t] = [e];
            }
            for (const t of r) {
              h && t.checkDeprecations(g, h), (y += t.getModuleSource(i, f));
              const e = t.injections[i];
              for (const t in e) {
                const n = t.match(/^(v|f)s:#([\w-]+)$/);
                if (n) {
                  const i = "decl" === n[2] ? b : w;
                  (i[t] = i[t] || []), i[t].push(e[t]);
                } else (v[t] = v[t] || []), v[t].push(e[t]);
              }
            }
            return (
              (y += "\n\n__LUMA_INJECT_DECLARATIONS__\n\n"),
              (y = zn(y, i, b)),
              (y += (function (t, e) {
                let n = "";
                for (const i in t) {
                  const r = t[i];
                  if (
                    ((n += `void ${r.signature} {\n`),
                    r.header && (n += `  ${r.header}`),
                    e[i])
                  ) {
                    const t = e[i];
                    t.sort((t, e) => t.order - e.order);
                    for (const e of t) n += `  ${e.injection}\n`;
                  }
                  r.footer && (n += `  ${r.footer}`), (n += "}\n");
                }
                return n;
              })(_[i], v)),
              (y += g),
              (y = zn(y, i, w)),
              (y = (function (t, e, n) {
                switch (e) {
                  case 300:
                    return n
                      ? ci(t, ei)
                      : (function (t) {
                          const e = (t = ci(t, ni)).match(oi);
                          if (e) {
                            const n = e[1];
                            t = t.replace(
                              new RegExp("\\bgl_FragColor\\b", "g"),
                              n
                            );
                          } else {
                            const e = "fragmentColor";
                            t = t
                              .replace(ai, (t) => `out vec4 ${e};\n${t}`)
                              .replace(
                                new RegExp("\\bgl_FragColor\\b", "g"),
                                e
                              );
                          }
                          return t;
                        })(t);
                  case 100:
                    return n
                      ? ci(t, ri)
                      : (function (t) {
                          const e = (t = ci(t, si)).match(oi);
                          if (e) {
                            const n = e[1];
                            t = t
                              .replace(oi, "")
                              .replace(
                                new RegExp(`\\b${n}\\b`, "g"),
                                "gl_FragColor"
                              );
                          }
                          return t;
                        })(t);
                  default:
                    throw new Error(`unknown GLSL version ${e}`);
                }
              })(y, c ? 100 : f, u)),
              y
            );
          }
          function ui(t) {
            return function (e) {
              const n = {};
              for (const i of t) {
                const t = i.getUniforms(e, n);
                Object.assign(n, t);
              }
              return n;
            };
          }
          const di = {
              5126: Ti.bind(null, "uniform1fv", _i, 1, Si),
              35664: Ti.bind(null, "uniform2fv", _i, 2, Si),
              35665: Ti.bind(null, "uniform3fv", _i, 3, Si),
              35666: Ti.bind(null, "uniform4fv", _i, 4, Si),
              5124: Ti.bind(null, "uniform1iv", vi, 1, Si),
              35667: Ti.bind(null, "uniform2iv", vi, 2, Si),
              35668: Ti.bind(null, "uniform3iv", vi, 3, Si),
              35669: Ti.bind(null, "uniform4iv", vi, 4, Si),
              35670: Ti.bind(null, "uniform1iv", vi, 1, Si),
              35671: Ti.bind(null, "uniform2iv", vi, 2, Si),
              35672: Ti.bind(null, "uniform3iv", vi, 3, Si),
              35673: Ti.bind(null, "uniform4iv", vi, 4, Si),
              35674: Ti.bind(null, "uniformMatrix2fv", _i, 4, Mi),
              35675: Ti.bind(null, "uniformMatrix3fv", _i, 9, Mi),
              35676: Ti.bind(null, "uniformMatrix4fv", _i, 16, Mi),
              35678: Ai,
              35680: Ai,
              5125: Ti.bind(null, "uniform1uiv", bi, 1, Si),
              36294: Ti.bind(null, "uniform2uiv", bi, 2, Si),
              36295: Ti.bind(null, "uniform3uiv", bi, 3, Si),
              36296: Ti.bind(null, "uniform4uiv", bi, 4, Si),
              35685: Ti.bind(null, "uniformMatrix2x3fv", _i, 6, Mi),
              35686: Ti.bind(null, "uniformMatrix2x4fv", _i, 8, Mi),
              35687: Ti.bind(null, "uniformMatrix3x2fv", _i, 6, Mi),
              35688: Ti.bind(null, "uniformMatrix3x4fv", _i, 12, Mi),
              35689: Ti.bind(null, "uniformMatrix4x2fv", _i, 8, Mi),
              35690: Ti.bind(null, "uniformMatrix4x3fv", _i, 12, Mi),
              35678: Ai,
              35680: Ai,
              35679: Ai,
              35682: Ai,
              36289: Ai,
              36292: Ai,
              36293: Ai,
              36298: Ai,
              36299: Ai,
              36300: Ai,
              36303: Ai,
              36306: Ai,
              36307: Ai,
              36308: Ai,
              36311: Ai,
            },
            fi = {},
            pi = {},
            gi = {},
            mi = [0];
          function yi(t, e, n, i) {
            1 === e && "boolean" == typeof t && (t = t ? 1 : 0),
              Number.isFinite(t) && ((mi[0] = t), (t = mi));
            const r = t.length;
            if (
              (r % e && C.warn(`Uniform size should be multiples of ${e}`, t)(),
              t instanceof n)
            )
              return t;
            let s = i[r];
            s || ((s = new n(r)), (i[r] = s));
            for (let e = 0; e < r; e++) s[e] = t[e];
            return s;
          }
          function _i(t, e) {
            return yi(t, e, Float32Array, fi);
          }
          function vi(t, e) {
            return yi(t, e, Int32Array, pi);
          }
          function bi(t, e) {
            return yi(t, e, Uint32Array, gi);
          }
          function wi(t, e, n) {
            const i = di[n.type];
            if (!i) throw new Error(`Unknown GLSL uniform type ${n.type}`);
            return i().bind(null, t, e);
          }
          function xi(t) {
            if ("]" !== t[t.length - 1])
              return { name: t, length: 1, isArray: !1 };
            const e = t.match(/([^[]*)(\[[0-9]+\])?/);
            if (!e || e.length < 2)
              throw new Error(`Failed to parse GLSL uniform name ${t}`);
            return { name: e[1], length: e[2] || 1, isArray: Boolean(e[2]) };
          }
          function Pi(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t)
              ? (function (t) {
                  if (0 === t.length) return !1;
                  const e = Math.min(t.length, 16);
                  for (let n = 0; n < e; ++n)
                    if (!Number.isFinite(t[n])) return !1;
                  return !0;
                })(t)
              : !!isFinite(t) ||
                  !0 === t ||
                  !1 === t ||
                  t instanceof ee ||
                  t instanceof se ||
                  (t instanceof ye && Boolean(t.texture));
          }
          function Ei(t, e, n) {
            if (Array.isArray(n) || ArrayBuffer.isView(n))
              if (t[e]) {
                const i = t[e];
                for (let t = 0, e = n.length; t < e; ++t) i[t] = n[t];
              } else t[e] = n.slice();
            else t[e] = n;
          }
          function Ai() {
            let t = null;
            return (e, n, i) => {
              const r = t !== i;
              return r && (e.uniform1i(n, i), (t = i)), r;
            };
          }
          function Ti(t, e, n, i) {
            let r = null,
              s = null;
            return (o, a, c) => {
              const l = e(c, n),
                h = l.length;
              let u = !1;
              if (null === r) (r = new Float32Array(h)), (s = h), (u = !0);
              else {
                Ct(s === h, "Uniform length cannot change.");
                for (let t = 0; t < h; ++t)
                  if (l[t] !== r[t]) {
                    u = !0;
                    break;
                  }
              }
              return u && (i(o, t, a, l), r.set(l)), u;
            };
          }
          function Si(t, e, n, i) {
            t[e](n, i);
          }
          function Mi(t, e, n, i) {
            t[e](n, !1, i);
          }
          function Ci(t, e = "unnamed") {
            const n = t.match(
              /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/
            );
            return n ? n[1] : e;
          }
          function Li(t, e) {
            let n = "";
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              if (
                (t[i + 3] || t[i + 2] || t[i + 1]) &&
                ((n += `${r}\n`), t[i + 1])
              ) {
                const e = t[i + 1],
                  r = e.split(":", 3),
                  s = r[0],
                  o = parseInt(r[1], 10) || 0;
                n += Oi(
                  `^^^ ${s}: ${e.substring(r.join(":").length + 1).trim()}\n\n`,
                  o
                );
              }
            }
            return n;
          }
          function Oi(t, e) {
            let n = "";
            for (let t = 0; t < e; ++t) n += " ";
            return `${n}${t}`;
          }
          class Ii extends Bt {
            static getTypeName(t) {
              switch (t) {
                case 35633:
                  return "vertex-shader";
                case 35632:
                  return "fragment-shader";
                default:
                  return Ct(!1), "unknown";
              }
            }
            constructor(t, e) {
              R(t),
                Ct(
                  "string" == typeof e.source,
                  "Shader: GLSL source code must be a JavaScript string"
                ),
                super(t, {
                  id:
                    Ci(e.source, null) ||
                    e.id ||
                    Rt(`unnamed ${Ii.getTypeName(e.shaderType)}`),
                }),
                (this.shaderType = e.shaderType),
                (this.source = e.source),
                this.initialize(e);
            }
            initialize({ source: t }) {
              const e = Ci(t, null);
              e && (this.id = Rt(e)), this._compile(t);
            }
            getParameter(t) {
              return this.gl.getShaderParameter(this.handle, t);
            }
            toString() {
              return `${Ii.getTypeName(this.shaderType)}:${this.id}`;
            }
            getName() {
              return Ci(this.source) || "unnamed-shader";
            }
            getSource() {
              return this.gl.getShaderSource(this.handle);
            }
            getTranslatedSource() {
              const t = this.gl.getExtension("WEBGL_debug_shaders");
              return t
                ? t.getTranslatedShaderSource(this.handle)
                : "No translated source available. WEBGL_debug_shaders not implemented";
            }
            _compile(t = this.source) {
              if (
                (t.startsWith("#version ") || (t = `#version 100\n${t}`),
                (this.source = t),
                this.gl.shaderSource(this.handle, this.source),
                this.gl.compileShader(this.handle),
                !this.getParameter(35713))
              ) {
                const t = this.gl.getShaderInfoLog(this.handle),
                  {
                    shaderName: e,
                    errors: n,
                    warnings: i,
                  } = (function (t, e, n, i) {
                    const r = t.split(/\r?\n/),
                      s = {},
                      o = {},
                      a = i || Ci(e) || "(unnamed)",
                      c = `${(function (t) {
                        switch (t) {
                          case 35632:
                            return "fragment";
                          case 35633:
                            return "vertex";
                          default:
                            return "unknown type";
                        }
                      })(n)} shader ${a}`;
                    for (let e = 0; e < r.length; e++) {
                      const n = r[e];
                      if (n.length <= 1) continue;
                      const i = n.split(":"),
                        a = i[0],
                        l = parseInt(i[2], 10);
                      if (isNaN(l))
                        throw new Error(`GLSL compilation error in ${c}: ${t}`);
                      "WARNING" !== a ? (s[l] = n) : (o[l] = n);
                    }
                    const l = (function (t, e = 1, n = ": ") {
                      const i = t.split(/\r?\n/),
                        r = String(i.length + e - 1).length;
                      return i.map((t, i) => {
                        const s = String(i + e),
                          o = s.length;
                        return Oi(s, r - o) + n + t;
                      });
                    })(e);
                    return {
                      shaderName: c,
                      errors: Li(s, l),
                      warnings: Li(o, l),
                    };
                  })(t, this.source, this.shaderType, this.id);
                throw (
                  (C.error(`GLSL compilation errors in ${e}\n${n}`)(),
                  C.warn(`GLSL compilation warnings in ${e}\n${i}`)(),
                  new Error(`GLSL compilation errors in ${e}`))
                );
              }
            }
            _deleteHandle() {
              this.gl.deleteShader(this.handle);
            }
            _getOptsFromHandle() {
              return {
                type: this.getParameter(35663),
                source: this.getSource(),
              };
            }
          }
          class Ri extends Ii {
            constructor(t, e) {
              "string" == typeof e && (e = { source: e }),
                super(t, Object.assign({}, e, { shaderType: 35633 }));
            }
            _createHandle() {
              return this.gl.createShader(35633);
            }
          }
          class ki extends Ii {
            constructor(t, e) {
              "string" == typeof e && (e = { source: e }),
                super(t, Object.assign({}, e, { shaderType: 35632 }));
            }
            _createHandle() {
              return this.gl.createShader(35632);
            }
          }
          const Fi = 5126,
            zi = 5124,
            ji = 5125,
            Bi = {
              [Fi]: [Fi, 1, "float"],
              35664: [Fi, 2, "vec2"],
              35665: [Fi, 3, "vec3"],
              35666: [Fi, 4, "vec4"],
              [zi]: [zi, 1, "int"],
              35667: [zi, 2, "ivec2"],
              35668: [zi, 3, "ivec3"],
              35669: [zi, 4, "ivec4"],
              [ji]: [ji, 1, "uint"],
              36294: [ji, 2, "uvec2"],
              36295: [ji, 3, "uvec3"],
              36296: [ji, 4, "uvec4"],
              35670: [Fi, 1, "bool"],
              35671: [Fi, 2, "bvec2"],
              35672: [Fi, 3, "bvec3"],
              35673: [Fi, 4, "bvec4"],
              35674: [Fi, 8, "mat2"],
              35685: [Fi, 8, "mat2x3"],
              35686: [Fi, 8, "mat2x4"],
              35675: [Fi, 12, "mat3"],
              35687: [Fi, 12, "mat3x2"],
              35688: [Fi, 12, "mat3x4"],
              35676: [Fi, 16, "mat4"],
              35689: [Fi, 16, "mat4x2"],
              35690: [Fi, 16, "mat4x3"],
            };
          function Di(t) {
            const e = Bi[t];
            if (!e) return null;
            const [n, i] = e;
            return { type: n, components: i };
          }
          function Ni(t, e) {
            switch (t) {
              case 5120:
              case 5121:
              case 5122:
              case 5123:
                t = Fi;
            }
            for (const n in Bi) {
              const [i, r, s] = Bi[n];
              if (i === t && r === e) return { glType: n, name: s };
            }
            return null;
          }
          class Ui {
            constructor(t) {
              (this.id = t.id),
                (this.attributeInfos = []),
                (this.attributeInfosByName = {}),
                (this.attributeInfosByLocation = []),
                (this.varyingInfos = []),
                (this.varyingInfosByName = {}),
                Object.seal(this),
                this._readAttributesFromProgram(t),
                this._readVaryingsFromProgram(t);
            }
            getAttributeInfo(t) {
              const e = Number(t);
              return Number.isFinite(e)
                ? this.attributeInfosByLocation[e]
                : this.attributeInfosByName[t] || null;
            }
            getAttributeLocation(t) {
              const e = this.getAttributeInfo(t);
              return e ? e.location : -1;
            }
            getAttributeAccessor(t) {
              const e = this.getAttributeInfo(t);
              return e ? e.accessor : null;
            }
            getVaryingInfo(t) {
              const e = Number(t);
              return Number.isFinite(e)
                ? this.varyingInfos[e]
                : this.varyingInfosByName[t] || null;
            }
            getVaryingIndex(t) {
              const e = this.getVaryingInfo();
              return e ? e.location : -1;
            }
            getVaryingAccessor(t) {
              const e = this.getVaryingInfo();
              return e ? e.accessor : null;
            }
            _readAttributesFromProgram(t) {
              const { gl: e } = t,
                n = e.getProgramParameter(t.handle, 35721);
              for (let i = 0; i < n; i++) {
                const {
                    name: n,
                    type: r,
                    size: s,
                  } = e.getActiveAttrib(t.handle, i),
                  o = e.getAttribLocation(t.handle, n);
                o >= 0 && this._addAttribute(o, n, r, s);
              }
              this.attributeInfos.sort((t, e) => t.location - e.location);
            }
            _readVaryingsFromProgram(t) {
              const { gl: e } = t;
              if (!I(e)) return;
              const n = e.getProgramParameter(t.handle, 35971);
              for (let i = 0; i < n; i++) {
                const {
                  name: n,
                  type: r,
                  size: s,
                } = e.getTransformFeedbackVarying(t.handle, i);
                this._addVarying(i, n, r, s);
              }
              this.varyingInfos.sort((t, e) => t.location - e.location);
            }
            _addAttribute(t, e, n, i) {
              const { type: r, components: s } = Di(n),
                o = { type: r, size: i * s };
              this._inferProperties(t, e, o);
              const a = { location: t, name: e, accessor: new Ht(o) };
              this.attributeInfos.push(a),
                (this.attributeInfosByLocation[t] = a),
                (this.attributeInfosByName[a.name] = a);
            }
            _inferProperties(t, e, n) {
              /instance/i.test(e) && (n.divisor = 1);
            }
            _addVarying(t, e, n, i) {
              const { type: r, components: s } = Di(n),
                o = {
                  location: t,
                  name: e,
                  accessor: new Ht({ type: r, size: i * s }),
                };
              this.varyingInfos.push(o), (this.varyingInfosByName[o.name] = o);
            }
          }
          const Vi = 35981,
            Gi = [
              "setVertexArray",
              "setAttributes",
              "setBuffers",
              "unsetBuffers",
              "use",
              "getUniformCount",
              "getUniformInfo",
              "getUniformLocation",
              "getUniformValue",
              "getVarying",
              "getFragDataLocation",
              "getAttachedShaders",
              "getAttributeCount",
              "getAttributeLocation",
              "getAttributeInfo",
            ];
          class Wi extends Bt {
            constructor(t, e = {}) {
              super(t, e),
                this.stubRemovedMethods("Program", "v6.0", Gi),
                (this._isCached = !1),
                this.initialize(e),
                Object.seal(this),
                this._setId(e.id);
            }
            initialize(t = {}) {
              const {
                hash: e,
                vs: n,
                fs: i,
                varyings: r,
                bufferMode: s = Vi,
              } = t;
              return (
                (this.hash = e || ""),
                (this.vs =
                  "string" == typeof n
                    ? new Ri(this.gl, { id: `${t.id}-vs`, source: n })
                    : n),
                (this.fs =
                  "string" == typeof i
                    ? new ki(this.gl, { id: `${t.id}-fs`, source: i })
                    : i),
                Ct(this.vs instanceof Ri),
                Ct(this.fs instanceof ki),
                (this.uniforms = {}),
                (this._textureUniforms = {}),
                r &&
                  r.length > 0 &&
                  (k(this.gl),
                  (this.varyings = r),
                  this.gl2.transformFeedbackVaryings(this.handle, r, s)),
                this._compileAndLink(),
                this._readUniformLocationsFromLinkedProgram(),
                (this.configuration = new Ui(this)),
                this.setProps(t)
              );
            }
            delete(t = {}) {
              return this._isCached ? this : super.delete(t);
            }
            setProps(t) {
              return "uniforms" in t && this.setUniforms(t.uniforms), this;
            }
            draw({
              logPriority: t,
              drawMode: e = 4,
              vertexCount: n,
              offset: i = 0,
              start: r,
              end: s,
              isIndexed: o = !1,
              indexType: a = 5123,
              instanceCount: c = 0,
              isInstanced: l = c > 0,
              vertexArray: h = null,
              transformFeedback: u,
              framebuffer: d,
              parameters: f = {},
              uniforms: p,
              samplers: g,
            }) {
              if (
                ((p || g) &&
                  (C.deprecated(
                    "Program.draw({uniforms})",
                    "Program.setUniforms(uniforms)"
                  )(),
                  this.setUniforms(p || {})),
                C.priority >= t)
              ) {
                const i = d ? d.id : "default",
                  r = `mode=${Ot(
                    this.gl,
                    e
                  )} verts=${n} instances=${c} indexType=${Ot(
                    this.gl,
                    a
                  )} isInstanced=${l} isIndexed=${o} Framebuffer=${i}`;
                C.log(t, r)();
              }
              return (
                Ct(h),
                this.gl.useProgram(this.handle),
                !(
                  !this._areTexturesRenderable() ||
                  0 === n ||
                  (l && 0 === c) ||
                  (h.bindForDraw(n, c, () => {
                    if (
                      (void 0 !== d &&
                        (f = Object.assign({}, f, { framebuffer: d })),
                      u)
                    ) {
                      const t = (function (t) {
                        switch (t) {
                          case 0:
                            return 0;
                          case 1:
                          case 3:
                          case 2:
                            return 1;
                          case 4:
                          case 5:
                          case 6:
                            return 4;
                          default:
                            return Ct(!1), 0;
                        }
                      })(e);
                      u.begin(t);
                    }
                    this._bindTextures(),
                      pt(this.gl, f, () => {
                        o && l
                          ? this.gl2.drawElementsInstanced(e, n, a, i, c)
                          : o && I(this.gl) && !isNaN(r) && !isNaN(s)
                          ? this.gl2.drawRangeElements(e, r, s, n, a, i)
                          : o
                          ? this.gl.drawElements(e, n, a, i)
                          : l
                          ? this.gl2.drawArraysInstanced(e, i, n, c)
                          : this.gl.drawArrays(e, i, n);
                      }),
                      u && u.end();
                  }),
                  0)
                )
              );
            }
            setUniforms(t = {}) {
              C.priority >= 2 &&
                (function (t, e, n) {
                  for (const i in t) {
                    const r = t[i];
                    if ((!n || Boolean(n[i])) && !Pi(r))
                      throw (
                        ((e = e ? `${e} ` : ""),
                        console.error(`${e} Bad uniform ${i}`, r),
                        new Error(`${e} Bad uniform ${i}`))
                      );
                  }
                })(t, this.id, this._uniformSetters),
                this.gl.useProgram(this.handle);
              for (const e in t) {
                const n = t[e],
                  i = this._uniformSetters[e];
                if (i) {
                  let t = n,
                    r = !1;
                  if ((t instanceof ye && (t = t.texture), t instanceof ee))
                    if (((r = this.uniforms[e] !== n), r)) {
                      void 0 === i.textureIndex &&
                        (i.textureIndex = this._textureIndexCounter++);
                      const n = t,
                        { textureIndex: r } = i;
                      n.bind(r), (t = r), (this._textureUniforms[e] = n);
                    } else t = i.textureIndex;
                  else
                    this._textureUniforms[e] && delete this._textureUniforms[e];
                  (i(t) || r) && Ei(this.uniforms, e, n);
                }
              }
              return this;
            }
            _areTexturesRenderable() {
              let t = !0;
              for (const e in this._textureUniforms) {
                const n = this._textureUniforms[e];
                n.update(), (t = t && n.loaded);
              }
              return t;
            }
            _bindTextures() {
              for (const t in this._textureUniforms) {
                const e = this._uniformSetters[t].textureIndex;
                this._textureUniforms[t].bind(e);
              }
            }
            _createHandle() {
              return this.gl.createProgram();
            }
            _deleteHandle() {
              this.gl.deleteProgram(this.handle);
            }
            _getOptionsFromHandle(t) {
              const e = this.gl.getAttachedShaders(t),
                n = {};
              for (const t of e)
                switch (this.gl.getShaderParameter(this.handle, 35663)) {
                  case 35633:
                    n.vs = new Ri({ handle: t });
                    break;
                  case 35632:
                    n.fs = new ki({ handle: t });
                }
              return n;
            }
            _getParameter(t) {
              return this.gl.getProgramParameter(this.handle, t);
            }
            _setId(t) {
              if (!t) {
                const t = this._getName();
                this.id = Rt(t);
              }
            }
            _getName() {
              let t = this.vs.getName() || this.fs.getName();
              return (
                (t = t.replace(/shader/i, "")),
                (t = t ? `${t}-program` : "program"),
                t
              );
            }
            _compileAndLink() {
              const { gl: t } = this;
              if (
                (t.attachShader(this.handle, this.vs.handle),
                t.attachShader(this.handle, this.fs.handle),
                C.time(4, `linkProgram for ${this._getName()}`)(),
                t.linkProgram(this.handle),
                C.timeEnd(4, `linkProgram for ${this._getName()}`)(),
                t.debug || C.level > 0)
              ) {
                if (!t.getProgramParameter(this.handle, 35714))
                  throw new Error(
                    `Error linking: ${t.getProgramInfoLog(this.handle)}`
                  );
                if (
                  (t.validateProgram(this.handle),
                  !t.getProgramParameter(this.handle, 35715))
                )
                  throw new Error(
                    `Error validating: ${t.getProgramInfoLog(this.handle)}`
                  );
              }
            }
            _readUniformLocationsFromLinkedProgram() {
              const { gl: t } = this;
              (this._uniformSetters = {}),
                (this._uniformCount = this._getParameter(35718));
              for (let e = 0; e < this._uniformCount; e++) {
                const n = this.gl.getActiveUniform(this.handle, e),
                  { name: i } = xi(n.name);
                let r = t.getUniformLocation(this.handle, i);
                if (((this._uniformSetters[i] = wi(t, r, n)), n.size > 1))
                  for (let e = 0; e < n.size; e++)
                    (r = t.getUniformLocation(this.handle, `${i}[${e}]`)),
                      (this._uniformSetters[`${i}[${e}]`] = wi(t, r, n));
              }
              this._textureIndexCounter = 0;
            }
            getActiveUniforms(t, e) {
              return this.gl2.getActiveUniforms(this.handle, t, e);
            }
            getUniformBlockIndex(t) {
              return this.gl2.getUniformBlockIndex(this.handle, t);
            }
            getActiveUniformBlockParameter(t, e) {
              return this.gl2.getActiveUniformBlockParameter(this.handle, t, e);
            }
            uniformBlockBinding(t, e) {
              this.gl2.uniformBlockBinding(this.handle, t, e);
            }
          }
          class Hi {
            static getDefaultProgramManager(t) {
              return (
                (t.luma = t.luma || {}),
                (t.luma.defaultProgramManager =
                  t.luma.defaultProgramManager || new Hi(t)),
                t.luma.defaultProgramManager
              );
            }
            constructor(t) {
              (this.gl = t),
                (this._programCache = {}),
                (this._getUniforms = {}),
                (this._registeredModules = {}),
                (this._hookFunctions = []),
                (this._defaultModules = []),
                (this._hashes = {}),
                (this._hashCounter = 0),
                (this.stateHash = 0),
                (this._useCounts = {});
            }
            addDefaultModule(t) {
              this._defaultModules.find((e) => e.name === t.name) ||
                this._defaultModules.push(t),
                this.stateHash++;
            }
            removeDefaultModule(t) {
              const e = "string" == typeof t ? t : t.name;
              (this._defaultModules = this._defaultModules.filter(
                (t) => t.name !== e
              )),
                this.stateHash++;
            }
            addShaderHook(t, e) {
              e && (t = Object.assign(e, { hook: t })),
                this._hookFunctions.push(t),
                this.stateHash++;
            }
            get(t = {}) {
              const {
                  vs: e = "",
                  fs: n = "",
                  defines: i = {},
                  inject: r = {},
                  varyings: s = [],
                  bufferMode: o = 35981,
                  transpileToGLSL100: a = !1,
                } = t,
                c = this._getModuleList(t.modules),
                l = this._getHash(e),
                h = this._getHash(n),
                u = c.map((t) => this._getHash(t.name)).sort(),
                d = s.map((t) => this._getHash(t)),
                f = Object.keys(i).sort(),
                p = Object.keys(r).sort(),
                g = [],
                m = [];
              for (const t of f)
                g.push(this._getHash(t)), g.push(this._getHash(i[t]));
              for (const t of p)
                m.push(this._getHash(t)), m.push(this._getHash(r[t]));
              const y = `${l}/${h}D${g.join("/")}M${u.join("/")}I${m.join(
                "/"
              )}V${d.join("/")}H${this.stateHash}B${o}${a ? "T" : ""}`;
              if (!this._programCache[y]) {
                const t = (function (t, e) {
                  const { vs: n, fs: i } = e,
                    r = Hn(e.modules || []);
                  return {
                    gl: t,
                    vs: hi(
                      t,
                      Object.assign({}, e, { source: n, type: Cn, modules: r })
                    ),
                    fs: hi(
                      t,
                      Object.assign({}, e, { source: i, type: Ln, modules: r })
                    ),
                    getUniforms: ui(r),
                  };
                })(this.gl, {
                  vs: e,
                  fs: n,
                  modules: c,
                  inject: r,
                  defines: i,
                  hookFunctions: this._hookFunctions,
                  transpileToGLSL100: a,
                });
                (this._programCache[y] = new Wi(this.gl, {
                  hash: y,
                  vs: t.vs,
                  fs: t.fs,
                  varyings: s,
                  bufferMode: o,
                })),
                  (this._getUniforms[y] = t.getUniforms || ((t) => {})),
                  (this._useCounts[y] = 0);
              }
              return this._useCounts[y]++, this._programCache[y];
            }
            getUniforms(t) {
              return this._getUniforms[t.hash] || null;
            }
            release(t) {
              const e = t.hash;
              this._useCounts[e]--,
                0 === this._useCounts[e] &&
                  (this._programCache[e].delete(),
                  delete this._programCache[e],
                  delete this._getUniforms[e],
                  delete this._useCounts[e]);
            }
            _getHash(t) {
              return (
                void 0 === this._hashes[t] &&
                  (this._hashes[t] = this._hashCounter++),
                this._hashes[t]
              );
            }
            _getModuleList(t = []) {
              const e = new Array(this._defaultModules.length + t.length),
                n = {};
              let i = 0;
              for (let t = 0, r = this._defaultModules.length; t < r; ++t) {
                const r = this._defaultModules[t],
                  s = r.name;
                (e[i++] = r), (n[s] = !0);
              }
              for (let r = 0, s = t.length; r < s; ++r) {
                const s = t[r],
                  o = s.name;
                n[o] || ((e[i++] = s), (n[o] = !0));
              }
              return (e.length = i), e;
            }
          }
          let $i = null;
          class Xi extends Bt {
            static isSupported(n, i = {}) {
              return (
                !i.constantAttributeZero ||
                I(n) ||
                "Chrome" ===
                  (function (n) {
                    if (!e()) return "Node";
                    if (t(n)) return "Electron";
                    const i =
                      ("undefined" != typeof navigator ? navigator : {})
                        .userAgent || "";
                    if (i.indexOf("Edge") > -1) return "Edge";
                    const r = -1 !== i.indexOf("MSIE "),
                      s = -1 !== i.indexOf("Trident/");
                    return r || s
                      ? "IE"
                      : d.chrome
                      ? "Chrome"
                      : d.safari
                      ? "Safari"
                      : d.mozInnerScreenX
                      ? "Firefox"
                      : "Unknown";
                  })()
              );
            }
            static getDefaultArray(t) {
              return (
                (t.luma = t.luma || {}),
                t.luma.defaultVertexArray ||
                  (t.luma.defaultVertexArray = new Xi(t, {
                    handle: null,
                    isDefaultArray: !0,
                  })),
                t.luma.defaultVertexArray
              );
            }
            static getMaxAttributes(t) {
              return (
                (Xi.MAX_ATTRIBUTES =
                  Xi.MAX_ATTRIBUTES || t.getParameter(34921)),
                Xi.MAX_ATTRIBUTES
              );
            }
            static setConstant(t, e, n) {
              switch (n.constructor) {
                case Float32Array:
                  Xi._setConstantFloatArray(t, e, n);
                  break;
                case Int32Array:
                  Xi._setConstantIntArray(t, e, n);
                  break;
                case Uint32Array:
                  Xi._setConstantUintArray(t, e, n);
                  break;
                default:
                  Ct(!1);
              }
            }
            constructor(t, e = {}) {
              const n = e.id || (e.program && e.program.id);
              super(t, Object.assign({}, e, { id: n })),
                (this.buffer = null),
                (this.bufferValue = null),
                (this.isDefaultArray = e.isDefaultArray || !1),
                (this.gl2 = t),
                this.initialize(e),
                Object.seal(this);
            }
            delete() {
              return super.delete(), this.buffer && this.buffer.delete(), this;
            }
            get MAX_ATTRIBUTES() {
              return Xi.getMaxAttributes(this.gl);
            }
            initialize(t = {}) {
              return this.setProps(t);
            }
            setProps(t) {
              return this;
            }
            setElementBuffer(t = null, e = {}) {
              return (
                Ct(
                  !t || 34963 === t.target,
                  "elements must be GL.ELEMENT_ARRAY_BUFFER"
                ),
                this.bind(() => {
                  this.gl.bindBuffer(34963, t ? t.handle : null);
                }),
                this
              );
            }
            setBuffer(t, e, n) {
              if (34963 === e.target) return this.setElementBuffer(e, n);
              const {
                  size: i,
                  type: r,
                  stride: s,
                  offset: o,
                  normalized: a,
                  integer: c,
                  divisor: l,
                } = n,
                { gl: h, gl2: u } = this;
              return (
                (t = Number(t)),
                this.bind(() => {
                  h.bindBuffer(34962, e.handle),
                    c
                      ? (Ct(I(h)), u.vertexAttribIPointer(t, i, r, s, o))
                      : h.vertexAttribPointer(t, i, r, a, s, o),
                    h.enableVertexAttribArray(t),
                    u.vertexAttribDivisor(t, l || 0);
                }),
                this
              );
            }
            enable(t, e = !0) {
              return (
                (!e &&
                  0 === t &&
                  !Xi.isSupported(this.gl, { constantAttributeZero: !0 })) ||
                  ((t = Number(t)),
                  this.bind(() =>
                    e
                      ? this.gl.enableVertexAttribArray(t)
                      : this.gl.disableVertexAttribArray(t)
                  )),
                this
              );
            }
            getConstantBuffer(t, e) {
              const n = this._normalizeConstantArrayValue(e),
                i = n.byteLength * t,
                r = n.length * t;
              let s = !this.buffer;
              if (
                ((this.buffer = this.buffer || new qt(this.gl, i)),
                (s = s || this.buffer.reallocate(i)),
                (s =
                  s || !this._compareConstantArrayValues(n, this.bufferValue)),
                s)
              ) {
                const t = (function (t, e) {
                  var n;
                  return new t(
                    ((n = t.BYTES_PER_ELEMENT * e),
                    (!$i || $i.byteLength < n) && ($i = new ArrayBuffer(n)),
                    $i),
                    0,
                    e
                  );
                })(e.constructor, r);
                !(function ({
                  target: t,
                  source: e,
                  start: n = 0,
                  count: i = 1,
                }) {
                  const r = e.length,
                    s = i * r;
                  let o = 0;
                  for (let i = n; o < r; o++) t[i++] = e[o];
                  for (; o < s; )
                    o < s - o
                      ? (t.copyWithin(n + o, n, n + o), (o *= 2))
                      : (t.copyWithin(n + o, n, n + s - o), (o = s));
                })({ target: t, source: n, start: 0, count: r }),
                  this.buffer.subData(t),
                  (this.bufferValue = e);
              }
              return this.buffer;
            }
            _normalizeConstantArrayValue(t) {
              return Array.isArray(t) ? new Float32Array(t) : t;
            }
            _compareConstantArrayValues(t, e) {
              if (
                !t ||
                !e ||
                t.length !== e.length ||
                t.constructor !== e.constructor
              )
                return !1;
              for (let n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;
              return !0;
            }
            static _setConstantFloatArray(t, e, n) {
              switch (n.length) {
                case 1:
                  t.vertexAttrib1fv(e, n);
                  break;
                case 2:
                  t.vertexAttrib2fv(e, n);
                  break;
                case 3:
                  t.vertexAttrib3fv(e, n);
                  break;
                case 4:
                  t.vertexAttrib4fv(e, n);
                  break;
                default:
                  Ct(!1);
              }
            }
            static _setConstantIntArray(t, e, n) {
              switch ((Ct(I(t)), n.length)) {
                case 1:
                  t.vertexAttribI1iv(e, n);
                  break;
                case 2:
                  t.vertexAttribI2iv(e, n);
                  break;
                case 3:
                  t.vertexAttribI3iv(e, n);
                  break;
                case 4:
                  t.vertexAttribI4iv(e, n);
                  break;
                default:
                  Ct(!1);
              }
            }
            static _setConstantUintArray(t, e, n) {
              switch ((Ct(I(t)), n.length)) {
                case 1:
                  t.vertexAttribI1uiv(e, n);
                  break;
                case 2:
                  t.vertexAttribI2uiv(e, n);
                  break;
                case 3:
                  t.vertexAttribI3uiv(e, n);
                  break;
                case 4:
                  t.vertexAttribI4uiv(e, n);
                  break;
                default:
                  Ct(!1);
              }
            }
            _createHandle() {
              return this.gl.createVertexArray();
            }
            _deleteHandle(t) {
              return this.gl2.deleteVertexArray(t), [this.elements];
            }
            _bindHandle(t) {
              this.gl2.bindVertexArray(t);
            }
            _getParameter(t, { location: e }) {
              return (
                Ct(Number.isFinite(e)),
                this.bind(() =>
                  34373 === t
                    ? this.gl.getVertexAttribOffset(e, t)
                    : this.gl.getVertexAttrib(e, t)
                )
              );
            }
          }
          const Yi = /^(.+)__LOCATION_([0-9]+)$/,
            qi = [
              "setBuffers",
              "setGeneric",
              "clearBindings",
              "setLocations",
              "setGenericValues",
              "setDivisor",
              "enable",
              "disable",
            ];
          class Zi {
            constructor(t, e = {}) {
              const n = e.id || (e.program && e.program.id);
              (this.id = n),
                (this.gl = t),
                (this.configuration = null),
                (this.elements = null),
                (this.elementsAccessor = null),
                (this.values = null),
                (this.accessors = null),
                (this.unused = null),
                (this.drawParams = null),
                (this.buffer = null),
                (this.attributes = {}),
                (this.vertexArrayObject = new Xi(t)),
                zt(this, "VertexArray", "v6.0", qi),
                this.initialize(e),
                Object.seal(this);
            }
            delete() {
              this.buffer && this.buffer.delete(),
                this.vertexArrayObject.delete();
            }
            initialize(t = {}) {
              return (
                this.reset(),
                (this.configuration = null),
                (this.bindOnUse = !1),
                this.setProps(t)
              );
            }
            reset() {
              (this.elements = null), (this.elementsAccessor = null);
              const { MAX_ATTRIBUTES: t } = this.vertexArrayObject;
              return (
                (this.values = new Array(t).fill(null)),
                (this.accessors = new Array(t).fill(null)),
                (this.unused = {}),
                (this.drawParams = null),
                this
              );
            }
            setProps(t) {
              return (
                "program" in t &&
                  (this.configuration = t.program && t.program.configuration),
                "configuration" in t && (this.configuration = t.configuration),
                "attributes" in t && this.setAttributes(t.attributes),
                "elements" in t && this.setElementBuffer(t.elements),
                "bindOnUse" in t && (t = t.bindOnUse),
                this
              );
            }
            clearDrawParams() {
              this.drawParams = null;
            }
            getDrawParams() {
              return (
                (this.drawParams = this.drawParams || this._updateDrawParams()),
                this.drawParams
              );
            }
            setAttributes(t) {
              return (
                Object.assign(this.attributes, t),
                this.vertexArrayObject.bind(() => {
                  for (const e in t) {
                    const n = t[e];
                    this._setAttribute(e, n);
                  }
                  this.gl.bindBuffer(34962, null);
                }),
                this
              );
            }
            setElementBuffer(t = null, e = {}) {
              return (
                (this.elements = t),
                (this.elementsAccessor = e),
                this.clearDrawParams(),
                this.vertexArrayObject.setElementBuffer(t, e),
                this
              );
            }
            setBuffer(t, e, n = {}) {
              if (34963 === e.target) return this.setElementBuffer(e, n);
              const { location: i, accessor: r } =
                this._resolveLocationAndAccessor(t, e, e.accessor, n);
              return (
                i >= 0 &&
                  ((this.values[i] = e),
                  (this.accessors[i] = r),
                  this.clearDrawParams(),
                  this.vertexArrayObject.setBuffer(i, e, r)),
                this
              );
            }
            setConstant(t, e, n = {}) {
              const { location: i, accessor: r } =
                this._resolveLocationAndAccessor(
                  t,
                  e,
                  Object.assign({ size: e.length }, n)
                );
              return (
                i >= 0 &&
                  ((e = this.vertexArrayObject._normalizeConstantArrayValue(e)),
                  (this.values[i] = e),
                  (this.accessors[i] = r),
                  this.clearDrawParams(),
                  this.vertexArrayObject.enable(i, !1)),
                this
              );
            }
            unbindBuffers() {
              return (
                this.vertexArrayObject.bind(() => {
                  this.elements &&
                    this.vertexArrayObject.setElementBuffer(null),
                    (this.buffer =
                      this.buffer ||
                      new qt(this.gl, { accessor: { size: 4 } }));
                  for (
                    let t = 0;
                    t < this.vertexArrayObject.MAX_ATTRIBUTES;
                    t++
                  )
                    this.values[t] instanceof qt &&
                      (this.gl.disableVertexAttribArray(t),
                      this.gl.bindBuffer(34962, this.buffer.handle),
                      this.gl.vertexAttribPointer(t, 1, 5126, !1, 0, 0));
                }),
                this
              );
            }
            bindBuffers() {
              return (
                this.vertexArrayObject.bind(() => {
                  this.elements && this.setElementBuffer(this.elements);
                  for (
                    let t = 0;
                    t < this.vertexArrayObject.MAX_ATTRIBUTES;
                    t++
                  ) {
                    const e = this.values[t];
                    e instanceof qt && this.setBuffer(t, e);
                  }
                }),
                this
              );
            }
            bindForDraw(t, e, n) {
              let i;
              return (
                this.vertexArrayObject.bind(() => {
                  this._setConstantAttributes(t, e), (i = n());
                }),
                i
              );
            }
            _resolveLocationAndAccessor(t, e, n, i) {
              const r = { location: -1, accessor: null },
                { location: s, name: o } = this._getAttributeIndex(t);
              if (!Number.isFinite(s) || s < 0)
                return (
                  (this.unused[t] = e),
                  C.once(3, () => `unused value ${t} in ${this.id}`)(),
                  r
                );
              const a = this._getAttributeInfo(o || s);
              if (!a) return r;
              const c = this.accessors[s] || {},
                l = Ht.resolve(a.accessor, c, n, i),
                { size: h, type: u } = l;
              return (
                Ct(Number.isFinite(h) && Number.isFinite(u)),
                { location: s, accessor: l }
              );
            }
            _getAttributeInfo(t) {
              return (
                this.configuration && this.configuration.getAttributeInfo(t)
              );
            }
            _getAttributeIndex(t) {
              const e = Number(t);
              if (Number.isFinite(e)) return { location: e };
              const n = Yi.exec(t),
                i = n ? n[1] : t,
                r = n ? Number(n[2]) : 0;
              return this.configuration
                ? {
                    location: this.configuration.getAttributeLocation(i) + r,
                    name: i,
                  }
                : { location: -1 };
            }
            _setAttribute(t, e) {
              if (e instanceof qt) this.setBuffer(t, e);
              else if (Array.isArray(e) && e.length && e[0] instanceof qt) {
                const n = e[0],
                  i = e[1];
                this.setBuffer(t, n, i);
              } else if (ArrayBuffer.isView(e) || Array.isArray(e)) {
                const n = e;
                this.setConstant(t, n);
              } else {
                if (!(e.buffer instanceof qt))
                  throw new Error(
                    "VertexArray: attributes must be Buffers or constants (i.e. typed array)"
                  );
                {
                  const n = e;
                  this.setBuffer(t, n.buffer, n);
                }
              }
            }
            _setConstantAttributes(t, e) {
              const n = Math.max(0 | t, 0 | e);
              let i = this.values[0];
              ArrayBuffer.isView(i) && this._setConstantAttributeZero(i, n);
              for (let t = 1; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++)
                (i = this.values[t]),
                  ArrayBuffer.isView(i) && this._setConstantAttribute(t, i);
            }
            _setConstantAttributeZero(t, e) {
              if (Xi.isSupported(this.gl, { constantAttributeZero: !0 }))
                return void this._setConstantAttribute(0, t);
              const n = this.vertexArrayObject.getConstantBuffer(e, t);
              this.vertexArrayObject.setBuffer(0, n, this.accessors[0]);
            }
            _setConstantAttribute(t, e) {
              Xi.setConstant(this.gl, t, e);
            }
            _updateDrawParams() {
              const t = {
                isIndexed: !1,
                isInstanced: !1,
                indexCount: 1 / 0,
                vertexCount: 1 / 0,
                instanceCount: 1 / 0,
              };
              for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++)
                this._updateDrawParamsForLocation(t, e);
              return (
                this.elements &&
                  ((t.elementCount = this.elements.getElementCount(
                    this.elements.accessor
                  )),
                  (t.isIndexed = !0),
                  (t.indexType =
                    this.elementsAccessor.type || this.elements.accessor.type),
                  (t.indexOffset = this.elementsAccessor.offset || 0)),
                t.indexCount === 1 / 0 && (t.indexCount = 0),
                t.vertexCount === 1 / 0 && (t.vertexCount = 0),
                t.instanceCount === 1 / 0 && (t.instanceCount = 0),
                t
              );
            }
            _updateDrawParamsForLocation(t, e) {
              const n = this.values[e],
                i = this.accessors[e];
              if (!n) return;
              const { divisor: r } = i,
                s = r > 0;
              if (((t.isInstanced = t.isInstanced || s), n instanceof qt)) {
                const e = n;
                if (s) {
                  const n = e.getVertexCount(i);
                  t.instanceCount = Math.min(t.instanceCount, n);
                } else {
                  const n = e.getVertexCount(i);
                  t.vertexCount = Math.min(t.vertexCount, n);
                }
              }
            }
            setElements(t = null, e = {}) {
              return (
                C.deprecated("setElements", "setElementBuffer")(),
                this.setElementBuffer(t, e)
              );
            }
          }
          function Ki(t, e = {}) {
            const { isInteger: n = !1 } = e;
            if (Array.isArray(t) || ArrayBuffer.isView(t))
              return (function (t, e) {
                const { maxElts: n = 16, size: i = 1 } = e;
                let r = "[";
                for (let s = 0; s < t.length && s < n; ++s)
                  s > 0 && (r += "," + (s % i == 0 ? " " : "")),
                    (r += Ki(t[s], e));
                return `${r}${t.length > n ? "..." : "]"}`;
              })(t, e);
            if (!Number.isFinite(t)) return String(t);
            if (Math.abs(t) < 1e-16) return n ? "0" : "0.";
            if (n) return t.toFixed(0);
            if (Math.abs(t) > 100 && Math.abs(t) < 1e4) return t.toFixed(0);
            const i = t.toPrecision(2);
            return i.indexOf(".0") === i.length - 2 ? i.slice(0, -1) : i;
          }
          function Ji(t, e, n, i) {
            const { gl: r } = t;
            if (!e) return { [i]: "null", "Format ": "N/A" };
            let s,
              o,
              a,
              c = "NOT PROVIDED",
              l = 1,
              h = 0,
              u = 0;
            if (
              (n &&
                ((c = n.type),
                (l = n.size),
                (c = String(c).replace("Array", "")),
                (s = -1 !== c.indexOf("nt"))),
              e instanceof qt)
            ) {
              const t = e,
                { data: d, changed: f } = t.getDebugData();
              let p;
              return (
                (o = f ? "*" : ""),
                (a = d),
                (u = t.byteLength),
                (h = u / d.BYTES_PER_ELEMENT / l),
                n
                  ? (p = `${
                      n.divisor > 0 ? "I " : "P "
                    } ${h} (x${l}=${u} bytes ${Ot(r, c)})`)
                  : ((s = !0), (p = `${u} bytes`)),
                { [i]: `${o}${Ki(a, { size: l, isInteger: s })}`, "Format ": p }
              );
            }
            return (
              (a = e),
              (l = e.length),
              (c = String(e.constructor.name).replace("Array", "")),
              (s = -1 !== c.indexOf("nt")),
              {
                [i]: `${Ki(a, { size: l, isInteger: s })} (constant)`,
                "Format ": `${l}x${c} (constant)`,
              }
            );
          }
          function Qi(t, e) {
            const { type: n, size: i } = e,
              r = Ni(n, i);
            return r ? `${t} (${r.name})` : t;
          }
          function tr({
            header: t = "Uniforms",
            program: e,
            uniforms: n,
            undefinedOnly: i = !1,
          }) {
            Ct(e);
            const r = ".*Matrix",
              s = e._uniformSetters,
              o = {},
              a = Object.keys(s).sort();
            let c = 0;
            for (const e of a)
              e.match(".*_.*") ||
                e.match(r) ||
                (er({
                  table: o,
                  header: t,
                  uniforms: n,
                  uniformName: e,
                  undefinedOnly: i,
                }) &&
                  c++);
            for (const e of a)
              e.match(r) &&
                er({
                  table: o,
                  header: t,
                  uniforms: n,
                  uniformName: e,
                  undefinedOnly: i,
                }) &&
                c++;
            for (const e of a)
              o[e] ||
                (er({
                  table: o,
                  header: t,
                  uniforms: n,
                  uniformName: e,
                  undefinedOnly: i,
                }) &&
                  c++);
            let l = 0;
            const h = {};
            if (!i)
              for (const e in n) {
                const i = n[e];
                o[e] || (l++, (h[e] = { Type: `NOT USED: ${i}`, [t]: Ki(i) }));
              }
            return { table: o, count: c, unusedTable: h, unusedCount: l };
          }
          function er({
            table: t,
            header: e,
            uniforms: n,
            uniformName: i,
            undefinedOnly: r,
          }) {
            const s = n[i],
              o = (function (t) {
                return null != t;
              })(s);
            return !(
              (r && o) ||
              ((t[i] = {
                [e]: o ? Ki(s) : "N/A",
                "Uniform Type": o ? s : "NOT PROVIDED",
              }),
              0)
            );
          }
          function nr(t) {
            const { type: e, size: n } = t.accessor,
              i = Ni(e, n);
            return i ? `${i.name} ${t.name}` : t.name;
          }
          const ir = {
            POSITION: "positions",
            NORMAL: "normals",
            COLOR_0: "colors",
            TEXCOORD_0: "texCoords",
            TEXCOORD_1: "texCoords1",
            TEXCOORD_2: "texCoords2",
          };
          function rr(t, e) {
            const { attributeMap: n = ir } = e || {};
            return (n && n[t]) || t;
          }
          function sr(t, e) {
            let n;
            switch (t) {
              case "texCoords":
              case "texCoord1":
              case "texCoord2":
              case "texCoord3":
                n = "uvs";
                break;
              case "vertices":
              case "positions":
              case "normals":
              case "pickingColors":
                n = "vectors";
            }
            switch (n) {
              case "vectors":
                e.size = e.size || 3;
                break;
              case "uvs":
                e.size = e.size || 2;
            }
            Ct(Number.isFinite(e.size), `attribute ${t} needs size`);
          }
          const or = () => {},
            ar = {};
          class cr {
            constructor(t, e = {}) {
              const { id: n = Rt("model") } = e;
              Ct(O(t)),
                (this.id = n),
                (this.gl = t),
                (this.id = e.id || Rt("Model")),
                (this.lastLogTime = 0),
                (this.animated = !1),
                this.initialize(e);
            }
            initialize(t) {
              (this.props = {}),
                (this.programManager =
                  t.programManager || Hi.getDefaultProgramManager(this.gl)),
                (this._programManagerState = -1),
                (this._managedProgram = !1);
              const {
                program: e = null,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: l,
              } = t;
              (this.programProps = {
                program: e,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: l,
              }),
                (this.program = null),
                (this.vertexArray = null),
                (this._programDirty = !0),
                (this.userData = {}),
                (this.needsRedraw = !0),
                (this._attributes = {}),
                (this.attributes = {}),
                (this.uniforms = {}),
                (this.pickable = !0),
                this._checkProgram(),
                this.setUniforms(
                  Object.assign({}, this.getModuleUniforms(t.moduleSettings))
                ),
                (this.drawMode = void 0 !== t.drawMode ? t.drawMode : 4),
                (this.vertexCount = t.vertexCount || 0),
                (this.geometryBuffers = {}),
                (this.isInstanced =
                  t.isInstanced || t.instanced || t.instanceCount > 0),
                this._setModelProps(t),
                (this.geometry = {}),
                Ct(
                  void 0 !== this.drawMode && Number.isFinite(this.vertexCount),
                  "Model needs drawMode and vertexCount"
                );
            }
            setProps(t) {
              this._setModelProps(t);
            }
            delete() {
              for (const t in this._attributes)
                this._attributes[t] !== this.attributes[t] &&
                  this._attributes[t].delete();
              this._managedProgram &&
                (this.programManager.release(this.program),
                (this._managedProgram = !1)),
                this.vertexArray.delete(),
                this._deleteGeometryBuffers();
            }
            getDrawMode() {
              return this.drawMode;
            }
            getVertexCount() {
              return this.vertexCount;
            }
            getInstanceCount() {
              return this.instanceCount;
            }
            getAttributes() {
              return this.attributes;
            }
            getProgram() {
              return this.program;
            }
            setProgram(t) {
              const {
                program: e,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: l,
              } = t;
              (this.programProps = {
                program: e,
                vs: n,
                fs: i,
                modules: r,
                defines: s,
                inject: o,
                varyings: a,
                bufferMode: c,
                transpileToGLSL100: l,
              }),
                (this._programDirty = !0);
            }
            getUniforms() {
              return this.uniforms;
            }
            setDrawMode(t) {
              return (this.drawMode = t), this;
            }
            setVertexCount(t) {
              return Ct(Number.isFinite(t)), (this.vertexCount = t), this;
            }
            setInstanceCount(t) {
              return Ct(Number.isFinite(t)), (this.instanceCount = t), this;
            }
            setGeometry(t) {
              return (
                (this.drawMode = t.drawMode),
                (this.vertexCount = t.getVertexCount()),
                this._deleteGeometryBuffers(),
                (this.geometryBuffers = (function (t, e, n) {
                  const i = {};
                  let r = e.indices;
                  for (const n in e.attributes) {
                    const s = e.attributes[n],
                      o = rr(n, undefined);
                    if ("indices" === n) r = s;
                    else if (s.constant) i[o] = s.value;
                    else {
                      const e = s.value,
                        r = { ...s };
                      delete r.value, (i[o] = [new qt(t, e), r]), sr(n, r);
                    }
                  }
                  if (r) {
                    const e = r.value || r;
                    Ct(
                      e instanceof Uint16Array || e instanceof Uint32Array,
                      'attribute array for "indices" must be of integer type'
                    );
                    const n = {
                      size: 1,
                      isIndexed: void 0 === r.isIndexed || r.isIndexed,
                    };
                    i.indices = [new qt(t, { data: e, target: 34963 }), n];
                  }
                  return i;
                })(this.gl, t)),
                this.vertexArray.setAttributes(this.geometryBuffers),
                this
              );
            }
            setAttributes(t = {}) {
              if (Ft(t)) return this;
              const e = {};
              for (const n in t) {
                const i = t[n];
                e[n] = i.getValue ? i.getValue() : i;
              }
              return this.vertexArray.setAttributes(e), this;
            }
            setUniforms(t = {}) {
              return Object.assign(this.uniforms, t), this;
            }
            getModuleUniforms(t) {
              this._checkProgram();
              const e = this.programManager.getUniforms(this.program);
              return e ? e(t) : {};
            }
            updateModuleSettings(t) {
              const e = this.getModuleUniforms(t || {});
              return this.setUniforms(e);
            }
            clear(t) {
              return ae(this.program.gl, t), this;
            }
            draw(t = {}) {
              this._checkProgram();
              const {
                moduleSettings: e = null,
                framebuffer: n,
                uniforms: i = {},
                attributes: r = {},
                transformFeedback: s = this.transformFeedback,
                parameters: o = {},
                vertexArray: a = this.vertexArray,
              } = t;
              let c;
              this.setAttributes(r),
                this.updateModuleSettings(e),
                this.setUniforms(i),
                C.priority >= 2 && (c = this._logDrawCallStart(2));
              const l = this.vertexArray.getDrawParams(),
                {
                  isIndexed: h = l.isIndexed,
                  indexType: u = l.indexType,
                  indexOffset: d = l.indexOffset,
                  vertexArrayInstanced: f = l.isInstanced,
                } = this.props;
              f &&
                !this.isInstanced &&
                C.warn(
                  "Found instanced attributes on non-instanced model",
                  this.id
                )();
              const { isInstanced: p, instanceCount: g } = this,
                { onBeforeRender: m = or, onAfterRender: y = or } = this.props;
              m(), this.program.setUniforms(this.uniforms);
              const _ = this.program.draw(
                Object.assign(ar, t, {
                  logPriority: c,
                  uniforms: null,
                  framebuffer: n,
                  parameters: o,
                  drawMode: this.getDrawMode(),
                  vertexCount: this.getVertexCount(),
                  vertexArray: a,
                  transformFeedback: s,
                  isIndexed: h,
                  indexType: u,
                  isInstanced: p,
                  instanceCount: g,
                  offset: h ? d : 0,
                })
              );
              return y(), C.priority >= 2 && this._logDrawCallEnd(c, a, n), _;
            }
            transform(t = {}) {
              const {
                discard: e = !0,
                feedbackBuffers: n,
                unbindModels: i = [],
              } = t;
              let { parameters: r } = t;
              n && this._setFeedbackBuffers(n),
                e && (r = Object.assign({}, r, { 35977: e })),
                i.forEach((t) => t.vertexArray.unbindBuffers());
              try {
                this.draw(Object.assign({}, t, { parameters: r }));
              } finally {
                i.forEach((t) => t.vertexArray.bindBuffers());
              }
              return this;
            }
            render(t = {}) {
              return (
                C.warn(
                  "Model.render() is deprecated. Use Model.setUniforms() and Model.draw()"
                )(),
                this.setUniforms(t).draw()
              );
            }
            _setModelProps(t) {
              Object.assign(this.props, t),
                "uniforms" in t && this.setUniforms(t.uniforms),
                "pickable" in t && (this.pickable = t.pickable),
                "instanceCount" in t && (this.instanceCount = t.instanceCount),
                "geometry" in t && this.setGeometry(t.geometry),
                "attributes" in t && this.setAttributes(t.attributes),
                "_feedbackBuffers" in t &&
                  this._setFeedbackBuffers(t._feedbackBuffers);
            }
            _checkProgram() {
              if (
                !this._programDirty &&
                this.programManager.stateHash === this._programManagerState
              )
                return;
              let { program: t } = this.programProps;
              if (t) this._managedProgram = !1;
              else {
                const {
                  vs: e,
                  fs: n,
                  modules: i,
                  inject: r,
                  defines: s,
                  varyings: o,
                  bufferMode: a,
                  transpileToGLSL100: c,
                } = this.programProps;
                (t = this.programManager.get({
                  vs: e,
                  fs: n,
                  modules: i,
                  inject: r,
                  defines: s,
                  varyings: o,
                  bufferMode: a,
                  transpileToGLSL100: c,
                })),
                  this.program &&
                    this._managedProgram &&
                    this.programManager.release(this.program),
                  (this._programManagerState = this.programManager.stateHash),
                  (this._managedProgram = !0);
              }
              Ct(t instanceof Wi, "Model needs a program"),
                (this._programDirty = !1),
                t !== this.program &&
                  ((this.program = t),
                  this.vertexArray
                    ? this.vertexArray.setProps({
                        program: this.program,
                        attributes: this.vertexArray.attributes,
                      })
                    : (this.vertexArray = new Zi(this.gl, {
                        program: this.program,
                      })),
                  this.setUniforms(
                    Object.assign({}, this.getModuleUniforms())
                  ));
            }
            _deleteGeometryBuffers() {
              for (const t in this.geometryBuffers) {
                const e = this.geometryBuffers[t][0] || this.geometryBuffers[t];
                e instanceof qt && e.delete();
              }
            }
            _setAnimationProps(t) {
              this.animated &&
                Ct(t, "Model.draw(): animated uniforms but no animationProps");
            }
            _setFeedbackBuffers(t = {}) {
              if (Ft(t)) return this;
              const { gl: e } = this.program;
              return (
                (this.transformFeedback =
                  this.transformFeedback ||
                  new Tn(e, { program: this.program })),
                this.transformFeedback.setBuffers(t),
                this
              );
            }
            _logDrawCallStart(t) {
              const e = t > 3 ? 0 : 1e4;
              if (!(Date.now() - this.lastLogTime < e))
                return (
                  (this.lastLogTime = Date.now()),
                  C.group(2, `>>> DRAWING MODEL ${this.id}`, {
                    collapsed: C.level <= 2,
                  })(),
                  t
                );
            }
            _logDrawCallEnd(t, e, n, i) {
              if (void 0 === t) return;
              const r = (function ({
                  vertexArray: t,
                  header: e = "Attributes",
                }) {
                  if (!t.configuration) return {};
                  const n = {};
                  t.elements &&
                    (n.ELEMENT_ARRAY_BUFFER = Ji(t, t.elements, null, e));
                  const i = t.values;
                  for (const r in i) {
                    const s = t._getAttributeInfo(r);
                    if (s) {
                      let o = `${r}: ${s.name}`;
                      const a = t.accessors[s.location];
                      a && (o = `${r}: ${Qi(s.name, a)}`),
                        (n[o] = Ji(t, i[r], a, e));
                    }
                  }
                  return n;
                })({
                  vertexArray: e,
                  header: `${this.id} attributes`,
                  attributes: this._attributes,
                }),
                {
                  table: s,
                  unusedTable: o,
                  unusedCount: a,
                } = tr({
                  header: `${this.id} uniforms`,
                  program: this.program,
                  uniforms: Object.assign({}, this.program.uniforms, n),
                }),
                { table: c, count: l } = tr({
                  header: `${this.id} uniforms`,
                  program: this.program,
                  uniforms: Object.assign({}, this.program.uniforms, n),
                  undefinedOnly: !0,
                });
              l > 0 && C.log("MISSING UNIFORMS", Object.keys(c))(),
                a > 0 && C.log("UNUSED UNIFORMS", Object.keys(o))();
              const h = (function (t) {
                const e = {},
                  n = `Accessors for ${t.id}`;
                for (const i of t.attributeInfos)
                  i && (e[`in ${nr(i)}`] = { [n]: JSON.stringify(i.accessor) });
                for (const i of t.varyingInfos)
                  i &&
                    (e[`out ${nr(i)}`] = { [n]: JSON.stringify(i.accessor) });
                return e;
              })(this.vertexArray.configuration);
              C.table(t, r)(),
                C.table(t, s)(),
                C.table(t + 1, h)(),
                i && i.log({ logLevel: 2, message: `Rendered to ${i.id}` }),
                C.groupEnd(2, `>>> DRAWING MODEL ${this.id}`)();
            }
          }
          class lr {
            static isSupported(t) {
              return I(t);
            }
            constructor(t, e = {}) {
              (this.gl = t),
                (this.model = null),
                (this.elementCount = 0),
                (this.bufferTransform = null),
                (this.textureTransform = null),
                (this.elementIDBuffer = null),
                this._initialize(e),
                Object.seal(this);
            }
            delete() {
              const {
                model: t,
                bufferTransform: e,
                textureTransform: n,
              } = this;
              t && t.delete(), e && e.delete(), n && n.delete();
            }
            run(t = {}) {
              const { clearRenderTarget: e = !0 } = t,
                n = this._updateDrawOptions(t);
              e && n.framebuffer && n.framebuffer.clear({ color: !0 }),
                this.model.transform(n);
            }
            swap() {
              let t = !1;
              const e = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const n of e) t = t || n.swap();
              Ct(t, "Nothing to swap");
            }
            getBuffer(t = null) {
              return this.bufferTransform && this.bufferTransform.getBuffer(t);
            }
            getData(t = {}) {
              const e = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const n of e) {
                const e = n.getData(t);
                if (e) return e;
              }
              return null;
            }
            getFramebuffer() {
              return (
                this.textureTransform && this.textureTransform.getFramebuffer()
              );
            }
            update(t = {}) {
              "elementCount" in t && this.model.setVertexCount(t.elementCount);
              const e = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const n of e) n.update(t);
            }
            _initialize(t = {}) {
              const { gl: e } = this;
              this._buildResourceTransforms(e, t),
                (t = this._updateModelProps(t)),
                (this.model = new cr(
                  e,
                  Object.assign({}, t, {
                    fs: t.fs || An({ version: Mn(t.vs) }),
                    id: t.id || "transform-model",
                    drawMode: t.drawMode || 0,
                    vertexCount: t.elementCount,
                  })
                )),
                this.bufferTransform &&
                  this.bufferTransform.setupResources({ model: this.model });
            }
            _updateModelProps(t) {
              let e = Object.assign({}, t);
              const n = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const t of n) e = t.updateModelProps(e);
              return e;
            }
            _buildResourceTransforms(t, e) {
              (function (t) {
                return !(
                  Ft(t.feedbackBuffers) &&
                  Ft(t.feedbackMap) &&
                  !(t.varyings && t.varyings.length > 0)
                );
              })(e) && (this.bufferTransform = new Sn(t, e)),
                (function (t) {
                  return !(
                    Ft(t._sourceTextures) &&
                    !t._targetTexture &&
                    !t._targetTextureVarying
                  );
                })(e) && (this.textureTransform = new Nn(t, e)),
                Ct(
                  this.bufferTransform || this.textureTransform,
                  "must provide source/feedback buffers or source/target textures"
                );
            }
            _updateDrawOptions(t) {
              let e = Object.assign({}, t);
              const n = [this.bufferTransform, this.textureTransform].filter(
                Boolean
              );
              for (const t of n) e = Object.assign(e, t.getDrawOptions(e));
              return e;
            }
          }
          function hr() {}
          const ur = { onStart: hr, onUpdate: hr, onInterrupt: hr, onEnd: hr };
          class dr {
            constructor(t) {
              (this._inProgress = !1),
                (this._handle = null),
                (this.timeline = t),
                (this.settings = {});
            }
            get inProgress() {
              return this._inProgress;
            }
            start(t) {
              this.cancel(),
                (this.settings = { ...ur, ...t }),
                (this._inProgress = !0),
                this.settings.onStart(this);
            }
            end() {
              this._inProgress &&
                (this.timeline.removeChannel(this._handle),
                (this._handle = null),
                (this._inProgress = !1),
                this.settings.onEnd(this));
            }
            cancel() {
              this._inProgress &&
                (this.settings.onInterrupt(this),
                this.timeline.removeChannel(this._handle),
                (this._handle = null),
                (this._inProgress = !1));
            }
            update() {
              if (!this._inProgress) return !1;
              if (null === this._handle) {
                const { timeline: t, settings: e } = this;
                this._handle = t.addChannel({
                  delay: t.getTime(),
                  duration: e.duration,
                });
              }
              return (
                (this.time = this.timeline.getTime(this._handle)),
                this._onUpdate(),
                this.settings.onUpdate(this),
                this.timeline.isFinished(this._handle) && this.end(),
                !0
              );
            }
            _onUpdate() {}
          }
          const fr = {
            interpolation: class {
              constructor({ gl: t, attribute: e, timeline: n }) {
                (this.gl = t),
                  (this.type = "interpolation"),
                  (this.transition = new dr(n)),
                  (this.attribute = e),
                  (this.attributeInTransition = new _n(t, e.settings)),
                  (this.currentStartIndices = e.startIndices),
                  (this.currentLength = 0),
                  (this.transform = (function (t, e) {
                    const n = pn(e.size);
                    return new lr(t, {
                      vs: "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n",
                      defines: { ATTRIBUTE_TYPE: n },
                      varyings: ["vCurrent"],
                    });
                  })(t, e));
                const i = { byteLength: 0, usage: 35050 };
                this.buffers = [new qt(t, i), new qt(t, i)];
              }
              get inProgress() {
                return this.transition.inProgress;
              }
              start(t, e) {
                if (t.duration <= 0) return void this.transition.cancel();
                const { gl: n, buffers: i, attribute: r } = this;
                gn(i);
                const s = {
                  numInstances: e,
                  attribute: r,
                  fromLength: this.currentLength,
                  fromStartIndices: this.currentStartIndices,
                  getData: t.enter,
                };
                for (const t of i) yn({ buffer: t, ...s });
                (this.currentStartIndices = r.startIndices),
                  (this.currentLength = mn(r, e)),
                  this.attributeInTransition.update({
                    buffer: i[1],
                    value: r.value,
                  }),
                  this.transition.start(t),
                  this.transform.update({
                    elementCount: Math.floor(this.currentLength / r.size),
                    sourceBuffers: { aFrom: i[0], aTo: fn(0, r) },
                    feedbackBuffers: { vCurrent: i[1] },
                  });
              }
              update() {
                const t = this.transition.update();
                if (t) {
                  const {
                      time: t,
                      settings: { duration: e, easing: n },
                    } = this.transition,
                    i = n(t / e);
                  this.transform.run({ uniforms: { time: i } });
                }
                return t;
              }
              cancel() {
                for (
                  this.transition.cancel(), this.transform.delete();
                  this.buffers.length;

                )
                  this.buffers.pop().delete();
              }
            },
            spring: class {
              constructor({ gl: t, attribute: e, timeline: n }) {
                (this.gl = t),
                  (this.type = "spring"),
                  (this.transition = new dr(n)),
                  (this.attribute = e),
                  (this.attributeInTransition = new _n(t, {
                    ...e.settings,
                    normalized: !1,
                  })),
                  (this.currentStartIndices = e.startIndices),
                  (this.currentLength = 0),
                  (this.texture = (function (t) {
                    return new ne(t, {
                      data: new Uint8Array(4),
                      format: 6408,
                      type: 5121,
                      border: 0,
                      mipmaps: !1,
                      dataFormat: 6408,
                      width: 1,
                      height: 1,
                    });
                  })(t)),
                  (this.framebuffer = (function (t, e) {
                    return new ye(t, {
                      id: "spring-transition-is-transitioning-framebuffer",
                      width: 1,
                      height: 1,
                      attachments: { 36064: e },
                    });
                  })(t, this.texture)),
                  (this.transform = (function (t, e, n) {
                    const i = pn(e.size);
                    return new lr(t, {
                      framebuffer: n,
                      vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
                      fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
                      defines: { ATTRIBUTE_TYPE: i },
                      varyings: ["vNext"],
                    });
                  })(t, e, this.framebuffer));
                const i = { byteLength: 0, usage: 35050 };
                this.buffers = [new qt(t, i), new qt(t, i), new qt(t, i)];
              }
              get inProgress() {
                return this.transition.inProgress;
              }
              start(t, e) {
                const { gl: n, buffers: i, attribute: r } = this,
                  s = {
                    numInstances: e,
                    attribute: r,
                    fromLength: this.currentLength,
                    fromStartIndices: this.currentStartIndices,
                    getData: t.enter,
                  };
                for (const t of i) yn({ buffer: t, ...s });
                (this.currentStartIndices = r.startIndices),
                  (this.currentLength = mn(r, e)),
                  this.attributeInTransition.update({
                    buffer: i[1],
                    value: r.value,
                  }),
                  this.transition.start(t),
                  this.transform.update({
                    elementCount: Math.floor(this.currentLength / r.size),
                    sourceBuffers: { aTo: fn(0, r) },
                  });
              }
              update() {
                const {
                  buffers: t,
                  transform: e,
                  framebuffer: n,
                  transition: i,
                } = this;
                return (
                  !!i.update() &&
                  (e.update({
                    sourceBuffers: { aPrev: t[0], aCur: t[1] },
                    feedbackBuffers: { vNext: t[2] },
                  }),
                  e.run({
                    framebuffer: n,
                    discard: !1,
                    clearRenderTarget: !0,
                    uniforms: {
                      stiffness: i.settings.stiffness,
                      damping: i.settings.damping,
                    },
                    parameters: {
                      depthTest: !1,
                      blend: !0,
                      viewport: [0, 0, 1, 1],
                      blendFunc: [1, 1],
                      blendEquation: [32776, 32776],
                    },
                  }),
                  gn(t),
                  this.attributeInTransition.update({
                    buffer: t[1],
                    value: this.attribute.value,
                  }),
                  fe(n)[0] > 0 || i.end(),
                  !0)
                );
              }
              cancel() {
                for (
                  this.transition.cancel(), this.transform.delete();
                  this.buffers.length;

                )
                  this.buffers.pop().delete();
                this.texture.delete(),
                  (this.texture = null),
                  this.framebuffer.delete(),
                  (this.framebuffer = null);
              }
            },
          };
          class pr {
            constructor(t, { id: e, timeline: n }) {
              (this.id = e),
                (this.gl = t),
                (this.timeline = n),
                (this.transitions = {}),
                (this.needsRedraw = !1),
                (this.numInstances = 1),
                (this.isSupported = lr.isSupported(t));
            }
            finalize() {
              for (const t in this.transitions) this._removeTransition(t);
            }
            update({ attributes: t, transitions: e, numInstances: n }) {
              this.numInstances = n || 1;
              for (const n in t) {
                const i = t[n],
                  r = i.getTransitionSetting(e);
                r && this._updateAttribute(n, i, r);
              }
              for (const n in this.transitions) {
                const i = t[n];
                (i && i.getTransitionSetting(e)) || this._removeTransition(n);
              }
            }
            hasAttribute(t) {
              const e = this.transitions[t];
              return e && e.inProgress;
            }
            getAttributes() {
              const t = {};
              for (const e in this.transitions) {
                const n = this.transitions[e];
                n.inProgress && (t[e] = n.attributeInTransition);
              }
              return t;
            }
            run() {
              if (!this.isSupported || 0 === this.numInstances) return !1;
              for (const t in this.transitions)
                this.transitions[t].update() && (this.needsRedraw = !0);
              const t = this.needsRedraw;
              return (this.needsRedraw = !1), t;
            }
            _removeTransition(t) {
              this.transitions[t].cancel(), delete this.transitions[t];
            }
            _updateAttribute(t, e, n) {
              const i = this.transitions[t];
              let r = !i || i.type !== n.type;
              if (r) {
                if (!this.isSupported)
                  return void E.warn(
                    "WebGL2 not supported by this browser. Transition for ".concat(
                      t,
                      " is disabled."
                    )
                  )();
                i && this._removeTransition(t);
                const s = fr[n.type];
                s
                  ? (this.transitions[t] = new s({
                      attribute: e,
                      timeline: this.timeline,
                      gl: this.gl,
                    }))
                  : (E.error(
                      "unsupported transition type '".concat(n.type, "'")
                    )(),
                    (r = !1));
              }
              (r || e.needsRedraw()) &&
                ((this.needsRedraw = !0),
                this.transitions[t].start(n, this.numInstances));
            }
          }
          const gr = "attributeManager.invalidate";
          class mr {
            constructor(
              t,
              { id: e = "attribute-manager", stats: n, timeline: i } = {}
            ) {
              (this.id = e),
                (this.gl = t),
                (this.attributes = {}),
                (this.updateTriggers = {}),
                (this.accessors = {}),
                (this.needsRedraw = !0),
                (this.userData = {}),
                (this.stats = n),
                (this.attributeTransitionManager = new pr(t, {
                  id: "".concat(e, "-transitions"),
                  timeline: i,
                })),
                Object.seal(this);
            }
            finalize() {
              for (const t in this.attributes) this.attributes[t].delete();
              this.attributeTransitionManager.finalize();
            }
            getNeedsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this.needsRedraw;
              return (
                (this.needsRedraw = this.needsRedraw && !t.clearRedrawFlags),
                e && this.id
              );
            }
            setNeedsRedraw(t = !0) {
              return (this.needsRedraw = !0), this;
            }
            add(t, e) {
              this._add(t, e);
            }
            addInstanced(t, e) {
              this._add(t, e, { instanced: 1 });
            }
            remove(t) {
              for (let e = 0; e < t.length; e++) {
                const n = t[e];
                void 0 !== this.attributes[n] &&
                  (this.attributes[n].delete(), delete this.attributes[n]);
              }
            }
            invalidate(t, e) {
              const n = this._invalidateTrigger(t, e);
              bn(gr, this, t, n);
            }
            invalidateAll(t) {
              for (const e in this.attributes)
                this.attributes[e].setNeedsUpdate(e, t);
              bn(gr, this, "all");
            }
            update({
              data: t,
              numInstances: e,
              startIndices: n = null,
              transitions: i,
              props: r = {},
              buffers: s = {},
              context: o = {},
            } = {}) {
              let a = !1;
              bn("attributeManager.updateStart", this),
                this.stats && this.stats.get("Update Attributes").timeStart();
              for (const i in this.attributes) {
                const c = this.attributes[i],
                  l = c.settings.accessor;
                (c.startIndices = n),
                  r[i] &&
                    E.removed(
                      "props.".concat(i),
                      "data.attributes.".concat(i)
                    )(),
                  c.setExternalBuffer(s[i]) ||
                    c.setBinaryValue(s[l], t.startIndices) ||
                    (!s[l] && c.setConstantValue(r[l])) ||
                    (c.needsUpdate() &&
                      ((a = !0),
                      this._updateAttribute({
                        attribute: c,
                        numInstances: e,
                        data: t,
                        props: r,
                        context: o,
                      }))),
                  (this.needsRedraw |= c.needsRedraw());
              }
              a && bn("attributeManager.updateEnd", this, e),
                this.stats && this.stats.get("Update Attributes").timeEnd(),
                this.attributeTransitionManager.update({
                  attributes: this.attributes,
                  numInstances: e,
                  transitions: i,
                });
            }
            updateTransition() {
              const { attributeTransitionManager: t } = this,
                e = t.run();
              return (this.needsRedraw = this.needsRedraw || e), e;
            }
            getAttributes() {
              return this.attributes;
            }
            getChangedAttributes(t = { clearChangedFlags: !1 }) {
              const { attributes: e, attributeTransitionManager: n } = this,
                i = { ...n.getAttributes() };
              for (const r in e) {
                const s = e[r];
                s.needsRedraw(t) && !n.hasAttribute(r) && (i[r] = s);
              }
              return i;
            }
            getShaderAttributes(t, e = {}) {
              t || (t = this.getAttributes());
              const n = {};
              for (const i in t)
                e[i] || Object.assign(n, t[i].getShaderAttributes());
              return n;
            }
            getAccessors() {
              return this.updateTriggers;
            }
            _add(t, e, n = {}) {
              e &&
                E.warn(
                  "AttributeManager.add({updaters}) - updater map no longer supported"
                )();
              for (const e in t) {
                const i = t[e];
                this.attributes[e] = this._createAttribute(e, i, n);
              }
              this._mapUpdateTriggersToAttributes();
            }
            _createAttribute(t, e, n) {
              const i = {
                ...e,
                id: t,
                isIndexed: e.isIndexed || e.elements || !1,
                constant: e.constant || !1,
                size: (e.elements ? 1 : e.size) || 1,
                value: e.value || null,
                divisor: e.instanced || n.instanced ? 1 : e.divisor || 0,
              };
              return new _n(this.gl, i);
            }
            _mapUpdateTriggersToAttributes() {
              const t = {};
              for (const e in this.attributes)
                this.attributes[e].getUpdateTriggers().forEach((n) => {
                  t[n] || (t[n] = []), t[n].push(e);
                });
              this.updateTriggers = t;
            }
            _invalidateTrigger(t, e) {
              const { attributes: n, updateTriggers: i } = this,
                r = i[t];
              return (
                r &&
                  r.forEach((t) => {
                    const i = n[t];
                    i && i.setNeedsUpdate(i.id, e);
                  }),
                r
              );
            }
            _updateAttribute(t) {
              const { attribute: e, numInstances: n } = t;
              bn("attribute.updateStart", e),
                e.constant
                  ? e.setConstantValue(e.value)
                  : (e.allocate(n) && bn("attribute.allocate", e, n),
                    e.updateBuffer(t) &&
                      ((this.needsRedraw = !0),
                      bn("attribute.updateEnd", e, n)));
            }
          }
          const yr = 1e-5;
          function _r(t, e, n, i, r) {
            const s = e - t;
            return (n - e) * r + -s * i + s + e;
          }
          function vr(t, e) {
            if (Array.isArray(t)) {
              let n = 0;
              for (let i = 0; i < t.length; i++) {
                const r = t[i] - e[i];
                n += r * r;
              }
              return Math.sqrt(n);
            }
            return Math.abs(t - e);
          }
          const br = {
            interpolation: class extends dr {
              get value() {
                return this._value;
              }
              _onUpdate() {
                const {
                    time: t,
                    settings: {
                      fromValue: e,
                      toValue: n,
                      duration: i,
                      easing: r,
                    },
                  } = this,
                  s = r(t / i);
                this._value = Ce(e, n, s);
              }
            },
            spring: class extends dr {
              get value() {
                return this._currValue;
              }
              _onUpdate() {
                const {
                    fromValue: t,
                    toValue: e,
                    damping: n,
                    stiffness: i,
                  } = this.settings,
                  { _prevValue: r = t, _currValue: s = t } = this;
                let o = (function (t, e, n, i, r) {
                  if (Array.isArray(n)) {
                    const s = [];
                    for (let o = 0; o < n.length; o++)
                      s[o] = _r(t[o], e[o], n[o], i, r);
                    return s;
                  }
                  return _r(t, e, n, i, r);
                })(r, s, e, n, i);
                const a = vr(o, e),
                  c = vr(o, s);
                a < yr && c < yr && ((o = e), this.end()),
                  (this._prevValue = s),
                  (this._currValue = o);
              }
            },
          };
          class wr {
            constructor(t) {
              (this.transitions = new Map()), (this.timeline = t);
            }
            get active() {
              return this.transitions.size > 0;
            }
            add(t, e, n, i) {
              const { transitions: r } = this;
              if (r.has(t)) {
                const n = r.get(t),
                  { value: i = n.settings.fromValue } = n;
                (e = i), this.remove(t);
              }
              if (!(i = dn(i))) return;
              const s = br[i.type];
              if (!s)
                return void E.error(
                  "unsupported transition type '".concat(i.type, "'")
                )();
              const o = new s(this.timeline);
              o.start({ ...i, fromValue: e, toValue: n }), r.set(t, o);
            }
            remove(t) {
              const { transitions: e } = this;
              e.has(t) && (e.get(t).cancel(), e.delete(t));
            }
            update() {
              const t = {};
              for (const [e, n] of this.transitions)
                n.update(), (t[e] = n.value), n.inProgress || this.remove(e);
              return t;
            }
            clear() {
              for (const t of this.transitions.keys()) this.remove(t);
            }
          }
          const xr = {
              COMPONENT: Symbol.for("component"),
              ASYNC_DEFAULTS: Symbol.for("asyncPropDefaults"),
              ASYNC_ORIGINAL: Symbol.for("asyncPropOriginal"),
              ASYNC_RESOLVED: Symbol.for("asyncPropResolved"),
            },
            { COMPONENT: Pr } = xr;
          function Er(t, e) {
            if (!t.transitions) return null;
            const n = {},
              i = Cr(t);
            for (const r in t.transitions) {
              const s = i[r],
                o = s && s.type;
              ("number" === o || "color" === o || "array" === o) &&
                Tr(t[r], e[r], s) &&
                (n[r] = !0);
            }
            return n;
          }
          function Ar({
            newProps: t,
            oldProps: e,
            ignoreProps: n = {},
            propTypes: i = {},
            triggerName: r = "props",
          } = {}) {
            if (e === t) return null;
            if ("object" != typeof t || null === t)
              return "".concat(r, " changed shallowly");
            if ("object" != typeof e || null === e)
              return "".concat(r, " changed shallowly");
            for (const s of Object.keys(t))
              if (!(s in n)) {
                if (!(s in e)) return "".concat(r, ".").concat(s, " added");
                const n = Tr(t[s], e[s], i[s]);
                if (n) return "".concat(r, ".").concat(s, " ").concat(n);
              }
            for (const s of Object.keys(e))
              if (!(s in n)) {
                if (!(s in t)) return "".concat(r, ".").concat(s, " dropped");
                if (!Object.hasOwnProperty.call(t, s)) {
                  const n = Tr(t[s], e[s], i[s]);
                  if (n) return "".concat(r, ".").concat(s, " ").concat(n);
                }
              }
            return null;
          }
          function Tr(t, e, n) {
            let i = n && n.equal;
            return i && !i(t, e, n)
              ? "changed deeply"
              : i || ((i = t && e && t.equals), !i || i.call(t, e))
              ? i || e === t
                ? null
                : "changed shallowly"
              : "changed deeply";
          }
          function Sr(t, e) {
            if (null === e) return "oldProps is null, initial diff";
            const n = e.extensions,
              { extensions: i } = t;
            if (i === n) return !1;
            if (i.length !== n.length) return !0;
            for (let t = 0; t < i.length; t++)
              if (!i[t].equals(n[t])) return !0;
            return !1;
          }
          function Mr(t, e, n) {
            let i = t.updateTriggers[n];
            i = null == i ? {} : i;
            let r = e.updateTriggers[n];
            return (
              (r = null == r ? {} : r),
              Ar({ oldProps: r, newProps: i, triggerName: n })
            );
          }
          function Cr(t) {
            const e = t[Pr],
              n = e && e.constructor;
            return n ? n._propTypes : {};
          }
          function Lr(t, e) {
            if (t === e) return !0;
            if (Array.isArray(t)) {
              const n = t.length;
              if (!e || e.length !== n) return !1;
              for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1;
              return !0;
            }
            return !1;
          }
          function Or(t) {
            let e,
              n = {};
            return (i) => {
              for (const r in i)
                if (!Lr(i[r], n[r])) {
                  (e = t(i)), (n = i);
                  break;
                }
              return e;
            };
          }
          function Ir(t, e) {
            if (!e) return t;
            const n = { ...t, ...e };
            if (
              ("defines" in e && (n.defines = { ...t.defines, ...e.defines }),
              "modules" in e &&
                ((n.modules = (t.modules || []).concat(e.modules)),
                e.modules.some((t) => "project64" === t.name)))
            ) {
              const t = n.modules.findIndex((t) => "project32" === t.name);
              t >= 0 && n.modules.splice(t, 1);
            }
            if ("inject" in e)
              if (t.inject) {
                const i = { ...t.inject };
                for (const t in e.inject) i[t] = (i[t] || "") + e.inject[t];
                n.inject = i;
              } else n.inject = e.inject;
            return n;
          }
          function Rr(t, e) {
            var n = e[0],
              i = e[1],
              r = e[2],
              s = e[3],
              o = e[4],
              a = e[5],
              c = e[6],
              l = e[7],
              h = e[8],
              u = e[9],
              d = e[10],
              f = e[11],
              p = e[12],
              g = e[13],
              m = e[14],
              y = e[15],
              _ = n * a - i * o,
              v = n * c - r * o,
              b = n * l - s * o,
              w = i * c - r * a,
              x = i * l - s * a,
              P = r * l - s * c,
              E = h * g - u * p,
              A = h * m - d * p,
              T = h * y - f * p,
              S = u * m - d * g,
              M = u * y - f * g,
              C = d * y - f * m,
              L = _ * C - v * M + b * S + w * T - x * A + P * E;
            return L
              ? ((L = 1 / L),
                (t[0] = (a * C - c * M + l * S) * L),
                (t[1] = (r * M - i * C - s * S) * L),
                (t[2] = (g * P - m * x + y * w) * L),
                (t[3] = (d * x - u * P - f * w) * L),
                (t[4] = (c * T - o * C - l * A) * L),
                (t[5] = (n * C - r * T + s * A) * L),
                (t[6] = (m * b - p * P - y * v) * L),
                (t[7] = (h * P - d * b + f * v) * L),
                (t[8] = (o * M - a * T + l * E) * L),
                (t[9] = (i * T - n * M - s * E) * L),
                (t[10] = (p * x - g * b + y * _) * L),
                (t[11] = (u * b - h * x - f * _) * L),
                (t[12] = (a * A - o * S - c * E) * L),
                (t[13] = (n * S - i * A + r * E) * L),
                (t[14] = (g * v - p * w - m * _) * L),
                (t[15] = (h * w - u * v + d * _) * L),
                t)
              : null;
          }
          function kr(t, e, n) {
            var i = e[0],
              r = e[1],
              s = e[2],
              o = e[3],
              a = e[4],
              c = e[5],
              l = e[6],
              h = e[7],
              u = e[8],
              d = e[9],
              f = e[10],
              p = e[11],
              g = e[12],
              m = e[13],
              y = e[14],
              _ = e[15],
              v = n[0],
              b = n[1],
              w = n[2],
              x = n[3];
            return (
              (t[0] = v * i + b * a + w * u + x * g),
              (t[1] = v * r + b * c + w * d + x * m),
              (t[2] = v * s + b * l + w * f + x * y),
              (t[3] = v * o + b * h + w * p + x * _),
              (v = n[4]),
              (b = n[5]),
              (w = n[6]),
              (x = n[7]),
              (t[4] = v * i + b * a + w * u + x * g),
              (t[5] = v * r + b * c + w * d + x * m),
              (t[6] = v * s + b * l + w * f + x * y),
              (t[7] = v * o + b * h + w * p + x * _),
              (v = n[8]),
              (b = n[9]),
              (w = n[10]),
              (x = n[11]),
              (t[8] = v * i + b * a + w * u + x * g),
              (t[9] = v * r + b * c + w * d + x * m),
              (t[10] = v * s + b * l + w * f + x * y),
              (t[11] = v * o + b * h + w * p + x * _),
              (v = n[12]),
              (b = n[13]),
              (w = n[14]),
              (x = n[15]),
              (t[12] = v * i + b * a + w * u + x * g),
              (t[13] = v * r + b * c + w * d + x * m),
              (t[14] = v * s + b * l + w * f + x * y),
              (t[15] = v * o + b * h + w * p + x * _),
              t
            );
          }
          function Fr(t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              c,
              l,
              h,
              u,
              d,
              f,
              p,
              g = n[0],
              m = n[1],
              y = n[2];
            return (
              e === t
                ? ((t[12] = e[0] * g + e[4] * m + e[8] * y + e[12]),
                  (t[13] = e[1] * g + e[5] * m + e[9] * y + e[13]),
                  (t[14] = e[2] * g + e[6] * m + e[10] * y + e[14]),
                  (t[15] = e[3] * g + e[7] * m + e[11] * y + e[15]))
                : ((i = e[0]),
                  (r = e[1]),
                  (s = e[2]),
                  (o = e[3]),
                  (a = e[4]),
                  (c = e[5]),
                  (l = e[6]),
                  (h = e[7]),
                  (u = e[8]),
                  (d = e[9]),
                  (f = e[10]),
                  (p = e[11]),
                  (t[0] = i),
                  (t[1] = r),
                  (t[2] = s),
                  (t[3] = o),
                  (t[4] = a),
                  (t[5] = c),
                  (t[6] = l),
                  (t[7] = h),
                  (t[8] = u),
                  (t[9] = d),
                  (t[10] = f),
                  (t[11] = p),
                  (t[12] = i * g + a * m + u * y + e[12]),
                  (t[13] = r * g + c * m + d * y + e[13]),
                  (t[14] = s * g + l * m + f * y + e[14]),
                  (t[15] = o * g + h * m + p * y + e[15])),
              t
            );
          }
          function zr(t, e, n) {
            var i = n[0],
              r = n[1],
              s = n[2];
            return (
              (t[0] = e[0] * i),
              (t[1] = e[1] * i),
              (t[2] = e[2] * i),
              (t[3] = e[3] * i),
              (t[4] = e[4] * r),
              (t[5] = e[5] * r),
              (t[6] = e[6] * r),
              (t[7] = e[7] * r),
              (t[8] = e[8] * s),
              (t[9] = e[9] * s),
              (t[10] = e[10] * s),
              (t[11] = e[11] * s),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15]),
              t
            );
          }
          function jr(t, e, n) {
            var i = Math.sin(n),
              r = Math.cos(n),
              s = e[4],
              o = e[5],
              a = e[6],
              c = e[7],
              l = e[8],
              h = e[9],
              u = e[10],
              d = e[11];
            return (
              e !== t &&
                ((t[0] = e[0]),
                (t[1] = e[1]),
                (t[2] = e[2]),
                (t[3] = e[3]),
                (t[12] = e[12]),
                (t[13] = e[13]),
                (t[14] = e[14]),
                (t[15] = e[15])),
              (t[4] = s * r + l * i),
              (t[5] = o * r + h * i),
              (t[6] = a * r + u * i),
              (t[7] = c * r + d * i),
              (t[8] = l * r - s * i),
              (t[9] = h * r - o * i),
              (t[10] = u * r - a * i),
              (t[11] = d * r - c * i),
              t
            );
          }
          function Br(t, e, n) {
            var i = Math.sin(n),
              r = Math.cos(n),
              s = e[0],
              o = e[1],
              a = e[2],
              c = e[3],
              l = e[4],
              h = e[5],
              u = e[6],
              d = e[7];
            return (
              e !== t &&
                ((t[8] = e[8]),
                (t[9] = e[9]),
                (t[10] = e[10]),
                (t[11] = e[11]),
                (t[12] = e[12]),
                (t[13] = e[13]),
                (t[14] = e[14]),
                (t[15] = e[15])),
              (t[0] = s * r + l * i),
              (t[1] = o * r + h * i),
              (t[2] = a * r + u * i),
              (t[3] = c * r + d * i),
              (t[4] = l * r - s * i),
              (t[5] = h * r - o * i),
              (t[6] = u * r - a * i),
              (t[7] = d * r - c * i),
              t
            );
          }
          function Dr(t, e, n, i, r) {
            var s,
              o = 1 / Math.tan(e / 2);
            return (
              (t[0] = o / n),
              (t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[4] = 0),
              (t[5] = o),
              (t[6] = 0),
              (t[7] = 0),
              (t[8] = 0),
              (t[9] = 0),
              (t[11] = -1),
              (t[12] = 0),
              (t[13] = 0),
              (t[15] = 0),
              null != r && r !== 1 / 0
                ? ((s = 1 / (i - r)),
                  (t[10] = (r + i) * s),
                  (t[14] = 2 * r * i * s))
                : ((t[10] = -1), (t[14] = -2 * i)),
              t
            );
          }
          function Nr(t, e) {
            var n = t[0],
              i = t[1],
              r = t[2],
              s = t[3],
              o = t[4],
              a = t[5],
              c = t[6],
              l = t[7],
              h = t[8],
              u = t[9],
              d = t[10],
              f = t[11],
              p = t[12],
              g = t[13],
              m = t[14],
              y = t[15],
              _ = e[0],
              v = e[1],
              b = e[2],
              w = e[3],
              x = e[4],
              P = e[5],
              E = e[6],
              A = e[7],
              T = e[8],
              S = e[9],
              M = e[10],
              C = e[11],
              L = e[12],
              O = e[13],
              I = e[14],
              R = e[15];
            return (
              Math.abs(n - _) <= Be * Math.max(1, Math.abs(n), Math.abs(_)) &&
              Math.abs(i - v) <= Be * Math.max(1, Math.abs(i), Math.abs(v)) &&
              Math.abs(r - b) <= Be * Math.max(1, Math.abs(r), Math.abs(b)) &&
              Math.abs(s - w) <= Be * Math.max(1, Math.abs(s), Math.abs(w)) &&
              Math.abs(o - x) <= Be * Math.max(1, Math.abs(o), Math.abs(x)) &&
              Math.abs(a - P) <= Be * Math.max(1, Math.abs(a), Math.abs(P)) &&
              Math.abs(c - E) <= Be * Math.max(1, Math.abs(c), Math.abs(E)) &&
              Math.abs(l - A) <= Be * Math.max(1, Math.abs(l), Math.abs(A)) &&
              Math.abs(h - T) <= Be * Math.max(1, Math.abs(h), Math.abs(T)) &&
              Math.abs(u - S) <= Be * Math.max(1, Math.abs(u), Math.abs(S)) &&
              Math.abs(d - M) <= Be * Math.max(1, Math.abs(d), Math.abs(M)) &&
              Math.abs(f - C) <= Be * Math.max(1, Math.abs(f), Math.abs(C)) &&
              Math.abs(p - L) <= Be * Math.max(1, Math.abs(p), Math.abs(L)) &&
              Math.abs(g - O) <= Be * Math.max(1, Math.abs(g), Math.abs(O)) &&
              Math.abs(m - I) <= Be * Math.max(1, Math.abs(m), Math.abs(I)) &&
              Math.abs(y - R) <= Be * Math.max(1, Math.abs(y), Math.abs(R))
            );
          }
          function Ur(t, e, n) {
            var i = e[0],
              r = e[1],
              s = e[2],
              o = e[3];
            return (
              (t[0] = n[0] * i + n[4] * r + n[8] * s + n[12] * o),
              (t[1] = n[1] * i + n[5] * r + n[9] * s + n[13] * o),
              (t[2] = n[2] * i + n[6] * r + n[10] * s + n[14] * o),
              (t[3] = n[3] * i + n[7] * r + n[11] * s + n[15] * o),
              t
            );
          }
          !(function () {
            var t = new De(4);
            De != Float32Array &&
              ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0));
          })();
          const Vr = [0, 0, 0, 0],
            Gr = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            Wr = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            Hr = [0, 0, 0],
            $r = [0, 0, 0],
            Xr = Or(function ({
              viewport: t,
              devicePixelRatio: e,
              coordinateSystem: n,
              coordinateOrigin: i,
            }) {
              const {
                  projectionCenter: r,
                  viewProjectionMatrix: s,
                  originCommon: o,
                  cameraPosCommon: a,
                  shaderCoordinateOrigin: c,
                  geospatialOrigin: l,
                } = (function (t, e, n) {
                  const { viewMatrixUncentered: i, projectionMatrix: r } = t;
                  let { viewMatrix: s, viewProjectionMatrix: o } = t,
                    a = Vr,
                    c = Vr,
                    l = t.cameraPosition;
                  const {
                    geospatialOrigin: h,
                    shaderCoordinateOrigin: u,
                    offsetMode: d,
                  } = Yr(t, e, n);
                  return (
                    d &&
                      ((c = t.projectPosition(h || u)),
                      (l = [l[0] - c[0], l[1] - c[1], l[2] - c[2]]),
                      (c[3] = 1),
                      (a = Ur([], c, o)),
                      (s = i || s),
                      (o = kr([], r, s)),
                      (o = kr([], o, Gr))),
                    {
                      viewMatrix: s,
                      viewProjectionMatrix: o,
                      projectionCenter: a,
                      originCommon: c,
                      cameraPosCommon: l,
                      shaderCoordinateOrigin: u,
                      geospatialOrigin: h,
                    }
                  );
                })(t, n, i),
                h = t.getDistanceScales(),
                u = [t.width * e, t.height * e],
                d =
                  t.projectionMatrix.transform([
                    0,
                    0,
                    -t.focalDistance,
                    1,
                  ])[3] || 1,
                f = {
                  project_uCoordinateSystem: n,
                  project_uProjectionMode: t.projectionMode,
                  project_uCoordinateOrigin: c,
                  project_uCommonOrigin: o.slice(0, 3),
                  project_uCenter: r,
                  project_uPseudoMeters: Boolean(t._pseudoMeters),
                  project_uViewportSize: u,
                  project_uDevicePixelRatio: e,
                  project_uFocalDistance: d,
                  project_uCommonUnitsPerMeter: h.unitsPerMeter,
                  project_uCommonUnitsPerWorldUnit: h.unitsPerMeter,
                  project_uCommonUnitsPerWorldUnit2: Hr,
                  project_uScale: t.scale,
                  project_uViewProjectionMatrix: s,
                  project_uCameraPosition: a,
                };
              if (l) {
                const e = t.getDistanceScales(l);
                switch (n) {
                  case A.METER_OFFSETS:
                    (f.project_uCommonUnitsPerWorldUnit = e.unitsPerMeter),
                      (f.project_uCommonUnitsPerWorldUnit2 = e.unitsPerMeter2);
                    break;
                  case A.LNGLAT:
                  case A.LNGLAT_OFFSETS:
                    t._pseudoMeters ||
                      (f.project_uCommonUnitsPerMeter = e.unitsPerMeter),
                      (f.project_uCommonUnitsPerWorldUnit = e.unitsPerDegree),
                      (f.project_uCommonUnitsPerWorldUnit2 = e.unitsPerDegree2);
                    break;
                  case A.CARTESIAN:
                    (f.project_uCommonUnitsPerWorldUnit = [
                      1,
                      1,
                      e.unitsPerMeter[2],
                    ]),
                      (f.project_uCommonUnitsPerWorldUnit2 = [
                        0,
                        0,
                        e.unitsPerMeter2[2],
                      ]);
                }
              }
              return f;
            });
          function Yr(t, e, n = $r) {
            let i,
              r = n,
              s = !0;
            switch (
              ((i =
                e === A.LNGLAT_OFFSETS || e === A.METER_OFFSETS
                  ? n
                  : t.isGeospatial
                  ? [Math.fround(t.longitude), Math.fround(t.latitude), 0]
                  : null),
              t.projectionMode)
            ) {
              case T.WEB_MERCATOR:
                (e !== A.LNGLAT && e !== A.CARTESIAN) ||
                  ((i = [0, 0, 0]), (s = !1));
                break;
              case T.WEB_MERCATOR_AUTO_OFFSET:
                e === A.LNGLAT
                  ? (r = i)
                  : e === A.CARTESIAN &&
                    ((r = [
                      Math.fround(t.center[0]),
                      Math.fround(t.center[1]),
                      0,
                    ]),
                    (i = t.unprojectPosition(r)),
                    (r[0] -= n[0]),
                    (r[1] -= n[1]),
                    (r[2] -= n[2]));
                break;
              case T.IDENTITY:
                r = t.position.map(Math.fround);
                break;
              case T.GLOBE:
                (s = !1), (i = null);
                break;
              default:
                s = !1;
            }
            return (
              (r[2] = r[2] || 0),
              { geospatialOrigin: i, shaderCoordinateOrigin: r, offsetMode: s }
            );
          }
          class qr extends Ie {
            get ELEMENTS() {
              return Oe(!1), 0;
            }
            get RANK() {
              return Oe(!1), 0;
            }
            toString() {
              let t = "[";
              if (Ae.printRowMajor) {
                t += "row-major:";
                for (let e = 0; e < this.RANK; ++e)
                  for (let n = 0; n < this.RANK; ++n)
                    t += " ".concat(this[n * this.RANK + e]);
              } else {
                t += "column-major:";
                for (let e = 0; e < this.ELEMENTS; ++e)
                  t += " ".concat(this[e]);
              }
              return (t += "]"), t;
            }
            getElementIndex(t, e) {
              return e * this.RANK + t;
            }
            getElement(t, e) {
              return this[e * this.RANK + t];
            }
            setElement(t, e, n) {
              return (this[e * this.RANK + t] = Re(n)), this;
            }
            getColumn(t, e = new Array(this.RANK).fill(-0)) {
              const n = t * this.RANK;
              for (let t = 0; t < this.RANK; ++t) e[t] = this[n + t];
              return e;
            }
            setColumn(t, e) {
              const n = t * this.RANK;
              for (let t = 0; t < this.RANK; ++t) this[n + t] = e[t];
              return this;
            }
          }
          function Zr(t, e, n) {
            return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), t;
          }
          function Kr(t, e) {
            return (t[0] = -e[0]), (t[1] = -e[1]), t;
          }
          function Jr(t, e, n, i) {
            var r = e[0],
              s = e[1];
            return (t[0] = r + i * (n[0] - r)), (t[1] = s + i * (n[1] - s)), t;
          }
          !(function () {
            var t = new De(2);
            De != Float32Array && ((t[0] = 0), (t[1] = 0));
          })();
          const Qr = Object.freeze([
              1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ]),
            ts = Object.freeze([
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ]),
            es = Object.freeze({
              COL0ROW0: 0,
              COL0ROW1: 1,
              COL0ROW2: 2,
              COL0ROW3: 3,
              COL1ROW0: 4,
              COL1ROW1: 5,
              COL1ROW2: 6,
              COL1ROW3: 7,
              COL2ROW0: 8,
              COL2ROW1: 9,
              COL2ROW2: 10,
              COL2ROW3: 11,
              COL3ROW0: 12,
              COL3ROW1: 13,
              COL3ROW2: 14,
              COL3ROW3: 15,
            }),
            ns = {};
          class is extends qr {
            static get IDENTITY() {
              return (
                (ns.IDENTITY = ns.IDENTITY || Object.freeze(new is(Qr))),
                ns.IDENTITY
              );
            }
            static get ZERO() {
              return (ns.ZERO = ns.ZERO || Object.freeze(new is(ts))), ns.ZERO;
            }
            get INDICES() {
              return es;
            }
            get ELEMENTS() {
              return 16;
            }
            get RANK() {
              return 4;
            }
            constructor(t) {
              super(
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0
              ),
                1 === arguments.length && Array.isArray(t)
                  ? this.copy(t)
                  : this.identity();
            }
            copy(t) {
              return (
                (this[0] = t[0]),
                (this[1] = t[1]),
                (this[2] = t[2]),
                (this[3] = t[3]),
                (this[4] = t[4]),
                (this[5] = t[5]),
                (this[6] = t[6]),
                (this[7] = t[7]),
                (this[8] = t[8]),
                (this[9] = t[9]),
                (this[10] = t[10]),
                (this[11] = t[11]),
                (this[12] = t[12]),
                (this[13] = t[13]),
                (this[14] = t[14]),
                (this[15] = t[15]),
                this.check()
              );
            }
            set(t, e, n, i, r, s, o, a, c, l, h, u, d, f, p, g) {
              return (
                (this[0] = t),
                (this[1] = e),
                (this[2] = n),
                (this[3] = i),
                (this[4] = r),
                (this[5] = s),
                (this[6] = o),
                (this[7] = a),
                (this[8] = c),
                (this[9] = l),
                (this[10] = h),
                (this[11] = u),
                (this[12] = d),
                (this[13] = f),
                (this[14] = p),
                (this[15] = g),
                this.check()
              );
            }
            setRowMajor(t, e, n, i, r, s, o, a, c, l, h, u, d, f, p, g) {
              return (
                (this[0] = t),
                (this[1] = r),
                (this[2] = c),
                (this[3] = d),
                (this[4] = e),
                (this[5] = s),
                (this[6] = l),
                (this[7] = f),
                (this[8] = n),
                (this[9] = o),
                (this[10] = h),
                (this[11] = p),
                (this[12] = i),
                (this[13] = a),
                (this[14] = u),
                (this[15] = g),
                this.check()
              );
            }
            toRowMajor(t) {
              return (
                (t[0] = this[0]),
                (t[1] = this[4]),
                (t[2] = this[8]),
                (t[3] = this[12]),
                (t[4] = this[1]),
                (t[5] = this[5]),
                (t[6] = this[9]),
                (t[7] = this[13]),
                (t[8] = this[2]),
                (t[9] = this[6]),
                (t[10] = this[10]),
                (t[11] = this[14]),
                (t[12] = this[3]),
                (t[13] = this[7]),
                (t[14] = this[11]),
                (t[15] = this[15]),
                t
              );
            }
            identity() {
              return this.copy(Qr);
            }
            fromQuaternion(t) {
              return (
                (function (t, e) {
                  var n = e[0],
                    i = e[1],
                    r = e[2],
                    s = e[3],
                    o = n + n,
                    a = i + i,
                    c = r + r,
                    l = n * o,
                    h = i * o,
                    u = i * a,
                    d = r * o,
                    f = r * a,
                    p = r * c,
                    g = s * o,
                    m = s * a,
                    y = s * c;
                  (t[0] = 1 - u - p),
                    (t[1] = h + y),
                    (t[2] = d - m),
                    (t[3] = 0),
                    (t[4] = h - y),
                    (t[5] = 1 - l - p),
                    (t[6] = f + g),
                    (t[7] = 0),
                    (t[8] = d + m),
                    (t[9] = f - g),
                    (t[10] = 1 - l - u),
                    (t[11] = 0),
                    (t[12] = 0),
                    (t[13] = 0),
                    (t[14] = 0),
                    (t[15] = 1);
                })(this, t),
                this.check()
              );
            }
            frustum({ left: t, right: e, bottom: n, top: i, near: r, far: s }) {
              return (
                s === 1 / 0
                  ? is._computeInfinitePerspectiveOffCenter(this, t, e, n, i, r)
                  : (function (t, e, n, i, r, s, o) {
                      var a = 1 / (n - e),
                        c = 1 / (r - i),
                        l = 1 / (s - o);
                      (t[0] = 2 * s * a),
                        (t[1] = 0),
                        (t[2] = 0),
                        (t[3] = 0),
                        (t[4] = 0),
                        (t[5] = 2 * s * c),
                        (t[6] = 0),
                        (t[7] = 0),
                        (t[8] = (n + e) * a),
                        (t[9] = (r + i) * c),
                        (t[10] = (o + s) * l),
                        (t[11] = -1),
                        (t[12] = 0),
                        (t[13] = 0),
                        (t[14] = o * s * 2 * l),
                        (t[15] = 0);
                    })(this, t, e, n, i, r, s),
                this.check()
              );
            }
            static _computeInfinitePerspectiveOffCenter(t, e, n, i, r, s) {
              const o = (2 * s) / (n - e),
                a = (2 * s) / (r - i),
                c = (n + e) / (n - e),
                l = (r + i) / (r - i),
                h = -2 * s;
              return (
                (t[0] = o),
                (t[1] = 0),
                (t[2] = 0),
                (t[3] = 0),
                (t[4] = 0),
                (t[5] = a),
                (t[6] = 0),
                (t[7] = 0),
                (t[8] = c),
                (t[9] = l),
                (t[10] = -1),
                (t[11] = -1),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = h),
                (t[15] = 0),
                t
              );
            }
            lookAt(t, e, n) {
              return (
                1 === arguments.length && ({ eye: t, center: e, up: n } = t),
                (function (t, e, n, i) {
                  var r,
                    s,
                    o,
                    a,
                    c,
                    l,
                    h,
                    u,
                    d,
                    f,
                    p = e[0],
                    g = e[1],
                    m = e[2],
                    y = i[0],
                    _ = i[1],
                    v = i[2],
                    b = n[0],
                    w = n[1],
                    x = n[2];
                  Math.abs(p - b) < Be &&
                  Math.abs(g - w) < Be &&
                  Math.abs(m - x) < Be
                    ? (function (t) {
                        (t[0] = 1),
                          (t[1] = 0),
                          (t[2] = 0),
                          (t[3] = 0),
                          (t[4] = 0),
                          (t[5] = 1),
                          (t[6] = 0),
                          (t[7] = 0),
                          (t[8] = 0),
                          (t[9] = 0),
                          (t[10] = 1),
                          (t[11] = 0),
                          (t[12] = 0),
                          (t[13] = 0),
                          (t[14] = 0),
                          (t[15] = 1);
                      })(t)
                    : ((h = p - b),
                      (u = g - w),
                      (d = m - x),
                      (r =
                        _ * (d *= f = 1 / Math.hypot(h, u, d)) - v * (u *= f)),
                      (s = v * (h *= f) - y * d),
                      (o = y * u - _ * h),
                      (f = Math.hypot(r, s, o))
                        ? ((r *= f = 1 / f), (s *= f), (o *= f))
                        : ((r = 0), (s = 0), (o = 0)),
                      (a = u * o - d * s),
                      (c = d * r - h * o),
                      (l = h * s - u * r),
                      (f = Math.hypot(a, c, l))
                        ? ((a *= f = 1 / f), (c *= f), (l *= f))
                        : ((a = 0), (c = 0), (l = 0)),
                      (t[0] = r),
                      (t[1] = a),
                      (t[2] = h),
                      (t[3] = 0),
                      (t[4] = s),
                      (t[5] = c),
                      (t[6] = u),
                      (t[7] = 0),
                      (t[8] = o),
                      (t[9] = l),
                      (t[10] = d),
                      (t[11] = 0),
                      (t[12] = -(r * p + s * g + o * m)),
                      (t[13] = -(a * p + c * g + l * m)),
                      (t[14] = -(h * p + u * g + d * m)),
                      (t[15] = 1));
                })(this, t, (e = e || [0, 0, 0]), (n = n || [0, 1, 0])),
                this.check()
              );
            }
            ortho({
              left: t,
              right: e,
              bottom: n,
              top: i,
              near: r = 0.1,
              far: s = 500,
            }) {
              return (
                (function (t, e, n, i, r, s, o) {
                  var a = 1 / (e - n),
                    c = 1 / (i - r),
                    l = 1 / (s - o);
                  (t[0] = -2 * a),
                    (t[1] = 0),
                    (t[2] = 0),
                    (t[3] = 0),
                    (t[4] = 0),
                    (t[5] = -2 * c),
                    (t[6] = 0),
                    (t[7] = 0),
                    (t[8] = 0),
                    (t[9] = 0),
                    (t[10] = 2 * l),
                    (t[11] = 0),
                    (t[12] = (e + n) * a),
                    (t[13] = (r + i) * c),
                    (t[14] = (o + s) * l),
                    (t[15] = 1);
                })(this, t, e, n, i, r, s),
                this.check()
              );
            }
            orthographic({
              fovy: t = (45 * Math.PI) / 180,
              aspect: e = 1,
              focalDistance: n = 1,
              near: i = 0.1,
              far: r = 500,
            }) {
              if (t > 2 * Math.PI) throw Error("radians");
              const s = t / 2,
                o = n * Math.tan(s),
                a = o * e;
              return new is().ortho({
                left: -a,
                right: a,
                bottom: -o,
                top: o,
                near: i,
                far: r,
              });
            }
            perspective({
              fovy: t,
              fov: e = (45 * Math.PI) / 180,
              aspect: n = 1,
              near: i = 0.1,
              far: r = 500,
            } = {}) {
              if ((t = t || e) > 2 * Math.PI) throw Error("radians");
              return Dr(this, t, n, i, r), this.check();
            }
            determinant() {
              return (
                (e = (t = this)[0]),
                (n = t[1]),
                (i = t[2]),
                (r = t[3]),
                (s = t[4]),
                (o = t[5]),
                (a = t[6]),
                (c = t[7]),
                (l = t[8]),
                (h = t[9]),
                (u = t[10]),
                (d = t[11]),
                (f = t[12]),
                (p = t[13]),
                (g = t[14]),
                (e * o - n * s) * (u * (m = t[15]) - d * g) -
                  (e * a - i * s) * (h * m - d * p) +
                  (e * c - r * s) * (h * g - u * p) +
                  (n * a - i * o) * (l * m - d * f) -
                  (n * c - r * o) * (l * g - u * f) +
                  (i * c - r * a) * (l * p - h * f)
              );
              var t, e, n, i, r, s, o, a, c, l, h, u, d, f, p, g, m;
            }
            getScale(t = [-0, -0, -0]) {
              return (
                (t[0] = Math.sqrt(
                  this[0] * this[0] + this[1] * this[1] + this[2] * this[2]
                )),
                (t[1] = Math.sqrt(
                  this[4] * this[4] + this[5] * this[5] + this[6] * this[6]
                )),
                (t[2] = Math.sqrt(
                  this[8] * this[8] + this[9] * this[9] + this[10] * this[10]
                )),
                t
              );
            }
            getTranslation(t = [-0, -0, -0]) {
              return (t[0] = this[12]), (t[1] = this[13]), (t[2] = this[14]), t;
            }
            getRotation(
              t = [
                -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,
              ],
              e = null
            ) {
              const n = this.getScale(e || [-0, -0, -0]),
                i = 1 / n[0],
                r = 1 / n[1],
                s = 1 / n[2];
              return (
                (t[0] = this[0] * i),
                (t[1] = this[1] * r),
                (t[2] = this[2] * s),
                (t[3] = 0),
                (t[4] = this[4] * i),
                (t[5] = this[5] * r),
                (t[6] = this[6] * s),
                (t[7] = 0),
                (t[8] = this[8] * i),
                (t[9] = this[9] * r),
                (t[10] = this[10] * s),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                t
              );
            }
            getRotationMatrix3(
              t = [-0, -0, -0, -0, -0, -0, -0, -0, -0],
              e = null
            ) {
              const n = this.getScale(e || [-0, -0, -0]),
                i = 1 / n[0],
                r = 1 / n[1],
                s = 1 / n[2];
              return (
                (t[0] = this[0] * i),
                (t[1] = this[1] * r),
                (t[2] = this[2] * s),
                (t[3] = this[4] * i),
                (t[4] = this[5] * r),
                (t[5] = this[6] * s),
                (t[6] = this[8] * i),
                (t[7] = this[9] * r),
                (t[8] = this[10] * s),
                t
              );
            }
            transpose() {
              return (
                (function (t, e) {
                  if (t === e) {
                    var n = e[1],
                      i = e[2],
                      r = e[3],
                      s = e[6],
                      o = e[7],
                      a = e[11];
                    (t[1] = e[4]),
                      (t[2] = e[8]),
                      (t[3] = e[12]),
                      (t[4] = n),
                      (t[6] = e[9]),
                      (t[7] = e[13]),
                      (t[8] = i),
                      (t[9] = s),
                      (t[11] = e[14]),
                      (t[12] = r),
                      (t[13] = o),
                      (t[14] = a);
                  } else
                    (t[0] = e[0]),
                      (t[1] = e[4]),
                      (t[2] = e[8]),
                      (t[3] = e[12]),
                      (t[4] = e[1]),
                      (t[5] = e[5]),
                      (t[6] = e[9]),
                      (t[7] = e[13]),
                      (t[8] = e[2]),
                      (t[9] = e[6]),
                      (t[10] = e[10]),
                      (t[11] = e[14]),
                      (t[12] = e[3]),
                      (t[13] = e[7]),
                      (t[14] = e[11]),
                      (t[15] = e[15]);
                })(this, this),
                this.check()
              );
            }
            invert() {
              return Rr(this, this), this.check();
            }
            multiplyLeft(t) {
              return kr(this, t, this), this.check();
            }
            multiplyRight(t) {
              return kr(this, this, t), this.check();
            }
            rotateX(t) {
              return jr(this, this, t), this.check();
            }
            rotateY(t) {
              return (
                (function (t, e, n) {
                  var i = Math.sin(n),
                    r = Math.cos(n),
                    s = e[0],
                    o = e[1],
                    a = e[2],
                    c = e[3],
                    l = e[8],
                    h = e[9],
                    u = e[10],
                    d = e[11];
                  e !== t &&
                    ((t[4] = e[4]),
                    (t[5] = e[5]),
                    (t[6] = e[6]),
                    (t[7] = e[7]),
                    (t[12] = e[12]),
                    (t[13] = e[13]),
                    (t[14] = e[14]),
                    (t[15] = e[15])),
                    (t[0] = s * r - l * i),
                    (t[1] = o * r - h * i),
                    (t[2] = a * r - u * i),
                    (t[3] = c * r - d * i),
                    (t[8] = s * i + l * r),
                    (t[9] = o * i + h * r),
                    (t[10] = a * i + u * r),
                    (t[11] = c * i + d * r);
                })(this, this, t),
                this.check()
              );
            }
            rotateZ(t) {
              return Br(this, this, t), this.check();
            }
            rotateXYZ([t, e, n]) {
              return this.rotateX(t).rotateY(e).rotateZ(n);
            }
            rotateAxis(t, e) {
              return (
                (function (t, e, n, i) {
                  var r,
                    s,
                    o,
                    a,
                    c,
                    l,
                    h,
                    u,
                    d,
                    f,
                    p,
                    g,
                    m,
                    y,
                    _,
                    v,
                    b,
                    w,
                    x,
                    P,
                    E,
                    A,
                    T,
                    S,
                    M = i[0],
                    C = i[1],
                    L = i[2],
                    O = Math.hypot(M, C, L);
                  O < Be ||
                    ((M *= O = 1 / O),
                    (C *= O),
                    (L *= O),
                    (r = Math.sin(n)),
                    (o = 1 - (s = Math.cos(n))),
                    (a = e[0]),
                    (c = e[1]),
                    (l = e[2]),
                    (h = e[3]),
                    (u = e[4]),
                    (d = e[5]),
                    (f = e[6]),
                    (p = e[7]),
                    (g = e[8]),
                    (m = e[9]),
                    (y = e[10]),
                    (_ = e[11]),
                    (v = M * M * o + s),
                    (b = C * M * o + L * r),
                    (w = L * M * o - C * r),
                    (x = M * C * o - L * r),
                    (P = C * C * o + s),
                    (E = L * C * o + M * r),
                    (A = M * L * o + C * r),
                    (T = C * L * o - M * r),
                    (S = L * L * o + s),
                    (t[0] = a * v + u * b + g * w),
                    (t[1] = c * v + d * b + m * w),
                    (t[2] = l * v + f * b + y * w),
                    (t[3] = h * v + p * b + _ * w),
                    (t[4] = a * x + u * P + g * E),
                    (t[5] = c * x + d * P + m * E),
                    (t[6] = l * x + f * P + y * E),
                    (t[7] = h * x + p * P + _ * E),
                    (t[8] = a * A + u * T + g * S),
                    (t[9] = c * A + d * T + m * S),
                    (t[10] = l * A + f * T + y * S),
                    (t[11] = h * A + p * T + _ * S),
                    e !== t &&
                      ((t[12] = e[12]),
                      (t[13] = e[13]),
                      (t[14] = e[14]),
                      (t[15] = e[15])));
                })(this, this, t, e),
                this.check()
              );
            }
            scale(t) {
              return (
                Array.isArray(t)
                  ? zr(this, this, t)
                  : zr(this, this, [t, t, t]),
                this.check()
              );
            }
            translate(t) {
              return Fr(this, this, t), this.check();
            }
            transform(t, e) {
              return 4 === t.length
                ? (ke((e = Ur(e || [-0, -0, -0, -0], t, this)), 4), e)
                : this.transformAsPoint(t, e);
            }
            transformAsPoint(t, e) {
              const { length: n } = t;
              switch (n) {
                case 2:
                  e = (function (t, e, n) {
                    var i = e[0],
                      r = e[1];
                    return (
                      (t[0] = n[0] * i + n[4] * r + n[12]),
                      (t[1] = n[1] * i + n[5] * r + n[13]),
                      t
                    );
                  })(e || [-0, -0], t, this);
                  break;
                case 3:
                  e = Ne(e || [-0, -0, -0], t, this);
                  break;
                default:
                  throw new Error("Illegal vector");
              }
              return ke(e, t.length), e;
            }
            transformAsVector(t, e) {
              switch (t.length) {
                case 2:
                  e = (function (t, e, n) {
                    const i = e[0],
                      r = e[1],
                      s = n[3] * i + n[7] * r || 1;
                    return (
                      (t[0] = (n[0] * i + n[4] * r) / s),
                      (t[1] = (n[1] * i + n[5] * r) / s),
                      t
                    );
                  })(e || [-0, -0], t, this);
                  break;
                case 3:
                  e = Ve(e || [-0, -0, -0], t, this);
                  break;
                default:
                  throw new Error("Illegal vector");
              }
              return ke(e, t.length), e;
            }
            makeRotationX(t) {
              return this.identity().rotateX(t);
            }
            makeTranslation(t, e, n) {
              return this.identity().translate([t, e, n]);
            }
            transformPoint(t, e) {
              return (
                ze("Matrix4.transformPoint", "3.0"), this.transformAsPoint(t, e)
              );
            }
            transformVector(t, e) {
              return (
                ze("Matrix4.transformVector", "3.0"),
                this.transformAsPoint(t, e)
              );
            }
            transformDirection(t, e) {
              return (
                ze("Matrix4.transformDirection", "3.0"),
                this.transformAsVector(t, e)
              );
            }
          }
          function rs(t, e) {
            const n = Ur([], e, t);
            return (
              (function (t, e, n) {
                (t[0] = e[0] * n),
                  (t[1] = e[1] * n),
                  (t[2] = e[2] * n),
                  (t[3] = e[3] * n);
              })(n, n, 1 / n[3]),
              n
            );
          }
          function ss(t, e) {
            const n = t % e;
            return n < 0 ? e + n : n;
          }
          const os =
            Math.log2 ||
            function (t) {
              return Math.log(t) * Math.LOG2E;
            };
          function as(t, e) {
            if (!t)
              throw new Error(e || "@math.gl/web-mercator: assertion failed.");
          }
          const cs = Math.PI,
            ls = cs / 4,
            hs = cs / 180,
            us = 180 / cs,
            ds = 512;
          function fs([t, e]) {
            as(Number.isFinite(t)),
              as(Number.isFinite(e) && e >= -90 && e <= 90, "invalid latitude");
            const n = e * hs;
            return [
              (ds * (t * hs + cs)) / (2 * cs),
              (ds * (cs + Math.log(Math.tan(ls + 0.5 * n)))) / (2 * cs),
            ];
          }
          function ps([t, e]) {
            const n = (t / ds) * (2 * cs) - cs,
              i = 2 * (Math.atan(Math.exp((e / ds) * (2 * cs) - cs)) - ls);
            return [n * us, i * us];
          }
          function gs({ latitude: t, longitude: e, highPrecision: n = !1 }) {
            as(Number.isFinite(t) && Number.isFinite(e));
            const i = {},
              r = Math.cos(t * hs),
              s = 512 / 360,
              o = s / r,
              a = 12790407194604047e-21 / r;
            if (
              ((i.unitsPerMeter = [a, a, a]),
              (i.metersPerUnit = [1 / a, 1 / a, 1 / a]),
              (i.unitsPerDegree = [s, o, a]),
              (i.degreesPerUnit = [0.703125, 1 / o, 1 / a]),
              n)
            ) {
              const e = (hs * Math.tan(t * hs)) / r,
                n = (s * e) / 2,
                c = 12790407194604047e-21 * e,
                l = (c / o) * a;
              (i.unitsPerDegree2 = [0, n, c]), (i.unitsPerMeter2 = [l, 0, l]);
            }
            return i;
          }
          function ms(t, e) {
            const [n, i, r] = t,
              [s, o, a] = e,
              { unitsPerMeter: c, unitsPerMeter2: l } = gs({
                longitude: n,
                latitude: i,
                highPrecision: !0,
              }),
              h = fs(t);
            (h[0] += s * (c[0] + l[0] * o)), (h[1] += o * (c[1] + l[1] * o));
            const u = ps(h),
              d = (r || 0) + (a || 0);
            return Number.isFinite(r) || Number.isFinite(a)
              ? [u[0], u[1], d]
              : u;
          }
          function ys({
            height: t,
            pitch: e,
            bearing: n,
            altitude: i,
            scale: r,
            center: s = null,
          }) {
            const o = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            return (
              Fr(o, o, [0, 0, -i]),
              jr(o, o, -e * hs),
              Br(o, o, n * hs),
              zr(o, o, [(r /= t), r, r]),
              s &&
                Fr(
                  o,
                  o,
                  (function (t, e) {
                    return (t[0] = -e[0]), (t[1] = -e[1]), (t[2] = -e[2]), t;
                  })([], s)
                ),
              o
            );
          }
          function _s({
            width: t,
            height: e,
            fovy: n = vs(1.5),
            altitude: i,
            pitch: r = 0,
            nearZMultiplier: s = 1,
            farZMultiplier: o = 1,
          }) {
            void 0 !== i && (n = vs(i));
            const a = 0.5 * n * hs,
              c = bs(n),
              l = r * hs,
              h =
                (Math.sin(a) * c) /
                Math.sin(
                  Math.min(Math.max(Math.PI / 2 - l - a, 0.01), Math.PI - 0.01)
                );
            return {
              fov: 2 * a,
              aspect: t / e,
              focalDistance: c,
              near: s,
              far: (Math.sin(l) * h + c) * o,
            };
          }
          function vs(t) {
            return 2 * Math.atan(0.5 / t) * us;
          }
          function bs(t) {
            return 0.5 / Math.tan(0.5 * t * hs);
          }
          function ws(t, e) {
            const [n, i, r = 0] = t;
            return (
              as(
                Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r)
              ),
              rs(e, [n, i, r, 1])
            );
          }
          function xs(t, e, n = 0) {
            const [i, r, s] = t;
            if (
              (as(
                Number.isFinite(i) && Number.isFinite(r),
                "invalid pixel coordinate"
              ),
              Number.isFinite(s))
            )
              return rs(e, [i, r, s, 1]);
            const o = rs(e, [i, r, 0, 1]),
              a = rs(e, [i, r, 1, 1]),
              c = o[2],
              l = a[2];
            return Jr([], o, a, c === l ? 0 : ((n || 0) - c) / (l - c));
          }
          function Ps({
            width: t,
            height: e,
            bounds: n,
            minExtent: i = 0,
            maxZoom: r = 24,
            padding: s = 0,
            offset: o = [0, 0],
          }) {
            const [[a, c], [l, h]] = n;
            Number.isFinite(s)
              ? (s = { top: s, bottom: s, left: s, right: s })
              : as(
                  Number.isFinite(s.top) &&
                    Number.isFinite(s.bottom) &&
                    Number.isFinite(s.left) &&
                    Number.isFinite(s.right)
                );
            const u = new Ss({
                width: t,
                height: e,
                longitude: 0,
                latitude: 0,
                zoom: 0,
              }),
              d = u.project([a, h]),
              f = u.project([l, c]),
              p = [
                Math.max(Math.abs(f[0] - d[0]), i),
                Math.max(Math.abs(f[1] - d[1]), i),
              ],
              g = [
                t - s.left - s.right - 2 * Math.abs(o[0]),
                e - s.top - s.bottom - 2 * Math.abs(o[1]),
              ];
            as(g[0] > 0 && g[1] > 0);
            const m = g[0] / p[0],
              y = g[1] / p[1],
              _ = (s.right - s.left) / 2 / m,
              v = (s.bottom - s.top) / 2 / y,
              b = [(f[0] + d[0]) / 2 + _, (f[1] + d[1]) / 2 + v],
              w = u.unproject(b),
              x = Math.min(r, u.zoom + os(Math.abs(Math.min(m, y))));
            return (
              as(Number.isFinite(x)),
              { longitude: w[0], latitude: w[1], zoom: x }
            );
          }
          const Es = Math.PI / 180;
          function As(t, e = 0) {
            const { width: n, height: i, unproject: r } = t,
              s = { targetZ: e },
              o = r([0, i], s),
              a = r([n, i], s);
            let c, l;
            return (
              (t.fovy ? 0.5 * t.fovy * Es : Math.atan(0.5 / t.altitude)) >
              (90 - t.pitch) * Es - 0.01
                ? ((c = Ts(t, 0, e)), (l = Ts(t, n, e)))
                : ((c = r([0, 0], s)), (l = r([n, 0], s))),
              [o, a, l, c]
            );
          }
          function Ts(t, e, n) {
            const { pixelUnprojectionMatrix: i } = t,
              r = rs(i, [e, 0, 1, 1]),
              s = rs(i, [e, t.height, 1, 1]),
              o = ps(
                Jr(
                  [],
                  r,
                  s,
                  (n * t.distanceScales.unitsPerMeter[2] - r[2]) / (s[2] - r[2])
                )
              );
            return (o[2] = n), o;
          }
          class Ss {
            constructor(
              {
                width: t,
                height: e,
                latitude: n = 0,
                longitude: i = 0,
                zoom: r = 0,
                pitch: s = 0,
                bearing: o = 0,
                altitude: a = null,
                fovy: c = null,
                position: l = null,
                nearZMultiplier: h = 0.02,
                farZMultiplier: u = 1.01,
              } = { width: 1, height: 1 }
            ) {
              (t = t || 1),
                (e = e || 1),
                null === c && null === a
                  ? (c = vs((a = 1.5)))
                  : null === c
                  ? (c = vs(a))
                  : null === a && (a = bs(c));
              const d = (function (t) {
                return Math.pow(2, t);
              })(r);
              a = Math.max(0.75, a);
              const f = gs({ longitude: i, latitude: n }),
                p = fs([i, n]);
              (p[2] = 0),
                l &&
                  (function (t, e, n) {
                    (t[0] = e[0] + n[0]),
                      (t[1] = e[1] + n[1]),
                      (t[2] = e[2] + n[2]);
                  })(
                    p,
                    p,
                    (function (t, e, n) {
                      return (
                        (t[0] = e[0] * n[0]),
                        (t[1] = e[1] * n[1]),
                        (t[2] = e[2] * n[2]),
                        t
                      );
                    })([], l, f.unitsPerMeter)
                  ),
                (this.projectionMatrix = (function ({
                  width: t,
                  height: e,
                  pitch: n,
                  altitude: i,
                  fovy: r,
                  nearZMultiplier: s,
                  farZMultiplier: o,
                }) {
                  const {
                    fov: a,
                    aspect: c,
                    near: l,
                    far: h,
                  } = _s({
                    width: t,
                    height: e,
                    altitude: i,
                    fovy: r,
                    pitch: n,
                    nearZMultiplier: s,
                    farZMultiplier: o,
                  });
                  return Dr([], a, c, l, h);
                })({
                  width: t,
                  height: e,
                  pitch: s,
                  fovy: c,
                  nearZMultiplier: h,
                  farZMultiplier: u,
                })),
                (this.viewMatrix = ys({
                  height: e,
                  scale: d,
                  center: p,
                  pitch: s,
                  bearing: o,
                  altitude: a,
                })),
                (this.width = t),
                (this.height = e),
                (this.scale = d),
                (this.latitude = n),
                (this.longitude = i),
                (this.zoom = r),
                (this.pitch = s),
                (this.bearing = o),
                (this.altitude = a),
                (this.fovy = c),
                (this.center = p),
                (this.meterOffset = l || [0, 0, 0]),
                (this.distanceScales = f),
                this._initMatrices(),
                (this.equals = this.equals.bind(this)),
                (this.project = this.project.bind(this)),
                (this.unproject = this.unproject.bind(this)),
                (this.projectPosition = this.projectPosition.bind(this)),
                (this.unprojectPosition = this.unprojectPosition.bind(this)),
                Object.freeze(this);
            }
            _initMatrices() {
              const {
                  width: t,
                  height: e,
                  projectionMatrix: n,
                  viewMatrix: i,
                } = this,
                r = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              kr(r, r, n), kr(r, r, i), (this.viewProjectionMatrix = r);
              const s = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              zr(s, s, [t / 2, -e / 2, 1]), Fr(s, s, [1, -1, 0]), kr(s, s, r);
              const o = Rr([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], s);
              if (!o) throw new Error("Pixel project matrix not invertible");
              (this.pixelProjectionMatrix = s),
                (this.pixelUnprojectionMatrix = o);
            }
            equals(t) {
              return (
                t instanceof Ss &&
                t.width === this.width &&
                t.height === this.height &&
                Nr(t.projectionMatrix, this.projectionMatrix) &&
                Nr(t.viewMatrix, this.viewMatrix)
              );
            }
            project(t, { topLeft: e = !0 } = {}) {
              const n = ws(this.projectPosition(t), this.pixelProjectionMatrix),
                [i, r] = n,
                s = e ? r : this.height - r;
              return 2 === t.length ? [i, s] : [i, s, n[2]];
            }
            unproject(t, { topLeft: e = !0, targetZ: n } = {}) {
              const [i, r, s] = t,
                o = e ? r : this.height - r,
                a = n && n * this.distanceScales.unitsPerMeter[2],
                c = xs([i, o, s], this.pixelUnprojectionMatrix, a),
                [l, h, u] = this.unprojectPosition(c);
              return Number.isFinite(s)
                ? [l, h, u]
                : Number.isFinite(n)
                ? [l, h, n]
                : [l, h];
            }
            projectPosition(t) {
              const [e, n] = fs(t);
              return [e, n, (t[2] || 0) * this.distanceScales.unitsPerMeter[2]];
            }
            unprojectPosition(t) {
              const [e, n] = ps(t);
              return [e, n, (t[2] || 0) * this.distanceScales.metersPerUnit[2]];
            }
            projectFlat(t) {
              return fs(t);
            }
            unprojectFlat(t) {
              return ps(t);
            }
            getMapCenterByLngLatPosition({ lngLat: t, pos: e }) {
              const n = xs(e, this.pixelUnprojectionMatrix),
                i = Zr([], fs(t), Kr([], n));
              return ps(Zr([], this.center, i));
            }
            getLocationAtPoint({ lngLat: t, pos: e }) {
              return this.getMapCenterByLngLatPosition({ lngLat: t, pos: e });
            }
            fitBounds(t, e = {}) {
              const { width: n, height: i } = this,
                {
                  longitude: r,
                  latitude: s,
                  zoom: o,
                } = Ps(Object.assign({ width: n, height: i, bounds: t }, e));
              return new Ss({
                width: n,
                height: i,
                longitude: r,
                latitude: s,
                zoom: o,
              });
            }
            getBounds(t) {
              const e = this.getBoundingRegion(t),
                n = Math.min(...e.map((t) => t[0])),
                i = Math.max(...e.map((t) => t[0]));
              return [
                [n, Math.min(...e.map((t) => t[1]))],
                [i, Math.max(...e.map((t) => t[1]))],
              ];
            }
            getBoundingRegion(t = {}) {
              return As(this, t.z || 0);
            }
          }
          const Ms = Math.PI / 180,
            Cs = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            Ls = [0, 0, 0],
            Os = { unitsPerMeter: [1, 1, 1], metersPerUnit: [1, 1, 1] };
          class Is {
            constructor(t = {}) {
              const {
                id: e = null,
                x: n = 0,
                y: i = 0,
                width: r = 1,
                height: s = 1,
              } = t;
              (this.id = e || this.constructor.displayName || "viewport"),
                (this.x = n),
                (this.y = i),
                (this.width = r || 1),
                (this.height = s || 1),
                (this._frustumPlanes = {}),
                this._initViewMatrix(t),
                this._initProjectionMatrix(t),
                this._initPixelMatrices(),
                (this.equals = this.equals.bind(this)),
                (this.project = this.project.bind(this)),
                (this.unproject = this.unproject.bind(this)),
                (this.projectPosition = this.projectPosition.bind(this)),
                (this.unprojectPosition = this.unprojectPosition.bind(this)),
                (this.projectFlat = this.projectFlat.bind(this)),
                (this.unprojectFlat = this.unprojectFlat.bind(this));
            }
            get metersPerPixel() {
              return this.distanceScales.metersPerUnit[2] / this.scale;
            }
            get projectionMode() {
              return this.isGeospatial
                ? this.zoom < 12
                  ? T.WEB_MERCATOR
                  : T.WEB_MERCATOR_AUTO_OFFSET
                : T.IDENTITY;
            }
            equals(t) {
              return (
                t instanceof Is &&
                (this === t ||
                  (t.width === this.width &&
                    t.height === this.height &&
                    t.scale === this.scale &&
                    Le(t.projectionMatrix, this.projectionMatrix) &&
                    Le(t.viewMatrix, this.viewMatrix)))
              );
            }
            project(t, { topLeft: e = !0 } = {}) {
              const n = ws(this.projectPosition(t), this.pixelProjectionMatrix),
                [i, r] = n,
                s = e ? r : this.height - r;
              return 2 === t.length ? [i, s] : [i, s, n[2]];
            }
            unproject(t, { topLeft: e = !0, targetZ: n } = {}) {
              const [i, r, s] = t,
                o = e ? r : this.height - r,
                a = n && n * this.distanceScales.unitsPerMeter[2],
                c = xs([i, o, s], this.pixelUnprojectionMatrix, a),
                [l, h, u] = this.unprojectPosition(c);
              return Number.isFinite(s)
                ? [l, h, u]
                : Number.isFinite(n)
                ? [l, h, n]
                : [l, h];
            }
            projectPosition(t) {
              const [e, n] = this.projectFlat(t);
              return [e, n, (t[2] || 0) * this.distanceScales.unitsPerMeter[2]];
            }
            unprojectPosition(t) {
              const [e, n] = this.unprojectFlat(t);
              return [e, n, (t[2] || 0) * this.distanceScales.metersPerUnit[2]];
            }
            projectFlat(t) {
              return this.isGeospatial ? fs(t) : t;
            }
            unprojectFlat(t) {
              return this.isGeospatial ? ps(t) : t;
            }
            getBounds(t = {}) {
              const e = { targetZ: t.z || 0 },
                n = this.unproject([0, 0], e),
                i = this.unproject([this.width, 0], e),
                r = this.unproject([0, this.height], e),
                s = this.unproject([this.width, this.height], e);
              return [
                Math.min(n[0], i[0], r[0], s[0]),
                Math.min(n[1], i[1], r[1], s[1]),
                Math.max(n[0], i[0], r[0], s[0]),
                Math.max(n[1], i[1], r[1], s[1]),
              ];
            }
            getDistanceScales(t = null) {
              return t
                ? gs({ longitude: t[0], latitude: t[1], highPrecision: !0 })
                : this.distanceScales;
            }
            containsPixel({ x: t, y: e, width: n = 1, height: i = 1 }) {
              return (
                t < this.x + this.width &&
                this.x < t + n &&
                e < this.y + this.height &&
                this.y < e + i
              );
            }
            getFrustumPlanes() {
              return (
                this._frustumPlanes.near ||
                  Object.assign(
                    this._frustumPlanes,
                    (function (t) {
                      const e = {};
                      return (
                        (e.left = Xe(
                          t[3] + t[0],
                          t[7] + t[4],
                          t[11] + t[8],
                          t[15] + t[12]
                        )),
                        (e.right = Xe(
                          t[3] - t[0],
                          t[7] - t[4],
                          t[11] - t[8],
                          t[15] - t[12]
                        )),
                        (e.bottom = Xe(
                          t[3] + t[1],
                          t[7] + t[5],
                          t[11] + t[9],
                          t[15] + t[13]
                        )),
                        (e.top = Xe(
                          t[3] - t[1],
                          t[7] - t[5],
                          t[11] - t[9],
                          t[15] - t[13]
                        )),
                        (e.near = Xe(
                          t[3] + t[2],
                          t[7] + t[6],
                          t[11] + t[10],
                          t[15] + t[14]
                        )),
                        (e.far = Xe(
                          t[3] - t[2],
                          t[7] - t[6],
                          t[11] - t[10],
                          t[15] - t[14]
                        )),
                        e
                      );
                    })(this.viewProjectionMatrix)
                  ),
                this._frustumPlanes
              );
            }
            panByPosition(t, e) {
              return null;
            }
            getCameraPosition() {
              return this.cameraPosition;
            }
            getCameraDirection() {
              return this.cameraDirection;
            }
            getCameraUp() {
              return this.cameraUp;
            }
            _createProjectionMatrix({
              orthographic: t,
              fovyRadians: e,
              aspect: n,
              focalDistance: i,
              near: r,
              far: s,
            }) {
              return t
                ? new is().orthographic({
                    fovy: e,
                    aspect: n,
                    focalDistance: i,
                    near: r,
                    far: s,
                  })
                : new is().perspective({ fovy: e, aspect: n, near: r, far: s });
            }
            _initViewMatrix(t) {
              const {
                viewMatrix: e = Cs,
                longitude: n = null,
                latitude: i = null,
                zoom: r = null,
                position: s = null,
                modelMatrix: o = null,
                focalDistance: a = 1,
                distanceScales: c = null,
              } = t;
              (this.isGeospatial = Number.isFinite(i) && Number.isFinite(n)),
                (this.zoom = r),
                Number.isFinite(this.zoom) ||
                  (this.zoom = this.isGeospatial
                    ? (function ({ latitude: t }) {
                        as(Number.isFinite(t));
                        const e = Math.cos(t * hs);
                        return os(4003e4 * e) - 9;
                      })({ latitude: i }) + Math.log2(a)
                    : 0);
              const l = Math.pow(2, this.zoom);
              (this.scale = l),
                (this.distanceScales = this.isGeospatial
                  ? gs({ latitude: i, longitude: n })
                  : c || Os),
                (this.focalDistance = a),
                (this.distanceScales.metersPerUnit = new He(
                  this.distanceScales.metersPerUnit
                )),
                (this.distanceScales.unitsPerMeter = new He(
                  this.distanceScales.unitsPerMeter
                )),
                (this.position = Ls),
                (this.meterOffset = Ls),
                s &&
                  ((this.position = s),
                  (this.modelMatrix = o),
                  (this.meterOffset = o ? o.transformVector(s) : s)),
                this.isGeospatial
                  ? ((this.longitude = n),
                    (this.latitude = i),
                    (this.center = this._getCenterInWorld({
                      longitude: n,
                      latitude: i,
                    })))
                  : (this.center = s ? this.projectPosition(s) : [0, 0, 0]),
                (this.viewMatrixUncentered = e),
                (this.viewMatrix = new is()
                  .multiplyRight(this.viewMatrixUncentered)
                  .translate(new He(this.center || Ls).negate()));
            }
            _getCenterInWorld({ longitude: t, latitude: e }) {
              const { meterOffset: n, distanceScales: i } = this,
                r = new He(this.projectPosition([t, e, 0]));
              if (n) {
                const t = new He(n).scale(i.unitsPerMeter);
                r.add(t);
              }
              return r;
            }
            _initProjectionMatrix(t) {
              const {
                projectionMatrix: e = null,
                orthographic: n = !1,
                fovyRadians: i,
                fovy: r = 75,
                near: s = 0.1,
                far: o = 1e3,
                focalDistance: a = 1,
              } = t;
              this.projectionMatrix =
                e ||
                this._createProjectionMatrix({
                  orthographic: n,
                  fovyRadians: i || r * Ms,
                  aspect: this.width / this.height,
                  focalDistance: a,
                  near: s,
                  far: o,
                });
            }
            _initPixelMatrices() {
              const t = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              var e;
              kr(t, t, this.projectionMatrix),
                kr(t, t, this.viewMatrix),
                (this.viewProjectionMatrix = t),
                (this.viewMatrixInverse =
                  Rr([], this.viewMatrix) || this.viewMatrix),
                (this.cameraPosition = [
                  (e = this.viewMatrixInverse)[12],
                  e[13],
                  e[14],
                ]);
              const n = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                i = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
              zr(n, n, [this.width / 2, -this.height / 2, 1]),
                Fr(n, n, [1, -1, 0]),
                kr(i, n, this.viewProjectionMatrix),
                (this.pixelProjectionMatrix = i),
                (this.viewportMatrix = n),
                (this.pixelUnprojectionMatrix = Rr(
                  [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                  this.pixelProjectionMatrix
                )),
                this.pixelUnprojectionMatrix ||
                  E.warn("Pixel project matrix not invertible")();
            }
          }
          Is.displayName = "Viewport";
          const Rs = Math.PI / 180;
          function ks(t) {
            return 512 / 4003e4 / Math.cos(t * Rs);
          }
          class Fs extends Is {
            constructor(t = {}) {
              const {
                latitude: e = 0,
                longitude: n = 0,
                zoom: i = 11,
                pitch: r = 0,
                bearing: s = 0,
                nearZMultiplier: o = 0.1,
                farZMultiplier: a = 1.01,
                orthographic: c = !1,
                projectionMatrix: l,
                repeat: h = !1,
                worldOffset: u = 0,
                legacyMeterSizes: d = !1,
              } = t;
              let { width: f, height: p, altitude: g = 1.5 } = t;
              const m = Math.pow(2, i);
              let y;
              (f = f || 1), (p = p || 1);
              let _ = null;
              l
                ? ((g = l[5] / 2), (y = vs(g)))
                : (t.fovy ? ((y = t.fovy), (g = bs(y))) : (y = vs(g)),
                  (_ = _s({
                    width: f,
                    height: p,
                    pitch: r,
                    fovy: y,
                    nearZMultiplier: o,
                    farZMultiplier: a,
                  })));
              let v = ys({
                height: p,
                pitch: r,
                bearing: s,
                scale: m,
                altitude: g,
              });
              u && (v = new is().translate([512 * u, 0, 0]).multiplyLeft(v)),
                super({
                  ...t,
                  width: f,
                  height: p,
                  viewMatrix: v,
                  longitude: n,
                  latitude: e,
                  zoom: i,
                  ..._,
                  fovy: y,
                  focalDistance: g,
                }),
                (this.latitude = e),
                (this.longitude = n),
                (this.zoom = i),
                (this.pitch = r),
                (this.bearing = s),
                (this.altitude = g),
                (this.fovy = y),
                (this.orthographic = c),
                (this._subViewports = h ? [] : null),
                (this._pseudoMeters = d),
                Object.freeze(this);
            }
            get subViewports() {
              if (this._subViewports && !this._subViewports.length) {
                const t = this.getBounds(),
                  e = Math.floor((t[0] + 180) / 360),
                  n = Math.ceil((t[2] - 180) / 360);
                for (let t = e; t <= n; t++) {
                  const e = t ? new Fs({ ...this, worldOffset: t }) : this;
                  this._subViewports.push(e);
                }
              }
              return this._subViewports;
            }
            projectPosition(t) {
              if (this._pseudoMeters) return super.projectPosition(t);
              const [e, n] = this.projectFlat(t);
              return [e, n, (t[2] || 0) * ks(t[1])];
            }
            unprojectPosition(t) {
              if (this._pseudoMeters) return super.unprojectPosition(t);
              const [e, n] = this.unprojectFlat(t);
              return [e, n, (t[2] || 0) / ks(n)];
            }
            addMetersToLngLat(t, e) {
              return ms(t, e);
            }
            panByPosition(t, e) {
              const n = xs(e, this.pixelUnprojectionMatrix),
                i = Zr([], this.projectFlat(t), Kr([], n)),
                r = Zr([], this.center, i),
                [s, o] = this.unprojectFlat(r);
              return { longitude: s, latitude: o };
            }
            getBounds(t = {}) {
              const e = As(this, t.z || 0);
              return [
                Math.min(e[0][0], e[1][0], e[2][0], e[3][0]),
                Math.min(e[0][1], e[1][1], e[2][1], e[3][1]),
                Math.max(e[0][0], e[1][0], e[2][0], e[3][0]),
                Math.max(e[0][1], e[1][1], e[2][1], e[3][1]),
              ];
            }
            fitBounds(t, e = {}) {
              const { width: n, height: i } = this,
                {
                  longitude: r,
                  latitude: s,
                  zoom: o,
                } = Ps({ width: n, height: i, bounds: t, ...e });
              return new Fs({
                width: n,
                height: i,
                longitude: r,
                latitude: s,
                zoom: o,
              });
            }
          }
          function zs(t, e, n = !1) {
            const i = e.projectPosition(t);
            if (n && e instanceof Fs) {
              const [n, r, s = 0] = t,
                o = e.getDistanceScales([n, r]);
              i[2] = s * o.unitsPerMeter[2];
            }
            return i;
          }
          function js(
            t,
            {
              viewport: e,
              modelMatrix: n,
              coordinateSystem: i,
              coordinateOrigin: r,
              offsetMode: s,
            }
          ) {
            let [o, a, c = 0] = t;
            switch ((n && ([o, a, c] = Ur([], [o, a, c, 1], n)), i)) {
              case A.LNGLAT:
                return zs([o, a, c], e, s);
              case A.LNGLAT_OFFSETS:
                return zs([o + r[0], a + r[1], c + (r[2] || 0)], e, s);
              case A.METER_OFFSETS:
                return zs(ms(r, [o, a, c]), e, s);
              default:
                return e.isGeospatial
                  ? [o + r[0], a + r[1], c + r[2]]
                  : e.projectPosition([o, a, c]);
            }
          }
          Fs.displayName = "WebMercatorViewport";
          const Bs = { 10241: 9987, 10240: 9729, 10242: 33071, 10243: 33071 },
            Ds = {},
            Ns = {
              boolean: {
                validate: (t, e) => !0,
                equal: (t, e, n) => Boolean(t) === Boolean(e),
              },
              number: {
                validate: (t, e) =>
                  Number.isFinite(t) &&
                  (!("max" in e) || t <= e.max) &&
                  (!("min" in e) || t >= e.min),
              },
              color: {
                validate: (t, e) =>
                  (e.optional && !t) ||
                  (Ws(t) && (3 === t.length || 4 === t.length)),
                equal: (t, e, n) => Us(t, e),
              },
              accessor: {
                validate(t, e) {
                  const n = Hs(t);
                  return "function" === n || n === Hs(e.value);
                },
                equal: (t, e, n) => "function" == typeof e || Us(t, e),
              },
              array: {
                validate: (t, e) => (e.optional && !t) || Ws(t),
                equal: (t, e, n) => (n.compare ? Us(t, e) : t === e),
              },
              function: {
                validate: (t, e) =>
                  (e.optional && !t) || "function" == typeof t,
                equal: (t, e, n) => !n.compare || t === e,
              },
              data: {
                transform: (t, e, n) => {
                  const { dataTransform: i } = n ? n.props : {};
                  return i && t ? i(t) : t;
                },
              },
              image: {
                transform: (t, e, n) =>
                  (function (t, e) {
                    const n = t.context && t.context.gl;
                    if (!n || !e) return null;
                    if (e instanceof ne) return e;
                    e.constructor &&
                      "Object" !== e.constructor.name &&
                      (e = { data: e });
                    let i = null;
                    e.compressed &&
                      (i = { 10241: e.data.length > 1 ? 9985 : 9729 });
                    const r = new ne(n, {
                      ...e,
                      parameters: { ...Bs, ...i, ...t.props.textureParameters },
                    });
                    return (Ds[r.id] = !0), r;
                  })(n, t),
                release: (t) => {
                  var e;
                  (e = t) &&
                    e instanceof ne &&
                    Ds[e.id] &&
                    (e.delete(), delete Ds[e.id]);
                },
              },
            };
          function Us(t, e) {
            if (t === e) return !0;
            if (!Ws(t) || !Ws(e)) return !1;
            const n = t.length;
            if (n !== e.length) return !1;
            for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1;
            return !0;
          }
          function Vs(t, e) {
            switch (Hs(e)) {
              case "object":
                return Gs(t, e);
              case "array":
                return Gs(t, { type: "array", value: e, compare: !1 });
              case "boolean":
                return Gs(t, { type: "boolean", value: e });
              case "number":
                return Gs(t, { type: "number", value: e });
              case "function":
                return Gs(t, { type: "function", value: e, compare: !0 });
              default:
                return { name: t, type: "unknown", value: e };
            }
          }
          function Gs(t, e) {
            return "type" in e
              ? { name: t, ...Ns[e.type], ...e }
              : "value" in e
              ? { name: t, type: Hs(e.value), ...e }
              : { name: t, type: "object", value: e };
          }
          function Ws(t) {
            return Array.isArray(t) || ArrayBuffer.isView(t);
          }
          function Hs(t) {
            return Ws(t) ? "array" : null === t ? "null" : typeof t;
          }
          const {
            COMPONENT: $s,
            ASYNC_ORIGINAL: Xs,
            ASYNC_RESOLVED: Ys,
            ASYNC_DEFAULTS: qs,
          } = xr;
          function Zs() {
            const t = this,
              e = Ks(t.constructor),
              n = Object.create(e);
            (n[$s] = t), (n[Xs] = {}), (n[Ys] = {});
            for (let t = 0; t < arguments.length; ++t) {
              const e = arguments[t];
              for (const t in e) n[t] = e[t];
            }
            return Object.freeze(n), n;
          }
          function Ks(t) {
            return (
              to(t, "_mergedDefaultProps") ||
              ((function (t) {
                if (!t.prototype) return;
                const e = Object.getPrototypeOf(t),
                  n = Ks(e),
                  i = (function (t) {
                    const e = {},
                      n = {},
                      i = {};
                    for (const [r, s] of Object.entries(t))
                      if (s && s.deprecatedFor)
                        i[r] = Array.isArray(s.deprecatedFor)
                          ? s.deprecatedFor
                          : [s.deprecatedFor];
                      else {
                        const t = Vs(r, s);
                        (e[r] = t), (n[r] = t.value);
                      }
                    return {
                      propTypes: e,
                      defaultProps: n,
                      deprecatedProps: i,
                    };
                  })(to(t, "defaultProps") || {}),
                  r = (function (t, e, n) {
                    const i = Object.create(null);
                    Object.assign(i, e, t);
                    const r = (function (t) {
                      const e = to(t, "layerName") || to(t, "componentName");
                      return (
                        e ||
                          E.once(
                            0,
                            "".concat(t.name, ".componentName not specified")
                          )(),
                        e || t.name
                      );
                    })(n);
                    return (
                      delete t.id,
                      Object.defineProperties(i, {
                        id: { writable: !0, value: r },
                      }),
                      i
                    );
                  })(i.defaultProps, n, t),
                  s = { ...e._propTypes, ...i.propTypes };
                !(function (t, e) {
                  const n = {},
                    i = {};
                  for (const t in e) {
                    const r = e[t],
                      { name: s, value: o } = r;
                    r.async && ((n[s] = o), (i[s] = Js(s)));
                  }
                  (t[qs] = n), (t[Xs] = {}), Object.defineProperties(t, i);
                })(r, s);
                const o = { ...e._deprecatedProps, ...i.deprecatedProps };
                (function (t, e) {
                  for (const n in e)
                    Object.defineProperty(t, n, {
                      enumerable: !1,
                      set(t) {
                        const i = "".concat(this.id, ": ").concat(n);
                        for (const i of e[n]) Qs(this, i) || (this[i] = t);
                        E.deprecated(i, e[n].join("/"))();
                      },
                    });
                })(r, o),
                  (t._mergedDefaultProps = r),
                  (t._propTypes = s),
                  (t._deprecatedProps = o);
              })(t),
              t._mergedDefaultProps)
            );
          }
          function Js(t) {
            return {
              enumerable: !0,
              set(e) {
                "string" == typeof e || e instanceof Promise || nn(e)
                  ? (this[Xs][t] = e)
                  : (this[Ys][t] = e);
              },
              get() {
                if (this[Ys]) {
                  if (t in this[Ys]) return this[Ys][t] || this[qs][t];
                  if (t in this[Xs]) {
                    const e = this[$s] && this[$s].internalState;
                    if (e && e.hasAsyncProp(t))
                      return e.getAsyncProp(t) || this[qs][t];
                  }
                }
                return this[qs][t];
              },
            };
          }
          function Qs(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
          }
          function to(t, e) {
            return Qs(t, e) && t[e];
          }
          const {
              ASYNC_ORIGINAL: eo,
              ASYNC_RESOLVED: no,
              ASYNC_DEFAULTS: io,
            } = xr,
            ro = Object.freeze({});
          class so {
            constructor(t = null) {
              (this.component = t),
                (this.asyncProps = {}),
                (this.onAsyncPropUpdated = () => {}),
                (this.oldProps = ro),
                (this.oldAsyncProps = null);
            }
            finalize() {
              for (const t in this.asyncProps) {
                const e = this.asyncProps[t];
                e.type &&
                  e.type.release &&
                  e.type.release(e.resolvedValue, e.type, this.component);
              }
            }
            getOldProps() {
              return this.oldAsyncProps || this.oldProps;
            }
            resetOldProps() {
              (this.oldAsyncProps = null),
                (this.oldProps = this.component.props);
            }
            freezeAsyncOldProps() {
              if (!this.oldAsyncProps) {
                (this.oldProps = this.oldProps || this.component.props),
                  (this.oldAsyncProps = Object.create(this.oldProps));
                for (const t in this.asyncProps)
                  Object.defineProperty(this.oldAsyncProps, t, {
                    enumerable: !0,
                    value: this.oldProps[t],
                  });
              }
            }
            hasAsyncProp(t) {
              return t in this.asyncProps;
            }
            getAsyncProp(t) {
              const e = this.asyncProps[t];
              return e && e.resolvedValue;
            }
            isAsyncPropLoading(t) {
              if (t) {
                const e = this.asyncProps[t];
                return Boolean(
                  e &&
                    e.pendingLoadCount > 0 &&
                    e.pendingLoadCount !== e.resolvedLoadCount
                );
              }
              for (const t in this.asyncProps)
                if (this.isAsyncPropLoading(t)) return !0;
              return !1;
            }
            reloadAsyncProp(t, e) {
              this._watchPromise(t, Promise.resolve(e));
            }
            setAsyncProps(t) {
              const e = t[no] || {},
                n = t[eo] || t,
                i = t[io] || {};
              for (const t in e) {
                const n = e[t];
                this._createAsyncPropData(t, i[t]),
                  this._updateAsyncProp(t, n),
                  (e[t] = this.getAsyncProp(t));
              }
              for (const t in n) {
                const e = n[t];
                this._createAsyncPropData(t, i[t]), this._updateAsyncProp(t, e);
              }
            }
            _updateAsyncProp(t, e) {
              if (this._didAsyncInputValueChange(t, e)) {
                if ("string" == typeof e) {
                  var n;
                  const i =
                      null === (n = this.layer) || void 0 === n
                        ? void 0
                        : n.props.fetch,
                    r = e;
                  i && (e = i(r, { propName: t, layer: this.layer }));
                }
                e instanceof Promise
                  ? this._watchPromise(t, e)
                  : nn(e)
                  ? this._resolveAsyncIterable(t, e)
                  : this._setPropValue(t, e);
              }
            }
            _didAsyncInputValueChange(t, e) {
              const n = this.asyncProps[t];
              return (
                e !== n.resolvedValue &&
                e !== n.lastValue &&
                ((n.lastValue = e), !0)
              );
            }
            _setPropValue(t, e) {
              this.freezeAsyncOldProps();
              const n = this.asyncProps[t];
              (e = this._postProcessValue(n, e)),
                (n.resolvedValue = e),
                n.pendingLoadCount++,
                (n.resolvedLoadCount = n.pendingLoadCount);
            }
            _setAsyncPropValue(t, e, n) {
              const i = this.asyncProps[t];
              i &&
                n >= i.resolvedLoadCount &&
                void 0 !== e &&
                (this.freezeAsyncOldProps(),
                (i.resolvedValue = e),
                (i.resolvedLoadCount = n),
                this.onAsyncPropUpdated(t, e));
            }
            _watchPromise(t, e) {
              const n = this.asyncProps[t];
              n.pendingLoadCount++;
              const i = n.pendingLoadCount;
              e.then((e) => {
                var r;
                (e = this._postProcessValue(n, e)),
                  this._setAsyncPropValue(t, e, i);
                const s =
                  null === (r = this.layer) || void 0 === r
                    ? void 0
                    : r.props.onDataLoad;
                "data" === t && s && s(e, { propName: t, layer: this.layer });
              }).catch((e) => {
                var n;
                null === (n = this.layer) ||
                  void 0 === n ||
                  n.raiseError(
                    e,
                    "loading ".concat(t, " of ").concat(this.layer)
                  );
              });
            }
            async _resolveAsyncIterable(t, e) {
              var n;
              "data" !== t && this._setPropValue(t, e);
              const i = this.asyncProps[t];
              i.pendingLoadCount++;
              const r = i.pendingLoadCount;
              let s = [],
                o = 0;
              for await (const n of e) {
                const { dataTransform: e } = this.component
                  ? this.component.props
                  : {};
                (s = e ? e(n, s) : s.concat(n)),
                  Object.defineProperty(s, "__diff", {
                    enumerable: !1,
                    value: [{ startRow: o, endRow: s.length }],
                  }),
                  (o = s.length),
                  this._setAsyncPropValue(t, s, r);
              }
              const a =
                null === (n = this.layer) || void 0 === n
                  ? void 0
                  : n.props.onDataLoad;
              a && a(s, { propName: t, layer: this.layer });
            }
            _postProcessValue(t, e) {
              const n = t.type;
              return n &&
                (n.release && n.release(t.resolvedValue, n, this.component),
                n.transform)
                ? n.transform(e, n, this.component)
                : e;
            }
            _createAsyncPropData(t, e) {
              if (!this.asyncProps[t]) {
                const n =
                  this.component && this.component.constructor._propTypes;
                this.asyncProps[t] = {
                  type: n && n[t],
                  lastValue: null,
                  resolvedValue: e,
                  pendingLoadCount: 0,
                  resolvedLoadCount: 0,
                };
              }
            }
          }
          const {
            ASYNC_ORIGINAL: oo,
            ASYNC_RESOLVED: ao,
            ASYNC_DEFAULTS: co,
          } = xr;
          let lo = 0;
          class ho {
            constructor() {
              (this.props = Zs.apply(this, arguments)),
                (this.id = this.props.id),
                (this.count = lo++),
                (this.lifecycle = "Awaiting state"),
                (this.parent = null),
                (this.context = null),
                (this.state = null),
                (this.internalState = null),
                Object.seal(this);
            }
            get root() {
              let t = this;
              for (; t.parent; ) t = t.parent;
              return t;
            }
            clone(t) {
              const { props: e } = this,
                n = {};
              for (const t in e[co])
                t in e[ao]
                  ? (n[t] = e[ao][t])
                  : t in e[oo] && (n[t] = e[oo][t]);
              return new this.constructor({ ...e, ...n, ...t });
            }
            get stats() {
              return this.internalState.stats;
            }
            _initState() {
              this.internalState = new so({});
            }
          }
          (ho.componentName = "Component"), (ho.defaultProps = {});
          class uo extends so {
            constructor({ attributeManager: t, layer: e }) {
              super(e),
                (this.attributeManager = t),
                (this.model = null),
                (this.needsRedraw = !0),
                (this.subLayers = null),
                (this.usesPickingColorCache = !1);
            }
            get layer() {
              return this.component;
            }
            set layer(t) {
              this.component = t;
            }
          }
          const fo = (t) => "function" == typeof t,
            po = (t) => null !== t && "object" == typeof t,
            go = (t) => po(t) && t.constructor === {}.constructor,
            mo = (t) =>
              ("undefined" != typeof Response && t instanceof Response) ||
              (t && t.arrayBuffer && t.text && t.json),
            yo = (t) => "undefined" != typeof Blob && t instanceof Blob,
            _o = (t) =>
              ((t) =>
                ("undefined" != typeof ReadableStream &&
                  t instanceof ReadableStream) ||
                (po(t) && fo(t.tee) && fo(t.cancel) && fo(t.getReader)))(t) ||
              ((t) =>
                po(t) &&
                fo(t.read) &&
                fo(t.pipe) &&
                ((t) => "boolean" == typeof t)(t.readable))(t);
          function vo(t, e) {
            if (!t) throw new Error(e || "loader assertion failed.");
          }
          function bo(t) {
            var e;
            return (
              !!t &&
              (Array.isArray(t) && (t = t[0]),
              Array.isArray(
                null === (e = t) || void 0 === e ? void 0 : e.extensions
              ))
            );
          }
          function wo(t) {
            var e, n;
            let i;
            return (
              vo(t, "null loader"),
              vo(bo(t), "invalid loader"),
              Array.isArray(t) &&
                ((i = t[1]),
                (t = t[0]),
                (t = { ...t, options: { ...t.options, ...i } })),
              ((null !== (e = t) && void 0 !== e && e.parseTextSync) ||
                (null !== (n = t) && void 0 !== n && n.parseText)) &&
                (t.text = !0),
              t.text || (t.binary = !0),
              t
            );
          }
          const xo = {
              self: "undefined" != typeof self && self,
              window: "undefined" != typeof window && window,
              global: void 0 !== n.g && n.g,
              document: "undefined" != typeof document && document,
            },
            Po = xo.global || xo.self || xo.window || {},
            Eo =
              "object" != typeof process ||
              "[object process]" !== String(process) ||
              process.browser,
            Ao =
              "undefined" != typeof process &&
              process.version &&
              /v([0-9]*)/.exec(process.version);
          Ao && parseFloat(Ao[1]);
          const To = {},
            So = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
            Mo = /^([-\w.]+\/[-\w.+]+)/;
          function Co(t) {
            const e = Mo.exec(t);
            return e ? e[1] : t;
          }
          function Lo(t) {
            const e = So.exec(t);
            return e ? e[1] : "";
          }
          const Oo = /\?.*/;
          function Io(t) {
            if (mo(t)) {
              const e = Ro(t.url || "");
              return {
                url: e,
                type: Co(t.headers.get("content-type") || "") || Lo(e),
              };
            }
            return yo(t)
              ? { url: Ro(t.name || ""), type: t.type || "" }
              : "string" == typeof t
              ? { url: Ro(t), type: Lo(t) }
              : { url: "", type: "" };
          }
          function Ro(t) {
            return t.replace(Oo, "");
          }
          async function ko(t) {
            if (mo(t)) return t;
            const e = {},
              n = (function (t) {
                return mo(t)
                  ? t.headers["content-length"] || -1
                  : yo(t)
                  ? t.size
                  : "string" == typeof t
                  ? t.length
                  : t instanceof ArrayBuffer || ArrayBuffer.isView(t)
                  ? t.byteLength
                  : -1;
              })(t);
            n >= 0 && (e["content-length"] = String(n));
            const { url: i, type: r } = Io(t);
            r && (e["content-type"] = r);
            const s = await (async function (t) {
              if ("string" == typeof t) return `data:,${t.slice(0, 5)}`;
              if (t instanceof Blob) {
                const e = t.slice(0, 5);
                return await new Promise((t) => {
                  const n = new FileReader();
                  (n.onload = (e) => {
                    var n;
                    return t(
                      null == e || null === (n = e.target) || void 0 === n
                        ? void 0
                        : n.result
                    );
                  }),
                    n.readAsDataURL(e);
                });
              }
              if (t instanceof ArrayBuffer) {
                const e = (function (t) {
                  let e = "";
                  const n = new Uint8Array(t);
                  for (let t = 0; t < n.byteLength; t++)
                    e += String.fromCharCode(n[t]);
                  return btoa(e);
                })(t.slice(0, 5));
                return `data:base64,${e}`;
              }
              return null;
            })(t);
            s && (e["x-first-bytes"] = s),
              "string" == typeof t && (t = new TextEncoder().encode(t));
            const o = new Response(t, { headers: e });
            return Object.defineProperty(o, "url", { value: i }), o;
          }
          async function Fo(t, e) {
            if ("string" == typeof t) {
              t = (function (t) {
                for (const e in To)
                  if (t.startsWith(e)) {
                    const n = To[e];
                    t = t.replace(e, n);
                  }
                return (
                  t.startsWith("http://") ||
                    t.startsWith("https://") ||
                    (t = `${t}`),
                  t
                );
              })(t);
              let n = e;
              return (
                null != e &&
                  e.fetch &&
                  "function" != typeof (null == e ? void 0 : e.fetch) &&
                  (n = e.fetch),
                await fetch(t, n)
              );
            }
            return await ko(t);
          }
          function zo(t, e, n) {
            return (
              e in t
                ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (t[e] = n),
              t
            );
          }
          const jo = new w({ id: "loaders.gl" });
          class Bo {
            log() {
              return () => {};
            }
            info() {
              return () => {};
            }
            warn() {
              return () => {};
            }
            error() {
              return () => {};
            }
          }
          const Do = {
              fetch: null,
              mimeType: void 0,
              nothrow: !1,
              log: new (class {
                constructor() {
                  zo(this, "console", void 0), (this.console = console);
                }
                log(...t) {
                  return this.console.log.bind(this.console, ...t);
                }
                info(...t) {
                  return this.console.info.bind(this.console, ...t);
                }
                warn(...t) {
                  return this.console.warn.bind(this.console, ...t);
                }
                error(...t) {
                  return this.console.error.bind(this.console, ...t);
                }
              })(),
              CDN: "https://unpkg.com/@loaders.gl",
              worker: !0,
              maxConcurrency: 3,
              maxMobileConcurrency: 1,
              reuseWorkers: !0,
              _workerType: "",
              limit: 0,
              _limitMB: 0,
              batchSize: "auto",
              batchDebounceMs: 0,
              metadata: !1,
              transforms: [],
            },
            No = {
              throws: "nothrow",
              dataType: "(no longer used)",
              uri: "baseUri",
              method: "fetch.method",
              headers: "fetch.headers",
              body: "fetch.body",
              mode: "fetch.mode",
              credentials: "fetch.credentials",
              cache: "fetch.cache",
              redirect: "fetch.redirect",
              referrer: "fetch.referrer",
              referrerPolicy: "fetch.referrerPolicy",
              integrity: "fetch.integrity",
              keepalive: "fetch.keepalive",
              signal: "fetch.signal",
            };
          function Uo() {
            Po.loaders = Po.loaders || {};
            const { loaders: t } = Po;
            return (t._state = t._state || {}), t._state;
          }
          const Vo = () => {
            const t = Uo();
            return (
              (t.globalOptions = t.globalOptions || { ...Do }), t.globalOptions
            );
          };
          function Go(t, e, n, i) {
            return (
              (n = n || []),
              (function (t, e) {
                Ho(t, null, Do, No, e);
                for (const n of e) {
                  const i = (t && t[n.id]) || {},
                    r = (n.options && n.options[n.id]) || {},
                    s =
                      (n.deprecatedOptions && n.deprecatedOptions[n.id]) || {};
                  Ho(i, n.id, r, s, e);
                }
              })(t, (n = Array.isArray(n) ? n : [n])),
              (function (t, e, n) {
                const i = { ...(t.options || {}) };
                return (
                  (function (t, e) {
                    e && !("baseUri" in t) && (t.baseUri = e);
                  })(i, n),
                  null === i.log && (i.log = new Bo()),
                  Xo(i, Vo()),
                  Xo(i, e),
                  i
                );
              })(e, t, i)
            );
          }
          function Wo(t, e) {
            const n = Vo(),
              i = t || n;
            return "function" == typeof i.fetch
              ? i.fetch
              : po(i.fetch)
              ? (t) => Fo(t, i)
              : null != e && e.fetch
              ? null == e
                ? void 0
                : e.fetch
              : Fo;
          }
          function Ho(t, e, n, i, r) {
            const s = e || "Top level",
              o = e ? `${e}.` : "";
            for (const a in t) {
              const c = !e && po(t[a]),
                l = "baseUri" === a && !e,
                h = "workerUrl" === a && e;
              if (!(a in n) && !l && !h)
                if (a in i)
                  jo.warn(
                    `${s} loader option '${o}${a}' no longer supported, use '${i[a]}'`
                  )();
                else if (!c) {
                  const t = $o(a, r);
                  jo.warn(
                    `${s} loader option '${o}${a}' not recognized. ${t}`
                  )();
                }
            }
          }
          function $o(t, e) {
            const n = t.toLowerCase();
            let i = "";
            for (const r of e)
              for (const e in r.options) {
                if (t === e) return `Did you mean '${r.id}.${e}'?`;
                const s = e.toLowerCase();
                (n.startsWith(s) || s.startsWith(n)) &&
                  (i = i || `Did you mean '${r.id}.${e}'?`);
              }
            return i;
          }
          function Xo(t, e) {
            for (const n in e)
              if (n in e) {
                const i = e[n];
                go(i) && go(t[n])
                  ? (t[n] = { ...t[n], ...e[n] })
                  : (t[n] = e[n]);
              }
          }
          function Yo(t, e) {
            if (!t) throw new Error(e || "loaders.gl assertion failed.");
          }
          "undefined" != typeof self && self,
            "undefined" != typeof window && window,
            void 0 !== n.g && n.g,
            "undefined" != typeof document && document,
            "object" != typeof process ||
              "[object process]" !== String(process) ||
              process.browser;
          const qo =
              "undefined" != typeof window && void 0 !== window.orientation,
            Zo =
              "undefined" != typeof process &&
              process.version &&
              /v([0-9]*)/.exec(process.version),
            Ko = (Zo && parseFloat(Zo[1]), new Map());
          function Jo(t) {
            const e = new Blob([t], { type: "application/javascript" });
            return URL.createObjectURL(e);
          }
          function Qo(t, e = !0, n) {
            const i = n || new Set();
            if (t)
              if (ta(t)) i.add(t);
              else if (ta(t.buffer)) i.add(t.buffer);
              else if (ArrayBuffer.isView(t));
              else if (e && "object" == typeof t)
                for (const n in t) Qo(t[n], e, i);
            return void 0 === n ? Array.from(i) : [];
          }
          function ta(t) {
            return (
              !!t &&
              (t instanceof ArrayBuffer ||
                ("undefined" != typeof MessagePort &&
                  t instanceof MessagePort) ||
                ("undefined" != typeof ImageBitmap &&
                  t instanceof ImageBitmap) ||
                ("undefined" != typeof OffscreenCanvas &&
                  t instanceof OffscreenCanvas))
            );
          }
          const ea = () => {};
          class na {
            static isSupported() {
              return "undefined" != typeof Worker;
            }
            constructor(t) {
              zo(this, "name", void 0),
                zo(this, "source", void 0),
                zo(this, "url", void 0),
                zo(this, "terminated", !1),
                zo(this, "worker", void 0),
                zo(this, "onMessage", void 0),
                zo(this, "onError", void 0),
                zo(this, "_loadableURL", "");
              const { name: e, source: n, url: i } = t;
              Yo(n || i),
                (this.name = e),
                (this.source = n),
                (this.url = i),
                (this.onMessage = ea),
                (this.onError = (t) => console.log(t)),
                (this.worker = this._createBrowserWorker());
            }
            destroy() {
              (this.onMessage = ea),
                (this.onError = ea),
                this.worker.terminate(),
                (this.terminated = !0);
            }
            get isRunning() {
              return Boolean(this.onMessage);
            }
            postMessage(t, e) {
              (e = e || Qo(t)), this.worker.postMessage(t, e);
            }
            _getErrorFromErrorEvent(t) {
              let e = "Failed to load ";
              return (
                (e += `worker ${this.name}. `),
                t.message && (e += `${t.message} in `),
                t.lineno && (e += `:${t.lineno}:${t.colno}`),
                new Error(e)
              );
            }
            _createBrowserWorker() {
              this._loadableURL = (function (t) {
                Yo((t.source && !t.url) || (!t.source && t.url));
                let e = Ko.get(t.source || t.url);
                return (
                  e ||
                    (t.url &&
                      ((e = (n = t.url).startsWith("http")
                        ? Jo(
                            `try {\n  importScripts('${n}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`
                          )
                        : n),
                      Ko.set(t.url, e)),
                    t.source && ((e = Jo(t.source)), Ko.set(t.source, e))),
                  Yo(e),
                  e
                );
                var n;
              })({ source: this.source, url: this.url });
              const t = new Worker(this._loadableURL, { name: this.name });
              return (
                (t.onmessage = (t) => {
                  t.data
                    ? this.onMessage(t.data)
                    : this.onError(new Error("No data received"));
                }),
                (t.onerror = (t) => {
                  this.onError(this._getErrorFromErrorEvent(t)),
                    (this.terminated = !0);
                }),
                (t.onmessageerror = (t) => console.error(t)),
                t
              );
            }
          }
          class ia {
            constructor(t, e) {
              zo(this, "name", void 0),
                zo(this, "workerThread", void 0),
                zo(this, "isRunning", void 0),
                zo(this, "result", void 0),
                zo(this, "_resolve", void 0),
                zo(this, "_reject", void 0),
                (this.name = t),
                (this.workerThread = e),
                (this.isRunning = !0),
                (this._resolve = () => {}),
                (this._reject = () => {}),
                (this.result = new Promise((t, e) => {
                  (this._resolve = t), (this._reject = e);
                }));
            }
            postMessage(t, e) {
              this.workerThread.postMessage({
                source: "loaders.gl",
                type: t,
                payload: e,
              });
            }
            done(t) {
              Yo(this.isRunning), (this.isRunning = !1), this._resolve(t);
            }
            error(t) {
              Yo(this.isRunning), (this.isRunning = !1), this._reject(t);
            }
          }
          class ra {
            constructor(t) {
              zo(this, "name", "unnamed"),
                zo(this, "source", void 0),
                zo(this, "url", void 0),
                zo(this, "maxConcurrency", 1),
                zo(this, "maxMobileConcurrency", 1),
                zo(this, "onDebug", () => {}),
                zo(this, "reuseWorkers", !0),
                zo(this, "props", {}),
                zo(this, "jobQueue", []),
                zo(this, "idleQueue", []),
                zo(this, "count", 0),
                zo(this, "isDestroyed", !1),
                (this.source = t.source),
                (this.url = t.url),
                this.setProps(t);
            }
            destroy() {
              this.idleQueue.forEach((t) => t.destroy()),
                (this.isDestroyed = !0);
            }
            setProps(t) {
              (this.props = { ...this.props, ...t }),
                void 0 !== t.name && (this.name = t.name),
                void 0 !== t.maxConcurrency &&
                  (this.maxConcurrency = t.maxConcurrency),
                void 0 !== t.maxMobileConcurrency &&
                  (this.maxMobileConcurrency = t.maxMobileConcurrency),
                void 0 !== t.reuseWorkers &&
                  (this.reuseWorkers = t.reuseWorkers),
                void 0 !== t.onDebug && (this.onDebug = t.onDebug);
            }
            async startJob(
              t,
              e = (t, e, n) => t.done(n),
              n = (t, e) => t.error(e)
            ) {
              const i = new Promise(
                (i) => (
                  this.jobQueue.push({
                    name: t,
                    onMessage: e,
                    onError: n,
                    onStart: i,
                  }),
                  this
                )
              );
              return this._startQueuedJob(), await i;
            }
            async _startQueuedJob() {
              if (!this.jobQueue.length) return;
              const t = this._getAvailableWorker();
              if (!t) return;
              const e = this.jobQueue.shift();
              if (e) {
                this.onDebug({
                  message: "Starting job",
                  name: e.name,
                  workerThread: t,
                  backlog: this.jobQueue.length,
                });
                const n = new ia(e.name, t);
                (t.onMessage = (t) => e.onMessage(n, t.type, t.payload)),
                  (t.onError = (t) => e.onError(n, t)),
                  e.onStart(n);
                try {
                  await n.result;
                } finally {
                  this.returnWorkerToQueue(t);
                }
              }
            }
            returnWorkerToQueue(t) {
              this.isDestroyed ||
              !this.reuseWorkers ||
              this.count > this._getMaxConcurrency()
                ? (t.destroy(), this.count--)
                : this.idleQueue.push(t),
                this.isDestroyed || this._startQueuedJob();
            }
            _getAvailableWorker() {
              if (this.idleQueue.length > 0)
                return this.idleQueue.shift() || null;
              if (this.count < this._getMaxConcurrency()) {
                this.count++;
                const t = `${this.name.toLowerCase()} (#${this.count} of ${
                  this.maxConcurrency
                })`;
                return new na({ name: t, source: this.source, url: this.url });
              }
              return null;
            }
            _getMaxConcurrency() {
              return qo ? this.maxMobileConcurrency : this.maxConcurrency;
            }
          }
          const sa = {
            maxConcurrency: 3,
            maxMobileConcurrency: 1,
            onDebug: () => {},
            reuseWorkers: !0,
          };
          class oa {
            static isSupported() {
              return na.isSupported();
            }
            static getWorkerFarm(t = {}) {
              return (
                (oa._workerFarm = oa._workerFarm || new oa({})),
                oa._workerFarm.setProps(t),
                oa._workerFarm
              );
            }
            constructor(t) {
              zo(this, "props", void 0),
                zo(this, "workerPools", new Map()),
                (this.props = { ...sa }),
                this.setProps(t),
                (this.workerPools = new Map());
            }
            destroy() {
              for (const t of this.workerPools.values()) t.destroy();
            }
            setProps(t) {
              this.props = { ...this.props, ...t };
              for (const t of this.workerPools.values())
                t.setProps(this._getWorkerPoolProps());
            }
            getWorkerPool(t) {
              const { name: e, source: n, url: i } = t;
              let r = this.workerPools.get(e);
              return (
                r ||
                  ((r = new ra({ name: e, source: n, url: i })),
                  r.setProps(this._getWorkerPoolProps()),
                  this.workerPools.set(e, r)),
                r
              );
            }
            _getWorkerPoolProps() {
              return {
                maxConcurrency: this.props.maxConcurrency,
                maxMobileConcurrency: this.props.maxMobileConcurrency,
                reuseWorkers: this.props.reuseWorkers,
                onDebug: this.props.onDebug,
              };
            }
          }
          async function aa(t, e, n, i, r) {
            const s = t.id,
              o = (function (t, e = {}) {
                const n = e[t.id] || {},
                  i = `${t.id}-worker.js`;
                let r = n.workerUrl;
                if (
                  ("test" === e._workerType &&
                    (r = `modules/${t.module}/dist/${i}`),
                  !r)
                ) {
                  let e = t.version;
                  "latest" === e && (e = "latest");
                  const n = e ? `@${e}` : "";
                  r = `https://unpkg.com/@loaders.gl/${t.module}${n}/dist/${i}`;
                }
                return Yo(r), r;
              })(t, n),
              a = oa.getWorkerFarm(n).getWorkerPool({ name: s, url: o });
            n = JSON.parse(JSON.stringify(n));
            const c = await a.startJob("process-on-worker", ca.bind(null, r));
            c.postMessage("process", { input: e, options: n });
            const l = await c.result;
            return await l.result;
          }
          async function ca(t, e, n, i) {
            switch (n) {
              case "done":
                e.done(i);
                break;
              case "error":
                e.error(i.error);
                break;
              case "process":
                const { id: r, input: s, options: o } = i;
                try {
                  const n = await t(s, o);
                  e.postMessage("done", { id: r, result: n });
                } catch (t) {
                  const n = t instanceof Error ? t.message : "unknown error";
                  e.postMessage("error", { id: r, error: n });
                }
                break;
              default:
                console.warn(`parse-with-worker unknown message ${n}`);
            }
          }
          zo(oa, "_workerFarm", void 0);
          var la = n(521);
          function ha(t) {
            var e;
            if (
              ((e = t) &&
                "object" == typeof e &&
                e.isBuffer &&
                (t = (function (t) {
                  return la.toArrayBuffer ? la.toArrayBuffer(t) : t;
                })(t)),
              t instanceof ArrayBuffer)
            )
              return t;
            if (ArrayBuffer.isView(t))
              return 0 === t.byteOffset && t.byteLength === t.buffer.byteLength
                ? t.buffer
                : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
            if ("string" == typeof t) {
              const e = t;
              return new TextEncoder().encode(e).buffer;
            }
            if (t && "object" == typeof t && t._toArrayBuffer)
              return t._toArrayBuffer();
            throw new Error("toArrayBuffer");
          }
          const ua = 262144;
          function da(t, e) {
            return Eo
              ? (async function* (t, e) {
                  const n = t.getReader();
                  let i;
                  try {
                    for (;;) {
                      const t = i || n.read();
                      null != e && e._streamReadAhead && (i = n.read());
                      const { done: r, value: s } = await t;
                      if (r) return;
                      yield ha(s);
                    }
                  } catch (t) {
                    n.releaseLock();
                  }
                })(t, e)
              : (async function* (t, e) {
                  for await (const e of t) yield ha(e);
                })(t);
          }
          const fa = "Cannot convert supplied data type";
          async function pa(t, e, n) {
            const i = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
            if ("string" == typeof t || i)
              return (function (t, e, n) {
                if (e.text && "string" == typeof t) return t;
                var i;
                if (
                  ((i = t) &&
                    "object" == typeof i &&
                    i.isBuffer &&
                    (t = t.buffer),
                  t instanceof ArrayBuffer)
                ) {
                  const n = t;
                  return e.text && !e.binary
                    ? new TextDecoder("utf8").decode(n)
                    : n;
                }
                if (ArrayBuffer.isView(t)) {
                  if (e.text && !e.binary)
                    return new TextDecoder("utf8").decode(t);
                  let n = t.buffer;
                  const i = t.byteLength || t.length;
                  return (
                    (0 === t.byteOffset && i === n.byteLength) ||
                      (n = n.slice(t.byteOffset, t.byteOffset + i)),
                    n
                  );
                }
                throw new Error(fa);
              })(t, e);
            if ((yo(t) && (t = await ko(t)), mo(t))) {
              const n = t;
              return (
                await (async function (t) {
                  if (!t.ok) {
                    const e = await (async function (t) {
                      let e = `Failed to fetch resource ${t.url} (${t.status}): `;
                      try {
                        const n = t.headers.get("Content-Type");
                        let i = t.statusText;
                        n.includes("application/json") &&
                          (i += ` ${await t.text()}`),
                          (e += i),
                          (e = e.length > 60 ? `${e.slice(60)}...` : e);
                      } catch (t) {}
                      return e;
                    })(t);
                    throw new Error(e);
                  }
                })(n),
                e.binary ? await n.arrayBuffer() : await n.text()
              );
            }
            if (
              (_o(t) &&
                (t = (function (t, e) {
                  if ("string" == typeof t)
                    return (function* (t, e) {
                      const n = (null == e ? void 0 : e.chunkSize) || 262144;
                      let i = 0;
                      const r = new TextEncoder();
                      for (; i < t.length; ) {
                        const e = Math.min(t.length - i, n),
                          s = t.slice(i, i + e);
                        (i += e), yield r.encode(s);
                      }
                    })(t, e);
                  if (t instanceof ArrayBuffer)
                    return (function* (t, e = {}) {
                      const { chunkSize: n = ua } = e;
                      let i = 0;
                      for (; i < t.byteLength; ) {
                        const e = Math.min(t.byteLength - i, n),
                          r = new ArrayBuffer(e),
                          s = new Uint8Array(t, i, e);
                        new Uint8Array(r).set(s), (i += e), yield r;
                      }
                    })(t, e);
                  if (yo(t))
                    return (async function* (t, e) {
                      const n = (null == e ? void 0 : e.chunkSize) || 1048576;
                      let i = 0;
                      for (; i < t.size; ) {
                        const e = i + n,
                          r = await t.slice(i, e).arrayBuffer();
                        (i = e), yield r;
                      }
                    })(t, e);
                  if (_o(t)) return da(t, e);
                  if (mo(t)) return da(t.body, e);
                  throw new Error("makeIterator");
                })(t, n)),
              ((r = t) && "function" == typeof r[Symbol.iterator]) ||
                ((t) => t && "function" == typeof t[Symbol.asyncIterator])(t))
            )
              return (async function (t) {
                const e = [];
                for await (const n of t) e.push(n);
                return (function (...t) {
                  const e = t.map((t) =>
                      t instanceof ArrayBuffer ? new Uint8Array(t) : t
                    ),
                    n = e.reduce((t, e) => t + e.byteLength, 0),
                    i = new Uint8Array(n);
                  let r = 0;
                  for (const t of e) i.set(t, r), (r += t.byteLength);
                  return i.buffer;
                })(...e);
              })(t);
            var r;
            throw new Error(fa);
          }
          const ga = () => {
              const t = Uo();
              return (
                (t.loaderRegistry = t.loaderRegistry || []), t.loaderRegistry
              );
            },
            ma = /\.([^.]+)$/;
          function ya(t, e = [], n, i) {
            if (!_a(t)) return null;
            if (e && !Array.isArray(e)) return wo(e);
            let r = [];
            e && (r = r.concat(e)),
              (null != n && n.ignoreRegisteredLoaders) || r.push(...ga()),
              (function (t) {
                for (const e of t) wo(e);
              })(r);
            const s = (function (t, e, n, i) {
              const { url: r, type: s } = Io(t),
                o = r || (null == i ? void 0 : i.url);
              let a = null;
              return (
                null != n &&
                  n.mimeType &&
                  (a = ba(e, null == n ? void 0 : n.mimeType)),
                (a =
                  a ||
                  (function (t, e) {
                    const n = e && ma.exec(e),
                      i = n && n[1];
                    return i
                      ? (function (t, e) {
                          e = e.toLowerCase();
                          for (const n of t)
                            for (const t of n.extensions)
                              if (t.toLowerCase() === e) return n;
                          return null;
                        })(t, i)
                      : null;
                  })(e, o)),
                (a = a || ba(e, s)),
                (a =
                  a ||
                  (function (t, e) {
                    if (!e) return null;
                    for (const n of t)
                      if ("string" == typeof e) {
                        if (wa(e, n)) return n;
                      } else if (ArrayBuffer.isView(e)) {
                        if (xa(e.buffer, e.byteOffset, n)) return n;
                      } else if (e instanceof ArrayBuffer && xa(e, 0, n))
                        return n;
                    return null;
                  })(e, t)),
                (a = a || ba(e, null == n ? void 0 : n.fallbackMimeType)),
                a
              );
            })(t, r, n, i);
            if (!(s || (null != n && n.nothrow))) throw new Error(va(t));
            return s;
          }
          function _a(t) {
            return !(t instanceof Response && 204 === t.status);
          }
          function va(t) {
            const { url: e, type: n } = Io(t);
            let i = "No valid loader found";
            return (
              t &&
                (i += ` data: "${(function (t, e = 5) {
                  return "string" == typeof t
                    ? t.slice(0, e)
                    : ArrayBuffer.isView(t)
                    ? Pa(t.buffer, t.byteOffset, e)
                    : t instanceof ArrayBuffer
                    ? Pa(t, 0, e)
                    : "";
                })(t)}", contentType: "${n}"`),
              e && (i += ` url: ${e}`),
              i
            );
          }
          function ba(t, e) {
            for (const n of t) {
              if (n.mimeTypes && n.mimeTypes.includes(e)) return n;
              if (e === `application/x.${n.id}`) return n;
            }
            return null;
          }
          function wa(t, e) {
            return e.testText
              ? e.testText(t)
              : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((e) =>
                  t.startsWith(e)
                );
          }
          function xa(t, e, n) {
            return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((i) =>
              (function (t, e, n, i) {
                if (i instanceof ArrayBuffer)
                  return (function (t, e, n) {
                    if (
                      ((n = n || t.byteLength),
                      t.byteLength < n || e.byteLength < n)
                    )
                      return !1;
                    const i = new Uint8Array(t),
                      r = new Uint8Array(e);
                    for (let t = 0; t < i.length; ++t)
                      if (i[t] !== r[t]) return !1;
                    return !0;
                  })(i, t, i.byteLength);
                switch (typeof i) {
                  case "function":
                    return i(t, n);
                  case "string":
                    return i === Pa(t, e, i.length);
                  default:
                    return !1;
                }
              })(t, e, n, i)
            );
          }
          function Pa(t, e, n) {
            if (t.byteLength < e + n) return "";
            const i = new DataView(t);
            let r = "";
            for (let t = 0; t < n; t++)
              r += String.fromCharCode(i.getUint8(e + t));
            return r;
          }
          async function Ea(t, e, n, i) {
            Yo(!i || "object" == typeof i),
              !e ||
                Array.isArray(e) ||
                bo(e) ||
                ((i = void 0), (n = e), (e = void 0)),
              (t = await t),
              (n = n || {});
            const { url: r } = Io(t),
              s = (function (t, e) {
                if (!e && t && !Array.isArray(t)) return t;
                let n;
                if ((t && (n = Array.isArray(t) ? t : [t]), e && e.loaders)) {
                  const t = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
                  n = n ? [...n, ...t] : t;
                }
                return n && n.length ? n : null;
              })(e, i),
              o = await (async function (t, e = [], n, i) {
                if (!_a(t)) return null;
                let r = ya(t, e, { ...n, nothrow: !0 }, i);
                if (r) return r;
                if (
                  (yo(t) &&
                    (r = ya((t = await t.slice(0, 10).arrayBuffer()), e, n, i)),
                  !(r || (null != n && n.nothrow)))
                )
                  throw new Error(va(t));
                return r;
              })(t, s, n);
            return o
              ? ((i = (function (t, e, n = null) {
                  if (n) return n;
                  const i = { fetch: Wo(e, t), ...t };
                  return Array.isArray(i.loaders) || (i.loaders = null), i;
                })({ url: r, parse: Ea, loaders: s }, (n = Go(n, o, s, r)), i)),
                await (async function (t, e, n, i) {
                  if (
                    ((function (t, e = "3.0.12") {
                      Yo(t, "no worker provided");
                      t.version;
                    })(t),
                    (e = await pa(e, t, n)),
                    t.parseTextSync && "string" == typeof e)
                  )
                    return (n.dataType = "text"), t.parseTextSync(e, n, i, t);
                  if (
                    (function (t, e) {
                      return (
                        !!oa.isSupported() &&
                        t.worker &&
                        (null == e ? void 0 : e.worker)
                      );
                    })(t, n)
                  )
                    return await aa(t, e, n, 0, Ea);
                  if (t.parseText && "string" == typeof e)
                    return await t.parseText(e, n, i, t);
                  if (t.parse) return await t.parse(e, n, i, t);
                  throw (
                    (Yo(!t.parseSync),
                    new Error(
                      `${t.id} loader - no parser found and worker is disabled`
                    ))
                  );
                })(o, t, n, i))
              : null;
          }
          async function Aa(t, e, n, i) {
            Array.isArray(e) || bo(e) || ((n = e), (e = void 0));
            const r = Wo(n);
            let s = t;
            return (
              "string" == typeof t && (s = await r(t)),
              yo(t) && (s = await r(t)),
              await Ea(s, e, n)
            );
          }
          const Ta = 2 ** 24 - 1,
            Sa = Object.freeze([]),
            Ma = Or(({ oldViewport: t, viewport: e }) => t.equals(e));
          let Ca = new Uint8ClampedArray(0);
          const La = {
            data: { type: "data", value: Sa, async: !0 },
            dataComparator: null,
            _dataDiff: {
              type: "function",
              value: (t) => t && t.__diff,
              compare: !1,
              optional: !0,
            },
            dataTransform: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDataLoad: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onError: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            fetch: {
              type: "function",
              value: (
                t,
                { propName: e, layer: n, loaders: i, loadOptions: r, signal: s }
              ) => {
                const { resourceManager: o } = n.context;
                var a;
                (r = r || n.getLoadOptions()),
                  (i = i || n.props.loaders),
                  s &&
                    (r = {
                      ...r,
                      fetch: {
                        ...(null === (a = r) || void 0 === a
                          ? void 0
                          : a.fetch),
                        signal: s,
                      },
                    });
                let c = o.contains(t);
                return (
                  c ||
                    r ||
                    (o.add({ resourceId: t, data: Aa(t, i), persistent: !1 }),
                    (c = !0)),
                  c
                    ? o.subscribe({
                        resourceId: t,
                        onChange: (t) => n.internalState.reloadAsyncProp(e, t),
                        consumerId: n.id,
                        requestId: e,
                      })
                    : Aa(t, i, r)
                );
              },
              compare: !1,
            },
            updateTriggers: {},
            visible: !0,
            pickable: !1,
            opacity: { type: "number", min: 0, max: 1, value: 1 },
            onHover: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onClick: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDragStart: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDrag: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            onDragEnd: {
              type: "function",
              value: null,
              compare: !1,
              optional: !0,
            },
            coordinateSystem: A.DEFAULT,
            coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
            modelMatrix: {
              type: "array",
              value: null,
              compare: !0,
              optional: !0,
            },
            wrapLongitude: !1,
            positionFormat: "XYZ",
            colorFormat: "RGBA",
            parameters: {},
            transitions: null,
            extensions: [],
            loaders: { type: "array", value: [], optional: !0, compare: !0 },
            getPolygonOffset: {
              type: "function",
              value: ({ layerIndex: t }) => [0, 100 * -t],
              compare: !1,
            },
            highlightedObjectIndex: -1,
            autoHighlight: !1,
            highlightColor: { type: "accessor", value: [0, 0, 128, 128] },
          };
          class Oa extends ho {
            toString() {
              const t = this.constructor.layerName || this.constructor.name;
              return "".concat(t, "({id: '").concat(this.props.id, "'})");
            }
            raiseError(t, e) {
              var n, i, r, s;
              e && (t.message = "".concat(e, ": ").concat(t.message)),
                (null === (n = (i = this.props).onError) || void 0 === n
                  ? void 0
                  : n.call(i, t)) ||
                  null === (r = this.context) ||
                  void 0 === r ||
                  null === (s = r.onError) ||
                  void 0 === s ||
                  s.call(r, t, this);
            }
            setState(t) {
              this.setChangeFlags({ stateChanged: !0 }),
                Object.assign(this.state, t),
                this.setNeedsRedraw();
            }
            setNeedsRedraw(t = !0) {
              this.internalState && (this.internalState.needsRedraw = t);
            }
            setNeedsUpdate() {
              this.context.layerManager.setNeedsUpdate(String(this)),
                (this.internalState.needsUpdate = !0);
            }
            getNeedsRedraw(t = { clearRedrawFlags: !1 }) {
              return this._getNeedsRedraw(t);
            }
            needsUpdate() {
              return (
                this.internalState.needsUpdate ||
                this.hasUniformTransition() ||
                this.shouldUpdateState(this._getUpdateParams())
              );
            }
            hasUniformTransition() {
              return this.internalState.uniformTransitions.active;
            }
            get isLoaded() {
              return (
                this.internalState && !this.internalState.isAsyncPropLoading()
              );
            }
            get wrapLongitude() {
              return this.props.wrapLongitude;
            }
            isPickable() {
              return this.props.pickable && this.props.visible;
            }
            getModels() {
              return (
                this.state &&
                (this.state.models ||
                  (this.state.model ? [this.state.model] : []))
              );
            }
            getAttributeManager() {
              return this.internalState && this.internalState.attributeManager;
            }
            getCurrentLayer() {
              return this.internalState && this.internalState.layer;
            }
            getLoadOptions() {
              return this.props.loadOptions;
            }
            project(t) {
              const { viewport: e } = this.context,
                n = js(t, {
                  viewport: e,
                  modelMatrix: this.props.modelMatrix,
                  coordinateOrigin: this.props.coordinateOrigin,
                  coordinateSystem: this.props.coordinateSystem,
                }),
                [i, r, s] = ws(n, e.pixelProjectionMatrix);
              return 2 === t.length ? [i, r] : [i, r, s];
            }
            unproject(t) {
              const { viewport: e } = this.context;
              return e.unproject(t);
            }
            projectPosition(t) {
              return (function (t, e) {
                const {
                    viewport: n,
                    coordinateSystem: i,
                    coordinateOrigin: r,
                    modelMatrix: s,
                    fromCoordinateSystem: o,
                    fromCoordinateOrigin: a,
                  } = (function (t) {
                    const e = { ...t };
                    let { coordinateSystem: n } = t;
                    const {
                      viewport: i,
                      coordinateOrigin: r,
                      fromCoordinateSystem: s,
                      fromCoordinateOrigin: o,
                    } = t;
                    return (
                      n === A.DEFAULT &&
                        (n = i.isGeospatial ? A.LNGLAT : A.CARTESIAN),
                      void 0 === s && (e.fromCoordinateSystem = n),
                      void 0 === o && (e.fromCoordinateOrigin = r),
                      (e.coordinateSystem = n),
                      e
                    );
                  })(e),
                  {
                    geospatialOrigin: c,
                    shaderCoordinateOrigin: l,
                    offsetMode: h,
                  } = Yr(n, i, r),
                  u = js(t, {
                    viewport: n,
                    modelMatrix: s,
                    coordinateSystem: o,
                    coordinateOrigin: a,
                    offsetMode: h,
                  });
                h &&
                  (function (t, e, n) {
                    (t[0] = e[0] - n[0]),
                      (t[1] = e[1] - n[1]),
                      (t[2] = e[2] - n[2]);
                  })(u, u, n.projectPosition(c || l));
                return u;
              })(t, {
                viewport: this.context.viewport,
                modelMatrix: this.props.modelMatrix,
                coordinateOrigin: this.props.coordinateOrigin,
                coordinateSystem: this.props.coordinateSystem,
              });
            }
            use64bitPositions() {
              const { coordinateSystem: t } = this.props;
              return t === A.DEFAULT || t === A.LNGLAT || t === A.CARTESIAN;
            }
            onHover(t, e) {
              return !!this.props.onHover && this.props.onHover(t, e);
            }
            onClick(t, e) {
              return !!this.props.onClick && this.props.onClick(t, e);
            }
            nullPickingColor() {
              return [0, 0, 0];
            }
            encodePickingColor(t, e = []) {
              return (
                (e[0] = (t + 1) & 255),
                (e[1] = ((t + 1) >> 8) & 255),
                (e[2] = (((t + 1) >> 8) >> 8) & 255),
                e
              );
            }
            decodePickingColor(t) {
              Je(t instanceof Uint8Array);
              const [e, n, i] = t;
              return e + 256 * n + 65536 * i - 1;
            }
            initializeState() {
              throw new Error(
                "Layer ".concat(this, " has not defined initializeState")
              );
            }
            getShaders(t) {
              for (const e of this.props.extensions)
                t = Ir(t, e.getShaders.call(this, e));
              return t;
            }
            shouldUpdateState({
              oldProps: t,
              props: e,
              context: n,
              changeFlags: i,
            }) {
              return i.propsOrDataChanged;
            }
            updateState({ oldProps: t, props: e, context: n, changeFlags: i }) {
              const r = this.getAttributeManager();
              if (i.dataChanged && r) {
                const { dataChanged: t } = i;
                if (Array.isArray(t)) for (const e of t) r.invalidateAll(e);
                else r.invalidateAll();
              }
              const s = t.highlightedObjectIndex >= 0 || t.pickable,
                o = e.highlightedObjectIndex >= 0 || e.pickable;
              if (s !== o && r) {
                const { pickingColors: t, instancePickingColors: e } =
                    r.attributes,
                  n = t || e;
                n &&
                  (o && n.constant && ((n.constant = !1), r.invalidate(n.id)),
                  n.value || o || ((n.constant = !0), (n.value = [0, 0, 0])));
              }
            }
            finalizeState() {
              for (const t of this.getModels()) t.delete();
              const t = this.getAttributeManager();
              t && t.finalize(),
                this.context.resourceManager.unsubscribe({
                  consumerId: this.id,
                }),
                this.internalState.uniformTransitions.clear(),
                this.internalState.finalize();
            }
            draw(t) {
              for (const e of this.getModels()) e.draw(t);
            }
            getPickingInfo({ info: t, mode: e }) {
              const { index: n } = t;
              return (
                n >= 0 &&
                  Array.isArray(this.props.data) &&
                  (t.object = this.props.data[n]),
                t
              );
            }
            activateViewport(t) {
              const e = this.internalState.viewport;
              (this.internalState.viewport = t),
                (e && Ma({ oldViewport: e, viewport: t })) ||
                  (this.setChangeFlags({ viewportChanged: !0 }),
                  this.isComposite
                    ? this.needsUpdate() && this.setNeedsUpdate()
                    : this._update());
            }
            invalidateAttribute(t = "all", e = "") {
              const n = this.getAttributeManager();
              n && ("all" === t ? n.invalidateAll() : n.invalidate(t));
            }
            updateAttributes(t) {
              for (const e of this.getModels()) this._setModelAttributes(e, t);
            }
            _updateAttributes(t) {
              const e = this.getAttributeManager();
              if (!e) return;
              const n = this.getNumInstances(t),
                i = this.getStartIndices(t);
              e.update({
                data: t.data,
                numInstances: n,
                startIndices: i,
                props: t,
                transitions: t.transitions,
                buffers: t.data.attributes,
                context: this,
                ignoreUnknownAttributes: !0,
              });
              const r = e.getChangedAttributes({ clearChangedFlags: !0 });
              this.updateAttributes(r);
            }
            _updateAttributeTransition() {
              const t = this.getAttributeManager();
              t && t.updateTransition();
            }
            _updateUniformTransition() {
              const { uniformTransitions: t } = this.internalState;
              if (t.active) {
                const e = t.update(),
                  n = Object.create(this.props);
                for (const t in e) Object.defineProperty(n, t, { value: e[t] });
                return n;
              }
              return this.props;
            }
            calculateInstancePickingColors(t, { numInstances: e }) {
              if (t.constant) return;
              const n = Math.floor(Ca.length / 3);
              if (((this.internalState.usesPickingColorCache = !0), n < e)) {
                e > Ta &&
                  E.warn(
                    "Layer has too many data objects. Picking might not be able to distinguish all objects."
                  )(),
                  (Ca = Ee.allocate(Ca, e, {
                    size: 3,
                    copy: !0,
                    maxCount: Math.max(e, Ta),
                  }));
                const t = Math.floor(Ca.length / 3),
                  i = [];
                for (let e = n; e < t; e++)
                  this.encodePickingColor(e, i),
                    (Ca[3 * e + 0] = i[0]),
                    (Ca[3 * e + 1] = i[1]),
                    (Ca[3 * e + 2] = i[2]);
              }
              t.value = Ca.subarray(0, 3 * e);
            }
            _setModelAttributes(t, e) {
              const n = this.getAttributeManager(),
                i = t.userData.excludeAttributes || {},
                r = n.getShaderAttributes(e, i);
              t.setAttributes(r);
            }
            disablePickingIndex(t) {
              this._disablePickingIndex(t);
            }
            _disablePickingIndex(t) {
              const { pickingColors: e, instancePickingColors: n } =
                  this.getAttributeManager().attributes,
                i = e || n,
                r = i.getVertexOffset(t),
                s = i.getVertexOffset(t + 1);
              i.buffer.subData({ data: new Uint8Array(s - r), offset: r });
            }
            restorePickingColors() {
              const { pickingColors: t, instancePickingColors: e } =
                  this.getAttributeManager().attributes,
                n = t || e;
              this.internalState.usesPickingColorCache &&
                n.value.buffer !== Ca.buffer &&
                (n.value = Ca.subarray(0, n.value.length)),
                n.updateSubBuffer({ startOffset: 0 });
            }
            getNumInstances(t) {
              return void 0 !== (t = t || this.props).numInstances
                ? t.numInstances
                : this.state && void 0 !== this.state.numInstances
                ? this.state.numInstances
                : (function (t) {
                    if (null === (e = t) || "object" != typeof e)
                      throw new Error("count(): argument not an object");
                    var e;
                    if ("function" == typeof t.count) return t.count();
                    if (Number.isFinite(t.size)) return t.size;
                    if (Number.isFinite(t.length)) return t.length;
                    if (
                      (function (t) {
                        return (
                          null !== t &&
                          "object" == typeof t &&
                          t.constructor === Object
                        );
                      })(t)
                    )
                      return Object.keys(t).length;
                    throw new Error("count(): argument not a container");
                  })(t.data);
            }
            getStartIndices(t) {
              return void 0 !== (t = t || this.props).startIndices
                ? t.startIndices
                : this.state && this.state.startIndices
                ? this.state.startIndices
                : null;
            }
            _initialize() {
              bn("layer.initialize", this),
                this._initState(),
                this.initializeState(this.context);
              for (const t of this.props.extensions)
                t.initializeState.call(this, this.context, t);
              this.setChangeFlags({
                dataChanged: !0,
                propsChanged: !0,
                viewportChanged: !0,
                extensionsChanged: !0,
              }),
                this._updateState();
            }
            _update() {
              const t = this.needsUpdate();
              bn("layer.update", this, t), t && this._updateState();
            }
            _updateState() {
              const t = this.props,
                e = this.context.viewport,
                n = this._updateUniformTransition();
              (this.internalState.propsInTransition = n),
                (this.context.viewport = this.internalState.viewport || e),
                (this.props = n);
              try {
                const n = this._getUpdateParams(),
                  i = this.getModels();
                if (this.context.gl) this.updateState(n);
                else
                  try {
                    this.updateState(n);
                  } catch (t) {}
                for (const t of this.props.extensions)
                  t.updateState.call(this, n, t);
                const r = this.getModels()[0] !== i[0];
                this._updateModules(n, r),
                  this.isComposite
                    ? this._renderLayers(n)
                    : (this.setNeedsRedraw(),
                      this._updateAttributes(this.props),
                      this.state.model &&
                        this.state.model.setInstanceCount(
                          this.getNumInstances()
                        ));
              } finally {
                (this.context.viewport = e),
                  (this.props = t),
                  this.clearChangeFlags(),
                  (this.internalState.needsUpdate = !1),
                  this.internalState.resetOldProps();
              }
            }
            _finalize() {
              bn("layer.finalize", this), this.finalizeState(this.context);
              for (const t of this.props.extensions)
                t.finalizeState.call(this, t);
            }
            drawLayer({
              moduleParameters: t = null,
              uniforms: e = {},
              parameters: n = {},
            }) {
              this._updateAttributeTransition();
              const i = this.props;
              this.props = this.internalState.propsInTransition || i;
              const { opacity: r } = this.props;
              e.opacity = Math.pow(r, 1 / 2.2);
              try {
                t && this.setModuleParameters(t);
                const { getPolygonOffset: r } = this.props,
                  s = (r && r(e)) || [0, 0];
                dt(this.context.gl, { polygonOffset: s }),
                  pt(this.context.gl, n, () => {
                    const i = {
                      moduleParameters: t,
                      uniforms: e,
                      parameters: n,
                      context: this.context,
                    };
                    for (const t of this.props.extensions)
                      t.draw.call(this, i, t);
                    this.draw(i);
                  });
              } finally {
                this.props = i;
              }
            }
            getChangeFlags() {
              return this.internalState.changeFlags;
            }
            setChangeFlags(t) {
              const { changeFlags: e } = this.internalState;
              for (const n in t)
                if (t[n]) {
                  let i = !1;
                  "dataChanged" === n &&
                    Array.isArray(e[n]) &&
                    ((e[n] = Array.isArray(t[n]) ? e[n].concat(t[n]) : t[n]),
                    (i = !0)),
                    e[n] || ((e[n] = t[n]), (i = !0)),
                    i && bn("layer.changeFlag", this, n, t);
                }
              const n =
                e.dataChanged ||
                e.updateTriggersChanged ||
                e.propsChanged ||
                e.extensionsChanged;
              (e.propsOrDataChanged = n),
                (e.somethingChanged = n || t.viewportChanged || t.stateChanged);
            }
            clearChangeFlags() {
              this.internalState.changeFlags = {
                dataChanged: !1,
                propsChanged: !1,
                updateTriggersChanged: !1,
                viewportChanged: !1,
                stateChanged: !1,
                extensionsChanged: !1,
                propsOrDataChanged: !1,
                somethingChanged: !1,
              };
            }
            diffProps(t, e) {
              const n = (function (t, e) {
                const n = Ar({
                    newProps: t,
                    oldProps: e,
                    propTypes: Cr(t),
                    ignoreProps: {
                      data: null,
                      updateTriggers: null,
                      extensions: null,
                      transitions: null,
                    },
                  }),
                  i = (function (t, e) {
                    if (null === e) return "oldProps is null, initial diff";
                    let n = null;
                    const { dataComparator: i, _dataDiff: r } = t;
                    return (
                      i
                        ? i(t.data, e.data) ||
                          (n = "Data comparator detected a change")
                        : t.data !== e.data &&
                          (n = "A new data container was supplied"),
                      n && r && (n = r(t.data, e.data) || n),
                      n
                    );
                  })(t, e);
                let r = !1;
                return (
                  i ||
                    (r = (function (t, e) {
                      if (null === e) return "oldProps is null, initial diff";
                      if ("all" in t.updateTriggers && Mr(t, e, "all"))
                        return { all: !0 };
                      const n = {};
                      let i = !1;
                      for (const r in t.updateTriggers)
                        "all" !== r && Mr(t, e, r) && ((n[r] = !0), (i = n));
                      return i;
                    })(t, e)),
                  {
                    dataChanged: i,
                    propsChanged: n,
                    updateTriggersChanged: r,
                    extensionsChanged: Sr(t, e),
                    transitionsChanged: Er(t, e),
                  }
                );
              })(t, e);
              if (n.updateTriggersChanged)
                for (const t in n.updateTriggersChanged)
                  n.updateTriggersChanged[t] && this.invalidateAttribute(t);
              if (n.transitionsChanged)
                for (const i in n.transitionsChanged)
                  this.internalState.uniformTransitions.add(
                    i,
                    e[i],
                    t[i],
                    t.transitions[i]
                  );
              return this.setChangeFlags(n);
            }
            validateProps() {
              !(function (t) {
                const e = Cr(t);
                for (const n in e) {
                  const i = e[n],
                    { validate: r } = i;
                  if (r && !r(t[n], i))
                    throw new Error(
                      "Invalid prop ".concat(n, ": ").concat(t[n])
                    );
                }
              })(this.props);
            }
            setModuleParameters(t) {
              for (const e of this.getModels()) e.updateModuleSettings(t);
            }
            updateAutoHighlight(t) {
              this.props.autoHighlight && this._updateAutoHighlight(t);
            }
            _updateAutoHighlight(t) {
              const e = { pickingSelectedColor: t.picked ? t.color : null },
                { highlightColor: n } = this.props;
              t.picked &&
                "function" == typeof n &&
                (e.pickingHighlightColor = n(t)),
                this.setModuleParameters(e),
                this.setNeedsRedraw();
            }
            _updateModules({ props: t, oldProps: e }, n) {
              const {
                autoHighlight: i,
                highlightedObjectIndex: r,
                highlightColor: s,
              } = t;
              if (
                n ||
                e.autoHighlight !== i ||
                e.highlightedObjectIndex !== r ||
                e.highlightColor !== s
              ) {
                const t = {};
                i || (t.pickingSelectedColor = null),
                  Array.isArray(s) && (t.pickingHighlightColor = s),
                  Number.isInteger(r) &&
                    (t.pickingSelectedColor =
                      r >= 0 ? this.encodePickingColor(r) : null),
                  this.setModuleParameters(t);
              }
            }
            _getUpdateParams() {
              return {
                props: this.props,
                oldProps: this.internalState.getOldProps(),
                context: this.context,
                changeFlags: this.internalState.changeFlags,
              };
            }
            _getNeedsRedraw(t) {
              if (!this.internalState) return !1;
              let e = !1;
              (e = e || (this.internalState.needsRedraw && this.id)),
                (this.internalState.needsRedraw =
                  this.internalState.needsRedraw && !t.clearRedrawFlags);
              const n = this.getAttributeManager(),
                i = n && n.getNeedsRedraw(t);
              return (e = e || i), e;
            }
            _getAttributeManager() {
              return new mr(this.context.gl, {
                id: this.props.id,
                stats: this.context.stats,
                timeline: this.context.timeline,
              });
            }
            _initState() {
              Je(!this.internalState && !this.state),
                Je(isFinite(this.props.coordinateSystem));
              const t = this._getAttributeManager();
              t &&
                t.addInstanced({
                  instancePickingColors: {
                    type: 5121,
                    size: 3,
                    noAlloc: !0,
                    update: this.calculateInstancePickingColors,
                  },
                }),
                (this.internalState = new uo({
                  attributeManager: t,
                  layer: this,
                })),
                this.clearChangeFlags(),
                (this.state = {}),
                Object.defineProperty(this.state, "attributeManager", {
                  get: () => (
                    E.deprecated(
                      "layer.state.attributeManager",
                      "layer.getAttributeManager()"
                    ),
                    t
                  ),
                }),
                (this.internalState.layer = this),
                (this.internalState.uniformTransitions = new wr(
                  this.context.timeline
                )),
                (this.internalState.onAsyncPropUpdated =
                  this._onAsyncPropUpdated.bind(this)),
                this.internalState.setAsyncProps(this.props);
            }
            _transferState(t) {
              bn("layer.matched", this, this === t);
              const { state: e, internalState: n } = t;
              this !== t &&
                ((this.internalState = n),
                (this.internalState.layer = this),
                (this.state = e),
                this.internalState.setAsyncProps(this.props),
                this.diffProps(this.props, this.internalState.getOldProps()));
            }
            _onAsyncPropUpdated() {
              this.diffProps(this.props, this.internalState.getOldProps()),
                this.setNeedsUpdate();
            }
          }
          (Oa.layerName = "Layer"), (Oa.defaultProps = La);
          class Ia extends Oa {
            get isComposite() {
              return !0;
            }
            get isLoaded() {
              return (
                super.isLoaded && this.getSubLayers().every((t) => t.isLoaded)
              );
            }
            getSubLayers() {
              return (this.internalState && this.internalState.subLayers) || [];
            }
            initializeState() {}
            setState(t) {
              super.setState(t), this.setNeedsUpdate();
            }
            getPickingInfo({ info: t }) {
              const { object: e } = t;
              return e &&
                e.__source &&
                e.__source.parent &&
                e.__source.parent.id === this.id
                ? ((t.object = e.__source.object),
                  (t.index = e.__source.index),
                  t)
                : t;
            }
            renderLayers() {
              return null;
            }
            filterSubLayer(t) {
              return !0;
            }
            shouldRenderSubLayer(t, e) {
              return e && e.length;
            }
            getSubLayerClass(t, e) {
              const { _subLayerProps: n } = this.props;
              return (n && n[t] && n[t].type) || e;
            }
            getSubLayerRow(t, e, n) {
              return (t.__source = { parent: this, object: e, index: n }), t;
            }
            getSubLayerAccessor(t) {
              if ("function" == typeof t) {
                const e = { data: this.props.data, target: [] };
                return (n, i) =>
                  n && n.__source
                    ? ((e.index = n.__source.index), t(n.__source.object, e))
                    : t(n, i);
              }
              return t;
            }
            getSubLayerProps(t = {}) {
              const {
                  opacity: e,
                  pickable: n,
                  visible: i,
                  parameters: r,
                  getPolygonOffset: s,
                  highlightedObjectIndex: o,
                  autoHighlight: a,
                  highlightColor: c,
                  coordinateSystem: l,
                  coordinateOrigin: h,
                  wrapLongitude: u,
                  positionFormat: d,
                  modelMatrix: f,
                  extensions: p,
                  fetch: g,
                  _subLayerProps: m,
                } = this.props,
                y = {
                  opacity: e,
                  pickable: n,
                  visible: i,
                  parameters: r,
                  getPolygonOffset: s,
                  highlightedObjectIndex: o,
                  autoHighlight: a,
                  highlightColor: c,
                  coordinateSystem: l,
                  coordinateOrigin: h,
                  wrapLongitude: u,
                  positionFormat: d,
                  modelMatrix: f,
                  extensions: p,
                  fetch: g,
                },
                _ = m && m[t.id],
                v = _ && _.updateTriggers,
                b = t.id || "sublayer";
              if (_) {
                const e = this.constructor._propTypes,
                  n = t.type ? t.type._propTypes : {};
                for (const t in _) {
                  const i = n[t] || e[t];
                  i &&
                    "accessor" === i.type &&
                    (_[t] = this.getSubLayerAccessor(_[t]));
                }
              }
              Object.assign(y, t, _),
                (y.id = "".concat(this.props.id, "-").concat(b)),
                (y.updateTriggers = {
                  all: this.props.updateTriggers.all,
                  ...t.updateTriggers,
                  ...v,
                });
              for (const t of p) {
                const e = t.getSubLayerProps.call(this, t);
                e &&
                  Object.assign(y, e, {
                    updateTriggers: Object.assign(
                      y.updateTriggers,
                      e.updateTriggers
                    ),
                  });
              }
              return y;
            }
            _updateAutoHighlight(t) {
              for (const e of this.getSubLayers()) e.updateAutoHighlight(t);
            }
            _getAttributeManager() {
              return null;
            }
            _renderLayers() {
              let { subLayers: t } = this.internalState;
              const e = !t || this.needsUpdate();
              e &&
                ((t = this.renderLayers()),
                (t = sn(t, Boolean)),
                (this.internalState.subLayers = t)),
                bn("compositeLayer.renderLayers", this, e, t);
              for (const e of t) e.parent = this;
            }
          }
          function Ra({ data: t, getIndex: e, dataRange: n, replace: i }) {
            const { startRow: r = 0, endRow: s = 1 / 0 } = n,
              o = t.length;
            let a = o,
              c = o;
            for (let n = 0; n < o; n++) {
              const i = e(t[n]);
              if ((a > n && i >= r && (a = n), i >= s)) {
                c = n;
                break;
              }
            }
            let l = a;
            const h = c - a !== i.length,
              u = h && t.slice(c);
            for (let e = 0; e < i.length; e++) t[l++] = i[e];
            if (h) {
              for (let e = 0; e < u.length; e++) t[l++] = u[e];
              t.length = l;
            }
            return { startRow: a, endRow: a + i.length };
          }
          Ia.layerName = "CompositeLayer";
          const ka = Object.keys(A)
              .map((t) =>
                "const int COORDINATE_SYSTEM_"
                  .concat(t, " = ")
                  .concat(A[t], ";")
              )
              .join(""),
            Fa = Object.keys(T)
              .map((t) =>
                "const int PROJECTION_MODE_".concat(t, " = ").concat(T[t], ";")
              )
              .join(""),
            za = Object.keys(S)
              .map((t) =>
                "const int UNIT_"
                  .concat(t.toUpperCase(), " = ")
                  .concat(S[t], ";")
              )
              .join(""),
            ja = ""
              .concat(ka, "\n")
              .concat(Fa, "\n")
              .concat(
                za,
                "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n"
              ),
            Ba = {},
            Da = {
              name: "project",
              dependencies: [
                {
                  name: "fp32",
                  vs: "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",
                  fs: null,
                },
                {
                  name: "geometry",
                  vs: "\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n",
                  fs: "\n#define SMOOTH_EDGE_RADIUS 0.5\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n",
                },
              ],
              vs: ja,
              getUniforms: function (t = Ba) {
                return t.viewport
                  ? (function ({
                      viewport: t,
                      devicePixelRatio: e = 1,
                      modelMatrix: n = null,
                      coordinateSystem: i = A.DEFAULT,
                      coordinateOrigin: r,
                      autoWrapLongitude: s = !1,
                    } = {}) {
                      i === A.DEFAULT &&
                        (i = t.isGeospatial ? A.LNGLAT : A.CARTESIAN);
                      const o = Xr({
                        viewport: t,
                        devicePixelRatio: e,
                        coordinateSystem: i,
                        coordinateOrigin: r,
                      });
                      return (
                        (o.project_uWrapLongitude = s),
                        (o.project_uModelMatrix = n || Wr),
                        o
                      );
                    })(t)
                  : {};
              },
            },
            Na = {
              name: "project32",
              dependencies: [Da],
              vs: "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    mat3 rotation = project_get_orientation_matrix(projectedPosition);\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n",
            },
            Ua = {
              pickingSelectedColor: null,
              pickingHighlightColor: new Uint8Array([0, 255, 255, 255]),
              pickingActive: !1,
              pickingAttribute: !1,
            },
            Va = {
              inject: {
                "vs:DECKGL_FILTER_COLOR":
                  "\n  picking_setPickingColor(geometry.pickingColor);\n  // for picking depth values\n  picking_setPickingAttribute(geometry.position.z);\n  ",
                "fs:DECKGL_FILTER_COLOR": {
                  order: 99,
                  injection:
                    "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    ",
                },
              },
              name: "picking",
              vs: "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",
              fs: "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",
              getUniforms: function (t = Ua) {
                const e = {};
                if (void 0 !== t.pickingSelectedColor)
                  if (t.pickingSelectedColor) {
                    const n = t.pickingSelectedColor.slice(0, 3);
                    (e.picking_uSelectedColorValid = 1),
                      (e.picking_uSelectedColor = n);
                  } else e.picking_uSelectedColorValid = 0;
                if (t.pickingHighlightColor) {
                  const n = Array.from(t.pickingHighlightColor, (t) => t / 255);
                  Number.isFinite(n[3]) || (n[3] = 1),
                    (e.picking_uHighlightColor = n);
                }
                return (
                  void 0 !== t.pickingActive &&
                    ((e.picking_uActive = Boolean(t.pickingActive)),
                    (e.picking_uAttribute = Boolean(t.pickingAttribute))),
                  e
                );
              },
            },
            Ga = {
              POINTS: 0,
              LINES: 1,
              LINE_LOOP: 2,
              LINE_STRIP: 3,
              TRIANGLES: 4,
              TRIANGLE_STRIP: 5,
              TRIANGLE_FAN: 6,
            };
          class Wa {
            static get DRAW_MODE() {
              return Ga;
            }
            constructor(t = {}) {
              const {
                id: e = Rt("geometry"),
                drawMode: n = Ga.TRIANGLES,
                attributes: i = {},
                indices: r = null,
                vertexCount: s = null,
              } = t;
              (this.id = e),
                (this.drawMode = 0 | n),
                (this.attributes = {}),
                (this.userData = {}),
                this._setAttributes(i, r),
                (this.vertexCount =
                  s ||
                  this._calculateVertexCount(this.attributes, this.indices));
            }
            get mode() {
              return this.drawMode;
            }
            getVertexCount() {
              return this.vertexCount;
            }
            getAttributes() {
              return this.indices
                ? { indices: this.indices, ...this.attributes }
                : this.attributes;
            }
            _print(t) {
              return `Geometry ${this.id} attribute ${t}`;
            }
            _setAttributes(t, e) {
              e &&
                (this.indices = ArrayBuffer.isView(e)
                  ? { value: e, size: 1 }
                  : e);
              for (const e in t) {
                let n = t[e];
                (n = ArrayBuffer.isView(n) ? { value: n } : n),
                  Ct(
                    ArrayBuffer.isView(n.value),
                    `${this._print(
                      e
                    )}: must be typed array or object with value as typed array`
                  ),
                  ("POSITION" !== e && "positions" !== e) ||
                    n.size ||
                    (n.size = 3),
                  "indices" === e
                    ? (Ct(!this.indices), (this.indices = n))
                    : (this.attributes[e] = n);
              }
              return (
                this.indices &&
                  void 0 !== this.indices.isIndexed &&
                  ((this.indices = Object.assign({}, this.indices)),
                  delete this.indices.isIndexed),
                this
              );
            }
            _calculateVertexCount(t, e) {
              if (e) return e.value.length;
              let n = 1 / 0;
              for (const e in t) {
                const i = t[e],
                  { value: r, size: s, constant: o } = i;
                !o && r && s >= 1 && (n = Math.min(n, r.length / s));
              }
              return Ct(Number.isFinite(n)), n;
            }
          }
          function Ha(t, e) {
            if (!t) throw new Error(e);
          }
          const $a = {
              self: "undefined" != typeof self && self,
              window: "undefined" != typeof window && window,
              global: void 0 !== n.g && n.g,
              document: "undefined" != typeof document && document,
            },
            Xa = $a.global || $a.self || $a.window,
            Ya =
              "object" != typeof process ||
              "[object process]" !== String(process) ||
              process.browser,
            qa =
              "undefined" != typeof process &&
              process.version &&
              /v([0-9]*)/.exec(process.version),
            { _parseImageNode: Za } = (qa && parseFloat(qa[1]), Xa),
            Ka = "undefined" != typeof Image,
            Ja = "undefined" != typeof ImageBitmap,
            Qa = Boolean(Za),
            tc = !!Ya || Qa;
          function ec(t) {
            const e = (function (t) {
              return "undefined" != typeof ImageBitmap &&
                t instanceof ImageBitmap
                ? "imagebitmap"
                : "undefined" != typeof Image && t instanceof Image
                ? "image"
                : t && "object" == typeof t && t.data && t.width && t.height
                ? "data"
                : null;
            })(t);
            if (!e) throw new Error("Not an image");
            return e;
          }
          const nc = /^data:image\/svg\+xml/,
            ic = /\.svg((\?|#).*)?$/;
          function rc(t) {
            return t && (nc.test(t) || ic.test(t));
          }
          function sc(t, e) {
            if (rc(e))
              throw new Error("SVG cannot be parsed directly to imagebitmap");
            return new Blob([new Uint8Array(t)]);
          }
          async function oc(t, e, n) {
            const i = (function (t, e) {
                if (rc(e)) {
                  let e = new TextDecoder().decode(t);
                  try {
                    "function" == typeof unescape &&
                      "function" == typeof encodeURIComponent &&
                      (e = unescape(encodeURIComponent(e)));
                  } catch (t) {
                    throw new Error(t.message);
                  }
                  return `data:image/svg+xml;base64,${btoa(e)}`;
                }
                return sc(t, e);
              })(t, n),
              r = self.URL || self.webkitURL,
              s = "string" != typeof i && r.createObjectURL(i);
            try {
              return await (async function (t, e) {
                const n = new Image();
                return (
                  (n.src = t),
                  e.image && e.image.decode && n.decode
                    ? (await n.decode(), n)
                    : await new Promise((e, i) => {
                        try {
                          (n.onload = () => e(n)),
                            (n.onerror = (e) =>
                              i(new Error(`Could not load image ${t}: ${e}`)));
                        } catch (t) {
                          i(t);
                        }
                      })
                );
              })(s || i, e);
            } finally {
              s && r.revokeObjectURL(s);
            }
          }
          const ac = {};
          let cc = !0;
          const lc = !1,
            hc = !0;
          function uc(t) {
            const e = dc(t);
            return (
              (function (t) {
                const e = dc(t);
                return e.byteLength >= 24 && 2303741511 === e.getUint32(0, lc)
                  ? {
                      mimeType: "image/png",
                      width: e.getUint32(16, lc),
                      height: e.getUint32(20, lc),
                    }
                  : null;
              })(e) ||
              (function (t) {
                const e = dc(t);
                if (
                  !(
                    e.byteLength >= 3 &&
                    65496 === e.getUint16(0, lc) &&
                    255 === e.getUint8(2)
                  )
                )
                  return null;
                const { tableMarkers: n, sofMarkers: i } = (function () {
                  const t = new Set([65499, 65476, 65484, 65501, 65534]);
                  for (let e = 65504; e < 65520; ++e) t.add(e);
                  return {
                    tableMarkers: t,
                    sofMarkers: new Set([
                      65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481,
                      65482, 65483, 65485, 65486, 65487, 65502,
                    ]),
                  };
                })();
                let r = 2;
                for (; r + 9 < e.byteLength; ) {
                  const t = e.getUint16(r, lc);
                  if (i.has(t))
                    return {
                      mimeType: "image/jpeg",
                      height: e.getUint16(r + 5, lc),
                      width: e.getUint16(r + 7, lc),
                    };
                  if (!n.has(t)) return null;
                  (r += 2), (r += e.getUint16(r, lc));
                }
                return null;
              })(e) ||
              (function (t) {
                const e = dc(t);
                return e.byteLength >= 10 && 1195984440 === e.getUint32(0, lc)
                  ? {
                      mimeType: "image/gif",
                      width: e.getUint16(6, hc),
                      height: e.getUint16(8, hc),
                    }
                  : null;
              })(e) ||
              (function (t) {
                const e = dc(t);
                return e.byteLength >= 14 &&
                  16973 === e.getUint16(0, lc) &&
                  e.getUint32(2, hc) === e.byteLength
                  ? {
                      mimeType: "image/bmp",
                      width: e.getUint32(18, hc),
                      height: e.getUint32(22, hc),
                    }
                  : null;
              })(e)
            );
          }
          function dc(t) {
            if (t instanceof DataView) return t;
            if (ArrayBuffer.isView(t)) return new DataView(t.buffer);
            if (t instanceof ArrayBuffer) return new DataView(t);
            throw new Error("toDataView");
          }
          const fc = {
              id: "image",
              module: "images",
              name: "Images",
              version: "3.0.12",
              mimeTypes: [
                "image/png",
                "image/jpeg",
                "image/gif",
                "image/webp",
                "image/bmp",
                "image/vnd.microsoft.icon",
                "image/svg+xml",
              ],
              extensions: [
                "png",
                "jpg",
                "jpeg",
                "gif",
                "webp",
                "bmp",
                "ico",
                "svg",
              ],
              parse: async function (t, e, n) {
                const i = ((e = e || {}).image || {}).type || "auto",
                  { url: r } = n || {};
                let s;
                switch (
                  (function (t) {
                    switch (t) {
                      case "auto":
                      case "data":
                        return (function () {
                          if (Ja) return "imagebitmap";
                          if (Ka) return "image";
                          if (tc) return "data";
                          throw new Error(
                            "Install '@loaders.gl/polyfills' to parse images under Node.js"
                          );
                        })();
                      default:
                        return (
                          (function (t) {
                            switch (t) {
                              case "auto":
                                return Ja || Ka || tc;
                              case "imagebitmap":
                                return Ja;
                              case "image":
                                return Ka;
                              case "data":
                                return tc;
                              default:
                                throw new Error(
                                  `@loaders.gl/images: image ${t} not supported in this environment`
                                );
                            }
                          })(t),
                          t
                        );
                    }
                  })(i)
                ) {
                  case "imagebitmap":
                    s = await (async function (t, e, n) {
                      let i;
                      i = rc(n) ? await oc(t, e, n) : sc(t, n);
                      const r = e && e.imagebitmap;
                      return await (async function (t, e = null) {
                        if (
                          ((!(function (t) {
                            for (const e in t || ac) return !1;
                            return !0;
                          })(e) &&
                            cc) ||
                            (e = null),
                          e)
                        )
                          try {
                            return await createImageBitmap(t, e);
                          } catch (t) {
                            console.warn(t), (cc = !1);
                          }
                        return await createImageBitmap(t);
                      })(i, r);
                    })(t, e, r);
                    break;
                  case "image":
                    s = await oc(t, e, r);
                    break;
                  case "data":
                    s = await (function (t, e) {
                      const { mimeType: n } = uc(t) || {},
                        { _parseImageNode: i } = Xa;
                      return Ha(i), i(t, n, e);
                    })(t, e);
                    break;
                  default:
                    Ha(!1);
                }
                return (
                  "data" === i &&
                    (s = (function (t) {
                      switch (ec(t)) {
                        case "data":
                          return t;
                        case "image":
                        case "imagebitmap":
                          const e = document.createElement("canvas"),
                            n = e.getContext("2d");
                          if (!n) throw new Error("getImageData");
                          return (
                            (e.width = t.width),
                            (e.height = t.height),
                            n.drawImage(t, 0, 0),
                            n.getImageData(0, 0, t.width, t.height)
                          );
                        default:
                          throw new Error("getImageData");
                      }
                    })(s)),
                  s
                );
              },
              tests: [(t) => Boolean(uc(new DataView(t)))],
              options: { image: { type: "auto", decode: !0 } },
            },
            pc = () => {},
            gc = { 10241: 9987, 10240: 9729, 10242: 33071, 10243: 33071 };
          function mc(t, e, n, i) {
            return n === e.width && i === e.height
              ? e
              : ((t.canvas.height = i),
                (t.canvas.width = n),
                t.clearRect(0, 0, t.canvas.width, t.canvas.height),
                t.drawImage(e, 0, 0, e.width, e.height, 0, 0, n, i),
                t.canvas);
          }
          function yc(t) {
            return t && (t.id || t.url);
          }
          function _c(t, e, n) {
            for (let i = 0; i < e.length; i++) {
              const { icon: r, xOffset: s } = e[i];
              t[yc(r)] = { ...r, x: s, y: n };
            }
          }
          class vc {
            constructor(t, { onUpdate: e = pc, onError: n = pc }) {
              (this.gl = t),
                (this.onUpdate = e),
                (this.onError = n),
                (this._loadOptions = null),
                (this._getIcon = null),
                (this._texture = null),
                (this._externalTexture = null),
                (this._mapping = {}),
                (this._pendingCount = 0),
                (this._autoPacking = !1),
                (this._xOffset = 0),
                (this._yOffset = 0),
                (this._rowHeight = 0),
                (this._buffer = 4),
                (this._canvasWidth = 1024),
                (this._canvasHeight = 0),
                (this._canvas = null);
            }
            finalize() {
              var t;
              null === (t = this._texture) || void 0 === t || t.delete();
            }
            getTexture() {
              return this._texture || this._externalTexture;
            }
            getIconMapping(t) {
              const e = this._autoPacking ? yc(t) : t;
              return this._mapping[e] || {};
            }
            setProps({
              loadOptions: t,
              autoPacking: e,
              iconAtlas: n,
              iconMapping: i,
              data: r,
              getIcon: s,
            }) {
              t && (this._loadOptions = t),
                void 0 !== e && (this._autoPacking = e),
                s && (this._getIcon = s),
                i && (this._mapping = i),
                n && this._updateIconAtlas(n),
                this._autoPacking &&
                  (r || s) &&
                  "undefined" != typeof document &&
                  ((this._canvas =
                    this._canvas || document.createElement("canvas")),
                  this._updateAutoPacking(r));
            }
            get isLoaded() {
              return 0 === this._pendingCount;
            }
            _updateIconAtlas(t) {
              var e;
              null === (e = this._texture) || void 0 === e || e.delete(),
                (this._texture = null),
                (this._externalTexture = t),
                this.onUpdate();
            }
            _updateAutoPacking(t) {
              const e = Object.values(
                (function (t, e, n) {
                  if (!t || !e) return null;
                  n = n || {};
                  const i = {},
                    { iterable: r, objectInfo: s } = en(t);
                  for (const t of r) {
                    s.index++;
                    const r = e(t, s),
                      o = yc(r);
                    if (!r) throw new Error("Icon is missing.");
                    if (!r.url) throw new Error("Icon url is missing.");
                    i[o] ||
                      (n[o] && r.url === n[o].url) ||
                      (i[o] = { ...r, source: t, sourceIndex: s.index });
                  }
                  return i;
                })(t, this._getIcon, this._mapping) || {}
              );
              if (e.length > 0) {
                const {
                  mapping: t,
                  xOffset: n,
                  yOffset: i,
                  rowHeight: r,
                  canvasHeight: s,
                } = (function ({
                  icons: t,
                  buffer: e,
                  mapping: n = {},
                  xOffset: i = 0,
                  yOffset: r = 0,
                  rowHeight: s = 0,
                  canvasWidth: o,
                }) {
                  let a = [];
                  for (let c = 0; c < t.length; c++) {
                    const l = t[c];
                    if (!n[yc(l)]) {
                      const { height: t, width: c } = l;
                      i + c + e > o &&
                        (_c(n, a, r),
                        (i = 0),
                        (r = s + r + e),
                        (s = 0),
                        (a = [])),
                        a.push({ icon: l, xOffset: i }),
                        (i = i + c + e),
                        (s = Math.max(s, t));
                    }
                  }
                  return (
                    a.length > 0 && _c(n, a, r),
                    {
                      mapping: n,
                      rowHeight: s,
                      xOffset: i,
                      yOffset: r,
                      canvasWidth: o,
                      canvasHeight:
                        ((c = s + r + e), Math.pow(2, Math.ceil(Math.log2(c)))),
                    }
                  );
                  var c;
                })({
                  icons: e,
                  buffer: this._buffer,
                  canvasWidth: this._canvasWidth,
                  mapping: this._mapping,
                  rowHeight: this._rowHeight,
                  xOffset: this._xOffset,
                  yOffset: this._yOffset,
                });
                (this._rowHeight = r),
                  (this._mapping = t),
                  (this._xOffset = n),
                  (this._yOffset = i),
                  (this._canvasHeight = s),
                  this._texture ||
                    (this._texture = new ne(this.gl, {
                      width: this._canvasWidth,
                      height: this._canvasHeight,
                      parameters: gc,
                    })),
                  this._texture.height !== this._canvasHeight &&
                    (this._texture = (function (t, e, n, i) {
                      const r = e.width,
                        s = e.height,
                        o = ue(e, { width: n, height: i });
                      return (
                        (function (t, e, n = {}) {
                          const {
                            sourceX: i = 0,
                            sourceY: r = 0,
                            targetMipmaplevel: s = 0,
                            targetInternalFormat: o = 6408,
                          } = n;
                          let {
                            targetX: a,
                            targetY: c,
                            targetZ: l,
                            width: h,
                            height: u,
                          } = n;
                          const { framebuffer: d, deleteFramebuffer: f } =
                            ge(t);
                          Ct(d);
                          const { gl: p, handle: g } = d,
                            m = void 0 !== a || void 0 !== c || void 0 !== l;
                          (a = a || 0), (c = c || 0), (l = l || 0);
                          const y = p.bindFramebuffer(36160, g);
                          Ct(e);
                          let _ = null;
                          if (
                            (e instanceof ee &&
                              ((_ = e),
                              (h = Number.isFinite(h) ? h : _.width),
                              (u = Number.isFinite(u) ? u : _.height),
                              _.bind(0),
                              (e = _.target)),
                            m)
                          )
                            switch (e) {
                              case 3553:
                              case 34067:
                                p.copyTexSubImage2D(e, s, a, c, i, r, h, u);
                                break;
                              case 35866:
                              case 32879:
                                k(p).copyTexSubImage3D(
                                  e,
                                  s,
                                  a,
                                  c,
                                  l,
                                  i,
                                  r,
                                  h,
                                  u
                                );
                            }
                          else p.copyTexImage2D(e, s, o, i, r, h, u, 0);
                          _ && _.unbind(),
                            p.bindFramebuffer(36160, y || null),
                            f && d.delete();
                        })(e, o, { targetY: 0, width: r, height: s }),
                        e.delete(),
                        o
                      );
                    })(
                      this.gl,
                      this._texture,
                      this._canvasWidth,
                      this._canvasHeight
                    )),
                  this.onUpdate(),
                  this._loadIcons(e);
              }
            }
            _loadIcons(t) {
              const e = this._canvas.getContext("2d");
              for (const n of t)
                this._pendingCount++,
                  Aa(n.url, fc, this._loadOptions)
                    .then((t) => {
                      const i = yc(n),
                        { x: r, y: s, width: o, height: a } = this._mapping[i],
                        c = mc(e, t, o, a);
                      this._texture.setSubImageData({
                        data: c,
                        x: r,
                        y: s,
                        width: o,
                        height: a,
                      }),
                        this._texture.generateMipmap(),
                        this.onUpdate();
                    })
                    .catch((t) => {
                      this.onError({
                        url: n.url,
                        source: n.source,
                        sourceIndex: n.sourceIndex,
                        loadOptions: this._loadOptions,
                        error: t,
                      });
                    })
                    .finally(() => {
                      this._pendingCount--;
                    });
            }
          }
          const bc = [0, 0, 0, 255],
            wc = {
              iconAtlas: { type: "image", value: null, async: !0 },
              iconMapping: { type: "object", value: {}, async: !0 },
              sizeScale: { type: "number", value: 1, min: 0 },
              billboard: !0,
              sizeUnits: "pixels",
              sizeMinPixels: { type: "number", min: 0, value: 0 },
              sizeMaxPixels: {
                type: "number",
                min: 0,
                value: Number.MAX_SAFE_INTEGER,
              },
              alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
              getPosition: { type: "accessor", value: (t) => t.position },
              getIcon: { type: "accessor", value: (t) => t.icon },
              getColor: { type: "accessor", value: bc },
              getSize: { type: "accessor", value: 1 },
              getAngle: { type: "accessor", value: 0 },
              getPixelOffset: { type: "accessor", value: [0, 0] },
              onIconError: {
                type: "function",
                value: null,
                compare: !1,
                optional: !0,
              },
            };
          class xc extends Oa {
            getShaders() {
              return super.getShaders({
                vs: "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",
                fs: "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                modules: [Na, Va],
              });
            }
            initializeState() {
              (this.state = {
                iconManager: new vc(this.context.gl, {
                  onUpdate: this._onUpdate.bind(this),
                  onError: this._onError.bind(this),
                }),
              }),
                this.getAttributeManager().addInstanced({
                  instancePositions: {
                    size: 3,
                    type: 5130,
                    fp64: this.use64bitPositions(),
                    transition: !0,
                    accessor: "getPosition",
                  },
                  instanceSizes: {
                    size: 1,
                    transition: !0,
                    accessor: "getSize",
                    defaultValue: 1,
                  },
                  instanceOffsets: {
                    size: 2,
                    accessor: "getIcon",
                    transform: this.getInstanceOffset,
                  },
                  instanceIconFrames: {
                    size: 4,
                    accessor: "getIcon",
                    transform: this.getInstanceIconFrame,
                  },
                  instanceColorModes: {
                    size: 1,
                    type: 5121,
                    accessor: "getIcon",
                    transform: this.getInstanceColorMode,
                  },
                  instanceColors: {
                    size: this.props.colorFormat.length,
                    type: 5121,
                    normalized: !0,
                    transition: !0,
                    accessor: "getColor",
                    defaultValue: bc,
                  },
                  instanceAngles: {
                    size: 1,
                    transition: !0,
                    accessor: "getAngle",
                  },
                  instancePixelOffset: {
                    size: 2,
                    transition: !0,
                    accessor: "getPixelOffset",
                  },
                });
            }
            updateState({ oldProps: t, props: e, changeFlags: n }) {
              super.updateState({ props: e, oldProps: t, changeFlags: n });
              const i = this.getAttributeManager(),
                { iconAtlas: r, iconMapping: s, data: o, getIcon: a } = e,
                { iconManager: c } = this.state;
              c.setProps({ loadOptions: e.loadOptions });
              let l = !1;
              if (
                (r || this.internalState.isAsyncPropLoading("iconAtlas")
                  ? (t.iconAtlas !== e.iconAtlas &&
                      c.setProps({ iconAtlas: r, autoPacking: !1 }),
                    t.iconMapping !== e.iconMapping &&
                      (c.setProps({ iconMapping: s }), (l = !0)))
                  : c.setProps({ autoPacking: !0 }),
                (n.dataChanged ||
                  (n.updateTriggersChanged &&
                    (n.updateTriggersChanged.all ||
                      n.updateTriggersChanged.getIcon))) &&
                  c.setProps({ data: o, getIcon: a }),
                l &&
                  (i.invalidate("instanceOffsets"),
                  i.invalidate("instanceIconFrames"),
                  i.invalidate("instanceColorModes")),
                n.extensionsChanged)
              ) {
                var h;
                const { gl: t } = this.context;
                null === (h = this.state.model) || void 0 === h || h.delete(),
                  (this.state.model = this._getModel(t)),
                  i.invalidateAll();
              }
            }
            get isLoaded() {
              return super.isLoaded && this.state.iconManager.isLoaded;
            }
            finalizeState() {
              super.finalizeState(), this.state.iconManager.finalize();
            }
            draw({ uniforms: t }) {
              const {
                  sizeScale: e,
                  sizeMinPixels: n,
                  sizeMaxPixels: i,
                  sizeUnits: r,
                  billboard: s,
                  alphaCutoff: o,
                } = this.props,
                { iconManager: a } = this.state,
                c = a.getTexture();
              c &&
                this.state.model
                  .setUniforms(t)
                  .setUniforms({
                    iconsTexture: c,
                    iconsTextureDim: [c.width, c.height],
                    sizeUnits: S[r],
                    sizeScale: e,
                    sizeMinPixels: n,
                    sizeMaxPixels: i,
                    billboard: s,
                    alphaCutoff: o,
                  })
                  .draw();
            }
            _getModel(t) {
              return new cr(t, {
                ...this.getShaders(),
                id: this.props.id,
                geometry: new Wa({
                  drawMode: 6,
                  attributes: {
                    positions: {
                      size: 2,
                      value: new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),
                    },
                  },
                }),
                isInstanced: !0,
              });
            }
            _onUpdate() {
              this.setNeedsRedraw();
            }
            _onError(t) {
              const { onIconError: e } = this.getCurrentLayer().props;
              e ? e(t) : E.error(t.error)();
            }
            getInstanceOffset(t) {
              const e = this.state.iconManager.getIconMapping(t);
              return [
                e.width / 2 - e.anchorX || 0,
                e.height / 2 - e.anchorY || 0,
              ];
            }
            getInstanceColorMode(t) {
              return this.state.iconManager.getIconMapping(t).mask ? 1 : 0;
            }
            getInstanceIconFrame(t) {
              const e = this.state.iconManager.getIconMapping(t);
              return [e.x || 0, e.y || 0, e.width || 0, e.height || 0];
            }
          }
          (xc.layerName = "IconLayer"), (xc.defaultProps = wc);
          const Pc = [0, 0, 0, 255],
            Ec = {
              radiusUnits: "meters",
              radiusScale: { type: "number", min: 0, value: 1 },
              radiusMinPixels: { type: "number", min: 0, value: 0 },
              radiusMaxPixels: {
                type: "number",
                min: 0,
                value: Number.MAX_SAFE_INTEGER,
              },
              lineWidthUnits: "meters",
              lineWidthScale: { type: "number", min: 0, value: 1 },
              lineWidthMinPixels: { type: "number", min: 0, value: 0 },
              lineWidthMaxPixels: {
                type: "number",
                min: 0,
                value: Number.MAX_SAFE_INTEGER,
              },
              stroked: !1,
              filled: !0,
              billboard: !1,
              antialiasing: !0,
              getPosition: { type: "accessor", value: (t) => t.position },
              getRadius: { type: "accessor", value: 1 },
              getFillColor: { type: "accessor", value: Pc },
              getLineColor: { type: "accessor", value: Pc },
              getLineWidth: { type: "accessor", value: 1 },
              strokeWidth: { deprecatedFor: "getLineWidth" },
              outline: { deprecatedFor: "stroked" },
              getColor: { deprecatedFor: ["getFillColor", "getLineColor"] },
            };
          class Ac extends Oa {
            getShaders() {
              return super.getShaders({
                vs: "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",
                fs: "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                modules: [Na, Va],
              });
            }
            initializeState() {
              this.getAttributeManager().addInstanced({
                instancePositions: {
                  size: 3,
                  type: 5130,
                  fp64: this.use64bitPositions(),
                  transition: !0,
                  accessor: "getPosition",
                },
                instanceRadius: {
                  size: 1,
                  transition: !0,
                  accessor: "getRadius",
                  defaultValue: 1,
                },
                instanceFillColors: {
                  size: this.props.colorFormat.length,
                  transition: !0,
                  normalized: !0,
                  type: 5121,
                  accessor: "getFillColor",
                  defaultValue: [0, 0, 0, 255],
                },
                instanceLineColors: {
                  size: this.props.colorFormat.length,
                  transition: !0,
                  normalized: !0,
                  type: 5121,
                  accessor: "getLineColor",
                  defaultValue: [0, 0, 0, 255],
                },
                instanceLineWidths: {
                  size: 1,
                  transition: !0,
                  accessor: "getLineWidth",
                  defaultValue: 1,
                },
              });
            }
            updateState({ props: t, oldProps: e, changeFlags: n }) {
              if (
                (super.updateState({ props: t, oldProps: e, changeFlags: n }),
                n.extensionsChanged)
              ) {
                var i;
                const { gl: t } = this.context;
                null === (i = this.state.model) || void 0 === i || i.delete(),
                  (this.state.model = this._getModel(t)),
                  this.getAttributeManager().invalidateAll();
              }
            }
            draw({ uniforms: t }) {
              const {
                radiusUnits: e,
                radiusScale: n,
                radiusMinPixels: i,
                radiusMaxPixels: r,
                stroked: s,
                filled: o,
                billboard: a,
                antialiasing: c,
                lineWidthUnits: l,
                lineWidthScale: h,
                lineWidthMinPixels: u,
                lineWidthMaxPixels: d,
              } = this.props;
              this.state.model
                .setUniforms(t)
                .setUniforms({
                  stroked: s ? 1 : 0,
                  filled: o,
                  billboard: a,
                  antialiasing: c,
                  radiusUnits: S[e],
                  radiusScale: n,
                  radiusMinPixels: i,
                  radiusMaxPixels: r,
                  lineWidthUnits: S[l],
                  lineWidthScale: h,
                  lineWidthMinPixels: u,
                  lineWidthMaxPixels: d,
                })
                .draw();
            }
            _getModel(t) {
              return new cr(t, {
                ...this.getShaders(),
                id: this.props.id,
                geometry: new Wa({
                  drawMode: 6,
                  vertexCount: 4,
                  attributes: {
                    positions: {
                      size: 3,
                      value: new Float32Array([
                        -1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0,
                      ]),
                    },
                  },
                }),
                isInstanced: !0,
              });
            }
          }
          (Ac.layerName = "ScatterplotLayer"), (Ac.defaultProps = Ec);
          const Tc = [];
          class Sc extends xc {
            getShaders() {
              return {
                ...super.getShaders(),
                fs: "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
              };
            }
            initializeState() {
              super.initializeState(),
                this.getAttributeManager().addInstanced({
                  instanceOffsets: { size: 2, accessor: "getIconOffsets" },
                  instancePickingColors: {
                    type: 5121,
                    size: 3,
                    accessor: (t, { index: e, target: n }) =>
                      this.encodePickingColor(e, n),
                  },
                });
            }
            updateState(t) {
              super.updateState(t);
              const { props: e, oldProps: n } = t;
              let { outlineColor: i } = e;
              i !== n.outlineColor &&
                ((i = i.map((t) => t / 255)),
                (i[3] = Number.isFinite(i[3]) ? i[3] : 1),
                this.setState({ outlineColor: i })),
                !e.sdf &&
                  e.outlineWidth &&
                  E.warn(
                    "".concat(
                      this.id,
                      ": fontSettings.sdf is required to render outline"
                    )
                  )();
            }
            draw(t) {
              const { sdf: e, smoothing: n, outlineWidth: i } = this.props,
                { outlineColor: r } = this.state;
              (t.uniforms = {
                ...t.uniforms,
                buffer: 0.75,
                outlineBuffer: i ? Math.max(n, 0.75 * (1 - i)) : -1,
                gamma: n,
                sdf: Boolean(e),
                outlineColor: r,
              }),
                super.draw(t);
            }
            getInstanceOffset(t) {
              return t
                ? Array.from(t).map((t) => super.getInstanceOffset(t))
                : Tc;
            }
            getInstanceColorMode(t) {
              return 1;
            }
            getInstanceIconFrame(t) {
              return t
                ? Array.from(t).map((t) => super.getInstanceIconFrame(t))
                : Tc;
            }
          }
          (Sc.layerName = "MultiIconLayer"),
            (Sc.defaultProps = {
              getIconOffsets: { type: "accessor", value: (t) => t.offsets },
              alphaCutoff: 0.001,
              smoothing: 0.1,
              outlineWidth: 0,
              outlineColor: { type: "color", value: [0, 0, 0, 255] },
            });
          var Mc = n(823),
            Cc = n.n(Mc);
          const Lc = [];
          function Oc(t, e, n, i) {
            let r = 0;
            for (let s = e; s < n; s++) {
              const e = t[s];
              let n = null;
              const o = i && i[e];
              o && (n = o.width), (r += n);
            }
            return r;
          }
          function Ic(t, e, n, i, r, s) {
            let o = e,
              a = 0;
            for (let c = e; c < n; c++) {
              const e = Oc(t, c, c + 1, r);
              a + e > i && (o < c && s.push(c), (o = c), (a = 0)), (a += e);
            }
            return a;
          }
          function Rc(t, e, n, i, r = 0, s) {
            void 0 === s && (s = t.length);
            const o = [];
            return (
              "break-all" === e
                ? Ic(t, r, s, n, i, o)
                : (function (t, e, n, i, r, s) {
                    let o = e,
                      a = e,
                      c = e,
                      l = 0;
                    for (let h = e; h < n; h++)
                      if (
                        (" " === t[h]
                          ? (c = h + 1)
                          : (" " !== t[h + 1] && h + 1 !== n) || (c = h + 1),
                        c > a)
                      ) {
                        let e = Oc(t, a, c, r);
                        l + e > i &&
                          (o < a && (s.push(a), (o = a), (l = 0)),
                          e > i &&
                            ((e = Ic(t, a, c, i, r, s)),
                            (o = s[s.length - 1]))),
                          (a = c),
                          (l += e);
                      }
                  })(t, r, s, n, i, o),
              o
            );
          }
          function kc(t, e, n, i, r, s) {
            let o = 0,
              a = 0;
            for (let s = e; s < n; s++) {
              const e = t[s],
                n = i[e];
              n
                ? (a || (a = n.height),
                  (r[s] = o + n.width / 2),
                  (o += n.width))
                : (E.warn(
                    "Missing character: "
                      .concat(e, " (")
                      .concat(e.codePointAt(0), ")")
                  )(),
                  (r[s] = o),
                  (o += 32));
            }
            (s[0] = o), (s[1] = a);
          }
          function Fc(t, e, n, i, r) {
            const s = (t = Array.from(t)).length,
              o = new Array(s),
              a = new Array(s),
              c = new Array(s),
              l =
                ("break-word" === n || "break-all" === n) &&
                isFinite(i) &&
                i > 0,
              h = [0, 0],
              u = [];
            let d = 0,
              f = 0,
              p = 0;
            for (let g = 0; g <= s; g++) {
              const m = t[g];
              if ((("\n" !== m && g !== s) || (p = g), p > f)) {
                const s = l ? Rc(t, n, i, r, f, p) : Lc;
                for (let n = 0; n <= s.length; n++) {
                  const i = 0 === n ? f : s[n - 1],
                    l = n < s.length ? s[n] : p;
                  kc(t, i, l, r, o, u);
                  for (let t = i; t < l; t++)
                    (a[t] = d + u[1] / 2), (c[t] = u[0]);
                  (d += u[1] * e), (h[0] = Math.max(h[0], u[0]));
                }
                f = p;
              }
              "\n" === m && ((o[f] = 0), (a[f] = 0), (c[f] = 0), f++);
            }
            return (h[1] = d), { x: o, y: a, rowWidth: c, size: h };
          }
          const zc = (function () {
              const t = [];
              for (let e = 32; e < 128; e++) t.push(String.fromCharCode(e));
              return t;
            })(),
            jc = "Monaco, monospace",
            Bc = "normal",
            Dc = new (class {
              constructor(t = 5) {
                (this.limit = t), this.clear();
              }
              clear() {
                (this._cache = {}), (this._order = []);
              }
              get(t) {
                const e = this._cache[t];
                return e && (this._deleteOrder(t), this._appendOrder(t)), e;
              }
              set(t, e) {
                this._cache[t]
                  ? (this.delete(t), (this._cache[t] = e), this._appendOrder(t))
                  : (Object.keys(this._cache).length === this.limit &&
                      this.delete(this._order[0]),
                    (this._cache[t] = e),
                    this._appendOrder(t));
              }
              delete(t) {
                this._cache[t] && (this._deleteCache(t), this._deleteOrder(t));
              }
              _deleteCache(t) {
                delete this._cache[t];
              }
              _deleteOrder(t) {
                const e = this._order.findIndex((e) => e === t);
                e >= 0 && this._order.splice(e, 1);
              }
              _appendOrder(t) {
                this._order.push(t);
              }
            })(3),
            Nc = [
              "fontFamily",
              "fontWeight",
              "characterSet",
              "fontSize",
              "sdf",
              "buffer",
              "cutoff",
              "radius",
            ];
          function Uc(t, e) {
            for (let n = 0; n < t.length; n++) e.data[4 * n + 3] = t[n];
          }
          function Vc(t, e, n, i) {
            (t.font = "".concat(i, " ").concat(n, "px ").concat(e)),
              (t.fillStyle = "#000"),
              (t.textBaseline = "baseline"),
              (t.textAlign = "left");
          }
          class Gc {
            constructor() {
              (this.props = {
                fontFamily: jc,
                fontWeight: Bc,
                characterSet: zc,
                fontSize: 64,
                buffer: 4,
                sdf: !1,
                cutoff: 0.25,
                radius: 12,
              }),
                (this._key = null),
                (this._atlas = null);
            }
            get texture() {
              return this._atlas;
            }
            get mapping() {
              return this._atlas && this._atlas.mapping;
            }
            get scale() {
              return 1.2;
            }
            setProps(t = {}) {
              Nc.forEach((e) => {
                e in t && (this.props[e] = t[e]);
              });
              const e = this._key;
              this._key = this._getKey();
              const n = (function (t, e) {
                  const n = Dc.get(t);
                  if (!n) return e;
                  const i = [],
                    r = n.mapping;
                  let s = Object.keys(r);
                  s = new Set(s);
                  let o = e;
                  return (
                    o instanceof Array && (o = new Set(o)),
                    o.forEach((t) => {
                      s.has(t) || i.push(t);
                    }),
                    i
                  );
                })(this._key, this.props.characterSet),
                i = Dc.get(this._key);
              if (i && 0 === n.length)
                return void (this._key !== e && (this._atlas = i));
              const r = this._generateFontAtlas(this._key, n, i);
              (this._atlas = r), Dc.set(this._key, r);
            }
            _generateFontAtlas(t, e, n) {
              const {
                fontFamily: i,
                fontWeight: r,
                fontSize: s,
                buffer: o,
                sdf: a,
                radius: c,
                cutoff: l,
              } = this.props;
              let h = n && n.data;
              h || ((h = document.createElement("canvas")), (h.width = 1024));
              const u = h.getContext("2d");
              Vc(u, i, s, r);
              const {
                mapping: d,
                canvasHeight: f,
                xOffset: p,
                yOffset: g,
              } = (function ({
                characterSet: t,
                getFontWidth: e,
                fontHeight: n,
                buffer: i,
                maxCanvasWidth: r,
                mapping: s = {},
                xOffset: o = 0,
                yOffset: a = 0,
              }) {
                let c = 0,
                  l = o,
                  h = 0;
                for (const o of t)
                  if (!s[o]) {
                    const t = e(o, h++);
                    l + t + 2 * i > r && ((l = 0), c++),
                      (s[o] = {
                        x: l + i,
                        y: a + c * (n + 2 * i) + i,
                        width: t,
                        height: n,
                      }),
                      (l += t + 2 * i);
                  }
                const u = n + 2 * i;
                return {
                  mapping: s,
                  xOffset: l,
                  yOffset: a + c * u,
                  canvasHeight:
                    ((d = a + (c + 1) * u),
                    Math.pow(2, Math.ceil(Math.log2(d)))),
                };
                var d;
              })({
                getFontWidth: (t) => u.measureText(t).width,
                fontHeight: 1.2 * s,
                buffer: o,
                characterSet: e,
                maxCanvasWidth: 1024,
                ...(n && {
                  mapping: n.mapping,
                  xOffset: n.xOffset,
                  yOffset: n.yOffset,
                }),
              });
              if (h.height !== f) {
                const t = u.getImageData(0, 0, h.width, h.height);
                (h.height = f), u.putImageData(t, 0, 0);
              }
              if ((Vc(u, i, s, r), a)) {
                const t = new (Cc())(s, o, c, l, i, r),
                  n = u.getImageData(0, 0, t.size, t.size);
                for (const i of e)
                  Uc(t.draw(i), n), u.putImageData(n, d[i].x - o, d[i].y + o);
              } else for (const t of e) u.fillText(t, d[t].x, d[t].y + 0.9 * s);
              return {
                xOffset: p,
                yOffset: g,
                mapping: d,
                data: h,
                width: h.width,
                height: h.height,
              };
            }
            _getKey() {
              const {
                fontFamily: t,
                fontWeight: e,
                fontSize: n,
                buffer: i,
                sdf: r,
                radius: s,
                cutoff: o,
              } = this.props;
              return r
                ? ""
                    .concat(t, " ")
                    .concat(e, " ")
                    .concat(n, " ")
                    .concat(i, " ")
                    .concat(s, " ")
                    .concat(o)
                : "".concat(t, " ").concat(e, " ").concat(n, " ").concat(i);
            }
          }
          const Wc = {
            billboard: !0,
            sizeScale: 1,
            sizeUnits: "pixels",
            sizeMinPixels: 0,
            sizeMaxPixels: Number.MAX_SAFE_INTEGER,
            padding: { type: "array", value: [0, 0, 0, 0] },
            getPosition: { type: "accessor", value: (t) => t.position },
            getSize: { type: "accessor", value: 1 },
            getAngle: { type: "accessor", value: 0 },
            getPixelOffset: { type: "accessor", value: [0, 0] },
            getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
            getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
            getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
            getLineWidth: { type: "accessor", value: 1 },
          };
          class Hc extends Oa {
            getShaders() {
              return super.getShaders({
                vs: "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",
                fs: "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                modules: [Na, Va],
              });
            }
            initializeState() {
              this.getAttributeManager().addInstanced({
                instancePositions: {
                  size: 3,
                  type: 5130,
                  fp64: this.use64bitPositions(),
                  transition: !0,
                  accessor: "getPosition",
                },
                instanceSizes: {
                  size: 1,
                  transition: !0,
                  accessor: "getSize",
                  defaultValue: 1,
                },
                instanceAngles: {
                  size: 1,
                  transition: !0,
                  accessor: "getAngle",
                },
                instanceRects: { size: 4, accessor: "getBoundingRect" },
                instancePixelOffsets: {
                  size: 2,
                  transition: !0,
                  accessor: "getPixelOffset",
                },
                instanceFillColors: {
                  size: 4,
                  transition: !0,
                  normalized: !0,
                  type: 5121,
                  accessor: "getFillColor",
                  defaultValue: [0, 0, 0, 255],
                },
                instanceLineColors: {
                  size: 4,
                  transition: !0,
                  normalized: !0,
                  type: 5121,
                  accessor: "getLineColor",
                  defaultValue: [0, 0, 0, 255],
                },
                instanceLineWidths: {
                  size: 1,
                  transition: !0,
                  accessor: "getLineWidth",
                  defaultValue: 1,
                },
              });
            }
            updateState({ props: t, oldProps: e, changeFlags: n }) {
              if (
                (super.updateState({ props: t, oldProps: e, changeFlags: n }),
                n.extensionsChanged)
              ) {
                var i;
                const { gl: t } = this.context;
                null === (i = this.state.model) || void 0 === i || i.delete(),
                  (this.state.model = this._getModel(t)),
                  this.getAttributeManager().invalidateAll();
              }
            }
            draw({ uniforms: t }) {
              const {
                billboard: e,
                sizeScale: n,
                sizeUnits: i,
                sizeMinPixels: r,
                sizeMaxPixels: s,
                getLineWidth: o,
              } = this.props;
              let { padding: a } = this.props;
              a.length < 4 && (a = [a[0], a[1], a[0], a[1]]),
                this.state.model
                  .setUniforms(t)
                  .setUniforms({
                    billboard: e,
                    stroked: Boolean(o),
                    padding: a,
                    sizeUnits: S[i],
                    sizeScale: n,
                    sizeMinPixels: r,
                    sizeMaxPixels: s,
                  })
                  .draw();
            }
            _getModel(t) {
              return new cr(t, {
                ...this.getShaders(),
                id: this.props.id,
                geometry: new Wa({
                  drawMode: 6,
                  vertexCount: 4,
                  attributes: {
                    positions: {
                      size: 2,
                      value: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                    },
                  },
                }),
                isInstanced: !0,
              });
            }
          }
          (Hc.layerName = "TextBackgroundLayer"), (Hc.defaultProps = Wc);
          const $c = {
              fontSize: 64,
              buffer: 4,
              sdf: !1,
              radius: 12,
              cutoff: 0.25,
              smoothing: 0.1,
            },
            Xc = { start: 1, middle: 0, end: -1 },
            Yc = { top: 1, center: 0, bottom: -1 },
            qc = [0, 0, 0, 255],
            Zc = ["fontSize", "buffer", "sdf", "radius", "cutoff"],
            Kc = {
              billboard: !0,
              sizeScale: 1,
              sizeUnits: "pixels",
              sizeMinPixels: 0,
              sizeMaxPixels: Number.MAX_SAFE_INTEGER,
              background: !1,
              getBackgroundColor: {
                type: "accessor",
                value: [255, 255, 255, 255],
              },
              getBorderColor: { type: "accessor", value: qc },
              getBorderWidth: { type: "accessor", value: 0 },
              backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
              characterSet: { type: "object", value: zc },
              fontFamily: jc,
              fontWeight: Bc,
              lineHeight: 1,
              outlineWidth: { type: "number", value: 0, min: 0 },
              outlineColor: { type: "color", value: qc },
              fontSettings: {},
              wordBreak: "break-word",
              maxWidth: { type: "number", value: -1 },
              getText: { type: "accessor", value: (t) => t.text },
              getPosition: { type: "accessor", value: (t) => t.position },
              getColor: { type: "accessor", value: qc },
              getSize: { type: "accessor", value: 32 },
              getAngle: { type: "accessor", value: 0 },
              getTextAnchor: { type: "accessor", value: "middle" },
              getAlignmentBaseline: { type: "accessor", value: "center" },
              getPixelOffset: { type: "accessor", value: [0, 0] },
              backgroundColor: {
                deprecatedFor: ["background", "getBackgroundColor"],
              },
            };
          class Jc extends Ia {
            initializeState() {
              this.state = { styleVersion: 0, fontAtlasManager: new Gc() };
            }
            updateState({ props: t, oldProps: e, changeFlags: n }) {
              const i =
                  n.dataChanged ||
                  (n.updateTriggersChanged &&
                    (n.updateTriggersChanged.all ||
                      n.updateTriggersChanged.getText)),
                r = this.state.characterSet;
              i && this._updateText();
              const s =
                r !== this.state.characterSet || this._fontChanged(e, t);
              s && this._updateFontAtlas(e, t),
                (s ||
                  t.lineHeight !== e.lineHeight ||
                  t.wordBreak !== e.wordBreak ||
                  t.maxWidth !== e.maxWidth) &&
                  this.setState({ styleVersion: this.state.styleVersion + 1 });
            }
            getPickingInfo({ info: t }) {
              return (
                (t.object = t.index >= 0 ? this.props.data[t.index] : null), t
              );
            }
            _updateFontAtlas(t, e) {
              const { fontSettings: n, fontFamily: i, fontWeight: r } = e,
                { fontAtlasManager: s, characterSet: o } = this.state;
              s.setProps({
                ...$c,
                ...n,
                characterSet: o,
                fontFamily: i,
                fontWeight: r,
              });
            }
            _fontChanged(t, e) {
              if (
                t.fontFamily !== e.fontFamily ||
                t.fontWeight !== e.fontWeight
              )
                return !0;
              if (t.fontSettings === e.fontSettings) return !1;
              const n = t.fontSettings || {},
                i = e.fontSettings || {};
              return Zc.some((t) => n[t] !== i[t]);
            }
            _updateText() {
              const { data: t, characterSet: e } = this.props,
                n = t.attributes && t.attributes.getText;
              let i,
                { getText: r } = this.props,
                { startIndices: s } = t;
              const o = "auto" === e && new Set();
              if (n && s) {
                const { texts: e, characterCount: a } = (function ({
                  value: t,
                  length: e,
                  stride: n,
                  offset: i,
                  startIndices: r,
                  characterSet: s,
                }) {
                  const o = t.BYTES_PER_ELEMENT,
                    a = n ? n / o : 1,
                    c = i ? i / o : 0,
                    l = r[e] || Math.ceil((t.length - c) / a),
                    h = s && new Set(),
                    u = new Array(e);
                  let d = t;
                  if (a > 1 || c > 0) {
                    d = new t.constructor(l);
                    for (let e = 0; e < l; e++) d[e] = t[e * a + c];
                  }
                  for (let t = 0; t < e; t++) {
                    const e = r[t],
                      n = r[t + 1] || l,
                      i = d.subarray(e, n);
                    (u[t] = String.fromCodePoint.apply(null, i)),
                      h && i.forEach(h.add, h);
                  }
                  if (h) for (const t of h) s.add(String.fromCodePoint(t));
                  return { texts: u, characterCount: l };
                })({
                  ...(ArrayBuffer.isView(n) ? { value: n } : n),
                  length: t.length,
                  startIndices: s,
                  characterSet: o,
                });
                (i = a), (r = (t, { index: n }) => e[n]);
              } else {
                const { iterable: e, objectInfo: n } = en(t);
                (s = [0]), (i = 0);
                for (const t of e) {
                  n.index++;
                  const e = Array.from(r(t, n) || "");
                  o && e.forEach(o.add, o), (i += e.length), s.push(i);
                }
              }
              this.setState({
                getText: r,
                startIndices: s,
                numInstances: i,
                characterSet: o || e,
              });
            }
            getBoundingRect(t, e) {
              const n = this.state.fontAtlasManager.mapping,
                { getText: i } = this.state,
                {
                  wordBreak: r,
                  maxWidth: s,
                  lineHeight: o,
                  getTextAnchor: a,
                  getAlignmentBaseline: c,
                } = this.props,
                l = i(t, e) || "",
                {
                  size: [h, u],
                } = Fc(l, o, r, s, n);
              return [
                ((Xc["function" == typeof a ? a(t, e) : a] - 1) * h) / 2,
                ((Yc["function" == typeof c ? c(t, e) : c] - 1) * u) / 2,
                h,
                u,
              ];
            }
            getIconOffsets(t, e) {
              const n = this.state.fontAtlasManager.mapping,
                { getText: i } = this.state,
                {
                  wordBreak: r,
                  maxWidth: s,
                  lineHeight: o,
                  getTextAnchor: a,
                  getAlignmentBaseline: c,
                } = this.props,
                l = i(t, e) || "",
                {
                  x: h,
                  y: u,
                  rowWidth: d,
                  size: [f, p],
                } = Fc(l, o, r, s, n),
                g = Xc["function" == typeof a ? a(t, e) : a],
                m = Yc["function" == typeof c ? c(t, e) : c],
                y = h.length,
                _ = new Array(2 * y);
              let v = 0;
              for (let t = 0; t < y; t++) {
                const e = ((1 - g) * (f - d[t])) / 2;
                (_[v++] = ((g - 1) * f) / 2 + e + h[t]),
                  (_[v++] = ((m - 1) * p) / 2 + u[t]);
              }
              return _;
            }
            renderLayers() {
              const {
                  startIndices: t,
                  numInstances: e,
                  getText: n,
                  fontAtlasManager: { scale: i, texture: r, mapping: s },
                  styleVersion: o,
                } = this.state,
                {
                  data: a,
                  _dataDiff: c,
                  getPosition: l,
                  getColor: h,
                  getSize: u,
                  getAngle: d,
                  getPixelOffset: f,
                  getBackgroundColor: p,
                  getBorderColor: g,
                  getBorderWidth: m,
                  backgroundPadding: y,
                  background: _,
                  billboard: v,
                  fontSettings: b,
                  outlineWidth: w,
                  outlineColor: x,
                  sizeScale: P,
                  sizeUnits: E,
                  sizeMinPixels: A,
                  sizeMaxPixels: T,
                  transitions: S,
                  updateTriggers: M,
                } = this.props,
                C = this.getSubLayerClass("characters", Sc),
                L = this.getSubLayerClass("background", Hc);
              return [
                _ &&
                  new L(
                    {
                      getFillColor: p,
                      getLineColor: g,
                      getLineWidth: m,
                      padding: y,
                      getPosition: l,
                      getSize: u,
                      getAngle: d,
                      getPixelOffset: f,
                      billboard: v,
                      sizeScale: P / this.state.fontAtlasManager.props.fontSize,
                      sizeUnits: E,
                      sizeMinPixels: A,
                      sizeMaxPixels: T,
                      transitions: S && {
                        getPosition: S.getPosition,
                        getAngle: S.getAngle,
                        getSize: S.getSize,
                        getFillColor: S.getBackgroundColor,
                        getLineColor: S.getBorderColor,
                        getLineWidth: S.getBorderWidth,
                        getPixelOffset: S.getPixelOffset,
                      },
                    },
                    this.getSubLayerProps({
                      id: "background",
                      updateTriggers: {
                        getPosition: M.getPosition,
                        getAngle: M.getAngle,
                        getSize: M.getSize,
                        getFillColor: M.getBackgroundColor,
                        getLineColor: M.getBorderColor,
                        getLineWidth: M.getBorderWidth,
                        getPixelOffset: M.getPixelOffset,
                        getBoundingRect: {
                          getText: M.getText,
                          getTextAnchor: M.getTextAnchor,
                          getAlignmentBaseline: M.getAlignmentBaseline,
                          styleVersion: o,
                        },
                      },
                    }),
                    {
                      data: a.attributes
                        ? {
                            length: a.length,
                            attributes: a.attributes.background || {},
                          }
                        : a,
                      _dataDiff: c,
                      autoHighlight: !1,
                      getBoundingRect: this.getBoundingRect.bind(this),
                    }
                  ),
                new C(
                  {
                    sdf: b.sdf,
                    smoothing: Number.isFinite(b.smoothing)
                      ? b.smoothing
                      : $c.smoothing,
                    outlineWidth: w,
                    outlineColor: x,
                    iconAtlas: r,
                    iconMapping: s,
                    getPosition: l,
                    getColor: h,
                    getSize: u,
                    getAngle: d,
                    getPixelOffset: f,
                    billboard: v,
                    sizeScale: P * i,
                    sizeUnits: E,
                    sizeMinPixels: A * i,
                    sizeMaxPixels: T * i,
                    transitions: S && {
                      getPosition: S.getPosition,
                      getAngle: S.getAngle,
                      getColor: S.getColor,
                      getSize: S.getSize,
                      getPixelOffset: S.getPixelOffset,
                    },
                  },
                  this.getSubLayerProps({
                    id: "characters",
                    updateTriggers: {
                      getIcon: M.getText,
                      getPosition: M.getPosition,
                      getAngle: M.getAngle,
                      getColor: M.getColor,
                      getSize: M.getSize,
                      getPixelOffset: M.getPixelOffset,
                      getIconOffsets: {
                        getText: M.getText,
                        getTextAnchor: M.getTextAnchor,
                        getAlignmentBaseline: M.getAlignmentBaseline,
                        styleVersion: o,
                      },
                    },
                  }),
                  {
                    data: a,
                    _dataDiff: c,
                    startIndices: t,
                    numInstances: e,
                    getIconOffsets: this.getIconOffsets.bind(this),
                    getIcon: n,
                  }
                ),
              ];
            }
          }
          (Jc.layerName = "TextLayer"), (Jc.defaultProps = Kc);
          class Qc {
            constructor(t = {}) {
              const { attributes: e = {} } = t;
              (this.typedArrayManager = Ee),
                (this.indexStarts = null),
                (this.vertexStarts = null),
                (this.vertexCount = 0),
                (this.instanceCount = 0),
                (this.attributes = {}),
                (this._attributeDefs = e),
                (this.opts = t),
                this.updateGeometry(t),
                Object.seal(this);
            }
            updateGeometry(t) {
              Object.assign(this.opts, t);
              const {
                data: e,
                buffers: n = {},
                getGeometry: i,
                geometryBuffer: r,
                positionFormat: s,
                dataChanged: o,
                normalize: a = !0,
              } = this.opts;
              if (
                ((this.data = e),
                (this.getGeometry = i),
                (this.positionSize = (r && r.size) || ("XY" === s ? 2 : 3)),
                (this.buffers = n),
                (this.normalize = a),
                r &&
                  (Je(e.startIndices),
                  (this.getGeometry = this.getGeometryFromBuffer(r)),
                  a || (n.positions = r)),
                (this.geometryBuffer = n.positions),
                Array.isArray(o))
              )
                for (const t of o) this._rebuildGeometry(t);
              else this._rebuildGeometry();
            }
            updatePartialGeometry({ startRow: t, endRow: e }) {
              this._rebuildGeometry({ startRow: t, endRow: e });
            }
            normalizeGeometry(t) {
              return t;
            }
            updateGeometryAttributes(t, e, n) {
              throw new Error("Not implemented");
            }
            getGeometrySize(t) {
              throw new Error("Not implemented");
            }
            getGeometryFromBuffer(t) {
              const e = t.value || t;
              return (
                Je(ArrayBuffer.isView(e)),
                rn(e, {
                  size: this.positionSize,
                  offset: t.offset,
                  stride: t.stride,
                  startIndices: this.data.startIndices,
                })
              );
            }
            _allocate(t, e) {
              const {
                attributes: n,
                buffers: i,
                _attributeDefs: r,
                typedArrayManager: s,
              } = this;
              for (const o in r)
                if (o in i) s.release(n[o]), (n[o] = null);
                else {
                  const i = r[o];
                  (i.copy = e), (n[o] = s.allocate(n[o], t, i));
                }
            }
            _forEachGeometry(t, e, n) {
              const { data: i, getGeometry: r } = this,
                { iterable: s, objectInfo: o } = en(i, e, n);
              for (const e of s) o.index++, t(r(e, o), o.index);
            }
            _rebuildGeometry(t) {
              if (!this.data || !this.getGeometry) return;
              let { indexStarts: e, vertexStarts: n, instanceCount: i } = this;
              const { data: r, geometryBuffer: s } = this,
                { startRow: o = 0, endRow: a = 1 / 0 } = t || {},
                c = {};
              if ((t || ((e = [0]), (n = [0])), this.normalize || !s))
                this._forEachGeometry(
                  (t, e) => {
                    (t = this.normalizeGeometry(t)),
                      (c[e] = t),
                      (n[e + 1] = n[e] + this.getGeometrySize(t));
                  },
                  o,
                  a
                ),
                  (i = n[n.length - 1]);
              else if (s.buffer instanceof qt) {
                const t = s.stride || 4 * this.positionSize;
                (n = r.startIndices),
                  (i = n[r.length] || s.buffer.byteLength / t);
              } else {
                const t = s.value || s,
                  e = s.stride / t.BYTES_PER_ELEMENT || this.positionSize;
                (n = r.startIndices), (i = n[r.length] || t.length / e);
              }
              this._allocate(i, Boolean(t)),
                (this.indexStarts = e),
                (this.vertexStarts = n),
                (this.instanceCount = i);
              const l = {};
              this._forEachGeometry(
                (t, r) => {
                  (t = c[r] || t),
                    (l.vertexStart = n[r]),
                    (l.indexStart = e[r]);
                  const s = r < n.length - 1 ? n[r + 1] : i;
                  (l.geometrySize = s - n[r]),
                    (l.geometryIndex = r),
                    this.updateGeometryAttributes(t, l);
                },
                o,
                a
              ),
                (this.vertexCount = e[e.length - 1]);
            }
          }
          function tl(t, e, n = {}) {
            const i = (function (t, e = {}) {
              return Math.sign(
                (function (t, e = {}) {
                  const { start: n = 0, end: i = t.length } = e,
                    r = e.size || 2;
                  let s = 0;
                  for (let e = n, o = i - r; e < i; e += r)
                    (s += (t[e] - t[o]) * (t[e + 1] + t[o + 1])), (o = e);
                  return s / 2;
                })(t, e)
              );
            })(t, n);
            return (
              i !== e &&
              ((function (t, e) {
                const { start: n = 0, end: i = t.length, size: r = 2 } = e,
                  s = (i - n) / r,
                  o = Math.floor(s / 2);
                for (let e = 0; e < o; ++e) {
                  const i = n + e * r,
                    o = n + (s - 1 - e) * r;
                  for (let e = 0; e < r; ++e) {
                    const n = t[i + e];
                    (t[i + e] = t[o + e]), (t[o + e] = n);
                  }
                }
              })(t, n),
              !0)
            );
          }
          function el(t, e, n, i, r = []) {
            let s, o;
            if (8 & n) (s = (i[3] - t[1]) / (e[1] - t[1])), (o = 3);
            else if (4 & n) (s = (i[1] - t[1]) / (e[1] - t[1])), (o = 1);
            else if (2 & n) (s = (i[2] - t[0]) / (e[0] - t[0])), (o = 2);
            else {
              if (!(1 & n)) return null;
              (s = (i[0] - t[0]) / (e[0] - t[0])), (o = 0);
            }
            for (let n = 0; n < t.length; n++)
              r[n] = (1 & o) === n ? i[o] : s * (e[n] - t[n]) + t[n];
            return r;
          }
          function nl(t, e) {
            let n = 0;
            return (
              t[0] < e[0] ? (n |= 1) : t[0] > e[2] && (n |= 2),
              t[1] < e[1] ? (n |= 4) : t[1] > e[3] && (n |= 8),
              n
            );
          }
          function il(t, e) {
            const n = e.length,
              i = t.length;
            if (i > 0) {
              let r = !0;
              for (let s = 0; s < n; s++)
                if (t[i - n + s] !== e[s]) {
                  r = !1;
                  break;
                }
              if (r) return !1;
            }
            for (let r = 0; r < n; r++) t[i + r] = e[r];
            return !0;
          }
          function rl(t, e) {
            const n = e.length;
            for (let i = 0; i < n; i++) t[i] = e[i];
          }
          function sl(t, e, n, i, r = []) {
            const s = i + e * n;
            for (let e = 0; e < n; e++) r[e] = t[s + e];
            return r;
          }
          function ol(t, e = {}) {
            const {
                size: n = 2,
                broken: i = !1,
                gridResolution: r = 10,
                gridOffset: s = [0, 0],
                startIndex: o = 0,
                endIndex: a = t.length,
              } = e,
              c = (a - o) / n;
            let l = [];
            const h = [l],
              u = sl(t, 0, n, o);
            let d, f;
            const p = hl(u, r, s, []),
              g = [];
            il(l, u);
            for (let e = 1; e < c; e++) {
              for (d = sl(t, e, n, o, d), f = nl(d, p); f; ) {
                el(u, d, f, p, g);
                const t = nl(g, p);
                t && (el(u, g, t, p, g), (f = t)),
                  il(l, g),
                  rl(u, g),
                  ul(p, r, f),
                  i && l.length > n && ((l = []), h.push(l), il(l, u)),
                  (f = nl(d, p));
              }
              il(l, d), rl(u, d);
            }
            return i ? h : h[0];
          }
          function al(t, e) {
            for (let n = 0; n < e.length; n++) t.push(e[n]);
            return t;
          }
          function cl(t, e, n = {}) {
            if (!t.length) return [];
            const {
                size: i = 2,
                gridResolution: r = 10,
                gridOffset: s = [0, 0],
                edgeTypes: o = !1,
              } = n,
              a = [],
              c = [
                {
                  pos: t,
                  types: o && new Array(t.length / i).fill(1),
                  holes: e || [],
                },
              ],
              l = [[], []];
            let h = [];
            for (; c.length; ) {
              const { pos: t, types: e, holes: n } = c.shift();
              dl(t, i, n[0] || t.length, l), (h = hl(l[0], r, s, h));
              const u = nl(l[1], h);
              if (u) {
                let r = ll(t, e, i, 0, n[0] || t.length, h, u);
                const s = { pos: r[0].pos, types: r[0].types, holes: [] },
                  a = { pos: r[1].pos, types: r[1].types, holes: [] };
                c.push(s, a);
                for (let c = 0; c < n.length; c++)
                  (r = ll(t, e, i, n[c], n[c + 1] || t.length, h, u)),
                    r[0] &&
                      (s.holes.push(s.pos.length),
                      (s.pos = al(s.pos, r[0].pos)),
                      o && (s.types = al(s.types, r[0].types))),
                    r[1] &&
                      (a.holes.push(a.pos.length),
                      (a.pos = al(a.pos, r[1].pos)),
                      o && (a.types = al(a.types, r[1].types)));
              } else {
                const i = { positions: t };
                o && (i.edgeTypes = e),
                  n.length && (i.holeIndices = n),
                  a.push(i);
              }
            }
            return a;
          }
          function ll(t, e, n, i, r, s, o) {
            const a = (r - i) / n,
              c = [],
              l = [],
              h = [],
              u = [],
              d = [];
            let f, p, g;
            const m = sl(t, a - 1, n, i);
            let y = Math.sign(8 & o ? m[1] - s[3] : m[0] - s[2]),
              _ = e && e[a - 1],
              v = 0,
              b = 0;
            for (let r = 0; r < a; r++)
              (f = sl(t, r, n, i, f)),
                (p = Math.sign(8 & o ? f[1] - s[3] : f[0] - s[2])),
                (g = e && e[i / n + r]),
                p &&
                  y &&
                  y !== p &&
                  (el(m, f, o, s, d),
                  il(c, d) && h.push(_),
                  il(l, d) && u.push(_)),
                p <= 0
                  ? (il(c, f) && h.push(g), (v -= p))
                  : h.length && (h[h.length - 1] = 0),
                p >= 0
                  ? (il(l, f) && u.push(g), (b += p))
                  : u.length && (u[u.length - 1] = 0),
                rl(m, f),
                (y = p),
                (_ = g);
            return [
              v ? { pos: c, types: e && h } : null,
              b ? { pos: l, types: e && u } : null,
            ];
          }
          function hl(t, e, n, i) {
            const r = Math.floor((t[0] - n[0]) / e) * e + n[0],
              s = Math.floor((t[1] - n[1]) / e) * e + n[1];
            return (i[0] = r), (i[1] = s), (i[2] = r + e), (i[3] = s + e), i;
          }
          function ul(t, e, n) {
            8 & n
              ? ((t[1] += e), (t[3] += e))
              : 4 & n
              ? ((t[1] -= e), (t[3] -= e))
              : 2 & n
              ? ((t[0] += e), (t[2] += e))
              : 1 & n && ((t[0] -= e), (t[2] -= e));
          }
          function dl(t, e, n, i) {
            let r = 1 / 0,
              s = -1 / 0,
              o = 1 / 0,
              a = -1 / 0;
            for (let i = 0; i < n; i += e) {
              const e = t[i],
                n = t[i + 1];
              (r = e < r ? e : r),
                (s = e > s ? e : s),
                (o = n < o ? n : o),
                (a = n > a ? n : a);
            }
            return (
              (i[0][0] = r), (i[0][1] = o), (i[1][0] = s), (i[1][1] = a), i
            );
          }
          function fl(t, e, n, i) {
            let r = -1,
              s = -1;
            for (let o = n + 1; o < i; o += e) {
              const e = Math.abs(t[o]);
              e > r && ((r = e), (s = o - 1));
            }
            return s;
          }
          function pl(t, e, n, i, r = 85.051129) {
            const s = t[n],
              o = t[i - e];
            if (Math.abs(s - o) > 180) {
              const i = sl(t, 0, e, n);
              (i[0] += 360 * Math.round((o - s) / 360)),
                il(t, i),
                (i[1] = Math.sign(i[1]) * r),
                il(t, i),
                (i[0] = s),
                il(t, i);
            }
          }
          function gl(t, e, n, i) {
            let r,
              s = t[0];
            for (let o = n; o < i; o += e) {
              r = t[o];
              const e = r - s;
              (e > 180 || e < -180) && (r -= 360 * Math.round(e / 360)),
                (t[o] = s = r);
            }
          }
          function ml(t, e) {
            let n;
            const i = t.length / e;
            for (
              let r = 0;
              r < i && ((n = t[r * e]), (n + 180) % 360 == 0);
              r++
            );
            const r = 360 * -Math.round(n / 360);
            if (0 !== r) for (let n = 0; n < i; n++) t[n * e] += r;
          }
          class yl extends Qc {
            constructor(t) {
              super({
                ...t,
                attributes: {
                  positions: {
                    size: 3,
                    padding: 18,
                    initialize: !0,
                    type: t.fp64 ? Float64Array : Float32Array,
                  },
                  segmentTypes: { size: 1, type: Uint8ClampedArray },
                },
              });
            }
            getGeometryFromBuffer(t) {
              return this.normalize
                ? super.getGeometryFromBuffer(t)
                : () => null;
            }
            normalizeGeometry(t) {
              return this.normalize
                ? (function (t, e, n, i) {
                    let r = t;
                    if (Array.isArray(t[0])) {
                      const n = t.length * e;
                      r = new Array(n);
                      for (let n = 0; n < t.length; n++)
                        for (let i = 0; i < e; i++) r[n * e + i] = t[n][i] || 0;
                    }
                    return n
                      ? ol(r, { size: e, gridResolution: n })
                      : i
                      ? (function (t, e = {}) {
                          const {
                              size: n = 2,
                              startIndex: i = 0,
                              endIndex: r = t.length,
                              normalize: s = !0,
                            } = e,
                            o = t.slice(i, r);
                          gl(o, n, 0, r - i);
                          const a = ol(o, {
                            size: n,
                            broken: !0,
                            gridResolution: 360,
                            gridOffset: [-180, -180],
                          });
                          if (s) for (const t of a) ml(t, n);
                          return a;
                        })(r, { size: e })
                      : r;
                  })(
                    t,
                    this.positionSize,
                    this.opts.resolution,
                    this.opts.wrapLongitude
                  )
                : t;
            }
            get(t) {
              return this.attributes[t];
            }
            getGeometrySize(t) {
              if (Array.isArray(t[0])) {
                let e = 0;
                for (const n of t) e += this.getGeometrySize(n);
                return e;
              }
              const e = this.getPathLength(t);
              return e < 2 ? 0 : this.isClosed(t) ? (e < 3 ? 0 : e + 2) : e;
            }
            updateGeometryAttributes(t, e) {
              if (0 !== e.geometrySize)
                if (t && Array.isArray(t[0]))
                  for (const n of t) {
                    const t = this.getGeometrySize(n);
                    (e.geometrySize = t),
                      this.updateGeometryAttributes(n, e),
                      (e.vertexStart += t);
                  }
                else
                  this._updateSegmentTypes(t, e), this._updatePositions(t, e);
            }
            _updateSegmentTypes(t, e) {
              const { segmentTypes: n } = this.attributes,
                i = this.isClosed(t),
                { vertexStart: r, geometrySize: s } = e;
              n.fill(0, r, r + s),
                i
                  ? ((n[r] = 4), (n[r + s - 2] = 4))
                  : ((n[r] += 1), (n[r + s - 2] += 2)),
                (n[r + s - 1] = 4);
            }
            _updatePositions(t, e) {
              const { positions: n } = this.attributes;
              if (!n) return;
              const { vertexStart: i, geometrySize: r } = e,
                s = new Array(3);
              for (let e = i, o = 0; o < r; e++, o++)
                this.getPointOnPath(t, o, s),
                  (n[3 * e] = s[0]),
                  (n[3 * e + 1] = s[1]),
                  (n[3 * e + 2] = s[2]);
            }
            getPathLength(t) {
              return t.length / this.positionSize;
            }
            getPointOnPath(t, e, n = []) {
              const { positionSize: i } = this;
              e * i >= t.length && (e += 1 - t.length / i);
              const r = e * i;
              return (
                (n[0] = t[r]),
                (n[1] = t[r + 1]),
                (n[2] = (3 === i && t[r + 2]) || 0),
                n
              );
            }
            isClosed(t) {
              if (!this.normalize) return this.opts.loop;
              const { positionSize: e } = this,
                n = t.length - e;
              return (
                t[0] === t[n] &&
                t[1] === t[n + 1] &&
                (2 === e || t[2] === t[n + 2])
              );
            }
          }
          const _l = [0, 0, 0, 255],
            vl = {
              widthUnits: "meters",
              widthScale: { type: "number", min: 0, value: 1 },
              widthMinPixels: { type: "number", min: 0, value: 0 },
              widthMaxPixels: {
                type: "number",
                min: 0,
                value: Number.MAX_SAFE_INTEGER,
              },
              jointRounded: !1,
              capRounded: !1,
              miterLimit: { type: "number", min: 0, value: 4 },
              billboard: !1,
              _pathType: null,
              getPath: { type: "accessor", value: (t) => t.path },
              getColor: { type: "accessor", value: _l },
              getWidth: { type: "accessor", value: 1 },
              rounded: { deprecatedFor: ["jointRounded", "capRounded"] },
            },
            bl = {
              enter: (t, e) => (e.length ? e.subarray(e.length - t.length) : t),
            };
          class wl extends Oa {
            getShaders() {
              return super.getShaders({
                vs: "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
                fs: "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                modules: [Na, Va],
              });
            }
            get wrapLongitude() {
              return !1;
            }
            initializeState() {
              this.getAttributeManager().addInstanced({
                positions: {
                  size: 3,
                  vertexOffset: 1,
                  type: 5130,
                  fp64: this.use64bitPositions(),
                  transition: bl,
                  accessor: "getPath",
                  update: this.calculatePositions,
                  noAlloc: !0,
                  shaderAttributes: {
                    instanceLeftPositions: { vertexOffset: 0 },
                    instanceStartPositions: { vertexOffset: 1 },
                    instanceEndPositions: { vertexOffset: 2 },
                    instanceRightPositions: { vertexOffset: 3 },
                  },
                },
                instanceTypes: {
                  size: 1,
                  type: 5121,
                  update: this.calculateSegmentTypes,
                  noAlloc: !0,
                },
                instanceStrokeWidths: {
                  size: 1,
                  accessor: "getWidth",
                  transition: bl,
                  defaultValue: 1,
                },
                instanceColors: {
                  size: this.props.colorFormat.length,
                  type: 5121,
                  normalized: !0,
                  accessor: "getColor",
                  transition: bl,
                  defaultValue: _l,
                },
                instancePickingColors: {
                  size: 3,
                  type: 5121,
                  accessor: (t, { index: e, target: n }) =>
                    this.encodePickingColor(
                      t && t.__source ? t.__source.index : e,
                      n
                    ),
                },
              }),
                this.setState({
                  pathTesselator: new yl({ fp64: this.use64bitPositions() }),
                }),
                this.props.getDashArray &&
                  !this.props.extensions.length &&
                  E.removed("getDashArray", "PathStyleExtension")();
            }
            updateState({ oldProps: t, props: e, changeFlags: n }) {
              super.updateState({ props: e, oldProps: t, changeFlags: n });
              const i = this.getAttributeManager();
              if (
                n.dataChanged ||
                (n.updateTriggersChanged &&
                  (n.updateTriggersChanged.all ||
                    n.updateTriggersChanged.getPath))
              ) {
                const { pathTesselator: t } = this.state,
                  r = e.data.attributes || {};
                t.updateGeometry({
                  data: e.data,
                  geometryBuffer: r.getPath,
                  buffers: r,
                  normalize: !e._pathType,
                  loop: "loop" === e._pathType,
                  getGeometry: e.getPath,
                  positionFormat: e.positionFormat,
                  wrapLongitude: e.wrapLongitude,
                  resolution: this.context.viewport.resolution,
                  dataChanged: n.dataChanged,
                }),
                  this.setState({
                    numInstances: t.instanceCount,
                    startIndices: t.vertexStarts,
                  }),
                  n.dataChanged || i.invalidateAll();
              }
              if (n.extensionsChanged) {
                var r;
                const { gl: t } = this.context;
                null === (r = this.state.model) || void 0 === r || r.delete(),
                  (this.state.model = this._getModel(t)),
                  i.invalidateAll();
              }
            }
            getPickingInfo(t) {
              const e = super.getPickingInfo(t),
                { index: n } = e,
                { data: i } = this.props;
              return (
                i[0] &&
                  i[0].__source &&
                  (e.object = i.find((t) => t.__source.index === n)),
                e
              );
            }
            disablePickingIndex(t) {
              const { data: e } = this.props;
              if (e[0] && e[0].__source)
                for (let n = 0; n < e.length; n++)
                  e[n].__source.index === t && this._disablePickingIndex(n);
              else this._disablePickingIndex(t);
            }
            draw({ uniforms: t }) {
              const {
                jointRounded: e,
                capRounded: n,
                billboard: i,
                miterLimit: r,
                widthUnits: s,
                widthScale: o,
                widthMinPixels: a,
                widthMaxPixels: c,
              } = this.props;
              this.state.model
                .setUniforms(t)
                .setUniforms({
                  jointType: Number(e),
                  capType: Number(n),
                  billboard: i,
                  widthUnits: S[s],
                  widthScale: o,
                  miterLimit: r,
                  widthMinPixels: a,
                  widthMaxPixels: c,
                })
                .draw();
            }
            _getModel(t) {
              return new cr(t, {
                ...this.getShaders(),
                id: this.props.id,
                geometry: new Wa({
                  drawMode: 4,
                  attributes: {
                    indices: new Uint16Array([
                      0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4,
                    ]),
                    positions: {
                      value: new Float32Array([
                        0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0,
                      ]),
                      size: 2,
                    },
                  },
                }),
                isInstanced: !0,
              });
            }
            calculatePositions(t) {
              const { pathTesselator: e } = this.state;
              (t.startIndices = e.vertexStarts), (t.value = e.get("positions"));
            }
            calculateSegmentTypes(t) {
              const { pathTesselator: e } = this.state;
              (t.startIndices = e.vertexStarts),
                (t.value = e.get("segmentTypes"));
            }
          }
          (wl.layerName = "PathLayer"), (wl.defaultProps = vl);
          const xl =
              "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",
            Pl = { lightSources: {} };
          function El({ color: t = [0, 0, 0], intensity: e = 1 } = {}) {
            return t.map((t) => (t * e) / 255);
          }
          const Al = {};
          const Tl = {
            name: "gouraud-lighting",
            dependencies: [
              {
                name: "lights",
                vs: xl,
                fs: xl,
                getUniforms: function t(e = Pl) {
                  if ("lightSources" in e) {
                    const {
                      ambientLight: t,
                      pointLights: n,
                      directionalLights: i,
                    } = e.lightSources || {};
                    return t || (n && n.length > 0) || (i && i.length > 0)
                      ? Object.assign(
                          {},
                          (function ({
                            ambientLight: t,
                            pointLights: e = [],
                            directionalLights: n = [],
                          }) {
                            const i = {};
                            return (
                              (i["lighting_uAmbientLight.color"] = t
                                ? El(t)
                                : [0, 0, 0]),
                              e.forEach((t, e) => {
                                (i[`lighting_uPointLight[${e}].color`] = El(t)),
                                  (i[`lighting_uPointLight[${e}].position`] =
                                    t.position),
                                  (i[`lighting_uPointLight[${e}].attenuation`] =
                                    t.attenuation || [1, 0, 0]);
                              }),
                              (i.lighting_uPointLightCount = e.length),
                              n.forEach((t, e) => {
                                (i[`lighting_uDirectionalLight[${e}].color`] =
                                  El(t)),
                                  (i[
                                    `lighting_uDirectionalLight[${e}].direction`
                                  ] = t.direction);
                              }),
                              (i.lighting_uDirectionalLightCount = n.length),
                              i
                            );
                          })({
                            ambientLight: t,
                            pointLights: n,
                            directionalLights: i,
                          }),
                          { lighting_uEnabled: !0 }
                        )
                      : { lighting_uEnabled: !1 };
                  }
                  if ("lights" in e) {
                    const n = { pointLights: [], directionalLights: [] };
                    for (const t of e.lights || [])
                      switch (t.type) {
                        case "ambient":
                          n.ambientLight = t;
                          break;
                        case "directional":
                          n.directionalLights.push(t);
                          break;
                        case "point":
                          n.pointLights.push(t);
                      }
                    return t({ lightSources: n });
                  }
                  return {};
                },
                defines: { MAX_LIGHTS: 3 },
              },
            ],
            vs: "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",
            defines: { LIGHTING_VERTEX: 1 },
            getUniforms: function (t = Al) {
              if (!("material" in t)) return {};
              const { material: e } = t;
              return e
                ? (function (t) {
                    const {
                      ambient: e = 0.35,
                      diffuse: n = 0.6,
                      shininess: i = 32,
                      specularColor: r = [30, 30, 30],
                    } = t;
                    return {
                      lighting_uAmbient: e,
                      lighting_uDiffuse: n,
                      lighting_uShininess: i,
                      lighting_uSpecularColor: r.map((t) => t / 255),
                    };
                  })(e)
                : { lighting_uEnabled: !1 };
            },
          };
          var Sl = n(282),
            Ml = n.n(Sl);
          const Cl = { isClosed: !0 };
          function Ll(t, e, n, i, r) {
            let s = e;
            const o = n.length;
            for (let e = 0; e < o; e++)
              for (let r = 0; r < i; r++) t[s++] = n[e][r] || 0;
            if (
              !(function (t) {
                const e = t[0],
                  n = t[t.length - 1];
                return e[0] === n[0] && e[1] === n[1] && e[2] === n[2];
              })(n)
            )
              for (let e = 0; e < i; e++) t[s++] = n[0][e] || 0;
            return (Cl.start = e), (Cl.end = s), (Cl.size = i), tl(t, r, Cl), s;
          }
          function Ol(t, e, n, i, r = 0, s, o) {
            const a = (s = s || n.length) - r;
            if (a <= 0) return e;
            let c = e;
            for (let e = 0; e < a; e++) t[c++] = n[r + e];
            if (
              !(function (t, e, n, i) {
                for (let r = 0; r < e; r++)
                  if (t[n + r] !== t[i - e + r]) return !1;
                return !0;
              })(n, i, r, s)
            )
              for (let e = 0; e < i; e++) t[c++] = n[r + e];
            return (Cl.start = e), (Cl.end = c), (Cl.size = i), tl(t, o, Cl), c;
          }
          class Il extends Qc {
            constructor(t) {
              const { fp64: e, IndexType: n = Uint32Array } = t;
              super({
                ...t,
                attributes: {
                  positions: { size: 3, type: e ? Float64Array : Float32Array },
                  vertexValid: { type: Uint8ClampedArray, size: 1 },
                  indices: { type: n, size: 1 },
                },
              });
            }
            get(t) {
              const { attributes: e } = this;
              return "indices" === t
                ? e.indices && e.indices.subarray(0, this.vertexCount)
                : e[t];
            }
            updateGeometry(t) {
              super.updateGeometry(t);
              const e = this.buffers.indices;
              e && (this.vertexCount = (e.value || e).length);
            }
            normalizeGeometry(t) {
              if (this.normalize) {
                if (
                  ((t = (function (t, e) {
                    !(function (t) {
                      if (
                        ((t = (t && t.positions) || t),
                        !Array.isArray(t) && !ArrayBuffer.isView(t))
                      )
                        throw new Error("invalid polygon");
                    })(t);
                    const n = [],
                      i = [];
                    if (t.positions) {
                      const { positions: r, holeIndices: s } = t;
                      if (s) {
                        let t = 0;
                        for (let o = 0; o <= s.length; o++)
                          (t = Ol(
                            n,
                            t,
                            r,
                            e,
                            s[o - 1],
                            s[o],
                            0 === o ? 1 : -1
                          )),
                            i.push(t);
                        return i.pop(), { positions: n, holeIndices: i };
                      }
                      t = r;
                    }
                    if (Number.isFinite(t[0]))
                      return Ol(n, 0, t, e, 0, n.length, 1), n;
                    if (
                      !(function (t) {
                        return (
                          t.length >= 1 &&
                          t[0].length >= 2 &&
                          Number.isFinite(t[0][0])
                        );
                      })(t)
                    ) {
                      let r = 0;
                      for (const [s, o] of t.entries())
                        (r = Ll(n, r, o, e, 0 === s ? 1 : -1)), i.push(r);
                      return i.pop(), { positions: n, holeIndices: i };
                    }
                    return Ll(n, 0, t, e, 1), n;
                  })(t, this.positionSize)),
                  this.opts.resolution)
                )
                  return cl(t.positions || t, t.holeIndices, {
                    size: this.positionSize,
                    gridResolution: this.opts.resolution,
                    edgeTypes: !0,
                  });
                if (this.opts.wrapLongitude)
                  return (function (t, e, n = {}) {
                    const {
                      size: i = 2,
                      normalize: r = !0,
                      edgeTypes: s = !1,
                    } = n;
                    e = e || [];
                    const o = [],
                      a = [];
                    let c = 0,
                      l = 0;
                    for (let r = 0; r <= e.length; r++) {
                      const s = e[r] || t.length,
                        h = l,
                        u = fl(t, i, c, s);
                      for (let e = u; e < s; e++) o[l++] = t[e];
                      for (let e = c; e < u; e++) o[l++] = t[e];
                      gl(o, i, h, l),
                        pl(o, i, h, l, n.maxLatitude),
                        (c = s),
                        (a[r] = l);
                    }
                    a.pop();
                    const h = cl(o, a, {
                      size: i,
                      gridResolution: 360,
                      gridOffset: [-180, -180],
                      edgeTypes: s,
                    });
                    if (r) for (const t of h) ml(t.positions, i);
                    return h;
                  })(t.positions || t, t.holeIndices, {
                    size: this.positionSize,
                    maxLatitude: 86,
                    edgeTypes: !0,
                  });
              }
              return t;
            }
            getGeometrySize(t) {
              if (Array.isArray(t) && !Number.isFinite(t[0])) {
                let e = 0;
                for (const n of t) e += this.getGeometrySize(n);
                return e;
              }
              return (t.positions || t).length / this.positionSize;
            }
            getGeometryFromBuffer(t) {
              return this.normalize || !this.buffers.indices
                ? super.getGeometryFromBuffer(t)
                : () => null;
            }
            updateGeometryAttributes(t, e) {
              if (Array.isArray(t) && !Number.isFinite(t[0]))
                for (const n of t) {
                  const t = this.getGeometrySize(n);
                  (e.geometrySize = t),
                    this.updateGeometryAttributes(n, e),
                    (e.vertexStart += t),
                    (e.indexStart = this.indexStarts[e.geometryIndex + 1]);
                }
              else
                this._updateIndices(t, e),
                  this._updatePositions(t, e),
                  this._updateVertexValid(t, e);
            }
            _updateIndices(
              t,
              { geometryIndex: e, vertexStart: n, indexStart: i }
            ) {
              const {
                attributes: r,
                indexStarts: s,
                typedArrayManager: o,
              } = this;
              let a = r.indices;
              if (!a) return;
              let c = i;
              const l = (function (t, e, n) {
                let i = null;
                t.holeIndices && (i = t.holeIndices.map((t) => t / e));
                let r = t.positions || t;
                if (n) {
                  const t = r.length;
                  r = r.slice();
                  const i = [];
                  for (let s = 0; s < t; s += e) {
                    (i[0] = r[s]), (i[1] = r[s + 1]);
                    const t = n(i);
                    (r[s] = t[0]), (r[s + 1] = t[1]);
                  }
                }
                return Ml()(r, i, e);
              })(t, this.positionSize, this.opts.preproject);
              a = o.allocate(a, i + l.length, { copy: !0 });
              for (let t = 0; t < l.length; t++) a[c++] = l[t] + n;
              (s[e + 1] = i + l.length), (r.indices = a);
            }
            _updatePositions(t, { vertexStart: e, geometrySize: n }) {
              const {
                attributes: { positions: i },
                positionSize: r,
              } = this;
              if (!i) return;
              const s = t.positions || t;
              for (let t = e, o = 0; o < n; t++, o++) {
                const e = s[o * r],
                  n = s[o * r + 1],
                  a = r > 2 ? s[o * r + 2] : 0;
                (i[3 * t] = e), (i[3 * t + 1] = n), (i[3 * t + 2] = a);
              }
            }
            _updateVertexValid(t, { vertexStart: e, geometrySize: n }) {
              const {
                  attributes: { vertexValid: i },
                  positionSize: r,
                } = this,
                s = t && t.holeIndices;
              if (
                (t && t.edgeTypes ? i.set(t.edgeTypes, e) : i.fill(1, e, e + n),
                s)
              )
                for (let t = 0; t < s.length; t++) i[e + s[t] / r - 1] = 0;
              i[e + n - 1] = 0;
            }
          }
          const Rl =
              "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",
            kl =
              "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(
                Rl,
                "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"
              ),
            Fl =
              "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(
                Rl,
                "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"
              ),
            zl = [0, 0, 0, 255],
            jl = {
              filled: !0,
              extruded: !1,
              wireframe: !1,
              _normalize: !0,
              _windingOrder: "CW",
              elevationScale: { type: "number", min: 0, value: 1 },
              getPolygon: { type: "accessor", value: (t) => t.polygon },
              getElevation: { type: "accessor", value: 1e3 },
              getFillColor: { type: "accessor", value: zl },
              getLineColor: { type: "accessor", value: zl },
              material: !0,
            },
            Bl = {
              enter: (t, e) => (e.length ? e.subarray(e.length - t.length) : t),
            };
          class Dl extends Oa {
            getShaders(t) {
              return super.getShaders({
                vs: "top" === t ? kl : Fl,
                fs: "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",
                defines: {
                  RING_WINDING_ORDER_CW:
                    this.props._normalize || "CCW" !== this.props._windingOrder
                      ? 1
                      : 0,
                },
                modules: [Na, Tl, Va],
              });
            }
            get wrapLongitude() {
              return !1;
            }
            initializeState() {
              const { gl: t, viewport: e } = this.context;
              let { coordinateSystem: n } = this.props;
              e.isGeospatial && n === A.DEFAULT && (n = A.LNGLAT),
                this.setState({
                  numInstances: 0,
                  polygonTesselator: new Il({
                    preproject: n === A.LNGLAT && e.projectFlat,
                    fp64: this.use64bitPositions(),
                    IndexType: !t || we(t, ve) ? Uint32Array : Uint16Array,
                  }),
                });
              const i = this.getAttributeManager(),
                r = !0;
              i.remove(["instancePickingColors"]),
                i.add({
                  indices: {
                    size: 1,
                    isIndexed: !0,
                    update: this.calculateIndices,
                    noAlloc: r,
                  },
                  positions: {
                    size: 3,
                    type: 5130,
                    fp64: this.use64bitPositions(),
                    transition: Bl,
                    accessor: "getPolygon",
                    update: this.calculatePositions,
                    noAlloc: r,
                    shaderAttributes: {
                      positions: { vertexOffset: 0, divisor: 0 },
                      instancePositions: { vertexOffset: 0, divisor: 1 },
                      nextPositions: { vertexOffset: 1, divisor: 1 },
                    },
                  },
                  vertexValid: {
                    size: 1,
                    divisor: 1,
                    type: 5121,
                    update: this.calculateVertexValid,
                    noAlloc: r,
                  },
                  elevations: {
                    size: 1,
                    transition: Bl,
                    accessor: "getElevation",
                    shaderAttributes: {
                      elevations: { divisor: 0 },
                      instanceElevations: { divisor: 1 },
                    },
                  },
                  fillColors: {
                    alias: "colors",
                    size: this.props.colorFormat.length,
                    type: 5121,
                    normalized: !0,
                    transition: Bl,
                    accessor: "getFillColor",
                    defaultValue: zl,
                    shaderAttributes: {
                      fillColors: { divisor: 0 },
                      instanceFillColors: { divisor: 1 },
                    },
                  },
                  lineColors: {
                    alias: "colors",
                    size: this.props.colorFormat.length,
                    type: 5121,
                    normalized: !0,
                    transition: Bl,
                    accessor: "getLineColor",
                    defaultValue: zl,
                    shaderAttributes: {
                      lineColors: { divisor: 0 },
                      instanceLineColors: { divisor: 1 },
                    },
                  },
                  pickingColors: {
                    size: 3,
                    type: 5121,
                    accessor: (t, { index: e, target: n }) =>
                      this.encodePickingColor(
                        t && t.__source ? t.__source.index : e,
                        n
                      ),
                    shaderAttributes: {
                      pickingColors: { divisor: 0 },
                      instancePickingColors: { divisor: 1 },
                    },
                  },
                });
            }
            getPickingInfo(t) {
              const e = super.getPickingInfo(t),
                { index: n } = e,
                { data: i } = this.props;
              return (
                i[0] &&
                  i[0].__source &&
                  (e.object = i.find((t) => t.__source.index === n)),
                e
              );
            }
            disablePickingIndex(t) {
              const { data: e } = this.props;
              if (e[0] && e[0].__source)
                for (let n = 0; n < e.length; n++)
                  e[n].__source.index === t && this._disablePickingIndex(n);
              else this._disablePickingIndex(t);
            }
            draw({ uniforms: t }) {
              const {
                  extruded: e,
                  filled: n,
                  wireframe: i,
                  elevationScale: r,
                } = this.props,
                {
                  topModel: s,
                  sideModel: o,
                  polygonTesselator: a,
                } = this.state,
                c = { ...t, extruded: Boolean(e), elevationScale: r };
              o &&
                (o.setInstanceCount(a.instanceCount - 1),
                o.setUniforms(c),
                i &&
                  (o.setDrawMode(3), o.setUniforms({ isWireframe: !0 }).draw()),
                n &&
                  (o.setDrawMode(6),
                  o.setUniforms({ isWireframe: !1 }).draw())),
                s && (s.setVertexCount(a.vertexCount), s.setUniforms(c).draw());
            }
            updateState(t) {
              super.updateState(t), this.updateGeometry(t);
              const { props: e, oldProps: n, changeFlags: i } = t,
                r = this.getAttributeManager();
              var s;
              (i.extensionsChanged ||
                e.filled !== n.filled ||
                e.extruded !== n.extruded) &&
                (null === (s = this.state.models) ||
                  void 0 === s ||
                  s.forEach((t) => t.delete()),
                this.setState(this._getModels(this.context.gl)),
                r.invalidateAll());
            }
            updateGeometry({ props: t, oldProps: e, changeFlags: n }) {
              if (
                n.dataChanged ||
                (n.updateTriggersChanged &&
                  (n.updateTriggersChanged.all ||
                    n.updateTriggersChanged.getPolygon))
              ) {
                const { polygonTesselator: e } = this.state,
                  i = t.data.attributes || {};
                e.updateGeometry({
                  data: t.data,
                  normalize: t._normalize,
                  geometryBuffer: i.getPolygon,
                  buffers: i,
                  getGeometry: t.getPolygon,
                  positionFormat: t.positionFormat,
                  wrapLongitude: t.wrapLongitude,
                  resolution: this.context.viewport.resolution,
                  fp64: this.use64bitPositions(),
                  dataChanged: n.dataChanged,
                }),
                  this.setState({
                    numInstances: e.instanceCount,
                    startIndices: e.vertexStarts,
                  }),
                  n.dataChanged || this.getAttributeManager().invalidateAll();
              }
            }
            _getModels(t) {
              const { id: e, filled: n, extruded: i } = this.props;
              let r, s;
              if (n) {
                const n = this.getShaders("top");
                (n.defines.NON_INSTANCED_MODEL = 1),
                  (r = new cr(t, {
                    ...n,
                    id: "".concat(e, "-top"),
                    drawMode: 4,
                    attributes: { vertexPositions: new Float32Array([0, 1]) },
                    uniforms: { isWireframe: !1, isSideVertex: !1 },
                    vertexCount: 0,
                    isIndexed: !0,
                  }));
              }
              return (
                i &&
                  ((s = new cr(t, {
                    ...this.getShaders("side"),
                    id: "".concat(e, "-side"),
                    geometry: new Wa({
                      drawMode: 1,
                      vertexCount: 4,
                      attributes: {
                        vertexPositions: {
                          size: 2,
                          value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1]),
                        },
                      },
                    }),
                    instanceCount: 0,
                    isInstanced: 1,
                  })),
                  (s.userData.excludeAttributes = { indices: !0 })),
                { models: [s, r].filter(Boolean), topModel: r, sideModel: s }
              );
            }
            calculateIndices(t) {
              const { polygonTesselator: e } = this.state;
              (t.startIndices = e.indexStarts), (t.value = e.get("indices"));
            }
            calculatePositions(t) {
              const { polygonTesselator: e } = this.state;
              (t.startIndices = e.vertexStarts), (t.value = e.get("positions"));
            }
            calculateVertexValid(t) {
              t.value = this.state.polygonTesselator.get("vertexValid");
            }
          }
          (Dl.layerName = "SolidPolygonLayer"), (Dl.defaultProps = jl);
          const Nl = {
              circle: {
                type: Ac,
                props: {
                  filled: "filled",
                  stroked: "stroked",
                  lineWidthMaxPixels: "lineWidthMaxPixels",
                  lineWidthMinPixels: "lineWidthMinPixels",
                  lineWidthScale: "lineWidthScale",
                  lineWidthUnits: "lineWidthUnits",
                  pointRadiusMaxPixels: "radiusMaxPixels",
                  pointRadiusMinPixels: "radiusMinPixels",
                  pointRadiusScale: "radiusScale",
                  pointRadiusUnits: "radiusUnits",
                  pointAntialiasing: "antialiasing",
                  getFillColor: "getFillColor",
                  getLineColor: "getLineColor",
                  getLineWidth: "getLineWidth",
                  getPointRadius: "getRadius",
                },
              },
              icon: {
                type: xc,
                props: {
                  iconAtlas: "iconAtlas",
                  iconMapping: "iconMapping",
                  iconSizeMaxPixels: "sizeMaxPixels",
                  iconSizeMinPixels: "sizeMinPixels",
                  iconSizeScale: "sizeScale",
                  iconSizeUnits: "sizeUnits",
                  getIcon: "getIcon",
                  getIconAngle: "getAngle",
                  getIconColor: "getColor",
                  getIconPixelOffset: "getPixelOffset",
                  getIconSize: "getSize",
                },
              },
              text: {
                type: Jc,
                props: {
                  textSizeMaxPixels: "sizeMaxPixels",
                  textSizeMinPixels: "sizeMinPixels",
                  textSizeScale: "sizeScale",
                  textSizeUnits: "sizeUnits",
                  textBackground: "background",
                  textBackgroundPadding: "backgroundPadding",
                  textFontFamily: "fontFamily",
                  textFontWeight: "fontWeight",
                  textLineHeight: "lineHeight",
                  textMaxWidth: "maxWidth",
                  textOutlineColor: "outlineColor",
                  textOutlineWidth: "outlineWidth",
                  textWordBreak: "wordBreak",
                  textCharacterSet: "characterSet",
                  getText: "getText",
                  getTextAngle: "getAngle",
                  getTextColor: "getColor",
                  getTextPixelOffset: "getPixelOffset",
                  getTextSize: "getSize",
                  getTextAnchor: "getTextAnchor",
                  getTextAlignmentBaseline: "getAlignmentBaseline",
                  getTextBackgroundColor: "getBackgroundColor",
                  getTextBorderColor: "getBorderColor",
                  getTextBorderWidth: "getBorderWidth",
                },
              },
            },
            Ul = {
              type: wl,
              props: {
                lineWidthUnits: "widthUnits",
                lineWidthScale: "widthScale",
                lineWidthMinPixels: "widthMinPixels",
                lineWidthMaxPixels: "widthMaxPixels",
                lineJointRounded: "jointRounded",
                lineCapRounded: "capRounded",
                lineMiterLimit: "miterLimit",
                getLineColor: "getColor",
                getLineWidth: "getWidth",
              },
            },
            Vl = {
              type: Dl,
              props: {
                extruded: "extruded",
                filled: "filled",
                wireframe: "wireframe",
                elevationScale: "elevationScale",
                material: "material",
                getElevation: "getElevation",
                getFillColor: "getFillColor",
                getLineColor: "getLineColor",
              },
            };
          function Gl({ type: t, props: e }) {
            const n = {};
            for (const i in e) n[i] = t.defaultProps[e[i]];
            return n;
          }
          function Wl(t, e) {
            const { transitions: n, updateTriggers: i } = t.props,
              r = {
                updateTriggers: {},
                transitions: n && { getPosition: n.geometry },
              };
            for (const s in e) {
              const o = e[s];
              let a = t.props[s];
              s.startsWith("get") &&
                ((a = t.getSubLayerAccessor(a)),
                (r.updateTriggers[o] = i[s]),
                n && (r.transitions[o] = n[s])),
                (r[o] = a);
            }
            return r;
          }
          function Hl(t, e, n = {}) {
            const i = {
                pointFeatures: [],
                lineFeatures: [],
                polygonFeatures: [],
                polygonOutlineFeatures: [],
              },
              { startRow: r = 0, endRow: s = t.length } = n;
            for (let n = r; n < s; n++) {
              const r = t[n];
              E.assert(r && r.geometry, "GeoJSON does not have geometry");
              const { geometry: s } = r;
              if ("GeometryCollection" === s.type) {
                E.assert(
                  Array.isArray(s.geometries),
                  "GeoJSON does not have geometries array"
                );
                const { geometries: t } = s;
                for (let s = 0; s < t.length; s++) $l(t[s], i, e, r, n);
              } else $l(s, i, e, r, n);
            }
            return i;
          }
          function $l(t, e, n, i, r) {
            const { type: s, coordinates: o } = t,
              {
                pointFeatures: a,
                lineFeatures: c,
                polygonFeatures: l,
                polygonOutlineFeatures: h,
              } = e;
            if (
              (function (t, e) {
                let n = Xl[t];
                for (
                  E.assert(n, "Unknown GeoJSON type ".concat(t));
                  e && --n > 0;

                )
                  e = e[0];
                return e && Number.isFinite(e[0]);
              })(s, o)
            )
              switch (s) {
                case "Point":
                  a.push(n({ geometry: t }, i, r));
                  break;
                case "MultiPoint":
                  o.forEach((t) => {
                    a.push(
                      n({ geometry: { type: "Point", coordinates: t } }, i, r)
                    );
                  });
                  break;
                case "LineString":
                  c.push(n({ geometry: t }, i, r));
                  break;
                case "MultiLineString":
                  o.forEach((t) => {
                    c.push(
                      n(
                        { geometry: { type: "LineString", coordinates: t } },
                        i,
                        r
                      )
                    );
                  });
                  break;
                case "Polygon":
                  l.push(n({ geometry: t }, i, r)),
                    o.forEach((t) => {
                      h.push(
                        n(
                          { geometry: { type: "LineString", coordinates: t } },
                          i,
                          r
                        )
                      );
                    });
                  break;
                case "MultiPolygon":
                  o.forEach((t) => {
                    l.push(
                      n({ geometry: { type: "Polygon", coordinates: t } }, i, r)
                    ),
                      t.forEach((t) => {
                        h.push(
                          n(
                            {
                              geometry: { type: "LineString", coordinates: t },
                            },
                            i,
                            r
                          )
                        );
                      });
                  });
              }
            else E.warn("".concat(s, " coordinates are malformed"))();
          }
          const Xl = {
            Point: 1,
            MultiPoint: 2,
            LineString: 2,
            MultiLineString: 3,
            Polygon: 3,
            MultiPolygon: 4,
          };
          function Yl(t) {
            return t.geometry.coordinates;
          }
          const ql = {
            ...Gl(Nl.circle),
            ...Gl(Nl.icon),
            ...Gl(Nl.text),
            ...Gl(Ul),
            ...Gl(Vl),
            stroked: !0,
            filled: !0,
            extruded: !1,
            wireframe: !1,
            iconAtlas: { type: "object", value: null },
            iconMapping: { type: "object", value: {} },
            getIcon: { type: "accessor", value: (t) => t.properties.icon },
            getText: { type: "accessor", value: (t) => t.properties.text },
            pointType: "circle",
            getRadius: { deprecatedFor: "getPointRadius" },
          };
          class Zl extends Ia {
            initializeState() {
              (this.state = { layerProps: {}, features: {} }),
                this.props.getLineDashArray &&
                  E.removed("getLineDashArray", "PathStyleExtension")();
            }
            updateState({ props: t, changeFlags: e }) {
              if (!e.dataChanged) return;
              const { data: n } = this.props,
                i = n && "points" in n && "polygons" in n && "lines" in n;
              this.setState({ binary: i }),
                i
                  ? this._updateStateBinary({ props: t, changeFlags: e })
                  : this._updateStateJSON({ props: t, changeFlags: e });
            }
            _updateStateBinary({ props: t, changeFlags: e }) {
              const n = (function (t, e) {
                const n = {
                    points: {},
                    lines: {},
                    polygons: {},
                    polygonsOutline: {},
                  },
                  { points: i, lines: r, polygons: s } = t,
                  o = (function (t, e) {
                    const n = { points: null, lines: null, polygons: null };
                    for (const i in n) {
                      const r = t[i].globalFeatureIds.value;
                      n[i] = new Uint8ClampedArray(3 * r.length);
                      const s = [];
                      for (let t = 0; t < r.length; t++)
                        e(r[t], s),
                          (n[i][3 * t + 0] = s[0]),
                          (n[i][3 * t + 1] = s[1]),
                          (n[i][3 * t + 2] = s[2]);
                    }
                    return n;
                  })(t, e);
                return (
                  (n.points.data = {
                    length: i.positions.value.length / i.positions.size,
                    attributes: {
                      getPosition: i.positions,
                      instancePickingColors: { size: 3, value: o.points },
                    },
                    properties: i.properties,
                    numericProps: i.numericProps,
                    featureIds: i.featureIds,
                  }),
                  (n.lines.data = {
                    length: r.pathIndices.value.length - 1,
                    startIndices: r.pathIndices.value,
                    attributes: {
                      getPath: r.positions,
                      instancePickingColors: { size: 3, value: o.lines },
                    },
                    properties: r.properties,
                    numericProps: r.numericProps,
                    featureIds: r.featureIds,
                  }),
                  (n.lines._pathType = "open"),
                  (n.polygons.data = {
                    length: s.polygonIndices.value.length - 1,
                    startIndices: s.polygonIndices.value,
                    attributes: {
                      getPolygon: s.positions,
                      pickingColors: { size: 3, value: o.polygons },
                    },
                    properties: s.properties,
                    numericProps: s.numericProps,
                    featureIds: s.featureIds,
                  }),
                  (n.polygons._normalize = !1),
                  s.triangles &&
                    (n.polygons.data.attributes.indices = s.triangles.value),
                  (n.polygonsOutline.data = {
                    length: s.primitivePolygonIndices.value.length - 1,
                    startIndices: s.primitivePolygonIndices.value,
                    attributes: {
                      getPath: s.positions,
                      instancePickingColors: { size: 3, value: o.polygons },
                    },
                    properties: s.properties,
                    numericProps: s.numericProps,
                    featureIds: s.featureIds,
                  }),
                  (n.polygonsOutline._pathType = "open"),
                  n
                );
              })(t.data, this.encodePickingColor);
              this.setState({ layerProps: n });
            }
            _updateStateJSON({ props: t, changeFlags: e }) {
              const n = (function (t) {
                  if (Array.isArray(t)) return t;
                  switch (
                    (E.assert(t.type, "GeoJSON does not have type"), t.type)
                  ) {
                    case "Feature":
                      return [t];
                    case "FeatureCollection":
                      return (
                        E.assert(
                          Array.isArray(t.features),
                          "GeoJSON does not have features array"
                        ),
                        t.features
                      );
                    default:
                      return [{ geometry: t }];
                  }
                })(t.data),
                i = this.getSubLayerRow.bind(this);
              let r = {};
              const s = {};
              if (Array.isArray(e.dataChanged)) {
                const t = this.state.features;
                for (const e in t) (r[e] = t[e].slice()), (s[e] = []);
                for (const o of e.dataChanged) {
                  const e = Hl(n, i, o);
                  for (const n in t)
                    s[n].push(
                      Ra({
                        data: r[n],
                        getIndex: (t) => t.__source.index,
                        dataRange: o,
                        replace: e[n],
                      })
                    );
                }
              } else r = Hl(n, i);
              const o = (function (t, e) {
                const n = {
                    points: {},
                    lines: {},
                    polygons: {},
                    polygonsOutline: {},
                  },
                  {
                    pointFeatures: i,
                    lineFeatures: r,
                    polygonFeatures: s,
                    polygonOutlineFeatures: o,
                  } = t;
                return (
                  (n.points.data = i),
                  (n.points._dataDiff =
                    e.pointFeatures && (() => e.pointFeatures)),
                  (n.points.getPosition = Yl),
                  (n.lines.data = r),
                  (n.lines._dataDiff =
                    e.lineFeatures && (() => e.lineFeatures)),
                  (n.lines.getPath = Yl),
                  (n.polygons.data = s),
                  (n.polygons._dataDiff =
                    e.polygonFeatures && (() => e.polygonFeatures)),
                  (n.polygons.getPolygon = Yl),
                  (n.polygonsOutline.data = o),
                  (n.polygonsOutline._dataDiff =
                    e.polygonOutlineFeatures &&
                    (() => e.polygonOutlineFeatures)),
                  (n.polygonsOutline.getPath = Yl),
                  n
                );
              })(r, s);
              this.setState({ features: r, featuresDiff: s, layerProps: o });
            }
            _updateAutoHighlight(t) {
              const e = "".concat(this.id, "-points-"),
                n = t.sourceLayer.id.startsWith(e);
              for (const i of this.getSubLayers())
                i.id.startsWith(e) === n && i.updateAutoHighlight(t);
            }
            _renderPolygonLayer() {
              const { extruded: t, wireframe: e } = this.props,
                { layerProps: n } = this.state,
                i = "polygons-fill",
                r =
                  this.shouldRenderSubLayer(i, n.polygons.data) &&
                  this.getSubLayerClass(i, Vl.type);
              if (r) {
                const s = Wl(this, Vl.props),
                  o = t && e;
                return (
                  o || delete s.getLineColor,
                  (s.updateTriggers.lineColors = o),
                  new r(
                    s,
                    this.getSubLayerProps({
                      id: i,
                      updateTriggers: s.updateTriggers,
                    }),
                    n.polygons
                  )
                );
              }
              return null;
            }
            _renderLineLayers() {
              const { extruded: t, stroked: e } = this.props,
                { layerProps: n } = this.state,
                i = "polygons-stroke",
                r = "linestrings",
                s =
                  !t &&
                  e &&
                  this.shouldRenderSubLayer(i, n.polygonsOutline.data) &&
                  this.getSubLayerClass(i, Ul.type),
                o =
                  this.shouldRenderSubLayer(r, n.lines.data) &&
                  this.getSubLayerClass(r, Ul.type);
              if (s || o) {
                const t = Wl(this, Ul.props);
                return [
                  s &&
                    new s(
                      t,
                      this.getSubLayerProps({
                        id: i,
                        updateTriggers: t.updateTriggers,
                      }),
                      n.polygonsOutline
                    ),
                  o &&
                    new o(
                      t,
                      this.getSubLayerProps({
                        id: r,
                        updateTriggers: t.updateTriggers,
                      }),
                      n.lines
                    ),
                ];
              }
              return null;
            }
            _renderPointLayers() {
              const { pointType: t } = this.props,
                { layerProps: e, binary: n } = this.state;
              let { highlightedObjectIndex: i } = this.props;
              !n &&
                Number.isFinite(i) &&
                (i = e.points.data.findIndex((t) => t.__source.index === i));
              const r = new Set(t.split("+")),
                s = [];
              for (const t of r) {
                const n = "points-".concat(t),
                  r = Nl[t],
                  o =
                    r &&
                    this.shouldRenderSubLayer(n, e.points.data) &&
                    this.getSubLayerClass(n, r.type);
                if (o) {
                  const t = Wl(this, r.props);
                  s.push(
                    new o(
                      t,
                      this.getSubLayerProps({
                        id: n,
                        updateTriggers: t.updateTriggers,
                        highlightedObjectIndex: i,
                      }),
                      e.points
                    )
                  );
                }
              }
              return s;
            }
            renderLayers() {
              const { extruded: t } = this.props,
                e = this._renderPolygonLayer();
              return [
                !t && e,
                this._renderLineLayers(),
                this._renderPointLayers(),
                t && e,
              ];
            }
            getSubLayerAccessor(t) {
              const { binary: e } = this.state;
              return e && "function" == typeof t
                ? (e, n) => {
                    const { data: i, index: r } = n,
                      s = (function (t, e) {
                        if (!t) return null;
                        const n = "startIndices" in t ? t.startIndices[e] : e,
                          i = t.featureIds.value[n];
                        return -1 !== n
                          ? (function (t, e, n) {
                              const i = { properties: { ...t.properties[e] } };
                              for (const e in t.numericProps)
                                i.properties[e] = t.numericProps[e].value[n];
                              return i;
                            })(t, i, n)
                          : null;
                      })(i, r);
                    return t(s, n);
                  }
                : super.getSubLayerAccessor(t);
            }
          }
          (Zl.layerName = "GeoJsonLayer"), (Zl.defaultProps = ql);
          let Kl = 1,
            Jl = 1;
          class Ql {
            constructor() {
              (this.time = 0),
                (this.channels = new Map()),
                (this.animations = new Map()),
                (this.playing = !1),
                (this.lastEngineTime = -1);
            }
            addChannel(t) {
              const {
                  delay: e = 0,
                  duration: n = Number.POSITIVE_INFINITY,
                  rate: i = 1,
                  repeat: r = 1,
                } = t,
                s = Kl++,
                o = { time: 0, delay: e, duration: n, rate: i, repeat: r };
              return (
                this._setChannelTime(o, this.time), this.channels.set(s, o), s
              );
            }
            removeChannel(t) {
              this.channels.delete(t);
              for (const [e, n] of this.animations)
                n.channel === t && this.detachAnimation(e);
            }
            isFinished(t) {
              const e = this.channels.get(t);
              return (
                void 0 !== e && this.time >= e.delay + e.duration * e.repeat
              );
            }
            getTime(t) {
              if (void 0 === t) return this.time;
              const e = this.channels.get(t);
              return void 0 === e ? -1 : e.time;
            }
            setTime(t) {
              this.time = Math.max(0, t);
              const e = this.channels.values();
              for (const t of e) this._setChannelTime(t, this.time);
              const n = this.animations.values();
              for (const t of n) {
                const { animation: e, channel: n } = t;
                e.setTime(this.getTime(n));
              }
            }
            play() {
              this.playing = !0;
            }
            pause() {
              (this.playing = !1), (this.lastEngineTime = -1);
            }
            reset() {
              this.setTime(0);
            }
            attachAnimation(t, e) {
              const n = Jl++;
              return (
                this.animations.set(n, { animation: t, channel: e }),
                t.setTime(this.getTime(e)),
                n
              );
            }
            detachAnimation(t) {
              this.animations.delete(t);
            }
            update(t) {
              this.playing &&
                (-1 === this.lastEngineTime && (this.lastEngineTime = t),
                this.setTime(this.time + (t - this.lastEngineTime)),
                (this.lastEngineTime = t));
            }
            _setChannelTime(t, e) {
              const n = e - t.delay;
              n >= t.duration * t.repeat
                ? (t.time = t.duration * t.rate)
                : ((t.time = Math.max(0, n) % t.duration), (t.time *= t.rate));
            }
          }
          class th {
            constructor(t, e, n) {
              (this.id = t),
                (this.context = n),
                (this._loadCount = 0),
                (this._subscribers = new Set()),
                this.setData(e);
            }
            subscribe(t) {
              this._subscribers.add(t);
            }
            unsubscribe(t) {
              this._subscribers.delete(t);
            }
            inUse() {
              return this._subscribers.size > 0;
            }
            delete() {}
            getData() {
              return this.isLoaded
                ? this._error
                  ? Promise.reject(this._error)
                  : this._content
                : this._loader.then(() => this.getData());
            }
            setData(t, e) {
              if (t === this._data && !e) return;
              this._data = t;
              const n = ++this._loadCount;
              let i = t;
              "string" == typeof t && (i = Aa(t)),
                i instanceof Promise
                  ? ((this.isLoaded = !1),
                    (this._loader = i
                      .then((t) => {
                        this._loadCount === n &&
                          ((this.isLoaded = !0),
                          (this._error = null),
                          (this._content = t));
                      })
                      .catch((t) => {
                        this._loadCount === n &&
                          ((this.isLoaded = !0), (this._error = t || !0));
                      })))
                  : ((this.isLoaded = !0),
                    (this._error = null),
                    (this._content = t));
              for (const t of this._subscribers) t.onChange(this.getData());
            }
          }
          class eh {
            constructor({ gl: t, protocol: e }) {
              (this.protocol = e || "resource://"),
                (this._context = { gl: t, resourceManager: this }),
                (this._resources = {}),
                (this._consumers = {}),
                (this._pruneRequest = null);
            }
            contains(t) {
              return !!t.startsWith(this.protocol) || t in this._resources;
            }
            add({
              resourceId: t,
              data: e,
              forceUpdate: n = !1,
              persistent: i = !0,
            }) {
              let r = this._resources[t];
              r
                ? r.setData(e, n)
                : ((r = new th(t, e, this._context)), (this._resources[t] = r)),
                (r.persistent = i);
            }
            remove(t) {
              const e = this._resources[t];
              e && (e.delete(), delete this._resources[t]);
            }
            unsubscribe({ consumerId: t }) {
              const e = this._consumers[t];
              if (e) {
                for (const t in e) {
                  const n = e[t];
                  n.resource && n.resource.unsubscribe(n);
                }
                delete this._consumers[t], this.prune();
              }
            }
            subscribe({
              resourceId: t,
              onChange: e,
              consumerId: n,
              requestId: i = "default",
            }) {
              const { _resources: r, protocol: s } = this;
              t.startsWith(s) &&
                (r[(t = t.replace(s, ""))] ||
                  this.add({ resourceId: t, data: null, persistent: !1 }));
              const o = r[t];
              if ((this._track(n, i, o, e), o)) return o.getData();
            }
            prune() {
              this._pruneRequest ||
                (this._pruneRequest = setTimeout(() => this._prune(), 0));
            }
            finalize() {
              for (const t in this._resources) this._resources[t].delete();
            }
            _track(t, e, n, i) {
              const r = this._consumers,
                s = (r[t] = r[t] || {}),
                o = s[e] || {};
              o.resource &&
                (o.resource.unsubscribe(o), (o.resource = null), this.prune()),
                n &&
                  ((s[e] = o),
                  (o.onChange = i),
                  (o.resource = n),
                  n.subscribe(o));
            }
            _prune() {
              this._pruneRequest = null;
              for (const t of Object.keys(this._resources)) {
                const e = this._resources[t];
                e.persistent ||
                  e.inUse() ||
                  (e.delete(), delete this._resources[t]);
              }
            }
          }
          const nh = [Da],
            ih = [
              "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
              "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
              "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
              "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)",
            ];
          function rh(t) {
            const e = Hi.getDefaultProgramManager(t);
            for (const t of nh) e.addDefaultModule(t);
            for (const t of ih) e.addShaderHook(t);
            return e;
          }
          const sh = Object.seal({
            layerManager: null,
            resourceManager: null,
            deck: null,
            gl: null,
            stats: null,
            shaderCache: null,
            pickingFBO: null,
            mousePosition: null,
            userData: {},
          });
          class oh {
            constructor(
              t,
              { deck: e, stats: n, viewport: i, timeline: r } = {}
            ) {
              (this.lastRenderedLayers = []),
                (this.layers = []),
                (this.resourceManager = new eh({ gl: t, protocol: "deck://" })),
                (this.context = {
                  ...sh,
                  layerManager: this,
                  gl: t,
                  deck: e,
                  programManager: t && rh(t),
                  stats: n || new Tt({ id: "deck.gl" }),
                  viewport: i || new Is({ id: "DEFAULT-INITIAL-VIEWPORT" }),
                  timeline: r || new Ql(),
                  resourceManager: this.resourceManager,
                }),
                (this._nextLayers = null),
                (this._needsRedraw = "Initial render"),
                (this._needsUpdate = !1),
                (this._debug = !1),
                (this.activateViewport = this.activateViewport.bind(this)),
                Object.seal(this);
            }
            finalize() {
              this.resourceManager.finalize();
              for (const t of this.layers) this._finalizeLayer(t);
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              let e = this._needsRedraw;
              t.clearRedrawFlags && (this._needsRedraw = !1);
              for (const n of this.layers) {
                const i = n.getNeedsRedraw(t);
                e = e || i;
              }
              return e;
            }
            needsUpdate() {
              return this._nextLayers &&
                this._nextLayers !== this.lastRenderedLayers
                ? "layers changed"
                : this._needsUpdate;
            }
            setNeedsRedraw(t) {
              this._needsRedraw = this._needsRedraw || t;
            }
            setNeedsUpdate(t) {
              this._needsUpdate = this._needsUpdate || t;
            }
            getLayers({ layerIds: t = null } = {}) {
              return t
                ? this.layers.filter((e) =>
                    t.find((t) => 0 === e.id.indexOf(t))
                  )
                : this.layers;
            }
            setProps(t) {
              "debug" in t && (this._debug = t.debug),
                "userData" in t && (this.context.userData = t.userData),
                "layers" in t && (this._nextLayers = t.layers),
                "onError" in t && (this.context.onError = t.onError);
            }
            setLayers(t, e) {
              bn("layerManager.setLayers", this, e, t),
                (this.lastRenderedLayers = t),
                (t = sn(t, Boolean));
              for (const e of t) e.context = this.context;
              return this._updateLayers(this.layers, t), this;
            }
            updateLayers() {
              const t = this.needsUpdate();
              t &&
                (this.setNeedsRedraw("updating layers: ".concat(t)),
                this.setLayers(this._nextLayers || this.lastRenderedLayers, t)),
                (this._nextLayers = null);
            }
            activateViewport(t) {
              return (
                bn("layerManager.activateViewport", this, t),
                t && (this.context.viewport = t),
                this
              );
            }
            _handleError(t, e, n) {
              n.raiseError(e, "".concat(t, " of ").concat(n));
            }
            _updateLayers(t, e) {
              const n = {};
              for (const e of t)
                n[e.id]
                  ? E.warn("Multiple old layers with same id ".concat(e.id))()
                  : (n[e.id] = e);
              const i = [];
              this._updateSublayersRecursively(e, n, i),
                this._finalizeOldLayers(n);
              let r = !1;
              for (const t of i)
                if (t.hasUniformTransition()) {
                  r = !0;
                  break;
                }
              (this._needsUpdate = r), (this.layers = i);
            }
            _updateSublayersRecursively(t, e, n) {
              for (const i of t) {
                i.context = this.context;
                const t = e[i.id];
                null === t &&
                  E.warn("Multiple new layers with same id ".concat(i.id))(),
                  (e[i.id] = null);
                let r = null;
                try {
                  this._debug && t !== i && i.validateProps(),
                    t
                      ? (this._transferLayerState(t, i), this._updateLayer(i))
                      : this._initializeLayer(i),
                    n.push(i),
                    (r = i.isComposite && i.getSubLayers());
                } catch (t) {
                  this._handleError("matching", t, i);
                }
                r && this._updateSublayersRecursively(r, e, n);
              }
            }
            _finalizeOldLayers(t) {
              for (const e in t) {
                const n = t[e];
                n && this._finalizeLayer(n);
              }
            }
            _initializeLayer(t) {
              try {
                t._initialize(), (t.lifecycle = "Initialized");
              } catch (e) {
                this._handleError("initialization", e, t);
              }
            }
            _transferLayerState(t, e) {
              e._transferState(t),
                (e.lifecycle =
                  "Matched. State transferred from previous layer"),
                e !== t &&
                  (t.lifecycle = "Discarded. Awaiting garbage collection");
            }
            _updateLayer(t) {
              try {
                t._update();
              } catch (e) {
                this._handleError("update", e, t);
              }
            }
            _finalizeLayer(t) {
              (this._needsRedraw = this._needsRedraw || "finalized ".concat(t)),
                (t.lifecycle =
                  "No longer matched. Awaiting garbage collection");
              try {
                t._finalize(),
                  (t.lifecycle = "Finalized! Awaiting garbage collection");
              } catch (e) {
                this._handleError("finalization", e, t);
              }
            }
          }
          function ah(t, e) {
            if (t === e) return !0;
            if (!t || !e) return !1;
            for (const n in t) {
              const i = t[n],
                r = e[n];
              if (
                !(i === r || (Array.isArray(i) && Array.isArray(r) && ah(i, r)))
              )
                return !1;
            }
            return !0;
          }
          class ch {
            constructor(t = {}) {
              (this.views = []),
                (this.width = 100),
                (this.height = 100),
                (this.viewState = {}),
                (this.controllers = {}),
                (this.timeline = t.timeline),
                (this._viewports = []),
                (this._viewportMap = {}),
                (this._isUpdating = !1),
                (this._needsRedraw = "Initial render"),
                (this._needsUpdate = !0),
                (this._eventManager = t.eventManager),
                (this._eventCallbacks = {
                  onViewStateChange: t.onViewStateChange,
                  onInteractionStateChange: t.onInteractionStateChange,
                }),
                Object.seal(this),
                this.setProps(t);
            }
            finalize() {
              for (const t in this.controllers)
                this.controllers[t] && this.controllers[t].finalize();
              this.controllers = {};
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this._needsRedraw;
              return t.clearRedrawFlags && (this._needsRedraw = !1), e;
            }
            setNeedsUpdate(t) {
              (this._needsUpdate = this._needsUpdate || t),
                (this._needsRedraw = this._needsRedraw || t);
            }
            updateViewStates() {
              for (const t in this.controllers) {
                const e = this.controllers[t];
                e && e.updateTransition();
              }
            }
            getViewports(t) {
              return t
                ? this._viewports.filter((e) => e.containsPixel(t))
                : this._viewports;
            }
            getViews() {
              const t = {};
              return (
                this.views.forEach((e) => {
                  t[e.id] = e;
                }),
                t
              );
            }
            getView(t) {
              return "string" == typeof t
                ? this.views.find((e) => e.id === t)
                : t;
            }
            getViewState(t) {
              const e = this.getView(t),
                n = (e && this.viewState[e.getViewStateId()]) || this.viewState;
              return e ? e.filterViewState(n) : n;
            }
            getViewport(t) {
              return this._viewportMap[t];
            }
            unproject(t, e) {
              const n = this.getViewports(),
                i = { x: t[0], y: t[1] };
              for (let r = n.length - 1; r >= 0; --r) {
                const s = n[r];
                if (s.containsPixel(i)) {
                  const n = t.slice();
                  return (n[0] -= s.x), (n[1] -= s.y), s.unproject(n, e);
                }
              }
              return null;
            }
            setProps(t) {
              "views" in t && this._setViews(t.views),
                "viewState" in t && this._setViewState(t.viewState),
                ("width" in t || "height" in t) &&
                  this._setSize(t.width, t.height),
                this._isUpdating || this._update();
            }
            _update() {
              (this._isUpdating = !0),
                this._needsUpdate &&
                  ((this._needsUpdate = !1), this._rebuildViewports()),
                this._needsUpdate &&
                  ((this._needsUpdate = !1), this._rebuildViewports()),
                (this._isUpdating = !1);
            }
            _setSize(t, e) {
              (t === this.width && e === this.height) ||
                ((this.width = t),
                (this.height = e),
                this.setNeedsUpdate("Size changed"));
            }
            _setViews(t) {
              (t = sn(t, Boolean)),
                this._diffViews(t, this.views) &&
                  this.setNeedsUpdate("views changed"),
                (this.views = t);
            }
            _setViewState(t) {
              t
                ? (!ah(t, this.viewState) &&
                    this.setNeedsUpdate("viewState changed"),
                  (this.viewState = t))
                : E.warn("missing `viewState` or `initialViewState`")();
            }
            _onViewStateChange(t, e) {
              (e.viewId = t),
                this._eventCallbacks.onViewStateChange &&
                  this._eventCallbacks.onViewStateChange(e);
            }
            _createController(t, e) {
              return new (0, e.type)({
                timeline: this.timeline,
                eventManager: this._eventManager,
                onViewStateChange: this._onViewStateChange.bind(this, e.id),
                onStateChange: this._eventCallbacks.onInteractionStateChange,
                makeViewport: (e) =>
                  t._getViewport(e, { width: e.width, height: e.height }),
                ...e,
              });
            }
            _updateController(t, e, n, i) {
              let r = t.controller;
              return r
                ? ((r = {
                    ...e,
                    ...t.props,
                    ...r,
                    id: t.id,
                    x: n.x,
                    y: n.y,
                    width: n.width,
                    height: n.height,
                  }),
                  i ? i.setProps(r) : (i = this._createController(t, r)),
                  i)
                : null;
            }
            _rebuildViewports() {
              const { width: t, height: e, views: n } = this,
                i = this.controllers;
              (this._viewports = []), (this.controllers = {});
              let r = !1;
              for (let s = n.length; s--; ) {
                const o = n[s],
                  a = this.getViewState(o),
                  c = o.makeViewport({ width: t, height: e, viewState: a });
                let l = i[o.id];
                o.controller && !l && (r = !0),
                  (!r && o.controller) || !l || (l.finalize(), (l = null)),
                  (this.controllers[o.id] = this._updateController(o, a, c, l)),
                  this._viewports.unshift(c);
              }
              for (const t in i)
                i[t] && !this.controllers[t] && i[t].finalize();
              this._buildViewportMap();
            }
            _buildViewportMap() {
              (this._viewportMap = {}),
                this._viewports.forEach((t) => {
                  t.id &&
                    (this._viewportMap[t.id] = this._viewportMap[t.id] || t);
                });
            }
            _diffViews(t, e) {
              return (
                t.length !== e.length || t.some((n, i) => !t[i].equals(e[i]))
              );
            }
          }
          const lh = /([0-9]+\.?[0-9]*)(%|px)/;
          function hh(t) {
            switch (typeof t) {
              case "number":
                return { position: t, relative: !1 };
              case "string":
                const e = t.match(lh);
                if (e && e.length >= 3) {
                  const t = "%" === e[2],
                    n = parseFloat(e[1]);
                  return { position: t ? n / 100 : n, relative: t };
                }
              default:
                throw new Error("Could not parse position string ".concat(t));
            }
          }
          function uh(t, e) {
            return t.relative ? Math.round(t.position * e) : t.position;
          }
          const dh = () => {},
            fh = {
              transitionEasing: (t) => t,
              transitionInterruption: 1,
              onTransitionStart: dh,
              onTransitionInterrupt: dh,
              onTransitionEnd: dh,
            };
          class ph {
            constructor(t, e = {}) {
              (this.ControllerState = t),
                (this.props = { ...fh, ...e }),
                (this.propsInTransition = null),
                (this.transition = new dr(e.timeline)),
                (this.onViewStateChange = e.onViewStateChange || dh),
                (this.onStateChange = e.onStateChange || dh),
                (this._onTransitionUpdate =
                  this._onTransitionUpdate.bind(this));
            }
            finalize() {
              this.transition.cancel();
            }
            getViewportInTransition() {
              return this.propsInTransition;
            }
            processViewStateChange(t) {
              let e = !1;
              const n = this.props;
              if (
                ((t = { ...fh, ...t }),
                (this.props = t),
                this._shouldIgnoreViewportChange(n, t))
              )
                return e;
              if (this._isTransitionEnabled(t)) {
                const { interruption: i, endProps: r } =
                    this.transition.settings,
                  s = { ...n, ...(2 === i ? r : this.propsInTransition || n) };
                this._triggerTransition(s, t), (e = !0);
              } else this.transition.cancel();
              return e;
            }
            updateTransition() {
              this.transition.update();
            }
            _isTransitionEnabled(t) {
              const { transitionDuration: e, transitionInterpolator: n } = t;
              return (e > 0 || "auto" === e) && Boolean(n);
            }
            _isUpdateDueToCurrentTransition(t) {
              return (
                !!this.transition.inProgress &&
                this.transition.settings.interpolator.arePropsEqual(
                  t,
                  this.propsInTransition
                )
              );
            }
            _shouldIgnoreViewportChange(t, e) {
              return this.transition.inProgress
                ? 3 === this.transition.settings.interruption ||
                    this._isUpdateDueToCurrentTransition(e)
                : !this._isTransitionEnabled(e) ||
                    e.transitionInterpolator.arePropsEqual(t, e);
            }
            _triggerTransition(t, e) {
              const n = new this.ControllerState(t),
                i = new this.ControllerState(e).shortestPathFrom(n),
                { transitionInterpolator: r } = e,
                s = r.getDuration ? r.getDuration(t, e) : e.transitionDuration;
              if (0 === s) return;
              const o = e.transitionInterpolator.initializeProps(t, i);
              (this.propsInTransition = {}),
                (this.duration = s),
                this.transition.start({
                  duration: s,
                  easing: e.transitionEasing,
                  interpolator: e.transitionInterpolator,
                  interruption: e.transitionInterruption,
                  startProps: o.start,
                  endProps: o.end,
                  onStart: e.onTransitionStart,
                  onUpdate: this._onTransitionUpdate,
                  onInterrupt: this._onTransitionEnd(e.onTransitionInterrupt),
                  onEnd: this._onTransitionEnd(e.onTransitionEnd),
                }),
                this.onStateChange({ inTransition: !0 }),
                this.updateTransition();
            }
            _onTransitionEnd(t) {
              return (e) => {
                (this.propsInTransition = null),
                  this.onStateChange({
                    inTransition: !1,
                    isZooming: !1,
                    isPanning: !1,
                    isRotating: !1,
                  }),
                  t(e);
              };
            }
            _onTransitionUpdate(t) {
              const {
                  time: e,
                  settings: {
                    interpolator: n,
                    startProps: i,
                    endProps: r,
                    duration: s,
                    easing: o,
                  },
                } = t,
                a = o(e / s),
                c = n.interpolateProps(i, r, a);
              (this.propsInTransition = new this.ControllerState({
                ...this.props,
                ...c,
              }).getViewportProps()),
                this.onViewStateChange({
                  viewState: this.propsInTransition,
                  oldViewState: this.props,
                });
            }
          }
          const gh = ["longitude", "latitude", "zoom", "bearing", "pitch"],
            mh = ["longitude", "latitude", "zoom"];
          class yh extends class {
            constructor(t = {}) {
              Array.isArray(t) && (t = { compare: t, extract: t, required: t });
              const { compare: e, extract: n, required: i } = t;
              (this._propsToCompare = e),
                (this._propsToExtract = n),
                (this._requiredProps = i);
            }
            arePropsEqual(t, e) {
              for (const n of this._propsToCompare || Object.keys(e))
                if (!(n in t) || !(n in e) || !Le(t[n], e[n])) return !1;
              return !0;
            }
            initializeProps(t, e) {
              let n;
              if (this._propsToExtract) {
                const i = {},
                  r = {};
                for (const n of this._propsToExtract)
                  (i[n] = t[n]), (r[n] = e[n]);
                n = { start: i, end: r };
              } else n = { start: t, end: e };
              return (
                this._checkRequiredProps(n.start),
                this._checkRequiredProps(n.end),
                n
              );
            }
            interpolateProps(t, e, n) {
              return e;
            }
            getDuration(t, e) {
              return e.transitionDuration;
            }
            _checkRequiredProps(t) {
              this._requiredProps &&
                this._requiredProps.forEach((e) => {
                  const n = t[e];
                  Je(
                    Number.isFinite(n) || Array.isArray(n),
                    "".concat(e, " is required for transition")
                  );
                });
            }
          } {
            constructor(t = {}) {
              super(
                (Array.isArray(t) ? t : t.transitionProps) || {
                  compare: gh,
                  extract: gh,
                  required: mh,
                }
              ),
                (this.opts = t);
            }
            initializeProps(t, e) {
              const n = super.initializeProps(t, e),
                { makeViewport: i, around: r } = this.opts;
              if (i && r) {
                const s = i(t),
                  o = i(e),
                  a = s.unproject(r);
                (n.start.around = r),
                  Object.assign(n.end, {
                    around: o.project(a),
                    aroundPosition: a,
                    width: e.width,
                    height: e.height,
                  });
              }
              return n;
            }
            interpolateProps(t, e, n) {
              const i = {};
              for (const r of this._propsToExtract)
                i[r] = Ce(t[r] || 0, e[r] || 0, n);
              if (e.aroundPosition) {
                const r = this.opts.makeViewport({ ...e, ...i });
                Object.assign(
                  i,
                  r.panByPosition(e.aroundPosition, Ce(t.around, e.around, n))
                );
              }
              return i;
            }
          }
          const _h = { transitionDuration: 0 },
            vh = {
              transitionDuration: 300,
              transitionEasing: (t) => t,
              transitionInterruption: 1,
            },
            bh = (t) => 1 - (1 - t) * (1 - t),
            wh = ["wheel"],
            xh = ["panstart", "panmove", "panend"],
            Ph = ["pinchstart", "pinchmove", "pinchend"],
            Eh = ["tripanstart", "tripanmove", "tripanend"],
            Ah = ["doubletap"],
            Th = ["keydown"];
          class Sh extends class {
            constructor(t) {
              this._viewportProps = this._applyConstraints(t);
            }
            getViewportProps() {
              return this._viewportProps;
            }
            getState() {
              return this._state;
            }
            shortestPathFrom(t) {
              return this._viewportProps;
            }
            _applyConstraints(t) {
              return t;
            }
          } {
            constructor({
              makeViewport: t,
              width: e,
              height: n,
              latitude: i,
              longitude: r,
              zoom: s,
              bearing: o = 0,
              pitch: a = 0,
              altitude: c = 1.5,
              maxZoom: l = 20,
              minZoom: h = 0,
              maxPitch: u = 60,
              minPitch: d = 0,
              startPanLngLat: f,
              startZoomLngLat: p,
              startRotatePos: g,
              startBearing: m,
              startPitch: y,
              startZoom: _,
              normalize: v,
            } = {}) {
              Je(Number.isFinite(r)),
                Je(Number.isFinite(i)),
                Je(Number.isFinite(s)),
                super({
                  width: e,
                  height: n,
                  latitude: i,
                  longitude: r,
                  zoom: s,
                  bearing: o,
                  pitch: a,
                  altitude: c,
                  maxZoom: l,
                  minZoom: h,
                  maxPitch: u,
                  minPitch: d,
                  normalize: v,
                }),
                (this._state = {
                  startPanLngLat: f,
                  startZoomLngLat: p,
                  startRotatePos: g,
                  startBearing: m,
                  startPitch: y,
                  startZoom: _,
                }),
                (this.makeViewport = t);
            }
            panStart({ pos: t }) {
              return this._getUpdatedState({
                startPanLngLat: this._unproject(t),
              });
            }
            pan({ pos: t, startPos: e }) {
              const n = this._state.startPanLngLat || this._unproject(e);
              if (!n) return this;
              const i = this.makeViewport(this._viewportProps).panByPosition(
                n,
                t
              );
              return this._getUpdatedState(i);
            }
            panEnd() {
              return this._getUpdatedState({ startPanLngLat: null });
            }
            rotateStart({ pos: t }) {
              return this._getUpdatedState({
                startRotatePos: t,
                startBearing: this._viewportProps.bearing,
                startPitch: this._viewportProps.pitch,
              });
            }
            rotate({ pos: t, deltaAngleX: e = 0, deltaAngleY: n = 0 }) {
              const {
                startRotatePos: i,
                startBearing: r,
                startPitch: s,
              } = this._state;
              if (!i || !Number.isFinite(r) || !Number.isFinite(s)) return this;
              let o;
              return (
                (o = t
                  ? this._calculateNewPitchAndBearing({
                      ...this._getRotationParams(t, i),
                      startBearing: r,
                      startPitch: s,
                    })
                  : { bearing: r + e, pitch: s + n }),
                this._getUpdatedState(o)
              );
            }
            rotateEnd() {
              return this._getUpdatedState({
                startBearing: null,
                startPitch: null,
              });
            }
            zoomStart({ pos: t }) {
              return this._getUpdatedState({
                startZoomLngLat: this._unproject(t),
                startZoom: this._viewportProps.zoom,
              });
            }
            zoom({ pos: t, startPos: e, scale: n }) {
              let { startZoom: i, startZoomLngLat: r } = this._state;
              Number.isFinite(i) ||
                ((i = this._viewportProps.zoom),
                (r = this._unproject(e) || this._unproject(t)));
              const s = this._calculateNewZoom({ scale: n, startZoom: i }),
                o = this.makeViewport({ ...this._viewportProps, zoom: s });
              return this._getUpdatedState({
                zoom: s,
                ...o.panByPosition(r, t),
              });
            }
            zoomEnd() {
              return this._getUpdatedState({
                startZoomLngLat: null,
                startZoom: null,
              });
            }
            zoomIn(t = 2) {
              return this._zoomFromCenter(t);
            }
            zoomOut(t = 2) {
              return this._zoomFromCenter(1 / t);
            }
            moveLeft(t = 100) {
              return this._panFromCenter([t, 0]);
            }
            moveRight(t = 100) {
              return this._panFromCenter([-t, 0]);
            }
            moveUp(t = 100) {
              return this._panFromCenter([0, t]);
            }
            moveDown(t = 100) {
              return this._panFromCenter([0, -t]);
            }
            rotateLeft(t = 15) {
              return this._getUpdatedState({
                bearing: this._viewportProps.bearing - t,
              });
            }
            rotateRight(t = 15) {
              return this._getUpdatedState({
                bearing: this._viewportProps.bearing + t,
              });
            }
            rotateUp(t = 10) {
              return this._getUpdatedState({
                pitch: this._viewportProps.pitch + t,
              });
            }
            rotateDown(t = 10) {
              return this._getUpdatedState({
                pitch: this._viewportProps.pitch - t,
              });
            }
            shortestPathFrom(t) {
              const e = t.getViewportProps(),
                n = { ...this._viewportProps },
                { bearing: i, longitude: r } = n;
              return (
                Math.abs(i - e.bearing) > 180 &&
                  (n.bearing = i < 0 ? i + 360 : i - 360),
                Math.abs(r - e.longitude) > 180 &&
                  (n.longitude = r < 0 ? r + 360 : r - 360),
                n
              );
            }
            _zoomFromCenter(t) {
              const { width: e, height: n } = this._viewportProps;
              return this.zoom({ pos: [e / 2, n / 2], scale: t });
            }
            _panFromCenter(t) {
              const { width: e, height: n } = this._viewportProps;
              return this.pan({
                startPos: [e / 2, n / 2],
                pos: [e / 2 + t[0], n / 2 + t[1]],
              });
            }
            _getUpdatedState(t) {
              return new this.constructor({
                makeViewport: this.makeViewport,
                ...this._viewportProps,
                ...this._state,
                ...t,
              });
            }
            _applyConstraints(t) {
              const { maxZoom: e, minZoom: n, zoom: i } = t;
              t.zoom = Me(i, n, e);
              const { maxPitch: r, minPitch: s, pitch: o } = t;
              t.pitch = Me(o, s, r);
              const { normalize: a = !0 } = t;
              return (
                a &&
                  Object.assign(
                    t,
                    (function ({
                      width: t,
                      height: e,
                      longitude: n,
                      latitude: i,
                      zoom: r,
                      pitch: s = 0,
                      bearing: o = 0,
                    }) {
                      (n < -180 || n > 180) && (n = ss(n + 180, 360) - 180),
                        (o < -180 || o > 180) && (o = ss(o + 180, 360) - 180);
                      const a = os(e / 512);
                      if (r <= a) (r = a), (i = 0);
                      else {
                        const t = e / 2 / Math.pow(2, r),
                          n = ps([0, t])[1];
                        if (i < n) i = n;
                        else {
                          const e = ps([0, 512 - t])[1];
                          i > e && (i = e);
                        }
                      }
                      return {
                        width: t,
                        height: e,
                        longitude: n,
                        latitude: i,
                        zoom: r,
                        pitch: s,
                        bearing: o,
                      };
                    })(t)
                  ),
                t
              );
            }
            _unproject(t) {
              const e = this.makeViewport(this._viewportProps);
              return t && e.unproject(t);
            }
            _calculateNewZoom({ scale: t, startZoom: e }) {
              const { maxZoom: n, minZoom: i } = this._viewportProps;
              return Me(e + Math.log2(t), i, n);
            }
            _calculateNewPitchAndBearing({
              deltaScaleX: t,
              deltaScaleY: e,
              startBearing: n,
              startPitch: i,
            }) {
              e = Me(e, -1, 1);
              const { minPitch: r, maxPitch: s } = this._viewportProps;
              let o = i;
              return (
                e > 0 ? (o = i + e * (s - i)) : e < 0 && (o = i - e * (r - i)),
                { pitch: o, bearing: n + 180 * t }
              );
            }
            _getRotationParams(t, e) {
              const n = t[0] - e[0],
                i = t[1] - e[1],
                r = t[1],
                s = e[1],
                { width: o, height: a } = this._viewportProps,
                c = n / o;
              let l = 0;
              return (
                i > 0
                  ? Math.abs(a - s) > 5 && (l = (i / (s - a)) * 1.2)
                  : i < 0 && s > 5 && (l = 1 - r / s),
                (l = Math.min(1, Math.max(-1, l))),
                { deltaScaleX: c, deltaScaleY: l }
              );
            }
          }
          class Mh extends class {
            constructor(t, e = {}) {
              (this.ControllerState = t),
                (this.controllerState = null),
                (this.controllerStateProps = null),
                (this.eventManager = null),
                (this.transitionManager = new ph(t, {
                  ...e,
                  onViewStateChange: this._onTransition.bind(this),
                  onStateChange: this._setInteractionState.bind(this),
                }));
              const n = this.linearTransitionProps;
              (this._transition = n && {
                ...vh,
                transitionInterpolator: new yh({ transitionProps: n }),
              }),
                (this._events = null),
                (this._interactionState = { isDragging: !1 }),
                (this._customEvents = []),
                (this.onViewStateChange = null),
                (this.onStateChange = null),
                (this.handleEvent = this.handleEvent.bind(this)),
                this.setProps(e);
            }
            get linearTransitionProps() {
              return null;
            }
            set events(t) {
              this.toggleEvents(this._customEvents, !1),
                this.toggleEvents(t, !0),
                (this._customEvents = t),
                this.setProps(this.controllerStateProps);
            }
            finalize() {
              for (const t in this._events)
                this._events[t] && this.eventManager.off(t, this.handleEvent);
              this.transitionManager.finalize();
            }
            handleEvent(t) {
              const { ControllerState: e } = this;
              this.controllerState = new e({
                makeViewport: this.makeViewport,
                ...this.controllerStateProps,
                ...this._state,
              });
              const n = this._eventStartBlocked;
              switch (t.type) {
                case "panstart":
                  return !n && this._onPanStart(t);
                case "panmove":
                  return this._onPan(t);
                case "panend":
                  return this._onPanEnd(t);
                case "pinchstart":
                  return !n && this._onPinchStart(t);
                case "pinchmove":
                  return this._onPinch(t);
                case "pinchend":
                  return this._onPinchEnd(t);
                case "tripanstart":
                  return !n && this._onTriplePanStart(t);
                case "tripanmove":
                  return this._onTriplePan(t);
                case "tripanend":
                  return this._onTriplePanEnd(t);
                case "doubletap":
                  return this._onDoubleTap(t);
                case "wheel":
                  return this._onWheel(t);
                case "keydown":
                  return this._onKeyDown(t);
                default:
                  return !1;
              }
            }
            getCenter(t) {
              const { x: e, y: n } = this.controllerStateProps,
                { offsetCenter: i } = t;
              return [i.x - e, i.y - n];
            }
            isPointInBounds(t, e) {
              const { width: n, height: i } = this.controllerStateProps;
              if (e && e.handled) return !1;
              const r = t[0] >= 0 && t[0] <= n && t[1] >= 0 && t[1] <= i;
              return r && e && e.stopPropagation(), r;
            }
            isFunctionKeyPressed(t) {
              const { srcEvent: e } = t;
              return Boolean(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
            }
            isDragging() {
              return this._interactionState.isDragging;
            }
            blockEvents(t) {
              const e = setTimeout(() => {
                this._eventStartBlocked === e &&
                  (this._eventStartBlocked = null);
              }, t);
              this._eventStartBlocked = e;
            }
            setProps(t) {
              "onViewStateChange" in t &&
                (this.onViewStateChange = t.onViewStateChange),
                "onStateChange" in t && (this.onStateChange = t.onStateChange),
                "makeViewport" in t && (this.makeViewport = t.makeViewport),
                "dragMode" in t && (this.dragMode = t.dragMode),
                (this.controllerStateProps = t),
                "eventManager" in t &&
                  this.eventManager !== t.eventManager &&
                  ((this.eventManager = t.eventManager),
                  (this._events = {}),
                  this.toggleEvents(this._customEvents, !0)),
                "transitionInterpolator" in t ||
                  (t.transitionInterpolator =
                    this._getTransitionProps().transitionInterpolator),
                this.transitionManager.processViewStateChange(t);
              let { inertia: e } = t;
              !0 === e && (e = 300), (this.inertia = e);
              const {
                  scrollZoom: n = !0,
                  dragPan: i = !0,
                  dragRotate: r = !0,
                  doubleClickZoom: s = !0,
                  touchZoom: o = !0,
                  touchRotate: a = !1,
                  keyboard: c = !0,
                } = t,
                l = Boolean(this.onViewStateChange);
              this.toggleEvents(wh, l && n),
                this.toggleEvents(xh, l && (i || r)),
                this.toggleEvents(Ph, l && (o || a)),
                this.toggleEvents(Eh, l && a),
                this.toggleEvents(Ah, l && s),
                this.toggleEvents(Th, l && c),
                (this.scrollZoom = n),
                (this.dragPan = i),
                (this.dragRotate = r),
                (this.doubleClickZoom = s),
                (this.touchZoom = o),
                (this.touchRotate = a),
                (this.keyboard = c);
            }
            updateTransition() {
              this.transitionManager.updateTransition();
            }
            toggleEvents(t, e) {
              this.eventManager &&
                t.forEach((t) => {
                  this._events[t] !== e &&
                    ((this._events[t] = e),
                    e
                      ? this.eventManager.on(t, this.handleEvent)
                      : this.eventManager.off(t, this.handleEvent));
                });
            }
            updateViewport(t, e = {}, n = {}) {
              const i = { ...t.getViewportProps(), ...e },
                r = this.controllerState !== t;
              if (
                ((this._state = t.getState()), this._setInteractionState(n), r)
              ) {
                const t = this.controllerState
                  ? this.controllerState.getViewportProps()
                  : null;
                this.onViewStateChange &&
                  this.onViewStateChange({
                    viewState: i,
                    interactionState: this._interactionState,
                    oldViewState: t,
                  });
              }
            }
            _onTransition(t) {
              this.onViewStateChange &&
                ((t.interactionState = this._interactionState),
                this.onViewStateChange(t));
            }
            _setInteractionState(t) {
              Object.assign(this._interactionState, t),
                this.onStateChange &&
                  this.onStateChange(this._interactionState);
            }
            _onPanStart(t) {
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              let n = this.isFunctionKeyPressed(t) || t.rightButton;
              (this.invertPan || "pan" === this.dragMode) && (n = !n);
              const i = this.controllerState[n ? "panStart" : "rotateStart"]({
                pos: e,
              });
              return (
                (this._panMove = n),
                this.updateViewport(i, _h, { isDragging: !0 }),
                !0
              );
            }
            _onPan(t) {
              return (
                !!this.isDragging() &&
                (this._panMove ? this._onPanMove(t) : this._onPanRotate(t))
              );
            }
            _onPanEnd(t) {
              return (
                !!this.isDragging() &&
                (this._panMove
                  ? this._onPanMoveEnd(t)
                  : this._onPanRotateEnd(t))
              );
            }
            _onPanMove(t) {
              if (!this.dragPan) return !1;
              const e = this.getCenter(t),
                n = this.controllerState.pan({ pos: e });
              return (
                this.updateViewport(n, _h, { isDragging: !0, isPanning: !0 }),
                !0
              );
            }
            _onPanMoveEnd(t) {
              const { inertia: e } = this;
              if (this.dragPan && e && t.velocity) {
                const n = this.getCenter(t),
                  i = [
                    n[0] + (t.velocityX * e) / 2,
                    n[1] + (t.velocityY * e) / 2,
                  ],
                  r = this.controllerState.pan({ pos: i }).panEnd();
                this.updateViewport(
                  r,
                  {
                    ...this._getTransitionProps(),
                    transitionDuration: e,
                    transitionEasing: bh,
                  },
                  { isDragging: !1, isPanning: !0 }
                );
              } else {
                const t = this.controllerState.panEnd();
                this.updateViewport(t, null, { isDragging: !1, isPanning: !1 });
              }
              return !0;
            }
            _onPanRotate(t) {
              if (!this.dragRotate) return !1;
              const e = this.getCenter(t),
                n = this.controllerState.rotate({ pos: e });
              return (
                this.updateViewport(n, _h, { isDragging: !0, isRotating: !0 }),
                !0
              );
            }
            _onPanRotateEnd(t) {
              const { inertia: e } = this;
              if (this.dragRotate && e && t.velocity) {
                const n = this.getCenter(t),
                  i = [
                    n[0] + (t.velocityX * e) / 2,
                    n[1] + (t.velocityY * e) / 2,
                  ],
                  r = this.controllerState.rotate({ pos: i }).rotateEnd();
                this.updateViewport(
                  r,
                  {
                    ...this._getTransitionProps(),
                    transitionDuration: e,
                    transitionEasing: bh,
                  },
                  { isDragging: !1, isRotating: !0 }
                );
              } else {
                const t = this.controllerState.rotateEnd();
                this.updateViewport(t, null, {
                  isDragging: !1,
                  isRotating: !1,
                });
              }
              return !0;
            }
            _onWheel(t) {
              if (!this.scrollZoom) return !1;
              t.preventDefault();
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const { speed: n = 0.01, smooth: i = !1 } = this.scrollZoom,
                { delta: r } = t;
              let s = 2 / (1 + Math.exp(-Math.abs(r * n)));
              r < 0 && 0 !== s && (s = 1 / s);
              const o = this.controllerState.zoom({ pos: e, scale: s });
              return (
                this.updateViewport(
                  o,
                  {
                    ...this._getTransitionProps({ around: e }),
                    transitionDuration: i ? 250 : 1,
                  },
                  { isZooming: !0, isPanning: !0 }
                ),
                !0
              );
            }
            _onTriplePanStart(t) {
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const n = this.controllerState.rotateStart({ pos: e });
              return this.updateViewport(n, _h, { isDragging: !0 }), !0;
            }
            _onTriplePan(t) {
              if (!this.touchRotate) return !1;
              if (!this.isDragging()) return !1;
              const e = this.getCenter(t);
              e[0] -= t.deltaX;
              const n = this.controllerState.rotate({ pos: e });
              return (
                this.updateViewport(n, _h, { isDragging: !0, isRotating: !0 }),
                !0
              );
            }
            _onTriplePanEnd(t) {
              if (!this.isDragging()) return !1;
              const { inertia: e } = this;
              if (this.touchRotate && e && t.velocityY) {
                const n = this.getCenter(t),
                  i = [n[0], (n[1] += (t.velocityY * e) / 2)],
                  r = this.controllerState.rotate({ pos: i });
                this.updateViewport(
                  r,
                  {
                    ...this._getTransitionProps(),
                    transitionDuration: e,
                    transitionEasing: bh,
                  },
                  { isDragging: !1, isRotating: !0 }
                ),
                  this.blockEvents(e);
              } else {
                const t = this.controllerState.rotateEnd();
                this.updateViewport(t, null, {
                  isDragging: !1,
                  isRotating: !1,
                });
              }
              return !0;
            }
            _onPinchStart(t) {
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const n = this.controllerState
                .zoomStart({ pos: e })
                .rotateStart({ pos: e });
              return (
                (this._startPinchRotation = t.rotation),
                (this._lastPinchEvent = t),
                this.updateViewport(n, _h, { isDragging: !0 }),
                !0
              );
            }
            _onPinch(t) {
              if (!this.touchZoom && !this.touchRotate) return !1;
              if (!this.isDragging()) return !1;
              let e = this.controllerState;
              if (this.touchZoom) {
                const { scale: n } = t,
                  i = this.getCenter(t);
                e = e.zoom({ pos: i, scale: n });
              }
              if (this.touchRotate) {
                const { rotation: n } = t;
                e = e.rotate({ deltaAngleX: this._startPinchRotation - n });
              }
              return (
                this.updateViewport(e, _h, {
                  isDragging: !0,
                  isPanning: this.touchZoom,
                  isZooming: this.touchZoom,
                  isRotating: this.touchRotate,
                }),
                (this._lastPinchEvent = t),
                !0
              );
            }
            _onPinchEnd(t) {
              if (!this.isDragging()) return !1;
              const { inertia: e, _lastPinchEvent: n } = this;
              if (this.touchZoom && e && n && t.scale !== n.scale) {
                const i = this.getCenter(t);
                let r = this.controllerState.rotateEnd();
                const s = Math.log2(t.scale),
                  o = (s - Math.log2(n.scale)) / (t.deltaTime - n.deltaTime),
                  a = Math.pow(2, s + (o * e) / 2);
                (r = r.zoom({ pos: i, scale: a }).zoomEnd()),
                  this.updateViewport(
                    r,
                    {
                      ...this._getTransitionProps({ around: i }),
                      transitionDuration: e,
                      transitionEasing: bh,
                    },
                    {
                      isDragging: !1,
                      isPanning: this.touchZoom,
                      isZooming: this.touchZoom,
                      isRotating: !1,
                    }
                  ),
                  this.blockEvents(e);
              } else {
                const t = this.controllerState.zoomEnd().rotateEnd();
                this.updateViewport(t, null, {
                  isDragging: !1,
                  isPanning: !1,
                  isZooming: !1,
                  isRotating: !1,
                });
              }
              return (
                (this._startPinchRotation = null),
                (this._lastPinchEvent = null),
                !0
              );
            }
            _onDoubleTap(t) {
              if (!this.doubleClickZoom) return !1;
              const e = this.getCenter(t);
              if (!this.isPointInBounds(e, t)) return !1;
              const n = this.isFunctionKeyPressed(t),
                i = this.controllerState.zoom({ pos: e, scale: n ? 0.5 : 2 });
              return (
                this.updateViewport(
                  i,
                  this._getTransitionProps({ around: e }),
                  { isZooming: !0, isPanning: !0 }
                ),
                this.blockEvents(100),
                !0
              );
            }
            _onKeyDown(t) {
              if (!this.keyboard) return !1;
              const e = this.isFunctionKeyPressed(t),
                {
                  zoomSpeed: n,
                  moveSpeed: i,
                  rotateSpeedX: r,
                  rotateSpeedY: s,
                } = this.keyboard,
                { controllerState: o } = this;
              let a;
              const c = {};
              switch (t.srcEvent.code) {
                case "Minus":
                  (a = e ? o.zoomOut(n).zoomOut(n) : o.zoomOut(n)),
                    (c.isZooming = !0);
                  break;
                case "Equal":
                  (a = e ? o.zoomIn(n).zoomIn(n) : o.zoomIn(n)),
                    (c.isZooming = !0);
                  break;
                case "ArrowLeft":
                  e
                    ? ((a = o.rotateLeft(r)), (c.isRotating = !0))
                    : ((a = o.moveLeft(i)), (c.isPanning = !0));
                  break;
                case "ArrowRight":
                  e
                    ? ((a = o.rotateRight(r)), (c.isRotating = !0))
                    : ((a = o.moveRight(i)), (c.isPanning = !0));
                  break;
                case "ArrowUp":
                  e
                    ? ((a = o.rotateUp(s)), (c.isRotating = !0))
                    : ((a = o.moveUp(i)), (c.isPanning = !0));
                  break;
                case "ArrowDown":
                  e
                    ? ((a = o.rotateDown(s)), (c.isRotating = !0))
                    : ((a = o.moveDown(i)), (c.isPanning = !0));
                  break;
                default:
                  return !1;
              }
              return this.updateViewport(a, this._getTransitionProps(), c), !0;
            }
            _getTransitionProps(t) {
              const { _transition: e } = this;
              return e
                ? t
                  ? {
                      ...e,
                      transitionInterpolator: new yh({
                        ...t,
                        transitionProps: this.linearTransitionProps,
                        makeViewport: this.controllerState.makeViewport,
                      }),
                    }
                  : e
                : _h;
            }
          } {
            constructor(t) {
              (t.dragMode = t.dragMode || "pan"), super(Sh, t);
            }
            setProps(t) {
              const e = this.controllerStateProps;
              super.setProps(t),
                (!e || e.height !== t.height) &&
                  this.updateViewport(
                    new this.ControllerState({
                      makeViewport: this.makeViewport,
                      ...this.controllerStateProps,
                      ...this._state,
                    })
                  );
            }
            get linearTransitionProps() {
              return ["longitude", "latitude", "zoom", "bearing", "pitch"];
            }
          }
          class Ch extends class {
            constructor(t = {}) {
              const {
                id: e = null,
                x: n = 0,
                y: i = 0,
                width: r = "100%",
                height: s = "100%",
                viewportInstance: o,
                type: a = Is,
              } = t;
              Je(!o || o instanceof Is),
                (this.viewportInstance = o),
                (this.id = e || this.constructor.displayName || "view"),
                (this.type = a),
                (this.props = { ...t, id: this.id }),
                this._parseDimensions({ x: n, y: i, width: r, height: s }),
                (this.equals = this.equals.bind(this)),
                Object.seal(this);
            }
            equals(t) {
              return (
                this === t ||
                (this.viewportInstance
                  ? t.viewportInstance &&
                    this.viewportInstance.equals(t.viewportInstance)
                  : ah(this.props, t.props))
              );
            }
            makeViewport({ width: t, height: e, viewState: n }) {
              if (this.viewportInstance) return this.viewportInstance;
              n = this.filterViewState(n);
              const i = this.getDimensions({ width: t, height: e });
              return this._getViewport(n, i);
            }
            getViewStateId() {
              switch (typeof this.props.viewState) {
                case "string":
                  return this.props.viewState;
                case "object":
                  return this.props.viewState && this.props.viewState.id;
                default:
                  return this.id;
              }
            }
            filterViewState(t) {
              if (
                this.props.viewState &&
                "object" == typeof this.props.viewState
              ) {
                if (!this.props.viewState.id) return this.props.viewState;
                const e = { ...t };
                for (const t in this.props.viewState)
                  "id" !== t && (e[t] = this.props.viewState[t]);
                return e;
              }
              return t;
            }
            getDimensions({ width: t, height: e }) {
              return {
                x: uh(this._x, t),
                y: uh(this._y, e),
                width: uh(this._width, t),
                height: uh(this._height, e),
              };
            }
            _getControllerProps(t) {
              let e = this.props.controller;
              return e
                ? !0 === e
                  ? t
                  : ("function" == typeof e && (e = { type: e }),
                    { ...t, ...e })
                : null;
            }
            _getViewport(t, e) {
              const { type: n } = this;
              return new n({ ...t, ...this.props, ...e });
            }
            _parseDimensions({ x: t, y: e, width: n, height: i }) {
              (this._x = hh(t)),
                (this._y = hh(e)),
                (this._width = hh(n)),
                (this._height = hh(i));
            }
          } {
            constructor(t) {
              super({ ...t, type: Fs });
            }
            get controller() {
              return this._getControllerProps({ type: Mh });
            }
          }
          Ch.displayName = "MapView";
          const Lh = [255, 255, 255],
            Oh = 1;
          let Ih = 0;
          class Rh {
            constructor(t = {}) {
              const { color: e = Lh } = t,
                { intensity: n = Oh } = t;
              (this.id = t.id || "ambient-".concat(Ih++)),
                (this.color = e),
                (this.intensity = n),
                (this.type = "ambient");
            }
          }
          const kh = [255, 255, 255],
            Fh = 1,
            zh = [0, 0, -1];
          let jh = 0;
          class Bh {
            constructor(t = {}) {
              const { color: e = kh } = t,
                { intensity: n = Fh } = t,
                { direction: i = zh } = t,
                { _shadow: r = !1 } = t;
              (this.id = t.id || "directional-".concat(jh++)),
                (this.color = e),
                (this.intensity = n),
                (this.type = "directional"),
                (this.direction = new He(i).normalize().toArray()),
                (this.shadow = r);
            }
            getProjectedLight() {
              return this;
            }
          }
          class Dh {
            constructor(t = {}) {
              const { id: e = "effect" } = t;
              (this.id = e), (this.props = { ...t });
            }
            preRender() {}
            getModuleParameters() {}
            cleanup() {}
          }
          class Nh extends class {
            constructor(t, e = {}) {
              const { id: n = "pass" } = e;
              (this.id = n), (this.gl = t), (this.props = { ...e });
            }
            setProps(t) {
              Object.assign(this.props, t);
            }
            render() {}
            cleanup() {}
          } {
            render(t) {
              return (
                dt(this.gl, { framebuffer: t.target }), this._drawLayers(t)
              );
            }
            _drawLayers(t) {
              const {
                viewports: e,
                views: n,
                onViewportActive: i,
                clearCanvas: r = !0,
              } = t;
              t.pass = t.pass || "unknown";
              const s = this.gl;
              r &&
                (function (t) {
                  dt(t, {
                    viewport: [
                      0,
                      0,
                      t.drawingBufferWidth,
                      t.drawingBufferHeight,
                    ],
                  }),
                    t.clear(16640);
                })(s);
              const o = [];
              for (const r of e) {
                const e = r.viewport || r,
                  a = n && n[e.id];
                i(e);
                const c = this._getDrawLayerParams(e, t);
                t.view = a;
                const l = e.subViewports || [e];
                for (const e of l) {
                  t.viewport = e;
                  const n = this._drawLayersInViewport(s, t, c);
                  o.push(n);
                }
              }
              return o;
            }
            _getDrawLayerParams(
              t,
              {
                layers: e,
                pass: n,
                layerFilter: i,
                effects: r,
                moduleParameters: s,
              }
            ) {
              const o = [],
                a = Uh(),
                c = {
                  viewport: t,
                  isPicking: n.startsWith("picking"),
                  renderPass: n,
                },
                l = {};
              for (let h = 0; h < e.length; h++) {
                const u = e[h],
                  d = this._shouldDrawLayer(u, c, i, l),
                  f = { shouldDrawLayer: d, layerRenderIndex: a(u, d) };
                d &&
                  ((f.moduleParameters = this._getModuleParameters(u, r, n, s)),
                  (f.layerParameters = this.getLayerParameters(u, h, t))),
                  (o[h] = f);
              }
              return o;
            }
            _drawLayersInViewport(
              t,
              { layers: e, pass: n, viewport: i, view: r },
              s
            ) {
              const o = (function (t, { viewport: e }) {
                const n = t.canvas
                    ? t.canvas.clientHeight || t.canvas.height
                    : 100,
                  i = e,
                  r = gt(t);
                return [
                  i.x * r,
                  (n - i.y - i.height) * r,
                  i.width * r,
                  i.height * r,
                ];
              })(t, { viewport: i });
              if (r && r.props.clear) {
                const e =
                  !0 === r.props.clear
                    ? { color: !0, depth: !0 }
                    : r.props.clear;
                pt(t, { scissorTest: !0, scissor: o }, () => ae(t, e));
              }
              const a = {
                totalCount: e.length,
                visibleCount: 0,
                compositeCount: 0,
                pickableCount: 0,
              };
              dt(t, { viewport: o });
              for (let t = 0; t < e.length; t++) {
                const r = e[t],
                  {
                    shouldDrawLayer: o,
                    layerRenderIndex: c,
                    moduleParameters: l,
                    layerParameters: h,
                  } = s[t];
                if ((o && r.props.pickable && a.pickableCount++, r.isComposite))
                  a.compositeCount++;
                else if (o) {
                  a.visibleCount++, (l.viewport = i);
                  try {
                    r.drawLayer({
                      moduleParameters: l,
                      uniforms: { layerIndex: c },
                      parameters: h,
                    });
                  } catch (t) {
                    r.raiseError(t, "drawing ".concat(r, " to ").concat(n));
                  }
                }
              }
              return a;
            }
            shouldDrawLayer(t) {
              return !0;
            }
            getModuleParameters(t, e) {
              return null;
            }
            getLayerParameters(t, e) {
              return t.props.parameters;
            }
            _shouldDrawLayer(t, e, n, i) {
              if (!this.shouldDrawLayer(t) || !t.props.visible) return !1;
              e.layer = t;
              let r = t.parent;
              for (; r; ) {
                if (!r.props.visible || !r.filterSubLayer(e)) return !1;
                (e.layer = r), (r = r.parent);
              }
              if (n) {
                const t = e.layer.id;
                if ((t in i || (i[t] = n(e)), !i[t])) return !1;
              }
              return t.activateViewport(e.viewport), !0;
            }
            _getModuleParameters(t, e, n, i) {
              const r = Object.assign(Object.create(t.props), {
                autoWrapLongitude: t.wrapLongitude,
                viewport: t.context.viewport,
                mousePosition: t.context.mousePosition,
                pickingActive: 0,
                devicePixelRatio: gt(this.gl),
              });
              if (e)
                for (const n of e) Object.assign(r, n.getModuleParameters(t));
              return Object.assign(r, this.getModuleParameters(t, e), i);
            }
          }
          function Uh(t = 0, e = {}) {
            const n = {},
              i = (r, s) => {
                const o = r.props._offset,
                  a = r.id,
                  c = r.parent && r.parent.id;
                let l;
                if ((c && !(c in e) && i(r.parent, !1), c in n)) {
                  const t = (n[c] = n[c] || Uh(e[c], e));
                  (l = t(r, s)), (n[a] = t);
                } else
                  Number.isFinite(o)
                    ? ((l = o + (e[c] || 0)), (n[a] = null))
                    : (l = t);
                return s && l >= t && (t = l + 1), (e[a] = l), l;
              };
            return i;
          }
          class Vh extends Nh {
            constructor(t, e) {
              super(t, e),
                (this.shadowMap = new ne(t, {
                  width: 1,
                  height: 1,
                  parameters: {
                    10241: 9729,
                    10240: 9729,
                    10242: 33071,
                    10243: 33071,
                  },
                })),
                (this.depthBuffer = new se(t, {
                  format: 33189,
                  width: 1,
                  height: 1,
                })),
                (this.fbo = new ye(t, {
                  id: "shadowmap",
                  width: 1,
                  height: 1,
                  attachments: {
                    36064: this.shadowMap,
                    36096: this.depthBuffer,
                  },
                }));
            }
            render(t) {
              const e = this.fbo;
              pt(
                this.gl,
                {
                  depthRange: [0, 1],
                  depthTest: !0,
                  blend: !1,
                  clearColor: [1, 1, 1, 1],
                },
                () => {
                  const n = t.viewports[0],
                    i = gt(this.gl),
                    r = n.width * i,
                    s = n.height * i;
                  (r === e.width && s === e.height) ||
                    e.resize({ width: r, height: s }),
                    super.render({ ...t, target: e, pass: "shadow" });
                }
              );
            }
            shouldDrawLayer(t) {
              return !1 !== t.props.shadowEnabled;
            }
            getModuleParameters() {
              return { drawToShadowMap: !0 };
            }
            delete() {
              this.fbo && (this.fbo.delete(), (this.fbo = null)),
                this.shadowMap &&
                  (this.shadowMap.delete(), (this.shadowMap = null)),
                this.depthBuffer &&
                  (this.depthBuffer.delete(), (this.depthBuffer = null));
            }
          }
          const Gh = Or(function ({ viewport: t, center: e }) {
              return new is(t.viewProjectionMatrix).invert().transform(e);
            }),
            Wh = Or(function ({ viewport: t, shadowMatrices: e }) {
              const n = [],
                i = t.pixelUnprojectionMatrix,
                r = t.isGeospatial ? void 0 : 1,
                s = [
                  [0, 0, r],
                  [t.width, 0, r],
                  [0, t.height, r],
                  [t.width, t.height, r],
                  [0, 0, -1],
                  [t.width, 0, -1],
                  [0, t.height, -1],
                  [t.width, t.height, -1],
                ].map((t) =>
                  (function (t, e) {
                    const [n, i, r] = t,
                      s = xs([n, i, r], e);
                    return Number.isFinite(r) ? s : [s[0], s[1], 0];
                  })(t, i)
                );
              for (const i of e) {
                const e = i.clone().translate(new He(t.center).negate()),
                  r = s.map((t) => e.transform(t)),
                  o = new is().ortho({
                    left: Math.min(...r.map((t) => t[0])),
                    right: Math.max(...r.map((t) => t[0])),
                    bottom: Math.min(...r.map((t) => t[1])),
                    top: Math.max(...r.map((t) => t[1])),
                    near: Math.min(...r.map((t) => -t[2])),
                    far: Math.max(...r.map((t) => -t[2])),
                  });
                n.push(o.multiplyRight(i));
              }
              return n;
            }),
            Hh = [0, 0, 0, 1],
            $h = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            Xh = {
              name: "shadow",
              dependencies: [Da],
              vs: "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n",
              fs: "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n",
              inject: {
                "vs:DECKGL_FILTER_GL_POSITION":
                  "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
                "fs:DECKGL_FILTER_COLOR":
                  "\n    color = shadow_filterShadowColor(color);\n    ",
              },
              getUniforms: (t = {}, e = {}) => {
                if (
                  t.drawToShadowMap ||
                  (t.shadowMaps && t.shadowMaps.length > 0)
                ) {
                  const { shadowEnabled: n = !0 } = t;
                  return n && t.shadowMatrices && t.shadowMatrices.length > 0
                    ? (function (t = {}, e = {}) {
                        const n = {
                            shadow_uDrawShadowMap: Boolean(t.drawToShadowMap),
                            shadow_uUseShadowMap:
                              !!t.shadowMaps && t.shadowMaps.length > 0,
                            shadow_uColor: t.shadowColor || Hh,
                            shadow_uLightId: t.shadowLightId || 0,
                            shadow_uLightCount: t.shadowMatrices.length,
                          },
                          i = Gh({
                            viewport: t.viewport,
                            center: e.project_uCenter,
                          }),
                          r = [],
                          s = Wh({
                            shadowMatrices: t.shadowMatrices,
                            viewport: t.viewport,
                          }).slice();
                        for (let n = 0; n < t.shadowMatrices.length; n++) {
                          const o = s[n],
                            a = o
                              .clone()
                              .translate(new He(t.viewport.center).negate());
                          e.project_uCoordinateSystem === A.LNGLAT &&
                          e.project_uProjectionMode === T.WEB_MERCATOR
                            ? ((s[n] = a), (r[n] = i))
                            : ((s[n] = o.clone().multiplyRight($h)),
                              (r[n] = a.transform(i)));
                        }
                        for (let e = 0; e < s.length; e++)
                          (n["shadow_uViewProjectionMatrices[".concat(e, "]")] =
                            s[e]),
                            (n["shadow_uProjectCenters[".concat(e, "]")] =
                              r[e]),
                            t.shadowMaps && t.shadowMaps.length > 0
                              ? (n["shadow_uShadowMap".concat(e)] =
                                  t.shadowMaps[e])
                              : (n["shadow_uShadowMap".concat(e)] =
                                  t.dummyShadowMap);
                        return n;
                      })(t, e)
                    : { shadow_uDrawShadowMap: !1, shadow_uUseShadowMap: !1 };
                }
                return {};
              },
            },
            Yh = { color: [255, 255, 255], intensity: 1 },
            qh = [
              { color: [255, 255, 255], intensity: 1, direction: [-1, 3, -1] },
              {
                color: [255, 255, 255],
                intensity: 0.9,
                direction: [1, -8, -2.5],
              },
            ],
            Zh = [0, 0, 0, 200 / 255];
          class Kh extends Dh {
            constructor(t) {
              super(t),
                (this.ambientLight = null),
                (this.directionalLights = []),
                (this.pointLights = []),
                (this.shadowColor = Zh),
                (this.shadowPasses = []),
                (this.shadowMaps = []),
                (this.dummyShadowMap = null),
                (this.shadow = !1),
                (this.programManager = null);
              for (const e in t) {
                const n = t[e];
                switch (n.type) {
                  case "ambient":
                    this.ambientLight = n;
                    break;
                  case "directional":
                    this.directionalLights.push(n);
                    break;
                  case "point":
                    this.pointLights.push(n);
                }
              }
              this._applyDefaultLights(),
                (this.shadow = this.directionalLights.some((t) => t.shadow));
            }
            preRender(
              t,
              {
                layers: e,
                layerFilter: n,
                viewports: i,
                onViewportActive: r,
                views: s,
              }
            ) {
              if (this.shadow) {
                (this.shadowMatrices = this._createLightMatrix()),
                  0 === this.shadowPasses.length && this._createShadowPasses(t),
                  this.programManager ||
                    ((this.programManager = Hi.getDefaultProgramManager(t)),
                    Xh && this.programManager.addDefaultModule(Xh)),
                  this.dummyShadowMap ||
                    (this.dummyShadowMap = new ne(t, { width: 1, height: 1 }));
                for (let t = 0; t < this.shadowPasses.length; t++)
                  this.shadowPasses[t].render({
                    layers: e,
                    layerFilter: n,
                    viewports: i,
                    onViewportActive: r,
                    views: s,
                    moduleParameters: {
                      shadowLightId: t,
                      dummyShadowMap: this.dummyShadowMap,
                      shadowMatrices: this.shadowMatrices,
                    },
                  });
              }
            }
            getModuleParameters(t) {
              const e = this.shadow
                ? {
                    shadowMaps: this.shadowMaps,
                    dummyShadowMap: this.dummyShadowMap,
                    shadowColor: this.shadowColor,
                    shadowMatrices: this.shadowMatrices,
                  }
                : {};
              return (
                (e.lightSources = {
                  ambientLight: this.ambientLight,
                  directionalLights: this.directionalLights.map((e) =>
                    e.getProjectedLight({ layer: t })
                  ),
                  pointLights: this.pointLights.map((e) =>
                    e.getProjectedLight({ layer: t })
                  ),
                }),
                e
              );
            }
            cleanup() {
              for (const t of this.shadowPasses) t.delete();
              (this.shadowPasses.length = 0),
                (this.shadowMaps.length = 0),
                this.dummyShadowMap &&
                  (this.dummyShadowMap.delete(), (this.dummyShadowMap = null)),
                this.shadow &&
                  this.programManager &&
                  (this.programManager.removeDefaultModule(Xh),
                  (this.programManager = null));
            }
            _createLightMatrix() {
              const t = [];
              for (const e of this.directionalLights) {
                const n = new is().lookAt({
                  eye: new He(e.direction).negate(),
                });
                t.push(n);
              }
              return t;
            }
            _createShadowPasses(t) {
              for (let e = 0; e < this.directionalLights.length; e++) {
                const n = new Vh(t);
                (this.shadowPasses[e] = n), (this.shadowMaps[e] = n.shadowMap);
              }
            }
            _applyDefaultLights() {
              const {
                ambientLight: t,
                pointLights: e,
                directionalLights: n,
              } = this;
              t ||
                0 !== e.length ||
                0 !== n.length ||
                ((this.ambientLight = new Rh(Yh)),
                this.directionalLights.push(new Bh(qh[0]), new Bh(qh[1])));
            }
          }
          const Jh = new Kh();
          class Qh {
            constructor() {
              (this.effects = []),
                (this._internalEffects = []),
                (this._needsRedraw = "Initial render"),
                this.setEffects();
            }
            setProps(t) {
              "effects" in t &&
                ((t.effects.length === this.effects.length &&
                  ah(t.effects, this.effects)) ||
                  (this.setEffects(t.effects),
                  (this._needsRedraw = "effects changed")));
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this._needsRedraw;
              return t.clearRedrawFlags && (this._needsRedraw = !1), e;
            }
            getEffects() {
              return this._internalEffects;
            }
            finalize() {
              this.cleanup();
            }
            setEffects(t = []) {
              this.cleanup(), (this.effects = t), this._createInternalEffects();
            }
            cleanup() {
              for (const t of this.effects) t.cleanup();
              for (const t of this._internalEffects) t.cleanup();
              (this.effects.length = 0), (this._internalEffects.length = 0);
            }
            _createInternalEffects() {
              (this._internalEffects = this.effects.slice()),
                this.effects.some((t) => t instanceof Kh) ||
                  this._internalEffects.push(Jh);
            }
          }
          class tu extends Nh {}
          const eu = { blendFunc: [1, 0, 32771, 0], blendEquation: 32774 };
          class nu extends Nh {
            render(t) {
              return t.pickingFBO
                ? this._drawPickingBuffer(t)
                : super.render(t);
            }
            _drawPickingBuffer({
              layers: t,
              layerFilter: e,
              views: n,
              viewports: i,
              onViewportActive: r,
              pickingFBO: s,
              deviceRect: { x: o, y: a, width: c, height: l },
              pass: h = "picking",
              redrawReason: u,
              pickZ: d,
            }) {
              const f = this.gl;
              this.pickZ = d;
              const p = !d && { byLayer: new Map(), byAlpha: [] };
              this._colors = p;
              const g = pt(
                f,
                {
                  scissorTest: !0,
                  scissor: [o, a, c, l],
                  clearColor: [0, 0, 0, 0],
                  depthMask: !0,
                  depthTest: !0,
                  depthRange: [0, 1],
                  colorMask: [!0, !0, !0, !0],
                  ...eu,
                  blend: !d,
                },
                () =>
                  super.render({
                    target: s,
                    layers: t,
                    layerFilter: e,
                    views: n,
                    viewports: i,
                    onViewportActive: r,
                    pass: h,
                    redrawReason: u,
                  })
              );
              return (
                (this._colors = null),
                { decodePickingColor: p && iu.bind(null, p), stats: g }
              );
            }
            shouldDrawLayer(t) {
              return t.props.pickable;
            }
            getModuleParameters() {
              return {
                pickingActive: 1,
                pickingAttribute: this.pickZ,
                lightSources: {},
              };
            }
            getLayerParameters(t, e, n) {
              const i = { ...t.props.parameters };
              return (
                this.pickZ
                  ? (i.blend = !1)
                  : (Object.assign(i, eu),
                    (i.blend = !0),
                    (i.blendColor = (function (t, e, n) {
                      const { byLayer: i, byAlpha: r } = t;
                      let s;
                      if (i.has(e)) {
                        const t = i.get(e);
                        t.viewports.push(n), (s = t.a);
                      } else if (((s = i.size + 1), s <= 255)) {
                        const t = { a: s, layer: e, viewports: [n] };
                        i.set(e, t), (r[s] = t);
                      } else
                        E.warn(
                          "Too many pickable layers, only picking the first 255"
                        )(),
                          (s = 0);
                      return [0, 0, 0, s / 255];
                    })(this._colors, t, n))),
                i
              );
            }
          }
          function iu(t, e) {
            const n = t.byAlpha[e[3]];
            return (
              n && {
                pickedLayer: n.layer,
                pickedViewports: n.viewports,
                pickedObjectIndex: n.layer.decodePickingColor(e),
              }
            );
          }
          class ru {
            constructor(t) {
              (this.gl = t),
                (this.layerFilter = null),
                (this.drawPickingColors = !1),
                (this.drawLayersPass = new tu(t)),
                (this.pickLayersPass = new nu(t)),
                (this.renderCount = 0),
                (this._needsRedraw = "Initial render"),
                (this.renderBuffers = []),
                (this.lastPostProcessEffect = null);
            }
            setProps(t) {
              "layerFilter" in t &&
                this.layerFilter !== t.layerFilter &&
                ((this.layerFilter = t.layerFilter),
                (this._needsRedraw = "layerFilter changed")),
                "drawPickingColors" in t &&
                  this.drawPickingColors !== t.drawPickingColors &&
                  ((this.drawPickingColors = t.drawPickingColors),
                  (this._needsRedraw = "drawPickingColors changed"));
            }
            renderLayers(t) {
              const e = this.drawPickingColors
                ? this.pickLayersPass
                : this.drawLayersPass;
              (t.layerFilter = t.layerFilter || this.layerFilter),
                (t.effects = t.effects || []),
                (t.target = t.target || ye.getDefaultFramebuffer(this.gl)),
                this._preRender(t.effects, t);
              const n = this.lastPostProcessEffect
                  ? this.renderBuffers[0]
                  : t.target,
                i = e.render({ ...t, target: n });
              this._postRender(t.effects, t),
                this.renderCount++,
                bn("deckRenderer.renderLayers", this, i, t);
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              const e = this._needsRedraw;
              return t.clearRedrawFlags && (this._needsRedraw = !1), e;
            }
            finalize() {
              const { renderBuffers: t } = this;
              for (const e of t) e.delete();
              t.length = 0;
            }
            _preRender(t, e) {
              let n = null;
              for (const i of t)
                i.preRender(this.gl, e), i.postRender && (n = i);
              n && this._resizeRenderBuffers(),
                (this.lastPostProcessEffect = n);
            }
            _resizeRenderBuffers() {
              const { renderBuffers: t } = this;
              0 === t.length && t.push(new ye(this.gl), new ye(this.gl));
              for (const e of t) e.resize();
            }
            _postRender(t, e) {
              const { renderBuffers: n } = this,
                i = { inputBuffer: n[0], swapBuffer: n[1], target: null };
              for (const r of t)
                if (r.postRender) {
                  if (r === this.lastPostProcessEffect) {
                    (i.target = e.target), r.postRender(this.gl, i);
                    break;
                  }
                  const t = r.postRender(this.gl, i);
                  (i.inputBuffer = t),
                    (i.swapBuffer = t === n[0] ? n[1] : n[0]);
                }
            }
          }
          const su = {
            pickedColor: null,
            pickedLayer: null,
            pickedObjectIndex: -1,
          };
          function ou({
            pickedColors: t,
            decodePickingColor: e,
            deviceX: n,
            deviceY: i,
            deviceRadius: r,
            deviceRect: s,
          }) {
            if (t) {
              const { x: o, y: a, width: c, height: l } = s;
              let h = r * r,
                u = -1,
                d = 0;
              for (let e = 0; e < l; e++) {
                const r = e + a - i,
                  s = r * r;
                if (s > h) d += 4 * c;
                else
                  for (let e = 0; e < c; e++) {
                    if (t[d + 3] - 1 >= 0) {
                      const t = e + o - n,
                        i = t * t + s;
                      i <= h && ((h = i), (u = d));
                    }
                    d += 4;
                  }
              }
              if (u >= 0) {
                const n = t.slice(u, u + 4),
                  i = e(n);
                if (i) {
                  const t = Math.floor(u / 4 / c),
                    e = u / 4 - t * c;
                  return {
                    ...i,
                    pickedColor: n,
                    pickedX: o + e,
                    pickedY: a + t,
                  };
                }
                E.error(
                  "Picked non-existent layer. Is picking buffer corrupt?"
                )();
              }
            }
            return su;
          }
          function au({
            pickInfo: t,
            viewports: e,
            pixelRatio: n,
            x: i,
            y: r,
            z: s,
          }) {
            let o = e[0];
            e.length > 1 &&
              (o = (function (t, e) {
                for (let n = t.length - 1; n >= 0; n--) {
                  const i = t[n];
                  if (i.containsPixel(e)) return i;
                }
                return t[0];
              })((null == t ? void 0 : t.pickedViewports) || e, {
                x: i,
                y: r,
              }));
            const a = o && o.unproject([i - o.x, r - o.y], { targetZ: s });
            return {
              color: null,
              layer: null,
              viewport: o,
              index: -1,
              picked: !1,
              x: i,
              y: r,
              pixel: [i, r],
              coordinate: a,
              devicePixel: t && [t.pickedX, t.pickedY],
              pixelRatio: n,
            };
          }
          function cu(t) {
            const { pickInfo: e, lastPickedInfo: n, mode: i, layers: r } = t,
              { pickedColor: s, pickedLayer: o, pickedObjectIndex: a } = e,
              c = o ? [o] : [];
            if ("hover" === i) {
              const t = n.index,
                e = n.layerId,
                i = o && o.props.id;
              if (i !== e || a !== t) {
                if (i !== e) {
                  const t = r.find((t) => t.props.id === e);
                  t && c.unshift(t);
                }
                (n.layerId = i), (n.index = a), (n.info = null);
              }
            }
            const l = au(t),
              h = new Map();
            return (
              h.set(null, l),
              c.forEach((t) => {
                let e = { ...l };
                t === o && ((e.color = s), (e.index = a), (e.picked = !0)),
                  (e = lu({ layer: t, info: e, mode: i })),
                  t === o && "hover" === i && (n.info = e),
                  h.set(e.layer.id, e),
                  "hover" === i && e.layer.updateAutoHighlight(e);
              }),
              h
            );
          }
          function lu({ layer: t, info: e, mode: n }) {
            for (; t && e; ) {
              const i = e.layer || null;
              (e.sourceLayer = i),
                (e.layer = t),
                (e = t.getPickingInfo({ info: e, mode: n, sourceLayer: i })),
                (t = t.parent);
            }
            return e;
          }
          class hu {
            constructor(t) {
              (this.gl = t),
                (this.pickingFBO = null),
                (this.pickLayersPass = new nu(t)),
                (this.layerFilter = null),
                (this.lastPickedInfo = {
                  index: -1,
                  layerId: null,
                  info: null,
                });
            }
            setProps(t) {
              "layerFilter" in t && (this.layerFilter = t.layerFilter),
                "_pickable" in t && (this._pickable = t._pickable);
            }
            finalize() {
              this.pickingFBO && this.pickingFBO.delete(),
                this.depthFBO &&
                  (this.depthFBO.color.delete(), this.depthFBO.delete());
            }
            pickObject(t) {
              return this._pickClosestObject(t);
            }
            pickObjects(t) {
              return this._pickVisibleObjects(t);
            }
            getLastPickedObject(
              { x: t, y: e, layers: n, viewports: i },
              r = this.lastPickedInfo.info
            ) {
              const s = r && r.layer && r.layer.id,
                o = r && r.viewport && r.viewport.id,
                a = s ? n.find((t) => t.id === s) : null,
                c = (o && i.find((t) => t.id === o)) || i[0],
                l = c && c.unproject([t - c.x, e - c.y]),
                h = { x: t, y: e, viewport: c, coordinate: l, layer: a };
              return a
                ? { ...r, ...h }
                : Object.assign(h, { color: null, object: null, index: -1 });
            }
            _resizeBuffer() {
              const { gl: t } = this;
              return (
                this.pickingFBO ||
                  ((this.pickingFBO = new ye(t)),
                  ye.isSupported(t, { colorBufferFloat: !0 }) &&
                    ((this.depthFBO = new ye(t)),
                    this.depthFBO.attach({
                      36064: new ne(t, {
                        format: I(t) ? 34836 : 6408,
                        type: 5126,
                      }),
                    }))),
                this.pickingFBO.resize({
                  width: t.canvas.width,
                  height: t.canvas.height,
                }),
                this.depthFBO &&
                  this.depthFBO.resize({
                    width: t.canvas.width,
                    height: t.canvas.height,
                  }),
                this.pickingFBO
              );
            }
            _getPickable(t) {
              if (!1 === this._pickable) return null;
              const e = t.filter((t) => t.isPickable() && !t.isComposite);
              return e.length ? e : null;
            }
            _pickClosestObject({
              layers: t,
              views: e,
              viewports: n,
              x: i,
              y: r,
              radius: s = 0,
              depth: o = 1,
              mode: a = "query",
              unproject3D: c,
              onViewportActive: l,
            }) {
              if (!(t = this._getPickable(t)))
                return {
                  result: [],
                  emptyInfo: au({ viewports: n, x: i, y: r }),
                };
              this._resizeBuffer();
              const h = gt(this.gl),
                u = mt(this.gl, [i, r], !0),
                d = [
                  u.x + Math.floor(u.width / 2),
                  u.y + Math.floor(u.height / 2),
                ],
                f = Math.round(s * h),
                { width: p, height: g } = this.pickingFBO,
                m = this._getPickingRect({
                  deviceX: d[0],
                  deviceY: d[1],
                  deviceRadius: f,
                  deviceWidth: p,
                  deviceHeight: g,
                });
              let y;
              const _ = [],
                v = {};
              for (let s = 0; s < o; s++) {
                const u = ou({
                  ...(m &&
                    this._drawAndSample({
                      layers: t,
                      views: e,
                      viewports: n,
                      onViewportActive: l,
                      deviceRect: m,
                      pass: "picking:".concat(a),
                      redrawReason: a,
                    })),
                  deviceX: d[0],
                  deviceY: d[1],
                  deviceRadius: f,
                  deviceRect: m,
                });
                let p;
                if (
                  (u.pickedLayer &&
                    c &&
                    this.depthFBO &&
                    (p =
                      this._drawAndSample({
                        layers: [u.pickedLayer],
                        views: e,
                        viewports: n,
                        onViewportActive: l,
                        deviceRect: {
                          x: u.pickedX,
                          y: u.pickedY,
                          width: 1,
                          height: 1,
                        },
                        pass: "picking:".concat(a),
                        redrawReason: "pick-z",
                        pickZ: !0,
                      }).pickedColors[0] *
                        n[0].distanceScales.metersPerUnit[2] +
                      n[0].position[2]),
                  u.pickedColor && s + 1 < o)
                ) {
                  const e = u.pickedColor[3] - 1;
                  (v[e] = !0), t[e].disablePickingIndex(u.pickedObjectIndex);
                }
                y = cu({
                  pickInfo: u,
                  lastPickedInfo: this.lastPickedInfo,
                  mode: a,
                  layers: t,
                  viewports: n,
                  x: i,
                  y: r,
                  z: p,
                  pixelRatio: h,
                });
                for (const t of y.values()) t.layer && _.push(t);
                if (!u.pickedColor) break;
              }
              for (const e in v) t[e].restorePickingColors();
              return { result: _, emptyInfo: y && y.get(null) };
            }
            _pickVisibleObjects({
              layers: t,
              views: e,
              viewports: n,
              x: i,
              y: r,
              width: s = 1,
              height: o = 1,
              mode: a = "query",
              maxObjects: c = null,
              onViewportActive: l,
            }) {
              if (!(t = this._getPickable(t))) return [];
              this._resizeBuffer();
              const h = gt(this.gl),
                u = mt(this.gl, [i, r], !0),
                d = u.x,
                f = u.y + u.height,
                p = mt(this.gl, [i + s, r + o], !0),
                g = p.x + p.width,
                m = p.y,
                y = { x: d, y: m, width: g - d, height: f - m },
                _ = (function ({ pickedColors: t, decodePickingColor: e }) {
                  const n = new Map();
                  if (t)
                    for (let i = 0; i < t.length; i += 4)
                      if (t[i + 3] - 1 >= 0) {
                        const r = t.slice(i, i + 4),
                          s = r.join(",");
                        if (!n.has(s)) {
                          const t = e(r);
                          t
                            ? n.set(s, { ...t, pickedColor: r })
                            : E.error(
                                "Picked non-existent layer. Is picking buffer corrupt?"
                              )();
                        }
                      }
                  return Array.from(n.values());
                })(
                  this._drawAndSample({
                    layers: t,
                    views: e,
                    viewports: n,
                    onViewportActive: l,
                    deviceRect: y,
                    pass: "picking:".concat(a),
                    redrawReason: a,
                  })
                ),
                v = new Map(),
                b = Number.isFinite(c);
              for (let t = 0; t < _.length && !(b && v.size >= c); t++) {
                const e = _[t];
                let n = {
                  color: e.pickedColor,
                  layer: null,
                  index: e.pickedObjectIndex,
                  picked: !0,
                  x: i,
                  y: r,
                  width: s,
                  height: o,
                  pixelRatio: h,
                };
                (n = lu({ layer: e.pickedLayer, info: n, mode: a })),
                  v.has(n.object) || v.set(n.object, n);
              }
              return Array.from(v.values());
            }
            _drawAndSample({
              layers: t,
              views: e,
              viewports: n,
              onViewportActive: i,
              deviceRect: r,
              pass: s,
              redrawReason: o,
              pickZ: a,
            }) {
              const c = a ? this.depthFBO : this.pickingFBO,
                { decodePickingColor: l } = this.pickLayersPass.render({
                  layers: t,
                  layerFilter: this.layerFilter,
                  views: e,
                  viewports: n,
                  onViewportActive: i,
                  pickingFBO: c,
                  deviceRect: r,
                  pass: s,
                  redrawReason: o,
                  pickZ: a,
                }),
                { x: h, y: u, width: d, height: f } = r,
                p = new (a ? Float32Array : Uint8Array)(d * f * 4);
              return (
                fe(c, {
                  sourceX: h,
                  sourceY: u,
                  sourceWidth: d,
                  sourceHeight: f,
                  target: p,
                }),
                { pickedColors: p, decodePickingColor: l }
              );
            }
            _getPickingRect({
              deviceX: t,
              deviceY: e,
              deviceRadius: n,
              deviceWidth: i,
              deviceHeight: r,
            }) {
              const s = Math.max(0, t - n),
                o = Math.max(0, e - n),
                a = Math.min(i, t + n + 1) - s,
                c = Math.min(r, e + n + 1) - o;
              return a <= 0 || c <= 0
                ? null
                : { x: s, y: o, width: a, height: c };
            }
          }
          const uu = {
            zIndex: 1,
            position: "absolute",
            pointerEvents: "none",
            color: "#a0a7b4",
            backgroundColor: "#29323c",
            padding: "10px",
            top: 0,
            left: 0,
            display: "none",
          };
          class du {
            constructor(t) {
              const e = t.parentElement;
              e &&
                ((this.el = document.createElement("div")),
                (this.el.className = "deck-tooltip"),
                Object.assign(this.el.style, uu),
                e.appendChild(this.el)),
                (this.isVisible = !1);
            }
            setTooltip(t, e, n) {
              const i = this.el;
              if ("string" == typeof t) i.innerText = t;
              else {
                if (!t)
                  return (this.isVisible = !1), void (i.style.display = "none");
                "text" in t && (i.innerText = t.text),
                  "html" in t && (i.innerHTML = t.html),
                  "className" in t && (i.className = t.className),
                  Object.assign(i.style, t.style);
              }
              (this.isVisible = !0),
                (i.style.display = "block"),
                (i.style.transform = "translate("
                  .concat(e, "px, ")
                  .concat(n, "px)"));
            }
            remove() {
              this.el && this.el.remove();
            }
          }
          const fu = {
              name: "JSON",
              extensions: ["json", "geojson"],
              mimeTypes: ["application/json", "application/geo+json"],
              testText: function (t) {
                const e = t[0],
                  n = t[t.length - 1];
                return ("{" === e && "}" === n) || ("[" === e && "]" === n);
              },
              parseTextSync: JSON.parse,
            },
            pu = "8.6.0",
            gu = F.CO.deck && F.CO.deck.VERSION;
          if (gu && gu !== pu)
            throw new Error(
              "deck.gl - multiple versions detected: "
                .concat(gu, " vs ")
                .concat(pu)
            );
          gu ||
            (E.log(1, "deck.gl ".concat(pu))(),
            (F.CO.deck = Object.assign(F.CO.deck || {}, {
              VERSION: pu,
              version: pu,
              log: E,
              _registerLoggers: function (t) {
                vn = t;
              },
            })),
            (function (t) {
              const e = ga();
              t = Array.isArray(t) ? t : [t];
              for (const n of t) {
                const t = wo(n);
                e.find((e) => t === e) || e.unshift(t);
              }
            })([fu, [fc, { imagebitmap: { premultiplyAlpha: "none" } }]]));
          const mu = F.CO.deck;
          class yu extends Bt {
            static isSupported(t, e = []) {
              const n = I(t),
                i = we(t, _e);
              let r = n || i;
              for (const t of e)
                switch (t) {
                  case "queries":
                    r = r && n;
                    break;
                  case "timers":
                    r = r && i;
                    break;
                  default:
                    Ct(!1);
                }
              return r;
            }
            constructor(t, e = {}) {
              super(t, e),
                (this.target = null),
                (this._queryPending = !1),
                (this._pollingPromise = null),
                Object.seal(this);
            }
            beginTimeElapsedQuery() {
              return this.begin(35007);
            }
            beginOcclusionQuery({ conservative: t = !1 } = {}) {
              return this.begin(t ? 36202 : 35887);
            }
            beginTransformFeedbackQuery() {
              return this.begin(35976);
            }
            begin(t) {
              return (
                this._queryPending ||
                  ((this.target = t),
                  this.gl2.beginQuery(this.target, this.handle)),
                this
              );
            }
            end() {
              return (
                this._queryPending ||
                  (this.target &&
                    (this.gl2.endQuery(this.target),
                    (this.target = null),
                    (this._queryPending = !0))),
                this
              );
            }
            isResultAvailable() {
              if (!this._queryPending) return !1;
              const t = this.gl2.getQueryParameter(this.handle, 34919);
              return t && (this._queryPending = !1), t;
            }
            isTimerDisjoint() {
              return this.gl2.getParameter(36795);
            }
            getResult() {
              return this.gl2.getQueryParameter(this.handle, 34918);
            }
            getTimerMilliseconds() {
              return this.getResult() / 1e6;
            }
            createPoll(t = Number.POSITIVE_INFINITY) {
              if (this._pollingPromise) return this._pollingPromise;
              let e = 0;
              return (
                (this._pollingPromise = new Promise((n, i) => {
                  const r = () => {
                    this.isResultAvailable()
                      ? (n(this.getResult()), (this._pollingPromise = null))
                      : e++ > t
                      ? (i("Timed out"), (this._pollingPromise = null))
                      : requestAnimationFrame(r);
                  };
                  requestAnimationFrame(r);
                })),
                this._pollingPromise
              );
            }
            _createHandle() {
              return yu.isSupported(this.gl) ? this.gl2.createQuery() : null;
            }
            _deleteHandle() {
              this.gl2.deleteQuery(this.handle);
            }
          }
          const _u = (0, F.jU)() && "undefined" != typeof document;
          let vu = 0;
          class bu {
            constructor(t = {}) {
              const {
                onCreateContext: e = (t) => xt(t),
                onAddHTML: n = null,
                onInitialize: i = () => {},
                onRender: r = () => {},
                onFinalize: s = () => {},
                onError: o,
                gl: a = null,
                glOptions: c = {},
                debug: l = !1,
                createFramebuffer: h = !1,
                autoResizeViewport: u = !0,
                autoResizeDrawingBuffer: d = !0,
                stats: f = Mt.get("animation-loop-" + vu++),
              } = t;
              let { useDevicePixels: p = !0 } = t;
              "useDevicePixelRatio" in t &&
                (C.deprecated("useDevicePixelRatio", "useDevicePixels")(),
                (p = t.useDevicePixelRatio)),
                (this.props = {
                  onCreateContext: e,
                  onAddHTML: n,
                  onInitialize: i,
                  onRender: r,
                  onFinalize: s,
                  onError: o,
                  gl: a,
                  glOptions: c,
                  debug: l,
                  createFramebuffer: h,
                }),
                (this.gl = a),
                (this.needsRedraw = null),
                (this.timeline = null),
                (this.stats = f),
                (this.cpuTime = this.stats.get("CPU Time")),
                (this.gpuTime = this.stats.get("GPU Time")),
                (this.frameRate = this.stats.get("Frame Rate")),
                (this._initialized = !1),
                (this._running = !1),
                (this._animationFrameId = null),
                (this._nextFramePromise = null),
                (this._resolveNextFrame = null),
                (this._cpuStartTime = 0),
                this.setProps({
                  autoResizeViewport: u,
                  autoResizeDrawingBuffer: d,
                  useDevicePixels: p,
                }),
                (this.start = this.start.bind(this)),
                (this.stop = this.stop.bind(this)),
                (this._pageLoadPromise = null),
                (this._onMousemove = this._onMousemove.bind(this)),
                (this._onMouseleave = this._onMouseleave.bind(this));
            }
            delete() {
              this.stop(), this._setDisplay(null);
            }
            setNeedsRedraw(t) {
              return (
                Ct("string" == typeof t),
                (this.needsRedraw = this.needsRedraw || t),
                this
              );
            }
            setProps(t) {
              return (
                "autoResizeViewport" in t &&
                  (this.autoResizeViewport = t.autoResizeViewport),
                "autoResizeDrawingBuffer" in t &&
                  (this.autoResizeDrawingBuffer = t.autoResizeDrawingBuffer),
                "useDevicePixels" in t &&
                  (this.useDevicePixels = t.useDevicePixels),
                this
              );
            }
            start(t = {}) {
              if (this._running) return this;
              this._running = !0;
              const e = this._getPageLoadPromise()
                .then(() =>
                  !this._running || this._initialized
                    ? null
                    : (this._createWebGLContext(t),
                      this._createFramebuffer(),
                      this._startEventHandling(),
                      this._initializeCallbackData(),
                      this._updateCallbackData(),
                      this._resizeCanvasDrawingBuffer(),
                      this._resizeViewport(),
                      (this._gpuTimeQuery = yu.isSupported(this.gl, ["timers"])
                        ? new yu(this.gl)
                        : null),
                      (this._initialized = !0),
                      this.onInitialize(this.animationProps))
                )
                .then((t) => {
                  this._running &&
                    (this._addCallbackData(t || {}),
                    !1 !== t && this._startLoop());
                });
              return this.props.onError && e.catch(this.props.onError), this;
            }
            redraw() {
              return (
                this.isContextLost() ||
                  (this._beginTimers(),
                  this._setupFrame(),
                  this._updateCallbackData(),
                  this._renderFrame(this.animationProps),
                  this._clearNeedsRedraw(),
                  this.offScreen && this.gl.commit && this.gl.commit(),
                  this._resolveNextFrame &&
                    (this._resolveNextFrame(this),
                    (this._nextFramePromise = null),
                    (this._resolveNextFrame = null)),
                  this._endTimers()),
                this
              );
            }
            stop() {
              return (
                this._running &&
                  (this._finalizeCallbackData(),
                  this._cancelAnimationFrame(this._animationFrameId),
                  (this._nextFramePromise = null),
                  (this._resolveNextFrame = null),
                  (this._animationFrameId = null),
                  (this._running = !1)),
                this
              );
            }
            attachTimeline(t) {
              return (this.timeline = t), this.timeline;
            }
            detachTimeline() {
              this.timeline = null;
            }
            waitForRender() {
              return (
                this.setNeedsRedraw("waitForRender"),
                this._nextFramePromise ||
                  (this._nextFramePromise = new Promise((t) => {
                    this._resolveNextFrame = t;
                  })),
                this._nextFramePromise
              );
            }
            async toDataURL() {
              return (
                this.setNeedsRedraw("toDataURL"),
                await this.waitForRender(),
                this.gl.canvas.toDataURL()
              );
            }
            isContextLost() {
              return this.gl.isContextLost();
            }
            onCreateContext(...t) {
              return this.props.onCreateContext(...t);
            }
            onInitialize(...t) {
              return this.props.onInitialize(...t);
            }
            onRender(...t) {
              return this.props.onRender(...t);
            }
            onFinalize(...t) {
              return this.props.onFinalize(...t);
            }
            getHTMLControlValue(t, e = 1) {
              const n = document.getElementById(t);
              return n ? Number(n.value) : e;
            }
            setViewParameters() {
              return (
                C.removed(
                  "AnimationLoop.setViewParameters",
                  "AnimationLoop.setProps"
                )(),
                this
              );
            }
            _startLoop() {
              const t = () => {
                this._running &&
                  (this.redraw(),
                  (this._animationFrameId = this._requestAnimationFrame(t)));
              };
              this._cancelAnimationFrame(this._animationFrameId),
                (this._animationFrameId = this._requestAnimationFrame(t));
            }
            _getPageLoadPromise() {
              return (
                this._pageLoadPromise ||
                  (this._pageLoadPromise = _u
                    ? new Promise((t, e) => {
                        _u && "complete" === document.readyState
                          ? t(document)
                          : window.addEventListener("load", () => {
                              t(document);
                            });
                      })
                    : Promise.resolve({})),
                this._pageLoadPromise
              );
            }
            _setDisplay(t) {
              this.display &&
                (this.display.delete(), (this.display.animationLoop = null)),
                t && (t.animationLoop = this),
                (this.display = t);
            }
            _cancelAnimationFrame(t) {
              return this.display && this.display.cancelAnimationFrame
                ? this.display.cancelAnimationFrame(t)
                : ((e = t),
                  "undefined" != typeof window && window.cancelAnimationFrame
                    ? window.cancelAnimationFrame(e)
                    : clearTimeout(e));
              var e;
            }
            _requestAnimationFrame(t) {
              if (this._running)
                return this.display && this.display.requestAnimationFrame
                  ? this.display.requestAnimationFrame(t)
                  : ((e = t),
                    "undefined" != typeof window && window.requestAnimationFrame
                      ? window.requestAnimationFrame(e)
                      : setTimeout(e, 1e3 / 60));
              var e;
            }
            _renderFrame(...t) {
              this.display
                ? this.display._renderFrame(...t)
                : this.onRender(...t);
            }
            _clearNeedsRedraw() {
              this.needsRedraw = null;
            }
            _setupFrame() {
              this._resizeCanvasDrawingBuffer(),
                this._resizeViewport(),
                this._resizeFramebuffer();
            }
            _initializeCallbackData() {
              this.animationProps = {
                gl: this.gl,
                stop: this.stop,
                canvas: this.gl.canvas,
                framebuffer: this.framebuffer,
                useDevicePixels: this.useDevicePixels,
                needsRedraw: null,
                startTime: Date.now(),
                engineTime: 0,
                tick: 0,
                tock: 0,
                time: 0,
                _timeline: this.timeline,
                _loop: this,
                _animationLoop: this,
                _mousePosition: null,
              };
            }
            _updateCallbackData() {
              const {
                width: t,
                height: e,
                aspect: n,
              } = this._getSizeAndAspect();
              (t === this.animationProps.width &&
                e === this.animationProps.height) ||
                this.setNeedsRedraw("drawing buffer resized"),
                n !== this.animationProps.aspect &&
                  this.setNeedsRedraw("drawing buffer aspect changed"),
                (this.animationProps.width = t),
                (this.animationProps.height = e),
                (this.animationProps.aspect = n),
                (this.animationProps.needsRedraw = this.needsRedraw),
                (this.animationProps.engineTime =
                  Date.now() - this.animationProps.startTime),
                this.timeline &&
                  this.timeline.update(this.animationProps.engineTime),
                (this.animationProps.tick = Math.floor(
                  (this.animationProps.time / 1e3) * 60
                )),
                this.animationProps.tock++,
                (this.animationProps.time = this.timeline
                  ? this.timeline.getTime()
                  : this.animationProps.engineTime),
                (this.animationProps._offScreen = this.offScreen);
            }
            _finalizeCallbackData() {
              this.onFinalize(this.animationProps);
            }
            _addCallbackData(t) {
              "object" == typeof t &&
                null !== t &&
                (this.animationProps = Object.assign(
                  {},
                  this.animationProps,
                  t
                ));
            }
            _createWebGLContext(t) {
              if (
                ((this.offScreen =
                  t.canvas &&
                  "undefined" != typeof OffscreenCanvas &&
                  t.canvas instanceof OffscreenCanvas),
                (t = Object.assign({}, t, this.props.glOptions)),
                (this.gl = this.props.gl
                  ? Pt(this.props.gl, t)
                  : this.onCreateContext(t)),
                !O(this.gl))
              )
                throw new Error(
                  "AnimationLoop.onCreateContext - illegal context returned"
                );
              dt(this.gl, Y), this._createInfoDiv();
            }
            _createInfoDiv() {
              if (this.gl.canvas && this.props.onAddHTML) {
                const t = document.createElement("div");
                document.body.appendChild(t), (t.style.position = "relative");
                const e = document.createElement("div");
                (e.style.position = "absolute"),
                  (e.style.left = "10px"),
                  (e.style.bottom = "10px"),
                  (e.style.width = "300px"),
                  (e.style.background = "white"),
                  t.appendChild(this.gl.canvas),
                  t.appendChild(e);
                const n = this.props.onAddHTML(e);
                n && (e.innerHTML = n);
              }
            }
            _getSizeAndAspect() {
              const t = this.gl.drawingBufferWidth,
                e = this.gl.drawingBufferHeight;
              let n = 1;
              const { canvas: i } = this.gl;
              return (
                i && i.clientHeight
                  ? (n = i.clientWidth / i.clientHeight)
                  : t > 0 && e > 0 && (n = t / e),
                { width: t, height: e, aspect: n }
              );
            }
            _resizeViewport() {
              this.autoResizeViewport &&
                this.gl.viewport(
                  0,
                  0,
                  this.gl.drawingBufferWidth,
                  this.gl.drawingBufferHeight
                );
            }
            _resizeCanvasDrawingBuffer() {
              this.autoResizeDrawingBuffer &&
                (function (t, e = {}) {
                  if (t.canvas)
                    return void (function (t, e, n) {
                      let i = "width" in n ? n.width : t.canvas.clientWidth,
                        r = "height" in n ? n.height : t.canvas.clientHeight;
                      (i && r) ||
                        (C.log(1, "Canvas clientWidth/clientHeight is 0")(),
                        (e = 1),
                        (i = t.canvas.width || 1),
                        (r = t.canvas.height || 1)),
                        (t.luma = t.luma || {}),
                        (t.luma.canvasSizeInfo = t.luma.canvasSizeInfo || {});
                      const s = t.luma.canvasSizeInfo;
                      if (
                        s.clientWidth !== i ||
                        s.clientHeight !== r ||
                        s.devicePixelRatio !== e
                      ) {
                        let n = e;
                        const s = Math.floor(i * n),
                          o = Math.floor(r * n);
                        (t.canvas.width = s),
                          (t.canvas.height = o),
                          (t.drawingBufferWidth === s &&
                            t.drawingBufferHeight === o) ||
                            (C.warn("Device pixel ratio clamped")(),
                            (n = Math.min(
                              t.drawingBufferWidth / i,
                              t.drawingBufferHeight / r
                            )),
                            (t.canvas.width = Math.floor(i * n)),
                            (t.canvas.height = Math.floor(r * n))),
                          Object.assign(t.luma.canvasSizeInfo, {
                            clientWidth: i,
                            clientHeight: r,
                            devicePixelRatio: e,
                          });
                      }
                    })(
                      t,
                      (function (t) {
                        const e =
                          "undefined" == typeof window
                            ? 1
                            : window.devicePixelRatio || 1;
                        return Number.isFinite(t)
                          ? t <= 0
                            ? 1
                            : t
                          : t
                          ? e
                          : 1;
                      })(e.useDevicePixels),
                      e
                    );
                  const n = t.getExtension("STACKGL_resize_drawingbuffer");
                  n &&
                    "width" in e &&
                    "height" in e &&
                    n.resize(e.width, e.height);
                })(this.gl, { useDevicePixels: this.useDevicePixels });
            }
            _createFramebuffer() {
              this.props.createFramebuffer &&
                (this.framebuffer = new ye(this.gl));
            }
            _resizeFramebuffer() {
              this.framebuffer &&
                this.framebuffer.resize({
                  width: this.gl.drawingBufferWidth,
                  height: this.gl.drawingBufferHeight,
                });
            }
            _beginTimers() {
              this.frameRate.timeEnd(),
                this.frameRate.timeStart(),
                this._gpuTimeQuery &&
                  this._gpuTimeQuery.isResultAvailable() &&
                  !this._gpuTimeQuery.isTimerDisjoint() &&
                  this.stats
                    .get("GPU Time")
                    .addTime(this._gpuTimeQuery.getTimerMilliseconds()),
                this._gpuTimeQuery &&
                  this._gpuTimeQuery.beginTimeElapsedQuery(),
                this.cpuTime.timeStart();
            }
            _endTimers() {
              this.cpuTime.timeEnd(),
                this._gpuTimeQuery && this._gpuTimeQuery.end();
            }
            _startEventHandling() {
              const { canvas: t } = this.gl;
              t &&
                (t.addEventListener("mousemove", this._onMousemove),
                t.addEventListener("mouseleave", this._onMouseleave));
            }
            _onMousemove(t) {
              this.animationProps._mousePosition = [t.offsetX, t.offsetY];
            }
            _onMouseleave(t) {
              this.animationProps._mousePosition = null;
            }
          }
          var wu = n(377),
            xu = n.n(wu);
          const Pu = { mousedown: 1, mousemove: 2, mouseup: 4 };
          !(function (t) {
            const e = t.prototype.handler;
            t.prototype.handler = function (t) {
              const n = this.store;
              t.button > 0 &&
                "pointerdown" === t.type &&
                ((function (e, n) {
                  for (let n = 0; n < e.length; n++)
                    if (e[n].pointerId === t.pointerId) return !0;
                  return !1;
                })(n) ||
                  n.push(t)),
                e.call(this, t);
            };
          })(xu().PointerEventInput),
            (xu().MouseInput.prototype.handler = function (t) {
              let e = Pu[t.type];
              1 & e && t.button >= 0 && (this.pressed = !0),
                2 & e && 0 === t.which && (e = 4),
                this.pressed &&
                  (4 & e && (this.pressed = !1),
                  this.callback(this.manager, e, {
                    pointers: [t],
                    changedPointers: [t],
                    pointerType: "mouse",
                    srcEvent: t,
                  }));
            });
          const Eu = xu().Manager,
            Au = xu(),
            Tu = Au
              ? [
                  [
                    Au.Pan,
                    { event: "tripan", pointers: 3, threshold: 0, enable: !1 },
                  ],
                  [Au.Rotate, { enable: !1 }],
                  [Au.Pinch, { enable: !1 }],
                  [Au.Swipe, { enable: !1 }],
                  [Au.Pan, { threshold: 0, enable: !1 }],
                  [Au.Press, { enable: !1 }],
                  [Au.Tap, { event: "doubletap", taps: 2, enable: !1 }],
                  [Au.Tap, { event: "anytap", enable: !1 }],
                  [Au.Tap, { enable: !1 }],
                ]
              : null,
            Su = {
              tripan: ["rotate", "pinch", "pan"],
              rotate: ["pinch"],
              pinch: ["pan"],
              pan: ["press", "doubletap", "anytap", "tap"],
              doubletap: ["anytap"],
              anytap: ["tap"],
            },
            Mu = { doubletap: ["tap"] },
            Cu = {
              pointerdown: "pointerdown",
              pointermove: "pointermove",
              pointerup: "pointerup",
              touchstart: "pointerdown",
              touchmove: "pointermove",
              touchend: "pointerup",
              mousedown: "pointerdown",
              mousemove: "pointermove",
              mouseup: "pointerup",
            },
            Lu = {
              KEY_EVENTS: ["keydown", "keyup"],
              MOUSE_EVENTS: [
                "mousedown",
                "mousemove",
                "mouseup",
                "mouseover",
                "mouseout",
                "mouseleave",
              ],
              WHEEL_EVENTS: ["wheel", "mousewheel"],
            },
            Ou = {
              tap: "tap",
              anytap: "anytap",
              doubletap: "doubletap",
              press: "press",
              pinch: "pinch",
              pinchin: "pinch",
              pinchout: "pinch",
              pinchstart: "pinch",
              pinchmove: "pinch",
              pinchend: "pinch",
              pinchcancel: "pinch",
              rotate: "rotate",
              rotatestart: "rotate",
              rotatemove: "rotate",
              rotateend: "rotate",
              rotatecancel: "rotate",
              tripan: "tripan",
              tripanstart: "tripan",
              tripanmove: "tripan",
              tripanup: "tripan",
              tripandown: "tripan",
              tripanleft: "tripan",
              tripanright: "tripan",
              tripanend: "tripan",
              tripancancel: "tripan",
              pan: "pan",
              panstart: "pan",
              panmove: "pan",
              panup: "pan",
              pandown: "pan",
              panleft: "pan",
              panright: "pan",
              panend: "pan",
              pancancel: "pan",
              swipe: "swipe",
              swipeleft: "swipe",
              swiperight: "swipe",
              swipeup: "swipe",
              swipedown: "swipe",
            },
            Iu = {
              click: "tap",
              anyclick: "anytap",
              dblclick: "doubletap",
              mousedown: "pointerdown",
              mousemove: "pointermove",
              mouseup: "pointerup",
              mouseover: "pointerover",
              mouseout: "pointerout",
              mouseleave: "pointerleave",
            },
            Ru =
              "undefined" != typeof navigator && navigator.userAgent
                ? navigator.userAgent.toLowerCase()
                : "",
            ku = "undefined" != typeof window ? window : n.g;
          void 0 !== n.g ? n.g : window,
            "undefined" != typeof document && document;
          let Fu = !1;
          try {
            const t = {
              get passive() {
                return (Fu = !0), !0;
              },
            };
            ku.addEventListener("test", t, t),
              ku.removeEventListener("test", t, t);
          } catch (t) {}
          const zu = -1 !== Ru.indexOf("firefox"),
            { WHEEL_EVENTS: ju } = Lu,
            Bu = "wheel",
            Du = 4.000244140625;
          class Nu {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.events = ju.concat(n.events || [])),
                (this.handleEvent = this.handleEvent.bind(this)),
                this.events.forEach((e) =>
                  t.addEventListener(
                    e,
                    this.handleEvent,
                    !!Fu && { passive: !1 }
                  )
                );
            }
            destroy() {
              this.events.forEach((t) =>
                this.element.removeEventListener(t, this.handleEvent)
              );
            }
            enableEventType(t, e) {
              t === Bu && (this.options.enable = e);
            }
            handleEvent(t) {
              if (!this.options.enable) return;
              let e = t.deltaY;
              ku.WheelEvent &&
                (zu &&
                  t.deltaMode === ku.WheelEvent.DOM_DELTA_PIXEL &&
                  (e /= ku.devicePixelRatio),
                t.deltaMode === ku.WheelEvent.DOM_DELTA_LINE && (e *= 40));
              const n = { x: t.clientX, y: t.clientY };
              0 !== e && e % Du == 0 && (e = Math.floor(e / Du)),
                t.shiftKey && e && (e *= 0.25),
                this._onWheel(t, -e, n);
            }
            _onWheel(t, e, n) {
              this.callback({
                type: Bu,
                center: n,
                delta: e,
                srcEvent: t,
                pointerType: "mouse",
                target: t.target,
              });
            }
          }
          const { MOUSE_EVENTS: Uu } = Lu,
            Vu = "pointermove",
            Gu = "pointerover",
            Wu = "pointerout",
            Hu = "pointerleave";
          class $u {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.pressed = !1),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.enableMoveEvent = this.options.enable),
                (this.enableLeaveEvent = this.options.enable),
                (this.enableOutEvent = this.options.enable),
                (this.enableOverEvent = this.options.enable),
                (this.events = Uu.concat(n.events || [])),
                (this.handleEvent = this.handleEvent.bind(this)),
                this.events.forEach((e) =>
                  t.addEventListener(e, this.handleEvent)
                );
            }
            destroy() {
              this.events.forEach((t) =>
                this.element.removeEventListener(t, this.handleEvent)
              );
            }
            enableEventType(t, e) {
              t === Vu && (this.enableMoveEvent = e),
                t === Gu && (this.enableOverEvent = e),
                t === Wu && (this.enableOutEvent = e),
                t === Hu && (this.enableLeaveEvent = e);
            }
            handleEvent(t) {
              this.handleOverEvent(t),
                this.handleOutEvent(t),
                this.handleLeaveEvent(t),
                this.handleMoveEvent(t);
            }
            handleOverEvent(t) {
              this.enableOverEvent &&
                "mouseover" === t.type &&
                this.callback({
                  type: Gu,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
            handleOutEvent(t) {
              this.enableOutEvent &&
                "mouseout" === t.type &&
                this.callback({
                  type: Wu,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
            handleLeaveEvent(t) {
              this.enableLeaveEvent &&
                "mouseleave" === t.type &&
                this.callback({
                  type: Hu,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
            handleMoveEvent(t) {
              if (this.enableMoveEvent)
                switch (t.type) {
                  case "mousedown":
                    t.button >= 0 && (this.pressed = !0);
                    break;
                  case "mousemove":
                    0 === t.which && (this.pressed = !1),
                      this.pressed ||
                        this.callback({
                          type: Vu,
                          srcEvent: t,
                          pointerType: "mouse",
                          target: t.target,
                        });
                    break;
                  case "mouseup":
                    this.pressed = !1;
                }
            }
          }
          const { KEY_EVENTS: Xu } = Lu,
            Yu = "keydown",
            qu = "keyup";
          class Zu {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.enableDownEvent = this.options.enable),
                (this.enableUpEvent = this.options.enable),
                (this.events = Xu.concat(n.events || [])),
                (this.handleEvent = this.handleEvent.bind(this)),
                (t.tabIndex = n.tabIndex || 0),
                (t.style.outline = "none"),
                this.events.forEach((e) =>
                  t.addEventListener(e, this.handleEvent)
                );
            }
            destroy() {
              this.events.forEach((t) =>
                this.element.removeEventListener(t, this.handleEvent)
              );
            }
            enableEventType(t, e) {
              t === Yu && (this.enableDownEvent = e),
                t === qu && (this.enableUpEvent = e);
            }
            handleEvent(t) {
              const e = t.target || t.srcElement;
              ("INPUT" === e.tagName && "text" === e.type) ||
                "TEXTAREA" === e.tagName ||
                (this.enableDownEvent &&
                  "keydown" === t.type &&
                  this.callback({
                    type: Yu,
                    srcEvent: t,
                    key: t.key,
                    target: t.target,
                  }),
                this.enableUpEvent &&
                  "keyup" === t.type &&
                  this.callback({
                    type: qu,
                    srcEvent: t,
                    key: t.key,
                    target: t.target,
                  }));
            }
          }
          const Ku = "contextmenu";
          class Ju {
            constructor(t, e, n = {}) {
              (this.element = t),
                (this.callback = e),
                (this.options = Object.assign({ enable: !0 }, n)),
                (this.handleEvent = this.handleEvent.bind(this)),
                t.addEventListener("contextmenu", this.handleEvent);
            }
            destroy() {
              this.element.removeEventListener("contextmenu", this.handleEvent);
            }
            enableEventType(t, e) {
              t === Ku && (this.options.enable = e);
            }
            handleEvent(t) {
              this.options.enable &&
                this.callback({
                  type: Ku,
                  center: { x: t.clientX, y: t.clientY },
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }
          }
          const Qu = {
              pointerdown: 1,
              pointermove: 2,
              pointerup: 4,
              mousedown: 1,
              mousemove: 2,
              mouseup: 4,
            },
            td = { srcElement: "root", priority: 0 };
          class ed {
            constructor(t) {
              (this.eventManager = t),
                (this.handlers = []),
                (this.handlersByElement = new Map()),
                (this.handleEvent = this.handleEvent.bind(this)),
                (this._active = !1);
            }
            isEmpty() {
              return !this._active;
            }
            add(t, e, n, i = !1, r = !1) {
              const { handlers: s, handlersByElement: o } = this;
              n &&
                ("object" != typeof n || n.addEventListener) &&
                (n = { srcElement: n }),
                (n = n ? Object.assign({}, td, n) : td);
              let a = o.get(n.srcElement);
              a || ((a = []), o.set(n.srcElement, a));
              const c = {
                type: t,
                handler: e,
                srcElement: n.srcElement,
                priority: n.priority,
              };
              i && (c.once = !0),
                r && (c.passive = !0),
                s.push(c),
                (this._active = this._active || !c.passive);
              let l = a.length - 1;
              for (; l >= 0 && !(a[l].priority >= c.priority); ) l--;
              a.splice(l + 1, 0, c);
            }
            remove(t, e) {
              const { handlers: n, handlersByElement: i } = this;
              for (let r = n.length - 1; r >= 0; r--) {
                const s = n[r];
                if (s.type === t && s.handler === e) {
                  n.splice(r, 1);
                  const t = i.get(s.srcElement);
                  t.splice(t.indexOf(s), 1),
                    0 === t.length && i.delete(s.srcElement);
                }
              }
              this._active = n.some((t) => !t.passive);
            }
            handleEvent(t) {
              if (this.isEmpty()) return;
              const e = this._normalizeEvent(t);
              let n = t.srcEvent.target;
              for (; n && n !== e.rootElement; ) {
                if ((this._emit(e, n), e.handled)) return;
                n = n.parentNode;
              }
              this._emit(e, "root");
            }
            _emit(t, e) {
              const n = this.handlersByElement.get(e);
              if (n) {
                let e = !1;
                const i = () => {
                    t.handled = !0;
                  },
                  r = () => {
                    (t.handled = !0), (e = !0);
                  },
                  s = [];
                for (let o = 0; o < n.length; o++) {
                  const { type: a, handler: c, once: l } = n[o];
                  if (
                    (c(
                      Object.assign({}, t, {
                        type: a,
                        stopPropagation: i,
                        stopImmediatePropagation: r,
                      })
                    ),
                    l && s.push(n[o]),
                    e)
                  )
                    break;
                }
                for (let t = 0; t < s.length; t++) {
                  const { type: e, handler: n } = s[t];
                  this.remove(e, n);
                }
              }
            }
            _normalizeEvent(t) {
              const e = this.eventManager.element;
              return Object.assign(
                {},
                t,
                (function (t) {
                  const e = Qu[t.srcEvent.type];
                  if (!e) return null;
                  const { buttons: n, button: i, which: r } = t.srcEvent;
                  let s = !1,
                    o = !1,
                    a = !1;
                  return (
                    4 === e || (2 === e && !Number.isFinite(n))
                      ? ((s = 1 === r), (o = 2 === r), (a = 3 === r))
                      : 2 === e
                      ? ((s = Boolean(1 & n)),
                        (o = Boolean(4 & n)),
                        (a = Boolean(2 & n)))
                      : 1 === e &&
                        ((s = 0 === i), (o = 1 === i), (a = 2 === i)),
                    { leftButton: s, middleButton: o, rightButton: a }
                  );
                })(t),
                (function (t, e) {
                  const { srcEvent: n } = t;
                  if (!t.center && !Number.isFinite(n.clientX)) return null;
                  const i = t.center || { x: n.clientX, y: n.clientY },
                    r = e.getBoundingClientRect(),
                    s = r.width / e.offsetWidth || 1,
                    o = r.height / e.offsetHeight || 1;
                  return {
                    center: i,
                    offsetCenter: {
                      x: (i.x - r.left - e.clientLeft) / s,
                      y: (i.y - r.top - e.clientTop) / o,
                    },
                  };
                })(t, e),
                { handled: !1, rootElement: e }
              );
            }
          }
          const nd = {
            events: null,
            recognizers: null,
            recognizerOptions: {},
            Manager: Eu,
            touchAction: "none",
            tabIndex: 0,
          };
          class id {
            constructor(t = null, e = {}) {
              (this.options = Object.assign({}, nd, e)),
                (this.events = new Map()),
                (this._onBasicInput = this._onBasicInput.bind(this)),
                (this._onOtherEvent = this._onOtherEvent.bind(this)),
                this.setElement(t);
              const { events: n } = e;
              n && this.on(n);
            }
            setElement(t) {
              if ((this.element && this.destroy(), (this.element = t), !t))
                return;
              const { options: e } = this,
                n = e.Manager;
              (this.manager = new n(t, {
                touchAction: e.touchAction,
                recognizers: e.recognizers || Tu,
              }).on("hammer.input", this._onBasicInput)),
                e.recognizers ||
                  Object.keys(Su).forEach((t) => {
                    const e = this.manager.get(t);
                    e &&
                      Su[t].forEach((t) => {
                        e.recognizeWith(t);
                      });
                  });
              for (const t in e.recognizerOptions) {
                const n = this.manager.get(t);
                if (n) {
                  const i = e.recognizerOptions[t];
                  delete i.enable, n.set(i);
                }
              }
              (this.wheelInput = new Nu(t, this._onOtherEvent, { enable: !1 })),
                (this.moveInput = new $u(t, this._onOtherEvent, {
                  enable: !1,
                })),
                (this.keyInput = new Zu(t, this._onOtherEvent, {
                  enable: !1,
                  tabIndex: e.tabIndex,
                })),
                (this.contextmenuInput = new Ju(t, this._onOtherEvent, {
                  enable: !1,
                }));
              for (const [t, e] of this.events)
                e.isEmpty() ||
                  (this._toggleRecognizer(e.recognizerName, !0),
                  this.manager.on(t, e.handleEvent));
            }
            destroy() {
              this.element &&
                (this.wheelInput.destroy(),
                this.moveInput.destroy(),
                this.keyInput.destroy(),
                this.contextmenuInput.destroy(),
                this.manager.destroy(),
                (this.wheelInput = null),
                (this.moveInput = null),
                (this.keyInput = null),
                (this.contextmenuInput = null),
                (this.manager = null),
                (this.element = null));
            }
            on(t, e, n) {
              this._addEventHandler(t, e, n, !1);
            }
            once(t, e, n) {
              this._addEventHandler(t, e, n, !0);
            }
            watch(t, e, n) {
              this._addEventHandler(t, e, n, !1, !0);
            }
            off(t, e) {
              this._removeEventHandler(t, e);
            }
            _toggleRecognizer(t, e) {
              const { manager: n } = this;
              if (!n) return;
              const i = n.get(t);
              if (i && i.options.enable !== e) {
                i.set({ enable: e });
                const r = Mu[t];
                r &&
                  !this.options.recognizers &&
                  r.forEach((r) => {
                    const s = n.get(r);
                    e
                      ? (s.requireFailure(t), i.dropRequireFailure(r))
                      : s.dropRequireFailure(t);
                  });
              }
              this.wheelInput.enableEventType(t, e),
                this.moveInput.enableEventType(t, e),
                this.keyInput.enableEventType(t, e),
                this.contextmenuInput.enableEventType(t, e);
            }
            _addEventHandler(t, e, n, i, r) {
              if ("string" != typeof t) {
                n = e;
                for (const e in t) this._addEventHandler(e, t[e], n, i, r);
                return;
              }
              const { manager: s, events: o } = this,
                a = Iu[t] || t;
              let c = o.get(a);
              c ||
                ((c = new ed(this)),
                o.set(a, c),
                (c.recognizerName = Ou[a] || a),
                s && s.on(a, c.handleEvent)),
                c.add(t, e, n, i, r),
                c.isEmpty() || this._toggleRecognizer(c.recognizerName, !0);
            }
            _removeEventHandler(t, e) {
              if ("string" != typeof t) {
                for (const e in t) this._removeEventHandler(e, t[e]);
                return;
              }
              const { events: n } = this,
                i = Iu[t] || t,
                r = n.get(i);
              if (r && (r.remove(t, e), r.isEmpty())) {
                const { recognizerName: t } = r;
                let e = !1;
                for (const i of n.values())
                  if (i.recognizerName === t && !i.isEmpty()) {
                    e = !0;
                    break;
                  }
                e || this._toggleRecognizer(t, !1);
              }
            }
            _onBasicInput(t) {
              const { srcEvent: e } = t,
                n = Cu[e.type];
              n && this.manager.emit(n, t);
            }
            _onOtherEvent(t) {
              this.manager.emit(t.type, t);
            }
          }
          function rd() {}
          const sd = {
            id: "",
            width: "100%",
            height: "100%",
            pickingRadius: 0,
            layerFilter: null,
            glOptions: {},
            gl: null,
            layers: [],
            effects: [],
            views: null,
            controller: null,
            useDevicePixels: !0,
            touchAction: "none",
            eventRecognizerOptions: {},
            _framebuffer: null,
            _animate: !1,
            _pickable: !0,
            _typedArrayManagerProps: {},
            onWebGLInitialized: rd,
            onResize: rd,
            onViewStateChange: rd,
            onInteractionStateChange: rd,
            onBeforeRender: rd,
            onAfterRender: rd,
            onLoad: rd,
            onError: (t, e) => E.error(t)(),
            _onMetrics: null,
            getCursor: ({ isDragging: t }) => (t ? "grabbing" : "grab"),
            debug: !1,
            drawPickingColors: !1,
          };
          class od {
            constructor(t) {
              (t = { ...sd, ...t }),
                (this.props = {}),
                (this.width = 0),
                (this.height = 0),
                (this.viewManager = null),
                (this.layerManager = null),
                (this.effectManager = null),
                (this.deckRenderer = null),
                (this.deckPicker = null),
                (this._needsRedraw = !0),
                (this._pickRequest = {}),
                (this._lastPointerDownInfo = null),
                (this.viewState = null),
                (this.interactiveState = { isHovering: !1, isDragging: !1 }),
                (this._onEvent = this._onEvent.bind(this)),
                (this._onPointerDown = this._onPointerDown.bind(this)),
                (this._onPointerMove = this._onPointerMove.bind(this)),
                t.viewState &&
                  t.initialViewState &&
                  E.warn(
                    "View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update."
                  )(),
                "IE" === (0, F.qs)() &&
                  E.warn("IE 11 support will be deprecated in v8.0")(),
                t.gl ||
                  ("undefined" != typeof document &&
                    (this.canvas = this._createCanvas(t))),
                (this.animationLoop = this._createAnimationLoop(t)),
                (this.stats = new Tt({ id: "deck.gl" })),
                (this.metrics = {
                  fps: 0,
                  setPropsTime: 0,
                  updateAttributesTime: 0,
                  framesRedrawn: 0,
                  pickTime: 0,
                  pickCount: 0,
                  gpuTime: 0,
                  gpuTimePerFrame: 0,
                  cpuTime: 0,
                  cpuTimePerFrame: 0,
                  bufferMemory: 0,
                  textureMemory: 0,
                  renderbufferMemory: 0,
                  gpuMemory: 0,
                }),
                (this._metricsCounter = 0),
                this.setProps(t),
                t._typedArrayManagerProps &&
                  Ee.setProps(t._typedArrayManagerProps),
                this.animationLoop.start();
            }
            finalize() {
              this.animationLoop.stop(),
                (this.animationLoop = null),
                (this._lastPointerDownInfo = null),
                this.layerManager &&
                  (this.layerManager.finalize(),
                  (this.layerManager = null),
                  this.viewManager.finalize(),
                  (this.viewManager = null),
                  this.effectManager.finalize(),
                  (this.effectManager = null),
                  this.deckRenderer.finalize(),
                  (this.deckRenderer = null),
                  this.deckPicker.finalize(),
                  (this.deckPicker = null),
                  this.eventManager.destroy(),
                  (this.eventManager = null),
                  this.tooltip.remove(),
                  (this.tooltip = null)),
                this.props.canvas ||
                  this.props.gl ||
                  !this.canvas ||
                  (this.canvas.parentElement.removeChild(this.canvas),
                  (this.canvas = null));
            }
            setProps(t) {
              this.stats.get("setProps Time").timeStart(),
                "onLayerHover" in t && E.removed("onLayerHover", "onHover")(),
                "onLayerClick" in t && E.removed("onLayerClick", "onClick")(),
                t.initialViewState &&
                  !ah(this.props.initialViewState, t.initialViewState) &&
                  (this.viewState = t.initialViewState),
                Object.assign(this.props, t),
                this._setCanvasSize(this.props);
              const e = Object.create(this.props);
              Object.assign(e, {
                views: this._getViews(),
                width: this.width,
                height: this.height,
                viewState: this._getViewState(),
              }),
                this.animationLoop.setProps(e),
                this.layerManager &&
                  (this.viewManager.setProps(e),
                  this.layerManager.activateViewport(this.getViewports()[0]),
                  this.layerManager.setProps(e),
                  this.effectManager.setProps(e),
                  this.deckRenderer.setProps(e),
                  this.deckPicker.setProps(e)),
                this.stats.get("setProps Time").timeEnd();
            }
            needsRedraw(t = { clearRedrawFlags: !1 }) {
              if (this.props._animate) return "Deck._animate";
              let e = this._needsRedraw;
              t.clearRedrawFlags && (this._needsRedraw = !1);
              const n = this.viewManager.needsRedraw(t),
                i = this.layerManager.needsRedraw(t),
                r = this.effectManager.needsRedraw(t),
                s = this.deckRenderer.needsRedraw(t);
              return (e = e || n || i || r || s), e;
            }
            redraw(t) {
              if (!this.layerManager) return;
              const e = t || this.needsRedraw({ clearRedrawFlags: !0 });
              e &&
                (this.stats.get("Redraw Count").incrementCount(),
                this.props._customRender
                  ? this.props._customRender(e)
                  : this._drawLayers(e));
            }
            getViews() {
              return this.viewManager.views;
            }
            getViewports(t) {
              return this.viewManager.getViewports(t);
            }
            pickObject(t) {
              const e = this._pick("pickObject", "pickObject Time", t).result;
              return e.length ? e[0] : null;
            }
            pickMultipleObjects(t) {
              return (
                (t.depth = t.depth || 10),
                this._pick("pickObject", "pickMultipleObjects Time", t).result
              );
            }
            pickObjects(t) {
              return this._pick("pickObjects", "pickObjects Time", t);
            }
            _addResources(t, e = !1) {
              for (const n in t)
                this.layerManager.resourceManager.add({
                  resourceId: n,
                  data: t[n],
                  forceUpdate: e,
                });
            }
            _removeResources(t) {
              for (const e of t) this.layerManager.resourceManager.remove(e);
            }
            _pick(t, e, n) {
              const { stats: i } = this;
              i.get("Pick Count").incrementCount(), i.get(e).timeStart();
              const r = this.deckPicker[t]({
                layers: this.layerManager.getLayers(n),
                views: this.viewManager.getViews(),
                viewports: this.getViewports(n),
                onViewportActive: this.layerManager.activateViewport,
                ...n,
              });
              return i.get(e).timeEnd(), r;
            }
            _createCanvas(t) {
              let e = t.canvas;
              return (
                "string" == typeof e &&
                  ((e = document.getElementById(e)), Je(e)),
                e ||
                  ((e = document.createElement("canvas")),
                  (e.id = t.id || "deckgl-overlay"),
                  (t.parent || document.body).appendChild(e)),
                Object.assign(e.style, t.style),
                e
              );
            }
            _setCanvasSize(t) {
              if (!this.canvas) return;
              let { width: e, height: n } = t;
              (e || 0 === e) &&
                ((e = Number.isFinite(e) ? "".concat(e, "px") : e),
                (this.canvas.style.width = e)),
                (n || 0 === n) &&
                  ((n = Number.isFinite(n) ? "".concat(n, "px") : n),
                  (this.canvas.style.position = "absolute"),
                  (this.canvas.style.height = n));
            }
            _updateCanvasSize() {
              if (this._checkForCanvasSizeChange()) {
                const { width: t, height: e } = this;
                this.viewManager.setProps({ width: t, height: e }),
                  this.props.onResize({
                    width: this.width,
                    height: this.height,
                  });
              }
            }
            _checkForCanvasSizeChange() {
              const { canvas: t } = this;
              if (!t) return !1;
              const e = t.clientWidth || t.width,
                n = t.clientHeight || t.height;
              return (
                (e !== this.width || n !== this.height) &&
                ((this.width = e), (this.height = n), !0)
              );
            }
            _createAnimationLoop(t) {
              const {
                width: e,
                height: n,
                gl: i,
                glOptions: r,
                debug: s,
                onError: o,
                onBeforeRender: a,
                onAfterRender: c,
                useDevicePixels: l,
                autoResizeDrawingBuffer: h,
              } = t;
              return new bu({
                width: e,
                height: n,
                useDevicePixels: l,
                autoResizeDrawingBuffer: h,
                autoResizeViewport: !1,
                gl: i,
                onCreateContext: (t) =>
                  xt({
                    ...r,
                    ...t,
                    canvas: this.canvas,
                    debug: s,
                    onContextLost: () => this._onContextLost(),
                  }),
                onInitialize: (t) => this._setGLContext(t.gl),
                onRender: this._onRenderFrame.bind(this),
                onBeforeRender: a,
                onAfterRender: c,
                onError: o,
              });
            }
            _getViewState() {
              return this.props.viewState || this.viewState;
            }
            _getViews() {
              let t = this.props.views || [new Ch({ id: "default-view" })];
              return (
                (t = Array.isArray(t) ? t : [t]),
                t.length &&
                  this.props.controller &&
                  (t[0].props.controller = this.props.controller),
                t
              );
            }
            _onContextLost() {
              const { onError: t } = this.props;
              this.animationLoop && t && t(new Error("WebGL context is lost"));
            }
            _onPointerMove(t) {
              const { _pickRequest: e } = this;
              if ("pointerleave" === t.type)
                (e.x = -1), (e.y = -1), (e.radius = 0);
              else {
                if (t.leftButton || t.rightButton) return;
                {
                  const n = t.offsetCenter;
                  if (!n) return;
                  (e.x = n.x),
                    (e.y = n.y),
                    (e.radius = this.props.pickingRadius);
                }
              }
              this.layerManager &&
                (this.layerManager.context.mousePosition = { x: e.x, y: e.y }),
                (e.event = t),
                (e.mode = "hover");
            }
            _pickAndCallback() {
              const { _pickRequest: t } = this;
              if (t.event) {
                const { result: e, emptyInfo: n } = this._pick(
                  "pickObject",
                  "pickObject Time",
                  t
                );
                this.interactiveState.isHovering = e.length > 0;
                let i = n,
                  r = !1;
                for (const n of e) (i = n), (r = n.layer.onHover(n, t.event));
                if (
                  (!r && this.props.onHover && this.props.onHover(i, t.event),
                  this.props.getTooltip)
                ) {
                  const t = this.props.getTooltip(i);
                  this.tooltip.setTooltip(t, i.x, i.y);
                }
                t.event = null;
              }
            }
            _updateCursor() {
              const t = this.props.parent || this.canvas;
              t &&
                (t.style.cursor = this.props.getCursor(this.interactiveState));
            }
            _setGLContext(t) {
              if (this.layerManager) return;
              this.canvas ||
                ((this.canvas = t.canvas),
                Pt(t, { enable: !0, copyState: !0 })),
                (this.tooltip = new du(this.canvas)),
                dt(t, {
                  blend: !0,
                  blendFunc: [770, 771, 1, 771],
                  polygonOffsetFill: !0,
                  depthTest: !0,
                  depthFunc: 515,
                }),
                this.props.onWebGLInitialized(t);
              const e = new Ql();
              e.play(),
                this.animationLoop.attachTimeline(e),
                (this.eventManager = new id(this.props.parent || t.canvas, {
                  touchAction: this.props.touchAction,
                  recognizerOptions: this.props.eventRecognizerOptions,
                  events: {
                    pointerdown: this._onPointerDown,
                    pointermove: this._onPointerMove,
                    pointerleave: this._onPointerMove,
                  },
                }));
              for (const t in M) this.eventManager.on(t, this._onEvent);
              this.viewManager = new ch({
                timeline: e,
                eventManager: this.eventManager,
                onViewStateChange: this._onViewStateChange.bind(this),
                onInteractionStateChange:
                  this._onInteractionStateChange.bind(this),
                views: this._getViews(),
                viewState: this._getViewState(),
                width: this.width,
                height: this.height,
              });
              const n = this.viewManager.getViewports()[0];
              (this.layerManager = new oh(t, {
                deck: this,
                stats: this.stats,
                viewport: n,
                timeline: e,
              })),
                (this.effectManager = new Qh()),
                (this.deckRenderer = new ru(t)),
                (this.deckPicker = new hu(t)),
                this.setProps(this.props),
                this._updateCanvasSize(),
                this.props.onLoad();
            }
            _drawLayers(t, e) {
              const { gl: n } = this.layerManager.context;
              dt(n, this.props.parameters),
                this.props.onBeforeRender({ gl: n }),
                this.deckRenderer.renderLayers({
                  target: this.props._framebuffer,
                  layers: this.layerManager.getLayers(),
                  viewports: this.viewManager.getViewports(),
                  onViewportActive: this.layerManager.activateViewport,
                  views: this.viewManager.getViews(),
                  pass: "screen",
                  redrawReason: t,
                  effects: this.effectManager.getEffects(),
                  ...e,
                }),
                this.props.onAfterRender({ gl: n });
            }
            _onRenderFrame(t) {
              this._getFrameStats(),
                this._metricsCounter++ % 60 == 0 &&
                  (this._getMetrics(),
                  this.stats.reset(),
                  E.table(4, this.metrics)(),
                  this.props._onMetrics && this.props._onMetrics(this.metrics)),
                this._updateCanvasSize(),
                this._updateCursor(),
                this.tooltip.isVisible &&
                  this.viewManager.needsRedraw() &&
                  this.tooltip.setTooltip(null),
                this.layerManager.updateLayers(),
                this._pickAndCallback(),
                this.redraw(!1),
                this.viewManager && this.viewManager.updateViewStates();
            }
            _onViewStateChange(t) {
              const e = this.props.onViewStateChange(t) || t.viewState;
              this.viewState &&
                ((this.viewState = { ...this.viewState, [t.viewId]: e }),
                this.props.viewState ||
                  (this.viewManager &&
                    this.viewManager.setProps({ viewState: this.viewState })));
            }
            _onInteractionStateChange(t) {
              (this.interactiveState.isDragging = t.isDragging),
                this.props.onInteractionStateChange(t);
            }
            _onEvent(t) {
              const e = M[t.type],
                n = t.offsetCenter;
              if (!e || !n) return;
              const i = this.layerManager.getLayers(),
                r = this.deckPicker.getLastPickedObject(
                  {
                    x: n.x,
                    y: n.y,
                    layers: i,
                    viewports: this.getViewports(n),
                  },
                  this._lastPointerDownInfo
                ),
                { layer: s } = r,
                o = s && (s[e.handler] || s.props[e.handler]),
                a = this.props[e.handler];
              let c = !1;
              o && (c = o.call(s, r, t)), !c && a && a(r, t);
            }
            _onPointerDown(t) {
              const e = t.offsetCenter;
              this._lastPointerDownInfo = this.pickObject({
                x: e.x,
                y: e.y,
                radius: this.props.pickingRadius,
              });
            }
            _getFrameStats() {
              const { stats: t } = this;
              t.get("frameRate").timeEnd(), t.get("frameRate").timeStart();
              const e = this.animationLoop.stats;
              t.get("GPU Time").addTime(e.get("GPU Time").lastTiming),
                t.get("CPU Time").addTime(e.get("CPU Time").lastTiming);
            }
            _getMetrics() {
              const { metrics: t, stats: e } = this;
              (t.fps = e.get("frameRate").getHz()),
                (t.setPropsTime = e.get("setProps Time").time),
                (t.updateAttributesTime = e.get("Update Attributes").time),
                (t.framesRedrawn = e.get("Redraw Count").count),
                (t.pickTime =
                  e.get("pickObject Time").time +
                  e.get("pickMultipleObjects Time").time +
                  e.get("pickObjects Time").time),
                (t.pickCount = e.get("Pick Count").count),
                (t.gpuTime = e.get("GPU Time").time),
                (t.cpuTime = e.get("CPU Time").time),
                (t.gpuTimePerFrame = e.get("GPU Time").getAverageTime()),
                (t.cpuTimePerFrame = e.get("CPU Time").getAverageTime());
              const n = Mt.get("Memory Usage");
              (t.bufferMemory = n.get("Buffer Memory").count),
                (t.textureMemory = n.get("Texture Memory").count),
                (t.renderbufferMemory = n.get("Renderbuffer Memory").count),
                (t.gpuMemory = n.get("GPU Memory").count);
            }
          }
          (od.getPropTypes = function (t) {
            return {
              id: t.string,
              width: t.oneOfType([t.number, t.string]),
              height: t.oneOfType([t.number, t.string]),
              layers: t.oneOfType([t.object, t.array]),
              layerFilter: t.func,
              views: t.oneOfType([t.object, t.array]),
              viewState: t.object,
              effects: t.arrayOf(t.instanceOf(Dh)),
              controller: t.oneOfType([t.func, t.bool, t.object]),
              gl: t.object,
              glOptions: t.object,
              parameters: t.object,
              pickingRadius: t.number,
              useDevicePixels: t.oneOfType([t.bool, t.number]),
              touchAction: t.string,
              eventRecognizerOptions: t.object,
              onWebGLInitialized: t.func,
              onResize: t.func,
              onViewStateChange: t.func,
              onInteractionStateChange: t.func,
              onBeforeRender: t.func,
              onAfterRender: t.func,
              onLoad: t.func,
              onError: t.func,
              debug: t.bool,
              drawPickingColors: t.bool,
              _framebuffer: t.object,
              _animate: t.bool,
              _pickable: t.bool,
              _typedArrayManagerProps: t.object,
            };
          }),
            (od.defaultProps = sd),
            (od.VERSION = mu.VERSION);
          const ad = 85.05113;
          function cd(t, e, n, i) {
            if (n) {
              if (n.props.userData._googleMap === t) return n;
              hd(n);
            }
            const r = {
              click: null,
              dblclick: null,
              mousemove: null,
              mouseout: null,
            };
            n = new od({
              ...i,
              style: null,
              parent: ld(e, i.style),
              initialViewState: { longitude: 0, latitude: 0, zoom: 1 },
              controller: !1,
              userData: { _googleMap: t, _eventListeners: r },
            });
            for (const e in r) r[e] = t.addListener(e, (t) => pd(n, e, t));
            return n;
          }
          function ld(t, e) {
            const n = document.createElement("div");
            return (
              (n.style.position = "absolute"),
              Object.assign(n.style, e),
              t.getPanes
                ? t.getPanes().overlayLayer.appendChild(n)
                : t.getMap().getDiv().appendChild(n),
              n
            );
          }
          function hd(t) {
            const { _eventListeners: e } = t.props.userData;
            for (const t in e) e[t].remove();
            t.finalize();
          }
          function ud(t, e) {
            const { width: n, height: i } = dd(t),
              {
                lat: r,
                lng: s,
                heading: o,
                tilt: a,
                zoom: c,
              } = e.getCameraParams(),
              l = n / i,
              h = new is().perspective({
                fovy: (25 * Math.PI) / 180,
                aspect: l,
                near: 0.75,
                far: 3e14,
              });
            return {
              width: !1,
              height: !1,
              viewState: {
                altitude: 0.5 * h[5],
                bearing: o,
                latitude: r,
                longitude: s,
                pitch: a,
                projectionMatrix: h,
                repeat: !0,
                zoom: c - 1,
              },
            };
          }
          function dd(t) {
            const e = t.getDiv().firstChild;
            return { width: e.offsetWidth, height: e.offsetHeight };
          }
          function fd(t, e) {
            if (t.pixel) return t.pixel;
            const n = e
              .getViewports()[0]
              .project([t.latLng.lng(), t.latLng.lat()]);
            return { x: n[0], y: n[1] };
          }
          function pd(t, e, n) {
            const i = { type: e, offsetCenter: fd(n, t), srcEvent: n };
            switch (e) {
              case "click":
                (t._lastPointerDownInfo = t.pickObject({
                  ...i.offsetCenter,
                  radius: t.props.pickingRadius,
                })),
                  (i.tapCount = 1),
                  t._onEvent(i);
                break;
              case "dblclick":
                (i.type = "click"), (i.tapCount = 2), t._onEvent(i);
                break;
              case "mousemove":
                (i.type = "pointermove"), t._onPointerMove(i);
                break;
              case "mouseout":
                (i.type = "pointerleave"), t._onPointerMove(i);
                break;
              default:
                return;
            }
          }
          const gd = () => !1,
            md = {
              depthMask: !0,
              depthTest: !0,
              blend: !0,
              blendFunc: [770, 771, 1, 771],
              blendEquation: 32774,
            };
          class yd {
            constructor(t) {
              (this.props = {}), (this._map = null), this.setProps(t);
            }
            setMap(t) {
              if (
                t !== this._map &&
                (this._map && (this._overlay.setMap(null), (this._map = null)),
                t)
              ) {
                this._map = t;
                const { UNINITIALIZED: e } = google.maps.RenderingType;
                t.getRenderingType() !== e
                  ? this._createOverlay(t)
                  : t.addListener("renderingtype_changed", () => {
                      this._createOverlay(t);
                    });
              }
            }
            setProps(t) {
              Object.assign(this.props, t),
                this._deck &&
                  (t.style &&
                    (Object.assign(
                      this._deck.canvas.parentElement.style,
                      t.style
                    ),
                    (t.style = null)),
                  this._deck.setProps(t));
            }
            pickObject(t) {
              return this._deck && this._deck.pickObject(t);
            }
            pickMultipleObjects(t) {
              return this._deck && this._deck.pickMultipleObjects(t);
            }
            pickObjects(t) {
              return this._deck && this._deck.pickObjects(t);
            }
            finalize() {
              this.setMap(null),
                this._deck && (hd(this._deck), (this._deck = null));
            }
            _createOverlay(t) {
              const { VECTOR: e, UNINITIALIZED: n } = google.maps.RenderingType,
                i = t.getRenderingType();
              if (i === n) return;
              const r = i === e && google.maps.WebglOverlayView,
                s = new (
                  r ? google.maps.WebglOverlayView : google.maps.OverlayView
                )();
              r
                ? ((s.onAdd = () => {}),
                  (s.onContextLost = this._onContextLost.bind(this)),
                  (s.onContextRestored = this._onContextRestored.bind(this)),
                  (s.onDraw = this._onDrawVector.bind(this)))
                : ((s.onAdd = this._onAdd.bind(this)),
                  (s.draw = this._onDrawRaster.bind(this))),
                (s.onRemove = this._onRemove.bind(this)),
                (this._overlay = s),
                this._overlay.setMap(t);
            }
            _onAdd() {
              this._deck = cd(this._map, this._overlay, this._deck, this.props);
            }
            _onContextRestored(t) {
              const e = cd(this._map, this._overlay, this._deck, {
                gl: t,
                _customRender: () => {
                  this._overlay.requestRedraw();
                },
                ...this.props,
              });
              (this._deck = e),
                (e.animationLoop._renderFrame = () => {
                  const n = t.getParameter(34964);
                  pt(t, {}, () => {
                    e.animationLoop.onRender();
                  }),
                    t.bindBuffer(34962, n);
                });
            }
            _onContextLost() {
              this._deck && (hd(this._deck), (this._deck = null));
            }
            _onRemove() {
              this._deck.setProps({ layerFilter: gd });
            }
            _onDrawRaster() {
              const t = this._deck,
                {
                  width: e,
                  height: n,
                  left: i,
                  top: r,
                  zoom: s,
                  pitch: o,
                  latitude: a,
                  longitude: c,
                } = (function (t, e) {
                  const { width: n, height: i } = dd(t),
                    r = e.getProjection(),
                    s = t.getBounds(),
                    o = s.getNorthEast(),
                    a = s.getSouthWest(),
                    c = r.fromLatLngToDivPixel(o),
                    l = r.fromLatLngToDivPixel(a),
                    h = new google.maps.Point(0, 0),
                    u = r.fromContainerPixelToLatLng(h),
                    d = r.fromLatLngToDivPixel(u);
                  let f = d.x,
                    p = d.y;
                  const g = r.getWorldWidth(),
                    m = Math.ceil(n / g);
                  f -= Math.floor(m / 2) * g;
                  const y = i ? (l.y - c.y) / i : 1,
                    _ = Math.log2(y || 1) + t.getZoom() - 1;
                  let v = new google.maps.Point(n / 2, i / 2);
                  const b = r.fromContainerPixelToLatLng(v);
                  let w = b.lat();
                  const x = b.lng();
                  if (Math.abs(w) > ad) {
                    w = w > 0 ? ad : -85.05113;
                    const t = new google.maps.LatLng(w, x);
                    (v = r.fromLatLngToContainerPixel(t)), (p += v.y - i / 2);
                  }
                  return {
                    width: n,
                    height: i,
                    left: f,
                    top: p,
                    zoom: _,
                    pitch: t.getTilt(),
                    latitude: w,
                    longitude: x,
                  };
                })(this._map, this._overlay),
                l = 0 === o,
                h = t.canvas.parentElement.style;
              (h.left = "".concat(i, "px")),
                (h.top = "".concat(r, "px")),
                t.setProps({
                  width: e,
                  height: n,
                  viewState: { latitude: a, longitude: c, zoom: s, repeat: !0 },
                  layerFilter: l ? this.props.layerFilter : gd,
                }),
                t.redraw();
            }
            _onDrawVector(t, e) {
              const n = this._deck;
              if ((n.setProps({ ...ud(this._map, e) }), n.layerManager)) {
                const e = ft(t, 36006);
                n.setProps({ _framebuffer: e }),
                  n.needsRedraw({ clearRedrawFlags: !0 }),
                  dt(t, {
                    viewport: [0, 0, t.canvas.width, t.canvas.height],
                    scissor: [0, 0, t.canvas.width, t.canvas.height],
                    stencilFunc: [519, 0, 255, 519, 0, 255],
                  }),
                  pt(t, md, () => {
                    n._drawLayers("google-vector", { clearCanvas: !1 });
                  });
              }
            }
          }
          function _d() {
            const t = new google.maps.Map(document.getElementById("map"), {
              center: { lat: 40, lng: -110 },
              zoom: 4,
            });
            new yd({
              layers: [
                new Zl({
                  id: "earthquakes",
                  data: "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson",
                  filled: !0,
                  pointRadiusMinPixels: 2,
                  pointRadiusMaxPixels: 200,
                  opacity: 0.4,
                  pointRadiusScale: 0.3,
                  getRadius: (t) => Math.pow(10, t.properties.mag),
                  getFillColor: [255, 70, 30, 180],
                  autoHighlight: !0,
                  transitions: {
                    getRadius: {
                      type: "spring",
                      stiffness: 0.1,
                      damping: 0.15,
                      enter: () => [0],
                      duration: 1e4,
                    },
                  },
                  onDataLoad: () => {
                    progress.done();
                  },
                }),
              ],
            }).setMap(t);
          }
        })();
        var r = window;
        for (var s in i) r[s] = i[s];
        i.__esModule && Object.defineProperty(r, "__esModule", { value: !0 });
      })();
    </script>
  </head>
  <body>
    <div
      role="progressbar"
      class="mdc-linear-progress"
      aria-label="Data Progress Bar"
    >
      <div class="mdc-linear-progress__buffer">
        <div class="mdc-linear-progress__buffer-bar"></div>
        <div class="mdc-linear-progress__buffer-dots"></div>
      </div>
      <div class="mdc-linear-progress__bar mdc-linear-progress__primary-bar">
        <span class="mdc-linear-progress__bar-inner"></span>
      </div>
      <div class="mdc-linear-progress__bar mdc-linear-progress__secondary-bar">
        <span class="mdc-linear-progress__bar-inner"></span>
      </div>
    </div>
    <script>
      var progress, progressDiv;
      progressDiv = document.querySelector(".mdc-linear-progress");
      progress = new mdc.linearProgress.MDCLinearProgress(progressDiv);
      progress.open();
      progress.determinate = false;
      progress.done = function () {
        progress.close();
        progressDiv.remove();
      };
    </script>
    <div id="map"></div>

    <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=weekly"
      async
    ></script>
  </body>
</html>
