<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
<style type="text/css">
  /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
  #map {
    height: 100%;
  }

  /* Optional: Makes the sample page fill the window. */
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
  }
</style>
<script>
  /*! For license information please see iframe.js.LICENSE.txt */
  (() => {
    "use strict";
    var e = {
        d: (t, n) => {
          for (var i in n)
            e.o(n, i) &&
              !e.o(t, i) &&
              Object.defineProperty(t, i, { enumerable: !0, get: n[i] });
        },
        o: (e, t) => Object.prototype.hasOwnProperty.call(e, t),
        r: (e) => {
          "undefined" != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(e, "__esModule", { value: !0 });
        },
      },
      t = {};
    e.r(t), e.d(t, { initMap: () => Vl });
    const n = 100,
      i = 1e3,
      r = 1001,
      s = 1002,
      a = 1003,
      o = 1004,
      l = 1005,
      c = 1006,
      h = 1008,
      u = 1012,
      d = 1014,
      p = 1015,
      m = 1016,
      f = 1020,
      g = 1022,
      v = 1023,
      x = 1026,
      y = 1027,
      _ = 2300,
      w = 2301,
      b = 2302,
      M = 2400,
      S = 2401,
      T = 2402,
      E = 3e3,
      A = 3001,
      L = 7680,
      R = 35044,
      C = 35048,
      P = "300 es";
    class I {
      addEventListener(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
      }
      hasEventListener(e, t) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[e] && -1 !== n[e].indexOf(t);
      }
      removeEventListener(e, t) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[e];
        if (void 0 !== n) {
          const e = n.indexOf(t);
          -1 !== e && n.splice(e, 1);
        }
      }
      dispatchEvent(e) {
        if (void 0 === this._listeners) return;
        const t = this._listeners[e.type];
        if (void 0 !== t) {
          e.target = this;
          const n = t.slice(0);
          for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
          e.target = null;
        }
      }
    }
    const N = [];
    for (let e = 0; e < 256; e++) N[e] = (e < 16 ? "0" : "") + e.toString(16);
    let D = 1234567;
    const O = Math.PI / 180,
      z = 180 / Math.PI;
    function H() {
      const e = (4294967295 * Math.random()) | 0,
        t = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0;
      return (
        N[255 & e] +
        N[(e >> 8) & 255] +
        N[(e >> 16) & 255] +
        N[(e >> 24) & 255] +
        "-" +
        N[255 & t] +
        N[(t >> 8) & 255] +
        "-" +
        N[((t >> 16) & 15) | 64] +
        N[(t >> 24) & 255] +
        "-" +
        N[(63 & n) | 128] +
        N[(n >> 8) & 255] +
        "-" +
        N[(n >> 16) & 255] +
        N[(n >> 24) & 255] +
        N[255 & i] +
        N[(i >> 8) & 255] +
        N[(i >> 16) & 255] +
        N[(i >> 24) & 255]
      ).toUpperCase();
    }
    function F(e, t, n) {
      return Math.max(t, Math.min(n, e));
    }
    function B(e, t) {
      return ((e % t) + t) % t;
    }
    function U(e, t, n) {
      return (1 - n) * e + n * t;
    }
    function G(e) {
      return 0 == (e & (e - 1)) && 0 !== e;
    }
    function k(e) {
      return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    }
    function V(e) {
      return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
    }
    var W = Object.freeze({
      __proto__: null,
      DEG2RAD: O,
      RAD2DEG: z,
      generateUUID: H,
      clamp: F,
      euclideanModulo: B,
      mapLinear: function (e, t, n, i, r) {
        return i + ((e - t) * (r - i)) / (n - t);
      },
      inverseLerp: function (e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0;
      },
      lerp: U,
      damp: function (e, t, n, i) {
        return U(e, t, 1 - Math.exp(-n * i));
      },
      pingpong: function (e, t = 1) {
        return t - Math.abs(B(e, 2 * t) - t);
      },
      smoothstep: function (e, t, n) {
        return e <= t
          ? 0
          : e >= n
          ? 1
          : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
      },
      smootherstep: function (e, t, n) {
        return e <= t
          ? 0
          : e >= n
          ? 1
          : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
      },
      randInt: function (e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
      },
      randFloat: function (e, t) {
        return e + Math.random() * (t - e);
      },
      randFloatSpread: function (e) {
        return e * (0.5 - Math.random());
      },
      seededRandom: function (e) {
        return (
          void 0 !== e && (D = e % 2147483647),
          (D = (16807 * D) % 2147483647),
          (D - 1) / 2147483646
        );
      },
      degToRad: function (e) {
        return e * O;
      },
      radToDeg: function (e) {
        return e * z;
      },
      isPowerOfTwo: G,
      ceilPowerOfTwo: k,
      floorPowerOfTwo: V,
      setQuaternionFromProperEuler: function (e, t, n, i, r) {
        const s = Math.cos,
          a = Math.sin,
          o = s(n / 2),
          l = a(n / 2),
          c = s((t + i) / 2),
          h = a((t + i) / 2),
          u = s((t - i) / 2),
          d = a((t - i) / 2),
          p = s((i - t) / 2),
          m = a((i - t) / 2);
        switch (r) {
          case "XYX":
            e.set(o * h, l * u, l * d, o * c);
            break;
          case "YZY":
            e.set(l * d, o * h, l * u, o * c);
            break;
          case "ZXZ":
            e.set(l * u, l * d, o * h, o * c);
            break;
          case "XZX":
            e.set(o * h, l * m, l * p, o * c);
            break;
          case "YXY":
            e.set(l * p, o * h, l * m, o * c);
            break;
          case "ZYZ":
            e.set(l * m, l * p, o * h, o * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                r
            );
        }
      },
    });
    class j {
      constructor(e = 0, t = 0) {
        (this.x = e), (this.y = t);
      }
      get width() {
        return this.x;
      }
      set width(e) {
        this.x = e;
      }
      get height() {
        return this.y;
      }
      set height(e) {
        this.y = e;
      }
      set(e, t) {
        return (this.x = e), (this.y = t), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x), (this.y += e.y), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x), (this.y -= e.y), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      applyMatrix3(e) {
        const t = this.x,
          n = this.y,
          i = e.elements;
        return (
          (this.x = i[0] * t + i[3] * n + i[6]),
          (this.y = i[1] * t + i[4] * n + i[7]),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y;
      }
      cross(e) {
        return this.x * e.y - this.y * e.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          n = this.y - e.y;
        return t * t + n * n;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          this
        );
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          this
        );
      }
      rotateAround(e, t) {
        const n = Math.cos(t),
          i = Math.sin(t),
          r = this.x - e.x,
          s = this.y - e.y;
        return (
          (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
    }
    j.prototype.isVector2 = !0;
    class q {
      constructor() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(e, t, n, i, r, s, a, o, l) {
        const c = this.elements;
        return (
          (c[0] = e),
          (c[1] = i),
          (c[2] = a),
          (c[3] = t),
          (c[4] = r),
          (c[5] = o),
          (c[6] = n),
          (c[7] = s),
          (c[8] = l),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(e) {
        const t = this.elements,
          n = e.elements;
        return (
          (t[0] = n[0]),
          (t[1] = n[1]),
          (t[2] = n[2]),
          (t[3] = n[3]),
          (t[4] = n[4]),
          (t[5] = n[5]),
          (t[6] = n[6]),
          (t[7] = n[7]),
          (t[8] = n[8]),
          this
        );
      }
      extractBasis(e, t, n) {
        return (
          e.setFromMatrix3Column(this, 0),
          t.setFromMatrix3Column(this, 1),
          n.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(e) {
        const t = e.elements;
        return (
          this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        );
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const n = e.elements,
          i = t.elements,
          r = this.elements,
          s = n[0],
          a = n[3],
          o = n[6],
          l = n[1],
          c = n[4],
          h = n[7],
          u = n[2],
          d = n[5],
          p = n[8],
          m = i[0],
          f = i[3],
          g = i[6],
          v = i[1],
          x = i[4],
          y = i[7],
          _ = i[2],
          w = i[5],
          b = i[8];
        return (
          (r[0] = s * m + a * v + o * _),
          (r[3] = s * f + a * x + o * w),
          (r[6] = s * g + a * y + o * b),
          (r[1] = l * m + c * v + h * _),
          (r[4] = l * f + c * x + h * w),
          (r[7] = l * g + c * y + h * b),
          (r[2] = u * m + d * v + p * _),
          (r[5] = u * f + d * x + p * w),
          (r[8] = u * g + d * y + p * b),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[3] *= e),
          (t[6] *= e),
          (t[1] *= e),
          (t[4] *= e),
          (t[7] *= e),
          (t[2] *= e),
          (t[5] *= e),
          (t[8] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          i = e[2],
          r = e[3],
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          c = e[8];
        return (
          t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          i = e[2],
          r = e[3],
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          c = e[8],
          h = c * s - a * l,
          u = a * o - c * r,
          d = l * r - s * o,
          p = t * h + n * u + i * d;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / p;
        return (
          (e[0] = h * m),
          (e[1] = (i * l - c * n) * m),
          (e[2] = (a * n - i * s) * m),
          (e[3] = u * m),
          (e[4] = (c * t - i * o) * m),
          (e[5] = (i * r - a * t) * m),
          (e[6] = d * m),
          (e[7] = (n * o - l * t) * m),
          (e[8] = (s * t - n * r) * m),
          this
        );
      }
      transpose() {
        let e;
        const t = this.elements;
        return (
          (e = t[1]),
          (t[1] = t[3]),
          (t[3] = e),
          (e = t[2]),
          (t[2] = t[6]),
          (t[6] = e),
          (e = t[5]),
          (t[5] = t[7]),
          (t[7] = e),
          this
        );
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transposeIntoArray(e) {
        const t = this.elements;
        return (
          (e[0] = t[0]),
          (e[1] = t[3]),
          (e[2] = t[6]),
          (e[3] = t[1]),
          (e[4] = t[4]),
          (e[5] = t[7]),
          (e[6] = t[2]),
          (e[7] = t[5]),
          (e[8] = t[8]),
          this
        );
      }
      setUvTransform(e, t, n, i, r, s, a) {
        const o = Math.cos(r),
          l = Math.sin(r);
        return (
          this.set(
            n * o,
            n * l,
            -n * (o * s + l * a) + s + e,
            -i * l,
            i * o,
            -i * (-l * s + o * a) + a + t,
            0,
            0,
            1
          ),
          this
        );
      }
      scale(e, t) {
        const n = this.elements;
        return (
          (n[0] *= e),
          (n[3] *= e),
          (n[6] *= e),
          (n[1] *= t),
          (n[4] *= t),
          (n[7] *= t),
          this
        );
      }
      rotate(e) {
        const t = Math.cos(e),
          n = Math.sin(e),
          i = this.elements,
          r = i[0],
          s = i[3],
          a = i[6],
          o = i[1],
          l = i[4],
          c = i[7];
        return (
          (i[0] = t * r + n * o),
          (i[3] = t * s + n * l),
          (i[6] = t * a + n * c),
          (i[1] = -n * r + t * o),
          (i[4] = -n * s + t * l),
          (i[7] = -n * a + t * c),
          this
        );
      }
      translate(e, t) {
        const n = this.elements;
        return (
          (n[0] += e * n[2]),
          (n[3] += e * n[5]),
          (n[6] += e * n[8]),
          (n[1] += t * n[2]),
          (n[4] += t * n[5]),
          (n[7] += t * n[8]),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          n = e.elements;
        for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.elements;
        return (
          (e[t] = n[0]),
          (e[t + 1] = n[1]),
          (e[t + 2] = n[2]),
          (e[t + 3] = n[3]),
          (e[t + 4] = n[4]),
          (e[t + 5] = n[5]),
          (e[t + 6] = n[6]),
          (e[t + 7] = n[7]),
          (e[t + 8] = n[8]),
          e
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    let X;
    q.prototype.isMatrix3 = !0;
    class Y {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
          void 0 === X &&
            (X = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "canvas"
            )),
            (X.width = e.width),
            (X.height = e.height);
          const n = X.getContext("2d");
          e instanceof ImageData
            ? n.putImageData(e, 0, 0)
            : n.drawImage(e, 0, 0, e.width, e.height),
            (t = X);
        }
        return t.width > 2048 || t.height > 2048
          ? (console.warn(
              "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
              e
            ),
            t.toDataURL("image/jpeg", 0.6))
          : t.toDataURL("image/png");
      }
    }
    let Z = 0;
    class J extends I {
      constructor(
        e = J.DEFAULT_IMAGE,
        t = J.DEFAULT_MAPPING,
        n = 1001,
        i = 1001,
        r = 1006,
        s = 1008,
        a = 1023,
        o = 1009,
        l = 1,
        c = 3e3
      ) {
        super(),
          Object.defineProperty(this, "id", { value: Z++ }),
          (this.uuid = H()),
          (this.name = ""),
          (this.image = e),
          (this.mipmaps = []),
          (this.mapping = t),
          (this.wrapS = n),
          (this.wrapT = i),
          (this.magFilter = r),
          (this.minFilter = s),
          (this.anisotropy = l),
          (this.format = a),
          (this.internalFormat = null),
          (this.type = o),
          (this.offset = new j(0, 0)),
          (this.repeat = new j(1, 1)),
          (this.center = new j(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new q()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = c),
          (this.version = 0),
          (this.onUpdate = null);
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.image = e.image),
          (this.mipmaps = e.mipmaps.slice(0)),
          (this.mapping = e.mapping),
          (this.wrapS = e.wrapS),
          (this.wrapT = e.wrapT),
          (this.magFilter = e.magFilter),
          (this.minFilter = e.minFilter),
          (this.anisotropy = e.anisotropy),
          (this.format = e.format),
          (this.internalFormat = e.internalFormat),
          (this.type = e.type),
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          (this.rotation = e.rotation),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this.matrix.copy(e.matrix),
          (this.generateMipmaps = e.generateMipmaps),
          (this.premultiplyAlpha = e.premultiplyAlpha),
          (this.flipY = e.flipY),
          (this.unpackAlignment = e.unpackAlignment),
          (this.encoding = e.encoding),
          this
        );
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid])
          return e.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        if (void 0 !== this.image) {
          const i = this.image;
          if (
            (void 0 === i.uuid && (i.uuid = H()),
            !t && void 0 === e.images[i.uuid])
          ) {
            let t;
            if (Array.isArray(i)) {
              t = [];
              for (let e = 0, n = i.length; e < n; e++)
                i[e].isDataTexture ? t.push(K(i[e].image)) : t.push(K(i[e]));
            } else t = K(i);
            e.images[i.uuid] = { uuid: i.uuid, url: t };
          }
          n.image = i.uuid;
        }
        return t || (e.textures[this.uuid] = n), n;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(e) {
        if (300 !== this.mapping) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
          switch (this.wrapS) {
            case i:
              e.x = e.x - Math.floor(e.x);
              break;
            case r:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case s:
              1 === Math.abs(Math.floor(e.x) % 2)
                ? (e.x = Math.ceil(e.x) - e.x)
                : (e.x = e.x - Math.floor(e.x));
          }
        if (e.y < 0 || e.y > 1)
          switch (this.wrapT) {
            case i:
              e.y = e.y - Math.floor(e.y);
              break;
            case r:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case s:
              1 === Math.abs(Math.floor(e.y) % 2)
                ? (e.y = Math.ceil(e.y) - e.y)
                : (e.y = e.y - Math.floor(e.y));
          }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
    }
    function K(e) {
      return ("undefined" != typeof HTMLImageElement &&
        e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
        ? Y.getDataURL(e)
        : e.data
        ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name,
          }
        : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    (J.DEFAULT_IMAGE = void 0),
      (J.DEFAULT_MAPPING = 300),
      (J.prototype.isTexture = !0);
    class Q {
      constructor(e = 0, t = 0, n = 0, i = 1) {
        (this.x = e), (this.y = t), (this.z = n), (this.w = i);
      }
      get width() {
        return this.z;
      }
      set width(e) {
        this.z = e;
      }
      get height() {
        return this.w;
      }
      set height(e) {
        this.w = e;
      }
      set(e, t, n, i) {
        return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setW(e) {
        return (this.w = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(e) {
        return (
          (this.x = e.x),
          (this.y = e.y),
          (this.z = e.z),
          (this.w = void 0 !== e.w ? e.w : 1),
          this
        );
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x),
          (this.y = e.y + t.y),
          (this.z = e.z + t.z),
          (this.w = e.w + t.w),
          this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t),
          (this.y += e.y * t),
          (this.z += e.z * t),
          (this.w += e.w * t),
          this
        );
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x),
          (this.y = e.y - t.y),
          (this.z = e.z - t.z),
          (this.w = e.w - t.w),
          this
        );
      }
      multiply(e) {
        return (
          (this.x *= e.x),
          (this.y *= e.y),
          (this.z *= e.z),
          (this.w *= e.w),
          this
        );
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
      }
      applyMatrix4(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          s = e.elements;
        return (
          (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
          (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
          (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
          (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
          this
        );
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return (
          t < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(e) {
        let t, n, i, r;
        const s = 0.01,
          a = 0.1,
          o = e.elements,
          l = o[0],
          c = o[4],
          h = o[8],
          u = o[1],
          d = o[5],
          p = o[9],
          m = o[2],
          f = o[6],
          g = o[10];
        if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
          if (
            Math.abs(c + u) < a &&
            Math.abs(h + m) < a &&
            Math.abs(p + f) < a &&
            Math.abs(l + d + g - 3) < a
          )
            return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          const e = (l + 1) / 2,
            o = (d + 1) / 2,
            v = (g + 1) / 2,
            x = (c + u) / 4,
            y = (h + m) / 4,
            _ = (p + f) / 4;
          return (
            e > o && e > v
              ? e < s
                ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                : ((n = Math.sqrt(e)), (i = x / n), (r = y / n))
              : o > v
              ? o < s
                ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                : ((i = Math.sqrt(o)), (n = x / i), (r = _ / i))
              : v < s
              ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
              : ((r = Math.sqrt(v)), (n = y / r), (i = _ / r)),
            this.set(n, i, r, t),
            this
          );
        }
        let v = Math.sqrt(
          (f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c)
        );
        return (
          Math.abs(v) < 0.001 && (v = 1),
          (this.x = (f - p) / v),
          (this.y = (h - m) / v),
          (this.z = (u - c) / v),
          (this.w = Math.acos((l + d + g - 1) / 2)),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          (this.w = Math.min(this.w, e.w)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          (this.w = Math.max(this.w, e.w)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          (this.w = Math.max(e.w, Math.min(t.w, this.w))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          (this.w = Math.max(e, Math.min(t, this.w))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          (this.w += (e.w - this.w) * t),
          this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          (this.z = e.z + (t.z - e.z) * n),
          (this.w = e.w + (t.w - e.w) * n),
          this
        );
      }
      equals(e) {
        return (
          e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this.x = e[t]),
          (this.y = e[t + 1]),
          (this.z = e[t + 2]),
          (this.w = e[t + 3]),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this.x),
          (e[t + 1] = this.y),
          (e[t + 2] = this.z),
          (e[t + 3] = this.w),
          e
        );
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          (this.w = e.getW(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
    }
    Q.prototype.isVector4 = !0;
    class $ extends I {
      constructor(e, t, n) {
        super(),
          (this.width = e),
          (this.height = t),
          (this.depth = 1),
          (this.scissor = new Q(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new Q(0, 0, e, t)),
          (n = n || {}),
          (this.texture = new J(
            void 0,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
          (this.texture.image = {}),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.image.depth = 1),
          (this.texture.generateMipmaps =
            void 0 !== n.generateMipmaps && n.generateMipmaps),
          (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : c),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null);
      }
      setTexture(e) {
        (e.image = {
          width: this.width,
          height: this.height,
          depth: this.depth,
        }),
          (this.texture = e);
      }
      setSize(e, t, n = 1) {
        (this.width === e && this.height === t && this.depth === n) ||
          ((this.width = e),
          (this.height = t),
          (this.depth = n),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.image.depth = n),
          this.dispose()),
          this.viewport.set(0, 0, e, t),
          this.scissor.set(0, 0, e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.copy(e.viewport),
          (this.texture = e.texture.clone()),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          (this.depthTexture = e.depthTexture),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    ($.prototype.isWebGLRenderTarget = !0),
      (class extends $ {
        constructor(e, t, n) {
          super(e, t, n), (this.samples = 4);
        }
        copy(e) {
          return super.copy.call(this, e), (this.samples = e.samples), this;
        }
      }.prototype.isWebGLMultisampleRenderTarget = !0);
    class ee {
      constructor(e = 0, t = 0, n = 0, i = 1) {
        (this._x = e), (this._y = t), (this._z = n), (this._w = i);
      }
      static slerp(e, t, n, i) {
        return (
          console.warn(
            "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
          ),
          n.slerpQuaternions(e, t, i)
        );
      }
      static slerpFlat(e, t, n, i, r, s, a) {
        let o = n[i + 0],
          l = n[i + 1],
          c = n[i + 2],
          h = n[i + 3];
        const u = r[s + 0],
          d = r[s + 1],
          p = r[s + 2],
          m = r[s + 3];
        if (0 === a)
          return (
            (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = c), void (e[t + 3] = h)
          );
        if (1 === a)
          return (
            (e[t + 0] = u), (e[t + 1] = d), (e[t + 2] = p), void (e[t + 3] = m)
          );
        if (h !== m || o !== u || l !== d || c !== p) {
          let e = 1 - a;
          const t = o * u + l * d + c * p + h * m,
            n = t >= 0 ? 1 : -1,
            i = 1 - t * t;
          if (i > Number.EPSILON) {
            const r = Math.sqrt(i),
              s = Math.atan2(r, t * n);
            (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
          }
          const r = a * n;
          if (
            ((o = o * e + u * r),
            (l = l * e + d * r),
            (c = c * e + p * r),
            (h = h * e + m * r),
            e === 1 - a)
          ) {
            const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
            (o *= e), (l *= e), (c *= e), (h *= e);
          }
        }
        (e[t] = o), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = h);
      }
      static multiplyQuaternionsFlat(e, t, n, i, r, s) {
        const a = n[i],
          o = n[i + 1],
          l = n[i + 2],
          c = n[i + 3],
          h = r[s],
          u = r[s + 1],
          d = r[s + 2],
          p = r[s + 3];
        return (
          (e[t] = a * p + c * h + o * d - l * u),
          (e[t + 1] = o * p + c * u + l * h - a * d),
          (e[t + 2] = l * p + c * d + a * u - o * h),
          (e[t + 3] = c * p - a * h - o * u - l * d),
          e
        );
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(e) {
        (this._w = e), this._onChangeCallback();
      }
      set(e, t, n, i) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = n),
          (this._w = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(e) {
        return (
          (this._x = e.x),
          (this._y = e.y),
          (this._z = e.z),
          (this._w = e.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(e, t) {
        if (!e || !e.isEuler)
          throw new Error(
            "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
          );
        const n = e._x,
          i = e._y,
          r = e._z,
          s = e._order,
          a = Math.cos,
          o = Math.sin,
          l = a(n / 2),
          c = a(i / 2),
          h = a(r / 2),
          u = o(n / 2),
          d = o(i / 2),
          p = o(r / 2);
        switch (s) {
          case "XYZ":
            (this._x = u * c * h + l * d * p),
              (this._y = l * d * h - u * c * p),
              (this._z = l * c * p + u * d * h),
              (this._w = l * c * h - u * d * p);
            break;
          case "YXZ":
            (this._x = u * c * h + l * d * p),
              (this._y = l * d * h - u * c * p),
              (this._z = l * c * p - u * d * h),
              (this._w = l * c * h + u * d * p);
            break;
          case "ZXY":
            (this._x = u * c * h - l * d * p),
              (this._y = l * d * h + u * c * p),
              (this._z = l * c * p + u * d * h),
              (this._w = l * c * h - u * d * p);
            break;
          case "ZYX":
            (this._x = u * c * h - l * d * p),
              (this._y = l * d * h + u * c * p),
              (this._z = l * c * p - u * d * h),
              (this._w = l * c * h + u * d * p);
            break;
          case "YZX":
            (this._x = u * c * h + l * d * p),
              (this._y = l * d * h + u * c * p),
              (this._z = l * c * p - u * d * h),
              (this._w = l * c * h - u * d * p);
            break;
          case "XZY":
            (this._x = u * c * h - l * d * p),
              (this._y = l * d * h - u * c * p),
              (this._z = l * c * p + u * d * h),
              (this._w = l * c * h + u * d * p);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                s
            );
        }
        return !1 !== t && this._onChangeCallback(), this;
      }
      setFromAxisAngle(e, t) {
        const n = t / 2,
          i = Math.sin(n);
        return (
          (this._x = e.x * i),
          (this._y = e.y * i),
          (this._z = e.z * i),
          (this._w = Math.cos(n)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e) {
        const t = e.elements,
          n = t[0],
          i = t[4],
          r = t[8],
          s = t[1],
          a = t[5],
          o = t[9],
          l = t[2],
          c = t[6],
          h = t[10],
          u = n + a + h;
        if (u > 0) {
          const e = 0.5 / Math.sqrt(u + 1);
          (this._w = 0.25 / e),
            (this._x = (c - o) * e),
            (this._y = (r - l) * e),
            (this._z = (s - i) * e);
        } else if (n > a && n > h) {
          const e = 2 * Math.sqrt(1 + n - a - h);
          (this._w = (c - o) / e),
            (this._x = 0.25 * e),
            (this._y = (i + s) / e),
            (this._z = (r + l) / e);
        } else if (a > h) {
          const e = 2 * Math.sqrt(1 + a - n - h);
          (this._w = (r - l) / e),
            (this._x = (i + s) / e),
            (this._y = 0.25 * e),
            (this._z = (o + c) / e);
        } else {
          const e = 2 * Math.sqrt(1 + h - n - a);
          (this._w = (s - i) / e),
            (this._x = (r + l) / e),
            (this._y = (o + c) / e),
            (this._z = 0.25 * e);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return (
          n < Number.EPSILON
            ? ((n = 0),
              Math.abs(e.x) > Math.abs(e.z)
                ? ((this._x = -e.y),
                  (this._y = e.x),
                  (this._z = 0),
                  (this._w = n))
                : ((this._x = 0),
                  (this._y = -e.z),
                  (this._z = e.y),
                  (this._w = n)))
            : ((this._x = e.y * t.z - e.z * t.y),
              (this._y = e.z * t.x - e.x * t.z),
              (this._z = e.x * t.y - e.y * t.x),
              (this._w = n)),
          this.normalize()
        );
      }
      angleTo(e) {
        return 2 * Math.acos(Math.abs(F(this.dot(e), -1, 1)));
      }
      rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (0 === n) return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(e) {
        return (
          this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
      }
      normalize() {
        let e = this.length();
        return (
          0 === e
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((e = 1 / e),
              (this._x = this._x * e),
              (this._y = this._y * e),
              (this._z = this._z * e),
              (this._w = this._w * e)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
            ),
            this.multiplyQuaternions(e, t))
          : this.multiplyQuaternions(this, e);
      }
      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }
      multiplyQuaternions(e, t) {
        const n = e._x,
          i = e._y,
          r = e._z,
          s = e._w,
          a = t._x,
          o = t._y,
          l = t._z,
          c = t._w;
        return (
          (this._x = n * c + s * a + i * l - r * o),
          (this._y = i * c + s * o + r * a - n * l),
          (this._z = r * c + s * l + n * o - i * a),
          (this._w = s * c - n * a - i * o - r * l),
          this._onChangeCallback(),
          this
        );
      }
      slerp(e, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(e);
        const n = this._x,
          i = this._y,
          r = this._z,
          s = this._w;
        let a = s * e._w + n * e._x + i * e._y + r * e._z;
        if (
          (a < 0
            ? ((this._w = -e._w),
              (this._x = -e._x),
              (this._y = -e._y),
              (this._z = -e._z),
              (a = -a))
            : this.copy(e),
          a >= 1)
        )
          return (
            (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
          );
        const o = 1 - a * a;
        if (o <= Number.EPSILON) {
          const e = 1 - t;
          return (
            (this._w = e * s + t * this._w),
            (this._x = e * n + t * this._x),
            (this._y = e * i + t * this._y),
            (this._z = e * r + t * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const l = Math.sqrt(o),
          c = Math.atan2(l, a),
          h = Math.sin((1 - t) * c) / l,
          u = Math.sin(t * c) / l;
        return (
          (this._w = s * h + this._w * u),
          (this._x = n * h + this._x * u),
          (this._y = i * h + this._y * u),
          (this._z = r * h + this._z * u),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(e, t, n) {
        this.copy(e).slerp(t, n);
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._w === this._w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this._x = e[t]),
          (this._y = e[t + 1]),
          (this._z = e[t + 2]),
          (this._w = e[t + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._w),
          e
        );
      }
      fromBufferAttribute(e, t) {
        return (
          (this._x = e.getX(t)),
          (this._y = e.getY(t)),
          (this._z = e.getZ(t)),
          (this._w = e.getW(t)),
          this
        );
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
    }
    ee.prototype.isQuaternion = !0;
    class te {
      constructor(e = 0, t = 0, n = 0) {
        (this.x = e), (this.y = t), (this.z = n);
      }
      set(e, t, n) {
        return (
          void 0 === n && (n = this.z),
          (this.x = e),
          (this.y = t),
          (this.z = n),
          this
        );
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
        );
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(e, t))
          : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
      }
      multiplyVectors(e, t) {
        return (
          (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
        );
      }
      applyEuler(e) {
        return (
          (e && e.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(ie.setFromEuler(e))
        );
      }
      applyAxisAngle(e, t) {
        return this.applyQuaternion(ie.setFromAxisAngle(e, t));
      }
      applyMatrix3(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[3] * n + r[6] * i),
          (this.y = r[1] * t + r[4] * n + r[7] * i),
          (this.z = r[2] * t + r[5] * n + r[8] * i),
          this
        );
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.elements,
          s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
        return (
          (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
          (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
          (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
          this
        );
      }
      applyQuaternion(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.x,
          s = e.y,
          a = e.z,
          o = e.w,
          l = o * t + s * i - a * n,
          c = o * n + a * t - r * i,
          h = o * i + r * n - s * t,
          u = -r * t - s * n - a * i;
        return (
          (this.x = l * o + u * -r + c * -a - h * -s),
          (this.y = c * o + u * -s + h * -r - l * -a),
          (this.z = h * o + u * -a + l * -s - c * -r),
          this
        );
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
          e.projectionMatrix
        );
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
          e.matrixWorld
        );
      }
      transformDirection(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[4] * n + r[8] * i),
          (this.y = r[1] * t + r[5] * n + r[9] * i),
          (this.z = r[2] * t + r[6] * n + r[10] * i),
          this.normalize()
        );
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          (this.z = e.z + (t.z - e.z) * n),
          this
        );
      }
      cross(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(e, t))
          : this.crossVectors(this, e);
      }
      crossVectors(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z,
          s = t.x,
          a = t.y,
          o = t.z;
        return (
          (this.x = i * o - r * a),
          (this.y = r * s - n * o),
          (this.z = n * a - i * s),
          this
        );
      }
      projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t) return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n);
      }
      projectOnPlane(e) {
        return ne.copy(this).projectOnVector(e), this.sub(ne);
      }
      reflect(e) {
        return this.sub(ne.copy(e).multiplyScalar(2 * this.dot(e)));
      }
      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(F(n, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          n = this.y - e.y,
          i = this.z - e.z;
        return t * t + n * n + i * i;
      }
      manhattanDistanceTo(e) {
        return (
          Math.abs(this.x - e.x) +
          Math.abs(this.y - e.y) +
          Math.abs(this.z - e.z)
        );
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return (
          (this.x = i * Math.sin(n)),
          (this.y = Math.cos(t) * e),
          (this.z = i * Math.cos(n)),
          this
        );
      }
      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }
      setFromCylindricalCoords(e, t, n) {
        return (
          (this.x = e * Math.sin(t)),
          (this.y = n),
          (this.z = e * Math.cos(t)),
          this
        );
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
      }
      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
          n = this.setFromMatrixColumn(e, 1).length(),
          i = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = n), (this.z = i), this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t);
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
    }
    te.prototype.isVector3 = !0;
    const ne = new te(),
      ie = new ee();
    class re {
      constructor(
        e = new te(1 / 0, 1 / 0, 1 / 0),
        t = new te(-1 / 0, -1 / 0, -1 / 0)
      ) {
        (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromArray(e) {
        let t = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          a = -1 / 0;
        for (let o = 0, l = e.length; o < l; o += 3) {
          const l = e[o],
            c = e[o + 1],
            h = e[o + 2];
          l < t && (t = l),
            c < n && (n = c),
            h < i && (i = h),
            l > r && (r = l),
            c > s && (s = c),
            h > a && (a = h);
        }
        return this.min.set(t, n, i), this.max.set(r, s, a), this;
      }
      setFromBufferAttribute(e) {
        let t = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          a = -1 / 0;
        for (let o = 0, l = e.count; o < l; o++) {
          const l = e.getX(o),
            c = e.getY(o),
            h = e.getZ(o);
          l < t && (t = l),
            c < n && (n = c),
            h < i && (i = h),
            l > r && (r = l),
            c > s && (s = c),
            h > a && (a = h);
        }
        return this.min.set(t, n, i), this.max.set(r, s, a), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const n = ae.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }
      setFromObject(e) {
        return this.makeEmpty(), this.expandByObject(e);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .getCenter() target is now required"),
            (e = new te())),
          this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      }
      getSize(e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .getSize() target is now required"),
            (e = new te())),
          this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        );
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      expandByObject(e) {
        e.updateWorldMatrix(!1, !1);
        const t = e.geometry;
        void 0 !== t &&
          (null === t.boundingBox && t.computeBoundingBox(),
          oe.copy(t.boundingBox),
          oe.applyMatrix4(e.matrixWorld),
          this.union(oe));
        const n = e.children;
        for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
        return this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y ||
          e.z < this.min.z ||
          e.z > this.max.z
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y &&
          this.min.z <= e.min.z &&
          e.max.z <= this.max.z
        );
      }
      getParameter(e, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getParameter() target is now required"),
            (t = new te())),
          t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          )
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y ||
          e.max.z < this.min.z ||
          e.min.z > this.max.z
        );
      }
      intersectsSphere(e) {
        return (
          this.clampPoint(e.center, ae),
          ae.distanceToSquared(e.center) <= e.radius * e.radius
        );
      }
      intersectsPlane(e) {
        let t, n;
        return (
          e.normal.x > 0
            ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
            : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
          e.normal.y > 0
            ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
            : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
          e.normal.z > 0
            ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
            : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
          t <= -e.constant && n >= -e.constant
        );
      }
      intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(me),
          fe.subVectors(this.max, me),
          le.subVectors(e.a, me),
          ce.subVectors(e.b, me),
          he.subVectors(e.c, me),
          ue.subVectors(ce, le),
          de.subVectors(he, ce),
          pe.subVectors(le, he);
        let t = [
          0,
          -ue.z,
          ue.y,
          0,
          -de.z,
          de.y,
          0,
          -pe.z,
          pe.y,
          ue.z,
          0,
          -ue.x,
          de.z,
          0,
          -de.x,
          pe.z,
          0,
          -pe.x,
          -ue.y,
          ue.x,
          0,
          -de.y,
          de.x,
          0,
          -pe.y,
          pe.x,
          0,
        ];
        return (
          !!xe(t, le, ce, he, fe) &&
          ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!xe(t, le, ce, he, fe) &&
            (ge.crossVectors(ue, de),
            (t = [ge.x, ge.y, ge.z]),
            xe(t, le, ce, he, fe)))
        );
      }
      clampPoint(e, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .clampPoint() target is now required"),
            (t = new te())),
          t.copy(e).clamp(this.min, this.max)
        );
      }
      distanceToPoint(e) {
        return ae.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      getBoundingSphere(e) {
        return (
          void 0 === e &&
            console.error(
              "THREE.Box3: .getBoundingSphere() target is now required"
            ),
          this.getCenter(e.center),
          (e.radius = 0.5 * this.getSize(ae).length()),
          e
        );
      }
      intersect(e) {
        return (
          this.min.max(e.min),
          this.max.min(e.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      applyMatrix4(e) {
        return (
          this.isEmpty() ||
            (se[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            se[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            se[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            se[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            se[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            se[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            se[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            se[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(se)),
          this
        );
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    re.prototype.isBox3 = !0;
    const se = [
        new te(),
        new te(),
        new te(),
        new te(),
        new te(),
        new te(),
        new te(),
        new te(),
      ],
      ae = new te(),
      oe = new re(),
      le = new te(),
      ce = new te(),
      he = new te(),
      ue = new te(),
      de = new te(),
      pe = new te(),
      me = new te(),
      fe = new te(),
      ge = new te(),
      ve = new te();
    function xe(e, t, n, i, r) {
      for (let s = 0, a = e.length - 3; s <= a; s += 3) {
        ve.fromArray(e, s);
        const a =
            r.x * Math.abs(ve.x) + r.y * Math.abs(ve.y) + r.z * Math.abs(ve.z),
          o = t.dot(ve),
          l = n.dot(ve),
          c = i.dot(ve);
        if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
      }
      return !0;
    }
    const ye = new re(),
      _e = new te(),
      we = new te(),
      be = new te();
    class Me {
      constructor(e = new te(), t = -1) {
        (this.center = e), (this.radius = t);
      }
      set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
      }
      setFromPoints(e, t) {
        const n = this.center;
        void 0 !== t ? n.copy(t) : ye.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let t = 0, r = e.length; t < r; t++)
          i = Math.max(i, n.distanceToSquared(e[t]));
        return (this.radius = Math.sqrt(i)), this;
      }
      copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }
      intersectsBox(e) {
        return e.intersectsSphere(this);
      }
      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return (
          void 0 === t &&
            (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            (t = new te())),
          t.copy(e),
          n > this.radius * this.radius &&
            (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
          t
        );
      }
      getBoundingBox(e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Sphere: .getBoundingBox() target is now required"
            ),
            (e = new re())),
          this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e)
        );
      }
      applyMatrix4(e) {
        return (
          this.center.applyMatrix4(e),
          (this.radius = this.radius * e.getMaxScaleOnAxis()),
          this
        );
      }
      translate(e) {
        return this.center.add(e), this;
      }
      expandByPoint(e) {
        be.subVectors(e, this.center);
        const t = be.lengthSq();
        if (t > this.radius * this.radius) {
          const e = Math.sqrt(t),
            n = 0.5 * (e - this.radius);
          this.center.add(be.multiplyScalar(n / e)), (this.radius += n);
        }
        return this;
      }
      union(e) {
        return (
          we
            .subVectors(e.center, this.center)
            .normalize()
            .multiplyScalar(e.radius),
          this.expandByPoint(_e.copy(e.center).add(we)),
          this.expandByPoint(_e.copy(e.center).sub(we)),
          this
        );
      }
      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Se = new te(),
      Te = new te(),
      Ee = new te(),
      Ae = new te(),
      Le = new te(),
      Re = new te(),
      Ce = new te();
    class Pe {
      constructor(e = new te(), t = new te(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
      }
      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }
      copy(e) {
        return (
          this.origin.copy(e.origin), this.direction.copy(e.direction), this
        );
      }
      at(e, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Ray: .at() target is now required"),
            (t = new te())),
          t.copy(this.direction).multiplyScalar(e).add(this.origin)
        );
      }
      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }
      recast(e) {
        return this.origin.copy(this.at(e, Se)), this;
      }
      closestPointToPoint(e, t) {
        void 0 === t &&
          (console.warn(
            "THREE.Ray: .closestPointToPoint() target is now required"
          ),
          (t = new te())),
          t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0
          ? t.copy(this.origin)
          : t.copy(this.direction).multiplyScalar(n).add(this.origin);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint(e) {
        const t = Se.subVectors(e, this.origin).dot(this.direction);
        return t < 0
          ? this.origin.distanceToSquared(e)
          : (Se.copy(this.direction).multiplyScalar(t).add(this.origin),
            Se.distanceToSquared(e));
      }
      distanceSqToSegment(e, t, n, i) {
        Te.copy(e).add(t).multiplyScalar(0.5),
          Ee.copy(t).sub(e).normalize(),
          Ae.copy(this.origin).sub(Te);
        const r = 0.5 * e.distanceTo(t),
          s = -this.direction.dot(Ee),
          a = Ae.dot(this.direction),
          o = -Ae.dot(Ee),
          l = Ae.lengthSq(),
          c = Math.abs(1 - s * s);
        let h, u, d, p;
        if (c > 0)
          if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
            if (u >= -p)
              if (u <= p) {
                const e = 1 / c;
                (h *= e),
                  (u *= e),
                  (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
              } else
                (u = r),
                  (h = Math.max(0, -(s * u + a))),
                  (d = -h * h + u * (u + 2 * o) + l);
            else
              (u = -r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
          else
            u <= -p
              ? ((h = Math.max(0, -(-s * r + a))),
                (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                (d = -h * h + u * (u + 2 * o) + l))
              : u <= p
              ? ((h = 0),
                (u = Math.min(Math.max(-r, -o), r)),
                (d = u * (u + 2 * o) + l))
              : ((h = Math.max(0, -(s * r + a))),
                (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
                (d = -h * h + u * (u + 2 * o) + l));
        else
          (u = s > 0 ? -r : r),
            (h = Math.max(0, -(s * u + a))),
            (d = -h * h + u * (u + 2 * o) + l);
        return (
          n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
          i && i.copy(Ee).multiplyScalar(u).add(Te),
          d
        );
      }
      intersectSphere(e, t) {
        Se.subVectors(e.center, this.origin);
        const n = Se.dot(this.direction),
          i = Se.dot(Se) - n * n,
          r = e.radius * e.radius;
        if (i > r) return null;
        const s = Math.sqrt(r - i),
          a = n - s,
          o = n + s;
        return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null;
      }
      intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return null === n ? null : this.at(n, t);
      }
      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return 0 === t || e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let n, i, r, s, a, o;
        const l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          h = 1 / this.direction.z,
          u = this.origin;
        return (
          l >= 0
            ? ((n = (e.min.x - u.x) * l), (i = (e.max.x - u.x) * l))
            : ((n = (e.max.x - u.x) * l), (i = (e.min.x - u.x) * l)),
          c >= 0
            ? ((r = (e.min.y - u.y) * c), (s = (e.max.y - u.y) * c))
            : ((r = (e.max.y - u.y) * c), (s = (e.min.y - u.y) * c)),
          n > s || r > i
            ? null
            : ((r > n || n != n) && (n = r),
              (s < i || i != i) && (i = s),
              h >= 0
                ? ((a = (e.min.z - u.z) * h), (o = (e.max.z - u.z) * h))
                : ((a = (e.max.z - u.z) * h), (o = (e.min.z - u.z) * h)),
              n > o || a > i
                ? null
                : ((a > n || n != n) && (n = a),
                  (o < i || i != i) && (i = o),
                  i < 0 ? null : this.at(n >= 0 ? n : i, t)))
        );
      }
      intersectsBox(e) {
        return null !== this.intersectBox(e, Se);
      }
      intersectTriangle(e, t, n, i, r) {
        Le.subVectors(t, e), Re.subVectors(n, e), Ce.crossVectors(Le, Re);
        let s,
          a = this.direction.dot(Ce);
        if (a > 0) {
          if (i) return null;
          s = 1;
        } else {
          if (!(a < 0)) return null;
          (s = -1), (a = -a);
        }
        Ae.subVectors(this.origin, e);
        const o = s * this.direction.dot(Re.crossVectors(Ae, Re));
        if (o < 0) return null;
        const l = s * this.direction.dot(Le.cross(Ae));
        if (l < 0) return null;
        if (o + l > a) return null;
        const c = -s * Ae.dot(Ce);
        return c < 0 ? null : this.at(c / a, r);
      }
      applyMatrix4(e) {
        return (
          this.origin.applyMatrix4(e),
          this.direction.transformDirection(e),
          this
        );
      }
      equals(e) {
        return (
          e.origin.equals(this.origin) && e.direction.equals(this.direction)
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class Ie {
      constructor() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(e, t, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
        const g = this.elements;
        return (
          (g[0] = e),
          (g[4] = t),
          (g[8] = n),
          (g[12] = i),
          (g[1] = r),
          (g[5] = s),
          (g[9] = a),
          (g[13] = o),
          (g[2] = l),
          (g[6] = c),
          (g[10] = h),
          (g[14] = u),
          (g[3] = d),
          (g[7] = p),
          (g[11] = m),
          (g[15] = f),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new Ie().fromArray(this.elements);
      }
      copy(e) {
        const t = this.elements,
          n = e.elements;
        return (
          (t[0] = n[0]),
          (t[1] = n[1]),
          (t[2] = n[2]),
          (t[3] = n[3]),
          (t[4] = n[4]),
          (t[5] = n[5]),
          (t[6] = n[6]),
          (t[7] = n[7]),
          (t[8] = n[8]),
          (t[9] = n[9]),
          (t[10] = n[10]),
          (t[11] = n[11]),
          (t[12] = n[12]),
          (t[13] = n[13]),
          (t[14] = n[14]),
          (t[15] = n[15]),
          this
        );
      }
      copyPosition(e) {
        const t = this.elements,
          n = e.elements;
        return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
      }
      setFromMatrix3(e) {
        const t = e.elements;
        return (
          this.set(
            t[0],
            t[3],
            t[6],
            0,
            t[1],
            t[4],
            t[7],
            0,
            t[2],
            t[5],
            t[8],
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractBasis(e, t, n) {
        return (
          e.setFromMatrixColumn(this, 0),
          t.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(e, t, n) {
        return (
          this.set(
            e.x,
            t.x,
            n.x,
            0,
            e.y,
            t.y,
            n.y,
            0,
            e.z,
            t.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractRotation(e) {
        const t = this.elements,
          n = e.elements,
          i = 1 / Ne.setFromMatrixColumn(e, 0).length(),
          r = 1 / Ne.setFromMatrixColumn(e, 1).length(),
          s = 1 / Ne.setFromMatrixColumn(e, 2).length();
        return (
          (t[0] = n[0] * i),
          (t[1] = n[1] * i),
          (t[2] = n[2] * i),
          (t[3] = 0),
          (t[4] = n[4] * r),
          (t[5] = n[5] * r),
          (t[6] = n[6] * r),
          (t[7] = 0),
          (t[8] = n[8] * s),
          (t[9] = n[9] * s),
          (t[10] = n[10] * s),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromEuler(e) {
        (e && e.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        const t = this.elements,
          n = e.x,
          i = e.y,
          r = e.z,
          s = Math.cos(n),
          a = Math.sin(n),
          o = Math.cos(i),
          l = Math.sin(i),
          c = Math.cos(r),
          h = Math.sin(r);
        if ("XYZ" === e.order) {
          const e = s * c,
            n = s * h,
            i = a * c,
            r = a * h;
          (t[0] = o * c),
            (t[4] = -o * h),
            (t[8] = l),
            (t[1] = n + i * l),
            (t[5] = e - r * l),
            (t[9] = -a * o),
            (t[2] = r - e * l),
            (t[6] = i + n * l),
            (t[10] = s * o);
        } else if ("YXZ" === e.order) {
          const e = o * c,
            n = o * h,
            i = l * c,
            r = l * h;
          (t[0] = e + r * a),
            (t[4] = i * a - n),
            (t[8] = s * l),
            (t[1] = s * h),
            (t[5] = s * c),
            (t[9] = -a),
            (t[2] = n * a - i),
            (t[6] = r + e * a),
            (t[10] = s * o);
        } else if ("ZXY" === e.order) {
          const e = o * c,
            n = o * h,
            i = l * c,
            r = l * h;
          (t[0] = e - r * a),
            (t[4] = -s * h),
            (t[8] = i + n * a),
            (t[1] = n + i * a),
            (t[5] = s * c),
            (t[9] = r - e * a),
            (t[2] = -s * l),
            (t[6] = a),
            (t[10] = s * o);
        } else if ("ZYX" === e.order) {
          const e = s * c,
            n = s * h,
            i = a * c,
            r = a * h;
          (t[0] = o * c),
            (t[4] = i * l - n),
            (t[8] = e * l + r),
            (t[1] = o * h),
            (t[5] = r * l + e),
            (t[9] = n * l - i),
            (t[2] = -l),
            (t[6] = a * o),
            (t[10] = s * o);
        } else if ("YZX" === e.order) {
          const e = s * o,
            n = s * l,
            i = a * o,
            r = a * l;
          (t[0] = o * c),
            (t[4] = r - e * h),
            (t[8] = i * h + n),
            (t[1] = h),
            (t[5] = s * c),
            (t[9] = -a * c),
            (t[2] = -l * c),
            (t[6] = n * h + i),
            (t[10] = e - r * h);
        } else if ("XZY" === e.order) {
          const e = s * o,
            n = s * l,
            i = a * o,
            r = a * l;
          (t[0] = o * c),
            (t[4] = -h),
            (t[8] = l * c),
            (t[1] = e * h + r),
            (t[5] = s * c),
            (t[9] = n * h - i),
            (t[2] = i * h - n),
            (t[6] = a * c),
            (t[10] = r * h + e);
        }
        return (
          (t[3] = 0),
          (t[7] = 0),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(e) {
        return this.compose(Oe, e, ze);
      }
      lookAt(e, t, n) {
        const i = this.elements;
        return (
          Be.subVectors(e, t),
          0 === Be.lengthSq() && (Be.z = 1),
          Be.normalize(),
          He.crossVectors(n, Be),
          0 === He.lengthSq() &&
            (1 === Math.abs(n.z) ? (Be.x += 1e-4) : (Be.z += 1e-4),
            Be.normalize(),
            He.crossVectors(n, Be)),
          He.normalize(),
          Fe.crossVectors(Be, He),
          (i[0] = He.x),
          (i[4] = Fe.x),
          (i[8] = Be.x),
          (i[1] = He.y),
          (i[5] = Fe.y),
          (i[9] = Be.y),
          (i[2] = He.z),
          (i[6] = Fe.z),
          (i[10] = Be.z),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(e, t))
          : this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const n = e.elements,
          i = t.elements,
          r = this.elements,
          s = n[0],
          a = n[4],
          o = n[8],
          l = n[12],
          c = n[1],
          h = n[5],
          u = n[9],
          d = n[13],
          p = n[2],
          m = n[6],
          f = n[10],
          g = n[14],
          v = n[3],
          x = n[7],
          y = n[11],
          _ = n[15],
          w = i[0],
          b = i[4],
          M = i[8],
          S = i[12],
          T = i[1],
          E = i[5],
          A = i[9],
          L = i[13],
          R = i[2],
          C = i[6],
          P = i[10],
          I = i[14],
          N = i[3],
          D = i[7],
          O = i[11],
          z = i[15];
        return (
          (r[0] = s * w + a * T + o * R + l * N),
          (r[4] = s * b + a * E + o * C + l * D),
          (r[8] = s * M + a * A + o * P + l * O),
          (r[12] = s * S + a * L + o * I + l * z),
          (r[1] = c * w + h * T + u * R + d * N),
          (r[5] = c * b + h * E + u * C + d * D),
          (r[9] = c * M + h * A + u * P + d * O),
          (r[13] = c * S + h * L + u * I + d * z),
          (r[2] = p * w + m * T + f * R + g * N),
          (r[6] = p * b + m * E + f * C + g * D),
          (r[10] = p * M + m * A + f * P + g * O),
          (r[14] = p * S + m * L + f * I + g * z),
          (r[3] = v * w + x * T + y * R + _ * N),
          (r[7] = v * b + x * E + y * C + _ * D),
          (r[11] = v * M + x * A + y * P + _ * O),
          (r[15] = v * S + x * L + y * I + _ * z),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[4] *= e),
          (t[8] *= e),
          (t[12] *= e),
          (t[1] *= e),
          (t[5] *= e),
          (t[9] *= e),
          (t[13] *= e),
          (t[2] *= e),
          (t[6] *= e),
          (t[10] *= e),
          (t[14] *= e),
          (t[3] *= e),
          (t[7] *= e),
          (t[11] *= e),
          (t[15] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          n = e[4],
          i = e[8],
          r = e[12],
          s = e[1],
          a = e[5],
          o = e[9],
          l = e[13],
          c = e[2],
          h = e[6],
          u = e[10],
          d = e[14];
        return (
          e[3] *
            (+r * o * h -
              i * l * h -
              r * a * u +
              n * l * u +
              i * a * d -
              n * o * d) +
          e[7] *
            (+t * o * d -
              t * l * u +
              r * s * u -
              i * s * d +
              i * l * c -
              r * o * c) +
          e[11] *
            (+t * l * h -
              t * a * d -
              r * s * h +
              n * s * d +
              r * a * c -
              n * l * c) +
          e[15] *
            (-i * a * c -
              t * o * h +
              t * a * u +
              i * s * h -
              n * s * u +
              n * o * c)
        );
      }
      transpose() {
        const e = this.elements;
        let t;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      }
      setPosition(e, t, n) {
        const i = this.elements;
        return (
          e.isVector3
            ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
            : ((i[12] = e), (i[13] = t), (i[14] = n)),
          this
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          i = e[2],
          r = e[3],
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          c = e[8],
          h = e[9],
          u = e[10],
          d = e[11],
          p = e[12],
          m = e[13],
          f = e[14],
          g = e[15],
          v =
            h * f * l -
            m * u * l +
            m * o * d -
            a * f * d -
            h * o * g +
            a * u * g,
          x =
            p * u * l -
            c * f * l -
            p * o * d +
            s * f * d +
            c * o * g -
            s * u * g,
          y =
            c * m * l -
            p * h * l +
            p * a * d -
            s * m * d -
            c * a * g +
            s * h * g,
          _ =
            p * h * o -
            c * m * o -
            p * a * u +
            s * m * u +
            c * a * f -
            s * h * f,
          w = t * v + n * x + i * y + r * _;
        if (0 === w)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const b = 1 / w;
        return (
          (e[0] = v * b),
          (e[1] =
            (m * u * r -
              h * f * r -
              m * i * d +
              n * f * d +
              h * i * g -
              n * u * g) *
            b),
          (e[2] =
            (a * f * r -
              m * o * r +
              m * i * l -
              n * f * l -
              a * i * g +
              n * o * g) *
            b),
          (e[3] =
            (h * o * r -
              a * u * r -
              h * i * l +
              n * u * l +
              a * i * d -
              n * o * d) *
            b),
          (e[4] = x * b),
          (e[5] =
            (c * f * r -
              p * u * r +
              p * i * d -
              t * f * d -
              c * i * g +
              t * u * g) *
            b),
          (e[6] =
            (p * o * r -
              s * f * r -
              p * i * l +
              t * f * l +
              s * i * g -
              t * o * g) *
            b),
          (e[7] =
            (s * u * r -
              c * o * r +
              c * i * l -
              t * u * l -
              s * i * d +
              t * o * d) *
            b),
          (e[8] = y * b),
          (e[9] =
            (p * h * r -
              c * m * r -
              p * n * d +
              t * m * d +
              c * n * g -
              t * h * g) *
            b),
          (e[10] =
            (s * m * r -
              p * a * r +
              p * n * l -
              t * m * l -
              s * n * g +
              t * a * g) *
            b),
          (e[11] =
            (c * a * r -
              s * h * r -
              c * n * l +
              t * h * l +
              s * n * d -
              t * a * d) *
            b),
          (e[12] = _ * b),
          (e[13] =
            (c * m * i -
              p * h * i +
              p * n * u -
              t * m * u -
              c * n * f +
              t * h * f) *
            b),
          (e[14] =
            (p * a * i -
              s * m * i -
              p * n * o +
              t * m * o +
              s * n * f -
              t * a * f) *
            b),
          (e[15] =
            (s * h * i -
              c * a * i +
              c * n * o -
              t * h * o -
              s * n * u +
              t * a * u) *
            b),
          this
        );
      }
      scale(e) {
        const t = this.elements,
          n = e.x,
          i = e.y,
          r = e.z;
        return (
          (t[0] *= n),
          (t[4] *= i),
          (t[8] *= r),
          (t[1] *= n),
          (t[5] *= i),
          (t[9] *= r),
          (t[2] *= n),
          (t[6] *= i),
          (t[10] *= r),
          (t[3] *= n),
          (t[7] *= i),
          (t[11] *= r),
          this
        );
      }
      getMaxScaleOnAxis() {
        const e = this.elements,
          t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
          n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
          i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i));
      }
      makeTranslation(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        const n = Math.cos(t),
          i = Math.sin(t),
          r = 1 - n,
          s = e.x,
          a = e.y,
          o = e.z,
          l = r * s,
          c = r * a;
        return (
          this.set(
            l * s + n,
            l * a - i * o,
            l * o + i * a,
            0,
            l * a + i * o,
            c * a + n,
            c * o - i * s,
            0,
            l * o - i * a,
            c * o + i * s,
            r * o * o + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      }
      makeShear(e, t, n) {
        return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, n) {
        const i = this.elements,
          r = t._x,
          s = t._y,
          a = t._z,
          o = t._w,
          l = r + r,
          c = s + s,
          h = a + a,
          u = r * l,
          d = r * c,
          p = r * h,
          m = s * c,
          f = s * h,
          g = a * h,
          v = o * l,
          x = o * c,
          y = o * h,
          _ = n.x,
          w = n.y,
          b = n.z;
        return (
          (i[0] = (1 - (m + g)) * _),
          (i[1] = (d + y) * _),
          (i[2] = (p - x) * _),
          (i[3] = 0),
          (i[4] = (d - y) * w),
          (i[5] = (1 - (u + g)) * w),
          (i[6] = (f + v) * w),
          (i[7] = 0),
          (i[8] = (p + x) * b),
          (i[9] = (f - v) * b),
          (i[10] = (1 - (u + m)) * b),
          (i[11] = 0),
          (i[12] = e.x),
          (i[13] = e.y),
          (i[14] = e.z),
          (i[15] = 1),
          this
        );
      }
      decompose(e, t, n) {
        const i = this.elements;
        let r = Ne.set(i[0], i[1], i[2]).length();
        const s = Ne.set(i[4], i[5], i[6]).length(),
          a = Ne.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
          (e.x = i[12]),
          (e.y = i[13]),
          (e.z = i[14]),
          De.copy(this);
        const o = 1 / r,
          l = 1 / s,
          c = 1 / a;
        return (
          (De.elements[0] *= o),
          (De.elements[1] *= o),
          (De.elements[2] *= o),
          (De.elements[4] *= l),
          (De.elements[5] *= l),
          (De.elements[6] *= l),
          (De.elements[8] *= c),
          (De.elements[9] *= c),
          (De.elements[10] *= c),
          t.setFromRotationMatrix(De),
          (n.x = r),
          (n.y = s),
          (n.z = a),
          this
        );
      }
      makePerspective(e, t, n, i, r, s) {
        void 0 === s &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        const a = this.elements,
          o = (2 * r) / (t - e),
          l = (2 * r) / (n - i),
          c = (t + e) / (t - e),
          h = (n + i) / (n - i),
          u = -(s + r) / (s - r),
          d = (-2 * s * r) / (s - r);
        return (
          (a[0] = o),
          (a[4] = 0),
          (a[8] = c),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = l),
          (a[9] = h),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = u),
          (a[14] = d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      }
      makeOrthographic(e, t, n, i, r, s) {
        const a = this.elements,
          o = 1 / (t - e),
          l = 1 / (n - i),
          c = 1 / (s - r),
          h = (t + e) * o,
          u = (n + i) * l,
          d = (s + r) * c;
        return (
          (a[0] = 2 * o),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -h),
          (a[1] = 0),
          (a[5] = 2 * l),
          (a[9] = 0),
          (a[13] = -u),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = -2 * c),
          (a[14] = -d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          n = e.elements;
        for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.elements;
        return (
          (e[t] = n[0]),
          (e[t + 1] = n[1]),
          (e[t + 2] = n[2]),
          (e[t + 3] = n[3]),
          (e[t + 4] = n[4]),
          (e[t + 5] = n[5]),
          (e[t + 6] = n[6]),
          (e[t + 7] = n[7]),
          (e[t + 8] = n[8]),
          (e[t + 9] = n[9]),
          (e[t + 10] = n[10]),
          (e[t + 11] = n[11]),
          (e[t + 12] = n[12]),
          (e[t + 13] = n[13]),
          (e[t + 14] = n[14]),
          (e[t + 15] = n[15]),
          e
        );
      }
    }
    Ie.prototype.isMatrix4 = !0;
    const Ne = new te(),
      De = new Ie(),
      Oe = new te(0, 0, 0),
      ze = new te(1, 1, 1),
      He = new te(),
      Fe = new te(),
      Be = new te(),
      Ue = new Ie(),
      Ge = new ee();
    class ke {
      constructor(e = 0, t = 0, n = 0, i = ke.DefaultOrder) {
        (this._x = e), (this._y = t), (this._z = n), (this._order = i);
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        (this._order = e), this._onChangeCallback();
      }
      set(e, t, n, i) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = n),
          (this._order = i || this._order),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(e) {
        return (
          (this._x = e._x),
          (this._y = e._y),
          (this._z = e._z),
          (this._order = e._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e, t, n) {
        const i = e.elements,
          r = i[0],
          s = i[4],
          a = i[8],
          o = i[1],
          l = i[5],
          c = i[9],
          h = i[2],
          u = i[6],
          d = i[10];
        switch ((t = t || this._order)) {
          case "XYZ":
            (this._y = Math.asin(F(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                : ((this._x = Math.atan2(u, l)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-F(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                : ((this._y = Math.atan2(-h, r)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(F(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
                : ((this._y = 0), (this._z = Math.atan2(o, r)));
            break;
          case "ZYX":
            (this._y = Math.asin(-F(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
                : ((this._x = 0), (this._z = Math.atan2(-s, l)));
            break;
          case "YZX":
            (this._z = Math.asin(F(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
                : ((this._x = 0), (this._y = Math.atan2(a, d)));
            break;
          case "XZY":
            (this._z = Math.asin(-F(s, -1, 1))),
              Math.abs(s) < 0.9999999
                ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
                : ((this._x = Math.atan2(-c, d)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                t
            );
        }
        return (this._order = t), !1 !== n && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, n) {
        return (
          Ue.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ue, t, n)
        );
      }
      setFromVector3(e, t) {
        return this.set(e.x, e.y, e.z, t || this._order);
      }
      reorder(e) {
        return Ge.setFromEuler(this), this.setFromQuaternion(Ge, e);
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._order === this._order
        );
      }
      fromArray(e) {
        return (
          (this._x = e[0]),
          (this._y = e[1]),
          (this._z = e[2]),
          void 0 !== e[3] && (this._order = e[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._order),
          e
        );
      }
      toVector3(e) {
        return e
          ? e.set(this._x, this._y, this._z)
          : new te(this._x, this._y, this._z);
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
    }
    (ke.prototype.isEuler = !0),
      (ke.DefaultOrder = "XYZ"),
      (ke.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
    class Ve {
      constructor() {
        this.mask = 1;
      }
      set(e) {
        this.mask = (1 << e) | 0;
      }
      enable(e) {
        this.mask |= (1 << e) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(e) {
        this.mask ^= (1 << e) | 0;
      }
      disable(e) {
        this.mask &= ~((1 << e) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(e) {
        return 0 != (this.mask & e.mask);
      }
    }
    let We = 0;
    const je = new te(),
      qe = new ee(),
      Xe = new Ie(),
      Ye = new te(),
      Ze = new te(),
      Je = new te(),
      Ke = new ee(),
      Qe = new te(1, 0, 0),
      $e = new te(0, 1, 0),
      et = new te(0, 0, 1),
      tt = { type: "added" },
      nt = { type: "removed" };
    class it extends I {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: We++ }),
          (this.uuid = H()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = it.DefaultUp.clone());
        const e = new te(),
          t = new ke(),
          n = new ee(),
          i = new te(1, 1, 1);
        t._onChange(function () {
          n.setFromEuler(t, !1);
        }),
          n._onChange(function () {
            t.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: n },
            scale: { configurable: !0, enumerable: !0, value: i },
            modelViewMatrix: { value: new Ie() },
            normalMatrix: { value: new q() },
          }),
          (this.matrix = new Ie()),
          (this.matrixWorld = new Ie()),
          (this.matrixAutoUpdate = it.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new Ve()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
      }
      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        return qe.setFromAxisAngle(e, t), this.quaternion.multiply(qe), this;
      }
      rotateOnWorldAxis(e, t) {
        return qe.setFromAxisAngle(e, t), this.quaternion.premultiply(qe), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(Qe, e);
      }
      rotateY(e) {
        return this.rotateOnAxis($e, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(et, e);
      }
      translateOnAxis(e, t) {
        return (
          je.copy(e).applyQuaternion(this.quaternion),
          this.position.add(je.multiplyScalar(t)),
          this
        );
      }
      translateX(e) {
        return this.translateOnAxis(Qe, e);
      }
      translateY(e) {
        return this.translateOnAxis($e, e);
      }
      translateZ(e) {
        return this.translateOnAxis(et, e);
      }
      localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return e.applyMatrix4(Xe.copy(this.matrixWorld).invert());
      }
      lookAt(e, t, n) {
        e.isVector3 ? Ye.copy(e) : Ye.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
          Ze.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? Xe.lookAt(Ze, Ye, this.up)
            : Xe.lookAt(Ye, Ze, this.up),
          this.quaternion.setFromRotationMatrix(Xe),
          i &&
            (Xe.extractRotation(i.matrixWorld),
            qe.setFromRotationMatrix(Xe),
            this.quaternion.premultiply(qe.invert()));
      }
      add(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return e === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              e
            ),
            this)
          : (e && e.isObject3D
              ? (null !== e.parent && e.parent.remove(e),
                (e.parent = this),
                this.children.push(e),
                e.dispatchEvent(tt))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  e
                ),
            this);
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const t = this.children.indexOf(e);
        return (
          -1 !== t &&
            ((e.parent = null),
            this.children.splice(t, 1),
            e.dispatchEvent(nt)),
          this
        );
      }
      clear() {
        for (let e = 0; e < this.children.length; e++) {
          const t = this.children[e];
          (t.parent = null), t.dispatchEvent(nt);
        }
        return (this.children.length = 0), this;
      }
      attach(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          Xe.copy(this.matrixWorld).invert(),
          null !== e.parent &&
            (e.parent.updateWorldMatrix(!0, !1),
            Xe.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(Xe),
          this.add(e),
          e.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(e) {
        return this.getObjectByProperty("id", e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty("name", e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
          const i = this.children[n].getObjectByProperty(e, t);
          if (void 0 !== i) return i;
        }
      }
      getWorldPosition(e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Object3D: .getWorldPosition() target is now required"
            ),
            (e = new te())),
          this.updateWorldMatrix(!0, !1),
          e.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Object3D: .getWorldQuaternion() target is now required"
            ),
            (e = new ee())),
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Ze, e, Je),
          e
        );
      }
      getWorldScale(e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Object3D: .getWorldScale() target is now required"
            ),
            (e = new te())),
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Ze, Ke, e),
          e
        );
      }
      getWorldDirection(e) {
        void 0 === e &&
          (console.warn(
            "THREE.Object3D: .getWorldDirection() target is now required"
          ),
          (e = new te())),
          this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {}
      traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
      }
      traverseVisible(e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
      }
      traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
      }
      updateWorldMatrix(e, t) {
        const n = this.parent;
        if (
          (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          !0 === t)
        ) {
          const e = this.children;
          for (let t = 0, n = e.length; t < n; t++)
            e[t].updateWorldMatrix(!1, !0);
        }
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e,
          n = {};
        t &&
          ((e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
          }),
          (n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        const i = {};
        function r(t, n) {
          return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          !0 === this.castShadow && (i.castShadow = !0),
          !0 === this.receiveShadow && (i.receiveShadow = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.frustumCulled && (i.frustumCulled = !1),
          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
          "{}" !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          (i.layers = this.layers.mask),
          (i.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((i.type = "InstancedMesh"),
            (i.count = this.count),
            (i.instanceMatrix = this.instanceMatrix.toJSON()),
            null !== this.instanceColor &&
              (i.instanceColor = this.instanceColor.toJSON())),
          this.isMesh || this.isLine || this.isPoints)
        ) {
          i.geometry = r(e.geometries, this.geometry);
          const t = this.geometry.parameters;
          if (void 0 !== t && void 0 !== t.shapes) {
            const n = t.shapes;
            if (Array.isArray(n))
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                r(e.shapes, i);
              }
            else r(e.shapes, n);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((i.bindMode = this.bindMode),
            (i.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton &&
              (r(e.skeletons, this.skeleton),
              (i.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const t = [];
            for (let n = 0, i = this.material.length; n < i; n++)
              t.push(r(e.materials, this.material[n]));
            i.material = t;
          } else i.material = r(e.materials, this.material);
        if (this.children.length > 0) {
          i.children = [];
          for (let t = 0; t < this.children.length; t++)
            i.children.push(this.children[t].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          i.animations = [];
          for (let t = 0; t < this.animations.length; t++) {
            const n = this.animations[t];
            i.animations.push(r(e.animations, n));
          }
        }
        if (t) {
          const t = s(e.geometries),
            i = s(e.materials),
            r = s(e.textures),
            a = s(e.images),
            o = s(e.shapes),
            l = s(e.skeletons),
            c = s(e.animations);
          t.length > 0 && (n.geometries = t),
            i.length > 0 && (n.materials = i),
            r.length > 0 && (n.textures = r),
            a.length > 0 && (n.images = a),
            o.length > 0 && (n.shapes = o),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c);
        }
        return (n.object = i), n;
        function s(e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            delete i.metadata, t.push(i);
          }
          return t;
        }
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t = !0) {
        if (
          ((this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          (this.rotation.order = e.rotation.order),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.layers.mask = e.layers.mask),
          (this.visible = e.visible),
          (this.castShadow = e.castShadow),
          (this.receiveShadow = e.receiveShadow),
          (this.frustumCulled = e.frustumCulled),
          (this.renderOrder = e.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          !0 === t)
        )
          for (let t = 0; t < e.children.length; t++) {
            const n = e.children[t];
            this.add(n.clone());
          }
        return this;
      }
    }
    (it.DefaultUp = new te(0, 1, 0)),
      (it.DefaultMatrixAutoUpdate = !0),
      (it.prototype.isObject3D = !0);
    const rt = new te(),
      st = new te(),
      at = new q();
    class ot {
      constructor(e = new te(1, 0, 0), t = 0) {
        (this.normal = e), (this.constant = t);
      }
      set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
      }
      setComponents(e, t, n, i) {
        return this.normal.set(e, t, n), (this.constant = i), this;
      }
      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
      }
      setFromCoplanarPoints(e, t, n) {
        const i = rt.subVectors(n, t).cross(st.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e), this;
      }
      copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
      }
      normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }
      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }
      projectPoint(e, t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .projectPoint() target is now required"
            ),
            (t = new te())),
          t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        );
      }
      intersectLine(e, t) {
        void 0 === t &&
          (console.warn("THREE.Plane: .intersectLine() target is now required"),
          (t = new te()));
        const n = e.delta(rt),
          i = this.normal.dot(n);
        if (0 === i)
          return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start);
      }
      intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
          n = this.distanceToPoint(e.end);
        return (t < 0 && n > 0) || (n < 0 && t > 0);
      }
      intersectsBox(e) {
        return e.intersectsPlane(this);
      }
      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }
      coplanarPoint(e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Plane: .coplanarPoint() target is now required"
            ),
            (e = new te())),
          e.copy(this.normal).multiplyScalar(-this.constant)
        );
      }
      applyMatrix4(e, t) {
        const n = t || at.getNormalMatrix(e),
          i = this.coplanarPoint(rt).applyMatrix4(e),
          r = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -i.dot(r)), this;
      }
      translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
      }
      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    ot.prototype.isPlane = !0;
    const lt = new te(),
      ct = new te(),
      ht = new te(),
      ut = new te(),
      dt = new te(),
      pt = new te(),
      mt = new te(),
      ft = new te(),
      gt = new te(),
      vt = new te();
    class xt {
      constructor(e = new te(), t = new te(), n = new te()) {
        (this.a = e), (this.b = t), (this.c = n);
      }
      static getNormal(e, t, n, i) {
        void 0 === i &&
          (console.warn("THREE.Triangle: .getNormal() target is now required"),
          (i = new te())),
          i.subVectors(n, t),
          lt.subVectors(e, t),
          i.cross(lt);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
      }
      static getBarycoord(e, t, n, i, r) {
        lt.subVectors(i, t), ct.subVectors(n, t), ht.subVectors(e, t);
        const s = lt.dot(lt),
          a = lt.dot(ct),
          o = lt.dot(ht),
          l = ct.dot(ct),
          c = ct.dot(ht),
          h = s * l - a * a;
        if (
          (void 0 === r &&
            (console.warn(
              "THREE.Triangle: .getBarycoord() target is now required"
            ),
            (r = new te())),
          0 === h)
        )
          return r.set(-2, -1, -1);
        const u = 1 / h,
          d = (l * o - a * c) * u,
          p = (s * c - a * o) * u;
        return r.set(1 - d - p, p, d);
      }
      static containsPoint(e, t, n, i) {
        return (
          this.getBarycoord(e, t, n, i, ut),
          ut.x >= 0 && ut.y >= 0 && ut.x + ut.y <= 1
        );
      }
      static getUV(e, t, n, i, r, s, a, o) {
        return (
          this.getBarycoord(e, t, n, i, ut),
          o.set(0, 0),
          o.addScaledVector(r, ut.x),
          o.addScaledVector(s, ut.y),
          o.addScaledVector(a, ut.z),
          o
        );
      }
      static isFrontFacing(e, t, n, i) {
        return (
          lt.subVectors(n, t), ct.subVectors(e, t), lt.cross(ct).dot(i) < 0
        );
      }
      set(e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
      }
      setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }
      getArea() {
        return (
          lt.subVectors(this.c, this.b),
          ct.subVectors(this.a, this.b),
          0.5 * lt.cross(ct).length()
        );
      }
      getMidpoint(e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Triangle: .getMidpoint() target is now required"
            ),
            (e = new te())),
          e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3)
        );
      }
      getNormal(e) {
        return xt.getNormal(this.a, this.b, this.c, e);
      }
      getPlane(e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Triangle: .getPlane() target is now required"),
            (e = new ot())),
          e.setFromCoplanarPoints(this.a, this.b, this.c)
        );
      }
      getBarycoord(e, t) {
        return xt.getBarycoord(e, this.a, this.b, this.c, t);
      }
      getUV(e, t, n, i, r) {
        return xt.getUV(e, this.a, this.b, this.c, t, n, i, r);
      }
      containsPoint(e) {
        return xt.containsPoint(e, this.a, this.b, this.c);
      }
      isFrontFacing(e) {
        return xt.isFrontFacing(this.a, this.b, this.c, e);
      }
      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }
      closestPointToPoint(e, t) {
        void 0 === t &&
          (console.warn(
            "THREE.Triangle: .closestPointToPoint() target is now required"
          ),
          (t = new te()));
        const n = this.a,
          i = this.b,
          r = this.c;
        let s, a;
        dt.subVectors(i, n), pt.subVectors(r, n), ft.subVectors(e, n);
        const o = dt.dot(ft),
          l = pt.dot(ft);
        if (o <= 0 && l <= 0) return t.copy(n);
        gt.subVectors(e, i);
        const c = dt.dot(gt),
          h = pt.dot(gt);
        if (c >= 0 && h <= c) return t.copy(i);
        const u = o * h - c * l;
        if (u <= 0 && o >= 0 && c <= 0)
          return (s = o / (o - c)), t.copy(n).addScaledVector(dt, s);
        vt.subVectors(e, r);
        const d = dt.dot(vt),
          p = pt.dot(vt);
        if (p >= 0 && d <= p) return t.copy(r);
        const m = d * l - o * p;
        if (m <= 0 && l >= 0 && p <= 0)
          return (a = l / (l - p)), t.copy(n).addScaledVector(pt, a);
        const f = c * p - d * h;
        if (f <= 0 && h - c >= 0 && d - p >= 0)
          return (
            mt.subVectors(r, i),
            (a = (h - c) / (h - c + (d - p))),
            t.copy(i).addScaledVector(mt, a)
          );
        const g = 1 / (f + m + u);
        return (
          (s = m * g),
          (a = u * g),
          t.copy(n).addScaledVector(dt, s).addScaledVector(pt, a)
        );
      }
      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }
    }
    let yt = 0;
    function _t() {
      Object.defineProperty(this, "id", { value: yt++ }),
        (this.uuid = H()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.blending = 1),
        (this.side = 0),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = n),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = L),
        (this.stencilZFail = L),
        (this.stencilZPass = L),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaTest = 0),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0);
    }
    (_t.prototype = Object.assign(Object.create(I.prototype), {
      constructor: _t,
      isMaterial: !0,
      onBuild: function () {},
      onBeforeCompile: function () {},
      customProgramCacheKey: function () {
        return this.onBeforeCompile.toString();
      },
      setValues: function (e) {
        if (void 0 !== e)
          for (const t in e) {
            const n = e[t];
            if (void 0 === n) {
              console.warn(
                "THREE.Material: '" + t + "' parameter is undefined."
              );
              continue;
            }
            if ("shading" === t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = 1 === n);
              continue;
            }
            const i = this[t];
            void 0 !== i
              ? i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n)
              : console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
          }
      },
      toJSON: function (e) {
        const t = void 0 === e || "string" == typeof e;
        t && (e = { textures: {}, images: {} });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function i(e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            delete i.metadata, t.push(i);
          }
          return t;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (n.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(e).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(e).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(e).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((n.lightMap = this.lightMap.toJSON(e).uuid),
            (n.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(e).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(e).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(e).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(e).uuid),
            void 0 !== this.combine && (n.combine = this.combine)),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio &&
            (n.refractionRatio = this.refractionRatio),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(e).uuid),
          void 0 !== this.size && (n.size = this.size),
          null !== this.shadowSide && (n.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (n.blending = this.blending),
          0 !== this.side && (n.side = this.side),
          this.vertexColors && (n.vertexColors = !0),
          this.opacity < 1 && (n.opacity = this.opacity),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.colorWrite = this.colorWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.alphaToCoverage &&
            (n.alphaToCoverage = this.alphaToCoverage),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.morphTargets && (n.morphTargets = !0),
          !0 === this.morphNormals && (n.morphNormals = !0),
          !0 === this.skinning && (n.skinning = !0),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          t)
        ) {
          const t = i(e.textures),
            r = i(e.images);
          t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
        }
        return n;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (e) {
        (this.name = e.name),
          (this.fog = e.fog),
          (this.blending = e.blending),
          (this.side = e.side),
          (this.vertexColors = e.vertexColors),
          (this.opacity = e.opacity),
          (this.transparent = e.transparent),
          (this.blendSrc = e.blendSrc),
          (this.blendDst = e.blendDst),
          (this.blendEquation = e.blendEquation),
          (this.blendSrcAlpha = e.blendSrcAlpha),
          (this.blendDstAlpha = e.blendDstAlpha),
          (this.blendEquationAlpha = e.blendEquationAlpha),
          (this.depthFunc = e.depthFunc),
          (this.depthTest = e.depthTest),
          (this.depthWrite = e.depthWrite),
          (this.stencilWriteMask = e.stencilWriteMask),
          (this.stencilFunc = e.stencilFunc),
          (this.stencilRef = e.stencilRef),
          (this.stencilFuncMask = e.stencilFuncMask),
          (this.stencilFail = e.stencilFail),
          (this.stencilZFail = e.stencilZFail),
          (this.stencilZPass = e.stencilZPass),
          (this.stencilWrite = e.stencilWrite);
        const t = e.clippingPlanes;
        let n = null;
        if (null !== t) {
          const e = t.length;
          n = new Array(e);
          for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = e.clipIntersection),
          (this.clipShadows = e.clipShadows),
          (this.shadowSide = e.shadowSide),
          (this.colorWrite = e.colorWrite),
          (this.precision = e.precision),
          (this.polygonOffset = e.polygonOffset),
          (this.polygonOffsetFactor = e.polygonOffsetFactor),
          (this.polygonOffsetUnits = e.polygonOffsetUnits),
          (this.dithering = e.dithering),
          (this.alphaTest = e.alphaTest),
          (this.alphaToCoverage = e.alphaToCoverage),
          (this.premultipliedAlpha = e.premultipliedAlpha),
          (this.visible = e.visible),
          (this.toneMapped = e.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    })),
      Object.defineProperty(_t.prototype, "needsUpdate", {
        set: function (e) {
          !0 === e && this.version++;
        },
      });
    const wt = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      bt = { h: 0, s: 0, l: 0 },
      Mt = { h: 0, s: 0, l: 0 };
    function St(e, t, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? e + 6 * (t - e) * n
          : n < 0.5
          ? t
          : n < 2 / 3
          ? e + 6 * (t - e) * (2 / 3 - n)
          : e
      );
    }
    function Tt(e) {
      return e < 0.04045
        ? 0.0773993808 * e
        : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
    }
    function Et(e) {
      return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
    }
    class At {
      constructor(e, t, n) {
        return void 0 === t && void 0 === n
          ? this.set(e)
          : this.setRGB(e, t, n);
      }
      set(e) {
        return (
          e && e.isColor
            ? this.copy(e)
            : "number" == typeof e
            ? this.setHex(e)
            : "string" == typeof e && this.setStyle(e),
          this
        );
      }
      setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
      }
      setHex(e) {
        return (
          (e = Math.floor(e)),
          (this.r = ((e >> 16) & 255) / 255),
          (this.g = ((e >> 8) & 255) / 255),
          (this.b = (255 & e) / 255),
          this
        );
      }
      setRGB(e, t, n) {
        return (this.r = e), (this.g = t), (this.b = n), this;
      }
      setHSL(e, t, n) {
        if (((e = B(e, 1)), (t = F(t, 0, 1)), (n = F(n, 0, 1)), 0 === t))
          this.r = this.g = this.b = n;
        else {
          const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
            r = 2 * n - i;
          (this.r = St(r, i, e + 1 / 3)),
            (this.g = St(r, i, e)),
            (this.b = St(r, i, e - 1 / 3));
        }
        return this;
      }
      setStyle(e) {
        function t(t) {
          void 0 !== t &&
            parseFloat(t) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + e + " will be ignored."
            );
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
          let e;
          const i = n[1],
            r = n[2];
          switch (i) {
            case "rgb":
            case "rgba":
              if (
                (e =
                  /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                  t(e[4]),
                  this
                );
              if (
                (e =
                  /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                  t(e[4]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (e =
                  /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              ) {
                const n = parseFloat(e[1]) / 360,
                  i = parseInt(e[2], 10) / 100,
                  r = parseInt(e[3], 10) / 100;
                return t(e[4]), this.setHSL(n, i, r);
              }
          }
        } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
          const e = n[1],
            t = e.length;
          if (3 === t)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
              (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
              (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
              this
            );
          if (6 === t)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
              (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
              (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
              this
            );
        }
        return e && e.length > 0 ? this.setColorName(e) : this;
      }
      setColorName(e) {
        const t = wt[e.toLowerCase()];
        return (
          void 0 !== t
            ? this.setHex(t)
            : console.warn("THREE.Color: Unknown color " + e),
          this
        );
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
      }
      copyGammaToLinear(e, t = 2) {
        return (
          (this.r = Math.pow(e.r, t)),
          (this.g = Math.pow(e.g, t)),
          (this.b = Math.pow(e.b, t)),
          this
        );
      }
      copyLinearToGamma(e, t = 2) {
        const n = t > 0 ? 1 / t : 1;
        return (
          (this.r = Math.pow(e.r, n)),
          (this.g = Math.pow(e.g, n)),
          (this.b = Math.pow(e.b, n)),
          this
        );
      }
      convertGammaToLinear(e) {
        return this.copyGammaToLinear(this, e), this;
      }
      convertLinearToGamma(e) {
        return this.copyLinearToGamma(this, e), this;
      }
      copySRGBToLinear(e) {
        return (this.r = Tt(e.r)), (this.g = Tt(e.g)), (this.b = Tt(e.b)), this;
      }
      copyLinearToSRGB(e) {
        return (this.r = Et(e.r)), (this.g = Et(e.g)), (this.b = Et(e.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(e) {
        void 0 === e &&
          (console.warn("THREE.Color: .getHSL() target is now required"),
          (e = { h: 0, s: 0, l: 0 }));
        const t = this.r,
          n = this.g,
          i = this.b,
          r = Math.max(t, n, i),
          s = Math.min(t, n, i);
        let a, o;
        const l = (s + r) / 2;
        if (s === r) (a = 0), (o = 0);
        else {
          const e = r - s;
          switch (((o = l <= 0.5 ? e / (r + s) : e / (2 - r - s)), r)) {
            case t:
              a = (n - i) / e + (n < i ? 6 : 0);
              break;
            case n:
              a = (i - t) / e + 2;
              break;
            case i:
              a = (t - n) / e + 4;
          }
          a /= 6;
        }
        return (e.h = a), (e.s = o), (e.l = l), e;
      }
      getStyle() {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      }
      offsetHSL(e, t, n) {
        return (
          this.getHSL(bt),
          (bt.h += e),
          (bt.s += t),
          (bt.l += n),
          this.setHSL(bt.h, bt.s, bt.l),
          this
        );
      }
      add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
      }
      addColors(e, t) {
        return (
          (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
        );
      }
      addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
      }
      sub(e) {
        return (
          (this.r = Math.max(0, this.r - e.r)),
          (this.g = Math.max(0, this.g - e.g)),
          (this.b = Math.max(0, this.b - e.b)),
          this
        );
      }
      multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
      }
      multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
      }
      lerp(e, t) {
        return (
          (this.r += (e.r - this.r) * t),
          (this.g += (e.g - this.g) * t),
          (this.b += (e.b - this.b) * t),
          this
        );
      }
      lerpColors(e, t, n) {
        return (
          (this.r = e.r + (t.r - e.r) * n),
          (this.g = e.g + (t.g - e.g) * n),
          (this.b = e.b + (t.b - e.b) * n),
          this
        );
      }
      lerpHSL(e, t) {
        this.getHSL(bt), e.getHSL(Mt);
        const n = U(bt.h, Mt.h, t),
          i = U(bt.s, Mt.s, t),
          r = U(bt.l, Mt.l, t);
        return this.setHSL(n, i, r), this;
      }
      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }
      fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
      }
      fromBufferAttribute(e, t) {
        return (
          (this.r = e.getX(t)),
          (this.g = e.getY(t)),
          (this.b = e.getZ(t)),
          !0 === e.normalized &&
            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      }
      toJSON() {
        return this.getHex();
      }
    }
    (At.NAMES = wt),
      (At.prototype.isColor = !0),
      (At.prototype.r = 1),
      (At.prototype.g = 1),
      (At.prototype.b = 1);
    class Lt extends _t {
      constructor(e) {
        super(),
          (this.type = "MeshBasicMaterial"),
          (this.color = new At(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          this
        );
      }
    }
    Lt.prototype.isMeshBasicMaterial = !0;
    const Rt = new te(),
      Ct = new j();
    class Pt {
      constructor(e, t, n) {
        if (Array.isArray(e))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === n),
          (this.usage = R),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.onUploadCallback = function () {});
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.array = new e.array.constructor(e.array)),
          (this.itemSize = e.itemSize),
          (this.count = e.count),
          (this.normalized = e.normalized),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, n) {
        (e *= this.itemSize), (n *= t.itemSize);
        for (let i = 0, r = this.itemSize; i < r; i++)
          this.array[e + i] = t.array[n + i];
        return this;
      }
      copyArray(e) {
        return this.array.set(e), this;
      }
      copyColorsArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              i
            ),
            (r = new At())),
            (t[n++] = r.r),
            (t[n++] = r.g),
            (t[n++] = r.b);
        }
        return this;
      }
      copyVector2sArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              i
            ),
            (r = new j())),
            (t[n++] = r.x),
            (t[n++] = r.y);
        }
        return this;
      }
      copyVector3sArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              i
            ),
            (r = new te())),
            (t[n++] = r.x),
            (t[n++] = r.y),
            (t[n++] = r.z);
        }
        return this;
      }
      copyVector4sArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              i
            ),
            (r = new Q())),
            (t[n++] = r.x),
            (t[n++] = r.y),
            (t[n++] = r.z),
            (t[n++] = r.w);
        }
        return this;
      }
      applyMatrix3(e) {
        if (2 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            Ct.fromBufferAttribute(this, t),
              Ct.applyMatrix3(e),
              this.setXY(t, Ct.x, Ct.y);
        else if (3 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            Rt.fromBufferAttribute(this, t),
              Rt.applyMatrix3(e),
              this.setXYZ(t, Rt.x, Rt.y, Rt.z);
        return this;
      }
      applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Rt.x = this.getX(t)),
            (Rt.y = this.getY(t)),
            (Rt.z = this.getZ(t)),
            Rt.applyMatrix4(e),
            this.setXYZ(t, Rt.x, Rt.y, Rt.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Rt.x = this.getX(t)),
            (Rt.y = this.getY(t)),
            (Rt.z = this.getZ(t)),
            Rt.applyNormalMatrix(e),
            this.setXYZ(t, Rt.x, Rt.y, Rt.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Rt.x = this.getX(t)),
            (Rt.y = this.getY(t)),
            (Rt.z = this.getZ(t)),
            Rt.transformDirection(e),
            this.setXYZ(t, Rt.x, Rt.y, Rt.z);
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      getX(e) {
        return this.array[e * this.itemSize];
      }
      setX(e, t) {
        return (this.array[e * this.itemSize] = t), this;
      }
      getY(e) {
        return this.array[e * this.itemSize + 1];
      }
      setY(e, t) {
        return (this.array[e * this.itemSize + 1] = t), this;
      }
      getZ(e) {
        return this.array[e * this.itemSize + 2];
      }
      setZ(e, t) {
        return (this.array[e * this.itemSize + 2] = t), this;
      }
      getW(e) {
        return this.array[e * this.itemSize + 3];
      }
      setW(e, t) {
        return (this.array[e * this.itemSize + 3] = t), this;
      }
      setXY(e, t, n) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          this
        );
      }
      setXYZ(e, t, n, i) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = i),
          this
        );
      }
      setXYZW(e, t, n, i, r) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = i),
          (this.array[e + 3] = r),
          this
        );
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized,
        };
        return (
          "" !== this.name && (e.name = this.name),
          this.usage !== R && (e.usage = this.usage),
          (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
            (e.updateRange = this.updateRange),
          e
        );
      }
    }
    Pt.prototype.isBufferAttribute = !0;
    class It extends Pt {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }
    }
    class Nt extends Pt {
      constructor(e, t, n) {
        super(new Uint32Array(e), t, n);
      }
    }
    (class extends Pt {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }
    }.prototype.isFloat16BufferAttribute = !0);
    class Dt extends Pt {
      constructor(e, t, n) {
        super(new Float32Array(e), t, n);
      }
    }
    function Ot(e) {
      if (0 === e.length) return -1 / 0;
      let t = e[0];
      for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
      return t;
    }
    Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array;
    let zt = 0;
    const Ht = new Ie(),
      Ft = new it(),
      Bt = new te(),
      Ut = new re(),
      Gt = new re(),
      kt = new te();
    class Vt extends I {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: zt++ }),
          (this.uuid = H()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(e) {
        return (
          Array.isArray(e)
            ? (this.index = new (Ot(e) > 65535 ? Nt : It)(e, 1))
            : (this.index = e),
          this
        );
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      setAttribute(e, t) {
        return (this.attributes[e] = t), this;
      }
      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }
      hasAttribute(e) {
        return void 0 !== this.attributes[e];
      }
      addGroup(e, t, n = 0) {
        this.groups.push({ start: e, count: t, materialIndex: n });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
      }
      applyMatrix4(e) {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const t = new q().getNormalMatrix(e);
          n.applyNormalMatrix(t), (n.needsUpdate = !0);
        }
        const i = this.attributes.tangent;
        return (
          void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      rotateX(e) {
        return Ht.makeRotationX(e), this.applyMatrix4(Ht), this;
      }
      rotateY(e) {
        return Ht.makeRotationY(e), this.applyMatrix4(Ht), this;
      }
      rotateZ(e) {
        return Ht.makeRotationZ(e), this.applyMatrix4(Ht), this;
      }
      translate(e, t, n) {
        return Ht.makeTranslation(e, t, n), this.applyMatrix4(Ht), this;
      }
      scale(e, t, n) {
        return Ht.makeScale(e, t, n), this.applyMatrix4(Ht), this;
      }
      lookAt(e) {
        return (
          Ft.lookAt(e), Ft.updateMatrix(), this.applyMatrix4(Ft.matrix), this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Bt).negate(),
          this.translate(Bt.x, Bt.y, Bt.z),
          this
        );
      }
      setFromPoints(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; n++) {
          const i = e[n];
          t.push(i.x, i.y, i.z || 0);
        }
        return this.setAttribute("position", new Dt(t, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new re());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingBox.set(
              new te(-1 / 0, -1 / 0, -1 / 0),
              new te(1 / 0, 1 / 0, 1 / 0)
            )
          );
        if (void 0 !== e) {
          if ((this.boundingBox.setFromBufferAttribute(e), t))
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              Ut.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (kt.addVectors(this.boundingBox.min, Ut.min),
                    this.boundingBox.expandByPoint(kt),
                    kt.addVectors(this.boundingBox.max, Ut.max),
                    this.boundingBox.expandByPoint(kt))
                  : (this.boundingBox.expandByPoint(Ut.min),
                    this.boundingBox.expandByPoint(Ut.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Me());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingSphere.set(new te(), 1 / 0)
          );
        if (e) {
          const n = this.boundingSphere.center;
          if ((Ut.setFromBufferAttribute(e), t))
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              Gt.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (kt.addVectors(Ut.min, Gt.min),
                    Ut.expandByPoint(kt),
                    kt.addVectors(Ut.max, Gt.max),
                    Ut.expandByPoint(kt))
                  : (Ut.expandByPoint(Gt.min), Ut.expandByPoint(Gt.max));
            }
          Ut.getCenter(n);
          let i = 0;
          for (let t = 0, r = e.count; t < r; t++)
            kt.fromBufferAttribute(e, t),
              (i = Math.max(i, n.distanceToSquared(kt)));
          if (t)
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r],
                a = this.morphTargetsRelative;
              for (let t = 0, r = s.count; t < r; t++)
                kt.fromBufferAttribute(s, t),
                  a && (Bt.fromBufferAttribute(e, t), kt.add(Bt)),
                  (i = Math.max(i, n.distanceToSquared(kt)));
            }
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }
      computeFaceNormals() {}
      computeTangents() {
        const e = this.index,
          t = this.attributes;
        if (
          null === e ||
          void 0 === t.position ||
          void 0 === t.normal ||
          void 0 === t.uv
        )
          return void console.error(
            "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
          );
        const n = e.array,
          i = t.position.array,
          r = t.normal.array,
          s = t.uv.array,
          a = i.length / 3;
        void 0 === t.tangent &&
          this.setAttribute("tangent", new Pt(new Float32Array(4 * a), 4));
        const o = t.tangent.array,
          l = [],
          c = [];
        for (let e = 0; e < a; e++) (l[e] = new te()), (c[e] = new te());
        const h = new te(),
          u = new te(),
          d = new te(),
          p = new j(),
          m = new j(),
          f = new j(),
          g = new te(),
          v = new te();
        function x(e, t, n) {
          h.fromArray(i, 3 * e),
            u.fromArray(i, 3 * t),
            d.fromArray(i, 3 * n),
            p.fromArray(s, 2 * e),
            m.fromArray(s, 2 * t),
            f.fromArray(s, 2 * n),
            u.sub(h),
            d.sub(h),
            m.sub(p),
            f.sub(p);
          const r = 1 / (m.x * f.y - f.x * m.y);
          isFinite(r) &&
            (g
              .copy(u)
              .multiplyScalar(f.y)
              .addScaledVector(d, -m.y)
              .multiplyScalar(r),
            v
              .copy(d)
              .multiplyScalar(m.x)
              .addScaledVector(u, -f.x)
              .multiplyScalar(r),
            l[e].add(g),
            l[t].add(g),
            l[n].add(g),
            c[e].add(v),
            c[t].add(v),
            c[n].add(v));
        }
        let y = this.groups;
        0 === y.length && (y = [{ start: 0, count: n.length }]);
        for (let e = 0, t = y.length; e < t; ++e) {
          const t = y[e],
            i = t.start;
          for (let e = i, r = i + t.count; e < r; e += 3)
            x(n[e + 0], n[e + 1], n[e + 2]);
        }
        const _ = new te(),
          w = new te(),
          b = new te(),
          M = new te();
        function S(e) {
          b.fromArray(r, 3 * e), M.copy(b);
          const t = l[e];
          _.copy(t),
            _.sub(b.multiplyScalar(b.dot(t))).normalize(),
            w.crossVectors(M, t);
          const n = w.dot(c[e]) < 0 ? -1 : 1;
          (o[4 * e] = _.x),
            (o[4 * e + 1] = _.y),
            (o[4 * e + 2] = _.z),
            (o[4 * e + 3] = n);
        }
        for (let e = 0, t = y.length; e < t; ++e) {
          const t = y[e],
            i = t.start;
          for (let e = i, r = i + t.count; e < r; e += 3)
            S(n[e + 0]), S(n[e + 1]), S(n[e + 2]);
        }
      }
      computeVertexNormals() {
        const e = this.index,
          t = this.getAttribute("position");
        if (void 0 !== t) {
          let n = this.getAttribute("normal");
          if (void 0 === n)
            (n = new Pt(new Float32Array(3 * t.count), 3)),
              this.setAttribute("normal", n);
          else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
          const i = new te(),
            r = new te(),
            s = new te(),
            a = new te(),
            o = new te(),
            l = new te(),
            c = new te(),
            h = new te();
          if (e)
            for (let u = 0, d = e.count; u < d; u += 3) {
              const d = e.getX(u + 0),
                p = e.getX(u + 1),
                m = e.getX(u + 2);
              i.fromBufferAttribute(t, d),
                r.fromBufferAttribute(t, p),
                s.fromBufferAttribute(t, m),
                c.subVectors(s, r),
                h.subVectors(i, r),
                c.cross(h),
                a.fromBufferAttribute(n, d),
                o.fromBufferAttribute(n, p),
                l.fromBufferAttribute(n, m),
                a.add(c),
                o.add(c),
                l.add(c),
                n.setXYZ(d, a.x, a.y, a.z),
                n.setXYZ(p, o.x, o.y, o.z),
                n.setXYZ(m, l.x, l.y, l.z);
            }
          else
            for (let e = 0, a = t.count; e < a; e += 3)
              i.fromBufferAttribute(t, e + 0),
                r.fromBufferAttribute(t, e + 1),
                s.fromBufferAttribute(t, e + 2),
                c.subVectors(s, r),
                h.subVectors(i, r),
                c.cross(h),
                n.setXYZ(e + 0, c.x, c.y, c.z),
                n.setXYZ(e + 1, c.x, c.y, c.z),
                n.setXYZ(e + 2, c.x, c.y, c.z);
          this.normalizeNormals(), (n.needsUpdate = !0);
        }
      }
      merge(e, t) {
        if (!e || !e.isBufferGeometry)
          return void console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            e
          );
        void 0 === t &&
          ((t = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
          ));
        const n = this.attributes;
        for (const i in n) {
          if (void 0 === e.attributes[i]) continue;
          const r = n[i].array,
            s = e.attributes[i],
            a = s.array,
            o = s.itemSize * t,
            l = Math.min(a.length, r.length - o);
          for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e];
        }
        return this;
      }
      normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
          kt.fromBufferAttribute(e, t),
            kt.normalize(),
            e.setXYZ(t, kt.x, kt.y, kt.z);
      }
      toNonIndexed() {
        function e(e, t) {
          const n = e.array,
            i = e.itemSize,
            r = e.normalized,
            s = new n.constructor(t.length * i);
          let a = 0,
            o = 0;
          for (let e = 0, r = t.length; e < r; e++) {
            a = t[e] * i;
            for (let e = 0; e < i; e++) s[o++] = n[a++];
          }
          return new Pt(s, i, r);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
            ),
            this
          );
        const t = new Vt(),
          n = this.index.array,
          i = this.attributes;
        for (const r in i) {
          const s = e(i[r], n);
          t.setAttribute(r, s);
        }
        const r = this.morphAttributes;
        for (const i in r) {
          const s = [],
            a = r[i];
          for (let t = 0, i = a.length; t < i; t++) {
            const i = e(a[t], n);
            s.push(i);
          }
          t.morphAttributes[i] = s;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e];
          t.addGroup(n.start, n.count, n.materialIndex);
        }
        return t;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((e.uuid = this.uuid),
          (e.type = this.type),
          "" !== this.name && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const t = this.parameters;
          for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
          return e;
        }
        e.data = { attributes: {} };
        const t = this.index;
        null !== t &&
          (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array),
          });
        const n = this.attributes;
        for (const t in n) {
          const i = n[t];
          e.data.attributes[t] = i.toJSON(e.data);
        }
        const i = {};
        let r = !1;
        for (const t in this.morphAttributes) {
          const n = this.morphAttributes[t],
            s = [];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            s.push(i.toJSON(e.data));
          }
          s.length > 0 && ((i[t] = s), (r = !0));
        }
        r &&
          ((e.data.morphAttributes = i),
          (e.data.morphTargetsRelative = this.morphTargetsRelative));
        const s = this.groups;
        s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
        const a = this.boundingSphere;
        return (
          null !== a &&
            (e.data.boundingSphere = {
              center: a.center.toArray(),
              radius: a.radius,
            }),
          e
        );
      }
      clone() {
        return new Vt().copy(this);
      }
      copy(e) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const t = {};
        this.name = e.name;
        const n = e.index;
        null !== n && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const e in i) {
          const n = i[e];
          this.setAttribute(e, n.clone(t));
        }
        const r = e.morphAttributes;
        for (const e in r) {
          const n = [],
            i = r[e];
          for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
          this.morphAttributes[e] = n;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const s = e.groups;
        for (let e = 0, t = s.length; e < t; e++) {
          const t = s[e];
          this.addGroup(t.start, t.count, t.materialIndex);
        }
        const a = e.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const o = e.boundingSphere;
        return (
          null !== o && (this.boundingSphere = o.clone()),
          (this.drawRange.start = e.drawRange.start),
          (this.drawRange.count = e.drawRange.count),
          (this.userData = e.userData),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    Vt.prototype.isBufferGeometry = !0;
    const Wt = new Ie(),
      jt = new Pe(),
      qt = new Me(),
      Xt = new te(),
      Yt = new te(),
      Zt = new te(),
      Jt = new te(),
      Kt = new te(),
      Qt = new te(),
      $t = new te(),
      en = new te(),
      tn = new te(),
      nn = new j(),
      rn = new j(),
      sn = new j(),
      an = new te(),
      on = new te();
    class ln extends it {
      constructor(e = new Vt(), t = new Lt()) {
        super(),
          (this.type = "Mesh"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          void 0 !== e.morphTargetInfluences &&
            (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
          void 0 !== e.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              e.morphTargetDictionary
            )),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
      raycast(e, t) {
        const n = this.geometry,
          i = this.material,
          r = this.matrixWorld;
        if (void 0 === i) return;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          qt.copy(n.boundingSphere),
          qt.applyMatrix4(r),
          !1 === e.ray.intersectsSphere(qt))
        )
          return;
        if (
          (Wt.copy(r).invert(),
          jt.copy(e.ray).applyMatrix4(Wt),
          null !== n.boundingBox && !1 === jt.intersectsBox(n.boundingBox))
        )
          return;
        let s;
        if (n.isBufferGeometry) {
          const r = n.index,
            a = n.attributes.position,
            o = n.morphAttributes.position,
            l = n.morphTargetsRelative,
            c = n.attributes.uv,
            h = n.attributes.uv2,
            u = n.groups,
            d = n.drawRange;
          if (null !== r)
            if (Array.isArray(i))
              for (let n = 0, p = u.length; n < p; n++) {
                const p = u[n],
                  m = i[p.materialIndex];
                for (
                  let n = Math.max(p.start, d.start),
                    i = Math.min(p.start + p.count, d.start + d.count);
                  n < i;
                  n += 3
                ) {
                  const i = r.getX(n),
                    u = r.getX(n + 1),
                    d = r.getX(n + 2);
                  (s = cn(this, m, e, jt, a, o, l, c, h, i, u, d)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = p.materialIndex),
                      t.push(s));
                }
              }
            else
              for (
                let n = Math.max(0, d.start),
                  u = Math.min(r.count, d.start + d.count);
                n < u;
                n += 3
              ) {
                const u = r.getX(n),
                  d = r.getX(n + 1),
                  p = r.getX(n + 2);
                (s = cn(this, i, e, jt, a, o, l, c, h, u, d, p)),
                  s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
              }
          else if (void 0 !== a)
            if (Array.isArray(i))
              for (let n = 0, r = u.length; n < r; n++) {
                const r = u[n],
                  p = i[r.materialIndex];
                for (
                  let n = Math.max(r.start, d.start),
                    i = Math.min(r.start + r.count, d.start + d.count);
                  n < i;
                  n += 3
                )
                  (s = cn(this, p, e, jt, a, o, l, c, h, n, n + 1, n + 2)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = r.materialIndex),
                      t.push(s));
              }
            else
              for (
                let n = Math.max(0, d.start),
                  r = Math.min(a.count, d.start + d.count);
                n < r;
                n += 3
              )
                (s = cn(this, i, e, jt, a, o, l, c, h, n, n + 1, n + 2)),
                  s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
        } else
          n.isGeometry &&
            console.error(
              "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
    }
    function cn(e, t, n, i, r, s, a, o, l, c, h, u) {
      Xt.fromBufferAttribute(r, c),
        Yt.fromBufferAttribute(r, h),
        Zt.fromBufferAttribute(r, u);
      const d = e.morphTargetInfluences;
      if (t.morphTargets && s && d) {
        $t.set(0, 0, 0), en.set(0, 0, 0), tn.set(0, 0, 0);
        for (let e = 0, t = s.length; e < t; e++) {
          const t = d[e],
            n = s[e];
          0 !== t &&
            (Jt.fromBufferAttribute(n, c),
            Kt.fromBufferAttribute(n, h),
            Qt.fromBufferAttribute(n, u),
            a
              ? ($t.addScaledVector(Jt, t),
                en.addScaledVector(Kt, t),
                tn.addScaledVector(Qt, t))
              : ($t.addScaledVector(Jt.sub(Xt), t),
                en.addScaledVector(Kt.sub(Yt), t),
                tn.addScaledVector(Qt.sub(Zt), t)));
        }
        Xt.add($t), Yt.add(en), Zt.add(tn);
      }
      e.isSkinnedMesh &&
        t.skinning &&
        (e.boneTransform(c, Xt),
        e.boneTransform(h, Yt),
        e.boneTransform(u, Zt));
      const p = (function (e, t, n, i, r, s, a, o) {
        let l;
        if (
          ((l =
            1 === t.side
              ? i.intersectTriangle(a, s, r, !0, o)
              : i.intersectTriangle(r, s, a, 2 !== t.side, o)),
          null === l)
        )
          return null;
        on.copy(o), on.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(on);
        return c < n.near || c > n.far
          ? null
          : { distance: c, point: on.clone(), object: e };
      })(e, t, n, i, Xt, Yt, Zt, an);
      if (p) {
        o &&
          (nn.fromBufferAttribute(o, c),
          rn.fromBufferAttribute(o, h),
          sn.fromBufferAttribute(o, u),
          (p.uv = xt.getUV(an, Xt, Yt, Zt, nn, rn, sn, new j()))),
          l &&
            (nn.fromBufferAttribute(l, c),
            rn.fromBufferAttribute(l, h),
            sn.fromBufferAttribute(l, u),
            (p.uv2 = xt.getUV(an, Xt, Yt, Zt, nn, rn, sn, new j())));
        const e = { a: c, b: h, c: u, normal: new te(), materialIndex: 0 };
        xt.getNormal(Xt, Yt, Zt, e.normal), (p.face = e);
      }
      return p;
    }
    ln.prototype.isMesh = !0;
    class hn extends Vt {
      constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
        super(),
          (this.type = "BoxGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: s,
          });
        const a = this;
        (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
        const o = [],
          l = [],
          c = [],
          h = [];
        let u = 0,
          d = 0;
        function p(e, t, n, i, r, s, p, m, f, g, v) {
          const x = s / f,
            y = p / g,
            _ = s / 2,
            w = p / 2,
            b = m / 2,
            M = f + 1,
            S = g + 1;
          let T = 0,
            E = 0;
          const A = new te();
          for (let s = 0; s < S; s++) {
            const a = s * y - w;
            for (let o = 0; o < M; o++) {
              const u = o * x - _;
              (A[e] = u * i),
                (A[t] = a * r),
                (A[n] = b),
                l.push(A.x, A.y, A.z),
                (A[e] = 0),
                (A[t] = 0),
                (A[n] = m > 0 ? 1 : -1),
                c.push(A.x, A.y, A.z),
                h.push(o / f),
                h.push(1 - s / g),
                (T += 1);
            }
          }
          for (let e = 0; e < g; e++)
            for (let t = 0; t < f; t++) {
              const n = u + t + M * e,
                i = u + t + M * (e + 1),
                r = u + (t + 1) + M * (e + 1),
                s = u + (t + 1) + M * e;
              o.push(n, i, s), o.push(i, r, s), (E += 6);
            }
          a.addGroup(d, E, v), (d += E), (u += T);
        }
        p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
          p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
          p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
          p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
          p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
          p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
          this.setIndex(o),
          this.setAttribute("position", new Dt(l, 3)),
          this.setAttribute("normal", new Dt(c, 3)),
          this.setAttribute("uv", new Dt(h, 2));
      }
    }
    function un(e) {
      const t = {};
      for (const n in e) {
        t[n] = {};
        for (const i in e[n]) {
          const r = e[n][i];
          r &&
          (r.isColor ||
            r.isMatrix3 ||
            r.isMatrix4 ||
            r.isVector2 ||
            r.isVector3 ||
            r.isVector4 ||
            r.isTexture ||
            r.isQuaternion)
            ? (t[n][i] = r.clone())
            : Array.isArray(r)
            ? (t[n][i] = r.slice())
            : (t[n][i] = r);
        }
      }
      return t;
    }
    function dn(e) {
      const t = {};
      for (let n = 0; n < e.length; n++) {
        const i = un(e[n]);
        for (const e in i) t[e] = i[e];
      }
      return t;
    }
    const pn = { clone: un, merge: dn };
    class mn extends _t {
      constructor(e) {
        super(),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== e &&
            (void 0 !== e.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(e));
      }
      copy(e) {
        return (
          super.copy(e),
          (this.fragmentShader = e.fragmentShader),
          (this.vertexShader = e.vertexShader),
          (this.uniforms = un(e.uniforms)),
          (this.defines = Object.assign({}, e.defines)),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.lights = e.lights),
          (this.clipping = e.clipping),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          (this.extensions = Object.assign({}, e.extensions)),
          (this.glslVersion = e.glslVersion),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (const n in this.uniforms) {
          const i = this.uniforms[n].value;
          i && i.isTexture
            ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
            : i && i.isColor
            ? (t.uniforms[n] = { type: "c", value: i.getHex() })
            : i && i.isVector2
            ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
            : i && i.isVector3
            ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
            : i && i.isVector4
            ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
            : i && i.isMatrix3
            ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
            : i && i.isMatrix4
            ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
            : (t.uniforms[n] = { value: i });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
          (t.vertexShader = this.vertexShader),
          (t.fragmentShader = this.fragmentShader);
        const n = {};
        for (const e in this.extensions)
          !0 === this.extensions[e] && (n[e] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n), t;
      }
    }
    mn.prototype.isShaderMaterial = !0;
    class fn extends it {
      constructor() {
        super(),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new Ie()),
          (this.projectionMatrix = new Ie()),
          (this.projectionMatrixInverse = new Ie());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this
        );
      }
      getWorldDirection(e) {
        void 0 === e &&
          (console.warn(
            "THREE.Camera: .getWorldDirection() target is now required"
          ),
          (e = new te())),
          this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    fn.prototype.isCamera = !0;
    class gn extends fn {
      constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
        super(),
          (this.type = "PerspectiveCamera"),
          (this.fov = e),
          (this.zoom = 1),
          (this.near = n),
          (this.far = i),
          (this.focus = 10),
          (this.aspect = t),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.fov = e.fov),
          (this.zoom = e.zoom),
          (this.near = e.near),
          (this.far = e.far),
          (this.focus = e.focus),
          (this.aspect = e.aspect),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          (this.filmGauge = e.filmGauge),
          (this.filmOffset = e.filmOffset),
          this
        );
      }
      setFocalLength(e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = 2 * z * Math.atan(t)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const e = Math.tan(0.5 * O * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
      }
      getEffectiveFOV() {
        return 2 * z * Math.atan(Math.tan(0.5 * O * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(e, t, n, i, r, s) {
        (this.aspect = e / t),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = this.near;
        let t = (e * Math.tan(0.5 * O * this.fov)) / this.zoom,
          n = 2 * t,
          i = this.aspect * n,
          r = -0.5 * i;
        const s = this.view;
        if (null !== this.view && this.view.enabled) {
          const e = s.fullWidth,
            a = s.fullHeight;
          (r += (s.offsetX * i) / e),
            (t -= (s.offsetY * n) / a),
            (i *= s.width / e),
            (n *= s.height / a);
        }
        const a = this.filmOffset;
        0 !== a && (r += (e * a) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            t,
            t - n,
            e,
            this.far
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      }
    }
    gn.prototype.isPerspectiveCamera = !0;
    const vn = 90;
    class xn extends it {
      constructor(e, t, n) {
        if (
          (super(),
          (this.type = "CubeCamera"),
          !0 !== n.isWebGLCubeRenderTarget)
        )
          return void console.error(
            "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
          );
        this.renderTarget = n;
        const i = new gn(vn, 1, e, t);
        (i.layers = this.layers),
          i.up.set(0, -1, 0),
          i.lookAt(new te(1, 0, 0)),
          this.add(i);
        const r = new gn(vn, 1, e, t);
        (r.layers = this.layers),
          r.up.set(0, -1, 0),
          r.lookAt(new te(-1, 0, 0)),
          this.add(r);
        const s = new gn(vn, 1, e, t);
        (s.layers = this.layers),
          s.up.set(0, 0, 1),
          s.lookAt(new te(0, 1, 0)),
          this.add(s);
        const a = new gn(vn, 1, e, t);
        (a.layers = this.layers),
          a.up.set(0, 0, -1),
          a.lookAt(new te(0, -1, 0)),
          this.add(a);
        const o = new gn(vn, 1, e, t);
        (o.layers = this.layers),
          o.up.set(0, -1, 0),
          o.lookAt(new te(0, 0, 1)),
          this.add(o);
        const l = new gn(vn, 1, e, t);
        (l.layers = this.layers),
          l.up.set(0, -1, 0),
          l.lookAt(new te(0, 0, -1)),
          this.add(l);
      }
      update(e, t) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget,
          [i, r, s, a, o, l] = this.children,
          c = e.xr.enabled,
          h = e.getRenderTarget();
        e.xr.enabled = !1;
        const u = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
          e.setRenderTarget(n, 0),
          e.render(t, i),
          e.setRenderTarget(n, 1),
          e.render(t, r),
          e.setRenderTarget(n, 2),
          e.render(t, s),
          e.setRenderTarget(n, 3),
          e.render(t, a),
          e.setRenderTarget(n, 4),
          e.render(t, o),
          (n.texture.generateMipmaps = u),
          e.setRenderTarget(n, 5),
          e.render(t, l),
          e.setRenderTarget(h),
          (e.xr.enabled = c);
      }
    }
    class yn extends J {
      constructor(e, t, n, i, r, s, a, o, l, c) {
        super(
          (e = void 0 !== e ? e : []),
          (t = void 0 !== t ? t : 301),
          n,
          i,
          r,
          s,
          (a = void 0 !== a ? a : g),
          o,
          l,
          c
        ),
          (this._needsFlipEnvMap = !0),
          (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(e) {
        this.image = e;
      }
    }
    yn.prototype.isCubeTexture = !0;
    class _n extends $ {
      constructor(e, t, n) {
        Number.isInteger(t) &&
          (console.warn(
            "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
          ),
          (t = n)),
          super(e, e, t),
          (t = t || {}),
          (this.texture = new yn(
            void 0,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
          (this.texture.generateMipmaps =
            void 0 !== t.generateMipmaps && t.generateMipmaps),
          (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : c),
          (this.texture._needsFlipEnvMap = !1);
      }
      fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
          (this.texture.format = v),
          (this.texture.encoding = t.encoding),
          (this.texture.generateMipmaps = t.generateMipmaps),
          (this.texture.minFilter = t.minFilter),
          (this.texture.magFilter = t.magFilter);
        const n = { tEquirect: { value: null } },
          i =
            "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
          r =
            "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
          s = new hn(5, 5, 5),
          a = new mn({
            name: "CubemapFromEquirect",
            uniforms: un(n),
            vertexShader: i,
            fragmentShader: r,
            side: 1,
            blending: 0,
          });
        a.uniforms.tEquirect.value = t;
        const o = new ln(s, a),
          l = t.minFilter;
        return (
          t.minFilter === h && (t.minFilter = c),
          new xn(1, 10, this).update(e, o),
          (t.minFilter = l),
          o.geometry.dispose(),
          o.material.dispose(),
          this
        );
      }
      clear(e, t, n, i) {
        const r = e.getRenderTarget();
        for (let r = 0; r < 6; r++)
          e.setRenderTarget(this, r), e.clear(t, n, i);
        e.setRenderTarget(r);
      }
    }
    _n.prototype.isWebGLCubeRenderTarget = !0;
    class wn extends J {
      constructor(e, t, n, i, r, s, o, l, c, h, u, d) {
        super(null, s, o, l, c, h, i, r, u, d),
          (this.image = { data: e || null, width: t || 1, height: n || 1 }),
          (this.magFilter = void 0 !== c ? c : a),
          (this.minFilter = void 0 !== h ? h : a),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    wn.prototype.isDataTexture = !0;
    const bn = new Me(),
      Mn = new te();
    class Sn {
      constructor(
        e = new ot(),
        t = new ot(),
        n = new ot(),
        i = new ot(),
        r = new ot(),
        s = new ot()
      ) {
        this.planes = [e, t, n, i, r, s];
      }
      set(e, t, n, i, r, s) {
        const a = this.planes;
        return (
          a[0].copy(e),
          a[1].copy(t),
          a[2].copy(n),
          a[3].copy(i),
          a[4].copy(r),
          a[5].copy(s),
          this
        );
      }
      copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
        return this;
      }
      setFromProjectionMatrix(e) {
        const t = this.planes,
          n = e.elements,
          i = n[0],
          r = n[1],
          s = n[2],
          a = n[3],
          o = n[4],
          l = n[5],
          c = n[6],
          h = n[7],
          u = n[8],
          d = n[9],
          p = n[10],
          m = n[11],
          f = n[12],
          g = n[13],
          v = n[14],
          x = n[15];
        return (
          t[0].setComponents(a - i, h - o, m - u, x - f).normalize(),
          t[1].setComponents(a + i, h + o, m + u, x + f).normalize(),
          t[2].setComponents(a + r, h + l, m + d, x + g).normalize(),
          t[3].setComponents(a - r, h - l, m - d, x - g).normalize(),
          t[4].setComponents(a - s, h - c, m - p, x - v).normalize(),
          t[5].setComponents(a + s, h + c, m + p, x + v).normalize(),
          this
        );
      }
      intersectsObject(e) {
        const t = e.geometry;
        return (
          null === t.boundingSphere && t.computeBoundingSphere(),
          bn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
          this.intersectsSphere(bn)
        );
      }
      intersectsSprite(e) {
        return (
          bn.center.set(0, 0, 0),
          (bn.radius = 0.7071067811865476),
          bn.applyMatrix4(e.matrixWorld),
          this.intersectsSphere(bn)
        );
      }
      intersectsSphere(e) {
        const t = this.planes,
          n = e.center,
          i = -e.radius;
        for (let e = 0; e < 6; e++) if (t[e].distanceToPoint(n) < i) return !1;
        return !0;
      }
      intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
          const i = t[n];
          if (
            ((Mn.x = i.normal.x > 0 ? e.max.x : e.min.x),
            (Mn.y = i.normal.y > 0 ? e.max.y : e.min.y),
            (Mn.z = i.normal.z > 0 ? e.max.z : e.min.z),
            i.distanceToPoint(Mn) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    function Tn() {
      let e = null,
        t = !1,
        n = null,
        i = null;
      function r(t, s) {
        n(t, s), (i = e.requestAnimationFrame(r));
      }
      return {
        start: function () {
          !0 !== t &&
            null !== n &&
            ((i = e.requestAnimationFrame(r)), (t = !0));
        },
        stop: function () {
          e.cancelAnimationFrame(i), (t = !1);
        },
        setAnimationLoop: function (e) {
          n = e;
        },
        setContext: function (t) {
          e = t;
        },
      };
    }
    function En(e, t) {
      const n = t.isWebGL2,
        i = new WeakMap();
      return {
        get: function (e) {
          return e.isInterleavedBufferAttribute && (e = e.data), i.get(e);
        },
        remove: function (t) {
          t.isInterleavedBufferAttribute && (t = t.data);
          const n = i.get(t);
          n && (e.deleteBuffer(n.buffer), i.delete(t));
        },
        update: function (t, r) {
          if (t.isGLBufferAttribute) {
            const e = i.get(t);
            return void (
              (!e || e.version < t.version) &&
              i.set(t, {
                buffer: t.buffer,
                type: t.type,
                bytesPerElement: t.elementSize,
                version: t.version,
              })
            );
          }
          t.isInterleavedBufferAttribute && (t = t.data);
          const s = i.get(t);
          void 0 === s
            ? i.set(
                t,
                (function (t, i) {
                  const r = t.array,
                    s = t.usage,
                    a = e.createBuffer();
                  e.bindBuffer(i, a),
                    e.bufferData(i, r, s),
                    t.onUploadCallback();
                  let o = 5126;
                  return (
                    r instanceof Float32Array
                      ? (o = 5126)
                      : r instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : r instanceof Uint16Array
                      ? t.isFloat16BufferAttribute
                        ? n
                          ? (o = 5131)
                          : console.warn(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                            )
                        : (o = 5123)
                      : r instanceof Int16Array
                      ? (o = 5122)
                      : r instanceof Uint32Array
                      ? (o = 5125)
                      : r instanceof Int32Array
                      ? (o = 5124)
                      : r instanceof Int8Array
                      ? (o = 5120)
                      : r instanceof Uint8Array && (o = 5121),
                    {
                      buffer: a,
                      type: o,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: t.version,
                    }
                  );
                })(t, r)
              )
            : s.version < t.version &&
              ((function (t, i, r) {
                const s = i.array,
                  a = i.updateRange;
                e.bindBuffer(r, t),
                  -1 === a.count
                    ? e.bufferSubData(r, 0, s)
                    : (n
                        ? e.bufferSubData(
                            r,
                            a.offset * s.BYTES_PER_ELEMENT,
                            s,
                            a.offset,
                            a.count
                          )
                        : e.bufferSubData(
                            r,
                            a.offset * s.BYTES_PER_ELEMENT,
                            s.subarray(a.offset, a.offset + a.count)
                          ),
                      (a.count = -1));
              })(s.buffer, t, r),
              (s.version = t.version));
        },
      };
    }
    class An extends Vt {
      constructor(e = 1, t = 1, n = 1, i = 1) {
        super(),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i,
          });
        const r = e / 2,
          s = t / 2,
          a = Math.floor(n),
          o = Math.floor(i),
          l = a + 1,
          c = o + 1,
          h = e / a,
          u = t / o,
          d = [],
          p = [],
          m = [],
          f = [];
        for (let e = 0; e < c; e++) {
          const t = e * u - s;
          for (let n = 0; n < l; n++) {
            const i = n * h - r;
            p.push(i, -t, 0), m.push(0, 0, 1), f.push(n / a), f.push(1 - e / o);
          }
        }
        for (let e = 0; e < o; e++)
          for (let t = 0; t < a; t++) {
            const n = t + l * e,
              i = t + l * (e + 1),
              r = t + 1 + l * (e + 1),
              s = t + 1 + l * e;
            d.push(n, i, s), d.push(i, r, s);
          }
        this.setIndex(d),
          this.setAttribute("position", new Dt(p, 3)),
          this.setAttribute("normal", new Dt(m, 3)),
          this.setAttribute("uv", new Dt(f, 2));
      }
    }
    const Ln = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common:
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin:
          "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment:
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmissionmap_fragment:
          "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
        transmissionmap_pars_fragment:
          "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
        uv_pars_fragment:
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag:
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert:
          "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      },
      Rn = {
        common: {
          diffuse: { value: new At(15658734) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new q() },
          uv2Transform: { value: new q() },
          alphaMap: { value: null },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          refractionRatio: { value: 0.98 },
          maxMipLevel: { value: 0 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new j(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new At(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: { direction: {}, color: {} },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: { color: {}, position: {}, decay: {}, distance: {} },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
          ltc_1: { value: null },
          ltc_2: { value: null },
        },
        points: {
          diffuse: { value: new At(15658734) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new q() },
        },
        sprite: {
          diffuse: { value: new At(15658734) },
          opacity: { value: 1 },
          center: { value: new j(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new q() },
        },
      },
      Cn = {
        basic: {
          uniforms: dn([
            Rn.common,
            Rn.specularmap,
            Rn.envmap,
            Rn.aomap,
            Rn.lightmap,
            Rn.fog,
          ]),
          vertexShader: Ln.meshbasic_vert,
          fragmentShader: Ln.meshbasic_frag,
        },
        lambert: {
          uniforms: dn([
            Rn.common,
            Rn.specularmap,
            Rn.envmap,
            Rn.aomap,
            Rn.lightmap,
            Rn.emissivemap,
            Rn.fog,
            Rn.lights,
            { emissive: { value: new At(0) } },
          ]),
          vertexShader: Ln.meshlambert_vert,
          fragmentShader: Ln.meshlambert_frag,
        },
        phong: {
          uniforms: dn([
            Rn.common,
            Rn.specularmap,
            Rn.envmap,
            Rn.aomap,
            Rn.lightmap,
            Rn.emissivemap,
            Rn.bumpmap,
            Rn.normalmap,
            Rn.displacementmap,
            Rn.fog,
            Rn.lights,
            {
              emissive: { value: new At(0) },
              specular: { value: new At(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: Ln.meshphong_vert,
          fragmentShader: Ln.meshphong_frag,
        },
        standard: {
          uniforms: dn([
            Rn.common,
            Rn.envmap,
            Rn.aomap,
            Rn.lightmap,
            Rn.emissivemap,
            Rn.bumpmap,
            Rn.normalmap,
            Rn.displacementmap,
            Rn.roughnessmap,
            Rn.metalnessmap,
            Rn.fog,
            Rn.lights,
            {
              emissive: { value: new At(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: Ln.meshphysical_vert,
          fragmentShader: Ln.meshphysical_frag,
        },
        toon: {
          uniforms: dn([
            Rn.common,
            Rn.aomap,
            Rn.lightmap,
            Rn.emissivemap,
            Rn.bumpmap,
            Rn.normalmap,
            Rn.displacementmap,
            Rn.gradientmap,
            Rn.fog,
            Rn.lights,
            { emissive: { value: new At(0) } },
          ]),
          vertexShader: Ln.meshtoon_vert,
          fragmentShader: Ln.meshtoon_frag,
        },
        matcap: {
          uniforms: dn([
            Rn.common,
            Rn.bumpmap,
            Rn.normalmap,
            Rn.displacementmap,
            Rn.fog,
            { matcap: { value: null } },
          ]),
          vertexShader: Ln.meshmatcap_vert,
          fragmentShader: Ln.meshmatcap_frag,
        },
        points: {
          uniforms: dn([Rn.points, Rn.fog]),
          vertexShader: Ln.points_vert,
          fragmentShader: Ln.points_frag,
        },
        dashed: {
          uniforms: dn([
            Rn.common,
            Rn.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: Ln.linedashed_vert,
          fragmentShader: Ln.linedashed_frag,
        },
        depth: {
          uniforms: dn([Rn.common, Rn.displacementmap]),
          vertexShader: Ln.depth_vert,
          fragmentShader: Ln.depth_frag,
        },
        normal: {
          uniforms: dn([
            Rn.common,
            Rn.bumpmap,
            Rn.normalmap,
            Rn.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: Ln.normal_vert,
          fragmentShader: Ln.normal_frag,
        },
        sprite: {
          uniforms: dn([Rn.sprite, Rn.fog]),
          vertexShader: Ln.sprite_vert,
          fragmentShader: Ln.sprite_frag,
        },
        background: {
          uniforms: { uvTransform: { value: new q() }, t2D: { value: null } },
          vertexShader: Ln.background_vert,
          fragmentShader: Ln.background_frag,
        },
        cube: {
          uniforms: dn([Rn.envmap, { opacity: { value: 1 } }]),
          vertexShader: Ln.cube_vert,
          fragmentShader: Ln.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: Ln.equirect_vert,
          fragmentShader: Ln.equirect_frag,
        },
        distanceRGBA: {
          uniforms: dn([
            Rn.common,
            Rn.displacementmap,
            {
              referencePosition: { value: new te() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: Ln.distanceRGBA_vert,
          fragmentShader: Ln.distanceRGBA_frag,
        },
        shadow: {
          uniforms: dn([
            Rn.lights,
            Rn.fog,
            { color: { value: new At(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: Ln.shadow_vert,
          fragmentShader: Ln.shadow_frag,
        },
      };
    function Pn(e, t, n, i, r) {
      const s = new At(0);
      let a,
        o,
        l = 0,
        c = null,
        h = 0,
        u = null;
      function d(e, t) {
        n.buffers.color.setClear(e.r, e.g, e.b, t, r);
      }
      return {
        getClearColor: function () {
          return s;
        },
        setClearColor: function (e, t = 1) {
          s.set(e), (l = t), d(s, l);
        },
        getClearAlpha: function () {
          return l;
        },
        setClearAlpha: function (e) {
          (l = e), d(s, l);
        },
        render: function (n, r, p, m) {
          let f = !0 === r.isScene ? r.background : null;
          f && f.isTexture && (f = t.get(f));
          const g = e.xr,
            v = g.getSession && g.getSession();
          v && "additive" === v.environmentBlendMode && (f = null),
            null === f ? d(s, l) : f && f.isColor && (d(f, 1), (m = !0)),
            (e.autoClear || m) &&
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            f && (f.isCubeTexture || 306 === f.mapping)
              ? (void 0 === o &&
                  ((o = new ln(
                    new hn(1, 1, 1),
                    new mn({
                      name: "BackgroundCubeMaterial",
                      uniforms: un(Cn.cube.uniforms),
                      vertexShader: Cn.cube.vertexShader,
                      fragmentShader: Cn.cube.fragmentShader,
                      side: 1,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  o.geometry.deleteAttribute("normal"),
                  o.geometry.deleteAttribute("uv"),
                  (o.onBeforeRender = function (e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(o.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  i.update(o)),
                (o.material.uniforms.envMap.value = f),
                (o.material.uniforms.flipEnvMap.value =
                  f.isCubeTexture && f._needsFlipEnvMap ? -1 : 1),
                (c === f && h === f.version && u === e.toneMapping) ||
                  ((o.material.needsUpdate = !0),
                  (c = f),
                  (h = f.version),
                  (u = e.toneMapping)),
                n.unshift(o, o.geometry, o.material, 0, 0, null))
              : f &&
                f.isTexture &&
                (void 0 === a &&
                  ((a = new ln(
                    new An(2, 2),
                    new mn({
                      name: "BackgroundMaterial",
                      uniforms: un(Cn.background.uniforms),
                      vertexShader: Cn.background.vertexShader,
                      fragmentShader: Cn.background.fragmentShader,
                      side: 0,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  i.update(a)),
                (a.material.uniforms.t2D.value = f),
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(f.matrix),
                (c === f && h === f.version && u === e.toneMapping) ||
                  ((a.material.needsUpdate = !0),
                  (c = f),
                  (h = f.version),
                  (u = e.toneMapping)),
                n.unshift(a, a.geometry, a.material, 0, 0, null));
        },
      };
    }
    function In(e, t, n, i) {
      const r = e.getParameter(34921),
        s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
        a = i.isWebGL2 || null !== s,
        o = {},
        l = d(null);
      let c = l;
      function h(t) {
        return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t);
      }
      function u(t) {
        return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t);
      }
      function d(e) {
        const t = [],
          n = [],
          i = [];
        for (let e = 0; e < r; e++) (t[e] = 0), (n[e] = 0), (i[e] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: t,
          enabledAttributes: n,
          attributeDivisors: i,
          object: e,
          attributes: {},
          index: null,
        };
      }
      function p() {
        const e = c.newAttributes;
        for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
      }
      function m(e) {
        f(e, 0);
      }
      function f(n, r) {
        const s = c.newAttributes,
          a = c.enabledAttributes,
          o = c.attributeDivisors;
        (s[n] = 1),
          0 === a[n] && (e.enableVertexAttribArray(n), (a[n] = 1)),
          o[n] !== r &&
            ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
              i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
            ](n, r),
            (o[n] = r));
      }
      function g() {
        const t = c.newAttributes,
          n = c.enabledAttributes;
        for (let i = 0, r = n.length; i < r; i++)
          n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
      }
      function v(t, n, r, s, a, o) {
        !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
          ? e.vertexAttribPointer(t, n, r, s, a, o)
          : e.vertexAttribIPointer(t, n, r, a, o);
      }
      function x() {
        y(), c !== l && ((c = l), h(c.object));
      }
      function y() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
      }
      return {
        setup: function (r, l, u, x, y) {
          let _ = !1;
          if (a) {
            const t = (function (t, n, r) {
              const a = !0 === r.wireframe;
              let l = o[t.id];
              void 0 === l && ((l = {}), (o[t.id] = l));
              let c = l[n.id];
              void 0 === c && ((c = {}), (l[n.id] = c));
              let h = c[a];
              return (
                void 0 === h &&
                  ((h = d(
                    i.isWebGL2
                      ? e.createVertexArray()
                      : s.createVertexArrayOES()
                  )),
                  (c[a] = h)),
                h
              );
            })(x, u, l);
            c !== t && ((c = t), h(c.object)),
              (_ = (function (e, t) {
                const n = c.attributes,
                  i = e.attributes;
                let r = 0;
                for (const e in i) {
                  const t = n[e],
                    s = i[e];
                  if (void 0 === t) return !0;
                  if (t.attribute !== s) return !0;
                  if (t.data !== s.data) return !0;
                  r++;
                }
                return c.attributesNum !== r || c.index !== t;
              })(x, y)),
              _ &&
                (function (e, t) {
                  const n = {},
                    i = e.attributes;
                  let r = 0;
                  for (const e in i) {
                    const t = i[e],
                      s = {};
                    (s.attribute = t),
                      t.data && (s.data = t.data),
                      (n[e] = s),
                      r++;
                  }
                  (c.attributes = n), (c.attributesNum = r), (c.index = t);
                })(x, y);
          } else {
            const e = !0 === l.wireframe;
            (c.geometry === x.id && c.program === u.id && c.wireframe === e) ||
              ((c.geometry = x.id),
              (c.program = u.id),
              (c.wireframe = e),
              (_ = !0));
          }
          !0 === r.isInstancedMesh && (_ = !0),
            null !== y && n.update(y, 34963),
            _ &&
              ((function (r, s, a, o) {
                if (
                  !1 === i.isWebGL2 &&
                  (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                  null === t.get("ANGLE_instanced_arrays")
                )
                  return;
                p();
                const l = o.attributes,
                  c = a.getAttributes(),
                  h = s.defaultAttributeValues;
                for (const t in c) {
                  const i = c[t];
                  if (i >= 0) {
                    const s = l[t];
                    if (void 0 !== s) {
                      const t = s.normalized,
                        r = s.itemSize,
                        a = n.get(s);
                      if (void 0 === a) continue;
                      const l = a.buffer,
                        c = a.type,
                        h = a.bytesPerElement;
                      if (s.isInterleavedBufferAttribute) {
                        const n = s.data,
                          a = n.stride,
                          u = s.offset;
                        n && n.isInstancedInterleavedBuffer
                          ? (f(i, n.meshPerAttribute),
                            void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                n.meshPerAttribute * n.count))
                          : m(i),
                          e.bindBuffer(34962, l),
                          v(i, r, c, t, a * h, u * h);
                      } else
                        s.isInstancedBufferAttribute
                          ? (f(i, s.meshPerAttribute),
                            void 0 === o._maxInstanceCount &&
                              (o._maxInstanceCount =
                                s.meshPerAttribute * s.count))
                          : m(i),
                          e.bindBuffer(34962, l),
                          v(i, r, c, t, 0, 0);
                    } else if ("instanceMatrix" === t) {
                      const t = n.get(r.instanceMatrix);
                      if (void 0 === t) continue;
                      const s = t.buffer,
                        a = t.type;
                      f(i + 0, 1),
                        f(i + 1, 1),
                        f(i + 2, 1),
                        f(i + 3, 1),
                        e.bindBuffer(34962, s),
                        e.vertexAttribPointer(i + 0, 4, a, !1, 64, 0),
                        e.vertexAttribPointer(i + 1, 4, a, !1, 64, 16),
                        e.vertexAttribPointer(i + 2, 4, a, !1, 64, 32),
                        e.vertexAttribPointer(i + 3, 4, a, !1, 64, 48);
                    } else if ("instanceColor" === t) {
                      const t = n.get(r.instanceColor);
                      if (void 0 === t) continue;
                      const s = t.buffer,
                        a = t.type;
                      f(i, 1),
                        e.bindBuffer(34962, s),
                        e.vertexAttribPointer(i, 3, a, !1, 12, 0);
                    } else if (void 0 !== h) {
                      const n = h[t];
                      if (void 0 !== n)
                        switch (n.length) {
                          case 2:
                            e.vertexAttrib2fv(i, n);
                            break;
                          case 3:
                            e.vertexAttrib3fv(i, n);
                            break;
                          case 4:
                            e.vertexAttrib4fv(i, n);
                            break;
                          default:
                            e.vertexAttrib1fv(i, n);
                        }
                    }
                  }
                }
                g();
              })(r, l, u, x),
              null !== y && e.bindBuffer(34963, n.get(y).buffer));
        },
        reset: x,
        resetDefaultState: y,
        dispose: function () {
          x();
          for (const e in o) {
            const t = o[e];
            for (const e in t) {
              const n = t[e];
              for (const e in n) u(n[e].object), delete n[e];
              delete t[e];
            }
            delete o[e];
          }
        },
        releaseStatesOfGeometry: function (e) {
          if (void 0 === o[e.id]) return;
          const t = o[e.id];
          for (const e in t) {
            const n = t[e];
            for (const e in n) u(n[e].object), delete n[e];
            delete t[e];
          }
          delete o[e.id];
        },
        releaseStatesOfProgram: function (e) {
          for (const t in o) {
            const n = o[t];
            if (void 0 === n[e.id]) continue;
            const i = n[e.id];
            for (const e in i) u(i[e].object), delete i[e];
            delete n[e.id];
          }
        },
        initAttributes: p,
        enableAttribute: m,
        disableUnusedAttributes: g,
      };
    }
    function Nn(e, t, n, i) {
      const r = i.isWebGL2;
      let s;
      (this.setMode = function (e) {
        s = e;
      }),
        (this.render = function (t, i) {
          e.drawArrays(s, t, i), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, a, o) {
          if (0 === o) return;
          let l, c;
          if (r) (l = e), (c = "drawArraysInstanced");
          else if (
            ((l = t.get("ANGLE_instanced_arrays")),
            (c = "drawArraysInstancedANGLE"),
            null === l)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          l[c](s, i, a, o), n.update(a, s, o);
        });
    }
    function Dn(e, t, n) {
      let i;
      function r(t) {
        if ("highp" === t) {
          if (
            e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          t = "mediump";
        }
        return "mediump" === t &&
          e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          e.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      const s =
        ("undefined" != typeof WebGL2RenderingContext &&
          e instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          e instanceof WebGL2ComputeRenderingContext);
      let a = void 0 !== n.precision ? n.precision : "highp";
      const o = r(a);
      o !== a &&
        (console.warn(
          "THREE.WebGLRenderer:",
          a,
          "not supported, using",
          o,
          "instead."
        ),
        (a = o));
      const l = !0 === n.logarithmicDepthBuffer,
        c = e.getParameter(34930),
        h = e.getParameter(35660),
        u = e.getParameter(3379),
        d = e.getParameter(34076),
        p = e.getParameter(34921),
        m = e.getParameter(36347),
        f = e.getParameter(36348),
        g = e.getParameter(36349),
        v = h > 0,
        x = s || t.has("OES_texture_float");
      return {
        isWebGL2: s,
        getMaxAnisotropy: function () {
          if (void 0 !== i) return i;
          if (!0 === t.has("EXT_texture_filter_anisotropic")) {
            const n = t.get("EXT_texture_filter_anisotropic");
            i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else i = 0;
          return i;
        },
        getMaxPrecision: r,
        precision: a,
        logarithmicDepthBuffer: l,
        maxTextures: c,
        maxVertexTextures: h,
        maxTextureSize: u,
        maxCubemapSize: d,
        maxAttributes: p,
        maxVertexUniforms: m,
        maxVaryings: f,
        maxFragmentUniforms: g,
        vertexTextures: v,
        floatFragmentTextures: x,
        floatVertexTextures: v && x,
        maxSamples: s ? e.getParameter(36183) : 0,
      };
    }
    function On(e) {
      const t = this;
      let n = null,
        i = 0,
        r = !1,
        s = !1;
      const a = new ot(),
        o = new q(),
        l = { value: null, needsUpdate: !1 };
      function c() {
        l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
          (t.numPlanes = i),
          (t.numIntersection = 0);
      }
      function h(e, n, i, r) {
        const s = null !== e ? e.length : 0;
        let c = null;
        if (0 !== s) {
          if (((c = l.value), !0 !== r || null === c)) {
            const t = i + 4 * s,
              r = n.matrixWorldInverse;
            o.getNormalMatrix(r),
              (null === c || c.length < t) && (c = new Float32Array(t));
            for (let t = 0, n = i; t !== s; ++t, n += 4)
              a.copy(e[t]).applyMatrix4(r, o),
                a.normal.toArray(c, n),
                (c[n + 3] = a.constant);
          }
          (l.value = c), (l.needsUpdate = !0);
        }
        return (t.numPlanes = s), (t.numIntersection = 0), c;
      }
      (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (e, t, s) {
          const a = 0 !== e.length || t || 0 !== i || r;
          return (r = t), (n = h(e, s, 0)), (i = e.length), a;
        }),
        (this.beginShadows = function () {
          (s = !0), h(null);
        }),
        (this.endShadows = function () {
          (s = !1), c();
        }),
        (this.setState = function (t, a, o) {
          const u = t.clippingPlanes,
            d = t.clipIntersection,
            p = t.clipShadows,
            m = e.get(t);
          if (!r || null === u || 0 === u.length || (s && !p))
            s ? h(null) : c();
          else {
            const e = s ? 0 : i,
              t = 4 * e;
            let r = m.clippingState || null;
            (l.value = r), (r = h(u, a, t, o));
            for (let e = 0; e !== t; ++e) r[e] = n[e];
            (m.clippingState = r),
              (this.numIntersection = d ? this.numPlanes : 0),
              (this.numPlanes += e);
          }
        });
    }
    function zn(e) {
      let t = new WeakMap();
      function n(e, t) {
        return (
          303 === t ? (e.mapping = 301) : 304 === t && (e.mapping = 302), e
        );
      }
      function i(e) {
        const n = e.target;
        n.removeEventListener("dispose", i);
        const r = t.get(n);
        void 0 !== r && (t.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture) {
            const s = r.mapping;
            if (303 === s || 304 === s) {
              if (t.has(r)) return n(t.get(r).texture, r.mapping);
              {
                const s = r.image;
                if (s && s.height > 0) {
                  const a = e.getRenderTarget(),
                    o = new _n(s.height / 2);
                  return (
                    o.fromEquirectangularTexture(e, r),
                    t.set(r, o),
                    e.setRenderTarget(a),
                    r.addEventListener("dispose", i),
                    n(o.texture, r.mapping)
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Hn(e) {
      const t = {};
      function n(n) {
        if (void 0 !== t[n]) return t[n];
        let i;
        switch (n) {
          case "WEBGL_depth_texture":
            i =
              e.getExtension("WEBGL_depth_texture") ||
              e.getExtension("MOZ_WEBGL_depth_texture") ||
              e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            i =
              e.getExtension("EXT_texture_filter_anisotropic") ||
              e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            i =
              e.getExtension("WEBGL_compressed_texture_s3tc") ||
              e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            i =
              e.getExtension("WEBGL_compressed_texture_pvrtc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            i = e.getExtension(n);
        }
        return (t[n] = i), i;
      }
      return {
        has: function (e) {
          return null !== n(e);
        },
        init: function (e) {
          e.isWebGL2
            ? n("EXT_color_buffer_float")
            : (n("WEBGL_depth_texture"),
              n("OES_texture_float"),
              n("OES_texture_half_float"),
              n("OES_texture_half_float_linear"),
              n("OES_standard_derivatives"),
              n("OES_element_index_uint"),
              n("OES_vertex_array_object"),
              n("ANGLE_instanced_arrays")),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float");
        },
        get: function (e) {
          const t = n(e);
          return (
            null === t &&
              console.warn(
                "THREE.WebGLRenderer: " + e + " extension not supported."
              ),
            t
          );
        },
      };
    }
    function Fn(e, t, n, i) {
      const r = {},
        s = new WeakMap();
      function a(e) {
        const o = e.target;
        null !== o.index && t.remove(o.index);
        for (const e in o.attributes) t.remove(o.attributes[e]);
        o.removeEventListener("dispose", a), delete r[o.id];
        const l = s.get(o);
        l && (t.remove(l), s.delete(o)),
          i.releaseStatesOfGeometry(o),
          !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
          n.memory.geometries--;
      }
      function o(e) {
        const n = [],
          i = e.index,
          r = e.attributes.position;
        let a = 0;
        if (null !== i) {
          const e = i.array;
          a = i.version;
          for (let t = 0, i = e.length; t < i; t += 3) {
            const i = e[t + 0],
              r = e[t + 1],
              s = e[t + 2];
            n.push(i, r, r, s, s, i);
          }
        } else {
          const e = r.array;
          a = r.version;
          for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
            const e = t + 0,
              i = t + 1,
              r = t + 2;
            n.push(e, i, i, r, r, e);
          }
        }
        const o = new (Ot(n) > 65535 ? Nt : It)(n, 1);
        o.version = a;
        const l = s.get(e);
        l && t.remove(l), s.set(e, o);
      }
      return {
        get: function (e, t) {
          return (
            !0 === r[t.id] ||
              (t.addEventListener("dispose", a),
              (r[t.id] = !0),
              n.memory.geometries++),
            t
          );
        },
        update: function (e) {
          const n = e.attributes;
          for (const e in n) t.update(n[e], 34962);
          const i = e.morphAttributes;
          for (const e in i) {
            const n = i[e];
            for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962);
          }
        },
        getWireframeAttribute: function (e) {
          const t = s.get(e);
          if (t) {
            const n = e.index;
            null !== n && t.version < n.version && o(e);
          } else o(e);
          return s.get(e);
        },
      };
    }
    function Bn(e, t, n, i) {
      const r = i.isWebGL2;
      let s, a, o;
      (this.setMode = function (e) {
        s = e;
      }),
        (this.setIndex = function (e) {
          (a = e.type), (o = e.bytesPerElement);
        }),
        (this.render = function (t, i) {
          e.drawElements(s, i, a, t * o), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, l, c) {
          if (0 === c) return;
          let h, u;
          if (r) (h = e), (u = "drawElementsInstanced");
          else if (
            ((h = t.get("ANGLE_instanced_arrays")),
            (u = "drawElementsInstancedANGLE"),
            null === h)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          h[u](s, l, a, i * o, c), n.update(l, s, c);
        });
    }
    function Un(e) {
      const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function () {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        },
        update: function (e, n, i) {
          switch ((t.calls++, n)) {
            case 4:
              t.triangles += i * (e / 3);
              break;
            case 1:
              t.lines += i * (e / 2);
              break;
            case 3:
              t.lines += i * (e - 1);
              break;
            case 2:
              t.lines += i * e;
              break;
            case 0:
              t.points += i * e;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        },
      };
    }
    function Gn(e, t) {
      return e[0] - t[0];
    }
    function kn(e, t) {
      return Math.abs(t[1]) - Math.abs(e[1]);
    }
    function Vn(e) {
      const t = {},
        n = new Float32Array(8),
        i = [];
      for (let e = 0; e < 8; e++) i[e] = [e, 0];
      return {
        update: function (r, s, a, o) {
          const l = r.morphTargetInfluences,
            c = void 0 === l ? 0 : l.length;
          let h = t[s.id];
          if (void 0 === h) {
            h = [];
            for (let e = 0; e < c; e++) h[e] = [e, 0];
            t[s.id] = h;
          }
          for (let e = 0; e < c; e++) {
            const t = h[e];
            (t[0] = e), (t[1] = l[e]);
          }
          h.sort(kn);
          for (let e = 0; e < 8; e++)
            e < c && h[e][1]
              ? ((i[e][0] = h[e][0]), (i[e][1] = h[e][1]))
              : ((i[e][0] = Number.MAX_SAFE_INTEGER), (i[e][1] = 0));
          i.sort(Gn);
          const u = a.morphTargets && s.morphAttributes.position,
            d = a.morphNormals && s.morphAttributes.normal;
          let p = 0;
          for (let e = 0; e < 8; e++) {
            const t = i[e],
              r = t[0],
              a = t[1];
            r !== Number.MAX_SAFE_INTEGER && a
              ? (u &&
                  s.getAttribute("morphTarget" + e) !== u[r] &&
                  s.setAttribute("morphTarget" + e, u[r]),
                d &&
                  s.getAttribute("morphNormal" + e) !== d[r] &&
                  s.setAttribute("morphNormal" + e, d[r]),
                (n[e] = a),
                (p += a))
              : (u &&
                  !0 === s.hasAttribute("morphTarget" + e) &&
                  s.deleteAttribute("morphTarget" + e),
                d &&
                  !0 === s.hasAttribute("morphNormal" + e) &&
                  s.deleteAttribute("morphNormal" + e),
                (n[e] = 0));
          }
          const m = s.morphTargetsRelative ? 1 : 1 - p;
          o.getUniforms().setValue(e, "morphTargetBaseInfluence", m),
            o.getUniforms().setValue(e, "morphTargetInfluences", n);
        },
      };
    }
    function Wn(e, t, n, i) {
      let r = new WeakMap();
      function s(e) {
        const t = e.target;
        t.removeEventListener("dispose", s),
          n.remove(t.instanceMatrix),
          null !== t.instanceColor && n.remove(t.instanceColor);
      }
      return {
        update: function (e) {
          const a = i.render.frame,
            o = e.geometry,
            l = t.get(e, o);
          return (
            r.get(l) !== a && (t.update(l), r.set(l, a)),
            e.isInstancedMesh &&
              (!1 === e.hasEventListener("dispose", s) &&
                e.addEventListener("dispose", s),
              n.update(e.instanceMatrix, 34962),
              null !== e.instanceColor && n.update(e.instanceColor, 34962)),
            l
          );
        },
        dispose: function () {
          r = new WeakMap();
        },
      };
    }
    Cn.physical = {
      uniforms: dn([
        Cn.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new j(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: new At(0) },
          transmission: { value: 0 },
          transmissionMap: { value: null },
        },
      ]),
      vertexShader: Ln.meshphysical_vert,
      fragmentShader: Ln.meshphysical_frag,
    };
    class jn extends J {
      constructor(e = null, t = 1, n = 1, i = 1) {
        super(null),
          (this.image = { data: e, width: t, height: n, depth: i }),
          (this.magFilter = a),
          (this.minFilter = a),
          (this.wrapR = r),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    jn.prototype.isDataTexture2DArray = !0;
    class qn extends J {
      constructor(e = null, t = 1, n = 1, i = 1) {
        super(null),
          (this.image = { data: e, width: t, height: n, depth: i }),
          (this.magFilter = a),
          (this.minFilter = a),
          (this.wrapR = r),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    qn.prototype.isDataTexture3D = !0;
    const Xn = new J(),
      Yn = new jn(),
      Zn = new qn(),
      Jn = new yn(),
      Kn = [],
      Qn = [],
      $n = new Float32Array(16),
      ei = new Float32Array(9),
      ti = new Float32Array(4);
    function ni(e, t, n) {
      const i = e[0];
      if (i <= 0 || i > 0) return e;
      const r = t * n;
      let s = Kn[r];
      if ((void 0 === s && ((s = new Float32Array(r)), (Kn[r] = s)), 0 !== t)) {
        i.toArray(s, 0);
        for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(s, r);
      }
      return s;
    }
    function ii(e, t) {
      if (e.length !== t.length) return !1;
      for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
      return !0;
    }
    function ri(e, t) {
      for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
    }
    function si(e, t) {
      let n = Qn[t];
      void 0 === n && ((n = new Int32Array(t)), (Qn[t] = n));
      for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
      return n;
    }
    function ai(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
    }
    function oi(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y) ||
          (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
      else {
        if (ii(n, t)) return;
        e.uniform2fv(this.addr, t), ri(n, t);
      }
    }
    function li(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
          (e.uniform3f(this.addr, t.x, t.y, t.z),
          (n[0] = t.x),
          (n[1] = t.y),
          (n[2] = t.z));
      else if (void 0 !== t.r)
        (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
          (e.uniform3f(this.addr, t.r, t.g, t.b),
          (n[0] = t.r),
          (n[1] = t.g),
          (n[2] = t.b));
      else {
        if (ii(n, t)) return;
        e.uniform3fv(this.addr, t), ri(n, t);
      }
    }
    function ci(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
          (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
          (n[0] = t.x),
          (n[1] = t.y),
          (n[2] = t.z),
          (n[3] = t.w));
      else {
        if (ii(n, t)) return;
        e.uniform4fv(this.addr, t), ri(n, t);
      }
    }
    function hi(e, t) {
      const n = this.cache,
        i = t.elements;
      if (void 0 === i) {
        if (ii(n, t)) return;
        e.uniformMatrix2fv(this.addr, !1, t), ri(n, t);
      } else {
        if (ii(n, i)) return;
        ti.set(i), e.uniformMatrix2fv(this.addr, !1, ti), ri(n, i);
      }
    }
    function ui(e, t) {
      const n = this.cache,
        i = t.elements;
      if (void 0 === i) {
        if (ii(n, t)) return;
        e.uniformMatrix3fv(this.addr, !1, t), ri(n, t);
      } else {
        if (ii(n, i)) return;
        ei.set(i), e.uniformMatrix3fv(this.addr, !1, ei), ri(n, i);
      }
    }
    function di(e, t) {
      const n = this.cache,
        i = t.elements;
      if (void 0 === i) {
        if (ii(n, t)) return;
        e.uniformMatrix4fv(this.addr, !1, t), ri(n, t);
      } else {
        if (ii(n, i)) return;
        $n.set(i), e.uniformMatrix4fv(this.addr, !1, $n), ri(n, i);
      }
    }
    function pi(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
    }
    function mi(e, t) {
      const n = this.cache;
      ii(n, t) || (e.uniform2iv(this.addr, t), ri(n, t));
    }
    function fi(e, t) {
      const n = this.cache;
      ii(n, t) || (e.uniform3iv(this.addr, t), ri(n, t));
    }
    function gi(e, t) {
      const n = this.cache;
      ii(n, t) || (e.uniform4iv(this.addr, t), ri(n, t));
    }
    function vi(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
    }
    function xi(e, t) {
      const n = this.cache;
      ii(n, t) || (e.uniform2uiv(this.addr, t), ri(n, t));
    }
    function yi(e, t) {
      const n = this.cache;
      ii(n, t) || (e.uniform3uiv(this.addr, t), ri(n, t));
    }
    function _i(e, t) {
      const n = this.cache;
      ii(n, t) || (e.uniform4uiv(this.addr, t), ri(n, t));
    }
    function wi(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTexture2D(t || Xn, r);
    }
    function bi(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture3D(t || Zn, r);
    }
    function Mi(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTextureCube(t || Jn, r);
    }
    function Si(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2DArray(t || Yn, r);
    }
    function Ti(e, t) {
      e.uniform1fv(this.addr, t);
    }
    function Ei(e, t) {
      const n = ni(t, this.size, 2);
      e.uniform2fv(this.addr, n);
    }
    function Ai(e, t) {
      const n = ni(t, this.size, 3);
      e.uniform3fv(this.addr, n);
    }
    function Li(e, t) {
      const n = ni(t, this.size, 4);
      e.uniform4fv(this.addr, n);
    }
    function Ri(e, t) {
      const n = ni(t, this.size, 4);
      e.uniformMatrix2fv(this.addr, !1, n);
    }
    function Ci(e, t) {
      const n = ni(t, this.size, 9);
      e.uniformMatrix3fv(this.addr, !1, n);
    }
    function Pi(e, t) {
      const n = ni(t, this.size, 16);
      e.uniformMatrix4fv(this.addr, !1, n);
    }
    function Ii(e, t) {
      e.uniform1iv(this.addr, t);
    }
    function Ni(e, t) {
      e.uniform2iv(this.addr, t);
    }
    function Di(e, t) {
      e.uniform3iv(this.addr, t);
    }
    function Oi(e, t) {
      e.uniform4iv(this.addr, t);
    }
    function zi(e, t) {
      e.uniform1uiv(this.addr, t);
    }
    function Hi(e, t) {
      e.uniform2uiv(this.addr, t);
    }
    function Fi(e, t) {
      e.uniform3uiv(this.addr, t);
    }
    function Bi(e, t) {
      e.uniform4uiv(this.addr, t);
    }
    function Ui(e, t, n) {
      const i = t.length,
        r = si(n, i);
      e.uniform1iv(this.addr, r);
      for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Xn, r[e]);
    }
    function Gi(e, t, n) {
      const i = t.length,
        r = si(n, i);
      e.uniform1iv(this.addr, r);
      for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || Jn, r[e]);
    }
    function ki(e, t, n) {
      (this.id = e),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return ai;
            case 35664:
              return oi;
            case 35665:
              return li;
            case 35666:
              return ci;
            case 35674:
              return hi;
            case 35675:
              return ui;
            case 35676:
              return di;
            case 5124:
            case 35670:
              return pi;
            case 35667:
            case 35671:
              return mi;
            case 35668:
            case 35672:
              return fi;
            case 35669:
            case 35673:
              return gi;
            case 5125:
              return vi;
            case 36294:
              return xi;
            case 36295:
              return yi;
            case 36296:
              return _i;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return wi;
            case 35679:
            case 36299:
            case 36307:
              return bi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Mi;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Si;
          }
        })(t.type));
    }
    function Vi(e, t, n) {
      (this.id = e),
        (this.addr = n),
        (this.cache = []),
        (this.size = t.size),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return Ti;
            case 35664:
              return Ei;
            case 35665:
              return Ai;
            case 35666:
              return Li;
            case 35674:
              return Ri;
            case 35675:
              return Ci;
            case 35676:
              return Pi;
            case 5124:
            case 35670:
              return Ii;
            case 35667:
            case 35671:
              return Ni;
            case 35668:
            case 35672:
              return Di;
            case 35669:
            case 35673:
              return Oi;
            case 5125:
              return zi;
            case 36294:
              return Hi;
            case 36295:
              return Fi;
            case 36296:
              return Bi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Ui;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Gi;
          }
        })(t.type));
    }
    function Wi(e) {
      (this.id = e), (this.seq = []), (this.map = {});
    }
    (Vi.prototype.updateCache = function (e) {
      const t = this.cache;
      e instanceof Float32Array &&
        t.length !== e.length &&
        (this.cache = new Float32Array(e.length)),
        ri(t, e);
    }),
      (Wi.prototype.setValue = function (e, t, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
          const s = i[r];
          s.setValue(e, t[s.id], n);
        }
      });
    const ji = /(\w+)(\])?(\[|\.)?/g;
    function qi(e, t) {
      e.seq.push(t), (e.map[t.id] = t);
    }
    function Xi(e, t, n) {
      const i = e.name,
        r = i.length;
      for (ji.lastIndex = 0; ; ) {
        const s = ji.exec(i),
          a = ji.lastIndex;
        let o = s[1];
        const l = "]" === s[2],
          c = s[3];
        if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
          qi(n, void 0 === c ? new ki(o, e, t) : new Vi(o, e, t));
          break;
        }
        {
          let e = n.map[o];
          void 0 === e && ((e = new Wi(o)), qi(n, e)), (n = e);
        }
      }
    }
    function Yi(e, t) {
      (this.seq = []), (this.map = {});
      const n = e.getProgramParameter(t, 35718);
      for (let i = 0; i < n; ++i) {
        const n = e.getActiveUniform(t, i);
        Xi(n, e.getUniformLocation(t, n.name), this);
      }
    }
    function Zi(e, t, n) {
      const i = e.createShader(t);
      return e.shaderSource(i, n), e.compileShader(i), i;
    }
    (Yi.prototype.setValue = function (e, t, n, i) {
      const r = this.map[t];
      void 0 !== r && r.setValue(e, n, i);
    }),
      (Yi.prototype.setOptional = function (e, t, n) {
        const i = t[n];
        void 0 !== i && this.setValue(e, n, i);
      }),
      (Yi.upload = function (e, t, n, i) {
        for (let r = 0, s = t.length; r !== s; ++r) {
          const s = t[r],
            a = n[s.id];
          !1 !== a.needsUpdate && s.setValue(e, a.value, i);
        }
      }),
      (Yi.seqWithValue = function (e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
          const r = e[i];
          r.id in t && n.push(r);
        }
        return n;
      });
    let Ji = 0;
    function Ki(e) {
      switch (e) {
        case E:
          return ["Linear", "( value )"];
        case A:
          return ["sRGB", "( value )"];
        case 3002:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case 3007:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
          return ["LogLuv", "( value )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
            ["Linear", "( value )"]
          );
      }
    }
    function Qi(e, t, n) {
      const i = e.getShaderParameter(t, 35713),
        r = e.getShaderInfoLog(t).trim();
      return i && "" === r
        ? ""
        : "THREE.WebGLShader: gl.getShaderInfoLog() " +
            n +
            "\n" +
            r +
            (function (e) {
              const t = e.split("\n");
              for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
              return t.join("\n");
            })(e.getShaderSource(t));
    }
    function $i(e, t) {
      const n = Ki(t);
      return (
        "vec4 " +
        e +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function er(e, t) {
      const n = Ki(t);
      return (
        "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
      );
    }
    function tr(e, t) {
      let n;
      switch (t) {
        case 1:
          n = "Linear";
          break;
        case 2:
          n = "Reinhard";
          break;
        case 3:
          n = "OptimizedCineon";
          break;
        case 4:
          n = "ACESFilmic";
          break;
        case 5:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
            (n = "Linear");
      }
      return (
        "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function nr(e) {
      return "" !== e;
    }
    function ir(e, t) {
      return e
        .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
    }
    function rr(e, t) {
      return e
        .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          t.numClippingPlanes - t.numClipIntersection
        );
    }
    const sr = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function ar(e) {
      return e.replace(sr, or);
    }
    function or(e, t) {
      const n = Ln[t];
      if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
      return ar(n);
    }
    const lr =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      cr =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function hr(e) {
      return e.replace(cr, dr).replace(lr, ur);
    }
    function ur(e, t, n, i) {
      return (
        console.warn(
          "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
        ),
        dr(0, t, n, i)
      );
    }
    function dr(e, t, n, i) {
      let r = "";
      for (let e = parseInt(t); e < parseInt(n); e++)
        r += i
          .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, e);
      return r;
    }
    function pr(e) {
      let t =
        "precision " +
        e.precision +
        " float;\nprecision " +
        e.precision +
        " int;";
      return (
        "highp" === e.precision
          ? (t += "\n#define HIGH_PRECISION")
          : "mediump" === e.precision
          ? (t += "\n#define MEDIUM_PRECISION")
          : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
        t
      );
    }
    function mr(e, t, n, i) {
      const r = e.getContext(),
        s = n.defines;
      let a = n.vertexShader,
        o = n.fragmentShader;
      const l = (function (e) {
          let t = "SHADOWMAP_TYPE_BASIC";
          return (
            1 === e.shadowMapType
              ? (t = "SHADOWMAP_TYPE_PCF")
              : 2 === e.shadowMapType
              ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
              : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
            t
          );
        })(n),
        c = (function (e) {
          let t = "ENVMAP_TYPE_CUBE";
          if (e.envMap)
            switch (e.envMapMode) {
              case 301:
              case 302:
                t = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
              case 307:
                t = "ENVMAP_TYPE_CUBE_UV";
            }
          return t;
        })(n),
        h = (function (e) {
          let t = "ENVMAP_MODE_REFLECTION";
          if (e.envMap)
            switch (e.envMapMode) {
              case 302:
              case 307:
                t = "ENVMAP_MODE_REFRACTION";
            }
          return t;
        })(n),
        u = (function (e) {
          let t = "ENVMAP_BLENDING_NONE";
          if (e.envMap)
            switch (e.combine) {
              case 0:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                t = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                t = "ENVMAP_BLENDING_ADD";
            }
          return t;
        })(n),
        d = e.gammaFactor > 0 ? e.gammaFactor : 1,
        p = n.isWebGL2
          ? ""
          : (function (e) {
              return [
                e.extensionDerivatives ||
                e.envMapCubeUV ||
                e.bumpMap ||
                e.tangentSpaceNormalMap ||
                e.clearcoatNormalMap ||
                e.flatShading ||
                "physical" === e.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                e.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (e.extensionShaderTextureLOD || e.envMap) &&
                e.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(nr)
                .join("\n");
            })(n),
        m = (function (e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            !1 !== i && t.push("#define " + n + " " + i);
          }
          return t.join("\n");
        })(s),
        f = r.createProgram();
      let g,
        v,
        x = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial
        ? ((g = [m].filter(nr).join("\n")),
          g.length > 0 && (g += "\n"),
          (v = [p, m].filter(nr).join("\n")),
          v.length > 0 && (v += "\n"))
        : ((g = [
            pr(n),
            "#define SHADER_NAME " + n.shaderName,
            m,
            n.instancing ? "#define USE_INSTANCING" : "",
            n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            "#define GAMMA_FACTOR " + d,
            "#define MAX_BONES " + n.maxBones,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + h : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.displacementMap && n.supportsVertexTextures
              ? "#define USE_DISPLACEMENTMAP"
              : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.skinning ? "#define USE_SKINNING" : "",
            n.useVertexTexture ? "#define BONE_TEXTURE" : "",
            n.morphTargets ? "#define USE_MORPHTARGETS" : "",
            n.morphNormals && !1 === n.flatShading
              ? "#define USE_MORPHNORMALS"
              : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "\tattribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "\tattribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_TANGENT",
            "\tattribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "\tattribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "\tattribute vec3 color;",
            "#endif",
            "#ifdef USE_MORPHTARGETS",
            "\tattribute vec3 morphTarget0;",
            "\tattribute vec3 morphTarget1;",
            "\tattribute vec3 morphTarget2;",
            "\tattribute vec3 morphTarget3;",
            "\t#ifdef USE_MORPHNORMALS",
            "\t\tattribute vec3 morphNormal0;",
            "\t\tattribute vec3 morphNormal1;",
            "\t\tattribute vec3 morphNormal2;",
            "\t\tattribute vec3 morphNormal3;",
            "\t#else",
            "\t\tattribute vec3 morphTarget4;",
            "\t\tattribute vec3 morphTarget5;",
            "\t\tattribute vec3 morphTarget6;",
            "\t\tattribute vec3 morphTarget7;",
            "\t#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "\tattribute vec4 skinIndex;",
            "\tattribute vec4 skinWeight;",
            "#endif",
            "\n",
          ]
            .filter(nr)
            .join("\n")),
          (v = [
            p,
            pr(n),
            "#define SHADER_NAME " + n.shaderName,
            m,
            n.alphaTest
              ? "#define ALPHATEST " +
                n.alphaTest +
                (n.alphaTest % 1 ? "" : ".0")
              : "",
            "#define GAMMA_FACTOR " + d,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.matcap ? "#define USE_MATCAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + c : "",
            n.envMap ? "#define " + h : "",
            n.envMap ? "#define " + u : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.sheen ? "#define USE_SHEEN" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.gradientMap ? "#define USE_GRADIENTMAP" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            n.physicallyCorrectLights
              ? "#define PHYSICALLY_CORRECT_LIGHTS"
              : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            (n.extensionShaderTextureLOD || n.envMap) &&
            n.rendererExtensionShaderTextureLod
              ? "#define TEXTURE_LOD_EXT"
              : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
            0 !== n.toneMapping ? Ln.tonemapping_pars_fragment : "",
            0 !== n.toneMapping ? tr("toneMapping", n.toneMapping) : "",
            n.dithering ? "#define DITHERING" : "",
            Ln.encodings_pars_fragment,
            n.map ? $i("mapTexelToLinear", n.mapEncoding) : "",
            n.matcap ? $i("matcapTexelToLinear", n.matcapEncoding) : "",
            n.envMap ? $i("envMapTexelToLinear", n.envMapEncoding) : "",
            n.emissiveMap
              ? $i("emissiveMapTexelToLinear", n.emissiveMapEncoding)
              : "",
            n.lightMap ? $i("lightMapTexelToLinear", n.lightMapEncoding) : "",
            er("linearToOutputTexel", n.outputEncoding),
            n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
            "\n",
          ]
            .filter(nr)
            .join("\n"))),
        (a = ar(a)),
        (a = ir(a, n)),
        (a = rr(a, n)),
        (o = ar(o)),
        (o = ir(o, n)),
        (o = rr(o, n)),
        (a = hr(a)),
        (o = hr(o)),
        n.isWebGL2 &&
          !0 !== n.isRawShaderMaterial &&
          ((x = "#version 300 es\n"),
          (g =
            [
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            g),
          (v =
            [
              "#define varying in",
              n.glslVersion === P ? "" : "out highp vec4 pc_fragColor;",
              n.glslVersion === P ? "" : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            v));
      const y = x + v + o,
        _ = Zi(r, 35633, x + g + a),
        w = Zi(r, 35632, y);
      if (
        (r.attachShader(f, _),
        r.attachShader(f, w),
        void 0 !== n.index0AttributeName
          ? r.bindAttribLocation(f, 0, n.index0AttributeName)
          : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"),
        r.linkProgram(f),
        e.debug.checkShaderErrors)
      ) {
        const e = r.getProgramInfoLog(f).trim(),
          t = r.getShaderInfoLog(_).trim(),
          n = r.getShaderInfoLog(w).trim();
        let i = !0,
          s = !0;
        if (!1 === r.getProgramParameter(f, 35714)) {
          i = !1;
          const t = Qi(r, _, "vertex"),
            n = Qi(r, w, "fragment");
          console.error(
            "THREE.WebGLProgram: shader error: ",
            r.getError(),
            "35715",
            r.getProgramParameter(f, 35715),
            "gl.getProgramInfoLog",
            e,
            t,
            n
          );
        } else
          "" !== e
            ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e)
            : ("" !== t && "" !== n) || (s = !1);
        s &&
          (this.diagnostics = {
            runnable: i,
            programLog: e,
            vertexShader: { log: t, prefix: g },
            fragmentShader: { log: n, prefix: v },
          });
      }
      let b, M;
      return (
        r.deleteShader(_),
        r.deleteShader(w),
        (this.getUniforms = function () {
          return void 0 === b && (b = new Yi(r, f)), b;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === M &&
              (M = (function (e, t) {
                const n = {},
                  i = e.getProgramParameter(t, 35721);
                for (let r = 0; r < i; r++) {
                  const i = e.getActiveAttrib(t, r).name;
                  n[i] = e.getAttribLocation(t, i);
                }
                return n;
              })(r, f)),
            M
          );
        }),
        (this.destroy = function () {
          i.releaseStatesOfProgram(this),
            r.deleteProgram(f),
            (this.program = void 0);
        }),
        (this.name = n.shaderName),
        (this.id = Ji++),
        (this.cacheKey = t),
        (this.usedTimes = 1),
        (this.program = f),
        (this.vertexShader = _),
        (this.fragmentShader = w),
        this
      );
    }
    function fr(e, t, n, i, r, s) {
      const a = [],
        o = i.isWebGL2,
        l = i.logarithmicDepthBuffer,
        c = i.floatVertexTextures,
        h = i.maxVertexUniforms,
        u = i.vertexTextures;
      let d = i.precision;
      const p = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        },
        m = [
          "precision",
          "isWebGL2",
          "supportsVertexTextures",
          "outputEncoding",
          "instancing",
          "instancingColor",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "envMapCubeUV",
          "lightMap",
          "lightMapEncoding",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoatMap",
          "clearcoatRoughnessMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "combine",
          "vertexColors",
          "vertexAlphas",
          "vertexTangents",
          "vertexUvs",
          "uvsVertexOnly",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "numDirLightShadows",
          "numPointLightShadows",
          "numSpotLightShadows",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "alphaTest",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "sheen",
          "transmissionMap",
        ];
      function f(e) {
        let t;
        return (
          e && e.isTexture
            ? (t = e.encoding)
            : e && e.isWebGLRenderTarget
            ? (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
              ),
              (t = e.texture.encoding))
            : (t = E),
          t
        );
      }
      return {
        getParameters: function (r, a, m, g, v) {
          const x = g.fog,
            y = r.isMeshStandardMaterial ? g.environment : null,
            _ = t.get(r.envMap || y),
            w = p[r.type],
            b = v.isSkinnedMesh
              ? (function (e) {
                  const t = e.skeleton.bones;
                  if (c) return 1024;
                  {
                    const e = h,
                      n = Math.floor((e - 20) / 4),
                      i = Math.min(n, t.length);
                    return i < t.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            t.length +
                            " bones. This GPU supports " +
                            i +
                            "."
                        ),
                        0)
                      : i;
                  }
                })(v)
              : 0;
          let M, S;
          if (
            (null !== r.precision &&
              ((d = i.getMaxPrecision(r.precision)),
              d !== r.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  r.precision,
                  "not supported, using",
                  d,
                  "instead."
                )),
            w)
          ) {
            const e = Cn[w];
            (M = e.vertexShader), (S = e.fragmentShader);
          } else (M = r.vertexShader), (S = r.fragmentShader);
          const T = e.getRenderTarget();
          return {
            isWebGL2: o,
            shaderID: w,
            shaderName: r.type,
            vertexShader: M,
            fragmentShader: S,
            defines: r.defines,
            isRawShaderMaterial: !0 === r.isRawShaderMaterial,
            glslVersion: r.glslVersion,
            precision: d,
            instancing: !0 === v.isInstancedMesh,
            instancingColor:
              !0 === v.isInstancedMesh && null !== v.instanceColor,
            supportsVertexTextures: u,
            outputEncoding: null !== T ? f(T.texture) : e.outputEncoding,
            map: !!r.map,
            mapEncoding: f(r.map),
            matcap: !!r.matcap,
            matcapEncoding: f(r.matcap),
            envMap: !!_,
            envMapMode: _ && _.mapping,
            envMapEncoding: f(_),
            envMapCubeUV: !!_ && (306 === _.mapping || 307 === _.mapping),
            lightMap: !!r.lightMap,
            lightMapEncoding: f(r.lightMap),
            aoMap: !!r.aoMap,
            emissiveMap: !!r.emissiveMap,
            emissiveMapEncoding: f(r.emissiveMap),
            bumpMap: !!r.bumpMap,
            normalMap: !!r.normalMap,
            objectSpaceNormalMap: 1 === r.normalMapType,
            tangentSpaceNormalMap: 0 === r.normalMapType,
            clearcoatMap: !!r.clearcoatMap,
            clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
            clearcoatNormalMap: !!r.clearcoatNormalMap,
            displacementMap: !!r.displacementMap,
            roughnessMap: !!r.roughnessMap,
            metalnessMap: !!r.metalnessMap,
            specularMap: !!r.specularMap,
            alphaMap: !!r.alphaMap,
            gradientMap: !!r.gradientMap,
            sheen: !!r.sheen,
            transmissionMap: !!r.transmissionMap,
            combine: r.combine,
            vertexTangents: r.normalMap && r.vertexTangents,
            vertexColors: r.vertexColors,
            vertexAlphas:
              !0 === r.vertexColors &&
              v.geometry &&
              v.geometry.attributes.color &&
              4 === v.geometry.attributes.color.itemSize,
            vertexUvs: !!(
              r.map ||
              r.bumpMap ||
              r.normalMap ||
              r.specularMap ||
              r.alphaMap ||
              r.emissiveMap ||
              r.roughnessMap ||
              r.metalnessMap ||
              r.clearcoatMap ||
              r.clearcoatRoughnessMap ||
              r.clearcoatNormalMap ||
              r.displacementMap ||
              r.transmissionMap
            ),
            uvsVertexOnly: !(
              r.map ||
              r.bumpMap ||
              r.normalMap ||
              r.specularMap ||
              r.alphaMap ||
              r.emissiveMap ||
              r.roughnessMap ||
              r.metalnessMap ||
              r.clearcoatNormalMap ||
              r.transmissionMap ||
              !r.displacementMap
            ),
            fog: !!x,
            useFog: r.fog,
            fogExp2: x && x.isFogExp2,
            flatShading: !!r.flatShading,
            sizeAttenuation: r.sizeAttenuation,
            logarithmicDepthBuffer: l,
            skinning: r.skinning && b > 0,
            maxBones: b,
            useVertexTexture: c,
            morphTargets: r.morphTargets,
            morphNormals: r.morphNormals,
            numDirLights: a.directional.length,
            numPointLights: a.point.length,
            numSpotLights: a.spot.length,
            numRectAreaLights: a.rectArea.length,
            numHemiLights: a.hemi.length,
            numDirLightShadows: a.directionalShadowMap.length,
            numPointLightShadows: a.pointShadowMap.length,
            numSpotLightShadows: a.spotShadowMap.length,
            numClippingPlanes: s.numPlanes,
            numClipIntersection: s.numIntersection,
            dithering: r.dithering,
            shadowMapEnabled: e.shadowMap.enabled && m.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: r.toneMapped ? e.toneMapping : 0,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: r.premultipliedAlpha,
            alphaTest: r.alphaTest,
            doubleSided: 2 === r.side,
            flipSided: 1 === r.side,
            depthPacking: void 0 !== r.depthPacking && r.depthPacking,
            index0AttributeName: r.index0AttributeName,
            extensionDerivatives: r.extensions && r.extensions.derivatives,
            extensionFragDepth: r.extensions && r.extensions.fragDepth,
            extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
            extensionShaderTextureLOD:
              r.extensions && r.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: o || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: o || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              o || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: r.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (t) {
          const n = [];
          if (
            (t.shaderID
              ? n.push(t.shaderID)
              : (n.push(t.fragmentShader), n.push(t.vertexShader)),
            void 0 !== t.defines)
          )
            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
          if (!1 === t.isRawShaderMaterial) {
            for (let e = 0; e < m.length; e++) n.push(t[m[e]]);
            n.push(e.outputEncoding), n.push(e.gammaFactor);
          }
          return n.push(t.customProgramCacheKey), n.join();
        },
        getUniforms: function (e) {
          const t = p[e.type];
          let n;
          if (t) {
            const e = Cn[t];
            n = pn.clone(e.uniforms);
          } else n = e.uniforms;
          return n;
        },
        acquireProgram: function (t, n) {
          let i;
          for (let e = 0, t = a.length; e < t; e++) {
            const t = a[e];
            if (t.cacheKey === n) {
              (i = t), ++i.usedTimes;
              break;
            }
          }
          return void 0 === i && ((i = new mr(e, n, t, r)), a.push(i)), i;
        },
        releaseProgram: function (e) {
          if (0 == --e.usedTimes) {
            const t = a.indexOf(e);
            (a[t] = a[a.length - 1]), a.pop(), e.destroy();
          }
        },
        programs: a,
      };
    }
    function gr() {
      let e = new WeakMap();
      return {
        get: function (t) {
          let n = e.get(t);
          return void 0 === n && ((n = {}), e.set(t, n)), n;
        },
        remove: function (t) {
          e.delete(t);
        },
        update: function (t, n, i) {
          e.get(t)[n] = i;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    function vr(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.program !== t.program
        ? e.program.id - t.program.id
        : e.material.id !== t.material.id
        ? e.material.id - t.material.id
        : e.z !== t.z
        ? e.z - t.z
        : e.id - t.id;
    }
    function xr(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.z !== t.z
        ? t.z - e.z
        : e.id - t.id;
    }
    function yr(e) {
      const t = [];
      let n = 0;
      const i = [],
        r = [],
        s = { id: -1 };
      function a(i, r, a, o, l, c) {
        let h = t[n];
        const u = e.get(a);
        return (
          void 0 === h
            ? ((h = {
                id: i.id,
                object: i,
                geometry: r,
                material: a,
                program: u.program || s,
                groupOrder: o,
                renderOrder: i.renderOrder,
                z: l,
                group: c,
              }),
              (t[n] = h))
            : ((h.id = i.id),
              (h.object = i),
              (h.geometry = r),
              (h.material = a),
              (h.program = u.program || s),
              (h.groupOrder = o),
              (h.renderOrder = i.renderOrder),
              (h.z = l),
              (h.group = c)),
          n++,
          h
        );
      }
      return {
        opaque: i,
        transparent: r,
        init: function () {
          (n = 0), (i.length = 0), (r.length = 0);
        },
        push: function (e, t, n, s, o, l) {
          const c = a(e, t, n, s, o, l);
          (!0 === n.transparent ? r : i).push(c);
        },
        unshift: function (e, t, n, s, o, l) {
          const c = a(e, t, n, s, o, l);
          (!0 === n.transparent ? r : i).unshift(c);
        },
        finish: function () {
          for (let e = n, i = t.length; e < i; e++) {
            const n = t[e];
            if (null === n.id) break;
            (n.id = null),
              (n.object = null),
              (n.geometry = null),
              (n.material = null),
              (n.program = null),
              (n.group = null);
          }
        },
        sort: function (e, t) {
          i.length > 1 && i.sort(e || vr), r.length > 1 && r.sort(t || xr);
        },
      };
    }
    function _r(e) {
      let t = new WeakMap();
      return {
        get: function (n, i) {
          let r;
          return (
            !1 === t.has(n)
              ? ((r = new yr(e)), t.set(n, [r]))
              : i >= t.get(n).length
              ? ((r = new yr(e)), t.get(n).push(r))
              : (r = t.get(n)[i]),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function wr() {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let n;
          switch (t.type) {
            case "DirectionalLight":
              n = { direction: new te(), color: new At() };
              break;
            case "SpotLight":
              n = {
                position: new te(),
                direction: new te(),
                color: new At(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              n = {
                position: new te(),
                color: new At(),
                distance: 0,
                decay: 0,
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new te(),
                skyColor: new At(),
                groundColor: new At(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new At(),
                position: new te(),
                halfWidth: new te(),
                halfHeight: new te(),
              };
          }
          return (e[t.id] = n), n;
        },
      };
    }
    let br = 0;
    function Mr(e, t) {
      return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
    }
    function Sr(e, t) {
      const n = new wr(),
        i = (function () {
          const e = {};
          return {
            get: function (t) {
              if (void 0 !== e[t.id]) return e[t.id];
              let n;
              switch (t.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new j(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new j(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (e[t.id] = n), n;
            },
          };
        })(),
        r = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let e = 0; e < 9; e++) r.probe.push(new te());
      const s = new te(),
        a = new Ie(),
        o = new Ie();
      return {
        setup: function (s) {
          let a = 0,
            o = 0,
            l = 0;
          for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
          let c = 0,
            h = 0,
            u = 0,
            d = 0,
            p = 0,
            m = 0,
            f = 0,
            g = 0;
          s.sort(Mr);
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e],
              v = t.color,
              x = t.intensity,
              y = t.distance,
              _ = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
            if (t.isAmbientLight)
              (a += v.r * x), (o += v.g * x), (l += v.b * x);
            else if (t.isLightProbe)
              for (let e = 0; e < 9; e++)
                r.probe[e].addScaledVector(t.sh.coefficients[e], x);
            else if (t.isDirectionalLight) {
              const e = n.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = i.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (r.directionalShadow[c] = n),
                  (r.directionalShadowMap[c] = _),
                  (r.directionalShadowMatrix[c] = t.shadow.matrix),
                  m++;
              }
              (r.directional[c] = e), c++;
            } else if (t.isSpotLight) {
              const e = n.get(t);
              if (
                (e.position.setFromMatrixPosition(t.matrixWorld),
                e.color.copy(v).multiplyScalar(x),
                (e.distance = y),
                (e.coneCos = Math.cos(t.angle)),
                (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = i.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (r.spotShadow[u] = n),
                  (r.spotShadowMap[u] = _),
                  (r.spotShadowMatrix[u] = t.shadow.matrix),
                  g++;
              }
              (r.spot[u] = e), u++;
            } else if (t.isRectAreaLight) {
              const e = n.get(t);
              e.color.copy(v).multiplyScalar(x),
                e.halfWidth.set(0.5 * t.width, 0, 0),
                e.halfHeight.set(0, 0.5 * t.height, 0),
                (r.rectArea[d] = e),
                d++;
            } else if (t.isPointLight) {
              const e = n.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity),
                (e.distance = t.distance),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = i.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (n.shadowCameraNear = e.camera.near),
                  (n.shadowCameraFar = e.camera.far),
                  (r.pointShadow[h] = n),
                  (r.pointShadowMap[h] = _),
                  (r.pointShadowMatrix[h] = t.shadow.matrix),
                  f++;
              }
              (r.point[h] = e), h++;
            } else if (t.isHemisphereLight) {
              const e = n.get(t);
              e.skyColor.copy(t.color).multiplyScalar(x),
                e.groundColor.copy(t.groundColor).multiplyScalar(x),
                (r.hemi[p] = e),
                p++;
            }
          }
          d > 0 &&
            (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
              ? ((r.rectAreaLTC1 = Rn.LTC_FLOAT_1),
                (r.rectAreaLTC2 = Rn.LTC_FLOAT_2))
              : !0 === e.has("OES_texture_half_float_linear")
              ? ((r.rectAreaLTC1 = Rn.LTC_HALF_1),
                (r.rectAreaLTC2 = Rn.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (r.ambient[0] = a),
            (r.ambient[1] = o),
            (r.ambient[2] = l);
          const v = r.hash;
          (v.directionalLength === c &&
            v.pointLength === h &&
            v.spotLength === u &&
            v.rectAreaLength === d &&
            v.hemiLength === p &&
            v.numDirectionalShadows === m &&
            v.numPointShadows === f &&
            v.numSpotShadows === g) ||
            ((r.directional.length = c),
            (r.spot.length = u),
            (r.rectArea.length = d),
            (r.point.length = h),
            (r.hemi.length = p),
            (r.directionalShadow.length = m),
            (r.directionalShadowMap.length = m),
            (r.pointShadow.length = f),
            (r.pointShadowMap.length = f),
            (r.spotShadow.length = g),
            (r.spotShadowMap.length = g),
            (r.directionalShadowMatrix.length = m),
            (r.pointShadowMatrix.length = f),
            (r.spotShadowMatrix.length = g),
            (v.directionalLength = c),
            (v.pointLength = h),
            (v.spotLength = u),
            (v.rectAreaLength = d),
            (v.hemiLength = p),
            (v.numDirectionalShadows = m),
            (v.numPointShadows = f),
            (v.numSpotShadows = g),
            (r.version = br++));
        },
        setupView: function (e, t) {
          let n = 0,
            i = 0,
            l = 0,
            c = 0,
            h = 0;
          const u = t.matrixWorldInverse;
          for (let t = 0, d = e.length; t < d; t++) {
            const d = e[t];
            if (d.isDirectionalLight) {
              const e = r.directional[n];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(s),
                e.direction.transformDirection(u),
                n++;
            } else if (d.isSpotLight) {
              const e = r.spot[l];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                e.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(s),
                e.direction.transformDirection(u),
                l++;
            } else if (d.isRectAreaLight) {
              const e = r.rectArea[c];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                o.identity(),
                a.copy(d.matrixWorld),
                a.premultiply(u),
                o.extractRotation(a),
                e.halfWidth.set(0.5 * d.width, 0, 0),
                e.halfHeight.set(0, 0.5 * d.height, 0),
                e.halfWidth.applyMatrix4(o),
                e.halfHeight.applyMatrix4(o),
                c++;
            } else if (d.isPointLight) {
              const e = r.point[i];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                i++;
            } else if (d.isHemisphereLight) {
              const e = r.hemi[h];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                e.direction.transformDirection(u),
                e.direction.normalize(),
                h++;
            }
          }
        },
        state: r,
      };
    }
    function Tr(e, t) {
      const n = new Sr(e, t),
        i = [],
        r = [];
      return {
        init: function () {
          (i.length = 0), (r.length = 0);
        },
        state: { lightsArray: i, shadowsArray: r, lights: n },
        setupLights: function () {
          n.setup(i);
        },
        setupLightsView: function (e) {
          n.setupView(i, e);
        },
        pushLight: function (e) {
          i.push(e);
        },
        pushShadow: function (e) {
          r.push(e);
        },
      };
    }
    function Er(e, t) {
      let n = new WeakMap();
      return {
        get: function (i, r = 0) {
          let s;
          return (
            !1 === n.has(i)
              ? ((s = new Tr(e, t)), n.set(i, [s]))
              : r >= n.get(i).length
              ? ((s = new Tr(e, t)), n.get(i).push(s))
              : (s = n.get(i)[r]),
            s
          );
        },
        dispose: function () {
          n = new WeakMap();
        },
      };
    }
    class Ar extends _t {
      constructor(e) {
        super(),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = 3200),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.depthPacking = e.depthPacking),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          this
        );
      }
    }
    Ar.prototype.isMeshDepthMaterial = !0;
    class Lr extends _t {
      constructor(e) {
        super(),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new te()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.referencePosition.copy(e.referencePosition),
          (this.nearDistance = e.nearDistance),
          (this.farDistance = e.farDistance),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          this
        );
      }
    }
    function Rr(e, t, n) {
      let i = new Sn();
      const r = new j(),
        s = new j(),
        o = new Q(),
        l = [],
        h = [],
        u = {},
        d = n.maxTextureSize,
        p = { 0: 1, 1: 0, 2: 2 },
        m = new mn({
          defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new j() },
            radius: { value: 4 },
          },
          vertexShader:
            "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader:
            "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
        }),
        f = m.clone();
      f.defines.HORIZONTAL_PASS = 1;
      const g = new Vt();
      g.setAttribute(
        "position",
        new Pt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      const x = new ln(g, m),
        y = this;
      function _(n, i) {
        const r = t.update(x);
        (m.uniforms.shadow_pass.value = n.map.texture),
          (m.uniforms.resolution.value = n.mapSize),
          (m.uniforms.radius.value = n.radius),
          e.setRenderTarget(n.mapPass),
          e.clear(),
          e.renderBufferDirect(i, null, r, m, x, null),
          (f.uniforms.shadow_pass.value = n.mapPass.texture),
          (f.uniforms.resolution.value = n.mapSize),
          (f.uniforms.radius.value = n.radius),
          e.setRenderTarget(n.map),
          e.clear(),
          e.renderBufferDirect(i, null, r, f, x, null);
      }
      function w(e, t, n) {
        const i = (e << 0) | (t << 1) | (n << 2);
        let r = l[i];
        return (
          void 0 === r &&
            ((r = new Ar({ depthPacking: 3201, morphTargets: e, skinning: t })),
            (l[i] = r)),
          r
        );
      }
      function b(e, t, n) {
        const i = (e << 0) | (t << 1) | (n << 2);
        let r = h[i];
        return (
          void 0 === r &&
            ((r = new Lr({ morphTargets: e, skinning: t })), (h[i] = r)),
          r
        );
      }
      function M(t, n, i, r, s, a, o) {
        let l = null,
          c = w,
          h = t.customDepthMaterial;
        if (
          (!0 === r.isPointLight && ((c = b), (h = t.customDistanceMaterial)),
          void 0 === h)
        ) {
          let e = !1;
          !0 === i.morphTargets &&
            (e =
              n.morphAttributes &&
              n.morphAttributes.position &&
              n.morphAttributes.position.length > 0);
          let r = !1;
          !0 === t.isSkinnedMesh &&
            (!0 === i.skinning
              ? (r = !0)
              : console.warn(
                  "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                  t
                )),
            (l = c(e, r, !0 === t.isInstancedMesh));
        } else l = h;
        if (
          e.localClippingEnabled &&
          !0 === i.clipShadows &&
          0 !== i.clippingPlanes.length
        ) {
          const e = l.uuid,
            t = i.uuid;
          let n = u[e];
          void 0 === n && ((n = {}), (u[e] = n));
          let r = n[t];
          void 0 === r && ((r = l.clone()), (n[t] = r)), (l = r);
        }
        return (
          (l.visible = i.visible),
          (l.wireframe = i.wireframe),
          (l.side =
            3 === o
              ? null !== i.shadowSide
                ? i.shadowSide
                : i.side
              : null !== i.shadowSide
              ? i.shadowSide
              : p[i.side]),
          (l.clipShadows = i.clipShadows),
          (l.clippingPlanes = i.clippingPlanes),
          (l.clipIntersection = i.clipIntersection),
          (l.wireframeLinewidth = i.wireframeLinewidth),
          (l.linewidth = i.linewidth),
          !0 === r.isPointLight &&
            !0 === l.isMeshDistanceMaterial &&
            (l.referencePosition.setFromMatrixPosition(r.matrixWorld),
            (l.nearDistance = s),
            (l.farDistance = a)),
          l
        );
      }
      function S(n, r, s, a, o) {
        if (!1 === n.visible) return;
        if (
          n.layers.test(r.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && 3 === o)) &&
          (!n.frustumCulled || i.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            s.matrixWorldInverse,
            n.matrixWorld
          );
          const i = t.update(n),
            r = n.material;
          if (Array.isArray(r)) {
            const t = i.groups;
            for (let l = 0, c = t.length; l < c; l++) {
              const c = t[l],
                h = r[c.materialIndex];
              if (h && h.visible) {
                const t = M(n, i, h, a, s.near, s.far, o);
                e.renderBufferDirect(s, null, i, t, n, c);
              }
            }
          } else if (r.visible) {
            const t = M(n, i, r, a, s.near, s.far, o);
            e.renderBufferDirect(s, null, i, t, n, null);
          }
        }
        const l = n.children;
        for (let e = 0, t = l.length; e < t; e++) S(l[e], r, s, a, o);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = 1),
        (this.render = function (t, n, l) {
          if (!1 === y.enabled) return;
          if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
          if (0 === t.length) return;
          const h = e.getRenderTarget(),
            u = e.getActiveCubeFace(),
            p = e.getActiveMipmapLevel(),
            m = e.state;
          m.setBlending(0),
            m.buffers.color.setClear(1, 1, 1, 1),
            m.buffers.depth.setTest(!0),
            m.setScissorTest(!1);
          for (let h = 0, u = t.length; h < u; h++) {
            const u = t[h],
              p = u.shadow;
            if (void 0 === p) {
              console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
              continue;
            }
            if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
            r.copy(p.mapSize);
            const f = p.getFrameExtents();
            if (
              (r.multiply(f),
              s.copy(p.mapSize),
              (r.x > d || r.y > d) &&
                (r.x > d &&
                  ((s.x = Math.floor(d / f.x)),
                  (r.x = s.x * f.x),
                  (p.mapSize.x = s.x)),
                r.y > d &&
                  ((s.y = Math.floor(d / f.y)),
                  (r.y = s.y * f.y),
                  (p.mapSize.y = s.y))),
              null === p.map && !p.isPointLightShadow && 3 === this.type)
            ) {
              const e = { minFilter: c, magFilter: c, format: v };
              (p.map = new $(r.x, r.y, e)),
                (p.map.texture.name = u.name + ".shadowMap"),
                (p.mapPass = new $(r.x, r.y, e)),
                p.camera.updateProjectionMatrix();
            }
            if (null === p.map) {
              const e = { minFilter: a, magFilter: a, format: v };
              (p.map = new $(r.x, r.y, e)),
                (p.map.texture.name = u.name + ".shadowMap"),
                p.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(p.map), e.clear();
            const g = p.getViewportCount();
            for (let e = 0; e < g; e++) {
              const t = p.getViewport(e);
              o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                m.viewport(o),
                p.updateMatrices(u, e),
                (i = p.getFrustum()),
                S(n, l, p.camera, u, this.type);
            }
            p.isPointLightShadow || 3 !== this.type || _(p, l),
              (p.needsUpdate = !1);
          }
          (y.needsUpdate = !1), e.setRenderTarget(h, u, p);
        });
    }
    function Cr(e, t, i) {
      const r = i.isWebGL2,
        s = new (function () {
          let t = !1;
          const n = new Q();
          let i = null;
          const r = new Q(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || t || (e.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t, i, s, a, o) {
              !0 === o && ((t *= a), (i *= a), (s *= a)),
                n.set(t, i, s, a),
                !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n));
            },
            reset: function () {
              (t = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        })(),
        a = new (function () {
          let t = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (e) {
              e ? z(2929) : H(2929);
            },
            setMask: function (i) {
              n === i || t || (e.depthMask(i), (n = i));
            },
            setFunc: function (t) {
              if (i !== t) {
                if (t)
                  switch (t) {
                    case 0:
                      e.depthFunc(512);
                      break;
                    case 1:
                      e.depthFunc(519);
                      break;
                    case 2:
                      e.depthFunc(513);
                      break;
                    case 3:
                      e.depthFunc(515);
                      break;
                    case 4:
                      e.depthFunc(514);
                      break;
                    case 5:
                      e.depthFunc(518);
                      break;
                    case 6:
                      e.depthFunc(516);
                      break;
                    case 7:
                      e.depthFunc(517);
                      break;
                    default:
                      e.depthFunc(515);
                  }
                else e.depthFunc(515);
                i = t;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              r !== t && (e.clearDepth(t), (r = t));
            },
            reset: function () {
              (t = !1), (n = null), (i = null), (r = null);
            },
          };
        })(),
        o = new (function () {
          let t = !1,
            n = null,
            i = null,
            r = null,
            s = null,
            a = null,
            o = null,
            l = null,
            c = null;
          return {
            setTest: function (e) {
              t || (e ? z(2960) : H(2960));
            },
            setMask: function (i) {
              n === i || t || (e.stencilMask(i), (n = i));
            },
            setFunc: function (t, n, a) {
              (i === t && r === n && s === a) ||
                (e.stencilFunc(t, n, a), (i = t), (r = n), (s = a));
            },
            setOp: function (t, n, i) {
              (a === t && o === n && l === i) ||
                (e.stencilOp(t, n, i), (a = t), (o = n), (l = i));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              c !== t && (e.clearStencil(t), (c = t));
            },
            reset: function () {
              (t = !1),
                (n = null),
                (i = null),
                (r = null),
                (s = null),
                (a = null),
                (o = null),
                (l = null),
                (c = null);
            },
          };
        })();
      let l = {},
        c = null,
        h = {},
        u = null,
        d = !1,
        p = null,
        m = null,
        f = null,
        g = null,
        v = null,
        x = null,
        y = null,
        _ = !1,
        w = null,
        b = null,
        M = null,
        S = null,
        T = null;
      const E = e.getParameter(35661);
      let A = !1,
        L = 0;
      const R = e.getParameter(7938);
      -1 !== R.indexOf("WebGL")
        ? ((L = parseFloat(/^WebGL (\d)/.exec(R)[1])), (A = L >= 1))
        : -1 !== R.indexOf("OpenGL ES") &&
          ((L = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (A = L >= 2));
      let C = null,
        P = {};
      const I = new Q(0, 0, e.canvas.width, e.canvas.height),
        N = new Q(0, 0, e.canvas.width, e.canvas.height);
      function D(t, n, i) {
        const r = new Uint8Array(4),
          s = e.createTexture();
        e.bindTexture(t, s),
          e.texParameteri(t, 10241, 9728),
          e.texParameteri(t, 10240, 9728);
        for (let t = 0; t < i; t++)
          e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return s;
      }
      const O = {};
      function z(t) {
        !0 !== l[t] && (e.enable(t), (l[t] = !0));
      }
      function H(t) {
        !1 !== l[t] && (e.disable(t), (l[t] = !1));
      }
      (O[3553] = D(3553, 3553, 1)),
        (O[34067] = D(34067, 34069, 6)),
        s.setClear(0, 0, 0, 1),
        a.setClear(1),
        o.setClear(0),
        z(2929),
        a.setFunc(3),
        G(!1),
        k(1),
        z(2884),
        U(0);
      const F = { [n]: 32774, 101: 32778, 102: 32779 };
      if (r) (F[103] = 32775), (F[104] = 32776);
      else {
        const e = t.get("EXT_blend_minmax");
        null !== e && ((F[103] = e.MIN_EXT), (F[104] = e.MAX_EXT));
      }
      const B = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773,
      };
      function U(t, i, r, s, a, o, l, c) {
        if (0 !== t) {
          if ((!1 === d && (z(3042), (d = !0)), 5 === t))
            (a = a || i),
              (o = o || r),
              (l = l || s),
              (i === m && a === v) ||
                (e.blendEquationSeparate(F[i], F[a]), (m = i), (v = a)),
              (r === f && s === g && o === x && l === y) ||
                (e.blendFuncSeparate(B[r], B[s], B[o], B[l]),
                (f = r),
                (g = s),
                (x = o),
                (y = l)),
              (p = t),
              (_ = null);
          else if (t !== p || c !== _) {
            if (
              ((m === n && v === n) ||
                (e.blendEquation(32774), (m = n), (v = n)),
              c)
            )
              switch (t) {
                case 1:
                  e.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  e.blendFunc(1, 1);
                  break;
                case 3:
                  e.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  e.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
            else
              switch (t) {
                case 1:
                  e.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  e.blendFunc(770, 1);
                  break;
                case 3:
                  e.blendFunc(0, 769);
                  break;
                case 4:
                  e.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
            (f = null), (g = null), (x = null), (y = null), (p = t), (_ = c);
          }
        } else !0 === d && (H(3042), (d = !1));
      }
      function G(t) {
        w !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (w = t));
      }
      function k(t) {
        0 !== t
          ? (z(2884),
            t !== b &&
              (1 === t
                ? e.cullFace(1029)
                : 2 === t
                ? e.cullFace(1028)
                : e.cullFace(1032)))
          : H(2884),
          (b = t);
      }
      function V(t, n, i) {
        t
          ? (z(32823),
            (S === n && T === i) || (e.polygonOffset(n, i), (S = n), (T = i)))
          : H(32823);
      }
      function W(t) {
        void 0 === t && (t = 33984 + E - 1),
          C !== t && (e.activeTexture(t), (C = t));
      }
      return {
        buffers: { color: s, depth: a, stencil: o },
        enable: z,
        disable: H,
        bindFramebuffer: function (t, n) {
          null === n && null !== c && (n = c),
            h[t] !== n &&
              (e.bindFramebuffer(t, n),
              (h[t] = n),
              r &&
                (36009 === t && (h[36160] = n), 36160 === t && (h[36009] = n)));
        },
        bindXRFramebuffer: function (t) {
          t !== c && (e.bindFramebuffer(36160, t), (c = t));
        },
        useProgram: function (t) {
          return u !== t && (e.useProgram(t), (u = t), !0);
        },
        setBlending: U,
        setMaterial: function (e, t) {
          2 === e.side ? H(2884) : z(2884);
          let n = 1 === e.side;
          t && (n = !n),
            G(n),
            1 === e.blending && !1 === e.transparent
              ? U(0)
              : U(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha
                ),
            a.setFunc(e.depthFunc),
            a.setTest(e.depthTest),
            a.setMask(e.depthWrite),
            s.setMask(e.colorWrite);
          const i = e.stencilWrite;
          o.setTest(i),
            i &&
              (o.setMask(e.stencilWriteMask),
              o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
              o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            V(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage ? z(32926) : H(32926);
        },
        setFlipSided: G,
        setCullFace: k,
        setLineWidth: function (t) {
          t !== M && (A && e.lineWidth(t), (M = t));
        },
        setPolygonOffset: V,
        setScissorTest: function (e) {
          e ? z(3089) : H(3089);
        },
        activeTexture: W,
        bindTexture: function (t, n) {
          null === C && W();
          let i = P[C];
          void 0 === i && ((i = { type: void 0, texture: void 0 }), (P[C] = i)),
            (i.type === t && i.texture === n) ||
              (e.bindTexture(t, n || O[t]), (i.type = t), (i.texture = n));
        },
        unbindTexture: function () {
          const t = P[C];
          void 0 !== t &&
            void 0 !== t.type &&
            (e.bindTexture(t.type, null),
            (t.type = void 0),
            (t.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            e.compressedTexImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage2D: function () {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage3D: function () {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        scissor: function (t) {
          !1 === I.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), I.copy(t));
        },
        viewport: function (t) {
          !1 === N.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), N.copy(t));
        },
        reset: function () {
          e.disable(3042),
            e.disable(2884),
            e.disable(2929),
            e.disable(32823),
            e.disable(3089),
            e.disable(2960),
            e.disable(32926),
            e.blendEquation(32774),
            e.blendFunc(1, 0),
            e.blendFuncSeparate(1, 0, 1, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(513),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(519, 0, 4294967295),
            e.stencilOp(7680, 7680, 7680),
            e.clearStencil(0),
            e.cullFace(1029),
            e.frontFace(2305),
            e.polygonOffset(0, 0),
            e.activeTexture(33984),
            e.bindFramebuffer(36160, null),
            !0 === r &&
              (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            (l = {}),
            (C = null),
            (P = {}),
            (c = null),
            (h = {}),
            (u = null),
            (d = !1),
            (p = null),
            (m = null),
            (f = null),
            (g = null),
            (v = null),
            (x = null),
            (y = null),
            (_ = !1),
            (w = null),
            (b = null),
            (M = null),
            (S = null),
            (T = null),
            I.set(0, 0, e.canvas.width, e.canvas.height),
            N.set(0, 0, e.canvas.width, e.canvas.height),
            s.reset(),
            a.reset(),
            o.reset();
        },
      };
    }
    function Pr(e, t, n, _, w, b, M) {
      const S = w.isWebGL2,
        T = w.maxTextures,
        E = w.maxCubemapSize,
        A = w.maxTextureSize,
        L = w.maxSamples,
        R = new WeakMap();
      let C,
        P = !1;
      try {
        P =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (e) {}
      function I(e, t) {
        return P
          ? new OffscreenCanvas(e, t)
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function N(e, t, n, i) {
        let r = 1;
        if (
          ((e.width > i || e.height > i) &&
            (r = i / Math.max(e.width, e.height)),
          r < 1 || !0 === t)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              e instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              e instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const i = t ? V : Math.floor,
              s = i(r * e.width),
              a = i(r * e.height);
            void 0 === C && (C = I(s, a));
            const o = n ? I(s, a) : C;
            return (
              (o.width = s),
              (o.height = a),
              o.getContext("2d").drawImage(e, 0, 0, s, a),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  e.width +
                  "x" +
                  e.height +
                  ") to (" +
                  s +
                  "x" +
                  a +
                  ")."
              ),
              o
            );
          }
          return (
            "data" in e &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  e.width +
                  "x" +
                  e.height +
                  ")."
              ),
            e
          );
        }
        return e;
      }
      function D(e) {
        return G(e.width) && G(e.height);
      }
      function O(e, t) {
        return e.generateMipmaps && t && e.minFilter !== a && e.minFilter !== c;
      }
      function z(t, n, i, r) {
        e.generateMipmap(t),
          (_.get(n).__maxMipLevel = Math.log2(Math.max(i, r)));
      }
      function H(n, i, r) {
        if (!1 === S) return i;
        if (null !== n) {
          if (void 0 !== e[n]) return e[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        let s = i;
        return (
          6403 === i &&
            (5126 === r && (s = 33326),
            5131 === r && (s = 33325),
            5121 === r && (s = 33321)),
          6407 === i &&
            (5126 === r && (s = 34837),
            5131 === r && (s = 34843),
            5121 === r && (s = 32849)),
          6408 === i &&
            (5126 === r && (s = 34836),
            5131 === r && (s = 34842),
            5121 === r && (s = 32856)),
          (33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s) ||
            t.get("EXT_color_buffer_float"),
          s
        );
      }
      function F(e) {
        return e === a || e === o || e === l ? 9728 : 9729;
      }
      function B(t) {
        const n = t.target;
        n.removeEventListener("dispose", B),
          (function (t) {
            const n = _.get(t);
            void 0 !== n.__webglInit &&
              (e.deleteTexture(n.__webglTexture), _.remove(t));
          })(n),
          n.isVideoTexture && R.delete(n),
          M.memory.textures--;
      }
      function U(t) {
        const n = t.target;
        n.removeEventListener("dispose", U),
          (function (t) {
            const n = t.texture,
              i = _.get(t),
              r = _.get(n);
            if (t) {
              if (
                (void 0 !== r.__webglTexture &&
                  e.deleteTexture(r.__webglTexture),
                t.depthTexture && t.depthTexture.dispose(),
                t.isWebGLCubeRenderTarget)
              )
                for (let t = 0; t < 6; t++)
                  e.deleteFramebuffer(i.__webglFramebuffer[t]),
                    i.__webglDepthbuffer &&
                      e.deleteRenderbuffer(i.__webglDepthbuffer[t]);
              else
                e.deleteFramebuffer(i.__webglFramebuffer),
                  i.__webglDepthbuffer &&
                    e.deleteRenderbuffer(i.__webglDepthbuffer),
                  i.__webglMultisampledFramebuffer &&
                    e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                  i.__webglColorRenderbuffer &&
                    e.deleteRenderbuffer(i.__webglColorRenderbuffer),
                  i.__webglDepthRenderbuffer &&
                    e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
              _.remove(n), _.remove(t);
            }
          })(n),
          M.memory.textures--;
      }
      let k = 0;
      function W(e, t) {
        const i = _.get(e);
        if (
          (e.isVideoTexture &&
            (function (e) {
              const t = M.render.frame;
              R.get(e) !== t && (R.set(e, t), e.update());
            })(e),
          e.version > 0 && i.__version !== e.version)
        ) {
          const n = e.image;
          if (void 0 === n)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== n.complete) return void J(i, e, t);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture);
      }
      function j(t, i) {
        const r = _.get(t);
        t.version > 0 && r.__version !== t.version
          ? (function (t, i, r) {
              if (6 !== i.image.length) return;
              Z(t, i),
                n.activeTexture(33984 + r),
                n.bindTexture(34067, t.__webglTexture),
                e.pixelStorei(37440, i.flipY),
                e.pixelStorei(37441, i.premultiplyAlpha),
                e.pixelStorei(3317, i.unpackAlignment),
                e.pixelStorei(37443, 0);
              const s =
                  i &&
                  (i.isCompressedTexture || i.image[0].isCompressedTexture),
                a = i.image[0] && i.image[0].isDataTexture,
                o = [];
              for (let e = 0; e < 6; e++)
                o[e] =
                  s || a
                    ? a
                      ? i.image[e].image
                      : i.image[e]
                    : N(i.image[e], !1, !0, E);
              const l = o[0],
                c = D(l) || S,
                h = b.convert(i.format),
                u = b.convert(i.type),
                d = H(i.internalFormat, h, u);
              let p;
              if ((Y(34067, i, c), s)) {
                for (let e = 0; e < 6; e++) {
                  p = o[e].mipmaps;
                  for (let t = 0; t < p.length; t++) {
                    const r = p[t];
                    i.format !== v && i.format !== g
                      ? null !== h
                        ? n.compressedTexImage2D(
                            34069 + e,
                            t,
                            d,
                            r.width,
                            r.height,
                            0,
                            r.data
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                      : n.texImage2D(
                          34069 + e,
                          t,
                          d,
                          r.width,
                          r.height,
                          0,
                          h,
                          u,
                          r.data
                        );
                  }
                }
                t.__maxMipLevel = p.length - 1;
              } else {
                p = i.mipmaps;
                for (let e = 0; e < 6; e++)
                  if (a) {
                    n.texImage2D(
                      34069 + e,
                      0,
                      d,
                      o[e].width,
                      o[e].height,
                      0,
                      h,
                      u,
                      o[e].data
                    );
                    for (let t = 0; t < p.length; t++) {
                      const i = p[t].image[e].image;
                      n.texImage2D(
                        34069 + e,
                        t + 1,
                        d,
                        i.width,
                        i.height,
                        0,
                        h,
                        u,
                        i.data
                      );
                    }
                  } else {
                    n.texImage2D(34069 + e, 0, d, h, u, o[e]);
                    for (let t = 0; t < p.length; t++) {
                      const i = p[t];
                      n.texImage2D(34069 + e, t + 1, d, h, u, i.image[e]);
                    }
                  }
                t.__maxMipLevel = p.length;
              }
              O(i, c) && z(34067, i, l.width, l.height),
                (t.__version = i.version),
                i.onUpdate && i.onUpdate(i);
            })(r, t, i)
          : (n.activeTexture(33984 + i),
            n.bindTexture(34067, r.__webglTexture));
      }
      const q = { [i]: 10497, [r]: 33071, [s]: 33648 },
        X = {
          [a]: 9728,
          [o]: 9984,
          [l]: 9986,
          [c]: 9729,
          1007: 9985,
          [h]: 9987,
        };
      function Y(n, i, s) {
        if (
          (s
            ? (e.texParameteri(n, 10242, q[i.wrapS]),
              e.texParameteri(n, 10243, q[i.wrapT]),
              (32879 !== n && 35866 !== n) ||
                e.texParameteri(n, 32882, q[i.wrapR]),
              e.texParameteri(n, 10240, X[i.magFilter]),
              e.texParameteri(n, 10241, X[i.minFilter]))
            : (e.texParameteri(n, 10242, 33071),
              e.texParameteri(n, 10243, 33071),
              (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, 33071),
              (i.wrapS === r && i.wrapT === r) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              e.texParameteri(n, 10240, F(i.magFilter)),
              e.texParameteri(n, 10241, F(i.minFilter)),
              i.minFilter !== a &&
                i.minFilter !== c &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                )),
          !0 === t.has("EXT_texture_filter_anisotropic"))
        ) {
          const r = t.get("EXT_texture_filter_anisotropic");
          if (i.type === p && !1 === t.has("OES_texture_float_linear")) return;
          if (
            !1 === S &&
            i.type === m &&
            !1 === t.has("OES_texture_half_float_linear")
          )
            return;
          (i.anisotropy > 1 || _.get(i).__currentAnisotropy) &&
            (e.texParameterf(
              n,
              r.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(i.anisotropy, w.getMaxAnisotropy())
            ),
            (_.get(i).__currentAnisotropy = i.anisotropy));
        }
      }
      function Z(t, n) {
        void 0 === t.__webglInit &&
          ((t.__webglInit = !0),
          n.addEventListener("dispose", B),
          (t.__webglTexture = e.createTexture()),
          M.memory.textures++);
      }
      function J(t, i, s) {
        let o = 3553;
        i.isDataTexture2DArray && (o = 35866),
          i.isDataTexture3D && (o = 32879),
          Z(t, i),
          n.activeTexture(33984 + s),
          n.bindTexture(o, t.__webglTexture),
          e.pixelStorei(37440, i.flipY),
          e.pixelStorei(37441, i.premultiplyAlpha),
          e.pixelStorei(3317, i.unpackAlignment),
          e.pixelStorei(37443, 0);
        const l =
            (function (e) {
              return (
                !S &&
                (e.wrapS !== r ||
                  e.wrapT !== r ||
                  (e.minFilter !== a && e.minFilter !== c))
              );
            })(i) && !1 === D(i.image),
          h = N(i.image, l, !1, A),
          m = D(h) || S,
          _ = b.convert(i.format);
        let w,
          M = b.convert(i.type),
          T = H(i.internalFormat, _, M);
        Y(o, i, m);
        const E = i.mipmaps;
        if (i.isDepthTexture)
          (T = 6402),
            S
              ? (T =
                  i.type === p
                    ? 36012
                    : i.type === d
                    ? 33190
                    : i.type === f
                    ? 35056
                    : 33189)
              : i.type === p &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            i.format === x &&
              6402 === T &&
              i.type !== u &&
              i.type !== d &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (i.type = u),
              (M = b.convert(i.type))),
            i.format === y &&
              6402 === T &&
              ((T = 34041),
              i.type !== f &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (i.type = f),
                (M = b.convert(i.type)))),
            n.texImage2D(3553, 0, T, h.width, h.height, 0, _, M, null);
        else if (i.isDataTexture)
          if (E.length > 0 && m) {
            for (let e = 0, t = E.length; e < t; e++)
              (w = E[e]),
                n.texImage2D(3553, e, T, w.width, w.height, 0, _, M, w.data);
            (i.generateMipmaps = !1), (t.__maxMipLevel = E.length - 1);
          } else
            n.texImage2D(3553, 0, T, h.width, h.height, 0, _, M, h.data),
              (t.__maxMipLevel = 0);
        else if (i.isCompressedTexture) {
          for (let e = 0, t = E.length; e < t; e++)
            (w = E[e]),
              i.format !== v && i.format !== g
                ? null !== _
                  ? n.compressedTexImage2D(
                      3553,
                      e,
                      T,
                      w.width,
                      w.height,
                      0,
                      w.data
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : n.texImage2D(3553, e, T, w.width, w.height, 0, _, M, w.data);
          t.__maxMipLevel = E.length - 1;
        } else if (i.isDataTexture2DArray)
          n.texImage3D(
            35866,
            0,
            T,
            h.width,
            h.height,
            h.depth,
            0,
            _,
            M,
            h.data
          ),
            (t.__maxMipLevel = 0);
        else if (i.isDataTexture3D)
          n.texImage3D(
            32879,
            0,
            T,
            h.width,
            h.height,
            h.depth,
            0,
            _,
            M,
            h.data
          ),
            (t.__maxMipLevel = 0);
        else if (E.length > 0 && m) {
          for (let e = 0, t = E.length; e < t; e++)
            (w = E[e]), n.texImage2D(3553, e, T, _, M, w);
          (i.generateMipmaps = !1), (t.__maxMipLevel = E.length - 1);
        } else n.texImage2D(3553, 0, T, _, M, h), (t.__maxMipLevel = 0);
        O(i, m) && z(o, i, h.width, h.height),
          (t.__version = i.version),
          i.onUpdate && i.onUpdate(i);
      }
      function K(t, i, r, s) {
        const a = i.texture,
          o = b.convert(a.format),
          l = b.convert(a.type),
          c = H(a.internalFormat, o, l);
        32879 === s || 35866 === s
          ? n.texImage3D(s, 0, c, i.width, i.height, i.depth, 0, o, l, null)
          : n.texImage2D(s, 0, c, i.width, i.height, 0, o, l, null),
          n.bindFramebuffer(36160, t),
          e.framebufferTexture2D(36160, r, s, _.get(a).__webglTexture, 0),
          n.bindFramebuffer(36160, null);
      }
      function Q(t, n, i) {
        if ((e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)) {
          let r = 33189;
          if (i) {
            const t = n.depthTexture;
            t &&
              t.isDepthTexture &&
              (t.type === p ? (r = 36012) : t.type === d && (r = 33190));
            const i = $(n);
            e.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
          } else e.renderbufferStorage(36161, r, n.width, n.height);
          e.framebufferRenderbuffer(36160, 36096, 36161, t);
        } else if (n.depthBuffer && n.stencilBuffer) {
          if (i) {
            const t = $(n);
            e.renderbufferStorageMultisample(
              36161,
              t,
              35056,
              n.width,
              n.height
            );
          } else e.renderbufferStorage(36161, 34041, n.width, n.height);
          e.framebufferRenderbuffer(36160, 33306, 36161, t);
        } else {
          const t = n.texture,
            r = b.convert(t.format),
            s = b.convert(t.type),
            a = H(t.internalFormat, r, s);
          if (i) {
            const t = $(n);
            e.renderbufferStorageMultisample(36161, t, a, n.width, n.height);
          } else e.renderbufferStorage(36161, a, n.width, n.height);
        }
        e.bindRenderbuffer(36161, null);
      }
      function $(e) {
        return S && e.isWebGLMultisampleRenderTarget
          ? Math.min(L, e.samples)
          : 0;
      }
      let ee = !1,
        te = !1;
      (this.allocateTextureUnit = function () {
        const e = k;
        return (
          e >= T &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                e +
                " texture units while this GPU supports only " +
                T
            ),
          (k += 1),
          e
        );
      }),
        (this.resetTextureUnits = function () {
          k = 0;
        }),
        (this.setTexture2D = W),
        (this.setTexture2DArray = function (e, t) {
          const i = _.get(e);
          e.version > 0 && i.__version !== e.version
            ? J(i, e, t)
            : (n.activeTexture(33984 + t),
              n.bindTexture(35866, i.__webglTexture));
        }),
        (this.setTexture3D = function (e, t) {
          const i = _.get(e);
          e.version > 0 && i.__version !== e.version
            ? J(i, e, t)
            : (n.activeTexture(33984 + t),
              n.bindTexture(32879, i.__webglTexture));
        }),
        (this.setTextureCube = j),
        (this.setupRenderTarget = function (t) {
          const i = t.texture,
            r = _.get(t),
            s = _.get(i);
          t.addEventListener("dispose", U),
            (s.__webglTexture = e.createTexture()),
            (s.__version = i.version),
            M.memory.textures++;
          const a = !0 === t.isWebGLCubeRenderTarget,
            o = !0 === t.isWebGLMultisampleRenderTarget,
            l = i.isDataTexture3D || i.isDataTexture2DArray,
            c = D(t) || S;
          if (
            (!S ||
              i.format !== g ||
              (i.type !== p && i.type !== m) ||
              ((i.format = v),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            a)
          ) {
            r.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++)
              r.__webglFramebuffer[t] = e.createFramebuffer();
          } else if (((r.__webglFramebuffer = e.createFramebuffer()), o))
            if (S) {
              (r.__webglMultisampledFramebuffer = e.createFramebuffer()),
                (r.__webglColorRenderbuffer = e.createRenderbuffer()),
                e.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
              const s = b.convert(i.format),
                a = b.convert(i.type),
                o = H(i.internalFormat, s, a),
                l = $(t);
              e.renderbufferStorageMultisample(36161, l, o, t.width, t.height),
                n.bindFramebuffer(36160, r.__webglMultisampledFramebuffer),
                e.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  r.__webglColorRenderbuffer
                ),
                e.bindRenderbuffer(36161, null),
                t.depthBuffer &&
                  ((r.__webglDepthRenderbuffer = e.createRenderbuffer()),
                  Q(r.__webglDepthRenderbuffer, t, !0)),
                n.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (a) {
            n.bindTexture(34067, s.__webglTexture), Y(34067, i, c);
            for (let e = 0; e < 6; e++)
              K(r.__webglFramebuffer[e], t, 36064, 34069 + e);
            O(i, c) && z(34067, i, t.width, t.height),
              n.bindTexture(34067, null);
          } else {
            let e = 3553;
            l &&
              (S
                ? (e = i.isDataTexture3D ? 32879 : 35866)
                : console.warn(
                    "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                  )),
              n.bindTexture(e, s.__webglTexture),
              Y(e, i, c),
              K(r.__webglFramebuffer, t, 36064, e),
              O(i, c) && z(3553, i, t.width, t.height),
              n.bindTexture(3553, null);
          }
          t.depthBuffer &&
            (function (t) {
              const i = _.get(t),
                r = !0 === t.isWebGLCubeRenderTarget;
              if (t.depthTexture) {
                if (r)
                  throw new Error(
                    "target.depthTexture not supported in Cube render targets"
                  );
                !(function (t, i) {
                  if (i && i.isWebGLCubeRenderTarget)
                    throw new Error(
                      "Depth Texture with cube render targets is not supported"
                    );
                  if (
                    (n.bindFramebuffer(36160, t),
                    !i.depthTexture || !i.depthTexture.isDepthTexture)
                  )
                    throw new Error(
                      "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                    );
                  (_.get(i.depthTexture).__webglTexture &&
                    i.depthTexture.image.width === i.width &&
                    i.depthTexture.image.height === i.height) ||
                    ((i.depthTexture.image.width = i.width),
                    (i.depthTexture.image.height = i.height),
                    (i.depthTexture.needsUpdate = !0)),
                    W(i.depthTexture, 0);
                  const r = _.get(i.depthTexture).__webglTexture;
                  if (i.depthTexture.format === x)
                    e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                  else {
                    if (i.depthTexture.format !== y)
                      throw new Error("Unknown depthTexture format");
                    e.framebufferTexture2D(36160, 33306, 3553, r, 0);
                  }
                })(i.__webglFramebuffer, t);
              } else if (r) {
                i.__webglDepthbuffer = [];
                for (let r = 0; r < 6; r++)
                  n.bindFramebuffer(36160, i.__webglFramebuffer[r]),
                    (i.__webglDepthbuffer[r] = e.createRenderbuffer()),
                    Q(i.__webglDepthbuffer[r], t, !1);
              } else
                n.bindFramebuffer(36160, i.__webglFramebuffer),
                  (i.__webglDepthbuffer = e.createRenderbuffer()),
                  Q(i.__webglDepthbuffer, t, !1);
              n.bindFramebuffer(36160, null);
            })(t);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          const t = e.texture;
          if (O(t, D(e) || S)) {
            const i = e.isWebGLCubeRenderTarget ? 34067 : 3553,
              r = _.get(t).__webglTexture;
            n.bindTexture(i, r),
              z(i, t, e.width, e.height),
              n.bindTexture(i, null);
          }
        }),
        (this.updateMultisampleRenderTarget = function (t) {
          if (t.isWebGLMultisampleRenderTarget)
            if (S) {
              const i = t.width,
                r = t.height;
              let s = 16384;
              t.depthBuffer && (s |= 256), t.stencilBuffer && (s |= 1024);
              const a = _.get(t);
              n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer),
                n.bindFramebuffer(36009, a.__webglFramebuffer),
                e.blitFramebuffer(0, 0, i, r, 0, 0, i, r, s, 9728),
                n.bindFramebuffer(36008, null),
                n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.safeSetTexture2D = function (e, t) {
          e &&
            e.isWebGLRenderTarget &&
            (!1 === ee &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (ee = !0)),
            (e = e.texture)),
            W(e, t);
        }),
        (this.safeSetTextureCube = function (e, t) {
          e &&
            e.isWebGLCubeRenderTarget &&
            (!1 === te &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (te = !0)),
            (e = e.texture)),
            j(e, t);
        });
    }
    function Ir(e, t, n) {
      const i = n.isWebGL2;
      return {
        convert: function (e) {
          let n;
          if (1009 === e) return 5121;
          if (1017 === e) return 32819;
          if (1018 === e) return 32820;
          if (1019 === e) return 33635;
          if (1010 === e) return 5120;
          if (1011 === e) return 5122;
          if (e === u) return 5123;
          if (1013 === e) return 5124;
          if (e === d) return 5125;
          if (e === p) return 5126;
          if (e === m)
            return i
              ? 5131
              : ((n = t.get("OES_texture_half_float")),
                null !== n ? n.HALF_FLOAT_OES : null);
          if (1021 === e) return 6406;
          if (e === g) return 6407;
          if (e === v) return 6408;
          if (1024 === e) return 6409;
          if (1025 === e) return 6410;
          if (e === x) return 6402;
          if (e === y) return 34041;
          if (1028 === e) return 6403;
          if (1029 === e) return 36244;
          if (1030 === e) return 33319;
          if (1031 === e) return 33320;
          if (1032 === e) return 36248;
          if (1033 === e) return 36249;
          if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
            if (((n = t.get("WEBGL_compressed_texture_s3tc")), null === n))
              return null;
            if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
            if (((n = t.get("WEBGL_compressed_texture_pvrtc")), null === n))
              return null;
            if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === e)
            return (
              (n = t.get("WEBGL_compressed_texture_etc1")),
              null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (37492 === e || 37496 === e) &&
            ((n = t.get("WEBGL_compressed_texture_etc")), null !== n)
          ) {
            if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
            if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return 37808 === e ||
            37809 === e ||
            37810 === e ||
            37811 === e ||
            37812 === e ||
            37813 === e ||
            37814 === e ||
            37815 === e ||
            37816 === e ||
            37817 === e ||
            37818 === e ||
            37819 === e ||
            37820 === e ||
            37821 === e ||
            37840 === e ||
            37841 === e ||
            37842 === e ||
            37843 === e ||
            37844 === e ||
            37845 === e ||
            37846 === e ||
            37847 === e ||
            37848 === e ||
            37849 === e ||
            37850 === e ||
            37851 === e ||
            37852 === e ||
            37853 === e
            ? ((n = t.get("WEBGL_compressed_texture_astc")),
              null !== n ? e : null)
            : 36492 === e
            ? ((n = t.get("EXT_texture_compression_bptc")),
              null !== n ? e : null)
            : e === f
            ? i
              ? 34042
              : ((n = t.get("WEBGL_depth_texture")),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0;
        },
      };
    }
    Lr.prototype.isMeshDistanceMaterial = !0;
    class Nr extends gn {
      constructor(e = []) {
        super(), (this.cameras = e);
      }
    }
    Nr.prototype.isArrayCamera = !0;
    class Dr extends it {
      constructor() {
        super(), (this.type = "Group");
      }
    }
    Dr.prototype.isGroup = !0;
    const Or = { type: "move" };
    class zr {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          null === this._hand &&
            ((this._hand = new Dr()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = { pinching: !1 })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          null === this._targetRay &&
            ((this._targetRay = new Dr()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new te()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new te())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          null === this._grip &&
            ((this._grip = new Dr()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new te()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new te())),
          this._grip
        );
      }
      dispatchEvent(e) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(e),
          null !== this._grip && this._grip.dispatchEvent(e),
          null !== this._hand && this._hand.dispatchEvent(e),
          this
        );
      }
      disconnect(e) {
        return (
          this.dispatchEvent({ type: "disconnected", data: e }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      }
      update(e, t, n) {
        let i = null,
          r = null,
          s = null;
        const a = this._targetRay,
          o = this._grip,
          l = this._hand;
        if (e && "visible-blurred" !== t.session.visibilityState)
          if (
            (null !== a &&
              ((i = t.getPose(e.targetRaySpace, n)),
              null !== i &&
                (a.matrix.fromArray(i.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                i.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(i.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(i.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(Or))),
            l && e.hand)
          ) {
            s = !0;
            for (const i of e.hand.values()) {
              const e = t.getJointPose(i, n);
              if (void 0 === l.joints[i.jointName]) {
                const e = new Dr();
                (e.matrixAutoUpdate = !1),
                  (e.visible = !1),
                  (l.joints[i.jointName] = e),
                  l.add(e);
              }
              const r = l.joints[i.jointName];
              null !== e &&
                (r.matrix.fromArray(e.transform.matrix),
                r.matrix.decompose(r.position, r.rotation, r.scale),
                (r.jointRadius = e.radius)),
                (r.visible = null !== e);
            }
            const i = l.joints["index-finger-tip"],
              r = l.joints["thumb-tip"],
              a = i.position.distanceTo(r.position),
              o = 0.02,
              c = 0.005;
            l.inputState.pinching && a > o + c
              ? ((l.inputState.pinching = !1),
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: e.handedness,
                  target: this,
                }))
              : !l.inputState.pinching &&
                a <= o - c &&
                ((l.inputState.pinching = !0),
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this,
                }));
          } else
            null !== o &&
              e.gripSpace &&
              ((r = t.getPose(e.gripSpace, n)),
              null !== r &&
                (o.matrix.fromArray(r.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                r.linearVelocity
                  ? ((o.hasLinearVelocity = !0),
                    o.linearVelocity.copy(r.linearVelocity))
                  : (o.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((o.hasAngularVelocity = !0),
                    o.angularVelocity.copy(r.angularVelocity))
                  : (o.hasAngularVelocity = !1)));
        return (
          null !== a && (a.visible = null !== i),
          null !== o && (o.visible = null !== r),
          null !== l && (l.visible = null !== s),
          this
        );
      }
    }
    class Hr extends I {
      constructor(e, t) {
        super();
        const n = this,
          i = e.state;
        let r = null,
          s = 1,
          a = null,
          o = "local-floor",
          l = null;
        const c = [],
          h = new Map(),
          u = new gn();
        u.layers.enable(1), (u.viewport = new Q());
        const d = new gn();
        d.layers.enable(2), (d.viewport = new Q());
        const p = [u, d],
          m = new Nr();
        m.layers.enable(1), m.layers.enable(2);
        let f = null,
          g = null;
        function v(e) {
          const t = h.get(e.inputSource);
          t && t.dispatchEvent({ type: e.type, data: e.inputSource });
        }
        function x() {
          h.forEach(function (e, t) {
            e.disconnect(t);
          }),
            h.clear(),
            (f = null),
            (g = null),
            i.bindXRFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            S.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({ type: "sessionend" });
        }
        function y(e) {
          const t = r.inputSources;
          for (let e = 0; e < c.length; e++) h.set(t[e], c[e]);
          for (let t = 0; t < e.removed.length; t++) {
            const n = e.removed[t],
              i = h.get(n);
            i &&
              (i.dispatchEvent({ type: "disconnected", data: n }), h.delete(n));
          }
          for (let t = 0; t < e.added.length; t++) {
            const n = e.added[t],
              i = h.get(n);
            i && i.dispatchEvent({ type: "connected", data: n });
          }
        }
        (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (e) {
            let t = c[e];
            return (
              void 0 === t && ((t = new zr()), (c[e] = t)),
              t.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (e) {
            let t = c[e];
            return (
              void 0 === t && ((t = new zr()), (c[e] = t)), t.getGripSpace()
            );
          }),
          (this.getHand = function (e) {
            let t = c[e];
            return (
              void 0 === t && ((t = new zr()), (c[e] = t)), t.getHandSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (e) {
            (s = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (e) {
            (o = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return a;
          }),
          (this.getSession = function () {
            return r;
          }),
          (this.setSession = async function (e) {
            if (((r = e), null !== r)) {
              r.addEventListener("select", v),
                r.addEventListener("selectstart", v),
                r.addEventListener("selectend", v),
                r.addEventListener("squeeze", v),
                r.addEventListener("squeezestart", v),
                r.addEventListener("squeezeend", v),
                r.addEventListener("end", x),
                r.addEventListener("inputsourceschange", y);
              const e = t.getContextAttributes();
              !0 !== e.xrCompatible && (await t.makeXRCompatible());
              const i = {
                  antialias: e.antialias,
                  alpha: e.alpha,
                  depth: e.depth,
                  stencil: e.stencil,
                  framebufferScaleFactor: s,
                },
                l = new XRWebGLLayer(r, t, i);
              r.updateRenderState({ baseLayer: l }),
                (a = await r.requestReferenceSpace(o)),
                S.setContext(r),
                S.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({ type: "sessionstart" });
            }
          });
        const _ = new te(),
          w = new te();
        function b(e, t) {
          null === t
            ? e.matrixWorld.copy(e.matrix)
            : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
        }
        this.getCamera = function (e) {
          (m.near = d.near = u.near = e.near),
            (m.far = d.far = u.far = e.far),
            (f === m.near && g === m.far) ||
              (r.updateRenderState({ depthNear: m.near, depthFar: m.far }),
              (f = m.near),
              (g = m.far));
          const t = e.parent,
            n = m.cameras;
          b(m, t);
          for (let e = 0; e < n.length; e++) b(n[e], t);
          e.matrixWorld.copy(m.matrixWorld),
            e.matrix.copy(m.matrix),
            e.matrix.decompose(e.position, e.quaternion, e.scale);
          const i = e.children;
          for (let e = 0, t = i.length; e < t; e++) i[e].updateMatrixWorld(!0);
          return (
            2 === n.length
              ? (function (e, t, n) {
                  _.setFromMatrixPosition(t.matrixWorld),
                    w.setFromMatrixPosition(n.matrixWorld);
                  const i = _.distanceTo(w),
                    r = t.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    o = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (s[8] + 1) / s[0],
                    d = a * h,
                    p = a * u,
                    m = i / (-h + u),
                    f = m * -h;
                  t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(f),
                    e.translateZ(m),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert();
                  const g = a + m,
                    v = o + m,
                    x = d - f,
                    y = p + (i - f),
                    b = ((l * o) / v) * g,
                    M = ((c * o) / v) * g;
                  e.projectionMatrix.makePerspective(x, y, b, M, g, v);
                })(m, u, d)
              : m.projectionMatrix.copy(u.projectionMatrix),
            m
          );
        };
        let M = null;
        const S = new Tn();
        S.setAnimationLoop(function (e, t) {
          if (((l = t.getViewerPose(a)), null !== l)) {
            const e = l.views,
              t = r.renderState.baseLayer;
            i.bindXRFramebuffer(t.framebuffer);
            let n = !1;
            e.length !== m.cameras.length && ((m.cameras.length = 0), (n = !0));
            for (let i = 0; i < e.length; i++) {
              const r = e[i],
                s = t.getViewport(r),
                a = p[i];
              a.matrix.fromArray(r.transform.matrix),
                a.projectionMatrix.fromArray(r.projectionMatrix),
                a.viewport.set(s.x, s.y, s.width, s.height),
                0 === i && m.matrix.copy(a.matrix),
                !0 === n && m.cameras.push(a);
            }
          }
          const n = r.inputSources;
          for (let e = 0; e < c.length; e++) {
            const i = c[e],
              r = n[e];
            i.update(r, t, a);
          }
          M && M(e, t);
        }),
          (this.setAnimationLoop = function (e) {
            M = e;
          }),
          (this.dispose = function () {});
      }
    }
    function Fr(e) {
      function t(t, n) {
        (t.opacity.value = n.opacity),
          n.color && t.diffuse.value.copy(n.color),
          n.emissive &&
            t.emissive.value
              .copy(n.emissive)
              .multiplyScalar(n.emissiveIntensity),
          n.map && (t.map.value = n.map),
          n.alphaMap && (t.alphaMap.value = n.alphaMap),
          n.specularMap && (t.specularMap.value = n.specularMap);
        const i = e.get(n).envMap;
        if (i) {
          (t.envMap.value = i),
            (t.flipEnvMap.value =
              i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1),
            (t.reflectivity.value = n.reflectivity),
            (t.refractionRatio.value = n.refractionRatio);
          const r = e.get(i).__maxMipLevel;
          void 0 !== r && (t.maxMipLevel.value = r);
        }
        let r, s;
        n.lightMap &&
          ((t.lightMap.value = n.lightMap),
          (t.lightMapIntensity.value = n.lightMapIntensity)),
          n.aoMap &&
            ((t.aoMap.value = n.aoMap),
            (t.aoMapIntensity.value = n.aoMapIntensity)),
          n.map
            ? (r = n.map)
            : n.specularMap
            ? (r = n.specularMap)
            : n.displacementMap
            ? (r = n.displacementMap)
            : n.normalMap
            ? (r = n.normalMap)
            : n.bumpMap
            ? (r = n.bumpMap)
            : n.roughnessMap
            ? (r = n.roughnessMap)
            : n.metalnessMap
            ? (r = n.metalnessMap)
            : n.alphaMap
            ? (r = n.alphaMap)
            : n.emissiveMap
            ? (r = n.emissiveMap)
            : n.clearcoatMap
            ? (r = n.clearcoatMap)
            : n.clearcoatNormalMap
            ? (r = n.clearcoatNormalMap)
            : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
          void 0 !== r &&
            (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            t.uvTransform.value.copy(r.matrix)),
          n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
          void 0 !== s &&
            (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            t.uv2Transform.value.copy(s.matrix));
      }
      function n(t, n) {
        (t.roughness.value = n.roughness),
          (t.metalness.value = n.metalness),
          n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
          n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
          n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
          n.bumpMap &&
            ((t.bumpMap.value = n.bumpMap),
            (t.bumpScale.value = n.bumpScale),
            1 === n.side && (t.bumpScale.value *= -1)),
          n.normalMap &&
            ((t.normalMap.value = n.normalMap),
            t.normalScale.value.copy(n.normalScale),
            1 === n.side && t.normalScale.value.negate()),
          n.displacementMap &&
            ((t.displacementMap.value = n.displacementMap),
            (t.displacementScale.value = n.displacementScale),
            (t.displacementBias.value = n.displacementBias)),
          e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
      }
      return {
        refreshFogUniforms: function (e, t) {
          e.fogColor.value.copy(t.color),
            t.isFog
              ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
              : t.isFogExp2 && (e.fogDensity.value = t.density);
        },
        refreshMaterialUniforms: function (e, i, r, s) {
          i.isMeshBasicMaterial
            ? t(e, i)
            : i.isMeshLambertMaterial
            ? (t(e, i),
              (function (e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
              })(e, i))
            : i.isMeshToonMaterial
            ? (t(e, i),
              (function (e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap),
                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                  t.bumpMap &&
                    ((e.bumpMap.value = t.bumpMap),
                    (e.bumpScale.value = t.bumpScale),
                    1 === t.side && (e.bumpScale.value *= -1)),
                  t.normalMap &&
                    ((e.normalMap.value = t.normalMap),
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate()),
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshPhongMaterial
            ? (t(e, i),
              (function (e, t) {
                e.specular.value.copy(t.specular),
                  (e.shininess.value = Math.max(t.shininess, 1e-4)),
                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                  t.bumpMap &&
                    ((e.bumpMap.value = t.bumpMap),
                    (e.bumpScale.value = t.bumpScale),
                    1 === t.side && (e.bumpScale.value *= -1)),
                  t.normalMap &&
                    ((e.normalMap.value = t.normalMap),
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate()),
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshStandardMaterial
            ? (t(e, i),
              i.isMeshPhysicalMaterial
                ? (function (e, t) {
                    n(e, t),
                      (e.reflectivity.value = t.reflectivity),
                      (e.clearcoat.value = t.clearcoat),
                      (e.clearcoatRoughness.value = t.clearcoatRoughness),
                      t.sheen && e.sheen.value.copy(t.sheen),
                      t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                      t.clearcoatRoughnessMap &&
                        (e.clearcoatRoughnessMap.value =
                          t.clearcoatRoughnessMap),
                      t.clearcoatNormalMap &&
                        (e.clearcoatNormalScale.value.copy(
                          t.clearcoatNormalScale
                        ),
                        (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                        1 === t.side && e.clearcoatNormalScale.value.negate()),
                      (e.transmission.value = t.transmission),
                      t.transmissionMap &&
                        (e.transmissionMap.value = t.transmissionMap);
                  })(e, i)
                : n(e, i))
            : i.isMeshMatcapMaterial
            ? (t(e, i),
              (function (e, t) {
                t.matcap && (e.matcap.value = t.matcap),
                  t.bumpMap &&
                    ((e.bumpMap.value = t.bumpMap),
                    (e.bumpScale.value = t.bumpScale),
                    1 === t.side && (e.bumpScale.value *= -1)),
                  t.normalMap &&
                    ((e.normalMap.value = t.normalMap),
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate()),
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshDepthMaterial
            ? (t(e, i),
              (function (e, t) {
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshDistanceMaterial
            ? (t(e, i),
              (function (e, t) {
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias)),
                  e.referencePosition.value.copy(t.referencePosition),
                  (e.nearDistance.value = t.nearDistance),
                  (e.farDistance.value = t.farDistance);
              })(e, i))
            : i.isMeshNormalMaterial
            ? (t(e, i),
              (function (e, t) {
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1)),
                  t.normalMap &&
                    ((e.normalMap.value = t.normalMap),
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate()),
                  t.displacementMap &&
                    ((e.displacementMap.value = t.displacementMap),
                    (e.displacementScale.value = t.displacementScale),
                    (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isLineBasicMaterial
            ? ((function (e, t) {
                e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
              })(e, i),
              i.isLineDashedMaterial &&
                (function (e, t) {
                  (e.dashSize.value = t.dashSize),
                    (e.totalSize.value = t.dashSize + t.gapSize),
                    (e.scale.value = t.scale);
                })(e, i))
            : i.isPointsMaterial
            ? (function (e, t, n, i) {
                let r;
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.size.value = t.size * n),
                  (e.scale.value = 0.5 * i),
                  t.map && (e.map.value = t.map),
                  t.alphaMap && (e.alphaMap.value = t.alphaMap),
                  t.map ? (r = t.map) : t.alphaMap && (r = t.alphaMap),
                  void 0 !== r &&
                    (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                    e.uvTransform.value.copy(r.matrix));
              })(e, i, r, s)
            : i.isSpriteMaterial
            ? (function (e, t) {
                let n;
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.rotation.value = t.rotation),
                  t.map && (e.map.value = t.map),
                  t.alphaMap && (e.alphaMap.value = t.alphaMap),
                  t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap),
                  void 0 !== n &&
                    (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    e.uvTransform.value.copy(n.matrix));
              })(e, i)
            : i.isShadowMaterial
            ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
            : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
        },
      };
    }
    function Br(e) {
      const t =
          void 0 !== (e = e || {}).canvas
            ? e.canvas
            : (function () {
                const e = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                );
                return (e.style.display = "block"), e;
              })(),
        n = void 0 !== e.context ? e.context : null,
        i = void 0 !== e.alpha && e.alpha,
        r = void 0 === e.depth || e.depth,
        s = void 0 === e.stencil || e.stencil,
        a = void 0 !== e.antialias && e.antialias,
        o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
        l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
        c = void 0 !== e.powerPreference ? e.powerPreference : "default",
        h =
          void 0 !== e.failIfMajorPerformanceCaveat &&
          e.failIfMajorPerformanceCaveat;
      let u = null,
        d = null;
      const f = [],
        g = [];
      (this.domElement = t),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.outputEncoding = E),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = 0),
        (this.toneMappingExposure = 1);
      const x = this;
      let y = !1,
        _ = 0,
        w = 0,
        b = null,
        M = -1,
        S = null;
      const T = new Q(),
        A = new Q();
      let L = null,
        R = t.width,
        C = t.height,
        P = 1,
        I = null,
        N = null;
      const D = new Q(0, 0, R, C),
        O = new Q(0, 0, R, C);
      let z = !1;
      const H = new Sn();
      let F = !1,
        B = !1;
      const U = new Ie(),
        G = new te(),
        V = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function W() {
        return null === b ? P : 1;
      }
      let q,
        X,
        Y,
        Z,
        J,
        K,
        $,
        ee,
        ne,
        ie,
        re,
        se,
        ae,
        oe,
        le,
        ce,
        he,
        ue,
        de,
        pe,
        me,
        fe,
        ge = n;
      function ve(e, n) {
        for (let i = 0; i < e.length; i++) {
          const r = e[i],
            s = t.getContext(r, n);
          if (null !== s) return s;
        }
        return null;
      }
      try {
        const e = {
          alpha: i,
          depth: r,
          stencil: s,
          antialias: a,
          premultipliedAlpha: o,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: h,
        };
        if (
          (t.addEventListener("webglcontextlost", _e, !1),
          t.addEventListener("webglcontextrestored", we, !1),
          null === ge)
        ) {
          const t = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === x.isWebGL1Renderer && t.shift(),
            (ge = ve(t, e)),
            null === ge)
          )
            throw ve(t)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        void 0 === ge.getShaderPrecisionFormat &&
          (ge.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (e) {
        throw (console.error("THREE.WebGLRenderer: " + e.message), e);
      }
      function xe() {
        (q = new Hn(ge)),
          (X = new Dn(ge, q, e)),
          q.init(X),
          (me = new Ir(ge, q, X)),
          (Y = new Cr(ge, q, X)),
          (Z = new Un(ge)),
          (J = new gr()),
          (K = new Pr(ge, q, Y, J, X, me, Z)),
          ($ = new zn(x)),
          (ee = new En(ge, X)),
          (fe = new In(ge, q, ee, X)),
          (ne = new Fn(ge, ee, Z, fe)),
          (ie = new Wn(ge, ne, ee, Z)),
          (ue = new Vn(ge)),
          (le = new On(J)),
          (re = new fr(x, $, q, X, fe, le)),
          (se = new Fr(J)),
          (ae = new _r(J)),
          (oe = new Er(q, X)),
          (he = new Pn(x, $, Y, ie, o)),
          (ce = new Rr(x, ie, X)),
          (de = new Nn(ge, q, Z, X)),
          (pe = new Bn(ge, q, Z, X)),
          (Z.programs = re.programs),
          (x.capabilities = X),
          (x.extensions = q),
          (x.properties = J),
          (x.renderLists = ae),
          (x.shadowMap = ce),
          (x.state = Y),
          (x.info = Z);
      }
      xe();
      const ye = new Hr(x, ge);
      function _e(e) {
        e.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (y = !0);
      }
      function we() {
        console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
        const e = Z.autoReset,
          t = ce.enabled,
          n = ce.autoUpdate,
          i = ce.needsUpdate,
          r = ce.type;
        xe(),
          (Z.autoReset = e),
          (ce.enabled = t),
          (ce.autoUpdate = n),
          (ce.needsUpdate = i),
          (ce.type = r);
      }
      function be(e) {
        const t = e.target;
        t.removeEventListener("dispose", be),
          (function (e) {
            (function (e) {
              const t = J.get(e).programs;
              void 0 !== t &&
                t.forEach(function (e) {
                  re.releaseProgram(e);
                });
            })(e),
              J.remove(e);
          })(t);
      }
      (this.xr = ye),
        (this.getContext = function () {
          return ge;
        }),
        (this.getContextAttributes = function () {
          return ge.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const e = q.get("WEBGL_lose_context");
          e && e.loseContext();
        }),
        (this.forceContextRestore = function () {
          const e = q.get("WEBGL_lose_context");
          e && e.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return P;
        }),
        (this.setPixelRatio = function (e) {
          void 0 !== e && ((P = e), this.setSize(R, C, !1));
        }),
        (this.getSize = function (e) {
          return (
            void 0 === e &&
              (console.warn(
                "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
              ),
              (e = new j())),
            e.set(R, C)
          );
        }),
        (this.setSize = function (e, n, i) {
          ye.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((R = e),
              (C = n),
              (t.width = Math.floor(e * P)),
              (t.height = Math.floor(n * P)),
              !1 !== i &&
                ((t.style.width = e + "px"), (t.style.height = n + "px")),
              this.setViewport(0, 0, e, n));
        }),
        (this.getDrawingBufferSize = function (e) {
          return (
            void 0 === e &&
              (console.warn(
                "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
              ),
              (e = new j())),
            e.set(R * P, C * P).floor()
          );
        }),
        (this.setDrawingBufferSize = function (e, n, i) {
          (R = e),
            (C = n),
            (P = i),
            (t.width = Math.floor(e * i)),
            (t.height = Math.floor(n * i)),
            this.setViewport(0, 0, e, n);
        }),
        (this.getCurrentViewport = function (e) {
          return (
            void 0 === e &&
              (console.warn(
                "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
              ),
              (e = new Q())),
            e.copy(T)
          );
        }),
        (this.getViewport = function (e) {
          return e.copy(D);
        }),
        (this.setViewport = function (e, t, n, i) {
          e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, i),
            Y.viewport(T.copy(D).multiplyScalar(P).floor());
        }),
        (this.getScissor = function (e) {
          return e.copy(O);
        }),
        (this.setScissor = function (e, t, n, i) {
          e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, i),
            Y.scissor(A.copy(O).multiplyScalar(P).floor());
        }),
        (this.getScissorTest = function () {
          return z;
        }),
        (this.setScissorTest = function (e) {
          Y.setScissorTest((z = e));
        }),
        (this.setOpaqueSort = function (e) {
          I = e;
        }),
        (this.setTransparentSort = function (e) {
          N = e;
        }),
        (this.getClearColor = function (e) {
          return (
            void 0 === e &&
              (console.warn(
                "WebGLRenderer: .getClearColor() now requires a Color as an argument"
              ),
              (e = new At())),
            e.copy(he.getClearColor())
          );
        }),
        (this.setClearColor = function () {
          he.setClearColor.apply(he, arguments);
        }),
        (this.getClearAlpha = function () {
          return he.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          he.setClearAlpha.apply(he, arguments);
        }),
        (this.clear = function (e, t, n) {
          let i = 0;
          (void 0 === e || e) && (i |= 16384),
            (void 0 === t || t) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            ge.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          t.removeEventListener("webglcontextlost", _e, !1),
            t.removeEventListener("webglcontextrestored", we, !1),
            ae.dispose(),
            oe.dispose(),
            J.dispose(),
            $.dispose(),
            ie.dispose(),
            fe.dispose(),
            ye.dispose(),
            ye.removeEventListener("sessionstart", Se),
            ye.removeEventListener("sessionend", Te),
            Ee.stop();
        }),
        (this.renderBufferImmediate = function (e, t) {
          fe.initAttributes();
          const n = J.get(e);
          e.hasPositions && !n.position && (n.position = ge.createBuffer()),
            e.hasNormals && !n.normal && (n.normal = ge.createBuffer()),
            e.hasUvs && !n.uv && (n.uv = ge.createBuffer()),
            e.hasColors && !n.color && (n.color = ge.createBuffer());
          const i = t.getAttributes();
          e.hasPositions &&
            (ge.bindBuffer(34962, n.position),
            ge.bufferData(34962, e.positionArray, 35048),
            fe.enableAttribute(i.position),
            ge.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            e.hasNormals &&
              (ge.bindBuffer(34962, n.normal),
              ge.bufferData(34962, e.normalArray, 35048),
              fe.enableAttribute(i.normal),
              ge.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs &&
              (ge.bindBuffer(34962, n.uv),
              ge.bufferData(34962, e.uvArray, 35048),
              fe.enableAttribute(i.uv),
              ge.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            e.hasColors &&
              (ge.bindBuffer(34962, n.color),
              ge.bufferData(34962, e.colorArray, 35048),
              fe.enableAttribute(i.color),
              ge.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            fe.disableUnusedAttributes(),
            ge.drawArrays(4, 0, e.count),
            (e.count = 0);
        }),
        (this.renderBufferDirect = function (e, t, n, i, r, s) {
          null === t && (t = V);
          const a = r.isMesh && r.matrixWorld.determinant() < 0,
            o = Ne(e, t, i, r);
          Y.setMaterial(i, a);
          let l = n.index;
          const c = n.attributes.position;
          if (null === l) {
            if (void 0 === c || 0 === c.count) return;
          } else if (0 === l.count) return;
          let h,
            u = 1;
          !0 === i.wireframe && ((l = ne.getWireframeAttribute(n)), (u = 2)),
            (i.morphTargets || i.morphNormals) && ue.update(r, n, i, o),
            fe.setup(r, i, o, n, l);
          let d = de;
          null !== l && ((h = ee.get(l)), (d = pe), d.setIndex(h));
          const p = null !== l ? l.count : c.count,
            m = n.drawRange.start * u,
            f = n.drawRange.count * u,
            g = null !== s ? s.start * u : 0,
            v = null !== s ? s.count * u : 1 / 0,
            x = Math.max(m, g),
            y = Math.min(p, m + f, g + v) - 1,
            _ = Math.max(0, y - x + 1);
          if (0 !== _) {
            if (r.isMesh)
              !0 === i.wireframe
                ? (Y.setLineWidth(i.wireframeLinewidth * W()), d.setMode(1))
                : d.setMode(4);
            else if (r.isLine) {
              let e = i.linewidth;
              void 0 === e && (e = 1),
                Y.setLineWidth(e * W()),
                r.isLineSegments
                  ? d.setMode(1)
                  : r.isLineLoop
                  ? d.setMode(2)
                  : d.setMode(3);
            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
            if (r.isInstancedMesh) d.renderInstances(x, _, r.count);
            else if (n.isInstancedBufferGeometry) {
              const e = Math.min(n.instanceCount, n._maxInstanceCount);
              d.renderInstances(x, _, e);
            } else d.render(x, _);
          }
        }),
        (this.compile = function (e, t) {
          (d = oe.get(e)),
            d.init(),
            e.traverseVisible(function (e) {
              e.isLight &&
                e.layers.test(t.layers) &&
                (d.pushLight(e), e.castShadow && d.pushShadow(e));
            }),
            d.setupLights(),
            e.traverse(function (t) {
              const n = t.material;
              if (n)
                if (Array.isArray(n))
                  for (let i = 0; i < n.length; i++) Ce(n[i], e, t);
                else Ce(n, e, t);
            });
        });
      let Me = null;
      function Se() {
        Ee.stop();
      }
      function Te() {
        Ee.start();
      }
      const Ee = new Tn();
      function Ae(e, t, n, i) {
        if (!1 === e.visible) return;
        if (e.layers.test(t.layers))
          if (e.isGroup) n = e.renderOrder;
          else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
          else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
          else if (e.isSprite) {
            if (!e.frustumCulled || H.intersectsSprite(e)) {
              i && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U);
              const t = ie.update(e),
                r = e.material;
              r.visible && u.push(e, t, r, n, G.z, null);
            }
          } else if (e.isImmediateRenderObject)
            i && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U),
              u.push(e, null, e.material, n, G.z, null);
          else if (
            (e.isMesh || e.isLine || e.isPoints) &&
            (e.isSkinnedMesh &&
              e.skeleton.frame !== Z.render.frame &&
              (e.skeleton.update(), (e.skeleton.frame = Z.render.frame)),
            !e.frustumCulled || H.intersectsObject(e))
          ) {
            i && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U);
            const t = ie.update(e),
              r = e.material;
            if (Array.isArray(r)) {
              const i = t.groups;
              for (let s = 0, a = i.length; s < a; s++) {
                const a = i[s],
                  o = r[a.materialIndex];
                o && o.visible && u.push(e, t, o, n, G.z, a);
              }
            } else r.visible && u.push(e, t, r, n, G.z, null);
          }
        const r = e.children;
        for (let e = 0, s = r.length; e < s; e++) Ae(r[e], t, n, i);
      }
      function Le(e, t, n) {
        const i = !0 === t.isScene ? t.overrideMaterial : null;
        for (let r = 0, s = e.length; r < s; r++) {
          const s = e[r],
            a = s.object,
            o = s.geometry,
            l = null === i ? s.material : i,
            c = s.group;
          if (n.isArrayCamera) {
            const e = n.cameras;
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              a.layers.test(i.layers) &&
                (Y.viewport(T.copy(i.viewport)),
                d.setupLightsView(i),
                Re(a, t, i, o, l, c));
            }
          } else Re(a, t, n, o, l, c);
        }
      }
      function Re(e, t, n, i, r, s) {
        if (
          (e.onBeforeRender(x, t, n, i, r, s),
          e.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            e.matrixWorld
          ),
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
          e.isImmediateRenderObject)
        ) {
          const i = Ne(n, t, r, e);
          Y.setMaterial(r),
            fe.reset(),
            (function (e, t) {
              e.render(function (e) {
                x.renderBufferImmediate(e, t);
              });
            })(e, i);
        } else x.renderBufferDirect(n, t, i, r, e, s);
        e.onAfterRender(x, t, n, i, r, s);
      }
      function Ce(e, t, n) {
        !0 !== t.isScene && (t = V);
        const i = J.get(e),
          r = d.state.lights,
          s = d.state.shadowsArray,
          a = r.state.version,
          o = re.getParameters(e, r.state, s, t, n),
          l = re.getProgramCacheKey(o);
        let c = i.programs;
        (i.environment = e.isMeshStandardMaterial ? t.environment : null),
          (i.fog = t.fog),
          (i.envMap = $.get(e.envMap || i.environment)),
          void 0 === c &&
            (e.addEventListener("dispose", be),
            (c = new Map()),
            (i.programs = c));
        let h = c.get(l);
        if (void 0 !== h) {
          if (i.currentProgram === h && i.lightsStateVersion === a)
            return Pe(e, o), h;
        } else
          (o.uniforms = re.getUniforms(e)),
            e.onBuild(o, x),
            e.onBeforeCompile(o, x),
            (h = re.acquireProgram(o, l)),
            c.set(l, h),
            (i.uniforms = o.uniforms);
        const u = i.uniforms;
        ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
          (u.clippingPlanes = le.uniform),
          Pe(e, o),
          (i.needsLights = (function (e) {
            return (
              e.isMeshLambertMaterial ||
              e.isMeshToonMaterial ||
              e.isMeshPhongMaterial ||
              e.isMeshStandardMaterial ||
              e.isShadowMaterial ||
              (e.isShaderMaterial && !0 === e.lights)
            );
          })(e)),
          (i.lightsStateVersion = a),
          i.needsLights &&
            ((u.ambientLightColor.value = r.state.ambient),
            (u.lightProbe.value = r.state.probe),
            (u.directionalLights.value = r.state.directional),
            (u.directionalLightShadows.value = r.state.directionalShadow),
            (u.spotLights.value = r.state.spot),
            (u.spotLightShadows.value = r.state.spotShadow),
            (u.rectAreaLights.value = r.state.rectArea),
            (u.ltc_1.value = r.state.rectAreaLTC1),
            (u.ltc_2.value = r.state.rectAreaLTC2),
            (u.pointLights.value = r.state.point),
            (u.pointLightShadows.value = r.state.pointShadow),
            (u.hemisphereLights.value = r.state.hemi),
            (u.directionalShadowMap.value = r.state.directionalShadowMap),
            (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (u.spotShadowMap.value = r.state.spotShadowMap),
            (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
            (u.pointShadowMap.value = r.state.pointShadowMap),
            (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
        const p = h.getUniforms(),
          m = Yi.seqWithValue(p.seq, u);
        return (i.currentProgram = h), (i.uniformsList = m), h;
      }
      function Pe(e, t) {
        const n = J.get(e);
        (n.outputEncoding = t.outputEncoding),
          (n.instancing = t.instancing),
          (n.numClippingPlanes = t.numClippingPlanes),
          (n.numIntersection = t.numClipIntersection),
          (n.vertexAlphas = t.vertexAlphas);
      }
      function Ne(e, t, n, i) {
        !0 !== t.isScene && (t = V), K.resetTextureUnits();
        const r = t.fog,
          s = n.isMeshStandardMaterial ? t.environment : null,
          a = null === b ? x.outputEncoding : b.texture.encoding,
          o = $.get(n.envMap || s),
          l =
            !0 === n.vertexColors &&
            i.geometry &&
            i.geometry.attributes.color &&
            4 === i.geometry.attributes.color.itemSize,
          c = J.get(n),
          h = d.state.lights;
        if (!0 === F && (!0 === B || e !== S)) {
          const t = e === S && n.id === M;
          le.setState(n, e, t);
        }
        let u = !1;
        n.version === c.__version
          ? (c.needsLights && c.lightsStateVersion !== h.state.version) ||
            c.outputEncoding !== a ||
            (i.isInstancedMesh && !1 === c.instancing)
            ? (u = !0)
            : i.isInstancedMesh || !0 !== c.instancing
            ? c.envMap !== o || (n.fog && c.fog !== r)
              ? (u = !0)
              : void 0 === c.numClippingPlanes ||
                (c.numClippingPlanes === le.numPlanes &&
                  c.numIntersection === le.numIntersection)
              ? c.vertexAlphas !== l && (u = !0)
              : (u = !0)
            : (u = !0)
          : ((u = !0), (c.__version = n.version));
        let m = c.currentProgram;
        !0 === u && (m = Ce(n, t, i));
        let f = !1,
          g = !1,
          y = !1;
        const _ = m.getUniforms(),
          w = c.uniforms;
        if (
          (Y.useProgram(m.program) && ((f = !0), (g = !0), (y = !0)),
          n.id !== M && ((M = n.id), (g = !0)),
          f || S !== e)
        ) {
          if (
            (_.setValue(ge, "projectionMatrix", e.projectionMatrix),
            X.logarithmicDepthBuffer &&
              _.setValue(
                ge,
                "logDepthBufFC",
                2 / (Math.log(e.far + 1) / Math.LN2)
              ),
            S !== e && ((S = e), (g = !0), (y = !0)),
            n.isShaderMaterial ||
              n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshStandardMaterial ||
              n.envMap)
          ) {
            const t = _.map.cameraPosition;
            void 0 !== t &&
              t.setValue(ge, G.setFromMatrixPosition(e.matrixWorld));
          }
          (n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial) &&
            _.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera),
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial ||
              n.isShadowMaterial ||
              n.skinning) &&
              _.setValue(ge, "viewMatrix", e.matrixWorldInverse);
        }
        if (n.skinning) {
          _.setOptional(ge, i, "bindMatrix"),
            _.setOptional(ge, i, "bindMatrixInverse");
          const e = i.skeleton;
          if (e) {
            const t = e.bones;
            if (X.floatVertexTextures) {
              if (null === e.boneTexture) {
                let n = Math.sqrt(4 * t.length);
                (n = k(n)), (n = Math.max(n, 4));
                const i = new Float32Array(n * n * 4);
                i.set(e.boneMatrices);
                const r = new wn(i, n, n, v, p);
                (e.boneMatrices = i),
                  (e.boneTexture = r),
                  (e.boneTextureSize = n);
              }
              _.setValue(ge, "boneTexture", e.boneTexture, K),
                _.setValue(ge, "boneTextureSize", e.boneTextureSize);
            } else _.setOptional(ge, e, "boneMatrices");
          }
        }
        var T, E;
        return (
          (g || c.receiveShadow !== i.receiveShadow) &&
            ((c.receiveShadow = i.receiveShadow),
            _.setValue(ge, "receiveShadow", i.receiveShadow)),
          g &&
            (_.setValue(ge, "toneMappingExposure", x.toneMappingExposure),
            c.needsLights &&
              ((E = y),
              ((T = w).ambientLightColor.needsUpdate = E),
              (T.lightProbe.needsUpdate = E),
              (T.directionalLights.needsUpdate = E),
              (T.directionalLightShadows.needsUpdate = E),
              (T.pointLights.needsUpdate = E),
              (T.pointLightShadows.needsUpdate = E),
              (T.spotLights.needsUpdate = E),
              (T.spotLightShadows.needsUpdate = E),
              (T.rectAreaLights.needsUpdate = E),
              (T.hemisphereLights.needsUpdate = E)),
            r && n.fog && se.refreshFogUniforms(w, r),
            se.refreshMaterialUniforms(w, n, P, C),
            Yi.upload(ge, c.uniformsList, w, K)),
          n.isShaderMaterial &&
            !0 === n.uniformsNeedUpdate &&
            (Yi.upload(ge, c.uniformsList, w, K), (n.uniformsNeedUpdate = !1)),
          n.isSpriteMaterial && _.setValue(ge, "center", i.center),
          _.setValue(ge, "modelViewMatrix", i.modelViewMatrix),
          _.setValue(ge, "normalMatrix", i.normalMatrix),
          _.setValue(ge, "modelMatrix", i.matrixWorld),
          m
        );
      }
      Ee.setAnimationLoop(function (e) {
        Me && Me(e);
      }),
        "undefined" != typeof window && Ee.setContext(window),
        (this.setAnimationLoop = function (e) {
          (Me = e), ye.setAnimationLoop(e), null === e ? Ee.stop() : Ee.start();
        }),
        ye.addEventListener("sessionstart", Se),
        ye.addEventListener("sessionend", Te),
        (this.render = function (e, t) {
          let n, i;
          if (
            (void 0 !== arguments[2] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
              ),
              (n = arguments[2])),
            void 0 !== arguments[3] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
              ),
              (i = arguments[3])),
            void 0 !== t && !0 !== t.isCamera)
          )
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === y) return;
          !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            !0 === ye.enabled &&
              !0 === ye.isPresenting &&
              (t = ye.getCamera(t)),
            !0 === e.isScene && e.onBeforeRender(x, e, t, n || b),
            (d = oe.get(e, g.length)),
            d.init(),
            g.push(d),
            U.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            H.setFromProjectionMatrix(U),
            (B = this.localClippingEnabled),
            (F = le.init(this.clippingPlanes, B, t)),
            (u = ae.get(e, f.length)),
            u.init(),
            f.push(u),
            Ae(e, t, 0, x.sortObjects),
            u.finish(),
            !0 === x.sortObjects && u.sort(I, N),
            !0 === F && le.beginShadows();
          const r = d.state.shadowsArray;
          ce.render(r, e, t),
            d.setupLights(),
            d.setupLightsView(t),
            !0 === F && le.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            void 0 !== n && this.setRenderTarget(n),
            he.render(u, e, t, i);
          const s = u.opaque,
            a = u.transparent;
          s.length > 0 && Le(s, e, t),
            a.length > 0 && Le(a, e, t),
            null !== b &&
              (K.updateRenderTargetMipmap(b),
              K.updateMultisampleRenderTarget(b)),
            !0 === e.isScene && e.onAfterRender(x, e, t),
            Y.buffers.depth.setTest(!0),
            Y.buffers.depth.setMask(!0),
            Y.buffers.color.setMask(!0),
            Y.setPolygonOffset(!1),
            fe.resetDefaultState(),
            (M = -1),
            (S = null),
            g.pop(),
            (d = g.length > 0 ? g[g.length - 1] : null),
            f.pop(),
            (u = f.length > 0 ? f[f.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return _;
        }),
        (this.getActiveMipmapLevel = function () {
          return w;
        }),
        (this.getRenderTarget = function () {
          return b;
        }),
        (this.setRenderTarget = function (e, t = 0, n = 0) {
          (b = e),
            (_ = t),
            (w = n),
            e &&
              void 0 === J.get(e).__webglFramebuffer &&
              K.setupRenderTarget(e);
          let i = null,
            r = !1,
            s = !1;
          if (e) {
            const n = e.texture;
            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
            const a = J.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget
              ? ((i = a[t]), (r = !0))
              : (i = e.isWebGLMultisampleRenderTarget
                  ? J.get(e).__webglMultisampledFramebuffer
                  : a),
              T.copy(e.viewport),
              A.copy(e.scissor),
              (L = e.scissorTest);
          } else
            T.copy(D).multiplyScalar(P).floor(),
              A.copy(O).multiplyScalar(P).floor(),
              (L = z);
          if (
            (Y.bindFramebuffer(36160, i),
            Y.viewport(T),
            Y.scissor(A),
            Y.setScissorTest(L),
            r)
          ) {
            const i = J.get(e.texture);
            ge.framebufferTexture2D(
              36160,
              36064,
              34069 + t,
              i.__webglTexture,
              n
            );
          } else if (s) {
            const i = J.get(e.texture),
              r = t || 0;
            ge.framebufferTextureLayer(
              36160,
              36064,
              i.__webglTexture,
              n || 0,
              r
            );
          }
        }),
        (this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
          if (!e || !e.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let o = J.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            Y.bindFramebuffer(36160, o);
            try {
              const a = e.texture,
                o = a.format,
                l = a.type;
              if (o !== v && me.convert(o) !== ge.getParameter(35739))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              const c =
                l === m &&
                (q.has("EXT_color_buffer_half_float") ||
                  (X.isWebGL2 && q.has("EXT_color_buffer_float")));
              if (
                !(
                  1009 === l ||
                  me.convert(l) === ge.getParameter(35738) ||
                  (l === p &&
                    (X.isWebGL2 ||
                      q.has("OES_texture_float") ||
                      q.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              36053 === ge.checkFramebufferStatus(36160)
                ? t >= 0 &&
                  t <= e.width - i &&
                  n >= 0 &&
                  n <= e.height - r &&
                  ge.readPixels(t, n, i, r, me.convert(o), me.convert(l), s)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                  );
            } finally {
              const e = null !== b ? J.get(b).__webglFramebuffer : null;
              Y.bindFramebuffer(36160, e);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (e, t, n = 0) {
          const i = Math.pow(2, -n),
            r = Math.floor(t.image.width * i),
            s = Math.floor(t.image.height * i),
            a = me.convert(t.format);
          K.setTexture2D(t, 0),
            ge.copyTexImage2D(3553, n, a, e.x, e.y, r, s, 0),
            Y.unbindTexture();
        }),
        (this.copyTextureToTexture = function (e, t, n, i = 0) {
          const r = t.image.width,
            s = t.image.height,
            a = me.convert(n.format),
            o = me.convert(n.type);
          K.setTexture2D(n, 0),
            ge.pixelStorei(37440, n.flipY),
            ge.pixelStorei(37441, n.premultiplyAlpha),
            ge.pixelStorei(3317, n.unpackAlignment),
            t.isDataTexture
              ? ge.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data)
              : t.isCompressedTexture
              ? ge.compressedTexSubImage2D(
                  3553,
                  i,
                  e.x,
                  e.y,
                  t.mipmaps[0].width,
                  t.mipmaps[0].height,
                  a,
                  t.mipmaps[0].data
                )
              : ge.texSubImage2D(3553, i, e.x, e.y, a, o, t.image),
            0 === i && n.generateMipmaps && ge.generateMipmap(3553),
            Y.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (e, t, n, i, r = 0) {
          if (x.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
            );
          const { width: s, height: a, data: o } = n.image,
            l = me.convert(i.format),
            c = me.convert(i.type);
          let h;
          if (i.isDataTexture3D) K.setTexture3D(i, 0), (h = 32879);
          else {
            if (!i.isDataTexture2DArray)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            K.setTexture2DArray(i, 0), (h = 35866);
          }
          ge.pixelStorei(37440, i.flipY),
            ge.pixelStorei(37441, i.premultiplyAlpha),
            ge.pixelStorei(3317, i.unpackAlignment);
          const u = ge.getParameter(3314),
            d = ge.getParameter(32878),
            p = ge.getParameter(3316),
            m = ge.getParameter(3315),
            f = ge.getParameter(32877);
          ge.pixelStorei(3314, s),
            ge.pixelStorei(32878, a),
            ge.pixelStorei(3316, e.min.x),
            ge.pixelStorei(3315, e.min.y),
            ge.pixelStorei(32877, e.min.z),
            ge.texSubImage3D(
              h,
              r,
              t.x,
              t.y,
              t.z,
              e.max.x - e.min.x + 1,
              e.max.y - e.min.y + 1,
              e.max.z - e.min.z + 1,
              l,
              c,
              o
            ),
            ge.pixelStorei(3314, u),
            ge.pixelStorei(32878, d),
            ge.pixelStorei(3316, p),
            ge.pixelStorei(3315, m),
            ge.pixelStorei(32877, f),
            0 === r && i.generateMipmaps && ge.generateMipmap(h),
            Y.unbindTexture();
        }),
        (this.initTexture = function (e) {
          K.setTexture2D(e, 0), Y.unbindTexture();
        }),
        (this.resetState = function () {
          (_ = 0), (w = 0), (b = null), Y.reset(), fe.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    (class extends Br {}.prototype.isWebGL1Renderer = !0);
    class Ur {
      constructor(e, t = 25e-5) {
        (this.name = ""), (this.color = new At(e)), (this.density = t);
      }
      clone() {
        return new Ur(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density,
        };
      }
    }
    Ur.prototype.isFogExp2 = !0;
    class Gr {
      constructor(e, t = 1, n = 1e3) {
        (this.name = ""),
          (this.color = new At(e)),
          (this.near = t),
          (this.far = n);
      }
      clone() {
        return new Gr(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far,
        };
      }
    }
    Gr.prototype.isFog = !0;
    class kr extends it {
      constructor() {
        super(),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          null !== e.background && (this.background = e.background.clone()),
          null !== e.environment && (this.environment = e.environment.clone()),
          null !== e.fog && (this.fog = e.fog.clone()),
          null !== e.overrideMaterial &&
            (this.overrideMaterial = e.overrideMaterial.clone()),
          (this.autoUpdate = e.autoUpdate),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          null !== this.background &&
            (t.object.background = this.background.toJSON(e)),
          null !== this.environment &&
            (t.object.environment = this.environment.toJSON(e)),
          null !== this.fog && (t.object.fog = this.fog.toJSON()),
          t
        );
      }
    }
    kr.prototype.isScene = !0;
    class Vr {
      constructor(e, t) {
        (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.usage = R),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = H()),
          (this.onUploadCallback = function () {});
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.array = new e.array.constructor(e.array)),
          (this.count = e.count),
          (this.stride = e.stride),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, n) {
        (e *= this.stride), (n *= t.stride);
        for (let i = 0, r = this.stride; i < r; i++)
          this.array[e + i] = t.array[n + i];
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      clone(e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = H()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              this.array.slice(0).buffer);
        const t = new this.array.constructor(
            e.arrayBuffers[this.array.buffer._uuid]
          ),
          n = new Vr(t, this.stride);
        return n.setUsage(this.usage), n;
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      toJSON(e) {
        return (
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = H()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
          {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride,
          }
        );
      }
    }
    Vr.prototype.isInterleavedBuffer = !0;
    const Wr = new te();
    class jr {
      constructor(e, t, n, i) {
        (this.name = ""),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = n),
          (this.normalized = !0 === i);
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }
      applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
          (Wr.x = this.getX(t)),
            (Wr.y = this.getY(t)),
            (Wr.z = this.getZ(t)),
            Wr.applyMatrix4(e),
            this.setXYZ(t, Wr.x, Wr.y, Wr.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Wr.x = this.getX(t)),
            (Wr.y = this.getY(t)),
            (Wr.z = this.getZ(t)),
            Wr.applyNormalMatrix(e),
            this.setXYZ(t, Wr.x, Wr.y, Wr.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Wr.x = this.getX(t)),
            (Wr.y = this.getY(t)),
            (Wr.z = this.getZ(t)),
            Wr.transformDirection(e),
            this.setXYZ(t, Wr.x, Wr.y, Wr.z);
        return this;
      }
      setX(e, t) {
        return (this.data.array[e * this.data.stride + this.offset] = t), this;
      }
      setY(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 1] = t), this
        );
      }
      setZ(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 2] = t), this
        );
      }
      setW(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 3] = t), this
        );
      }
      getX(e) {
        return this.data.array[e * this.data.stride + this.offset];
      }
      getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
      }
      getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
      }
      getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
      }
      setXY(e, t, n) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          this
        );
      }
      setXYZ(e, t, n, i) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = i),
          this
        );
      }
      setXYZW(e, t, n, i, r) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = i),
          (this.data.array[e + 3] = r),
          this
        );
      }
      clone(e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return new Pt(
            new this.array.constructor(e),
            this.itemSize,
            this.normalized
          );
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new jr(
            e.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        );
      }
      toJSON(e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: e,
            normalized: this.normalized,
          };
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
      }
    }
    jr.prototype.isInterleavedBufferAttribute = !0;
    class qr extends _t {
      constructor(e) {
        super(),
          (this.type = "SpriteMaterial"),
          (this.color = new At(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.rotation = e.rotation),
          (this.sizeAttenuation = e.sizeAttenuation),
          this
        );
      }
    }
    let Xr;
    qr.prototype.isSpriteMaterial = !0;
    const Yr = new te(),
      Zr = new te(),
      Jr = new te(),
      Kr = new j(),
      Qr = new j(),
      $r = new Ie(),
      es = new te(),
      ts = new te(),
      ns = new te(),
      is = new j(),
      rs = new j(),
      ss = new j();
    function as(e, t, n, i, r, s) {
      Kr.subVectors(e, n).addScalar(0.5).multiply(i),
        void 0 !== r
          ? ((Qr.x = s * Kr.x - r * Kr.y), (Qr.y = r * Kr.x + s * Kr.y))
          : Qr.copy(Kr),
        e.copy(t),
        (e.x += Qr.x),
        (e.y += Qr.y),
        e.applyMatrix4($r);
    }
    (class extends it {
      constructor(e) {
        if ((super(), (this.type = "Sprite"), void 0 === Xr)) {
          Xr = new Vt();
          const e = new Float32Array([
              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
              0.5, 0, 0, 1,
            ]),
            t = new Vr(e, 5);
          Xr.setIndex([0, 1, 2, 0, 2, 3]),
            Xr.setAttribute("position", new jr(t, 3, 0, !1)),
            Xr.setAttribute("uv", new jr(t, 2, 3, !1));
        }
        (this.geometry = Xr),
          (this.material = void 0 !== e ? e : new qr()),
          (this.center = new j(0.5, 0.5));
      }
      raycast(e, t) {
        null === e.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          Zr.setFromMatrixScale(this.matrixWorld),
          $r.copy(e.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            e.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          Jr.setFromMatrixPosition(this.modelViewMatrix),
          e.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            Zr.multiplyScalar(-Jr.z);
        const n = this.material.rotation;
        let i, r;
        0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
        const s = this.center;
        as(es.set(-0.5, -0.5, 0), Jr, s, Zr, i, r),
          as(ts.set(0.5, -0.5, 0), Jr, s, Zr, i, r),
          as(ns.set(0.5, 0.5, 0), Jr, s, Zr, i, r),
          is.set(0, 0),
          rs.set(1, 0),
          ss.set(1, 1);
        let a = e.ray.intersectTriangle(es, ts, ns, !1, Yr);
        if (
          null === a &&
          (as(ts.set(-0.5, 0.5, 0), Jr, s, Zr, i, r),
          rs.set(0, 1),
          (a = e.ray.intersectTriangle(es, ns, ts, !1, Yr)),
          null === a)
        )
          return;
        const o = e.ray.origin.distanceTo(Yr);
        o < e.near ||
          o > e.far ||
          t.push({
            distance: o,
            point: Yr.clone(),
            uv: xt.getUV(Yr, es, ts, ns, is, rs, ss, new j()),
            face: null,
            object: this,
          });
      }
      copy(e) {
        return (
          super.copy(e),
          void 0 !== e.center && this.center.copy(e.center),
          (this.material = e.material),
          this
        );
      }
    }.prototype.isSprite = !0);
    const os = new te(),
      ls = new Q(),
      cs = new Q(),
      hs = new te(),
      us = new Ie();
    class ds extends ln {
      constructor(e, t) {
        super(e, t),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new Ie()),
          (this.bindMatrixInverse = new Ie());
      }
      copy(e) {
        return (
          super.copy(e),
          (this.bindMode = e.bindMode),
          this.bindMatrix.copy(e.bindMatrix),
          this.bindMatrixInverse.copy(e.bindMatrixInverse),
          (this.skeleton = e.skeleton),
          this
        );
      }
      bind(e, t) {
        (this.skeleton = e),
          void 0 === t &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (t = this.matrixWorld)),
          this.bindMatrix.copy(t),
          this.bindMatrixInverse.copy(t).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const e = new Q(),
          t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
          (e.x = t.getX(n)),
            (e.y = t.getY(n)),
            (e.z = t.getZ(n)),
            (e.w = t.getW(n));
          const i = 1 / e.manhattanLength();
          i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w);
        }
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          "attached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
            : "detached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
            : console.warn(
                "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
              );
      }
      boneTransform(e, t) {
        const n = this.skeleton,
          i = this.geometry;
        ls.fromBufferAttribute(i.attributes.skinIndex, e),
          cs.fromBufferAttribute(i.attributes.skinWeight, e),
          os
            .fromBufferAttribute(i.attributes.position, e)
            .applyMatrix4(this.bindMatrix),
          t.set(0, 0, 0);
        for (let e = 0; e < 4; e++) {
          const i = cs.getComponent(e);
          if (0 !== i) {
            const r = ls.getComponent(e);
            us.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
              t.addScaledVector(hs.copy(os).applyMatrix4(us), i);
          }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
      }
    }
    ds.prototype.isSkinnedMesh = !0;
    class ps extends it {
      constructor() {
        super(), (this.type = "Bone");
      }
    }
    ps.prototype.isBone = !0;
    const ms = new Ie(),
      fs = new Ie();
    class gs {
      constructor(e = [], t = []) {
        (this.uuid = H()),
          (this.bones = e.slice(0)),
          (this.boneInverses = t),
          (this.boneMatrices = null),
          (this.boneTexture = null),
          (this.boneTextureSize = 0),
          (this.frame = -1),
          this.init();
      }
      init() {
        const e = this.bones,
          t = this.boneInverses;
        if (
          ((this.boneMatrices = new Float32Array(16 * e.length)),
          0 === t.length)
        )
          this.calculateInverses();
        else if (e.length !== t.length) {
          console.warn(
            "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
          ),
            (this.boneInverses = []);
          for (let e = 0, t = this.bones.length; e < t; e++)
            this.boneInverses.push(new Ie());
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = new Ie();
          this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(t);
        }
      }
      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t && t.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t &&
            (t.parent && t.parent.isBone
              ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
        }
      }
      update() {
        const e = this.bones,
          t = this.boneInverses,
          n = this.boneMatrices,
          i = this.boneTexture;
        for (let i = 0, r = e.length; i < r; i++) {
          const r = e[i] ? e[i].matrixWorld : fs;
          ms.multiplyMatrices(r, t[i]), ms.toArray(n, 16 * i);
        }
        null !== i && (i.needsUpdate = !0);
      }
      clone() {
        return new gs(this.bones, this.boneInverses);
      }
      getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
          const n = this.bones[t];
          if (n.name === e) return n;
        }
      }
      dispose() {
        null !== this.boneTexture &&
          (this.boneTexture.dispose(), (this.boneTexture = null));
      }
      fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
          const i = e.bones[n];
          let r = t[i];
          void 0 === r &&
            (console.warn("THREE.Skeleton: No bone found with UUID:", i),
            (r = new ps())),
            this.bones.push(r),
            this.boneInverses.push(new Ie().fromArray(e.boneInverses[n]));
        }
        return this.init(), this;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON",
          },
          bones: [],
          boneInverses: [],
        };
        e.uuid = this.uuid;
        const t = this.bones,
          n = this.boneInverses;
        for (let i = 0, r = t.length; i < r; i++) {
          const r = t[i];
          e.bones.push(r.uuid);
          const s = n[i];
          e.boneInverses.push(s.toArray());
        }
        return e;
      }
    }
    const vs = new Ie(),
      xs = new Ie(),
      ys = [],
      _s = new ln();
    (class extends ln {
      constructor(e, t, n) {
        super(e, t),
          (this.instanceMatrix = new Pt(new Float32Array(16 * n), 16)),
          (this.instanceColor = null),
          (this.count = n),
          (this.frustumCulled = !1);
      }
      copy(e) {
        return (
          super.copy(e),
          this.instanceMatrix.copy(e.instanceMatrix),
          null !== e.instanceColor &&
            (this.instanceColor = e.instanceColor.clone()),
          (this.count = e.count),
          this
        );
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, 3 * e);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, 16 * e);
      }
      raycast(e, t) {
        const n = this.matrixWorld,
          i = this.count;
        if (
          ((_s.geometry = this.geometry),
          (_s.material = this.material),
          void 0 !== _s.material)
        )
          for (let r = 0; r < i; r++) {
            this.getMatrixAt(r, vs),
              xs.multiplyMatrices(n, vs),
              (_s.matrixWorld = xs),
              _s.raycast(e, ys);
            for (let e = 0, n = ys.length; e < n; e++) {
              const n = ys[e];
              (n.instanceId = r), (n.object = this), t.push(n);
            }
            ys.length = 0;
          }
      }
      setColorAt(e, t) {
        null === this.instanceColor &&
          (this.instanceColor = new Pt(new Float32Array(3 * this.count), 3)),
          t.toArray(this.instanceColor.array, 3 * e);
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, 16 * e);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }.prototype.isInstancedMesh = !0);
    class ws extends _t {
      constructor(e) {
        super(),
          (this.type = "LineBasicMaterial"),
          (this.color = new At(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.linewidth = e.linewidth),
          (this.linecap = e.linecap),
          (this.linejoin = e.linejoin),
          (this.morphTargets = e.morphTargets),
          this
        );
      }
    }
    ws.prototype.isLineBasicMaterial = !0;
    const bs = new te(),
      Ms = new te(),
      Ss = new Ie(),
      Ts = new Pe(),
      Es = new Me();
    class As extends it {
      constructor(e = new Vt(), t = new ws()) {
        super(),
          (this.type = "Line"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.isBufferGeometry)
          if (null === e.index) {
            const t = e.attributes.position,
              n = [0];
            for (let e = 1, i = t.count; e < i; e++)
              bs.fromBufferAttribute(t, e - 1),
                Ms.fromBufferAttribute(t, e),
                (n[e] = n[e - 1]),
                (n[e] += bs.distanceTo(Ms));
            e.setAttribute("lineDistance", new Dt(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          e.isGeometry &&
            console.error(
              "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
      raycast(e, t) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = e.params.Line.threshold,
          s = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Es.copy(n.boundingSphere),
          Es.applyMatrix4(i),
          (Es.radius += r),
          !1 === e.ray.intersectsSphere(Es))
        )
          return;
        Ss.copy(i).invert(), Ts.copy(e.ray).applyMatrix4(Ss);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a,
          l = new te(),
          c = new te(),
          h = new te(),
          u = new te(),
          d = this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          const i = n.index,
            r = n.attributes.position;
          if (null !== i)
            for (
              let n = Math.max(0, s.start),
                a = Math.min(i.count, s.start + s.count) - 1;
              n < a;
              n += d
            ) {
              const s = i.getX(n),
                a = i.getX(n + 1);
              if (
                (l.fromBufferAttribute(r, s),
                c.fromBufferAttribute(r, a),
                Ts.distanceSqToSegment(l, c, u, h) > o)
              )
                continue;
              u.applyMatrix4(this.matrixWorld);
              const d = e.ray.origin.distanceTo(u);
              d < e.near ||
                d > e.far ||
                t.push({
                  distance: d,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          else
            for (
              let n = Math.max(0, s.start),
                i = Math.min(r.count, s.start + s.count) - 1;
              n < i;
              n += d
            ) {
              if (
                (l.fromBufferAttribute(r, n),
                c.fromBufferAttribute(r, n + 1),
                Ts.distanceSqToSegment(l, c, u, h) > o)
              )
                continue;
              u.applyMatrix4(this.matrixWorld);
              const i = e.ray.origin.distanceTo(u);
              i < e.near ||
                i > e.far ||
                t.push({
                  distance: i,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    As.prototype.isLine = !0;
    const Ls = new te(),
      Rs = new te();
    class Cs extends As {
      constructor(e, t) {
        super(e, t), (this.type = "LineSegments");
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.isBufferGeometry)
          if (null === e.index) {
            const t = e.attributes.position,
              n = [];
            for (let e = 0, i = t.count; e < i; e += 2)
              Ls.fromBufferAttribute(t, e),
                Rs.fromBufferAttribute(t, e + 1),
                (n[e] = 0 === e ? 0 : n[e - 1]),
                (n[e + 1] = n[e] + Ls.distanceTo(Rs));
            e.setAttribute("lineDistance", new Dt(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          e.isGeometry &&
            console.error(
              "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
    }
    Cs.prototype.isLineSegments = !0;
    class Ps extends As {
      constructor(e, t) {
        super(e, t), (this.type = "LineLoop");
      }
    }
    Ps.prototype.isLineLoop = !0;
    class Is extends _t {
      constructor(e) {
        super(),
          (this.type = "PointsMaterial"),
          (this.color = new At(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.morphTargets = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.size = e.size),
          (this.sizeAttenuation = e.sizeAttenuation),
          (this.morphTargets = e.morphTargets),
          this
        );
      }
    }
    Is.prototype.isPointsMaterial = !0;
    const Ns = new Ie(),
      Ds = new Pe(),
      Os = new Me(),
      zs = new te();
    class Hs extends it {
      constructor(e = new Vt(), t = new Is()) {
        super(),
          (this.type = "Points"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      raycast(e, t) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = e.params.Points.threshold,
          s = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Os.copy(n.boundingSphere),
          Os.applyMatrix4(i),
          (Os.radius += r),
          !1 === e.ray.intersectsSphere(Os))
        )
          return;
        Ns.copy(i).invert(), Ds.copy(e.ray).applyMatrix4(Ns);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a;
        if (n.isBufferGeometry) {
          const r = n.index,
            a = n.attributes.position;
          if (null !== r)
            for (
              let n = Math.max(0, s.start),
                l = Math.min(r.count, s.start + s.count);
              n < l;
              n++
            ) {
              const s = r.getX(n);
              zs.fromBufferAttribute(a, s), Fs(zs, s, o, i, e, t, this);
            }
          else
            for (
              let n = Math.max(0, s.start),
                r = Math.min(a.count, s.start + s.count);
              n < r;
              n++
            )
              zs.fromBufferAttribute(a, n), Fs(zs, n, o, i, e, t, this);
        } else
          console.error(
            "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    function Fs(e, t, n, i, r, s, a) {
      const o = Ds.distanceSqToPoint(e);
      if (o < n) {
        const n = new te();
        Ds.closestPointToPoint(e, n), n.applyMatrix4(i);
        const l = r.ray.origin.distanceTo(n);
        if (l < r.near || l > r.far) return;
        s.push({
          distance: l,
          distanceToRay: Math.sqrt(o),
          point: n,
          index: t,
          face: null,
          object: a,
        });
      }
    }
    (Hs.prototype.isPoints = !0),
      (class extends J {
        constructor(e, t, n, i, r, s, a, o, l) {
          super(e, t, n, i, r, s, a, o, l),
            (this.format = void 0 !== a ? a : g),
            (this.minFilter = void 0 !== s ? s : c),
            (this.magFilter = void 0 !== r ? r : c),
            (this.generateMipmaps = !1);
          const h = this;
          "requestVideoFrameCallback" in e &&
            e.requestVideoFrameCallback(function t() {
              (h.needsUpdate = !0), e.requestVideoFrameCallback(t);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          !1 == "requestVideoFrameCallback" in e &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }.prototype.isVideoTexture = !0);
    (class extends J {
      constructor(e, t, n, i, r, s, a, o, l, c, h, u) {
        super(null, s, a, o, l, c, i, r, h, u),
          (this.image = { width: t, height: n }),
          (this.mipmaps = e),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }.prototype.isCompressedTexture = !0);
    class Bs extends J {
      constructor(e, t, n, i, r, s, a, o, l) {
        super(e, t, n, i, r, s, a, o, l), (this.needsUpdate = !0);
      }
    }
    (Bs.prototype.isCanvasTexture = !0),
      (class extends J {
        constructor(e, t, n, i, r, s, o, l, c, h) {
          if ((h = void 0 !== h ? h : x) !== x && h !== y)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && h === x && (n = u),
            void 0 === n && h === y && (n = f),
            super(null, i, r, s, o, l, h, n, c),
            (this.image = { width: e, height: t }),
            (this.magFilter = void 0 !== o ? o : a),
            (this.minFilter = void 0 !== l ? l : a),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }.prototype.isDepthTexture = !0),
      new te(),
      new te(),
      new te(),
      new xt();
    function Us(e, t, n, i, r) {
      let s, a;
      if (
        r ===
        (function (e, t, n, i) {
          let r = 0;
          for (let s = t, a = n - i; s < n; s += i)
            (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])), (a = s);
          return r;
        })(e, t, n, i) >
          0
      )
        for (s = t; s < n; s += i) a = oa(s, e[s], e[s + 1], a);
      else for (s = n - i; s >= t; s -= i) a = oa(s, e[s], e[s + 1], a);
      return a && ta(a, a.next) && (la(a), (a = a.next)), a;
    }
    function Gs(e, t) {
      if (!e) return e;
      t || (t = e);
      let n,
        i = e;
      do {
        if (
          ((n = !1),
          i.steiner || (!ta(i, i.next) && 0 !== ea(i.prev, i, i.next)))
        )
          i = i.next;
        else {
          if ((la(i), (i = t = i.prev), i === i.next)) break;
          n = !0;
        }
      } while (n || i !== t);
      return t;
    }
    function ks(e, t, n, i, r, s, a) {
      if (!e) return;
      !a &&
        s &&
        (function (e, t, n, i) {
          let r = e;
          do {
            null === r.z && (r.z = Js(r.x, r.y, t, n, i)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== e);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (e) {
              let t,
                n,
                i,
                r,
                s,
                a,
                o,
                l,
                c = 1;
              do {
                for (n = e, e = null, s = null, a = 0; n; ) {
                  for (
                    a++, i = n, o = 0, t = 0;
                    t < c && (o++, (i = i.nextZ), i);
                    t++
                  );
                  for (l = c; o > 0 || (l > 0 && i); )
                    0 !== o && (0 === l || !i || n.z <= i.z)
                      ? ((r = n), (n = n.nextZ), o--)
                      : ((r = i), (i = i.nextZ), l--),
                      s ? (s.nextZ = r) : (e = r),
                      (r.prevZ = s),
                      (s = r);
                  n = i;
                }
                (s.nextZ = null), (c *= 2);
              } while (a > 1);
            })(r);
        })(e, i, r, s);
      let o,
        l,
        c = e;
      for (; e.prev !== e.next; )
        if (((o = e.prev), (l = e.next), s ? Ws(e, i, r, s) : Vs(e)))
          t.push(o.i / n),
            t.push(e.i / n),
            t.push(l.i / n),
            la(e),
            (e = l.next),
            (c = l.next);
        else if ((e = l) === c) {
          a
            ? 1 === a
              ? ks((e = js(Gs(e), t, n)), t, n, i, r, s, 2)
              : 2 === a && qs(e, t, n, i, r, s)
            : ks(Gs(e), t, n, i, r, s, 1);
          break;
        }
    }
    function Vs(e) {
      const t = e.prev,
        n = e,
        i = e.next;
      if (ea(t, n, i) >= 0) return !1;
      let r = e.next.next;
      for (; r !== e.prev; ) {
        if (
          Qs(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
          ea(r.prev, r, r.next) >= 0
        )
          return !1;
        r = r.next;
      }
      return !0;
    }
    function Ws(e, t, n, i) {
      const r = e.prev,
        s = e,
        a = e.next;
      if (ea(r, s, a) >= 0) return !1;
      const o = r.x < s.x ? (r.x < a.x ? r.x : a.x) : s.x < a.x ? s.x : a.x,
        l = r.y < s.y ? (r.y < a.y ? r.y : a.y) : s.y < a.y ? s.y : a.y,
        c = r.x > s.x ? (r.x > a.x ? r.x : a.x) : s.x > a.x ? s.x : a.x,
        h = r.y > s.y ? (r.y > a.y ? r.y : a.y) : s.y > a.y ? s.y : a.y,
        u = Js(o, l, t, n, i),
        d = Js(c, h, t, n, i);
      let p = e.prevZ,
        m = e.nextZ;
      for (; p && p.z >= u && m && m.z <= d; ) {
        if (
          p !== e.prev &&
          p !== e.next &&
          Qs(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
          ea(p.prev, p, p.next) >= 0
        )
          return !1;
        if (
          ((p = p.prevZ),
          m !== e.prev &&
            m !== e.next &&
            Qs(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
            ea(m.prev, m, m.next) >= 0)
        )
          return !1;
        m = m.nextZ;
      }
      for (; p && p.z >= u; ) {
        if (
          p !== e.prev &&
          p !== e.next &&
          Qs(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
          ea(p.prev, p, p.next) >= 0
        )
          return !1;
        p = p.prevZ;
      }
      for (; m && m.z <= d; ) {
        if (
          m !== e.prev &&
          m !== e.next &&
          Qs(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
          ea(m.prev, m, m.next) >= 0
        )
          return !1;
        m = m.nextZ;
      }
      return !0;
    }
    function js(e, t, n) {
      let i = e;
      do {
        const r = i.prev,
          s = i.next.next;
        !ta(r, s) &&
          na(r, i, i.next, s) &&
          sa(r, s) &&
          sa(s, r) &&
          (t.push(r.i / n),
          t.push(i.i / n),
          t.push(s.i / n),
          la(i),
          la(i.next),
          (i = e = s)),
          (i = i.next);
      } while (i !== e);
      return Gs(i);
    }
    function qs(e, t, n, i, r, s) {
      let a = e;
      do {
        let e = a.next.next;
        for (; e !== a.prev; ) {
          if (a.i !== e.i && $s(a, e)) {
            let o = aa(a, e);
            return (
              (a = Gs(a, a.next)),
              (o = Gs(o, o.next)),
              ks(a, t, n, i, r, s),
              void ks(o, t, n, i, r, s)
            );
          }
          e = e.next;
        }
        a = a.next;
      } while (a !== e);
    }
    function Xs(e, t) {
      return e.x - t.x;
    }
    function Ys(e, t) {
      if (
        (t = (function (e, t) {
          let n = t;
          const i = e.x,
            r = e.y;
          let s,
            a = -1 / 0;
          do {
            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
              const e = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
              if (e <= i && e > a) {
                if (((a = e), e === i)) {
                  if (r === n.y) return n;
                  if (r === n.next.y) return n.next;
                }
                s = n.x < n.next.x ? n : n.next;
              }
            }
            n = n.next;
          } while (n !== t);
          if (!s) return null;
          if (i === a) return s;
          const o = s,
            l = s.x,
            c = s.y;
          let h,
            u = 1 / 0;
          n = s;
          do {
            i >= n.x &&
              n.x >= l &&
              i !== n.x &&
              Qs(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) &&
              ((h = Math.abs(r - n.y) / (i - n.x)),
              sa(n, e) &&
                (h < u ||
                  (h === u && (n.x > s.x || (n.x === s.x && Zs(s, n))))) &&
                ((s = n), (u = h))),
              (n = n.next);
          } while (n !== o);
          return s;
        })(e, t))
      ) {
        const n = aa(t, e);
        Gs(t, t.next), Gs(n, n.next);
      }
    }
    function Zs(e, t) {
      return ea(e.prev, e, t.prev) < 0 && ea(t.next, e, e.next) < 0;
    }
    function Js(e, t, n, i, r) {
      return (
        (e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) |
        ((t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) <<
          1)
      );
    }
    function Ks(e) {
      let t = e,
        n = e;
      do {
        (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
      } while (t !== e);
      return n;
    }
    function Qs(e, t, n, i, r, s, a, o) {
      return (
        (r - a) * (t - o) - (e - a) * (s - o) >= 0 &&
        (e - a) * (i - o) - (n - a) * (t - o) >= 0 &&
        (n - a) * (s - o) - (r - a) * (i - o) >= 0
      );
    }
    function $s(e, t) {
      return (
        e.next.i !== t.i &&
        e.prev.i !== t.i &&
        !(function (e, t) {
          let n = e;
          do {
            if (
              n.i !== e.i &&
              n.next.i !== e.i &&
              n.i !== t.i &&
              n.next.i !== t.i &&
              na(n, n.next, e, t)
            )
              return !0;
            n = n.next;
          } while (n !== e);
          return !1;
        })(e, t) &&
        ((sa(e, t) &&
          sa(t, e) &&
          (function (e, t) {
            let n = e,
              i = !1;
            const r = (e.x + t.x) / 2,
              s = (e.y + t.y) / 2;
            do {
              n.y > s != n.next.y > s &&
                n.next.y !== n.y &&
                r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                (i = !i),
                (n = n.next);
            } while (n !== e);
            return i;
          })(e, t) &&
          (ea(e.prev, e, t.prev) || ea(e, t.prev, t))) ||
          (ta(e, t) && ea(e.prev, e, e.next) > 0 && ea(t.prev, t, t.next) > 0))
      );
    }
    function ea(e, t, n) {
      return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
    }
    function ta(e, t) {
      return e.x === t.x && e.y === t.y;
    }
    function na(e, t, n, i) {
      const r = ra(ea(e, t, n)),
        s = ra(ea(e, t, i)),
        a = ra(ea(n, i, e)),
        o = ra(ea(n, i, t));
      return (
        (r !== s && a !== o) ||
        !(0 !== r || !ia(e, n, t)) ||
        !(0 !== s || !ia(e, i, t)) ||
        !(0 !== a || !ia(n, e, i)) ||
        !(0 !== o || !ia(n, t, i))
      );
    }
    function ia(e, t, n) {
      return (
        t.x <= Math.max(e.x, n.x) &&
        t.x >= Math.min(e.x, n.x) &&
        t.y <= Math.max(e.y, n.y) &&
        t.y >= Math.min(e.y, n.y)
      );
    }
    function ra(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    function sa(e, t) {
      return ea(e.prev, e, e.next) < 0
        ? ea(e, t, e.next) >= 0 && ea(e, e.prev, t) >= 0
        : ea(e, t, e.prev) < 0 || ea(e, e.next, t) < 0;
    }
    function aa(e, t) {
      const n = new ca(e.i, e.x, e.y),
        i = new ca(t.i, t.x, t.y),
        r = e.next,
        s = t.prev;
      return (
        (e.next = t),
        (t.prev = e),
        (n.next = r),
        (r.prev = n),
        (i.next = n),
        (n.prev = i),
        (s.next = i),
        (i.prev = s),
        i
      );
    }
    function oa(e, t, n, i) {
      const r = new ca(e, t, n);
      return (
        i
          ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function la(e) {
      (e.next.prev = e.prev),
        (e.prev.next = e.next),
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }
    function ca(e, t, n) {
      (this.i = e),
        (this.x = t),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    class ha {
      static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, r = 0; r < t; i = r++)
          n += e[i].x * e[r].y - e[r].x * e[i].y;
        return 0.5 * n;
      }
      static isClockWise(e) {
        return ha.area(e) < 0;
      }
      static triangulateShape(e, t) {
        const n = [],
          i = [],
          r = [];
        ua(e), da(n, e);
        let s = e.length;
        t.forEach(ua);
        for (let e = 0; e < t.length; e++)
          i.push(s), (s += t[e].length), da(n, t[e]);
        const a = (function (e, t, n) {
          n = n || 2;
          const i = t && t.length,
            r = i ? t[0] * n : e.length;
          let s = Us(e, 0, r, n, !0);
          const a = [];
          if (!s || s.next === s.prev) return a;
          let o, l, c, h, u, d, p;
          if (
            (i &&
              (s = (function (e, t, n, i) {
                const r = [];
                let s, a, o, l, c;
                for (s = 0, a = t.length; s < a; s++)
                  (o = t[s] * i),
                    (l = s < a - 1 ? t[s + 1] * i : e.length),
                    (c = Us(e, o, l, i, !1)),
                    c === c.next && (c.steiner = !0),
                    r.push(Ks(c));
                for (r.sort(Xs), s = 0; s < r.length; s++)
                  Ys(r[s], n), (n = Gs(n, n.next));
                return n;
              })(e, t, s, n)),
            e.length > 80 * n)
          ) {
            (o = c = e[0]), (l = h = e[1]);
            for (let t = n; t < r; t += n)
              (u = e[t]),
                (d = e[t + 1]),
                u < o && (o = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            (p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0);
          }
          return ks(s, a, n, o, l, p), a;
        })(n, i);
        for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
        return r;
      }
    }
    function ua(e) {
      const t = e.length;
      t > 2 && e[t - 1].equals(e[0]) && e.pop();
    }
    function da(e, t) {
      for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
    }
    class pa extends Vt {
      constructor(e, t) {
        super(),
          (this.type = "ExtrudeGeometry"),
          (this.parameters = { shapes: e, options: t }),
          (e = Array.isArray(e) ? e : [e]);
        const n = this,
          i = [],
          r = [];
        for (let t = 0, n = e.length; t < n; t++) s(e[t]);
        function s(e) {
          const s = [],
            a = void 0 !== t.curveSegments ? t.curveSegments : 12,
            o = void 0 !== t.steps ? t.steps : 1;
          let l = void 0 !== t.depth ? t.depth : 100,
            c = void 0 === t.bevelEnabled || t.bevelEnabled,
            h = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            u = void 0 !== t.bevelSize ? t.bevelSize : h - 2,
            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
          const m = t.extrudePath,
            f = void 0 !== t.UVGenerator ? t.UVGenerator : ma;
          void 0 !== t.amount &&
            (console.warn(
              "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
            ),
            (l = t.amount));
          let g,
            v,
            x,
            y,
            _,
            w = !1;
          m &&
            ((g = m.getSpacedPoints(o)),
            (w = !0),
            (c = !1),
            (v = m.computeFrenetFrames(o, !1)),
            (x = new te()),
            (y = new te()),
            (_ = new te())),
            c || ((p = 0), (h = 0), (u = 0), (d = 0));
          const b = e.extractPoints(a);
          let M = b.shape;
          const S = b.holes;
          if (!ha.isClockWise(M)) {
            M = M.reverse();
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              ha.isClockWise(t) && (S[e] = t.reverse());
            }
          }
          const T = ha.triangulateShape(M, S),
            E = M;
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            M = M.concat(t);
          }
          function A(e, t, n) {
            return (
              t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
              t.clone().multiplyScalar(n).add(e)
            );
          }
          const L = M.length,
            R = T.length;
          function C(e, t, n) {
            let i, r, s;
            const a = e.x - t.x,
              o = e.y - t.y,
              l = n.x - e.x,
              c = n.y - e.y,
              h = a * a + o * o,
              u = a * c - o * l;
            if (Math.abs(u) > Number.EPSILON) {
              const u = Math.sqrt(h),
                d = Math.sqrt(l * l + c * c),
                p = t.x - o / u,
                m = t.y + a / u,
                f =
                  ((n.x - c / d - p) * c - (n.y + l / d - m) * l) /
                  (a * c - o * l);
              (i = p + a * f - e.x), (r = m + o * f - e.y);
              const g = i * i + r * r;
              if (g <= 2) return new j(i, r);
              s = Math.sqrt(g / 2);
            } else {
              let e = !1;
              a > Number.EPSILON
                ? l > Number.EPSILON && (e = !0)
                : a < -Number.EPSILON
                ? l < -Number.EPSILON && (e = !0)
                : Math.sign(o) === Math.sign(c) && (e = !0),
                e
                  ? ((i = -o), (r = a), (s = Math.sqrt(h)))
                  : ((i = a), (r = o), (s = Math.sqrt(h / 2)));
            }
            return new j(i / s, r / s);
          }
          const P = [];
          for (
            let e = 0, t = E.length, n = t - 1, i = e + 1;
            e < t;
            e++, n++, i++
          )
            n === t && (n = 0),
              i === t && (i = 0),
              (P[e] = C(E[e], E[n], E[i]));
          const I = [];
          let N,
            D = P.concat();
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            N = [];
            for (
              let e = 0, n = t.length, i = n - 1, r = e + 1;
              e < n;
              e++, i++, r++
            )
              i === n && (i = 0),
                r === n && (r = 0),
                (N[e] = C(t[e], t[i], t[r]));
            I.push(N), (D = D.concat(N));
          }
          for (let e = 0; e < p; e++) {
            const t = e / p,
              n = h * Math.cos((t * Math.PI) / 2),
              i = u * Math.sin((t * Math.PI) / 2) + d;
            for (let e = 0, t = E.length; e < t; e++) {
              const t = A(E[e], P[e], i);
              H(t.x, t.y, -n);
            }
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              N = I[e];
              for (let e = 0, r = t.length; e < r; e++) {
                const r = A(t[e], N[e], i);
                H(r.x, r.y, -n);
              }
            }
          }
          const O = u + d;
          for (let e = 0; e < L; e++) {
            const t = c ? A(M[e], D[e], O) : M[e];
            w
              ? (y.copy(v.normals[0]).multiplyScalar(t.x),
                x.copy(v.binormals[0]).multiplyScalar(t.y),
                _.copy(g[0]).add(y).add(x),
                H(_.x, _.y, _.z))
              : H(t.x, t.y, 0);
          }
          for (let e = 1; e <= o; e++)
            for (let t = 0; t < L; t++) {
              const n = c ? A(M[t], D[t], O) : M[t];
              w
                ? (y.copy(v.normals[e]).multiplyScalar(n.x),
                  x.copy(v.binormals[e]).multiplyScalar(n.y),
                  _.copy(g[e]).add(y).add(x),
                  H(_.x, _.y, _.z))
                : H(n.x, n.y, (l / o) * e);
            }
          for (let e = p - 1; e >= 0; e--) {
            const t = e / p,
              n = h * Math.cos((t * Math.PI) / 2),
              i = u * Math.sin((t * Math.PI) / 2) + d;
            for (let e = 0, t = E.length; e < t; e++) {
              const t = A(E[e], P[e], i);
              H(t.x, t.y, l + n);
            }
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              N = I[e];
              for (let e = 0, r = t.length; e < r; e++) {
                const r = A(t[e], N[e], i);
                w
                  ? H(r.x, r.y + g[o - 1].y, g[o - 1].x + n)
                  : H(r.x, r.y, l + n);
              }
            }
          }
          function z(e, t) {
            let n = e.length;
            for (; --n >= 0; ) {
              const i = n;
              let r = n - 1;
              r < 0 && (r = e.length - 1);
              for (let e = 0, n = o + 2 * p; e < n; e++) {
                const n = L * e,
                  s = L * (e + 1);
                B(t + i + n, t + r + n, t + r + s, t + i + s);
              }
            }
          }
          function H(e, t, n) {
            s.push(e), s.push(t), s.push(n);
          }
          function F(e, t, r) {
            U(e), U(t), U(r);
            const s = i.length / 3,
              a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
            G(a[0]), G(a[1]), G(a[2]);
          }
          function B(e, t, r, s) {
            U(e), U(t), U(s), U(t), U(r), U(s);
            const a = i.length / 3,
              o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
            G(o[0]), G(o[1]), G(o[3]), G(o[1]), G(o[2]), G(o[3]);
          }
          function U(e) {
            i.push(s[3 * e + 0]), i.push(s[3 * e + 1]), i.push(s[3 * e + 2]);
          }
          function G(e) {
            r.push(e.x), r.push(e.y);
          }
          !(function () {
            const e = i.length / 3;
            if (c) {
              let e = 0,
                t = L * e;
              for (let e = 0; e < R; e++) {
                const n = T[e];
                F(n[2] + t, n[1] + t, n[0] + t);
              }
              (e = o + 2 * p), (t = L * e);
              for (let e = 0; e < R; e++) {
                const n = T[e];
                F(n[0] + t, n[1] + t, n[2] + t);
              }
            } else {
              for (let e = 0; e < R; e++) {
                const t = T[e];
                F(t[2], t[1], t[0]);
              }
              for (let e = 0; e < R; e++) {
                const t = T[e];
                F(t[0] + L * o, t[1] + L * o, t[2] + L * o);
              }
            }
            n.addGroup(e, i.length / 3 - e, 0);
          })(),
            (function () {
              const e = i.length / 3;
              let t = 0;
              z(E, t), (t += E.length);
              for (let e = 0, n = S.length; e < n; e++) {
                const n = S[e];
                z(n, t), (t += n.length);
              }
              n.addGroup(e, i.length / 3 - e, 1);
            })();
        }
        this.setAttribute("position", new Dt(i, 3)),
          this.setAttribute("uv", new Dt(r, 2)),
          this.computeVertexNormals();
      }
      toJSON() {
        const e = Vt.prototype.toJSON.call(this);
        return (function (e, t, n) {
          if (((n.shapes = []), Array.isArray(e)))
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t];
              n.shapes.push(i.uuid);
            }
          else n.shapes.push(e.uuid);
          return (
            void 0 !== t.extrudePath &&
              (n.options.extrudePath = t.extrudePath.toJSON()),
            n
          );
        })(this.parameters.shapes, this.parameters.options, e);
      }
    }
    const ma = {
      generateTopUV: function (e, t, n, i, r) {
        const s = t[3 * n],
          a = t[3 * n + 1],
          o = t[3 * i],
          l = t[3 * i + 1],
          c = t[3 * r],
          h = t[3 * r + 1];
        return [new j(s, a), new j(o, l), new j(c, h)];
      },
      generateSideWallUV: function (e, t, n, i, r, s) {
        const a = t[3 * n],
          o = t[3 * n + 1],
          l = t[3 * n + 2],
          c = t[3 * i],
          h = t[3 * i + 1],
          u = t[3 * i + 2],
          d = t[3 * r],
          p = t[3 * r + 1],
          m = t[3 * r + 2],
          f = t[3 * s],
          g = t[3 * s + 1],
          v = t[3 * s + 2];
        return Math.abs(o - h) < 0.01
          ? [new j(a, 1 - l), new j(c, 1 - u), new j(d, 1 - m), new j(f, 1 - v)]
          : [
              new j(o, 1 - l),
              new j(h, 1 - u),
              new j(p, 1 - m),
              new j(g, 1 - v),
            ];
      },
    };
    class fa extends Vt {
      constructor(e, t = 12) {
        super(),
          (this.type = "ShapeGeometry"),
          (this.parameters = { shapes: e, curveSegments: t });
        const n = [],
          i = [],
          r = [],
          s = [];
        let a = 0,
          o = 0;
        if (!1 === Array.isArray(e)) l(e);
        else
          for (let t = 0; t < e.length; t++)
            l(e[t]), this.addGroup(a, o, t), (a += o), (o = 0);
        function l(e) {
          const a = i.length / 3,
            l = e.extractPoints(t);
          let c = l.shape;
          const h = l.holes;
          !1 === ha.isClockWise(c) && (c = c.reverse());
          for (let e = 0, t = h.length; e < t; e++) {
            const t = h[e];
            !0 === ha.isClockWise(t) && (h[e] = t.reverse());
          }
          const u = ha.triangulateShape(c, h);
          for (let e = 0, t = h.length; e < t; e++) {
            const t = h[e];
            c = c.concat(t);
          }
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y);
          }
          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e],
              i = t[0] + a,
              r = t[1] + a,
              s = t[2] + a;
            n.push(i, r, s), (o += 3);
          }
        }
        this.setIndex(n),
          this.setAttribute("position", new Dt(i, 3)),
          this.setAttribute("normal", new Dt(r, 3)),
          this.setAttribute("uv", new Dt(s, 2));
      }
      toJSON() {
        const e = Vt.prototype.toJSON.call(this);
        return (function (e, t) {
          if (((t.shapes = []), Array.isArray(e)))
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              t.shapes.push(i.uuid);
            }
          else t.shapes.push(e.uuid);
          return t;
        })(this.parameters.shapes, e);
      }
    }
    (class extends _t {
      constructor(e) {
        super(),
          (this.type = "ShadowMaterial"),
          (this.color = new At(0)),
          (this.transparent = !0),
          this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.color.copy(e.color), this;
      }
    }.prototype.isShadowMaterial = !0);
    (class extends mn {
      constructor(e) {
        super(e), (this.type = "RawShaderMaterial");
      }
    }.prototype.isRawShaderMaterial = !0);
    class ga extends _t {
      constructor(e) {
        super(),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new At(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new At(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new j(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.flatShading = !1),
          (this.vertexTangents = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: "" }),
          this.color.copy(e.color),
          (this.roughness = e.roughness),
          (this.metalness = e.metalness),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.roughnessMap = e.roughnessMap),
          (this.metalnessMap = e.metalnessMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.envMapIntensity = e.envMapIntensity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          (this.flatShading = e.flatShading),
          (this.vertexTangents = e.vertexTangents),
          this
        );
      }
    }
    ga.prototype.isMeshStandardMaterial = !0;
    class va extends ga {
      constructor(e) {
        super(),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoat = 0),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new j(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.reflectivity = 0.5),
          Object.defineProperty(this, "ior", {
            get: function () {
              return (
                (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
              );
            },
            set: function (e) {
              this.reflectivity = F((2.5 * (e - 1)) / (e + 1), 0, 1);
            },
          }),
          (this.sheen = null),
          (this.transmission = 0),
          (this.transmissionMap = null),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.clearcoat = e.clearcoat),
          (this.clearcoatMap = e.clearcoatMap),
          (this.clearcoatRoughness = e.clearcoatRoughness),
          (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = e.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
          (this.reflectivity = e.reflectivity),
          e.sheen
            ? (this.sheen = (this.sheen || new At()).copy(e.sheen))
            : (this.sheen = null),
          (this.transmission = e.transmission),
          (this.transmissionMap = e.transmissionMap),
          this
        );
      }
    }
    va.prototype.isMeshPhysicalMaterial = !0;
    (class extends _t {
      constructor(e) {
        super(),
          (this.type = "MeshPhongMaterial"),
          (this.color = new At(16777215)),
          (this.specular = new At(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new At(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new j(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          this.specular.copy(e.specular),
          (this.shininess = e.shininess),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }.prototype.isMeshPhongMaterial = !0);
    (class extends _t {
      constructor(e) {
        super(),
          (this.defines = { TOON: "" }),
          (this.type = "MeshToonMaterial"),
          (this.color = new At(16777215)),
          (this.map = null),
          (this.gradientMap = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new At(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new j(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.gradientMap = e.gradientMap),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.alphaMap = e.alphaMap),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          this
        );
      }
    }.prototype.isMeshToonMaterial = !0);
    (class extends _t {
      constructor(e) {
        super(),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new j(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }.prototype.isMeshNormalMaterial = !0);
    (class extends _t {
      constructor(e) {
        super(),
          (this.type = "MeshLambertMaterial"),
          (this.color = new At(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new At(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          this
        );
      }
    }.prototype.isMeshLambertMaterial = !0);
    (class extends _t {
      constructor(e) {
        super(),
          (this.defines = { MATCAP: "" }),
          (this.type = "MeshMatcapMaterial"),
          (this.color = new At(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new j(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { MATCAP: "" }),
          this.color.copy(e.color),
          (this.matcap = e.matcap),
          (this.map = e.map),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.alphaMap = e.alphaMap),
          (this.skinning = e.skinning),
          (this.morphTargets = e.morphTargets),
          (this.morphNormals = e.morphNormals),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }.prototype.isMeshMatcapMaterial = !0);
    (class extends ws {
      constructor(e) {
        super(),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.scale = e.scale),
          (this.dashSize = e.dashSize),
          (this.gapSize = e.gapSize),
          this
        );
      }
    }.prototype.isLineDashedMaterial = !0);
    const xa = {
      arraySlice: function (e, t, n) {
        return xa.isTypedArray(e)
          ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
          : e.slice(t, n);
      },
      convertArray: function (e, t, n) {
        return !e || (!n && e.constructor === t)
          ? e
          : "number" == typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      },
      isTypedArray: function (e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      },
      getKeyframeOrder: function (e) {
        const t = e.length,
          n = new Array(t);
        for (let e = 0; e !== t; ++e) n[e] = e;
        return (
          n.sort(function (t, n) {
            return e[t] - e[n];
          }),
          n
        );
      },
      sortedArray: function (e, t, n) {
        const i = e.length,
          r = new e.constructor(i);
        for (let s = 0, a = 0; a !== i; ++s) {
          const i = n[s] * t;
          for (let n = 0; n !== t; ++n) r[a++] = e[i + n];
        }
        return r;
      },
      flattenJSON: function (e, t, n, i) {
        let r = 1,
          s = e[0];
        for (; void 0 !== s && void 0 === s[i]; ) s = e[r++];
        if (void 0 === s) return;
        let a = s[i];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push.apply(n, a)),
                (s = e[r++]);
            } while (void 0 !== s);
          else if (void 0 !== a.toArray)
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), a.toArray(n, n.length)),
                (s = e[r++]);
            } while (void 0 !== s);
          else
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push(a)),
                (s = e[r++]);
            } while (void 0 !== s);
      },
      subclip: function (e, t, n, i, r = 30) {
        const s = e.clone();
        s.name = t;
        const a = [];
        for (let e = 0; e < s.tracks.length; ++e) {
          const t = s.tracks[e],
            o = t.getValueSize(),
            l = [],
            c = [];
          for (let e = 0; e < t.times.length; ++e) {
            const s = t.times[e] * r;
            if (!(s < n || s >= i)) {
              l.push(t.times[e]);
              for (let n = 0; n < o; ++n) c.push(t.values[e * o + n]);
            }
          }
          0 !== l.length &&
            ((t.times = xa.convertArray(l, t.times.constructor)),
            (t.values = xa.convertArray(c, t.values.constructor)),
            a.push(t));
        }
        s.tracks = a;
        let o = 1 / 0;
        for (let e = 0; e < s.tracks.length; ++e)
          o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
        for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
        return s.resetDuration(), s;
      },
      makeClipAdditive: function (e, t = 0, n = e, i = 30) {
        i <= 0 && (i = 30);
        const r = n.tracks.length,
          s = t / i;
        for (let t = 0; t < r; ++t) {
          const i = n.tracks[t],
            r = i.ValueTypeName;
          if ("bool" === r || "string" === r) continue;
          const a = e.tracks.find(function (e) {
            return e.name === i.name && e.ValueTypeName === r;
          });
          if (void 0 === a) continue;
          let o = 0;
          const l = i.getValueSize();
          i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (o = l / 3);
          let c = 0;
          const h = a.getValueSize();
          a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (c = h / 3);
          const u = i.times.length - 1;
          let d;
          if (s <= i.times[0]) {
            const e = o,
              t = l - o;
            d = xa.arraySlice(i.values, e, t);
          } else if (s >= i.times[u]) {
            const e = u * l + o,
              t = e + l - o;
            d = xa.arraySlice(i.values, e, t);
          } else {
            const e = i.createInterpolant(),
              t = o,
              n = l - o;
            e.evaluate(s), (d = xa.arraySlice(e.resultBuffer, t, n));
          }
          "quaternion" === r &&
            new ee().fromArray(d).normalize().conjugate().toArray(d);
          const p = a.times.length;
          for (let e = 0; e < p; ++e) {
            const t = e * h + c;
            if ("quaternion" === r)
              ee.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
            else {
              const e = h - 2 * c;
              for (let n = 0; n < e; ++n) a.values[t + n] -= d[n];
            }
          }
        }
        return (e.blendMode = 2501), e;
      },
    };
    class ya {
      constructor(e, t, n, i) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
          (this.sampleValues = t),
          (this.valueSize = n),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
          i = t[n],
          r = t[n - 1];
        e: {
          t: {
            let s;
            n: {
              i: if (!(e < i)) {
                for (let s = n + 2; ; ) {
                  if (void 0 === i) {
                    if (e < r) break i;
                    return (
                      (n = t.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, e, r)
                    );
                  }
                  if (n === s) break;
                  if (((r = i), (i = t[++n]), e < i)) break t;
                }
                s = t.length;
                break n;
              }
              if (e >= r) break e;
              {
                const a = t[1];
                e < a && ((n = 2), (r = a));
                for (let s = n - 2; ; ) {
                  if (void 0 === r)
                    return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
                  if (n === s) break;
                  if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                }
                (s = n), (n = 0);
              }
            }
            for (; n < s; ) {
              const i = (n + s) >>> 1;
              e < t[i] ? (s = i) : (n = i + 1);
            }
            if (((i = t[n]), (r = t[n - 1]), void 0 === r))
              return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
            if (void 0 === i)
              return (
                (n = t.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, r, e)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, e, i);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = e * i;
        for (let e = 0; e !== i; ++e) t[e] = n[r + e];
        return t;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    (ya.prototype.beforeStart_ = ya.prototype.copySampleValue_),
      (ya.prototype.afterEnd_ = ya.prototype.copySampleValue_);
    class _a extends ya {
      constructor(e, t, n, i) {
        super(e, t, n, i),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = { endingStart: M, endingEnd: M });
      }
      intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let r = e - 2,
          s = e + 1,
          a = i[r],
          o = i[s];
        if (void 0 === a)
          switch (this.getSettings_().endingStart) {
            case S:
              (r = e), (a = 2 * t - n);
              break;
            case T:
              (r = i.length - 2), (a = t + i[r] - i[r + 1]);
              break;
            default:
              (r = e), (a = n);
          }
        if (void 0 === o)
          switch (this.getSettings_().endingEnd) {
            case S:
              (s = e), (o = 2 * n - t);
              break;
            case T:
              (s = 1), (o = n + i[1] - i[0]);
              break;
            default:
              (s = e - 1), (o = t);
          }
        const l = 0.5 * (n - t),
          c = this.valueSize;
        (this._weightPrev = l / (t - a)),
          (this._weightNext = l / (o - n)),
          (this._offsetPrev = r * c),
          (this._offsetNext = s * c);
      }
      interpolate_(e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = e * a,
          l = o - a,
          c = this._offsetPrev,
          h = this._offsetNext,
          u = this._weightPrev,
          d = this._weightNext,
          p = (n - t) / (i - t),
          m = p * p,
          f = m * p,
          g = -u * f + 2 * u * m - u * p,
          v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
          x = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
          y = d * f - d * m;
        for (let e = 0; e !== a; ++e)
          r[e] = g * s[c + e] + v * s[l + e] + x * s[o + e] + y * s[h + e];
        return r;
      }
    }
    class wa extends ya {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      interpolate_(e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = e * a,
          l = o - a,
          c = (n - t) / (i - t),
          h = 1 - c;
        for (let e = 0; e !== a; ++e) r[e] = s[l + e] * h + s[o + e] * c;
        return r;
      }
    }
    class ba extends ya {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }
    }
    class Ma {
      constructor(e, t, n, i) {
        if (void 0 === e)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + e
          );
        (this.name = e),
          (this.times = xa.convertArray(t, this.TimeBufferType)),
          (this.values = xa.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(i || this.DefaultInterpolation);
      }
      static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON) n = t.toJSON(e);
        else {
          n = {
            name: e.name,
            times: xa.convertArray(e.times, Array),
            values: xa.convertArray(e.values, Array),
          };
          const t = e.getInterpolation();
          t !== e.DefaultInterpolation && (n.interpolation = t);
        }
        return (n.type = e.ValueTypeName), n;
      }
      InterpolantFactoryMethodDiscrete(e) {
        return new ba(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodLinear(e) {
        return new wa(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodSmooth(e) {
        return new _a(this.times, this.values, this.getValueSize(), e);
      }
      setInterpolation(e) {
        let t;
        switch (e) {
          case _:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case w:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case b:
            t = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === t) {
          const t =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (e === this.DefaultInterpolation) throw new Error(t);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", t), this;
        }
        return (this.createInterpolant = t), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return _;
          case this.InterpolantFactoryMethodLinear:
            return w;
          case this.InterpolantFactoryMethodSmooth:
            return b;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(e) {
        if (0 !== e) {
          const t = this.times;
          for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
        }
        return this;
      }
      scale(e) {
        if (1 !== e) {
          const t = this.times;
          for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
        }
        return this;
      }
      trim(e, t) {
        const n = this.times,
          i = n.length;
        let r = 0,
          s = i - 1;
        for (; r !== i && n[r] < e; ) ++r;
        for (; -1 !== s && n[s] > t; ) --s;
        if ((++s, 0 !== r || s !== i)) {
          r >= s && ((s = Math.max(s, 1)), (r = s - 1));
          const e = this.getValueSize();
          (this.times = xa.arraySlice(n, r, s)),
            (this.values = xa.arraySlice(this.values, r * e, s * e));
        }
        return this;
      }
      validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (e = !1));
        const n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (e = !1));
        let s = null;
        for (let t = 0; t !== r; t++) {
          const i = n[t];
          if ("number" == typeof i && isNaN(i)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              t,
              i
            ),
              (e = !1);
            break;
          }
          if (null !== s && s > i) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              t,
              i,
              s
            ),
              (e = !1);
            break;
          }
          s = i;
        }
        if (void 0 !== i && xa.isTypedArray(i))
          for (let t = 0, n = i.length; t !== n; ++t) {
            const n = i[t];
            if (isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                t,
                n
              ),
                (e = !1);
              break;
            }
          }
        return e;
      }
      optimize() {
        const e = xa.arraySlice(this.times),
          t = xa.arraySlice(this.values),
          n = this.getValueSize(),
          i = this.getInterpolation() === b,
          r = e.length - 1;
        let s = 1;
        for (let a = 1; a < r; ++a) {
          let r = !1;
          const o = e[a];
          if (o !== e[a + 1] && (1 !== a || o !== e[0]))
            if (i) r = !0;
            else {
              const e = a * n,
                i = e - n,
                s = e + n;
              for (let a = 0; a !== n; ++a) {
                const n = t[e + a];
                if (n !== t[i + a] || n !== t[s + a]) {
                  r = !0;
                  break;
                }
              }
            }
          if (r) {
            if (a !== s) {
              e[s] = e[a];
              const i = a * n,
                r = s * n;
              for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
            }
            ++s;
          }
        }
        if (r > 0) {
          e[s] = e[r];
          for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
            t[i + a] = t[e + a];
          ++s;
        }
        return (
          s !== e.length
            ? ((this.times = xa.arraySlice(e, 0, s)),
              (this.values = xa.arraySlice(t, 0, s * n)))
            : ((this.times = e), (this.values = t)),
          this
        );
      }
      clone() {
        const e = xa.arraySlice(this.times, 0),
          t = xa.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, e, t);
        return (n.createInterpolant = this.createInterpolant), n;
      }
    }
    (Ma.prototype.TimeBufferType = Float32Array),
      (Ma.prototype.ValueBufferType = Float32Array),
      (Ma.prototype.DefaultInterpolation = w);
    class Sa extends Ma {}
    (Sa.prototype.ValueTypeName = "bool"),
      (Sa.prototype.ValueBufferType = Array),
      (Sa.prototype.DefaultInterpolation = _),
      (Sa.prototype.InterpolantFactoryMethodLinear = void 0),
      (Sa.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Ta extends Ma {}
    Ta.prototype.ValueTypeName = "color";
    class Ea extends Ma {}
    Ea.prototype.ValueTypeName = "number";
    class Aa extends ya {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      interpolate_(e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = (n - t) / (i - t);
        let l = e * a;
        for (let e = l + a; l !== e; l += 4)
          ee.slerpFlat(r, 0, s, l - a, s, l, o);
        return r;
      }
    }
    class La extends Ma {
      InterpolantFactoryMethodLinear(e) {
        return new Aa(this.times, this.values, this.getValueSize(), e);
      }
    }
    (La.prototype.ValueTypeName = "quaternion"),
      (La.prototype.DefaultInterpolation = w),
      (La.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Ra extends Ma {}
    (Ra.prototype.ValueTypeName = "string"),
      (Ra.prototype.ValueBufferType = Array),
      (Ra.prototype.DefaultInterpolation = _),
      (Ra.prototype.InterpolantFactoryMethodLinear = void 0),
      (Ra.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Ca extends Ma {}
    Ca.prototype.ValueTypeName = "vector";
    class Pa {
      constructor(e, t = -1, n, i = 2500) {
        (this.name = e),
          (this.tracks = n),
          (this.duration = t),
          (this.blendMode = i),
          (this.uuid = H()),
          this.duration < 0 && this.resetDuration();
      }
      static parse(e) {
        const t = [],
          n = e.tracks,
          i = 1 / (e.fps || 1);
        for (let e = 0, r = n.length; e !== r; ++e) t.push(Ia(n[e]).scale(i));
        const r = new this(e.name, e.duration, t, e.blendMode);
        return (r.uuid = e.uuid), r;
      }
      static toJSON(e) {
        const t = [],
          n = e.tracks,
          i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode,
          };
        for (let e = 0, i = n.length; e !== i; ++e) t.push(Ma.toJSON(n[e]));
        return i;
      }
      static CreateFromMorphTargetSequence(e, t, n, i) {
        const r = t.length,
          s = [];
        for (let e = 0; e < r; e++) {
          let a = [],
            o = [];
          a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
          const l = xa.getKeyframeOrder(a);
          (a = xa.sortedArray(a, 1, l)),
            (o = xa.sortedArray(o, 1, l)),
            i || 0 !== a[0] || (a.push(r), o.push(o[0])),
            s.push(
              new Ea(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(
                1 / n
              )
            );
        }
        return new this(e, -1, s);
      }
      static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
          const t = e;
          n = (t.geometry && t.geometry.animations) || t.animations;
        }
        for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {},
          r = /^([\w-]*?)([\d]+)$/;
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t],
            s = n.name.match(r);
          if (s && s.length > 1) {
            const e = s[1];
            let t = i[e];
            t || (i[e] = t = []), t.push(n);
          }
        }
        const s = [];
        for (const e in i)
          s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
        return s;
      }
      static parseAnimation(e, t) {
        if (!e)
          return (
            console.error(
              "THREE.AnimationClip: No animation in JSONLoader data."
            ),
            null
          );
        const n = function (e, t, n, i, r) {
            if (0 !== n.length) {
              const s = [],
                a = [];
              xa.flattenJSON(n, s, a, i),
                0 !== s.length && r.push(new e(t, s, a));
            }
          },
          i = [],
          r = e.name || "default",
          s = e.fps || 30,
          a = e.blendMode;
        let o = e.length || -1;
        const l = e.hierarchy || [];
        for (let e = 0; e < l.length; e++) {
          const r = l[e].keys;
          if (r && 0 !== r.length)
            if (r[0].morphTargets) {
              const e = {};
              let t;
              for (t = 0; t < r.length; t++)
                if (r[t].morphTargets)
                  for (let n = 0; n < r[t].morphTargets.length; n++)
                    e[r[t].morphTargets[n]] = -1;
              for (const n in e) {
                const e = [],
                  s = [];
                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                  const i = r[t];
                  e.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                }
                i.push(new Ea(".morphTargetInfluence[" + n + "]", e, s));
              }
              o = e.length * (s || 1);
            } else {
              const s = ".bones[" + t[e].name + "]";
              n(Ca, s + ".position", r, "pos", i),
                n(La, s + ".quaternion", r, "rot", i),
                n(Ca, s + ".scale", r, "scl", i);
            }
        }
        return 0 === i.length ? null : new this(r, o, i, a);
      }
      resetDuration() {
        let e = 0;
        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
          const n = this.tracks[t];
          e = Math.max(e, n.times[n.times.length - 1]);
        }
        return (this.duration = e), this;
      }
      trim() {
        for (let e = 0; e < this.tracks.length; e++)
          this.tracks[e].trim(0, this.duration);
        return this;
      }
      validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
          e = e && this.tracks[t].validate();
        return e;
      }
      optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
      }
      clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
          e.push(this.tracks[t].clone());
        return new this.constructor(
          this.name,
          this.duration,
          e,
          this.blendMode
        );
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function Ia(e) {
      if (void 0 === e.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      const t = (function (e) {
        switch (e.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Ea;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Ca;
          case "color":
            return Ta;
          case "quaternion":
            return La;
          case "bool":
          case "boolean":
            return Sa;
          case "string":
            return Ra;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
      })(e.type);
      if (void 0 === e.times) {
        const t = [],
          n = [];
        xa.flattenJSON(e.keys, t, n, "value"), (e.times = t), (e.values = n);
      }
      return void 0 !== t.parse
        ? t.parse(e)
        : new t(e.name, e.times, e.values, e.interpolation);
    }
    const Na = {
      enabled: !1,
      files: {},
      add: function (e, t) {
        !1 !== this.enabled && (this.files[e] = t);
      },
      get: function (e) {
        if (!1 !== this.enabled) return this.files[e];
      },
      remove: function (e) {
        delete this.files[e];
      },
      clear: function () {
        this.files = {};
      },
    };
    const Da = new (class {
      constructor(e, t, n) {
        const i = this;
        let r,
          s = !1,
          a = 0,
          o = 0;
        const l = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = n),
          (this.itemStart = function (e) {
            o++,
              !1 === s && void 0 !== i.onStart && i.onStart(e, a, o),
              (s = !0);
          }),
          (this.itemEnd = function (e) {
            a++,
              void 0 !== i.onProgress && i.onProgress(e, a, o),
              a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== i.onError && i.onError(e);
          }),
          (this.resolveURL = function (e) {
            return r ? r(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (r = e), this;
          }),
          (this.addHandler = function (e, t) {
            return l.push(e, t), this;
          }),
          (this.removeHandler = function (e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this;
          }),
          (this.getHandler = function (e) {
            for (let t = 0, n = l.length; t < n; t += 2) {
              const n = l[t],
                i = l[t + 1];
              if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
            }
            return null;
          });
      }
    })();
    class Oa {
      constructor(e) {
        (this.manager = void 0 !== e ? e : Da),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(e, t) {
        const n = this;
        return new Promise(function (i, r) {
          n.load(e, i, t, r);
        });
      }
      parse() {}
      setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
      }
      setWithCredentials(e) {
        return (this.withCredentials = e), this;
      }
      setPath(e) {
        return (this.path = e), this;
      }
      setResourcePath(e) {
        return (this.resourcePath = e), this;
      }
      setRequestHeader(e) {
        return (this.requestHeader = e), this;
      }
    }
    const za = {};
    class Ha extends Oa {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          s = Na.get(e);
        if (void 0 !== s)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(s), r.manager.itemEnd(e);
            }, 0),
            s
          );
        if (void 0 !== za[e])
          return void za[e].push({ onLoad: t, onProgress: n, onError: i });
        const a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
        let o;
        if (a) {
          const n = a[1],
            s = !!a[2];
          let o = a[3];
          (o = decodeURIComponent(o)), s && (o = atob(o));
          try {
            let i;
            const s = (this.responseType || "").toLowerCase();
            switch (s) {
              case "arraybuffer":
              case "blob":
                const e = new Uint8Array(o.length);
                for (let t = 0; t < o.length; t++) e[t] = o.charCodeAt(t);
                i = "blob" === s ? new Blob([e.buffer], { type: n }) : e.buffer;
                break;
              case "document":
                const t = new DOMParser();
                i = t.parseFromString(o, n);
                break;
              case "json":
                i = JSON.parse(o);
                break;
              default:
                i = o;
            }
            setTimeout(function () {
              t && t(i), r.manager.itemEnd(e);
            }, 0);
          } catch (t) {
            setTimeout(function () {
              i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
            }, 0);
          }
        } else {
          (za[e] = []),
            za[e].push({ onLoad: t, onProgress: n, onError: i }),
            (o = new XMLHttpRequest()),
            o.open("GET", e, !0),
            o.addEventListener(
              "load",
              function (t) {
                const n = this.response,
                  i = za[e];
                if ((delete za[e], 200 === this.status || 0 === this.status)) {
                  0 === this.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    Na.add(e, n);
                  for (let e = 0, t = i.length; e < t; e++) {
                    const t = i[e];
                    t.onLoad && t.onLoad(n);
                  }
                  r.manager.itemEnd(e);
                } else {
                  for (let e = 0, n = i.length; e < n; e++) {
                    const n = i[e];
                    n.onError && n.onError(t);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                }
              },
              !1
            ),
            o.addEventListener(
              "progress",
              function (t) {
                const n = za[e];
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  i.onProgress && i.onProgress(t);
                }
              },
              !1
            ),
            o.addEventListener(
              "error",
              function (t) {
                const n = za[e];
                delete za[e];
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  i.onError && i.onError(t);
                }
                r.manager.itemError(e), r.manager.itemEnd(e);
              },
              !1
            ),
            o.addEventListener(
              "abort",
              function (t) {
                const n = za[e];
                delete za[e];
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  i.onError && i.onError(t);
                }
                r.manager.itemError(e), r.manager.itemEnd(e);
              },
              !1
            ),
            void 0 !== this.responseType &&
              (o.responseType = this.responseType),
            void 0 !== this.withCredentials &&
              (o.withCredentials = this.withCredentials),
            o.overrideMimeType &&
              o.overrideMimeType(
                void 0 !== this.mimeType ? this.mimeType : "text/plain"
              );
          for (const e in this.requestHeader)
            o.setRequestHeader(e, this.requestHeader[e]);
          o.send(null);
        }
        return r.manager.itemStart(e), o;
      }
      setResponseType(e) {
        return (this.responseType = e), this;
      }
      setMimeType(e) {
        return (this.mimeType = e), this;
      }
    }
    class Fa extends Oa {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          s = Na.get(e);
        if (void 0 !== s)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(s), r.manager.itemEnd(e);
            }, 0),
            s
          );
        const a = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "img"
        );
        function o() {
          a.removeEventListener("load", o, !1),
            a.removeEventListener("error", l, !1),
            Na.add(e, this),
            t && t(this),
            r.manager.itemEnd(e);
        }
        function l(t) {
          a.removeEventListener("load", o, !1),
            a.removeEventListener("error", l, !1),
            i && i(t),
            r.manager.itemError(e),
            r.manager.itemEnd(e);
        }
        return (
          a.addEventListener("load", o, !1),
          a.addEventListener("error", l, !1),
          "data:" !== e.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (a.crossOrigin = this.crossOrigin),
          r.manager.itemStart(e),
          (a.src = e),
          a
        );
      }
    }
    class Ba extends Oa {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const r = new yn(),
          s = new Fa(this.manager);
        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
        let a = 0;
        function o(n) {
          s.load(
            e[n],
            function (e) {
              (r.images[n] = e),
                a++,
                6 === a && ((r.needsUpdate = !0), t && t(r));
            },
            void 0,
            i
          );
        }
        for (let t = 0; t < e.length; ++t) o(t);
        return r;
      }
    }
    class Ua extends Oa {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const r = new J(),
          s = new Fa(this.manager);
        return (
          s.setCrossOrigin(this.crossOrigin),
          s.setPath(this.path),
          s.load(
            e,
            function (n) {
              r.image = n;
              const i =
                e.search(/\.jpe?g($|\?)/i) > 0 ||
                0 === e.search(/^data\:image\/jpeg/);
              (r.format = i ? g : v),
                (r.needsUpdate = !0),
                void 0 !== t && t(r);
            },
            n,
            i
          ),
          r
        );
      }
    }
    class Ga {
      constructor() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t);
      }
      getPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return t;
      }
      getSpacedPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
        return t;
      }
      getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
      }
      getLengths(e = this.arcLengthDivisions) {
        if (
          this.cacheArcLengths &&
          this.cacheArcLengths.length === e + 1 &&
          !this.needsUpdate
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n,
          i = this.getPoint(0),
          r = 0;
        t.push(0);
        for (let s = 1; s <= e; s++)
          (n = this.getPoint(s / e)),
            (r += n.distanceTo(i)),
            t.push(r),
            (i = n);
        return (this.cacheArcLengths = t), t;
      }
      updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
      }
      getUtoTmapping(e, t) {
        const n = this.getLengths();
        let i = 0;
        const r = n.length;
        let s;
        s = t || e * n[r - 1];
        let a,
          o = 0,
          l = r - 1;
        for (; o <= l; )
          if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0))
            o = i + 1;
          else {
            if (!(a > 0)) {
              l = i;
              break;
            }
            l = i - 1;
          }
        if (((i = l), n[i] === s)) return i / (r - 1);
        const c = n[i];
        return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
      }
      getTangent(e, t) {
        const n = 1e-4;
        let i = e - n,
          r = e + n;
        i < 0 && (i = 0), r > 1 && (r = 1);
        const s = this.getPoint(i),
          a = this.getPoint(r),
          o = t || (s.isVector2 ? new j() : new te());
        return o.copy(a).sub(s).normalize(), o;
      }
      getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t);
      }
      computeFrenetFrames(e, t) {
        const n = new te(),
          i = [],
          r = [],
          s = [],
          a = new te(),
          o = new Ie();
        for (let t = 0; t <= e; t++) {
          const n = t / e;
          (i[t] = this.getTangentAt(n, new te())), i[t].normalize();
        }
        (r[0] = new te()), (s[0] = new te());
        let l = Number.MAX_VALUE;
        const c = Math.abs(i[0].x),
          h = Math.abs(i[0].y),
          u = Math.abs(i[0].z);
        c <= l && ((l = c), n.set(1, 0, 0)),
          h <= l && ((l = h), n.set(0, 1, 0)),
          u <= l && n.set(0, 0, 1),
          a.crossVectors(i[0], n).normalize(),
          r[0].crossVectors(i[0], a),
          s[0].crossVectors(i[0], r[0]);
        for (let t = 1; t <= e; t++) {
          if (
            ((r[t] = r[t - 1].clone()),
            (s[t] = s[t - 1].clone()),
            a.crossVectors(i[t - 1], i[t]),
            a.length() > Number.EPSILON)
          ) {
            a.normalize();
            const e = Math.acos(F(i[t - 1].dot(i[t]), -1, 1));
            r[t].applyMatrix4(o.makeRotationAxis(a, e));
          }
          s[t].crossVectors(i[t], r[t]);
        }
        if (!0 === t) {
          let t = Math.acos(F(r[0].dot(r[e]), -1, 1));
          (t /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
          for (let n = 1; n <= e; n++)
            r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
              s[n].crossVectors(i[n], r[n]);
        }
        return { tangents: i, normals: r, binormals: s };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
      toJSON() {
        const e = {
          metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
        };
        return (
          (e.arcLengthDivisions = this.arcLengthDivisions),
          (e.type = this.type),
          e
        );
      }
      fromJSON(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
    }
    class ka extends Ga {
      constructor(
        e = 0,
        t = 0,
        n = 1,
        i = 1,
        r = 0,
        s = 2 * Math.PI,
        a = !1,
        o = 0
      ) {
        super(),
          (this.type = "EllipseCurve"),
          (this.aX = e),
          (this.aY = t),
          (this.xRadius = n),
          (this.yRadius = i),
          (this.aStartAngle = r),
          (this.aEndAngle = s),
          (this.aClockwise = a),
          (this.aRotation = o);
      }
      getPoint(e, t) {
        const n = t || new j(),
          i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(r) < Number.EPSILON;
        for (; r < 0; ) r += i;
        for (; r > i; ) r -= i;
        r < Number.EPSILON && (r = s ? 0 : i),
          !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
        const a = this.aStartAngle + e * r;
        let o = this.aX + this.xRadius * Math.cos(a),
          l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
          const e = Math.cos(this.aRotation),
            t = Math.sin(this.aRotation),
            n = o - this.aX,
            i = l - this.aY;
          (o = n * e - i * t + this.aX), (l = n * t + i * e + this.aY);
        }
        return n.set(o, l);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.aX = this.aX),
          (e.aY = this.aY),
          (e.xRadius = this.xRadius),
          (e.yRadius = this.yRadius),
          (e.aStartAngle = this.aStartAngle),
          (e.aEndAngle = this.aEndAngle),
          (e.aClockwise = this.aClockwise),
          (e.aRotation = this.aRotation),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
    }
    ka.prototype.isEllipseCurve = !0;
    class Va extends ka {
      constructor(e, t, n, i, r, s) {
        super(e, t, n, n, i, r, s), (this.type = "ArcCurve");
      }
    }
    function Wa() {
      let e = 0,
        t = 0,
        n = 0,
        i = 0;
      function r(r, s, a, o) {
        (e = r),
          (t = a),
          (n = -3 * r + 3 * s - 2 * a - o),
          (i = 2 * r - 2 * s + a + o);
      }
      return {
        initCatmullRom: function (e, t, n, i, s) {
          r(t, n, s * (n - e), s * (i - t));
        },
        initNonuniformCatmullRom: function (e, t, n, i, s, a, o) {
          let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
            c = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
          (l *= a), (c *= a), r(t, n, l, c);
        },
        calc: function (r) {
          const s = r * r;
          return e + t * r + n * s + i * (s * r);
        },
      };
    }
    Va.prototype.isArcCurve = !0;
    const ja = new te(),
      qa = new Wa(),
      Xa = new Wa(),
      Ya = new Wa();
    class Za extends Ga {
      constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
        super(),
          (this.type = "CatmullRomCurve3"),
          (this.points = e),
          (this.closed = t),
          (this.curveType = n),
          (this.tension = i);
      }
      getPoint(e, t = new te()) {
        const n = t,
          i = this.points,
          r = i.length,
          s = (r - (this.closed ? 0 : 1)) * e;
        let a,
          o,
          l = Math.floor(s),
          c = s - l;
        this.closed
          ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
          : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
          this.closed || l > 0
            ? (a = i[(l - 1) % r])
            : (ja.subVectors(i[0], i[1]).add(i[0]), (a = ja));
        const h = i[l % r],
          u = i[(l + 1) % r];
        if (
          (this.closed || l + 2 < r
            ? (o = i[(l + 2) % r])
            : (ja.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = ja)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          const e = "chordal" === this.curveType ? 0.5 : 0.25;
          let t = Math.pow(a.distanceToSquared(h), e),
            n = Math.pow(h.distanceToSquared(u), e),
            i = Math.pow(u.distanceToSquared(o), e);
          n < 1e-4 && (n = 1),
            t < 1e-4 && (t = n),
            i < 1e-4 && (i = n),
            qa.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, t, n, i),
            Xa.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, t, n, i),
            Ya.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, t, n, i);
        } else
          "catmullrom" === this.curveType &&
            (qa.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
            Xa.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
            Ya.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
        return n.set(qa.calc(c), Xa.calc(c), Ya.calc(c)), n;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return (
          (this.closed = e.closed),
          (this.curveType = e.curveType),
          (this.tension = e.tension),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return (
          (e.closed = this.closed),
          (e.curveType = this.curveType),
          (e.tension = this.tension),
          e
        );
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new te().fromArray(n));
        }
        return (
          (this.closed = e.closed),
          (this.curveType = e.curveType),
          (this.tension = e.tension),
          this
        );
      }
    }
    function Ja(e, t, n, i, r) {
      const s = 0.5 * (i - t),
        a = 0.5 * (r - n),
        o = e * e;
      return (
        (2 * n - 2 * i + s + a) * (e * o) +
        (-3 * n + 3 * i - 2 * s - a) * o +
        s * e +
        n
      );
    }
    function Ka(e, t, n, i) {
      return (
        (function (e, t) {
          const n = 1 - e;
          return n * n * t;
        })(e, t) +
        (function (e, t) {
          return 2 * (1 - e) * e * t;
        })(e, n) +
        (function (e, t) {
          return e * e * t;
        })(e, i)
      );
    }
    function Qa(e, t, n, i, r) {
      return (
        (function (e, t) {
          const n = 1 - e;
          return n * n * n * t;
        })(e, t) +
        (function (e, t) {
          const n = 1 - e;
          return 3 * n * n * e * t;
        })(e, n) +
        (function (e, t) {
          return 3 * (1 - e) * e * e * t;
        })(e, i) +
        (function (e, t) {
          return e * e * e * t;
        })(e, r)
      );
    }
    Za.prototype.isCatmullRomCurve3 = !0;
    class $a extends Ga {
      constructor(e = new j(), t = new j(), n = new j(), i = new j()) {
        super(),
          (this.type = "CubicBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = i);
      }
      getPoint(e, t = new j()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2,
          a = this.v3;
        return n.set(Qa(e, i.x, r.x, s.x, a.x), Qa(e, i.y, r.y, s.y, a.y)), n;
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this.v3.copy(e.v3),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    $a.prototype.isCubicBezierCurve = !0;
    class eo extends Ga {
      constructor(e = new te(), t = new te(), n = new te(), i = new te()) {
        super(),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = i);
      }
      getPoint(e, t = new te()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2,
          a = this.v3;
        return (
          n.set(
            Qa(e, i.x, r.x, s.x, a.x),
            Qa(e, i.y, r.y, s.y, a.y),
            Qa(e, i.z, r.z, s.z, a.z)
          ),
          n
        );
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this.v3.copy(e.v3),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    eo.prototype.isCubicBezierCurve3 = !0;
    class to extends Ga {
      constructor(e = new j(), t = new j()) {
        super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
      }
      getPoint(e, t = new j()) {
        const n = t;
        return (
          1 === e
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
          n
        );
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      getTangent(e, t) {
        const n = t || new j();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    to.prototype.isLineCurve = !0;
    class no extends Ga {
      constructor(e = new j(), t = new j(), n = new j()) {
        super(),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      getPoint(e, t = new j()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2;
        return n.set(Ka(e, i.x, r.x, s.x), Ka(e, i.y, r.y, s.y)), n;
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    no.prototype.isQuadraticBezierCurve = !0;
    class io extends Ga {
      constructor(e = new te(), t = new te(), n = new te()) {
        super(),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      getPoint(e, t = new te()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2;
        return (
          n.set(
            Ka(e, i.x, r.x, s.x),
            Ka(e, i.y, r.y, s.y),
            Ka(e, i.z, r.z, s.z)
          ),
          n
        );
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    io.prototype.isQuadraticBezierCurve3 = !0;
    class ro extends Ga {
      constructor(e = []) {
        super(), (this.type = "SplineCurve"), (this.points = e);
      }
      getPoint(e, t = new j()) {
        const n = t,
          i = this.points,
          r = (i.length - 1) * e,
          s = Math.floor(r),
          a = r - s,
          o = i[0 === s ? s : s - 1],
          l = i[s],
          c = i[s > i.length - 2 ? i.length - 1 : s + 1],
          h = i[s > i.length - 3 ? i.length - 1 : s + 2];
        return n.set(Ja(a, o.x, l.x, c.x, h.x), Ja(a, o.y, l.y, c.y, h.y)), n;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new j().fromArray(n));
        }
        return this;
      }
    }
    ro.prototype.isSplineCurve = !0;
    var so = Object.freeze({
      __proto__: null,
      ArcCurve: Va,
      CatmullRomCurve3: Za,
      CubicBezierCurve: $a,
      CubicBezierCurve3: eo,
      EllipseCurve: ka,
      LineCurve: to,
      LineCurve3: class extends Ga {
        constructor(e = new te(), t = new te()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new te()) {
          const n = t;
          return (
            1 === e
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      },
      QuadraticBezierCurve: no,
      QuadraticBezierCurve3: io,
      SplineCurve: ro,
    });
    class ao extends Ga {
      constructor() {
        super(),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      add(e) {
        this.curves.push(e);
      }
      closePath() {
        const e = this.curves[0].getPoint(0),
          t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new to(t, e));
      }
      getPoint(e) {
        const t = e * this.getLength(),
          n = this.getCurveLengths();
        let i = 0;
        for (; i < n.length; ) {
          if (n[i] >= t) {
            const e = n[i] - t,
              r = this.curves[i],
              s = r.getLength(),
              a = 0 === s ? 0 : 1 - e / s;
            return r.getPointAt(a);
          }
          i++;
        }
        return null;
      }
      getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
      }
      updateArcLengths() {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      }
      getCurveLengths() {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
          (t += this.curves[n].getLength()), e.push(t);
        return (this.cacheLengths = e), e;
      }
      getSpacedPoints(e = 40) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]), t;
      }
      getPoints(e = 12) {
        const t = [];
        let n;
        for (let i = 0, r = this.curves; i < r.length; i++) {
          const s = r[i],
            a =
              s && s.isEllipseCurve
                ? 2 * e
                : s && (s.isLineCurve || s.isLineCurve3)
                ? 1
                : s && s.isSplineCurve
                ? e * s.points.length
                : e,
            o = s.getPoints(a);
          for (let e = 0; e < o.length; e++) {
            const i = o[e];
            (n && n.equals(i)) || (t.push(i), (n = i));
          }
        }
        return (
          this.autoClose &&
            t.length > 1 &&
            !t[t.length - 1].equals(t[0]) &&
            t.push(t[0]),
          t
        );
      }
      copy(e) {
        super.copy(e), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(n.clone());
        }
        return (this.autoClose = e.autoClose), this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.autoClose = this.autoClose), (e.curves = []);
        for (let t = 0, n = this.curves.length; t < n; t++) {
          const n = this.curves[t];
          e.curves.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(new so[n.type]().fromJSON(n));
        }
        return this;
      }
    }
    class oo extends ao {
      constructor(e) {
        super(),
          (this.type = "Path"),
          (this.currentPoint = new j()),
          e && this.setFromPoints(e);
      }
      setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
        return this;
      }
      moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
      }
      lineTo(e, t) {
        const n = new to(this.currentPoint.clone(), new j(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this;
      }
      quadraticCurveTo(e, t, n, i) {
        const r = new no(this.currentPoint.clone(), new j(e, t), new j(n, i));
        return this.curves.push(r), this.currentPoint.set(n, i), this;
      }
      bezierCurveTo(e, t, n, i, r, s) {
        const a = new $a(
          this.currentPoint.clone(),
          new j(e, t),
          new j(n, i),
          new j(r, s)
        );
        return this.curves.push(a), this.currentPoint.set(r, s), this;
      }
      splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
          n = new ro(t);
        return (
          this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
        );
      }
      arc(e, t, n, i, r, s) {
        const a = this.currentPoint.x,
          o = this.currentPoint.y;
        return this.absarc(e + a, t + o, n, i, r, s), this;
      }
      absarc(e, t, n, i, r, s) {
        return this.absellipse(e, t, n, n, i, r, s), this;
      }
      ellipse(e, t, n, i, r, s, a, o) {
        const l = this.currentPoint.x,
          c = this.currentPoint.y;
        return this.absellipse(e + l, t + c, n, i, r, s, a, o), this;
      }
      absellipse(e, t, n, i, r, s, a, o) {
        const l = new ka(e, t, n, i, r, s, a, o);
        if (this.curves.length > 0) {
          const e = l.getPoint(0);
          e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }
      copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.currentPoint = this.currentPoint.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
        );
      }
    }
    class lo extends oo {
      constructor(e) {
        super(e), (this.uuid = H()), (this.type = "Shape"), (this.holes = []);
      }
      getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
          t[n] = this.holes[n].getPoints(e);
        return t;
      }
      extractPoints(e) {
        return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
      }
      copy(e) {
        super.copy(e), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, n = this.holes.length; t < n; t++) {
          const n = this.holes[t];
          e.holes.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(new oo().fromJSON(n));
        }
        return this;
      }
    }
    class co extends it {
      constructor(e, t = 1) {
        super(),
          (this.type = "Light"),
          (this.color = new At(e)),
          (this.intensity = t);
      }
      dispose() {}
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.intensity = e.intensity),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (t.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (t.object.distance = this.distance),
          void 0 !== this.angle && (t.object.angle = this.angle),
          void 0 !== this.decay && (t.object.decay = this.decay),
          void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      }
    }
    co.prototype.isLight = !0;
    (class extends co {
      constructor(e, t, n) {
        super(e, n),
          (this.type = "HemisphereLight"),
          this.position.copy(it.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new At(t));
      }
      copy(e) {
        return (
          co.prototype.copy.call(this, e),
          this.groundColor.copy(e.groundColor),
          this
        );
      }
    }.prototype.isHemisphereLight = !0);
    const ho = new Ie(),
      uo = new te(),
      po = new te();
    class mo {
      constructor(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.mapSize = new j(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new Ie()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new Sn()),
          (this._frameExtents = new j(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new Q(0, 0, 1, 1)]);
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(e) {
        const t = this.camera,
          n = this.matrix;
        uo.setFromMatrixPosition(e.matrixWorld),
          t.position.copy(uo),
          po.setFromMatrixPosition(e.target.matrixWorld),
          t.lookAt(po),
          t.updateMatrixWorld(),
          ho.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(ho),
          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          n.multiply(t.projectionMatrix),
          n.multiply(t.matrixWorldInverse);
      }
      getViewport(e) {
        return this._viewports[e];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(e) {
        return (
          (this.camera = e.camera.clone()),
          (this.bias = e.bias),
          (this.radius = e.radius),
          this.mapSize.copy(e.mapSize),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = {};
        return (
          0 !== this.bias && (e.bias = this.bias),
          0 !== this.normalBias && (e.normalBias = this.normalBias),
          1 !== this.radius && (e.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (e.mapSize = this.mapSize.toArray()),
          (e.camera = this.camera.toJSON(!1).object),
          delete e.camera.matrix,
          e
        );
      }
    }
    class fo extends mo {
      constructor() {
        super(new gn(50, 1, 0.5, 500)), (this.focus = 1);
      }
      updateMatrices(e) {
        const t = this.camera,
          n = 2 * z * e.angle * this.focus,
          i = this.mapSize.width / this.mapSize.height,
          r = e.distance || t.far;
        (n === t.fov && i === t.aspect && r === t.far) ||
          ((t.fov = n),
          (t.aspect = i),
          (t.far = r),
          t.updateProjectionMatrix()),
          super.updateMatrices(e);
      }
      copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
      }
    }
    fo.prototype.isSpotLightShadow = !0;
    class go extends co {
      constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
        super(e, t),
          (this.type = "SpotLight"),
          this.position.copy(it.DefaultUp),
          this.updateMatrix(),
          (this.target = new it()),
          (this.distance = n),
          (this.angle = i),
          (this.penumbra = r),
          (this.decay = s),
          (this.shadow = new fo());
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.distance = e.distance),
          (this.angle = e.angle),
          (this.penumbra = e.penumbra),
          (this.decay = e.decay),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    go.prototype.isSpotLight = !0;
    const vo = new Ie(),
      xo = new te(),
      yo = new te();
    class _o extends mo {
      constructor() {
        super(new gn(90, 1, 0.5, 500)),
          (this._frameExtents = new j(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new Q(2, 1, 1, 1),
            new Q(0, 1, 1, 1),
            new Q(3, 1, 1, 1),
            new Q(1, 1, 1, 1),
            new Q(3, 0, 1, 1),
            new Q(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new te(1, 0, 0),
            new te(-1, 0, 0),
            new te(0, 0, 1),
            new te(0, 0, -1),
            new te(0, 1, 0),
            new te(0, -1, 0),
          ]),
          (this._cubeUps = [
            new te(0, 1, 0),
            new te(0, 1, 0),
            new te(0, 1, 0),
            new te(0, 1, 0),
            new te(0, 0, 1),
            new te(0, 0, -1),
          ]);
      }
      updateMatrices(e, t = 0) {
        const n = this.camera,
          i = this.matrix,
          r = e.distance || n.far;
        r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
          xo.setFromMatrixPosition(e.matrixWorld),
          n.position.copy(xo),
          yo.copy(n.position),
          yo.add(this._cubeDirections[t]),
          n.up.copy(this._cubeUps[t]),
          n.lookAt(yo),
          n.updateMatrixWorld(),
          i.makeTranslation(-xo.x, -xo.y, -xo.z),
          vo.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(vo);
      }
    }
    _o.prototype.isPointLightShadow = !0;
    class wo extends co {
      constructor(e, t, n = 0, i = 1) {
        super(e, t),
          (this.type = "PointLight"),
          (this.distance = n),
          (this.decay = i),
          (this.shadow = new _o());
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.distance = e.distance),
          (this.decay = e.decay),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    wo.prototype.isPointLight = !0;
    class bo extends fn {
      constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
        super(),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = e),
          (this.right = t),
          (this.top = n),
          (this.bottom = i),
          (this.near = r),
          (this.far = s),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.left = e.left),
          (this.right = e.right),
          (this.top = e.top),
          (this.bottom = e.bottom),
          (this.near = e.near),
          (this.far = e.far),
          (this.zoom = e.zoom),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          this
        );
      }
      setViewOffset(e, t, n, i, r, s) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
        let r = n - e,
          s = n + e,
          a = i + t,
          o = i - t;
        if (null !== this.view && this.view.enabled) {
          const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (r += e * this.view.offsetX),
            (s = r + e * this.view.width),
            (a -= t * this.view.offsetY),
            (o = a - t * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
        );
      }
    }
    bo.prototype.isOrthographicCamera = !0;
    class Mo extends mo {
      constructor() {
        super(new bo(-5, 5, 5, -5, 0.5, 500));
      }
    }
    Mo.prototype.isDirectionalLightShadow = !0;
    class So extends co {
      constructor(e, t) {
        super(e, t),
          (this.type = "DirectionalLight"),
          this.position.copy(it.DefaultUp),
          this.updateMatrix(),
          (this.target = new it()),
          (this.shadow = new Mo());
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    So.prototype.isDirectionalLight = !0;
    class To extends co {
      constructor(e, t) {
        super(e, t), (this.type = "AmbientLight");
      }
    }
    To.prototype.isAmbientLight = !0;
    (class extends co {
      constructor(e, t, n = 10, i = 10) {
        super(e, t),
          (this.type = "RectAreaLight"),
          (this.width = n),
          (this.height = i);
      }
      copy(e) {
        return (
          super.copy(e), (this.width = e.width), (this.height = e.height), this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.width = this.width), (t.object.height = this.height), t
        );
      }
    }.prototype.isRectAreaLight = !0);
    class Eo {
      constructor() {
        this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new te());
      }
      set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this;
      }
      zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this;
      }
      getAt(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z,
          s = this.coefficients;
        return (
          t.copy(s[0]).multiplyScalar(0.282095),
          t.addScaledVector(s[1], 0.488603 * i),
          t.addScaledVector(s[2], 0.488603 * r),
          t.addScaledVector(s[3], 0.488603 * n),
          t.addScaledVector(s[4], n * i * 1.092548),
          t.addScaledVector(s[5], i * r * 1.092548),
          t.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
          t.addScaledVector(s[7], n * r * 1.092548),
          t.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
          t
        );
      }
      getIrradianceAt(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z,
          s = this.coefficients;
        return (
          t.copy(s[0]).multiplyScalar(0.886227),
          t.addScaledVector(s[1], 1.023328 * i),
          t.addScaledVector(s[2], 1.023328 * r),
          t.addScaledVector(s[3], 1.023328 * n),
          t.addScaledVector(s[4], 0.858086 * n * i),
          t.addScaledVector(s[5], 0.858086 * i * r),
          t.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
          t.addScaledVector(s[7], 0.858086 * n * r),
          t.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
          t
        );
      }
      add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this;
      }
      addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this;
      }
      scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this;
      }
      lerp(e, t) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].lerp(e.coefficients[n], t);
        return this;
      }
      equals(e) {
        for (let t = 0; t < 9; t++)
          if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
      }
      copy(e) {
        return this.set(e.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(e, t = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
        return e;
      }
      static getBasisAt(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z;
        (t[0] = 0.282095),
          (t[1] = 0.488603 * i),
          (t[2] = 0.488603 * r),
          (t[3] = 0.488603 * n),
          (t[4] = 1.092548 * n * i),
          (t[5] = 1.092548 * i * r),
          (t[6] = 0.315392 * (3 * r * r - 1)),
          (t[7] = 1.092548 * n * r),
          (t[8] = 0.546274 * (n * n - i * i));
      }
    }
    Eo.prototype.isSphericalHarmonics3 = !0;
    class Ao extends co {
      constructor(e = new Eo(), t = 1) {
        super(void 0, t), (this.sh = e);
      }
      copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
      }
      fromJSON(e) {
        return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (t.object.sh = this.sh.toArray()), t;
      }
    }
    Ao.prototype.isLightProbe = !0;
    class Lo {
      static decodeText(e) {
        if ("undefined" != typeof TextDecoder)
          return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++)
          t += String.fromCharCode(e[n]);
        try {
          return decodeURIComponent(escape(t));
        } catch (e) {
          return t;
        }
      }
      static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1);
      }
    }
    (class extends Vt {
      constructor() {
        super(),
          (this.type = "InstancedBufferGeometry"),
          (this.instanceCount = 1 / 0);
      }
      copy(e) {
        return super.copy(e), (this.instanceCount = e.instanceCount), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = super.toJSON(this);
        return (
          (e.instanceCount = this.instanceCount),
          (e.isInstancedBufferGeometry = !0),
          e
        );
      }
    }.prototype.isInstancedBufferGeometry = !0);
    (class extends Pt {
      constructor(e, t, n, i) {
        "number" == typeof n &&
          ((i = n),
          (n = !1),
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
          )),
          super(e, t, n),
          (this.meshPerAttribute = i || 1);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.meshPerAttribute = this.meshPerAttribute),
          (e.isInstancedBufferAttribute = !0),
          e
        );
      }
    }.prototype.isInstancedBufferAttribute = !0);
    class Ro extends Oa {
      constructor(e) {
        super(e),
          "undefined" == typeof createImageBitmap &&
            console.warn(
              "THREE.ImageBitmapLoader: createImageBitmap() not supported."
            ),
          "undefined" == typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          (this.options = { premultiplyAlpha: "none" });
      }
      setOptions(e) {
        return (this.options = e), this;
      }
      load(e, t, n, i) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          s = Na.get(e);
        if (void 0 !== s)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(s), r.manager.itemEnd(e);
            }, 0),
            s
          );
        const a = {};
        (a.credentials =
          "anonymous" === this.crossOrigin ? "same-origin" : "include"),
          (a.headers = this.requestHeader),
          fetch(e, a)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(
                e,
                Object.assign(r.options, { colorSpaceConversion: "none" })
              );
            })
            .then(function (n) {
              Na.add(e, n), t && t(n), r.manager.itemEnd(e);
            })
            .catch(function (t) {
              i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
            }),
          r.manager.itemStart(e);
      }
    }
    Ro.prototype.isImageBitmapLoader = !0;
    let Co;
    class Po extends Oa {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const r = this,
          s = new Ha(this.manager);
        s.setResponseType("arraybuffer"),
          s.setPath(this.path),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(this.withCredentials),
          s.load(
            e,
            function (n) {
              try {
                const e = n.slice(0);
                (void 0 === Co &&
                  (Co = new (window.AudioContext ||
                    window.webkitAudioContext)()),
                Co).decodeAudioData(e, function (e) {
                  t(e);
                });
              } catch (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e);
              }
            },
            n,
            i
          );
      }
    }
    ((class extends Ao {
      constructor(e, t, n = 1) {
        super(void 0, n);
        const i = new At().set(e),
          r = new At().set(t),
          s = new te(i.r, i.g, i.b),
          a = new te(r.r, r.g, r.b),
          o = Math.sqrt(Math.PI),
          l = o * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
          this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
      }
    }.prototype.isHemisphereLightProbe = !0),
      (class extends Ao {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new At().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }.prototype.isAmbientLightProbe = !0));
    class Io {
      constructor(e, t, n) {
        let i, r, s;
        switch (((this.binding = e), (this.valueSize = n), t)) {
          case "quaternion":
            (i = this._slerp),
              (r = this._slerpAdditive),
              (s = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(6 * n)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (i = this._select),
              (r = this._select),
              (s = this._setAdditiveIdentityOther),
              (this.buffer = new Array(5 * n));
            break;
          default:
            (i = this._lerp),
              (r = this._lerpAdditive),
              (s = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(5 * n));
        }
        (this._mixBufferRegion = i),
          (this._mixBufferRegionAdditive = r),
          (this._setIdentity = s),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      accumulate(e, t) {
        const n = this.buffer,
          i = this.valueSize,
          r = e * i + i;
        let s = this.cumulativeWeight;
        if (0 === s) {
          for (let e = 0; e !== i; ++e) n[r + e] = n[e];
          s = t;
        } else {
          s += t;
          const e = t / s;
          this._mixBufferRegion(n, r, 0, e, i);
        }
        this.cumulativeWeight = s;
      }
      accumulateAdditive(e) {
        const t = this.buffer,
          n = this.valueSize,
          i = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(),
          this._mixBufferRegionAdditive(t, i, 0, e, n),
          (this.cumulativeWeightAdditive += e);
      }
      apply(e) {
        const t = this.valueSize,
          n = this.buffer,
          i = e * t + t,
          r = this.cumulativeWeight,
          s = this.cumulativeWeightAdditive,
          a = this.binding;
        if (
          ((this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          r < 1)
        ) {
          const e = t * this._origIndex;
          this._mixBufferRegion(n, i, e, 1 - r, t);
        }
        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
        for (let e = t, r = t + t; e !== r; ++e)
          if (n[e] !== n[e + t]) {
            a.setValue(n, i);
            break;
          }
      }
      saveOriginalState() {
        const e = this.binding,
          t = this.buffer,
          n = this.valueSize,
          i = n * this._origIndex;
        e.getValue(t, i);
        for (let e = n, r = i; e !== r; ++e) t[e] = t[i + (e % n)];
        this._setIdentity(),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0);
      }
      restoreOriginalState() {
        const e = 3 * this.valueSize;
        this.binding.setValue(this.buffer, e);
      }
      _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
          t = e + this.valueSize;
        for (let n = e; n < t; n++) this.buffer[n] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
          (this.buffer[this._addIndex * this.valueSize + 3] = 1);
      }
      _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
          t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
          this.buffer[t + n] = this.buffer[e + n];
      }
      _select(e, t, n, i, r) {
        if (i >= 0.5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i];
      }
      _slerp(e, t, n, i) {
        ee.slerpFlat(e, t, e, t, e, n, i);
      }
      _slerpAdditive(e, t, n, i, r) {
        const s = this._workIndex * r;
        ee.multiplyQuaternionsFlat(e, s, e, t, e, n),
          ee.slerpFlat(e, t, e, t, e, s, i);
      }
      _lerp(e, t, n, i, r) {
        const s = 1 - i;
        for (let a = 0; a !== r; ++a) {
          const r = t + a;
          e[r] = e[r] * s + e[n + a] * i;
        }
      }
      _lerpAdditive(e, t, n, i, r) {
        for (let s = 0; s !== r; ++s) {
          const r = t + s;
          e[r] = e[r] + e[n + s] * i;
        }
      }
    }
    const No = new RegExp("[\\[\\]\\.:\\/]", "g"),
      Do = "[^\\[\\]\\.:\\/]",
      Oo = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      zo = /((?:WC+[\/:])*)/.source.replace("WC", Do),
      Ho = /(WCOD+)?/.source.replace("WCOD", Oo),
      Fo = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Do),
      Bo = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Do),
      Uo = new RegExp("^" + zo + Ho + Fo + Bo + "$"),
      Go = ["material", "materials", "bones"];
    class ko {
      constructor(e, t, n) {
        (this.path = t),
          (this.parsedPath = n || ko.parseTrackName(t)),
          (this.node = ko.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(e, t, n) {
        return e && e.isAnimationObjectGroup
          ? new ko.Composite(e, t, n)
          : new ko(e, t, n);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(No, "");
      }
      static parseTrackName(e) {
        const t = Uo.exec(e);
        if (!t)
          throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6],
          },
          i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
          const e = n.nodeName.substring(i + 1);
          -1 !== Go.indexOf(e) &&
            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + e
          );
        return n;
      }
      static findNode(e, t) {
        if (
          !t ||
          "" === t ||
          "." === t ||
          -1 === t ||
          t === e.name ||
          t === e.uuid
        )
          return e;
        if (e.skeleton) {
          const n = e.skeleton.getBoneByName(t);
          if (void 0 !== n) return n;
        }
        if (e.children) {
          const n = function (e) {
              for (let i = 0; i < e.length; i++) {
                const r = e[i];
                if (r.name === t || r.uuid === t) return r;
                const s = n(r.children);
                if (s) return s;
              }
              return null;
            },
            i = n(e.children);
          if (i) return i;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, t) {
        e[t] = this.node[this.propertyName];
      }
      _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
      }
      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }
      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }
      _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
      }
      _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }
      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }
      bind() {
        let e = this.node;
        const t = this.parsedPath,
          n = t.objectName,
          i = t.propertyName;
        let r = t.propertyIndex;
        if (
          (e ||
            ((e = ko.findNode(this.rootNode, t.nodeName) || this.rootNode),
            (this.node = e)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !e)
        )
          return void console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found."
          );
        if (n) {
          let i = t.objectIndex;
          switch (n) {
            case "materials":
              if (!e.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!e.material.materials)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
              e = e.skeleton.bones;
              for (let t = 0; t < e.length; t++)
                if (e[t].name === i) {
                  i = t;
                  break;
                }
              break;
            default:
              if (void 0 === e[n])
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
              e = e[n];
          }
          if (void 0 !== i) {
            if (void 0 === e[i])
              return void console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                e
              );
            e = e[i];
          }
        }
        const s = e[i];
        if (void 0 === s) {
          const n = t.nodeName;
          return void console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              n +
              "." +
              i +
              " but it wasn't found.",
            e
          );
        }
        let a = this.Versioning.None;
        (this.targetObject = e),
          void 0 !== e.needsUpdate
            ? (a = this.Versioning.NeedsUpdate)
            : void 0 !== e.matrixWorldNeedsUpdate &&
              (a = this.Versioning.MatrixWorldNeedsUpdate);
        let o = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === i) {
            if (!e.geometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
            if (!e.geometry.isBufferGeometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                this
              );
            if (!e.geometry.morphAttributes)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
            void 0 !== e.morphTargetDictionary[r] &&
              (r = e.morphTargetDictionary[r]);
          }
          (o = this.BindingType.ArrayElement),
            (this.resolvedProperty = s),
            (this.propertyIndex = r);
        } else
          void 0 !== s.fromArray && void 0 !== s.toArray
            ? ((o = this.BindingType.HasFromToArray),
              (this.resolvedProperty = s))
            : Array.isArray(s)
            ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
            : (this.propertyName = i);
        (this.getValue = this.GetterByBindingType[o]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
      }
      unbind() {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    }
    (ko.Composite = class {
      constructor(e, t, n) {
        const i = n || ko.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
      }
      getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
        void 0 !== i && i.getValue(e, t);
      }
      setValue(e, t) {
        const n = this._bindings;
        for (
          let i = this._targetGroup.nCachedObjects_, r = n.length;
          i !== r;
          ++i
        )
          n[i].setValue(e, t);
      }
      bind() {
        const e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, n = e.length;
          t !== n;
          ++t
        )
          e[t].bind();
      }
      unbind() {
        const e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, n = e.length;
          t !== n;
          ++t
        )
          e[t].unbind();
      }
    }),
      (ko.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
      (ko.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      }),
      (ko.prototype.GetterByBindingType = [
        ko.prototype._getValue_direct,
        ko.prototype._getValue_array,
        ko.prototype._getValue_arrayElement,
        ko.prototype._getValue_toArray,
      ]),
      (ko.prototype.SetterByBindingTypeAndVersioning = [
        [
          ko.prototype._setValue_direct,
          ko.prototype._setValue_direct_setNeedsUpdate,
          ko.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          ko.prototype._setValue_array,
          ko.prototype._setValue_array_setNeedsUpdate,
          ko.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          ko.prototype._setValue_arrayElement,
          ko.prototype._setValue_arrayElement_setNeedsUpdate,
          ko.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          ko.prototype._setValue_fromArray,
          ko.prototype._setValue_fromArray_setNeedsUpdate,
          ko.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]);
    class Vo {
      constructor(e, t, n = null, i = t.blendMode) {
        (this._mixer = e),
          (this._clip = t),
          (this._localRoot = n),
          (this.blendMode = i);
        const r = t.tracks,
          s = r.length,
          a = new Array(s),
          o = { endingStart: M, endingEnd: M };
        for (let e = 0; e !== s; ++e) {
          const t = r[e].createInterpolant(null);
          (a[e] = t), (t.settings = o);
        }
        (this._interpolantSettings = o),
          (this._interpolants = a),
          (this._propertyBindings = new Array(s)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = 2201),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      }
      isRunning() {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(e) {
        return (this._startTime = e), this;
      }
      setLoop(e, t) {
        return (this.loop = e), (this.repetitions = t), this;
      }
      setEffectiveWeight(e) {
        return (
          (this.weight = e),
          (this._effectiveWeight = this.enabled ? e : 0),
          this.stopFading()
        );
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
      }
      fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
      }
      crossFadeFrom(e, t, n) {
        if ((e.fadeOut(t), this.fadeIn(t), n)) {
          const n = this._clip.duration,
            i = e._clip.duration,
            r = i / n,
            s = n / i;
          e.warp(1, r, t), this.warp(s, 1, t);
        }
        return this;
      }
      crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n);
      }
      stopFading() {
        const e = this._weightInterpolant;
        return (
          null !== e &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      setEffectiveTimeScale(e) {
        return (
          (this.timeScale = e),
          (this._effectiveTimeScale = this.paused ? 0 : e),
          this.stopWarping()
        );
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(e) {
        return (this.timeScale = this._clip.duration / e), this.stopWarping();
      }
      syncWith(e) {
        return (
          (this.time = e.time),
          (this.timeScale = e.timeScale),
          this.stopWarping()
        );
      }
      halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
      }
      warp(e, t, n) {
        const i = this._mixer,
          r = i.time,
          s = this.timeScale;
        let a = this._timeScaleInterpolant;
        null === a &&
          ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        const o = a.parameterPositions,
          l = a.sampleValues;
        return (o[0] = r), (o[1] = r + n), (l[0] = e / s), (l[1] = t / s), this;
      }
      stopWarping() {
        const e = this._timeScaleInterpolant;
        return (
          null !== e &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(e, t, n, i) {
        if (!this.enabled) return void this._updateWeight(e);
        const r = this._startTime;
        if (null !== r) {
          const i = (e - r) * n;
          if (i < 0 || 0 === n) return;
          (this._startTime = null), (t = n * i);
        }
        t *= this._updateTimeScale(e);
        const s = this._updateTime(t),
          a = this._updateWeight(e);
        if (a > 0) {
          const e = this._interpolants,
            t = this._propertyBindings;
          switch (this.blendMode) {
            case 2501:
              for (let n = 0, i = e.length; n !== i; ++n)
                e[n].evaluate(s), t[n].accumulateAdditive(a);
              break;
            case 2500:
            default:
              for (let n = 0, r = e.length; n !== r; ++n)
                e[n].evaluate(s), t[n].accumulate(i, a);
          }
        }
      }
      _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
          t = this.weight;
          const n = this._weightInterpolant;
          if (null !== n) {
            const i = n.evaluate(e)[0];
            (t *= i),
              e > n.parameterPositions[1] &&
                (this.stopFading(), 0 === i && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = t), t;
      }
      _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
          t = this.timeScale;
          const n = this._timeScaleInterpolant;
          null !== n &&
            ((t *= n.evaluate(e)[0]),
            e > n.parameterPositions[1] &&
              (this.stopWarping(),
              0 === t ? (this.paused = !0) : (this.timeScale = t)));
        }
        return (this._effectiveTimeScale = t), t;
      }
      _updateTime(e) {
        const t = this._clip.duration,
          n = this.loop;
        let i = this.time + e,
          r = this._loopCount;
        const s = 2202 === n;
        if (0 === e) return -1 === r ? i : s && 1 == (1 & r) ? t - i : i;
        if (2200 === n) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          e: {
            if (i >= t) i = t;
            else {
              if (!(i < 0)) {
                this.time = i;
                break e;
              }
              i = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === r &&
              (e >= 0
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                : this._setEndings(0 === this.repetitions, !0, s)),
            i >= t || i < 0)
          ) {
            const n = Math.floor(i / t);
            (i -= t * n), (r += Math.abs(n));
            const a = this.repetitions - r;
            if (a <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (i = e > 0 ? t : 0),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e > 0 ? 1 : -1,
                });
            else {
              if (1 === a) {
                const t = e < 0;
                this._setEndings(t, !t, s);
              } else this._setEndings(!1, !1, s);
              (this._loopCount = r),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: n,
                });
            }
          } else this.time = i;
          if (s && 1 == (1 & r)) return t - i;
        }
        return i;
      }
      _setEndings(e, t, n) {
        const i = this._interpolantSettings;
        n
          ? ((i.endingStart = S), (i.endingEnd = S))
          : ((i.endingStart = e ? (this.zeroSlopeAtStart ? S : M) : T),
            (i.endingEnd = t ? (this.zeroSlopeAtEnd ? S : M) : T));
      }
      _scheduleFading(e, t, n) {
        const i = this._mixer,
          r = i.time;
        let s = this._weightInterpolant;
        null === s &&
          ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
        const a = s.parameterPositions,
          o = s.sampleValues;
        return (a[0] = r), (o[0] = t), (a[1] = r + e), (o[1] = n), this;
      }
    }
    (class extends I {
      constructor(e) {
        super(),
          (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      _bindAction(e, t) {
        const n = e._localRoot || this._root,
          i = e._clip.tracks,
          r = i.length,
          s = e._propertyBindings,
          a = e._interpolants,
          o = n.uuid,
          l = this._bindingsByRootAndName;
        let c = l[o];
        void 0 === c && ((c = {}), (l[o] = c));
        for (let e = 0; e !== r; ++e) {
          const r = i[e],
            l = r.name;
          let h = c[l];
          if (void 0 !== h) s[e] = h;
          else {
            if (((h = s[e]), void 0 !== h)) {
              null === h._cacheIndex &&
                (++h.referenceCount, this._addInactiveBinding(h, o, l));
              continue;
            }
            const i = t && t._propertyBindings[e].binding.parsedPath;
            (h = new Io(ko.create(n, l, i), r.ValueTypeName, r.getValueSize())),
              ++h.referenceCount,
              this._addInactiveBinding(h, o, l),
              (s[e] = h);
          }
          a[e].resultBuffer = h.buffer;
        }
      }
      _activateAction(e) {
        if (!this._isActiveAction(e)) {
          if (null === e._cacheIndex) {
            const t = (e._localRoot || this._root).uuid,
              n = e._clip.uuid,
              i = this._actionsByClip[n];
            this._bindAction(e, i && i.knownActions[0]),
              this._addInactiveAction(e, n, t);
          }
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
          }
          this._lendAction(e);
        }
      }
      _deactivateAction(e) {
        if (this._isActiveAction(e)) {
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.useCount &&
              (n.restoreOriginalState(), this._takeBackBinding(n));
          }
          this._takeBackAction(e);
        }
      }
      _initMemoryManager() {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        const e = this;
        this.stats = {
          actions: {
            get total() {
              return e._actions.length;
            },
            get inUse() {
              return e._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return e._bindings.length;
            },
            get inUse() {
              return e._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return e._controlInterpolants.length;
            },
            get inUse() {
              return e._nActiveControlInterpolants;
            },
          },
        };
      }
      _isActiveAction(e) {
        const t = e._cacheIndex;
        return null !== t && t < this._nActiveActions;
      }
      _addInactiveAction(e, t, n) {
        const i = this._actions,
          r = this._actionsByClip;
        let s = r[t];
        if (void 0 === s)
          (s = { knownActions: [e], actionByRoot: {} }),
            (e._byClipCacheIndex = 0),
            (r[t] = s);
        else {
          const t = s.knownActions;
          (e._byClipCacheIndex = t.length), t.push(e);
        }
        (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[n] = e);
      }
      _removeInactiveAction(e) {
        const t = this._actions,
          n = t[t.length - 1],
          i = e._cacheIndex;
        (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
        const r = e._clip.uuid,
          s = this._actionsByClip,
          a = s[r],
          o = a.knownActions,
          l = o[o.length - 1],
          c = e._byClipCacheIndex;
        (l._byClipCacheIndex = c),
          (o[c] = l),
          o.pop(),
          (e._byClipCacheIndex = null),
          delete a.actionByRoot[(e._localRoot || this._root).uuid],
          0 === o.length && delete s[r],
          this._removeInactiveBindingsForAction(e);
      }
      _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let e = 0, n = t.length; e !== n; ++e) {
          const n = t[e];
          0 == --n.referenceCount && this._removeInactiveBinding(n);
        }
      }
      _lendAction(e) {
        const t = this._actions,
          n = e._cacheIndex,
          i = this._nActiveActions++,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _takeBackAction(e) {
        const t = this._actions,
          n = e._cacheIndex,
          i = --this._nActiveActions,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _addInactiveBinding(e, t, n) {
        const i = this._bindingsByRootAndName,
          r = this._bindings;
        let s = i[t];
        void 0 === s && ((s = {}), (i[t] = s)),
          (s[n] = e),
          (e._cacheIndex = r.length),
          r.push(e);
      }
      _removeInactiveBinding(e) {
        const t = this._bindings,
          n = e.binding,
          i = n.rootNode.uuid,
          r = n.path,
          s = this._bindingsByRootAndName,
          a = s[i],
          o = t[t.length - 1],
          l = e._cacheIndex;
        (o._cacheIndex = l),
          (t[l] = o),
          t.pop(),
          delete a[r],
          0 === Object.keys(a).length && delete s[i];
      }
      _lendBinding(e) {
        const t = this._bindings,
          n = e._cacheIndex,
          i = this._nActiveBindings++,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _takeBackBinding(e) {
        const t = this._bindings,
          n = e._cacheIndex,
          i = --this._nActiveBindings,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _lendControlInterpolant() {
        const e = this._controlInterpolants,
          t = this._nActiveControlInterpolants++;
        let n = e[t];
        return (
          void 0 === n &&
            ((n = new wa(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer
            )),
            (n.__cacheIndex = t),
            (e[t] = n)),
          n
        );
      }
      _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
          n = e.__cacheIndex,
          i = --this._nActiveControlInterpolants,
          r = t[i];
        (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
      }
      clipAction(e, t, n) {
        const i = t || this._root,
          r = i.uuid;
        let s = "string" == typeof e ? Pa.findByName(i, e) : e;
        const a = null !== s ? s.uuid : e,
          o = this._actionsByClip[a];
        let l = null;
        if (
          (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o)
        ) {
          const e = o.actionByRoot[r];
          if (void 0 !== e && e.blendMode === n) return e;
          (l = o.knownActions[0]), null === s && (s = l._clip);
        }
        if (null === s) return null;
        const c = new Vo(this, s, t, n);
        return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
      }
      existingAction(e, t) {
        const n = t || this._root,
          i = n.uuid,
          r = "string" == typeof e ? Pa.findByName(n, e) : e,
          s = r ? r.uuid : e,
          a = this._actionsByClip[s];
        return (void 0 !== a && a.actionByRoot[i]) || null;
      }
      stopAllAction() {
        const e = this._actions;
        for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
        return this;
      }
      update(e) {
        e *= this.timeScale;
        const t = this._actions,
          n = this._nActiveActions,
          i = (this.time += e),
          r = Math.sign(e),
          s = (this._accuIndex ^= 1);
        for (let a = 0; a !== n; ++a) t[a]._update(i, e, r, s);
        const a = this._bindings,
          o = this._nActiveBindings;
        for (let e = 0; e !== o; ++e) a[e].apply(s);
        return this;
      }
      setTime(e) {
        this.time = 0;
        for (let e = 0; e < this._actions.length; e++)
          this._actions[e].time = 0;
        return this.update(e);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(e) {
        const t = this._actions,
          n = e.uuid,
          i = this._actionsByClip,
          r = i[n];
        if (void 0 !== r) {
          const e = r.knownActions;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const i = e[n];
            this._deactivateAction(i);
            const r = i._cacheIndex,
              s = t[t.length - 1];
            (i._cacheIndex = null),
              (i._byClipCacheIndex = null),
              (s._cacheIndex = r),
              (t[r] = s),
              t.pop(),
              this._removeInactiveBindingsForAction(i);
          }
          delete i[n];
        }
      }
      uncacheRoot(e) {
        const t = e.uuid,
          n = this._actionsByClip;
        for (const e in n) {
          const i = n[e].actionByRoot[t];
          void 0 !== i &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
        }
        const i = this._bindingsByRootAndName[t];
        if (void 0 !== i)
          for (const e in i) {
            const t = i[e];
            t.restoreOriginalState(), this._removeInactiveBinding(t);
          }
      }
      uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        null !== n &&
          (this._deactivateAction(n), this._removeInactiveAction(n));
      }
    }.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
    class Wo {
      constructor(e) {
        "string" == typeof e &&
          (console.warn("THREE.Uniform: Type parameter is no longer needed."),
          (e = arguments[1])),
          (this.value = e);
      }
      clone() {
        return new Wo(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }
    }
    (class extends Vr {
      constructor(e, t, n = 1) {
        super(e, t), (this.meshPerAttribute = n || 1);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      clone(e) {
        const t = super.clone(e);
        return (t.meshPerAttribute = this.meshPerAttribute), t;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.isInstancedInterleavedBuffer = !0),
          (t.meshPerAttribute = this.meshPerAttribute),
          t
        );
      }
    }.prototype.isInstancedInterleavedBuffer = !0);
    const jo = new j();
    class qo {
      constructor(e = new j(1 / 0, 1 / 0), t = new j(-1 / 0, -1 / 0)) {
        (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const n = jo.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .getCenter() target is now required"),
            (e = new j())),
          this.isEmpty()
            ? e.set(0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      }
      getSize(e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .getSize() target is now required"),
            (e = new j())),
          this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        );
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y
        );
      }
      getParameter(e, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getParameter() target is now required"),
            (t = new j())),
          t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y)
          )
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y
        );
      }
      clampPoint(e, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .clampPoint() target is now required"),
            (t = new j())),
          t.copy(e).clamp(this.min, this.max)
        );
      }
      distanceToPoint(e) {
        return jo.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this;
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    (qo.prototype.isBox2 = !0),
      (class extends it {
        constructor(e) {
          super(),
            (this.material = e),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0);
        }
      }.prototype.isImmediateRenderObject = !0);
    const Xo = new te(),
      Yo = new Ie(),
      Zo = new Ie();
    function Jo(e) {
      const t = [];
      e && e.isBone && t.push(e);
      for (let n = 0; n < e.children.length; n++)
        t.push.apply(t, Jo(e.children[n]));
      return t;
    }
    const Ko = new Float32Array(1);
    new Int32Array(Ko.buffer), Math.pow(2, 8);
    const Qo = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      $o = 5 + Qo.length,
      el = new Lt({ side: 1, depthWrite: !1, depthTest: !1 }),
      {
        _lodPlanes: tl,
        _sizeLods: nl,
        _sigmas: il,
      } = (new ln(new hn(), el), rl());
    function rl() {
      const e = [],
        t = [],
        n = [];
      let i = 8;
      for (let r = 0; r < $o; r++) {
        const s = Math.pow(2, i);
        t.push(s);
        let a = 1 / s;
        r > 4 ? (a = Qo[r - 8 + 4 - 1]) : 0 == r && (a = 0), n.push(a);
        const o = 1 / (s - 1),
          l = -o / 2,
          c = 1 + o / 2,
          h = [l, l, c, l, c, c, l, l, c, c, l, c],
          u = 6,
          d = 6,
          p = 3,
          m = 2,
          f = 1,
          g = new Float32Array(p * d * u),
          v = new Float32Array(m * d * u),
          x = new Float32Array(f * d * u);
        for (let e = 0; e < u; e++) {
          const t = ((e % 3) * 2) / 3 - 1,
            n = e > 2 ? 0 : -1,
            i = [
              t,
              n,
              0,
              t + 2 / 3,
              n,
              0,
              t + 2 / 3,
              n + 1,
              0,
              t,
              n,
              0,
              t + 2 / 3,
              n + 1,
              0,
              t,
              n + 1,
              0,
            ];
          g.set(i, p * d * e), v.set(h, m * d * e);
          const r = [e, e, e, e, e, e];
          x.set(r, f * d * e);
        }
        const y = new Vt();
        y.setAttribute("position", new Pt(g, p)),
          y.setAttribute("uv", new Pt(v, m)),
          y.setAttribute("faceIndex", new Pt(x, f)),
          e.push(y),
          i > 4 && i--;
      }
      return { _lodPlanes: e, _sizeLods: t, _sigmas: n };
    }
    Math.sqrt(5),
      (Ga.create = function (e, t) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (e.prototype = Object.create(Ga.prototype)),
          (e.prototype.constructor = e),
          (e.prototype.getPoint = t),
          e
        );
      }),
      (oo.prototype.fromPoints = function (e) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(e)
        );
      }),
      (class extends Cs {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new At(n)), (i = new At(i));
          const r = t / 2,
            s = e / t,
            a = e / 2,
            o = [],
            l = [];
          for (let e = 0, c = 0, h = -a; e <= t; e++, h += s) {
            o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
            const t = e === r ? n : i;
            t.toArray(l, c),
              (c += 3),
              t.toArray(l, c),
              (c += 3),
              t.toArray(l, c),
              (c += 3),
              t.toArray(l, c),
              (c += 3);
          }
          const c = new Vt();
          c.setAttribute("position", new Dt(o, 3)),
            c.setAttribute("color", new Dt(l, 3)),
            super(c, new ws({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "GridHelper");
        }
      }.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (class extends Cs {
        constructor(e) {
          const t = Jo(e),
            n = new Vt(),
            i = [],
            r = [],
            s = new At(0, 0, 1),
            a = new At(0, 1, 0);
          for (let e = 0; e < t.length; e++) {
            const n = t[e];
            n.parent &&
              n.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(s.r, s.g, s.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new Dt(i, 3)),
            n.setAttribute("color", new Dt(r, 3)),
            super(
              n,
              new ws({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
              })
            ),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          Zo.copy(this.root.matrixWorld).invert();
          for (let e = 0, n = 0; e < t.length; e++) {
            const r = t[e];
            r.parent &&
              r.parent.isBone &&
              (Yo.multiplyMatrices(Zo, r.matrixWorld),
              Xo.setFromMatrixPosition(Yo),
              i.setXYZ(n, Xo.x, Xo.y, Xo.z),
              Yo.multiplyMatrices(Zo, r.parent.matrixWorld),
              Xo.setFromMatrixPosition(Yo),
              i.setXYZ(n + 1, Xo.x, Xo.y, Xo.z),
              (n += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      (Oa.prototype.extractUrlBase = function (e) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Lo.extractUrlBase(e)
        );
      }),
      (Oa.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      }),
      (qo.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (qo.prototype.empty = function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (qo.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (qo.prototype.size = function (e) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      }),
      (re.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (re.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (re.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (re.prototype.isIntersectionSphere = function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      }),
      (re.prototype.size = function (e) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      }),
      (Me.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      }),
      (Sn.prototype.setFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(e)
        );
      }),
      (q.prototype.flattenToArrayOffset = function (e, t) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      }),
      (q.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      }),
      (q.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      }),
      (q.prototype.applyToBufferAttribute = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      }),
      (q.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      }),
      (q.prototype.getInverse = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      }),
      (Ie.prototype.extractPosition = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(e)
        );
      }),
      (Ie.prototype.flattenToArrayOffset = function (e, t) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      }),
      (Ie.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new te().setFromMatrixColumn(this, 3)
        );
      }),
      (Ie.prototype.setRotationFromQuaternion = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(e)
        );
      }),
      (Ie.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }),
      (Ie.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Ie.prototype.multiplyVector4 = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Ie.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      }),
      (Ie.prototype.rotateAxis = function (e) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          e.transformDirection(this);
      }),
      (Ie.prototype.crossVector = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Ie.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }),
      (Ie.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }),
      (Ie.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }),
      (Ie.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }),
      (Ie.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }),
      (Ie.prototype.applyToBufferAttribute = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Ie.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      }),
      (Ie.prototype.makeFrustum = function (e, t, n, i, r, s) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(e, t, i, n, r, s)
        );
      }),
      (Ie.prototype.getInverse = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      }),
      (ot.prototype.isIntersectionLine = function (e) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(e)
        );
      }),
      (ee.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          e.applyQuaternion(this)
        );
      }),
      (ee.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      }),
      (Pe.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (Pe.prototype.isIntersectionPlane = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(e)
        );
      }),
      (Pe.prototype.isIntersectionSphere = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      }),
      (xt.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      }),
      (xt.prototype.barycoordFromPoint = function (e, t) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(e, t)
        );
      }),
      (xt.prototype.midpoint = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(e)
        );
      }),
      (xt.prototypenormal = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(e)
        );
      }),
      (xt.prototype.plane = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(e)
        );
      }),
      (xt.barycoordFromPoint = function (e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          xt.getBarycoord(e, t, n, i, r)
        );
      }),
      (xt.normal = function (e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          xt.getNormal(e, t, n, i)
        );
      }),
      (lo.prototype.extractAllPoints = function (e) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(e)
        );
      }),
      (lo.prototype.extrude = function (e) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new pa(this, e)
        );
      }),
      (lo.prototype.makeGeometry = function (e) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new fa(this, e)
        );
      }),
      (j.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (j.prototype.distanceToManhattan = function (e) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      }),
      (j.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (te.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      }),
      (te.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      }),
      (te.prototype.getPositionFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(e)
        );
      }),
      (te.prototype.getScaleFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(e)
        );
      }),
      (te.prototype.getColumnFromMatrix = function (e, t) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(t, e)
        );
      }),
      (te.prototype.applyProjection = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(e)
        );
      }),
      (te.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (te.prototype.distanceToManhattan = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      }),
      (te.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (Q.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (Q.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (it.prototype.getChildByName = function (e) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(e)
        );
      }),
      (it.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      }),
      (it.prototype.translate = function (e, t) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(t, e)
        );
      }),
      (it.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      }),
      (it.prototype.applyMatrix = function (e) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      }),
      Object.defineProperties(it.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (e) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = e);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      (ln.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      }),
      Object.defineProperties(ln.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              0
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      }),
      (ds.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      (gn.prototype.setLens = function (e, t) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== t && (this.filmGauge = t),
          this.setFocalLength(e);
      }),
      Object.defineProperties(co.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = e);
          },
        },
        shadowCameraLeft: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = e);
          },
        },
        shadowCameraRight: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = e);
          },
        },
        shadowCameraTop: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = e);
          },
        },
        shadowCameraBottom: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = e);
          },
        },
        shadowCameraNear: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = e);
          },
        },
        shadowCameraFar: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = e);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (e) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = e);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = e);
          },
        },
        shadowMapHeight: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = e);
          },
        },
      }),
      Object.defineProperties(Pt.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === C
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(C);
          },
        },
      }),
      (Pt.prototype.setDynamic = function (e) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? C : R),
          this
        );
      }),
      (Pt.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
      (Pt.prototype.setArray = function () {
        console.error(
          "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (Vt.prototype.addIndex = function (e) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(e);
      }),
      (Vt.prototype.addAttribute = function (e, t) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
            ? "index" === e
              ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                ),
                this.setIndex(t),
                this)
              : this.setAttribute(e, t)
            : (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(e, new Pt(arguments[1], arguments[2])))
        );
      }),
      (Vt.prototype.addDrawCall = function (e, t, n) {
        void 0 !== n &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(e, t);
      }),
      (Vt.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      }),
      (Vt.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      }),
      (Vt.prototype.removeAttribute = function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(e)
        );
      }),
      (Vt.prototype.applyMatrix = function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      }),
      Object.defineProperties(Vt.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      (Vr.prototype.setDynamic = function (e) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? C : R),
          this
        );
      }),
      (Vr.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (pa.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      }),
      (pa.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      }),
      (pa.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      }),
      (kr.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      }),
      (Wo.prototype.onUpdate = function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      }),
      Object.defineProperties(_t.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new At()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (e) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === e);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (e) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = e);
          },
        },
      }),
      Object.defineProperties(mn.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (e) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = e);
          },
        },
      }),
      (Br.prototype.clearTarget = function (e, t, n, i) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(e),
          this.clear(t, n, i);
      }),
      (Br.prototype.animate = function (e) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(e);
      }),
      (Br.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      }),
      (Br.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      }),
      (Br.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      }),
      (Br.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      }),
      (Br.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      }),
      (Br.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      }),
      (Br.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      }),
      (Br.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      }),
      (Br.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      }),
      (Br.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      }),
      (Br.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      }),
      (Br.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      }),
      (Br.prototype.enableScissorTest = function (e) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(e);
      }),
      (Br.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }),
      (Br.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }),
      (Br.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }),
      (Br.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      }),
      (Br.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      }),
      (Br.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      }),
      (Br.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }),
      (Br.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }),
      (Br.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      }),
      (Br.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      }),
      Object.defineProperties(Br.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = e);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = e);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = !0 === e ? A : E);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      }),
      Object.defineProperties(Rr.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      }),
      Object.defineProperties($.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = e);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = e);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = e);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = e);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = e);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = e);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = e);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = e);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = e);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = e);
          },
        },
      }),
      (class extends it {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (!0 === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl)
            return void console.warn(
              "THREE.Audio: this Audio has no playback control."
            );
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._progress = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            !0 === this._connected
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = e),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = e),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }.prototype.load = function (e) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const t = this;
        return (
          new Po().load(e, function (e) {
            t.setBuffer(e);
          }),
          this
        );
      }),
      (xn.prototype.updateCubeMap = function (e, t) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(e, t)
        );
      }),
      (xn.prototype.clear = function (e, t, n, i) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(e, t, n, i)
        );
      }),
      (Y.crossOrigin = void 0),
      (Y.loadTexture = function (e, t, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const r = new Ua();
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(e, n, void 0, i);
        return t && (s.mapping = t), s;
      }),
      (Y.loadTextureCube = function (e, t, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const r = new Ba();
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(e, n, void 0, i);
        return t && (s.mapping = t), s;
      }),
      (Y.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (Y.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      }),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: "128" } })
        ),
      "undefined" != typeof window &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = "128"));
    class sl extends Oa {
      constructor(e) {
        super(e),
          (this.dracoLoader = null),
          (this.ktx2Loader = null),
          (this.meshoptDecoder = null),
          (this.pluginCallbacks = []),
          this.register(function (e) {
            return new hl(e);
          }),
          this.register(function (e) {
            return new dl(e);
          }),
          this.register(function (e) {
            return new pl(e);
          }),
          this.register(function (e) {
            return new ul(e);
          }),
          this.register(function (e) {
            return new ll(e);
          }),
          this.register(function (e) {
            return new ml(e);
          });
      }
      load(e, t, n, i) {
        const r = this;
        let s;
        (s =
          "" !== this.resourcePath
            ? this.resourcePath
            : "" !== this.path
            ? this.path
            : Lo.extractUrlBase(e)),
          this.manager.itemStart(e);
        const a = function (t) {
            i ? i(t) : console.error(t),
              r.manager.itemError(e),
              r.manager.itemEnd(e);
          },
          o = new Ha(this.manager);
        o.setPath(this.path),
          o.setResponseType("arraybuffer"),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                r.parse(
                  n,
                  s,
                  function (n) {
                    t(n), r.manager.itemEnd(e);
                  },
                  a
                );
              } catch (e) {
                a(e);
              }
            },
            n,
            a
          );
      }
      setDRACOLoader(e) {
        return (this.dracoLoader = e), this;
      }
      setDDSLoader() {
        throw new Error(
          'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
        );
      }
      setKTX2Loader(e) {
        return (this.ktx2Loader = e), this;
      }
      setMeshoptDecoder(e) {
        return (this.meshoptDecoder = e), this;
      }
      register(e) {
        return (
          -1 === this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.push(e),
          this
        );
      }
      unregister(e) {
        return (
          -1 !== this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
          this
        );
      }
      parse(e, t, n, i) {
        let r;
        const s = {},
          a = {};
        if ("string" == typeof e) r = e;
        else if (Lo.decodeText(new Uint8Array(e, 0, 4)) === fl) {
          try {
            s[ol.KHR_BINARY_GLTF] = new gl(e);
          } catch (e) {
            return void (i && i(e));
          }
          r = s[ol.KHR_BINARY_GLTF].content;
        } else r = Lo.decodeText(new Uint8Array(e));
        const o = JSON.parse(r);
        if (void 0 === o.asset || o.asset.version[0] < 2)
          return void (
            i &&
            i(
              new Error(
                "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
              )
            )
          );
        const l = new Hl(o, {
          path: t || this.resourcePath || "",
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder,
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let e = 0; e < this.pluginCallbacks.length; e++) {
          const t = this.pluginCallbacks[e](l);
          (a[t.name] = t), (s[t.name] = !0);
        }
        if (o.extensionsUsed)
          for (let e = 0; e < o.extensionsUsed.length; ++e) {
            const t = o.extensionsUsed[e],
              n = o.extensionsRequired || [];
            switch (t) {
              case ol.KHR_MATERIALS_UNLIT:
                s[t] = new cl();
                break;
              case ol.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                s[t] = new _l();
                break;
              case ol.KHR_DRACO_MESH_COMPRESSION:
                s[t] = new vl(o, this.dracoLoader);
                break;
              case ol.KHR_TEXTURE_TRANSFORM:
                s[t] = new xl();
                break;
              case ol.KHR_MESH_QUANTIZATION:
                s[t] = new wl();
                break;
              default:
                n.indexOf(t) >= 0 &&
                  void 0 === a[t] &&
                  console.warn(
                    'THREE.GLTFLoader: Unknown extension "' + t + '".'
                  );
            }
          }
        l.setExtensions(s), l.setPlugins(a), l.parse(n, i);
      }
    }
    function al() {
      let e = {};
      return {
        get: function (t) {
          return e[t];
        },
        add: function (t, n) {
          e[t] = n;
        },
        remove: function (t) {
          delete e[t];
        },
        removeAll: function () {
          e = {};
        },
      };
    }
    const ol = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
        "KHR_materials_pbrSpecularGlossiness",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    };
    class ll {
      constructor(e) {
        (this.parser = e),
          (this.name = ol.KHR_LIGHTS_PUNCTUAL),
          (this.cache = { refs: {}, uses: {} });
      }
      _markDefs() {
        const e = this.parser,
          t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          i.extensions &&
            i.extensions[this.name] &&
            void 0 !== i.extensions[this.name].light &&
            e._addNodeRef(this.cache, i.extensions[this.name].light);
        }
      }
      _loadLight(e) {
        const t = this.parser,
          n = "light:" + e;
        let i = t.cache.get(n);
        if (i) return i;
        const r = t.json,
          s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[
            e
          ];
        let a;
        const o = new At(16777215);
        void 0 !== s.color && o.fromArray(s.color);
        const l = void 0 !== s.range ? s.range : 0;
        switch (s.type) {
          case "directional":
            (a = new So(o)), a.target.position.set(0, 0, -1), a.add(a.target);
            break;
          case "point":
            (a = new wo(o)), (a.distance = l);
            break;
          case "spot":
            (a = new go(o)),
              (a.distance = l),
              (s.spot = s.spot || {}),
              (s.spot.innerConeAngle =
                void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
              (s.spot.outerConeAngle =
                void 0 !== s.spot.outerConeAngle
                  ? s.spot.outerConeAngle
                  : Math.PI / 4),
              (a.angle = s.spot.outerConeAngle),
              (a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
              a.target.position.set(0, 0, -1),
              a.add(a.target);
            break;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unexpected light type: " + s.type
            );
        }
        return (
          a.position.set(0, 0, 0),
          (a.decay = 2),
          void 0 !== s.intensity && (a.intensity = s.intensity),
          (a.name = t.createUniqueName(s.name || "light_" + e)),
          (i = Promise.resolve(a)),
          t.cache.add(n, i),
          i
        );
      }
      createNodeAttachment(e) {
        const t = this,
          n = this.parser,
          i = n.json.nodes[e],
          r = ((i.extensions && i.extensions[this.name]) || {}).light;
        return void 0 === r
          ? null
          : this._loadLight(r).then(function (e) {
              return n._getNodeRef(t.cache, r, e);
            });
      }
    }
    class cl {
      constructor() {
        this.name = ol.KHR_MATERIALS_UNLIT;
      }
      getMaterialType() {
        return Lt;
      }
      extendParams(e, t, n) {
        const i = [];
        (e.color = new At(1, 1, 1)), (e.opacity = 1);
        const r = t.pbrMetallicRoughness;
        if (r) {
          if (Array.isArray(r.baseColorFactor)) {
            const t = r.baseColorFactor;
            e.color.fromArray(t), (e.opacity = t[3]);
          }
          void 0 !== r.baseColorTexture &&
            i.push(n.assignTexture(e, "map", r.baseColorTexture));
        }
        return Promise.all(i);
      }
    }
    class hl {
      constructor(e) {
        (this.parser = e), (this.name = ol.KHR_MATERIALS_CLEARCOAT);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? va : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [],
          s = i.extensions[this.name];
        if (
          (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
          void 0 !== s.clearcoatTexture &&
            r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
          void 0 !== s.clearcoatRoughnessFactor &&
            (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
          void 0 !== s.clearcoatRoughnessTexture &&
            r.push(
              n.assignTexture(
                t,
                "clearcoatRoughnessMap",
                s.clearcoatRoughnessTexture
              )
            ),
          void 0 !== s.clearcoatNormalTexture &&
            (r.push(
              n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)
            ),
            void 0 !== s.clearcoatNormalTexture.scale))
        ) {
          const e = s.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new j(e, -e);
        }
        return Promise.all(r);
      }
    }
    class ul {
      constructor(e) {
        (this.parser = e), (this.name = ol.KHR_MATERIALS_TRANSMISSION);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? va : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [],
          s = i.extensions[this.name];
        return (
          void 0 !== s.transmissionFactor &&
            (t.transmission = s.transmissionFactor),
          void 0 !== s.transmissionTexture &&
            r.push(
              n.assignTexture(t, "transmissionMap", s.transmissionTexture)
            ),
          Promise.all(r)
        );
      }
    }
    class dl {
      constructor(e) {
        (this.parser = e), (this.name = ol.KHR_TEXTURE_BASISU);
      }
      loadTexture(e) {
        const t = this.parser,
          n = t.json,
          i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name]) return null;
        const r = i.extensions[this.name],
          s = n.images[r.source],
          a = t.options.ktx2Loader;
        if (!a) {
          if (
            n.extensionsRequired &&
            n.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
            );
          return null;
        }
        return t.loadTextureImage(e, s, a);
      }
    }
    class pl {
      constructor(e) {
        (this.parser = e),
          (this.name = ol.EXT_TEXTURE_WEBP),
          (this.isSupported = null);
      }
      loadTexture(e) {
        const t = this.name,
          n = this.parser,
          i = n.json,
          r = i.textures[e];
        if (!r.extensions || !r.extensions[t]) return null;
        const s = r.extensions[t],
          a = i.images[s.source];
        let o = n.textureLoader;
        if (a.uri) {
          const e = n.options.manager.getHandler(a.uri);
          null !== e && (o = e);
        }
        return this.detectSupport().then(function (r) {
          if (r) return n.loadTextureImage(e, a, o);
          if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
            throw new Error(
              "THREE.GLTFLoader: WebP required by asset but unsupported."
            );
          return n.loadTexture(e);
        });
      }
      detectSupport() {
        return (
          this.isSupported ||
            (this.isSupported = new Promise(function (e) {
              const t = new Image();
              (t.src =
                "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                (t.onload = t.onerror =
                  function () {
                    e(1 === t.height);
                  });
            })),
          this.isSupported
        );
      }
    }
    class ml {
      constructor(e) {
        (this.name = ol.EXT_MESHOPT_COMPRESSION), (this.parser = e);
      }
      loadBufferView(e) {
        const t = this.parser.json,
          n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
          const e = n.extensions[this.name],
            i = this.parser.getDependency("buffer", e.buffer),
            r = this.parser.options.meshoptDecoder;
          if (!r || !r.supported) {
            if (
              t.extensionsRequired &&
              t.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
              );
            return null;
          }
          return Promise.all([i, r.ready]).then(function (t) {
            const n = e.byteOffset || 0,
              i = e.byteLength || 0,
              s = e.count,
              a = e.byteStride,
              o = new ArrayBuffer(s * a),
              l = new Uint8Array(t[0], n, i);
            return (
              r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter),
              o
            );
          });
        }
        return null;
      }
    }
    const fl = "glTF";
    class gl {
      constructor(e) {
        (this.name = ol.KHR_BINARY_GLTF),
          (this.content = null),
          (this.body = null);
        const t = new DataView(e, 0, 12);
        if (
          ((this.header = {
            magic: Lo.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0),
          }),
          this.header.magic !== fl)
        )
          throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
          throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - 12,
          i = new DataView(e, 12);
        let r = 0;
        for (; r < n; ) {
          const t = i.getUint32(r, !0);
          r += 4;
          const n = i.getUint32(r, !0);
          if (((r += 4), 1313821514 === n)) {
            const n = new Uint8Array(e, 12 + r, t);
            this.content = Lo.decodeText(n);
          } else if (5130562 === n) {
            const n = 12 + r;
            this.body = e.slice(n, n + t);
          }
          r += t;
        }
        if (null === this.content)
          throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
    class vl {
      constructor(e, t) {
        if (!t)
          throw new Error(
            "THREE.GLTFLoader: No DRACOLoader instance provided."
          );
        (this.name = ol.KHR_DRACO_MESH_COMPRESSION),
          (this.json = e),
          (this.dracoLoader = t),
          this.dracoLoader.preload();
      }
      decodePrimitive(e, t) {
        const n = this.json,
          i = this.dracoLoader,
          r = e.extensions[this.name].bufferView,
          s = e.extensions[this.name].attributes,
          a = {},
          o = {},
          l = {};
        for (const e in s) {
          const t = Al[e] || e.toLowerCase();
          a[t] = s[e];
        }
        for (const t in e.attributes) {
          const i = Al[t] || t.toLowerCase();
          if (void 0 !== s[t]) {
            const r = n.accessors[e.attributes[t]],
              s = Ml[r.componentType];
            (l[i] = s), (o[i] = !0 === r.normalized);
          }
        }
        return t.getDependency("bufferView", r).then(function (e) {
          return new Promise(function (t) {
            i.decodeDracoFile(
              e,
              function (e) {
                for (const t in e.attributes) {
                  const n = e.attributes[t],
                    i = o[t];
                  void 0 !== i && (n.normalized = i);
                }
                t(e);
              },
              a,
              l
            );
          });
        });
      }
    }
    class xl {
      constructor() {
        this.name = ol.KHR_TEXTURE_TRANSFORM;
      }
      extendTexture(e, t) {
        return (
          (e = e.clone()),
          void 0 !== t.offset && e.offset.fromArray(t.offset),
          void 0 !== t.rotation && (e.rotation = t.rotation),
          void 0 !== t.scale && e.repeat.fromArray(t.scale),
          void 0 !== t.texCoord &&
            console.warn(
              'THREE.GLTFLoader: Custom UV sets in "' +
                this.name +
                '" extension not yet supported.'
            ),
          (e.needsUpdate = !0),
          e
        );
      }
    }
    class yl extends ga {
      constructor(e) {
        super(), (this.isGLTFSpecularGlossinessMaterial = !0);
        const t = [
            "#ifdef USE_SPECULARMAP",
            "\tuniform sampler2D specularMap;",
            "#endif",
          ].join("\n"),
          n = [
            "#ifdef USE_GLOSSINESSMAP",
            "\tuniform sampler2D glossinessMap;",
            "#endif",
          ].join("\n"),
          i = [
            "vec3 specularFactor = specular;",
            "#ifdef USE_SPECULARMAP",
            "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
            "\ttexelSpecular = sRGBToLinear( texelSpecular );",
            "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "\tspecularFactor *= texelSpecular.rgb;",
            "#endif",
          ].join("\n"),
          r = [
            "float glossinessFactor = glossiness;",
            "#ifdef USE_GLOSSINESSMAP",
            "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
            "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "\tglossinessFactor *= texelGlossiness.a;",
            "#endif",
          ].join("\n"),
          s = [
            "PhysicalMaterial material;",
            "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
            "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
            "material.specularRoughness += geometryRoughness;",
            "material.specularRoughness = min( material.specularRoughness, 1.0 );",
            "material.specularColor = specularFactor;",
          ].join("\n"),
          a = {
            specular: { value: new At().setHex(16777215) },
            glossiness: { value: 1 },
            specularMap: { value: null },
            glossinessMap: { value: null },
          };
        (this._extraUniforms = a),
          (this.onBeforeCompile = function (e) {
            for (const t in a) e.uniforms[t] = a[t];
            e.fragmentShader = e.fragmentShader
              .replace("uniform float roughness;", "uniform vec3 specular;")
              .replace("uniform float metalness;", "uniform float glossiness;")
              .replace("#include <roughnessmap_pars_fragment>", t)
              .replace("#include <metalnessmap_pars_fragment>", n)
              .replace("#include <roughnessmap_fragment>", i)
              .replace("#include <metalnessmap_fragment>", r)
              .replace("#include <lights_physical_fragment>", s);
          }),
          Object.defineProperties(this, {
            specular: {
              get: function () {
                return a.specular.value;
              },
              set: function (e) {
                a.specular.value = e;
              },
            },
            specularMap: {
              get: function () {
                return a.specularMap.value;
              },
              set: function (e) {
                (a.specularMap.value = e),
                  e
                    ? (this.defines.USE_SPECULARMAP = "")
                    : delete this.defines.USE_SPECULARMAP;
              },
            },
            glossiness: {
              get: function () {
                return a.glossiness.value;
              },
              set: function (e) {
                a.glossiness.value = e;
              },
            },
            glossinessMap: {
              get: function () {
                return a.glossinessMap.value;
              },
              set: function (e) {
                (a.glossinessMap.value = e),
                  e
                    ? ((this.defines.USE_GLOSSINESSMAP = ""),
                      (this.defines.USE_UV = ""))
                    : (delete this.defines.USE_GLOSSINESSMAP,
                      delete this.defines.USE_UV);
              },
            },
          }),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.specularMap = e.specularMap),
          this.specular.copy(e.specular),
          (this.glossinessMap = e.glossinessMap),
          (this.glossiness = e.glossiness),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this
        );
      }
    }
    class _l {
      constructor() {
        (this.name = ol.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
          (this.specularGlossinessParams = [
            "color",
            "map",
            "lightMap",
            "lightMapIntensity",
            "aoMap",
            "aoMapIntensity",
            "emissive",
            "emissiveIntensity",
            "emissiveMap",
            "bumpMap",
            "bumpScale",
            "normalMap",
            "normalMapType",
            "displacementMap",
            "displacementScale",
            "displacementBias",
            "specularMap",
            "specular",
            "glossinessMap",
            "glossiness",
            "alphaMap",
            "envMap",
            "envMapIntensity",
            "refractionRatio",
          ]);
      }
      getMaterialType() {
        return yl;
      }
      extendParams(e, t, n) {
        const i = t.extensions[this.name];
        (e.color = new At(1, 1, 1)), (e.opacity = 1);
        const r = [];
        if (Array.isArray(i.diffuseFactor)) {
          const t = i.diffuseFactor;
          e.color.fromArray(t), (e.opacity = t[3]);
        }
        if (
          (void 0 !== i.diffuseTexture &&
            r.push(n.assignTexture(e, "map", i.diffuseTexture)),
          (e.emissive = new At(0, 0, 0)),
          (e.glossiness =
            void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
          (e.specular = new At(1, 1, 1)),
          Array.isArray(i.specularFactor) &&
            e.specular.fromArray(i.specularFactor),
          void 0 !== i.specularGlossinessTexture)
        ) {
          const t = i.specularGlossinessTexture;
          r.push(n.assignTexture(e, "glossinessMap", t)),
            r.push(n.assignTexture(e, "specularMap", t));
        }
        return Promise.all(r);
      }
      createMaterial(e) {
        const t = new yl(e);
        return (
          (t.fog = !0),
          (t.color = e.color),
          (t.map = void 0 === e.map ? null : e.map),
          (t.lightMap = null),
          (t.lightMapIntensity = 1),
          (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
          (t.aoMapIntensity = 1),
          (t.emissive = e.emissive),
          (t.emissiveIntensity = 1),
          (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
          (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
          (t.bumpScale = 1),
          (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
          (t.normalMapType = 0),
          e.normalScale && (t.normalScale = e.normalScale),
          (t.displacementMap = null),
          (t.displacementScale = 1),
          (t.displacementBias = 0),
          (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
          (t.specular = e.specular),
          (t.glossinessMap =
            void 0 === e.glossinessMap ? null : e.glossinessMap),
          (t.glossiness = e.glossiness),
          (t.alphaMap = null),
          (t.envMap = void 0 === e.envMap ? null : e.envMap),
          (t.envMapIntensity = 1),
          (t.refractionRatio = 0.98),
          t
        );
      }
    }
    class wl {
      constructor() {
        this.name = ol.KHR_MESH_QUANTIZATION;
      }
    }
    class bl extends ya {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = e * i * 3 + i;
        for (let e = 0; e !== i; e++) t[e] = n[r + e];
        return t;
      }
    }
    (bl.prototype.beforeStart_ = bl.prototype.copySampleValue_),
      (bl.prototype.afterEnd_ = bl.prototype.copySampleValue_),
      (bl.prototype.interpolate_ = function (e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = 2 * a,
          l = 3 * a,
          c = i - t,
          h = (n - t) / c,
          u = h * h,
          d = u * h,
          p = e * l,
          m = p - l,
          f = -2 * d + 3 * u,
          g = d - u,
          v = 1 - f,
          x = g - u + h;
        for (let e = 0; e !== a; e++) {
          const t = s[m + e + a],
            n = s[m + e + o] * c,
            i = s[p + e + a],
            l = s[p + e] * c;
          r[e] = v * t + x * n + f * i + g * l;
        }
        return r;
      });
    const Ml = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
      },
      Sl = { 9728: a, 9729: c, 9984: o, 9985: 1007, 9986: l, 9987: h },
      Tl = { 33071: r, 33648: s, 10497: i },
      El = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      Al = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex",
      },
      Ll = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences",
      },
      Rl = { CUBICSPLINE: void 0, LINEAR: w, STEP: _ };
    function Cl(e, t) {
      return "string" != typeof e || "" === e
        ? ""
        : (/^https?:\/\//i.test(t) &&
            /^\//.test(e) &&
            (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(e) ||
          /^data:.*,.*$/i.test(e) ||
          /^blob:.*$/i.test(e)
            ? e
            : t + e);
    }
    function Pl(e, t, n) {
      for (const i in n.extensions)
        void 0 === e[i] &&
          ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
          (t.userData.gltfExtensions[i] = n.extensions[i]));
    }
    function Il(e, t) {
      void 0 !== t.extras &&
        ("object" == typeof t.extras
          ? Object.assign(e.userData, t.extras)
          : console.warn(
              "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
            ));
    }
    function Nl(e, t) {
      if ((e.updateMorphTargets(), void 0 !== t.weights))
        for (let n = 0, i = t.weights.length; n < i; n++)
          e.morphTargetInfluences[n] = t.weights[n];
      if (t.extras && Array.isArray(t.extras.targetNames)) {
        const n = t.extras.targetNames;
        if (e.morphTargetInfluences.length === n.length) {
          e.morphTargetDictionary = {};
          for (let t = 0, i = n.length; t < i; t++)
            e.morphTargetDictionary[n[t]] = t;
        } else
          console.warn(
            "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
          );
      }
    }
    function Dl(e) {
      const t = e.extensions && e.extensions[ol.KHR_DRACO_MESH_COMPRESSION];
      let n;
      return (
        (n = t
          ? "draco:" + t.bufferView + ":" + t.indices + ":" + Ol(t.attributes)
          : e.indices + ":" + Ol(e.attributes) + ":" + e.mode),
        n
      );
    }
    function Ol(e) {
      let t = "";
      const n = Object.keys(e).sort();
      for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
      return t;
    }
    function zl(e) {
      switch (e) {
        case Int8Array:
          return 1 / 127;
        case Uint8Array:
          return 1 / 255;
        case Int16Array:
          return 1 / 32767;
        case Uint16Array:
          return 1 / 65535;
        default:
          throw new Error(
            "THREE.GLTFLoader: Unsupported normalized accessor component type."
          );
      }
    }
    class Hl {
      constructor(e = {}, t = {}) {
        (this.json = e),
          (this.extensions = {}),
          (this.plugins = {}),
          (this.options = t),
          (this.cache = new al()),
          (this.associations = new Map()),
          (this.primitiveCache = {}),
          (this.meshCache = { refs: {}, uses: {} }),
          (this.cameraCache = { refs: {}, uses: {} }),
          (this.lightCache = { refs: {}, uses: {} }),
          (this.nodeNamesUsed = {}),
          "undefined" != typeof createImageBitmap &&
          !1 === /Firefox/.test(navigator.userAgent)
            ? (this.textureLoader = new Ro(this.options.manager))
            : (this.textureLoader = new Ua(this.options.manager)),
          this.textureLoader.setCrossOrigin(this.options.crossOrigin),
          this.textureLoader.setRequestHeader(this.options.requestHeader),
          (this.fileLoader = new Ha(this.options.manager)),
          this.fileLoader.setResponseType("arraybuffer"),
          "use-credentials" === this.options.crossOrigin &&
            this.fileLoader.setWithCredentials(!0);
      }
      setExtensions(e) {
        this.extensions = e;
      }
      setPlugins(e) {
        this.plugins = e;
      }
      parse(e, t) {
        const n = this,
          i = this.json,
          r = this.extensions;
        this.cache.removeAll(),
          this._invokeAll(function (e) {
            return e._markDefs && e._markDefs();
          }),
          Promise.all(
            this._invokeAll(function (e) {
              return e.beforeRoot && e.beforeRoot();
            })
          )
            .then(function () {
              return Promise.all([
                n.getDependencies("scene"),
                n.getDependencies("animation"),
                n.getDependencies("camera"),
              ]);
            })
            .then(function (t) {
              const s = {
                scene: t[0][i.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: i.asset,
                parser: n,
                userData: {},
              };
              Pl(r, s, i),
                Il(s, i),
                Promise.all(
                  n._invokeAll(function (e) {
                    return e.afterRoot && e.afterRoot(s);
                  })
                ).then(function () {
                  e(s);
                });
            })
            .catch(t);
      }
      _markDefs() {
        const e = this.json.nodes || [],
          t = this.json.skins || [],
          n = this.json.meshes || [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n].joints;
          for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0;
        }
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t];
          void 0 !== i.mesh &&
            (this._addNodeRef(this.meshCache, i.mesh),
            void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
            void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera);
        }
      }
      _addNodeRef(e, t) {
        void 0 !== t &&
          (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }
      _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1) return n;
        const i = n.clone();
        return (i.name += "_instance_" + e.uses[t]++), i;
      }
      _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
          const i = e(t[n]);
          if (i) return i;
        }
        return null;
      }
      _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
          const r = e(t[i]);
          r && n.push(r);
        }
        return n;
      }
      getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
          switch (e) {
            case "scene":
              i = this.loadScene(t);
              break;
            case "node":
              i = this.loadNode(t);
              break;
            case "mesh":
              i = this._invokeOne(function (e) {
                return e.loadMesh && e.loadMesh(t);
              });
              break;
            case "accessor":
              i = this.loadAccessor(t);
              break;
            case "bufferView":
              i = this._invokeOne(function (e) {
                return e.loadBufferView && e.loadBufferView(t);
              });
              break;
            case "buffer":
              i = this.loadBuffer(t);
              break;
            case "material":
              i = this._invokeOne(function (e) {
                return e.loadMaterial && e.loadMaterial(t);
              });
              break;
            case "texture":
              i = this._invokeOne(function (e) {
                return e.loadTexture && e.loadTexture(t);
              });
              break;
            case "skin":
              i = this.loadSkin(t);
              break;
            case "animation":
              i = this.loadAnimation(t);
              break;
            case "camera":
              i = this.loadCamera(t);
              break;
            default:
              throw new Error("Unknown type: " + e);
          }
          this.cache.add(n, i);
        }
        return i;
      }
      getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
          const n = this,
            i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
          (t = Promise.all(
            i.map(function (t, i) {
              return n.getDependency(e, i);
            })
          )),
            this.cache.add(e, t);
        }
        return t;
      }
      loadBuffer(e) {
        const t = this.json.buffers[e],
          n = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type)
          throw new Error(
            "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
          );
        if (void 0 === t.uri && 0 === e)
          return Promise.resolve(this.extensions[ol.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function (e, r) {
          n.load(Cl(t.uri, i.path), e, void 0, function () {
            r(
              new Error(
                'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
              )
            );
          });
        });
      }
      loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (e) {
          const n = t.byteLength || 0,
            i = t.byteOffset || 0;
          return e.slice(i, i + n);
        });
      }
      loadAccessor(e) {
        const t = this,
          n = this.json,
          i = this.json.accessors[e];
        if (void 0 === i.bufferView && void 0 === i.sparse)
          return Promise.resolve(null);
        const r = [];
        return (
          void 0 !== i.bufferView
            ? r.push(this.getDependency("bufferView", i.bufferView))
            : r.push(null),
          void 0 !== i.sparse &&
            (r.push(
              this.getDependency("bufferView", i.sparse.indices.bufferView)
            ),
            r.push(
              this.getDependency("bufferView", i.sparse.values.bufferView)
            )),
          Promise.all(r).then(function (e) {
            const r = e[0],
              s = El[i.type],
              a = Ml[i.componentType],
              o = a.BYTES_PER_ELEMENT,
              l = o * s,
              c = i.byteOffset || 0,
              h =
                void 0 !== i.bufferView
                  ? n.bufferViews[i.bufferView].byteStride
                  : void 0,
              u = !0 === i.normalized;
            let d, p;
            if (h && h !== l) {
              const e = Math.floor(c / h),
                n =
                  "InterleavedBuffer:" +
                  i.bufferView +
                  ":" +
                  i.componentType +
                  ":" +
                  e +
                  ":" +
                  i.count;
              let l = t.cache.get(n);
              l ||
                ((d = new a(r, e * h, (i.count * h) / o)),
                (l = new Vr(d, h / o)),
                t.cache.add(n, l)),
                (p = new jr(l, s, (c % h) / o, u));
            } else (d = null === r ? new a(i.count * s) : new a(r, c, i.count * s)), (p = new Pt(d, s, u));
            if (void 0 !== i.sparse) {
              const t = El.SCALAR,
                n = Ml[i.sparse.indices.componentType],
                o = i.sparse.indices.byteOffset || 0,
                l = i.sparse.values.byteOffset || 0,
                c = new n(e[1], o, i.sparse.count * t),
                h = new a(e[2], l, i.sparse.count * s);
              null !== r &&
                (p = new Pt(p.array.slice(), p.itemSize, p.normalized));
              for (let e = 0, t = c.length; e < t; e++) {
                const t = c[e];
                if (
                  (p.setX(t, h[e * s]),
                  s >= 2 && p.setY(t, h[e * s + 1]),
                  s >= 3 && p.setZ(t, h[e * s + 2]),
                  s >= 4 && p.setW(t, h[e * s + 3]),
                  s >= 5)
                )
                  throw new Error(
                    "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                  );
              }
            }
            return p;
          })
        );
      }
      loadTexture(e) {
        const t = this.json,
          n = this.options,
          i = t.textures[e],
          r = t.images[i.source];
        let s = this.textureLoader;
        if (r.uri) {
          const e = n.manager.getHandler(r.uri);
          null !== e && (s = e);
        }
        return this.loadTextureImage(e, r, s);
      }
      loadTextureImage(e, t, n) {
        const r = this,
          s = this.json,
          a = this.options,
          o = s.textures[e],
          l = self.URL || self.webkitURL;
        let u = t.uri,
          d = !1,
          p = !0;
        if (("image/jpeg" === t.mimeType && (p = !1), void 0 !== t.bufferView))
          u = r.getDependency("bufferView", t.bufferView).then(function (e) {
            if ("image/png" === t.mimeType) {
              const t = new DataView(e, 25, 1).getUint8(0, !1);
              p = 6 === t || 4 === t || 3 === t;
            }
            d = !0;
            const n = new Blob([e], { type: t.mimeType });
            return (u = l.createObjectURL(n)), u;
          });
        else if (void 0 === t.uri)
          throw new Error(
            "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
          );
        return Promise.resolve(u)
          .then(function (e) {
            return new Promise(function (t, i) {
              let r = t;
              !0 === n.isImageBitmapLoader &&
                (r = function (e) {
                  t(new Bs(e));
                }),
                n.load(Cl(e, a.path), r, void 0, i);
            });
          })
          .then(function (t) {
            !0 === d && l.revokeObjectURL(u),
              (t.flipY = !1),
              o.name && (t.name = o.name),
              p || (t.format = g);
            const n = (s.samplers || {})[o.sampler] || {};
            return (
              (t.magFilter = Sl[n.magFilter] || c),
              (t.minFilter = Sl[n.minFilter] || h),
              (t.wrapS = Tl[n.wrapS] || i),
              (t.wrapT = Tl[n.wrapT] || i),
              r.associations.set(t, { type: "textures", index: e }),
              t
            );
          });
      }
      assignTexture(e, t, n) {
        const i = this;
        return this.getDependency("texture", n.index).then(function (r) {
          if (
            (void 0 === n.texCoord ||
              0 == n.texCoord ||
              ("aoMap" === t && 1 == n.texCoord) ||
              console.warn(
                "THREE.GLTFLoader: Custom UV set " +
                  n.texCoord +
                  " for texture " +
                  t +
                  " not yet supported."
              ),
            i.extensions[ol.KHR_TEXTURE_TRANSFORM])
          ) {
            const e =
              void 0 !== n.extensions
                ? n.extensions[ol.KHR_TEXTURE_TRANSFORM]
                : void 0;
            if (e) {
              const t = i.associations.get(r);
              (r = i.extensions[ol.KHR_TEXTURE_TRANSFORM].extendTexture(r, e)),
                i.associations.set(r, t);
            }
          }
          e[t] = r;
        });
      }
      assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = void 0 !== t.attributes.tangent,
          r = void 0 !== t.attributes.color,
          s = void 0 === t.attributes.normal,
          a = !0 === e.isSkinnedMesh,
          o = Object.keys(t.morphAttributes).length > 0,
          l = o && void 0 !== t.morphAttributes.normal;
        if (e.isPoints) {
          const e = "PointsMaterial:" + n.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new Is()),
            _t.prototype.copy.call(t, n),
            t.color.copy(n.color),
            (t.map = n.map),
            (t.sizeAttenuation = !1),
            this.cache.add(e, t)),
            (n = t);
        } else if (e.isLine) {
          const e = "LineBasicMaterial:" + n.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new ws()),
            _t.prototype.copy.call(t, n),
            t.color.copy(n.color),
            this.cache.add(e, t)),
            (n = t);
        }
        if (i || r || s || a || o) {
          let e = "ClonedMaterial:" + n.uuid + ":";
          n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
            a && (e += "skinning:"),
            i && (e += "vertex-tangents:"),
            r && (e += "vertex-colors:"),
            s && (e += "flat-shading:"),
            o && (e += "morph-targets:"),
            l && (e += "morph-normals:");
          let t = this.cache.get(e);
          t ||
            ((t = n.clone()),
            a && (t.skinning = !0),
            r && (t.vertexColors = !0),
            s && (t.flatShading = !0),
            o && (t.morphTargets = !0),
            l && (t.morphNormals = !0),
            i &&
              ((t.vertexTangents = !0),
              t.normalScale && (t.normalScale.y *= -1),
              t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
            this.cache.add(e, t),
            this.associations.set(t, this.associations.get(n))),
            (n = t);
        }
        n.aoMap &&
          void 0 === t.attributes.uv2 &&
          void 0 !== t.attributes.uv &&
          t.setAttribute("uv2", t.attributes.uv),
          (e.material = n);
      }
      getMaterialType() {
        return ga;
      }
      loadMaterial(e) {
        const t = this,
          n = this.json,
          i = this.extensions,
          r = n.materials[e];
        let s;
        const a = {},
          o = r.extensions || {},
          l = [];
        if (o[ol.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          const e = i[ol.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          (s = e.getMaterialType()), l.push(e.extendParams(a, r, t));
        } else if (o[ol.KHR_MATERIALS_UNLIT]) {
          const e = i[ol.KHR_MATERIALS_UNLIT];
          (s = e.getMaterialType()), l.push(e.extendParams(a, r, t));
        } else {
          const n = r.pbrMetallicRoughness || {};
          if (
            ((a.color = new At(1, 1, 1)),
            (a.opacity = 1),
            Array.isArray(n.baseColorFactor))
          ) {
            const e = n.baseColorFactor;
            a.color.fromArray(e), (a.opacity = e[3]);
          }
          void 0 !== n.baseColorTexture &&
            l.push(t.assignTexture(a, "map", n.baseColorTexture)),
            (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
            (a.roughness =
              void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
            void 0 !== n.metallicRoughnessTexture &&
              (l.push(
                t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)
              ),
              l.push(
                t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture)
              )),
            (s = this._invokeOne(function (t) {
              return t.getMaterialType && t.getMaterialType(e);
            })),
            l.push(
              Promise.all(
                this._invokeAll(function (t) {
                  return t.extendMaterialParams && t.extendMaterialParams(e, a);
                })
              )
            );
        }
        !0 === r.doubleSided && (a.side = 2);
        const c = r.alphaMode || "OPAQUE";
        return (
          "BLEND" === c
            ? ((a.transparent = !0), (a.depthWrite = !1))
            : ((a.transparent = !1),
              "MASK" === c &&
                (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
          void 0 !== r.normalTexture &&
            s !== Lt &&
            (l.push(t.assignTexture(a, "normalMap", r.normalTexture)),
            (a.normalScale = new j(1, -1)),
            void 0 !== r.normalTexture.scale &&
              a.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)),
          void 0 !== r.occlusionTexture &&
            s !== Lt &&
            (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
            void 0 !== r.occlusionTexture.strength &&
              (a.aoMapIntensity = r.occlusionTexture.strength)),
          void 0 !== r.emissiveFactor &&
            s !== Lt &&
            (a.emissive = new At().fromArray(r.emissiveFactor)),
          void 0 !== r.emissiveTexture &&
            s !== Lt &&
            l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
          Promise.all(l).then(function () {
            let n;
            return (
              (n =
                s === yl
                  ? i[ol.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(
                      a
                    )
                  : new s(a)),
              r.name && (n.name = r.name),
              n.map && (n.map.encoding = A),
              n.emissiveMap && (n.emissiveMap.encoding = A),
              Il(n, r),
              t.associations.set(n, { type: "materials", index: e }),
              r.extensions && Pl(i, n, r),
              n
            );
          })
        );
      }
      createUniqueName(e) {
        const t = ko.sanitizeNodeName(e || "");
        let n = t;
        for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
        return (this.nodeNamesUsed[n] = !0), n;
      }
      loadGeometries(e) {
        const t = this,
          n = this.extensions,
          i = this.primitiveCache;
        function r(e) {
          return n[ol.KHR_DRACO_MESH_COMPRESSION]
            .decodePrimitive(e, t)
            .then(function (n) {
              return Bl(n, e, t);
            });
        }
        const s = [];
        for (let n = 0, a = e.length; n < a; n++) {
          const a = e[n],
            o = Dl(a),
            l = i[o];
          if (l) s.push(l.promise);
          else {
            let e;
            (e =
              a.extensions && a.extensions[ol.KHR_DRACO_MESH_COMPRESSION]
                ? r(a)
                : Bl(new Vt(), a, t)),
              (i[o] = { primitive: a, promise: e }),
              s.push(e);
          }
        }
        return Promise.all(s);
      }
      loadMesh(e) {
        const t = this,
          n = this.json,
          i = this.extensions,
          r = n.meshes[e],
          s = r.primitives,
          a = [];
        for (let e = 0, t = s.length; e < t; e++) {
          const t =
            void 0 === s[e].material
              ? (void 0 === (o = this.cache).DefaultMaterial &&
                  (o.DefaultMaterial = new ga({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0,
                  })),
                o.DefaultMaterial)
              : this.getDependency("material", s[e].material);
          a.push(t);
        }
        var o;
        return (
          a.push(t.loadGeometries(s)),
          Promise.all(a).then(function (n) {
            const a = n.slice(0, n.length - 1),
              o = n[n.length - 1],
              l = [];
            for (let n = 0, c = o.length; n < c; n++) {
              const c = o[n],
                h = s[n];
              let u;
              const d = a[n];
              if (
                4 === h.mode ||
                5 === h.mode ||
                6 === h.mode ||
                void 0 === h.mode
              )
                (u = !0 === r.isSkinnedMesh ? new ds(c, d) : new ln(c, d)),
                  !0 !== u.isSkinnedMesh ||
                    u.geometry.attributes.skinWeight.normalized ||
                    u.normalizeSkinWeights(),
                  5 === h.mode
                    ? (u.geometry = Ul(u.geometry, 1))
                    : 6 === h.mode && (u.geometry = Ul(u.geometry, 2));
              else if (1 === h.mode) u = new Cs(c, d);
              else if (3 === h.mode) u = new As(c, d);
              else if (2 === h.mode) u = new Ps(c, d);
              else {
                if (0 !== h.mode)
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
                  );
                u = new Hs(c, d);
              }
              Object.keys(u.geometry.morphAttributes).length > 0 && Nl(u, r),
                (u.name = t.createUniqueName(r.name || "mesh_" + e)),
                Il(u, r),
                h.extensions && Pl(i, u, h),
                t.assignFinalMaterial(u),
                l.push(u);
            }
            if (1 === l.length) return l[0];
            const c = new Dr();
            for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
            return c;
          })
        );
      }
      loadCamera(e) {
        let t;
        const n = this.json.cameras[e],
          i = n[n.type];
        if (i)
          return (
            "perspective" === n.type
              ? (t = new gn(
                  W.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : "orthographic" === n.type &&
                (t = new bo(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            Il(t, n),
            Promise.resolve(t)
          );
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
      }
      loadSkin(e) {
        const t = this.json.skins[e],
          n = { joints: t.joints };
        return void 0 === t.inverseBindMatrices
          ? Promise.resolve(n)
          : this.getDependency("accessor", t.inverseBindMatrices).then(
              function (e) {
                return (n.inverseBindMatrices = e), n;
              }
            );
      }
      loadAnimation(e) {
        const t = this.json.animations[e],
          n = [],
          i = [],
          r = [],
          s = [],
          a = [];
        for (let e = 0, o = t.channels.length; e < o; e++) {
          const o = t.channels[e],
            l = t.samplers[o.sampler],
            c = o.target,
            h = void 0 !== c.node ? c.node : c.id,
            u = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
            d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
          n.push(this.getDependency("node", h)),
            i.push(this.getDependency("accessor", u)),
            r.push(this.getDependency("accessor", d)),
            s.push(l),
            a.push(c);
        }
        return Promise.all([
          Promise.all(n),
          Promise.all(i),
          Promise.all(r),
          Promise.all(s),
          Promise.all(a),
        ]).then(function (n) {
          const i = n[0],
            r = n[1],
            s = n[2],
            a = n[3],
            o = n[4],
            l = [];
          for (let e = 0, t = i.length; e < t; e++) {
            const t = i[e],
              n = r[e],
              c = s[e],
              h = a[e],
              u = o[e];
            if (void 0 === t) continue;
            let d;
            switch ((t.updateMatrix(), (t.matrixAutoUpdate = !0), Ll[u.path])) {
              case Ll.weights:
                d = Ea;
                break;
              case Ll.rotation:
                d = La;
                break;
              case Ll.position:
              case Ll.scale:
              default:
                d = Ca;
            }
            const p = t.name ? t.name : t.uuid,
              m = void 0 !== h.interpolation ? Rl[h.interpolation] : w,
              f = [];
            Ll[u.path] === Ll.weights
              ? t.traverse(function (e) {
                  !0 === e.isMesh &&
                    e.morphTargetInfluences &&
                    f.push(e.name ? e.name : e.uuid);
                })
              : f.push(p);
            let g = c.array;
            if (c.normalized) {
              const e = zl(g.constructor),
                t = new Float32Array(g.length);
              for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
              g = t;
            }
            for (let e = 0, t = f.length; e < t; e++) {
              const t = new d(f[e] + "." + Ll[u.path], n.array, g, m);
              "CUBICSPLINE" === h.interpolation &&
                ((t.createInterpolant = function (e) {
                  return new bl(
                    this.times,
                    this.values,
                    this.getValueSize() / 3,
                    e
                  );
                }),
                (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                  !0)),
                l.push(t);
            }
          }
          const c = t.name ? t.name : "animation_" + e;
          return new Pa(c, void 0, l);
        });
      }
      createNodeMesh(e) {
        const t = this.json,
          n = this,
          i = t.nodes[e];
        return void 0 === i.mesh
          ? null
          : n.getDependency("mesh", i.mesh).then(function (e) {
              const t = n._getNodeRef(n.meshCache, i.mesh, e);
              return (
                void 0 !== i.weights &&
                  t.traverse(function (e) {
                    if (e.isMesh)
                      for (let t = 0, n = i.weights.length; t < n; t++)
                        e.morphTargetInfluences[t] = i.weights[t];
                  }),
                t
              );
            });
      }
      loadNode(e) {
        const t = this.json,
          n = this.extensions,
          i = this,
          r = t.nodes[e],
          s = r.name ? i.createUniqueName(r.name) : "";
        return (function () {
          const t = [],
            n = i._invokeOne(function (t) {
              return t.createNodeMesh && t.createNodeMesh(e);
            });
          return (
            n && t.push(n),
            void 0 !== r.camera &&
              t.push(
                i.getDependency("camera", r.camera).then(function (e) {
                  return i._getNodeRef(i.cameraCache, r.camera, e);
                })
              ),
            i
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                t.push(e);
              }),
            Promise.all(t)
          );
        })().then(function (t) {
          let a;
          if (
            ((a =
              !0 === r.isBone
                ? new ps()
                : t.length > 1
                ? new Dr()
                : 1 === t.length
                ? t[0]
                : new it()),
            a !== t[0])
          )
            for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
          if (
            (r.name && ((a.userData.name = r.name), (a.name = s)),
            Il(a, r),
            r.extensions && Pl(n, a, r),
            void 0 !== r.matrix)
          ) {
            const e = new Ie();
            e.fromArray(r.matrix), a.applyMatrix4(e);
          } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
          return i.associations.set(a, { type: "nodes", index: e }), a;
        });
      }
      loadScene(e) {
        const t = this.json,
          n = this.extensions,
          i = this.json.scenes[e],
          r = this,
          s = new Dr();
        i.name && (s.name = r.createUniqueName(i.name)),
          Il(s, i),
          i.extensions && Pl(n, s, i);
        const a = i.nodes || [],
          o = [];
        for (let e = 0, n = a.length; e < n; e++) o.push(Fl(a[e], s, t, r));
        return Promise.all(o).then(function () {
          return s;
        });
      }
    }
    function Fl(e, t, n, i) {
      const r = n.nodes[e];
      return i
        .getDependency("node", e)
        .then(function (e) {
          if (void 0 === r.skin) return e;
          let t;
          return i
            .getDependency("skin", r.skin)
            .then(function (e) {
              t = e;
              const n = [];
              for (let e = 0, r = t.joints.length; e < r; e++)
                n.push(i.getDependency("node", t.joints[e]));
              return Promise.all(n);
            })
            .then(function (n) {
              return (
                e.traverse(function (e) {
                  if (!e.isMesh) return;
                  const i = [],
                    r = [];
                  for (let e = 0, s = n.length; e < s; e++) {
                    const s = n[e];
                    if (s) {
                      i.push(s);
                      const n = new Ie();
                      void 0 !== t.inverseBindMatrices &&
                        n.fromArray(t.inverseBindMatrices.array, 16 * e),
                        r.push(n);
                    } else
                      console.warn(
                        'THREE.GLTFLoader: Joint "%s" could not be found.',
                        t.joints[e]
                      );
                  }
                  e.bind(new gs(i, r), e.matrixWorld);
                }),
                e
              );
            });
        })
        .then(function (e) {
          t.add(e);
          const s = [];
          if (r.children) {
            const t = r.children;
            for (let r = 0, a = t.length; r < a; r++) {
              const a = t[r];
              s.push(Fl(a, e, n, i));
            }
          }
          return Promise.all(s);
        });
    }
    function Bl(e, t, n) {
      const i = t.attributes,
        r = [];
      function s(t, i) {
        return n.getDependency("accessor", t).then(function (t) {
          e.setAttribute(i, t);
        });
      }
      for (const t in i) {
        const n = Al[t] || t.toLowerCase();
        n in e.attributes || r.push(s(i[t], n));
      }
      if (void 0 !== t.indices && !e.index) {
        const i = n.getDependency("accessor", t.indices).then(function (t) {
          e.setIndex(t);
        });
        r.push(i);
      }
      return (
        Il(e, t),
        (function (e, t, n) {
          const i = t.attributes,
            r = new re();
          if (void 0 === i.POSITION) return;
          {
            const e = n.json.accessors[i.POSITION],
              t = e.min,
              s = e.max;
            if (void 0 === t || void 0 === s)
              return void console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
            if (
              (r.set(new te(t[0], t[1], t[2]), new te(s[0], s[1], s[2])),
              e.normalized)
            ) {
              const t = zl(Ml[e.componentType]);
              r.min.multiplyScalar(t), r.max.multiplyScalar(t);
            }
          }
          const s = t.targets;
          if (void 0 !== s) {
            const e = new te(),
              t = new te();
            for (let i = 0, r = s.length; i < r; i++) {
              const r = s[i];
              if (void 0 !== r.POSITION) {
                const i = n.json.accessors[r.POSITION],
                  s = i.min,
                  a = i.max;
                if (void 0 !== s && void 0 !== a) {
                  if (
                    (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                    t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                    t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                    i.normalized)
                  ) {
                    const e = zl(Ml[i.componentType]);
                    t.multiplyScalar(e);
                  }
                  e.max(t);
                } else
                  console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
              }
            }
            r.expandByVector(e);
          }
          e.boundingBox = r;
          const a = new Me();
          r.getCenter(a.center),
            (a.radius = r.min.distanceTo(r.max) / 2),
            (e.boundingSphere = a);
        })(e, t, n),
        Promise.all(r).then(function () {
          return void 0 !== t.targets
            ? (function (e, t, n) {
                let i = !1,
                  r = !1;
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e];
                  if (
                    (void 0 !== n.POSITION && (i = !0),
                    void 0 !== n.NORMAL && (r = !0),
                    i && r)
                  )
                    break;
                }
                if (!i && !r) return Promise.resolve(e);
                const s = [],
                  a = [];
                for (let o = 0, l = t.length; o < l; o++) {
                  const l = t[o];
                  if (i) {
                    const t =
                      void 0 !== l.POSITION
                        ? n.getDependency("accessor", l.POSITION)
                        : e.attributes.position;
                    s.push(t);
                  }
                  if (r) {
                    const t =
                      void 0 !== l.NORMAL
                        ? n.getDependency("accessor", l.NORMAL)
                        : e.attributes.normal;
                    a.push(t);
                  }
                }
                return Promise.all([Promise.all(s), Promise.all(a)]).then(
                  function (t) {
                    const n = t[0],
                      s = t[1];
                    return (
                      i && (e.morphAttributes.position = n),
                      r && (e.morphAttributes.normal = s),
                      (e.morphTargetsRelative = !0),
                      e
                    );
                  }
                );
              })(e, t.targets, n)
            : e;
        })
      );
    }
    function Ul(e, t) {
      let n = e.getIndex();
      if (null === n) {
        const t = [],
          i = e.getAttribute("position");
        if (void 0 === i)
          return (
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
            ),
            e
          );
        for (let e = 0; e < i.count; e++) t.push(e);
        e.setIndex(t), (n = e.getIndex());
      }
      const i = n.count - 2,
        r = [];
      if (2 === t)
        for (let e = 1; e <= i; e++)
          r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
      else
        for (let e = 0; e < i; e++)
          e % 2 == 0
            ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2)))
            : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
      r.length / 3 !== i &&
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
        );
      const s = e.clone();
      return s.setIndex(r), s;
    }
    let Gl;
    const kl = {
      tilt: 0,
      heading: 0,
      zoom: 18,
      center: { lat: 35.6594945, lng: 139.6999859 },
      mapId: "15431d2b469f209e",
    };
    function Vl() {
      const e = document.getElementById("map");
      (Gl = new google.maps.Map(e, kl)),
        (function (e) {
          let t, n, i, r;
          const s = new google.maps.WebglOverlayView();
          (s.onAdd = () => {
            (t = new kr()), (i = new gn());
            const e = new To(16777215, 0.75);
            t.add(e);
            const n = new So(16777215, 0.25);
            n.position.set(0.5, -1, 0.5), t.add(n), (r = new sl());
            r.load(
              "https://raw.githubusercontent.com/googlemaps/js-samples/master/assets/pin.gltf",
              (e) => {
                e.scene.scale.set(10, 10, 10),
                  (e.scene.rotation.x = Math.PI),
                  t.add(e.scene);
              }
            );
          }),
            (s.onContextRestored = (t) => {
              (n = new Br({
                canvas: t.canvas,
                context: t,
                ...t.getContextAttributes(),
              })),
                (n.autoClear = !1),
                (r.manager.onLoad = () => {
                  n.setAnimationLoop(() => {
                    s.requestRedraw();
                    const { tilt: t, heading: i, zoom: r } = kl;
                    e.moveCamera({ tilt: t, heading: i, zoom: r }),
                      kl.tilt < 67.5
                        ? (kl.tilt += 0.5)
                        : kl.heading <= 360
                        ? ((kl.heading += 0.2), (kl.zoom -= 5e-4))
                        : n.setAnimationLoop(null);
                  });
                });
            }),
            (s.onDraw = (e, r) => {
              const a = r.fromLatLngAltitude(kl.center, 120);
              (i.projectionMatrix = new Ie().fromArray(a)),
                s.requestRedraw(),
                n.render(t, i),
                n.resetState();
            }),
            s.setMap(e);
        })(Gl);
    }
    var Wl = window;
    for (var jl in t) Wl[jl] = t[jl];
    t.__esModule && Object.defineProperty(Wl, "__esModule", { value: !0 });
  })();
</script>

<div id="iframe-contents">
  <div id="map" class="map"></div>

  <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&libraries=&v=beta"
    async
  ></script>
</div>
