<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Simple WebGL Overlay</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://unpkg.com/three@0.129.0/build/three.min.js"></script>

    <script type="module" crossorigin>
      const kl = function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
          n(i);
        new MutationObserver((i) => {
          for (const r of i)
            if (r.type === "childList")
              for (const o of r.addedNodes)
                o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(i) {
          const r = {};
          return (
            i.integrity && (r.integrity = i.integrity),
            i.referrerpolicy && (r.referrerPolicy = i.referrerpolicy),
            i.crossorigin === "use-credentials"
              ? (r.credentials = "include")
              : i.crossorigin === "anonymous"
              ? (r.credentials = "omit")
              : (r.credentials = "same-origin"),
            r
          );
        }
        function n(i) {
          if (i.ep) return;
          i.ep = !0;
          const r = t(i);
          fetch(i.href, r);
        }
      };
      kl();
      /**
       * @license
       * Copyright 2010-2021 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const Da = "129",
        Vl = 0,
        lo = 1,
        Wl = 2,
        Na = 1,
        ql = 2,
        mi = 3,
        Ti = 0,
        Ze = 1,
        Bi = 2,
        Fa = 1,
        xi = 0,
        vi = 1,
        co = 2,
        ho = 3,
        uo = 4,
        Xl = 5,
        Nn = 100,
        jl = 101,
        Yl = 102,
        fo = 103,
        po = 104,
        Zl = 200,
        Jl = 201,
        Kl = 202,
        Ql = 203,
        Ba = 204,
        Oa = 205,
        $l = 206,
        ec = 207,
        tc = 208,
        nc = 209,
        ic = 210,
        rc = 0,
        sc = 1,
        oc = 2,
        ms = 3,
        ac = 4,
        lc = 5,
        cc = 6,
        hc = 7,
        Sr = 0,
        uc = 1,
        dc = 2,
        _i = 0,
        fc = 1,
        pc = 2,
        mc = 3,
        gc = 4,
        xc = 5,
        za = 300,
        Ls = 301,
        Rs = 302,
        mo = 303,
        go = 304,
        Cs = 306,
        Ps = 307,
        Hn = 1e3,
        dt = 1001,
        vr = 1002,
        $e = 1003,
        gs = 1004,
        xs = 1005,
        ft = 1006,
        Ua = 1007,
        Xn = 1008,
        Is = 1009,
        vc = 1010,
        _c = 1011,
        _r = 1012,
        yc = 1013,
        xr = 1014,
        Qt = 1015,
        yr = 1016,
        Mc = 1017,
        wc = 1018,
        bc = 1019,
        yi = 1020,
        Sc = 1021,
        tn = 1022,
        Et = 1023,
        Tc = 1024,
        Ec = 1025,
        zn = 1026,
        Ei = 1027,
        Ac = 1028,
        Lc = 1029,
        Rc = 1030,
        Cc = 1031,
        Pc = 1032,
        Ic = 1033,
        xo = 33776,
        vo = 33777,
        _o = 33778,
        yo = 33779,
        Mo = 35840,
        wo = 35841,
        bo = 35842,
        So = 35843,
        Dc = 36196,
        To = 37492,
        Eo = 37496,
        Nc = 37808,
        Fc = 37809,
        Bc = 37810,
        Oc = 37811,
        zc = 37812,
        Uc = 37813,
        Hc = 37814,
        Gc = 37815,
        kc = 37816,
        Vc = 37817,
        Wc = 37818,
        qc = 37819,
        Xc = 37820,
        jc = 37821,
        Yc = 36492,
        Zc = 37840,
        Jc = 37841,
        Kc = 37842,
        Qc = 37843,
        $c = 37844,
        eh = 37845,
        th = 37846,
        nh = 37847,
        ih = 37848,
        rh = 37849,
        sh = 37850,
        oh = 37851,
        ah = 37852,
        lh = 37853,
        ch = 2200,
        hh = 2201,
        uh = 2202,
        Ai = 2300,
        Gn = 2301,
        Nr = 2302,
        Fn = 2400,
        Bn = 2401,
        Mr = 2402,
        Ds = 2500,
        Ha = 2501,
        dh = 0,
        fh = 1,
        Ga = 2,
        Oi = 3e3,
        wr = 3001,
        ph = 3007,
        mh = 3002,
        gh = 3003,
        xh = 3004,
        vh = 3005,
        _h = 3006,
        yh = 3200,
        Mh = 3201,
        pn = 0,
        wh = 1,
        Fr = 7680,
        bh = 519,
        Li = 35044,
        br = 35048,
        Ao = "300 es";
      class mn {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e];
          if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e.type];
          if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
            e.target = null;
          }
        }
      }
      const Qe = [];
      for (let s = 0; s < 256; s++)
        Qe[s] = (s < 16 ? "0" : "") + s.toString(16);
      let Gi = 1234567;
      const Mi = Math.PI / 180,
        Ri = 180 / Math.PI;
      function vt() {
        const s = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          Qe[s & 255] +
          Qe[(s >> 8) & 255] +
          Qe[(s >> 16) & 255] +
          Qe[(s >> 24) & 255] +
          "-" +
          Qe[e & 255] +
          Qe[(e >> 8) & 255] +
          "-" +
          Qe[((e >> 16) & 15) | 64] +
          Qe[(e >> 24) & 255] +
          "-" +
          Qe[(t & 63) | 128] +
          Qe[(t >> 8) & 255] +
          "-" +
          Qe[(t >> 16) & 255] +
          Qe[(t >> 24) & 255] +
          Qe[n & 255] +
          Qe[(n >> 8) & 255] +
          Qe[(n >> 16) & 255] +
          Qe[(n >> 24) & 255]
        ).toUpperCase();
      }
      function ut(s, e, t) {
        return Math.max(e, Math.min(t, s));
      }
      function Ns(s, e) {
        return ((s % e) + e) % e;
      }
      function Sh(s, e, t, n, i) {
        return n + ((s - e) * (i - n)) / (t - e);
      }
      function Th(s, e, t) {
        return s !== e ? (t - s) / (e - s) : 0;
      }
      function wi(s, e, t) {
        return (1 - t) * s + t * e;
      }
      function Eh(s, e, t, n) {
        return wi(s, e, 1 - Math.exp(-t * n));
      }
      function Ah(s, e = 1) {
        return e - Math.abs(Ns(s, e * 2) - e);
      }
      function Lh(s, e, t) {
        return s <= e
          ? 0
          : s >= t
          ? 1
          : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
      }
      function Rh(s, e, t) {
        return s <= e
          ? 0
          : s >= t
          ? 1
          : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
      }
      function Ch(s, e) {
        return s + Math.floor(Math.random() * (e - s + 1));
      }
      function Ph(s, e) {
        return s + Math.random() * (e - s);
      }
      function Ih(s) {
        return s * (0.5 - Math.random());
      }
      function Dh(s) {
        return (
          s !== void 0 && (Gi = s % 2147483647),
          (Gi = (Gi * 16807) % 2147483647),
          (Gi - 1) / 2147483646
        );
      }
      function Nh(s) {
        return s * Mi;
      }
      function Fh(s) {
        return s * Ri;
      }
      function vs(s) {
        return (s & (s - 1)) === 0 && s !== 0;
      }
      function ka(s) {
        return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
      }
      function Va(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      function Bh(s, e, t, n, i) {
        const r = Math.cos,
          o = Math.sin,
          a = r(t / 2),
          l = o(t / 2),
          c = r((e + n) / 2),
          h = o((e + n) / 2),
          u = r((e - n) / 2),
          d = o((e - n) / 2),
          f = r((n - e) / 2),
          m = o((n - e) / 2);
        switch (i) {
          case "XYX":
            s.set(a * h, l * u, l * d, a * c);
            break;
          case "YZY":
            s.set(l * d, a * h, l * u, a * c);
            break;
          case "ZXZ":
            s.set(l * u, l * d, a * h, a * c);
            break;
          case "XZX":
            s.set(a * h, l * m, l * f, a * c);
            break;
          case "YXY":
            s.set(l * f, a * h, l * m, a * c);
            break;
          case "ZYZ":
            s.set(l * m, l * f, a * h, a * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
            );
        }
      }
      var Oh = Object.freeze({
        __proto__: null,
        DEG2RAD: Mi,
        RAD2DEG: Ri,
        generateUUID: vt,
        clamp: ut,
        euclideanModulo: Ns,
        mapLinear: Sh,
        inverseLerp: Th,
        lerp: wi,
        damp: Eh,
        pingpong: Ah,
        smoothstep: Lh,
        smootherstep: Rh,
        randInt: Ch,
        randFloat: Ph,
        randFloatSpread: Ih,
        seededRandom: Dh,
        degToRad: Nh,
        radToDeg: Fh,
        isPowerOfTwo: vs,
        ceilPowerOfTwo: ka,
        floorPowerOfTwo: Va,
        setQuaternionFromProperEuler: Bh,
      });
      class Y {
        constructor(e = 0, t = 0) {
          (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
      }
      Y.prototype.isVector2 = !0;
      class et {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, l, c) {
          const h = this.elements;
          return (
            (h[0] = e),
            (h[1] = i),
            (h[2] = a),
            (h[3] = t),
            (h[4] = r),
            (h[5] = l),
            (h[6] = n),
            (h[7] = o),
            (h[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            u = n[7],
            d = n[2],
            f = n[5],
            m = n[8],
            x = i[0],
            v = i[3],
            p = i[6],
            g = i[1],
            S = i[4],
            L = i[7],
            E = i[2],
            _ = i[5],
            C = i[8];
          return (
            (r[0] = o * x + a * g + l * E),
            (r[3] = o * v + a * S + l * _),
            (r[6] = o * p + a * L + l * C),
            (r[1] = c * x + h * g + u * E),
            (r[4] = c * v + h * S + u * _),
            (r[7] = c * p + h * L + u * C),
            (r[2] = d * x + f * g + m * E),
            (r[5] = d * v + f * S + m * _),
            (r[8] = d * p + f * L + m * C),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8];
          return (
            t * o * h -
            t * a * c -
            n * r * h +
            n * a * l +
            i * r * c -
            i * o * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = h * o - a * c,
            d = a * l - h * r,
            f = c * r - o * l,
            m = t * u + n * d + i * f;
          if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const x = 1 / m;
          return (
            (e[0] = u * x),
            (e[1] = (i * c - h * n) * x),
            (e[2] = (a * n - i * o) * x),
            (e[3] = d * x),
            (e[4] = (h * t - i * l) * x),
            (e[5] = (i * r - a * t) * x),
            (e[6] = f * x),
            (e[7] = (n * l - c * t) * x),
            (e[8] = (o * t - n * r) * x),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, o, a) {
          const l = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * l,
              n * c,
              -n * (l * o + c * a) + o + e,
              -i * c,
              i * l,
              -i * (-c * o + l * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            r = i[0],
            o = i[3],
            a = i[6],
            l = i[1],
            c = i[4],
            h = i[7];
          return (
            (i[0] = t * r + n * l),
            (i[3] = t * o + n * c),
            (i[6] = t * a + n * h),
            (i[1] = -n * r + t * l),
            (i[4] = -n * o + t * c),
            (i[7] = -n * a + t * h),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      et.prototype.isMatrix3 = !0;
      let xn;
      class jn {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            xn === void 0 &&
              (xn = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (xn.width = e.width),
              (xn.height = e.height);
            const n = xn.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = xn);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
      }
      let zh = 0;
      class tt extends mn {
        constructor(
          e = tt.DEFAULT_IMAGE,
          t = tt.DEFAULT_MAPPING,
          n = dt,
          i = dt,
          r = ft,
          o = Xn,
          a = Et,
          l = Is,
          c = 1,
          h = Oi
        ) {
          super(),
            Object.defineProperty(this, "id", { value: zh++ }),
            (this.uuid = vt()),
            (this.name = ""),
            (this.image = e),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = o),
            (this.anisotropy = c),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = l),
            (this.offset = new Y(0, 0)),
            (this.repeat = new Y(1, 1)),
            (this.center = new Y(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new et()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = h),
            (this.version = 0),
            (this.onUpdate = null);
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.image = e.image),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            this
          );
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (this.image !== void 0) {
            const i = this.image;
            if (
              (i.uuid === void 0 && (i.uuid = vt()),
              !t && e.images[i.uuid] === void 0)
            ) {
              let r;
              if (Array.isArray(i)) {
                r = [];
                for (let o = 0, a = i.length; o < a; o++)
                  i[o].isDataTexture
                    ? r.push(Br(i[o].image))
                    : r.push(Br(i[o]));
              } else r = Br(i);
              e.images[i.uuid] = { uuid: i.uuid, url: r };
            }
            n.image = i.uuid;
          }
          return t || (e.textures[this.uuid] = n), n;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== za) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case Hn:
                e.x = e.x - Math.floor(e.x);
                break;
              case dt:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case vr:
                Math.abs(Math.floor(e.x) % 2) === 1
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case Hn:
                e.y = e.y - Math.floor(e.y);
                break;
              case dt:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case vr:
                Math.abs(Math.floor(e.y) % 2) === 1
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      tt.DEFAULT_IMAGE = void 0;
      tt.DEFAULT_MAPPING = za;
      tt.prototype.isTexture = !0;
      function Br(s) {
        return (typeof HTMLImageElement != "undefined" &&
          s instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            s instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && s instanceof ImageBitmap)
          ? jn.getDataURL(s)
          : s.data
          ? {
              data: Array.prototype.slice.call(s.data),
              width: s.width,
              height: s.height,
              type: s.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      class Fe {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.x = e), (this.y = t), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const l = e.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            m = l[9],
            x = l[2],
            v = l[6],
            p = l[10];
          if (
            Math.abs(h - d) < 0.01 &&
            Math.abs(u - x) < 0.01 &&
            Math.abs(m - v) < 0.01
          ) {
            if (
              Math.abs(h + d) < 0.1 &&
              Math.abs(u + x) < 0.1 &&
              Math.abs(m + v) < 0.1 &&
              Math.abs(c + f + p - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const S = (c + 1) / 2,
              L = (f + 1) / 2,
              E = (p + 1) / 2,
              _ = (h + d) / 4,
              C = (u + x) / 4,
              F = (m + v) / 4;
            return (
              S > L && S > E
                ? S < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(S)), (i = _ / n), (r = C / n))
                : L > E
                ? L < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(L)), (n = _ / i), (r = F / i))
                : E < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(E)), (n = C / r), (i = F / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let g = Math.sqrt(
            (v - m) * (v - m) + (u - x) * (u - x) + (d - h) * (d - h)
          );
          return (
            Math.abs(g) < 0.001 && (g = 1),
            (this.x = (v - m) / g),
            (this.y = (u - x) / g),
            (this.z = (d - h) / g),
            (this.w = Math.acos((c + f + p - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
      }
      Fe.prototype.isVector4 = !0;
      class Ht extends mn {
        constructor(e, t, n) {
          super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Fe(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Fe(0, 0, e, t)),
            (n = n || {}),
            (this.texture = new tt(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding
            )),
            (this.texture.image = {}),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = 1),
            (this.texture.generateMipmaps =
              n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.minFilter =
              n.minFilter !== void 0 ? n.minFilter : ft),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
              n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
              n.depthTexture !== void 0 ? n.depthTexture : null);
        }
        setTexture(e) {
          (e.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = e);
        }
        setSize(e, t, n = 1) {
          (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Ht.prototype.isWebGLRenderTarget = !0;
      class Uh extends Ht {
        constructor(e, t, n) {
          super(e, t);
          const i = this.texture;
          this.texture = [];
          for (let r = 0; r < n; r++) this.texture[r] = i.clone();
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = e),
                (this.texture[i].image.height = t),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
          );
        }
        copy(e) {
          this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            (this.texture.length = 0);
          for (let t = 0, n = e.texture.length; t < n; t++)
            this.texture[t] = e.texture[t].clone();
          return this;
        }
      }
      Uh.prototype.isWebGLMultipleRenderTargets = !0;
      class Hh extends Ht {
        constructor(e, t, n) {
          super(e, t, n), (this.samples = 4);
        }
        copy(e) {
          return super.copy.call(this, e), (this.samples = e.samples), this;
        }
      }
      Hh.prototype.isWebGLMultisampleRenderTarget = !0;
      class ct {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this._x = e), (this._y = t), (this._z = n), (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, r, o, a) {
          let l = n[i + 0],
            c = n[i + 1],
            h = n[i + 2],
            u = n[i + 3];
          const d = r[o + 0],
            f = r[o + 1],
            m = r[o + 2],
            x = r[o + 3];
          if (a === 0) {
            (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
            return;
          }
          if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = m), (e[t + 3] = x);
            return;
          }
          if (u !== x || l !== d || c !== f || h !== m) {
            let v = 1 - a;
            const p = l * d + c * f + h * m + u * x,
              g = p >= 0 ? 1 : -1,
              S = 1 - p * p;
            if (S > Number.EPSILON) {
              const E = Math.sqrt(S),
                _ = Math.atan2(E, p * g);
              (v = Math.sin(v * _) / E), (a = Math.sin(a * _) / E);
            }
            const L = a * g;
            if (
              ((l = l * v + d * L),
              (c = c * v + f * L),
              (h = h * v + m * L),
              (u = u * v + x * L),
              v === 1 - a)
            ) {
              const E = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
              (l *= E), (c *= E), (h *= E), (u *= E);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, o) {
          const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            u = r[o],
            d = r[o + 1],
            f = r[o + 2],
            m = r[o + 3];
          return (
            (e[t] = a * m + h * u + l * f - c * d),
            (e[t + 1] = l * m + h * d + c * u - a * f),
            (e[t + 2] = c * m + h * f + a * d - l * u),
            (e[t + 3] = h * m - a * u - l * d - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!(e && e.isEuler))
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            h = a(i / 2),
            u = a(r / 2),
            d = l(n / 2),
            f = l(i / 2),
            m = l(r / 2);
          switch (o) {
            case "XYZ":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "YXZ":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            case "ZXY":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "ZYX":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            case "YZX":
              (this._x = d * h * u + c * f * m),
                (this._y = c * f * u + d * h * m),
                (this._z = c * h * m - d * f * u),
                (this._w = c * h * u - d * f * m);
              break;
            case "XZY":
              (this._x = d * h * u - c * f * m),
                (this._y = c * f * u - d * h * m),
                (this._z = c * h * m + d * f * u),
                (this._w = c * h * u + d * f * m);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return t !== !1 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            h = t[6],
            u = t[10],
            d = n + a + u;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
              (this._x = (h - l) * f),
              (this._y = (r - c) * f),
              (this._z = (o - i) * f);
          } else if (n > a && n > u) {
            const f = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (h - l) / f),
              (this._x = 0.25 * f),
              (this._y = (i + o) / f),
              (this._z = (r + c) / f);
          } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (r - c) / f),
              (this._x = (i + o) / f),
              (this._y = 0.25 * f),
              (this._z = (l + h) / f);
          } else {
            const f = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (o - i) / f),
              (this._x = (r + c) / f),
              (this._y = (l + h) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(ut(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (n === 0) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            h = t._w;
          return (
            (this._x = n * h + o * a + i * c - r * l),
            (this._y = i * h + o * l + r * a - n * c),
            (this._z = r * h + o * c + n * l - i * a),
            (this._w = o * h - n * a - i * l - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            o = this._w;
          let a = o * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * n + t * this._x),
              (this._y = f * i + t * this._y),
              (this._z = f * r + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            h = Math.atan2(c, a),
            u = Math.sin((1 - t) * h) / c,
            d = Math.sin(t * h) / c;
          return (
            (this._w = o * u + this._w * d),
            (this._x = n * u + this._x * d),
            (this._y = i * u + this._y * d),
            (this._z = r * u + this._z * d),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          this.copy(e).slerp(t, n);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      ct.prototype.isQuaternion = !0;
      class b {
        constructor(e = 0, t = 0, n = 0) {
          (this.x = e), (this.y = t), (this.z = n);
        }
        set(e, t, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(Lo.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(Lo.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * i - a * n,
            h = l * n + a * t - r * i,
            u = l * i + r * n - o * t,
            d = -r * t - o * n - a * i;
          return (
            (this.x = c * l + d * -r + h * -a - u * -o),
            (this.y = h * l + d * -o + u * -r - c * -a),
            (this.z = u * l + d * -a + c * -o - h * -r),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = i * l - r * a),
            (this.y = r * o - n * l),
            (this.z = n * a - i * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return Or.copy(this).projectOnVector(e), this.sub(Or);
        }
        reflect(e) {
          return this.sub(Or.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(ut(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
      }
      b.prototype.isVector3 = !0;
      const Or = new b(),
        Lo = new ct();
      class gt {
        constructor(
          e = new b(1 / 0, 1 / 0, 1 / 0),
          t = new b(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.length; l < c; l += 3) {
            const h = e[l],
              u = e[l + 1],
              d = e[l + 2];
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > r && (r = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.count; l < c; l++) {
            const h = e.getX(l),
              u = e.getY(l),
              d = e.getZ(l);
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > r && (r = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(r, o, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = ii.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e) {
          return this.makeEmpty(), this.expandByObject(e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box3: .getCenter() target is now required"),
              (e = new b())),
            this.isEmpty()
              ? e.set(0, 0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        }
        getSize(e) {
          return (
            e === void 0 &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
              (e = new b())),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
          );
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e) {
          e.updateWorldMatrix(!1, !1);
          const t = e.geometry;
          t !== void 0 &&
            (t.boundingBox === null && t.computeBoundingBox(),
            zr.copy(t.boundingBox),
            zr.applyMatrix4(e.matrixWorld),
            this.union(zr));
          const n = e.children;
          for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
              (t = new b())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y),
              (e.z - this.min.z) / (this.max.z - this.min.z)
            )
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, ii),
            ii.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(ri),
            ki.subVectors(this.max, ri),
            vn.subVectors(e.a, ri),
            _n.subVectors(e.b, ri),
            yn.subVectors(e.c, ri),
            Vt.subVectors(_n, vn),
            Wt.subVectors(yn, _n),
            hn.subVectors(vn, yn);
          let t = [
            0,
            -Vt.z,
            Vt.y,
            0,
            -Wt.z,
            Wt.y,
            0,
            -hn.z,
            hn.y,
            Vt.z,
            0,
            -Vt.x,
            Wt.z,
            0,
            -Wt.x,
            hn.z,
            0,
            -hn.x,
            -Vt.y,
            Vt.x,
            0,
            -Wt.y,
            Wt.x,
            0,
            -hn.y,
            hn.x,
            0,
          ];
          return !Ur(t, vn, _n, yn, ki) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Ur(t, vn, _n, yn, ki))
            ? !1
            : (Vi.crossVectors(Vt, Wt),
              (t = [Vi.x, Vi.y, Vi.z]),
              Ur(t, vn, _n, yn, ki));
        }
        clampPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Box3: .clampPoint() target is now required"),
              (t = new b())),
            t.copy(e).clamp(this.min, this.max)
          );
        }
        distanceToPoint(e) {
          return ii.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            e === void 0 &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              ),
            this.getCenter(e.center),
            (e.radius = this.getSize(ii).length() * 0.5),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (Dt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              Dt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              Dt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              Dt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              Dt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              Dt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              Dt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              Dt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(Dt),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      gt.prototype.isBox3 = !0;
      const Dt = [
          new b(),
          new b(),
          new b(),
          new b(),
          new b(),
          new b(),
          new b(),
          new b(),
        ],
        ii = new b(),
        zr = new gt(),
        vn = new b(),
        _n = new b(),
        yn = new b(),
        Vt = new b(),
        Wt = new b(),
        hn = new b(),
        ri = new b(),
        ki = new b(),
        Vi = new b(),
        un = new b();
      function Ur(s, e, t, n, i) {
        for (let r = 0, o = s.length - 3; r <= o; r += 3) {
          un.fromArray(s, r);
          const a =
              i.x * Math.abs(un.x) +
              i.y * Math.abs(un.y) +
              i.z * Math.abs(un.z),
            l = e.dot(un),
            c = t.dot(un),
            h = n.dot(un);
          if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
        }
        return !0;
      }
      const Gh = new gt(),
        Ro = new b(),
        Hr = new b(),
        Gr = new b();
      class gn {
        constructor(e = new b(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          t !== void 0 ? n.copy(t) : Gh.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let r = 0, o = e.length; r < o; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
              (t = new b())),
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
              (e = new gt())),
            this.isEmpty()
              ? (e.makeEmpty(), e)
              : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
          );
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          Gr.subVectors(e, this.center);
          const t = Gr.lengthSq();
          if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
              i = (n - this.radius) * 0.5;
            this.center.add(Gr.multiplyScalar(i / n)), (this.radius += i);
          }
          return this;
        }
        union(e) {
          return (
            Hr.subVectors(e.center, this.center)
              .normalize()
              .multiplyScalar(e.radius),
            this.expandByPoint(Ro.copy(e.center).add(Hr)),
            this.expandByPoint(Ro.copy(e.center).sub(Hr)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Nt = new b(),
        kr = new b(),
        Wi = new b(),
        qt = new b(),
        Vr = new b(),
        qi = new b(),
        Wr = new b();
      class Yn {
        constructor(e = new b(), t = new b(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return (
            t === void 0 &&
              (console.warn("THREE.Ray: .at() target is now required"),
              (t = new b())),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
          );
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, Nt)), this;
        }
        closestPointToPoint(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Ray: .closestPointToPoint() target is now required"
            ),
            (t = new b())),
            t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = Nt.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (Nt.copy(this.direction).multiplyScalar(t).add(this.origin),
              Nt.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          kr.copy(e).add(t).multiplyScalar(0.5),
            Wi.copy(t).sub(e).normalize(),
            qt.copy(this.origin).sub(kr);
          const r = e.distanceTo(t) * 0.5,
            o = -this.direction.dot(Wi),
            a = qt.dot(this.direction),
            l = -qt.dot(Wi),
            c = qt.lengthSq(),
            h = Math.abs(1 - o * o);
          let u, d, f, m;
          if (h > 0)
            if (((u = o * l - a), (d = o * a - l), (m = r * h), u >= 0))
              if (d >= -m)
                if (d <= m) {
                  const x = 1 / h;
                  (u *= x),
                    (d *= x),
                    (f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c);
                } else
                  (d = r),
                    (u = Math.max(0, -(o * d + a))),
                    (f = -u * u + d * (d + 2 * l) + c);
              else
                (d = -r),
                  (u = Math.max(0, -(o * d + a))),
                  (f = -u * u + d * (d + 2 * l) + c);
            else
              d <= -m
                ? ((u = Math.max(0, -(-o * r + a))),
                  (d = u > 0 ? -r : Math.min(Math.max(-r, -l), r)),
                  (f = -u * u + d * (d + 2 * l) + c))
                : d <= m
                ? ((u = 0),
                  (d = Math.min(Math.max(-r, -l), r)),
                  (f = d * (d + 2 * l) + c))
                : ((u = Math.max(0, -(o * r + a))),
                  (d = u > 0 ? r : Math.min(Math.max(-r, -l), r)),
                  (f = -u * u + d * (d + 2 * l) + c));
          else
            (d = o > 0 ? -r : r),
              (u = Math.max(0, -(o * d + a))),
              (f = -u * u + d * (d + 2 * l) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(Wi).multiplyScalar(d).add(kr),
            f
          );
        }
        intersectSphere(e, t) {
          Nt.subVectors(e.center, this.origin);
          const n = Nt.dot(this.direction),
            i = Nt.dot(Nt) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const o = Math.sqrt(r - i),
            a = n - o,
            l = n + o;
          return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, o, a, l;
          const c = 1 / this.direction.x,
            h = 1 / this.direction.y,
            u = 1 / this.direction.z,
            d = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
              : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
            h >= 0
              ? ((r = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h))
              : ((r = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
            n > o ||
            r > i ||
            ((r > n || n !== n) && (n = r),
            (o < i || i !== i) && (i = o),
            u >= 0
              ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
              : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
            n > l || a > i) ||
            ((a > n || n !== n) && (n = a),
            (l < i || i !== i) && (i = l),
            i < 0)
              ? null
              : this.at(n >= 0 ? n : i, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, Nt) !== null;
        }
        intersectTriangle(e, t, n, i, r) {
          Vr.subVectors(t, e), qi.subVectors(n, e), Wr.crossVectors(Vr, qi);
          let o = this.direction.dot(Wr),
            a;
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else if (o < 0) (a = -1), (o = -o);
          else return null;
          qt.subVectors(this.origin, e);
          const l = a * this.direction.dot(qi.crossVectors(qt, qi));
          if (l < 0) return null;
          const c = a * this.direction.dot(Vr.cross(qt));
          if (c < 0 || l + c > o) return null;
          const h = -a * qt.dot(Wr);
          return h < 0 ? null : this.at(h / o, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class le {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, r, o, a, l, c, h, u, d, f, m, x, v) {
          const p = this.elements;
          return (
            (p[0] = e),
            (p[4] = t),
            (p[8] = n),
            (p[12] = i),
            (p[1] = r),
            (p[5] = o),
            (p[9] = a),
            (p[13] = l),
            (p[2] = c),
            (p[6] = h),
            (p[10] = u),
            (p[14] = d),
            (p[3] = f),
            (p[7] = m),
            (p[11] = x),
            (p[15] = v),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new le().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / Mn.setFromMatrixColumn(e, 0).length(),
            r = 1 / Mn.setFromMatrixColumn(e, 1).length(),
            o = 1 / Mn.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * o),
            (t[9] = n[9] * o),
            (t[10] = n[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            h = Math.cos(r),
            u = Math.sin(r);
          if (e.order === "XYZ") {
            const d = o * h,
              f = o * u,
              m = a * h,
              x = a * u;
            (t[0] = l * h),
              (t[4] = -l * u),
              (t[8] = c),
              (t[1] = f + m * c),
              (t[5] = d - x * c),
              (t[9] = -a * l),
              (t[2] = x - d * c),
              (t[6] = m + f * c),
              (t[10] = o * l);
          } else if (e.order === "YXZ") {
            const d = l * h,
              f = l * u,
              m = c * h,
              x = c * u;
            (t[0] = d + x * a),
              (t[4] = m * a - f),
              (t[8] = o * c),
              (t[1] = o * u),
              (t[5] = o * h),
              (t[9] = -a),
              (t[2] = f * a - m),
              (t[6] = x + d * a),
              (t[10] = o * l);
          } else if (e.order === "ZXY") {
            const d = l * h,
              f = l * u,
              m = c * h,
              x = c * u;
            (t[0] = d - x * a),
              (t[4] = -o * u),
              (t[8] = m + f * a),
              (t[1] = f + m * a),
              (t[5] = o * h),
              (t[9] = x - d * a),
              (t[2] = -o * c),
              (t[6] = a),
              (t[10] = o * l);
          } else if (e.order === "ZYX") {
            const d = o * h,
              f = o * u,
              m = a * h,
              x = a * u;
            (t[0] = l * h),
              (t[4] = m * c - f),
              (t[8] = d * c + x),
              (t[1] = l * u),
              (t[5] = x * c + d),
              (t[9] = f * c - m),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = o * l);
          } else if (e.order === "YZX") {
            const d = o * l,
              f = o * c,
              m = a * l,
              x = a * c;
            (t[0] = l * h),
              (t[4] = x - d * u),
              (t[8] = m * u + f),
              (t[1] = u),
              (t[5] = o * h),
              (t[9] = -a * h),
              (t[2] = -c * h),
              (t[6] = f * u + m),
              (t[10] = d - x * u);
          } else if (e.order === "XZY") {
            const d = o * l,
              f = o * c,
              m = a * l,
              x = a * c;
            (t[0] = l * h),
              (t[4] = -u),
              (t[8] = c * h),
              (t[1] = d * u + x),
              (t[5] = o * h),
              (t[9] = f * u - m),
              (t[2] = m * u - f),
              (t[6] = a * h),
              (t[10] = x * u + d);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(kh, e, Vh);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            pt.subVectors(e, t),
            pt.lengthSq() === 0 && (pt.z = 1),
            pt.normalize(),
            Xt.crossVectors(n, pt),
            Xt.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (pt.x += 1e-4) : (pt.z += 1e-4),
              pt.normalize(),
              Xt.crossVectors(n, pt)),
            Xt.normalize(),
            Xi.crossVectors(pt, Xt),
            (i[0] = Xt.x),
            (i[4] = Xi.x),
            (i[8] = pt.x),
            (i[1] = Xt.y),
            (i[5] = Xi.y),
            (i[9] = pt.y),
            (i[2] = Xt.z),
            (i[6] = Xi.z),
            (i[10] = pt.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            u = n[5],
            d = n[9],
            f = n[13],
            m = n[2],
            x = n[6],
            v = n[10],
            p = n[14],
            g = n[3],
            S = n[7],
            L = n[11],
            E = n[15],
            _ = i[0],
            C = i[4],
            F = i[8],
            O = i[12],
            V = i[1],
            W = i[5],
            z = i[9],
            T = i[13],
            I = i[2],
            P = i[6],
            R = i[10],
            G = i[14],
            ee = i[3],
            Z = i[7],
            se = i[11],
            ie = i[15];
          return (
            (r[0] = o * _ + a * V + l * I + c * ee),
            (r[4] = o * C + a * W + l * P + c * Z),
            (r[8] = o * F + a * z + l * R + c * se),
            (r[12] = o * O + a * T + l * G + c * ie),
            (r[1] = h * _ + u * V + d * I + f * ee),
            (r[5] = h * C + u * W + d * P + f * Z),
            (r[9] = h * F + u * z + d * R + f * se),
            (r[13] = h * O + u * T + d * G + f * ie),
            (r[2] = m * _ + x * V + v * I + p * ee),
            (r[6] = m * C + x * W + v * P + p * Z),
            (r[10] = m * F + x * z + v * R + p * se),
            (r[14] = m * O + x * T + v * G + p * ie),
            (r[3] = g * _ + S * V + L * I + E * ee),
            (r[7] = g * C + S * W + L * P + E * Z),
            (r[11] = g * F + S * z + L * R + E * se),
            (r[15] = g * O + S * T + L * G + E * ie),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            h = e[2],
            u = e[6],
            d = e[10],
            f = e[14],
            m = e[3],
            x = e[7],
            v = e[11],
            p = e[15];
          return (
            m *
              (+r * l * u -
                i * c * u -
                r * a * d +
                n * c * d +
                i * a * f -
                n * l * f) +
            x *
              (+t * l * f -
                t * c * d +
                r * o * d -
                i * o * f +
                i * c * h -
                r * l * h) +
            v *
              (+t * c * u -
                t * a * f -
                r * o * u +
                n * o * f +
                r * a * h -
                n * c * h) +
            p *
              (-i * a * h -
                t * l * u +
                t * a * d +
                i * o * u -
                n * o * d +
                n * l * h)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = e[9],
            d = e[10],
            f = e[11],
            m = e[12],
            x = e[13],
            v = e[14],
            p = e[15],
            g =
              u * v * c -
              x * d * c +
              x * l * f -
              a * v * f -
              u * l * p +
              a * d * p,
            S =
              m * d * c -
              h * v * c -
              m * l * f +
              o * v * f +
              h * l * p -
              o * d * p,
            L =
              h * x * c -
              m * u * c +
              m * a * f -
              o * x * f -
              h * a * p +
              o * u * p,
            E =
              m * u * l -
              h * x * l -
              m * a * d +
              o * x * d +
              h * a * v -
              o * u * v,
            _ = t * g + n * S + i * L + r * E;
          if (_ === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const C = 1 / _;
          return (
            (e[0] = g * C),
            (e[1] =
              (x * d * r -
                u * v * r -
                x * i * f +
                n * v * f +
                u * i * p -
                n * d * p) *
              C),
            (e[2] =
              (a * v * r -
                x * l * r +
                x * i * c -
                n * v * c -
                a * i * p +
                n * l * p) *
              C),
            (e[3] =
              (u * l * r -
                a * d * r -
                u * i * c +
                n * d * c +
                a * i * f -
                n * l * f) *
              C),
            (e[4] = S * C),
            (e[5] =
              (h * v * r -
                m * d * r +
                m * i * f -
                t * v * f -
                h * i * p +
                t * d * p) *
              C),
            (e[6] =
              (m * l * r -
                o * v * r -
                m * i * c +
                t * v * c +
                o * i * p -
                t * l * p) *
              C),
            (e[7] =
              (o * d * r -
                h * l * r +
                h * i * c -
                t * d * c -
                o * i * f +
                t * l * f) *
              C),
            (e[8] = L * C),
            (e[9] =
              (m * u * r -
                h * x * r -
                m * n * f +
                t * x * f +
                h * n * p -
                t * u * p) *
              C),
            (e[10] =
              (o * x * r -
                m * a * r +
                m * n * c -
                t * x * c -
                o * n * p +
                t * a * p) *
              C),
            (e[11] =
              (h * a * r -
                o * u * r -
                h * n * c +
                t * u * c +
                o * n * f -
                t * a * f) *
              C),
            (e[12] = E * C),
            (e[13] =
              (h * x * i -
                m * u * i +
                m * n * d -
                t * x * d -
                h * n * v +
                t * u * v) *
              C),
            (e[14] =
              (m * a * i -
                o * x * i -
                m * n * l +
                t * x * l +
                o * n * v -
                t * a * v) *
              C),
            (e[15] =
              (o * u * i -
                h * a * i +
                h * n * l -
                t * u * l -
                o * n * d +
                t * a * d) *
              C),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            o = e.x,
            a = e.y,
            l = e.z,
            c = r * o,
            h = r * a;
          return (
            this.set(
              c * o + n,
              c * a - i * l,
              c * l + i * a,
              0,
              c * a + i * l,
              h * a + n,
              h * l - i * o,
              0,
              c * l - i * a,
              h * l + i * o,
              r * l * l + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, o) {
          return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = r + r,
            h = o + o,
            u = a + a,
            d = r * c,
            f = r * h,
            m = r * u,
            x = o * h,
            v = o * u,
            p = a * u,
            g = l * c,
            S = l * h,
            L = l * u,
            E = n.x,
            _ = n.y,
            C = n.z;
          return (
            (i[0] = (1 - (x + p)) * E),
            (i[1] = (f + L) * E),
            (i[2] = (m - S) * E),
            (i[3] = 0),
            (i[4] = (f - L) * _),
            (i[5] = (1 - (d + p)) * _),
            (i[6] = (v + g) * _),
            (i[7] = 0),
            (i[8] = (m + S) * C),
            (i[9] = (v - g) * C),
            (i[10] = (1 - (d + x)) * C),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = Mn.set(i[0], i[1], i[2]).length();
          const o = Mn.set(i[4], i[5], i[6]).length(),
            a = Mn.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            wt.copy(this);
          const c = 1 / r,
            h = 1 / o,
            u = 1 / a;
          return (
            (wt.elements[0] *= c),
            (wt.elements[1] *= c),
            (wt.elements[2] *= c),
            (wt.elements[4] *= h),
            (wt.elements[5] *= h),
            (wt.elements[6] *= h),
            (wt.elements[8] *= u),
            (wt.elements[9] *= u),
            (wt.elements[10] *= u),
            t.setFromRotationMatrix(wt),
            (n.x = r),
            (n.y = o),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, o) {
          o === void 0 &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            l = (2 * r) / (t - e),
            c = (2 * r) / (n - i),
            h = (t + e) / (t - e),
            u = (n + i) / (n - i),
            d = -(o + r) / (o - r),
            f = (-2 * o * r) / (o - r);
          return (
            (a[0] = l),
            (a[4] = 0),
            (a[8] = h),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = u),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, o) {
          const a = this.elements,
            l = 1 / (t - e),
            c = 1 / (n - i),
            h = 1 / (o - r),
            u = (t + e) * l,
            d = (n + i) * c,
            f = (o + r) * h;
          return (
            (a[0] = 2 * l),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -u),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * h),
            (a[14] = -f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      le.prototype.isMatrix4 = !0;
      const Mn = new b(),
        wt = new le(),
        kh = new b(0, 0, 0),
        Vh = new b(1, 1, 1),
        Xt = new b(),
        Xi = new b(),
        pt = new b(),
        Co = new le(),
        Po = new ct();
      class Zn {
        constructor(e = 0, t = 0, n = 0, i = Zn.DefaultOrder) {
          (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i || this._order),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t, n) {
          const i = e.elements,
            r = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            h = i[9],
            u = i[2],
            d = i[6],
            f = i[10];
          switch (((t = t || this._order), t)) {
            case "XYZ":
              (this._y = Math.asin(ut(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-o, r)))
                  : ((this._x = Math.atan2(d, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-ut(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(ut(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-u, f)),
                    (this._z = Math.atan2(-o, c)))
                  : ((this._y = 0), (this._z = Math.atan2(l, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-ut(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, c)));
              break;
            case "YZX":
              (this._z = Math.asin(ut(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-h, c)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-ut(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-h, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), n !== !1 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            Co.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Co, t, n)
          );
        }
        setFromVector3(e, t) {
          return this.set(e.x, e.y, e.z, t || this._order);
        }
        reorder(e) {
          return Po.setFromEuler(this), this.setFromQuaternion(Po, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        toVector3(e) {
          return e
            ? e.set(this._x, this._y, this._z)
            : new b(this._x, this._y, this._z);
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
      }
      Zn.prototype.isEuler = !0;
      Zn.DefaultOrder = "XYZ";
      Zn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Wh {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e) | 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
      }
      let qh = 0;
      const Io = new b(),
        wn = new ct(),
        Ft = new le(),
        ji = new b(),
        si = new b(),
        Xh = new b(),
        jh = new ct(),
        Do = new b(1, 0, 0),
        No = new b(0, 1, 0),
        Fo = new b(0, 0, 1),
        Yh = { type: "added" },
        Bo = { type: "removed" };
      class Ie extends mn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: qh++ }),
            (this.uuid = vt()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Ie.DefaultUp.clone());
          const e = new b(),
            t = new Zn(),
            n = new ct(),
            i = new b(1, 1, 1);
          function r() {
            n.setFromEuler(t, !1);
          }
          function o() {
            t.setFromQuaternion(n, void 0, !1);
          }
          t._onChange(r),
            n._onChange(o),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new le() },
              normalMatrix: { value: new et() },
            }),
            (this.matrix = new le()),
            (this.matrixWorld = new le()),
            (this.matrixAutoUpdate = Ie.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Wh()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return wn.setFromAxisAngle(e, t), this.quaternion.multiply(wn), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            wn.setFromAxisAngle(e, t), this.quaternion.premultiply(wn), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(Do, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(No, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(Fo, e);
        }
        translateOnAxis(e, t) {
          return (
            Io.copy(e).applyQuaternion(this.quaternion),
            this.position.add(Io.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(Do, e);
        }
        translateY(e) {
          return this.translateOnAxis(No, e);
        }
        translateZ(e) {
          return this.translateOnAxis(Fo, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(Ft.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? ji.copy(e) : ji.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            si.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Ft.lookAt(si, ji, this.up)
              : Ft.lookAt(ji, si, this.up),
            this.quaternion.setFromRotationMatrix(Ft),
            i &&
              (Ft.extractRotation(i.matrixWorld),
              wn.setFromRotationMatrix(Ft),
              this.quaternion.premultiply(wn.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.parent !== null && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(Yh))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(Bo)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(Bo);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            Ft.copy(this.matrixWorld).invert(),
            e.parent !== null &&
              (e.parent.updateWorldMatrix(!0, !1),
              Ft.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Ft),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0) return o;
          }
        }
        getWorldPosition(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (e = new b())),
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (e = new ct())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(si, e, Xh),
            e
          );
        }
        getWorldScale(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (e = new b())),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(si, jh, e),
            e
          );
        }
        getWorldDirection(e) {
          e === void 0 &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required"
            ),
            (e = new b())),
            this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            t === !0)
          ) {
            const i = this.children;
            for (let r = 0, o = i.length; r < o; r++)
              i[r].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            JSON.stringify(this.userData) !== "{}" &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (i.instanceColor = this.instanceColor.toJSON()));
          function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
          }
          if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const l = a.shapes;
              if (Array.isArray(l))
                for (let c = 0, h = l.length; c < h; c++) {
                  const u = l[c];
                  r(e.shapes, u);
                }
              else r(e.shapes, l);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const a = [];
              for (let l = 0, c = this.material.length; l < c; l++)
                a.push(r(e.materials, this.material[l]));
              i.material = a;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
              i.children.push(this.children[a].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const l = this.animations[a];
              i.animations.push(r(e.animations, l));
            }
          }
          if (t) {
            const a = o(e.geometries),
              l = o(e.materials),
              c = o(e.textures),
              h = o(e.images),
              u = o(e.shapes),
              d = o(e.skeletons),
              f = o(e.animations);
            a.length > 0 && (n.geometries = a),
              l.length > 0 && (n.materials = l),
              c.length > 0 && (n.textures = c),
              h.length > 0 && (n.images = h),
              u.length > 0 && (n.shapes = u),
              d.length > 0 && (n.skeletons = d),
              f.length > 0 && (n.animations = f);
          }
          return (n.object = i), n;
          function o(a) {
            const l = [];
            for (const c in a) {
              const h = a[c];
              delete h.metadata, l.push(h);
            }
            return l;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let n = 0; n < e.children.length; n++) {
              const i = e.children[n];
              this.add(i.clone());
            }
          return this;
        }
      }
      Ie.DefaultUp = new b(0, 1, 0);
      Ie.DefaultMatrixAutoUpdate = !0;
      Ie.prototype.isObject3D = !0;
      const qr = new b(),
        Zh = new b(),
        Jh = new et();
      class Lt {
        constructor(e = new b(1, 0, 0), t = 0) {
          (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = qr.subVectors(n, t).cross(Zh.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return (
            t === void 0 &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
              (t = new b())),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
          );
        }
        intersectLine(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Plane: .intersectLine() target is now required"
            ),
            (t = new b()));
          const n = e.delta(qr),
            i = this.normal.dot(n);
          if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : t.copy(n).multiplyScalar(r).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
              (e = new b())),
            e.copy(this.normal).multiplyScalar(-this.constant)
          );
        }
        applyMatrix4(e, t) {
          const n = t || Jh.getNormalMatrix(e),
            i = this.coplanarPoint(qr).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Lt.prototype.isPlane = !0;
      const bt = new b(),
        Bt = new b(),
        Xr = new b(),
        Ot = new b(),
        bn = new b(),
        Sn = new b(),
        Oo = new b(),
        jr = new b(),
        Yr = new b(),
        Zr = new b();
      class qe {
        constructor(e = new b(), t = new b(), n = new b()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i === void 0 &&
            (console.warn(
              "THREE.Triangle: .getNormal() target is now required"
            ),
            (i = new b())),
            i.subVectors(n, t),
            bt.subVectors(e, t),
            i.cross(bt);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          bt.subVectors(i, t), Bt.subVectors(n, t), Xr.subVectors(e, t);
          const o = bt.dot(bt),
            a = bt.dot(Bt),
            l = bt.dot(Xr),
            c = Bt.dot(Bt),
            h = Bt.dot(Xr),
            u = o * c - a * a;
          if (
            (r === void 0 &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required"
              ),
              (r = new b())),
            u === 0)
          )
            return r.set(-2, -1, -1);
          const d = 1 / u,
            f = (c * l - a * h) * d,
            m = (o * h - a * l) * d;
          return r.set(1 - f - m, m, f);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, Ot),
            Ot.x >= 0 && Ot.y >= 0 && Ot.x + Ot.y <= 1
          );
        }
        static getUV(e, t, n, i, r, o, a, l) {
          return (
            this.getBarycoord(e, t, n, i, Ot),
            l.set(0, 0),
            l.addScaledVector(r, Ot.x),
            l.addScaledVector(o, Ot.y),
            l.addScaledVector(a, Ot.z),
            l
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            bt.subVectors(n, t), Bt.subVectors(e, t), bt.cross(Bt).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            bt.subVectors(this.c, this.b),
            Bt.subVectors(this.a, this.b),
            bt.cross(Bt).length() * 0.5
          );
        }
        getMidpoint(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (e = new b())),
            e
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        }
        getNormal(e) {
          return qe.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return (
            e === void 0 &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (e = new Lt())),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        }
        getBarycoord(e, t) {
          return qe.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, r) {
          return qe.getUV(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return qe.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return qe.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          t === void 0 &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (t = new b()));
          const n = this.a,
            i = this.b,
            r = this.c;
          let o, a;
          bn.subVectors(i, n), Sn.subVectors(r, n), jr.subVectors(e, n);
          const l = bn.dot(jr),
            c = Sn.dot(jr);
          if (l <= 0 && c <= 0) return t.copy(n);
          Yr.subVectors(e, i);
          const h = bn.dot(Yr),
            u = Sn.dot(Yr);
          if (h >= 0 && u <= h) return t.copy(i);
          const d = l * u - h * c;
          if (d <= 0 && l >= 0 && h <= 0)
            return (o = l / (l - h)), t.copy(n).addScaledVector(bn, o);
          Zr.subVectors(e, r);
          const f = bn.dot(Zr),
            m = Sn.dot(Zr);
          if (m >= 0 && f <= m) return t.copy(r);
          const x = f * c - l * m;
          if (x <= 0 && c >= 0 && m <= 0)
            return (a = c / (c - m)), t.copy(n).addScaledVector(Sn, a);
          const v = h * m - f * u;
          if (v <= 0 && u - h >= 0 && f - m >= 0)
            return (
              Oo.subVectors(r, i),
              (a = (u - h) / (u - h + (f - m))),
              t.copy(i).addScaledVector(Oo, a)
            );
          const p = 1 / (v + x + d);
          return (
            (o = x * p),
            (a = d * p),
            t.copy(n).addScaledVector(bn, o).addScaledVector(Sn, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let Kh = 0;
      class Ke extends mn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: Kh++ }),
            (this.uuid = vt()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = vi),
            (this.side = Ti),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = Ba),
            (this.blendDst = Oa),
            (this.blendEquation = Nn),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = ms),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = bh),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Fr),
            (this.stencilZFail = Fr),
            (this.stencilZPass = Fr),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0);
        }
        onBuild() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const n = e[t];
              if (n === void 0) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if (t === "shading") {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === Fa);
                continue;
              }
              const i = this[t];
              if (i === void 0) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
                continue;
              }
              i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== vi && (n.blending = this.blending),
            this.side !== Ti && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 &&
              (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.morphTargets === !0 && (n.morphTargets = !0),
            this.morphNormals === !0 && (n.morphNormals = !0),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData);
          function i(r) {
            const o = [];
            for (const a in r) {
              const l = r[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (t) {
            const r = i(e.textures),
              o = i(e.images);
            r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.fog = e.fog),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      Ke.prototype.isMaterial = !0;
      const Wa = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        St = { h: 0, s: 0, l: 0 },
        Yi = { h: 0, s: 0, l: 0 };
      function Jr(s, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? s + (e - s) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? s + (e - s) * 6 * (2 / 3 - t)
            : s
        );
      }
      function Kr(s) {
        return s < 0.04045
          ? s * 0.0773993808
          : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function Qr(s) {
        return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      class ae {
        constructor(e, t, n) {
          return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : typeof e == "number"
              ? this.setHex(e)
              : typeof e == "string" && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            this
          );
        }
        setRGB(e, t, n) {
          return (this.r = e), (this.g = t), (this.b = n), this;
        }
        setHSL(e, t, n) {
          if (((e = Ns(e, 1)), (t = ut(t, 0, 1)), (n = ut(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = Jr(r, i, e + 1 / 3)),
              (this.g = Jr(r, i, e)),
              (this.b = Jr(r, i, e - 1 / 3));
          }
          return this;
        }
        setStyle(e) {
          function t(i) {
            i !== void 0 &&
              parseFloat(i) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let n;
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let i;
            const r = n[1],
              o = n[2];
            switch (r) {
              case "rgb":
              case "rgba":
                if (
                  (i =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                    t(i[4]),
                    this
                  );
                if (
                  (i =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                    t(i[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (i =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                ) {
                  const a = parseFloat(i[1]) / 360,
                    l = parseInt(i[2], 10) / 100,
                    c = parseInt(i[3], 10) / 100;
                  return t(i[4]), this.setHSL(a, l, c);
                }
                break;
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const i = n[1],
              r = i.length;
            if (r === 3)
              return (
                (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
                (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
                (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
                this
              );
            if (r === 6)
              return (
                (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
                (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
                (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e) : this;
        }
        setColorName(e) {
          const t = Wa[e.toLowerCase()];
          return (
            t !== void 0
              ? this.setHex(t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copyGammaToLinear(e, t = 2) {
          return (
            (this.r = Math.pow(e.r, t)),
            (this.g = Math.pow(e.g, t)),
            (this.b = Math.pow(e.b, t)),
            this
          );
        }
        copyLinearToGamma(e, t = 2) {
          const n = t > 0 ? 1 / t : 1;
          return (
            (this.r = Math.pow(e.r, n)),
            (this.g = Math.pow(e.g, n)),
            (this.b = Math.pow(e.b, n)),
            this
          );
        }
        convertGammaToLinear(e) {
          return this.copyGammaToLinear(this, e), this;
        }
        convertLinearToGamma(e) {
          return this.copyLinearToGamma(this, e), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = Kr(e.r)), (this.g = Kr(e.g)), (this.b = Kr(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = Qr(e.r)), (this.g = Qr(e.g)), (this.b = Qr(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((this.r * 255) << 16) ^
            ((this.g * 255) << 8) ^
            ((this.b * 255) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(e) {
          e === void 0 &&
            (console.warn("THREE.Color: .getHSL() target is now required"),
            (e = { h: 0, s: 0, l: 0 }));
          const t = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(t, n, i),
            o = Math.min(t, n, i);
          let a, l;
          const c = (o + r) / 2;
          if (o === r) (a = 0), (l = 0);
          else {
            const h = r - o;
            switch (((l = c <= 0.5 ? h / (r + o) : h / (2 - r - o)), r)) {
              case t:
                a = (n - i) / h + (n < i ? 6 : 0);
                break;
              case n:
                a = (i - t) / h + 2;
                break;
              case i:
                a = (t - n) / h + 4;
                break;
            }
            a /= 6;
          }
          return (e.h = a), (e.s = l), (e.l = c), e;
        }
        getStyle() {
          return (
            "rgb(" +
            ((this.r * 255) | 0) +
            "," +
            ((this.g * 255) | 0) +
            "," +
            ((this.b * 255) | 0) +
            ")"
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(St),
            (St.h += e),
            (St.s += t),
            (St.l += n),
            this.setHSL(St.h, St.s, St.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(St), e.getHSL(Yi);
          const n = wi(St.h, Yi.h, t),
            i = wi(St.s, Yi.s, t),
            r = wi(St.l, Yi.l, t);
          return this.setHSL(n, i, r), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      ae.NAMES = Wa;
      ae.prototype.isColor = !0;
      ae.prototype.r = 1;
      ae.prototype.g = 1;
      ae.prototype.b = 1;
      class $t extends Ke {
        constructor(e) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new ae(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Sr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      $t.prototype.isMeshBasicMaterial = !0;
      const Oe = new b(),
        Zi = new Y();
      class Xe {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n === !0),
            (this.usage = Li),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (o = new ae())),
              (t[n++] = o.r),
              (t[n++] = o.g),
              (t[n++] = o.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (o = new Y())),
              (t[n++] = o.x),
              (t[n++] = o.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (o = new b())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, r = e.length; i < r; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (o = new Fe())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z),
              (t[n++] = o.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
              Zi.fromBufferAttribute(this, t),
                Zi.applyMatrix3(e),
                this.setXY(t, Zi.x, Zi.y);
          else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
              Oe.fromBufferAttribute(this, t),
                Oe.applyMatrix3(e),
                this.setXYZ(t, Oe.x, Oe.y, Oe.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (Oe.x = this.getX(t)),
              (Oe.y = this.getY(t)),
              (Oe.z = this.getZ(t)),
              Oe.applyMatrix4(e),
              this.setXYZ(t, Oe.x, Oe.y, Oe.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (Oe.x = this.getX(t)),
              (Oe.y = this.getY(t)),
              (Oe.z = this.getZ(t)),
              Oe.applyNormalMatrix(e),
              this.setXYZ(t, Oe.x, Oe.y, Oe.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (Oe.x = this.getX(t)),
              (Oe.y = this.getY(t)),
              (Oe.z = this.getZ(t)),
              Oe.transformDirection(e),
              this.setXYZ(t, Oe.x, Oe.y, Oe.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (e.name = this.name),
            this.usage !== Li && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      Xe.prototype.isBufferAttribute = !0;
      class qa extends Xe {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class Xa extends Xe {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class Qh extends Xe {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      Qh.prototype.isFloat16BufferAttribute = !0;
      class Je extends Xe {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      function ja(s) {
        if (s.length === 0) return -1 / 0;
        let e = s[0];
        for (let t = 1, n = s.length; t < n; ++t) s[t] > e && (e = s[t]);
        return e;
      }
      let $h = 0;
      const xt = new le(),
        $r = new Ie(),
        Tn = new b(),
        mt = new gt(),
        oi = new gt(),
        Ye = new b();
      class ze extends mn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: $h++ }),
            (this.uuid = vt()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (ja(e) > 65535 ? Xa : qa)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const r = new et().getNormalMatrix(e);
            n.applyNormalMatrix(r), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return xt.makeRotationFromQuaternion(e), this.applyMatrix4(xt), this;
        }
        rotateX(e) {
          return xt.makeRotationX(e), this.applyMatrix4(xt), this;
        }
        rotateY(e) {
          return xt.makeRotationY(e), this.applyMatrix4(xt), this;
        }
        rotateZ(e) {
          return xt.makeRotationZ(e), this.applyMatrix4(xt), this;
        }
        translate(e, t, n) {
          return xt.makeTranslation(e, t, n), this.applyMatrix4(xt), this;
        }
        scale(e, t, n) {
          return xt.makeScale(e, t, n), this.applyMatrix4(xt), this;
        }
        lookAt(e) {
          return (
            $r.lookAt(e), $r.updateMatrix(), this.applyMatrix4($r.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Tn).negate(),
            this.translate(Tn.x, Tn.y, Tn.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0);
          }
          return this.setAttribute("position", new Je(t, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new gt());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingBox.set(
                new b(-1 / 0, -1 / 0, -1 / 0),
                new b(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let n = 0, i = t.length; n < i; n++) {
                const r = t[n];
                mt.setFromBufferAttribute(r),
                  this.morphTargetsRelative
                    ? (Ye.addVectors(this.boundingBox.min, mt.min),
                      this.boundingBox.expandByPoint(Ye),
                      Ye.addVectors(this.boundingBox.max, mt.max),
                      this.boundingBox.expandByPoint(Ye))
                    : (this.boundingBox.expandByPoint(mt.min),
                      this.boundingBox.expandByPoint(mt.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new gn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingSphere.set(new b(), 1 / 0);
            return;
          }
          if (e) {
            const n = this.boundingSphere.center;
            if ((mt.setFromBufferAttribute(e), t))
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r];
                oi.setFromBufferAttribute(a),
                  this.morphTargetsRelative
                    ? (Ye.addVectors(mt.min, oi.min),
                      mt.expandByPoint(Ye),
                      Ye.addVectors(mt.max, oi.max),
                      mt.expandByPoint(Ye))
                    : (mt.expandByPoint(oi.min), mt.expandByPoint(oi.max));
              }
            mt.getCenter(n);
            let i = 0;
            for (let r = 0, o = e.count; r < o; r++)
              Ye.fromBufferAttribute(e, r),
                (i = Math.max(i, n.distanceToSquared(Ye)));
            if (t)
              for (let r = 0, o = t.length; r < o; r++) {
                const a = t[r],
                  l = this.morphTargetsRelative;
                for (let c = 0, h = a.count; c < h; c++)
                  Ye.fromBufferAttribute(a, c),
                    l && (Tn.fromBufferAttribute(e, c), Ye.add(Tn)),
                    (i = Math.max(i, n.distanceToSquared(Ye)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeFaceNormals() {}
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.array,
            i = t.position.array,
            r = t.normal.array,
            o = t.uv.array,
            a = i.length / 3;
          t.tangent === void 0 &&
            this.setAttribute("tangent", new Xe(new Float32Array(4 * a), 4));
          const l = t.tangent.array,
            c = [],
            h = [];
          for (let V = 0; V < a; V++) (c[V] = new b()), (h[V] = new b());
          const u = new b(),
            d = new b(),
            f = new b(),
            m = new Y(),
            x = new Y(),
            v = new Y(),
            p = new b(),
            g = new b();
          function S(V, W, z) {
            u.fromArray(i, V * 3),
              d.fromArray(i, W * 3),
              f.fromArray(i, z * 3),
              m.fromArray(o, V * 2),
              x.fromArray(o, W * 2),
              v.fromArray(o, z * 2),
              d.sub(u),
              f.sub(u),
              x.sub(m),
              v.sub(m);
            const T = 1 / (x.x * v.y - v.x * x.y);
            !isFinite(T) ||
              (p
                .copy(d)
                .multiplyScalar(v.y)
                .addScaledVector(f, -x.y)
                .multiplyScalar(T),
              g
                .copy(f)
                .multiplyScalar(x.x)
                .addScaledVector(d, -v.x)
                .multiplyScalar(T),
              c[V].add(p),
              c[W].add(p),
              c[z].add(p),
              h[V].add(g),
              h[W].add(g),
              h[z].add(g));
          }
          let L = this.groups;
          L.length === 0 && (L = [{ start: 0, count: n.length }]);
          for (let V = 0, W = L.length; V < W; ++V) {
            const z = L[V],
              T = z.start,
              I = z.count;
            for (let P = T, R = T + I; P < R; P += 3)
              S(n[P + 0], n[P + 1], n[P + 2]);
          }
          const E = new b(),
            _ = new b(),
            C = new b(),
            F = new b();
          function O(V) {
            C.fromArray(r, V * 3), F.copy(C);
            const W = c[V];
            E.copy(W),
              E.sub(C.multiplyScalar(C.dot(W))).normalize(),
              _.crossVectors(F, W);
            const T = _.dot(h[V]) < 0 ? -1 : 1;
            (l[V * 4] = E.x),
              (l[V * 4 + 1] = E.y),
              (l[V * 4 + 2] = E.z),
              (l[V * 4 + 3] = T);
          }
          for (let V = 0, W = L.length; V < W; ++V) {
            const z = L[V],
              T = z.start,
              I = z.count;
            for (let P = T, R = T + I; P < R; P += 3)
              O(n[P + 0]), O(n[P + 1]), O(n[P + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new Xe(new Float32Array(t.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const i = new b(),
              r = new b(),
              o = new b(),
              a = new b(),
              l = new b(),
              c = new b(),
              h = new b(),
              u = new b();
            if (e)
              for (let d = 0, f = e.count; d < f; d += 3) {
                const m = e.getX(d + 0),
                  x = e.getX(d + 1),
                  v = e.getX(d + 2);
                i.fromBufferAttribute(t, m),
                  r.fromBufferAttribute(t, x),
                  o.fromBufferAttribute(t, v),
                  h.subVectors(o, r),
                  u.subVectors(i, r),
                  h.cross(u),
                  a.fromBufferAttribute(n, m),
                  l.fromBufferAttribute(n, x),
                  c.fromBufferAttribute(n, v),
                  a.add(h),
                  l.add(h),
                  c.add(h),
                  n.setXYZ(m, a.x, a.y, a.z),
                  n.setXYZ(x, l.x, l.y, l.z),
                  n.setXYZ(v, c.x, c.y, c.z);
              }
            else
              for (let d = 0, f = t.count; d < f; d += 3)
                i.fromBufferAttribute(t, d + 0),
                  r.fromBufferAttribute(t, d + 1),
                  o.fromBufferAttribute(t, d + 2),
                  h.subVectors(o, r),
                  u.subVectors(i, r),
                  h.cross(u),
                  n.setXYZ(d + 0, h.x, h.y, h.z),
                  n.setXYZ(d + 1, h.x, h.y, h.z),
                  n.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!(e && e.isBufferGeometry)) {
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
            return;
          }
          t === void 0 &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (e.attributes[i] === void 0) continue;
            const o = n[i].array,
              a = e.attributes[i],
              l = a.array,
              c = a.itemSize * t,
              h = Math.min(l.length, o.length - c);
            for (let u = 0, d = c; u < h; u++, d++) o[d] = l[u];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            Ye.fromBufferAttribute(e, t),
              Ye.normalize(),
              e.setXYZ(t, Ye.x, Ye.y, Ye.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              h = a.itemSize,
              u = a.normalized,
              d = new c.constructor(l.length * h);
            let f = 0,
              m = 0;
            for (let x = 0, v = l.length; x < v; x++) {
              f = l[x] * h;
              for (let p = 0; p < h; p++) d[m++] = c[f++];
            }
            return new Xe(d, h, u);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new ze(),
            n = this.index.array,
            i = this.attributes;
          for (const a in i) {
            const l = i[a],
              c = e(l, n);
            t.setAttribute(a, c);
          }
          const r = this.morphAttributes;
          for (const a in r) {
            const l = [],
              c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
              const d = c[h],
                f = e(d, n);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              h = [];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = c[u];
              h.push(f.toJSON(e.data));
            }
            h.length > 0 && ((i[l] = h), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            a !== null &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new ze().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          n !== null && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const c in i) {
            const h = i[c];
            this.setAttribute(c, h.clone(t));
          }
          const r = e.morphAttributes;
          for (const c in r) {
            const h = [],
              u = r[c];
            for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
            this.morphAttributes[c] = h;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          const a = e.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            l !== null && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      ze.prototype.isBufferGeometry = !0;
      const zo = new le(),
        En = new Yn(),
        es = new gn(),
        jt = new b(),
        Yt = new b(),
        Zt = new b(),
        ts = new b(),
        ns = new b(),
        is = new b(),
        Ji = new b(),
        Ki = new b(),
        Qi = new b(),
        $i = new Y(),
        er = new Y(),
        tr = new Y(),
        rs = new b(),
        nr = new b();
      class _t extends Ie {
        constructor(e = new ze(), t = new $t()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            e.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (
            i === void 0 ||
            (n.boundingSphere === null && n.computeBoundingSphere(),
            es.copy(n.boundingSphere),
            es.applyMatrix4(r),
            e.ray.intersectsSphere(es) === !1) ||
            (zo.copy(r).invert(),
            En.copy(e.ray).applyMatrix4(zo),
            n.boundingBox !== null && En.intersectsBox(n.boundingBox) === !1)
          )
            return;
          let o;
          if (n.isBufferGeometry) {
            const a = n.index,
              l = n.attributes.position,
              c = n.morphAttributes.position,
              h = n.morphTargetsRelative,
              u = n.attributes.uv,
              d = n.attributes.uv2,
              f = n.groups,
              m = n.drawRange;
            if (a !== null)
              if (Array.isArray(i))
                for (let x = 0, v = f.length; x < v; x++) {
                  const p = f[x],
                    g = i[p.materialIndex],
                    S = Math.max(p.start, m.start),
                    L = Math.min(p.start + p.count, m.start + m.count);
                  for (let E = S, _ = L; E < _; E += 3) {
                    const C = a.getX(E),
                      F = a.getX(E + 1),
                      O = a.getX(E + 2);
                    (o = ir(this, g, e, En, l, c, h, u, d, C, F, O)),
                      o &&
                        ((o.faceIndex = Math.floor(E / 3)),
                        (o.face.materialIndex = p.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const x = Math.max(0, m.start),
                  v = Math.min(a.count, m.start + m.count);
                for (let p = x, g = v; p < g; p += 3) {
                  const S = a.getX(p),
                    L = a.getX(p + 1),
                    E = a.getX(p + 2);
                  (o = ir(this, i, e, En, l, c, h, u, d, S, L, E)),
                    o && ((o.faceIndex = Math.floor(p / 3)), t.push(o));
                }
              }
            else if (l !== void 0)
              if (Array.isArray(i))
                for (let x = 0, v = f.length; x < v; x++) {
                  const p = f[x],
                    g = i[p.materialIndex],
                    S = Math.max(p.start, m.start),
                    L = Math.min(p.start + p.count, m.start + m.count);
                  for (let E = S, _ = L; E < _; E += 3) {
                    const C = E,
                      F = E + 1,
                      O = E + 2;
                    (o = ir(this, g, e, En, l, c, h, u, d, C, F, O)),
                      o &&
                        ((o.faceIndex = Math.floor(E / 3)),
                        (o.face.materialIndex = p.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const x = Math.max(0, m.start),
                  v = Math.min(l.count, m.start + m.count);
                for (let p = x, g = v; p < g; p += 3) {
                  const S = p,
                    L = p + 1,
                    E = p + 2;
                  (o = ir(this, i, e, En, l, c, h, u, d, S, L, E)),
                    o && ((o.faceIndex = Math.floor(p / 3)), t.push(o));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      _t.prototype.isMesh = !0;
      function eu(s, e, t, n, i, r, o, a) {
        let l;
        if (
          (e.side === Ze
            ? (l = n.intersectTriangle(o, r, i, !0, a))
            : (l = n.intersectTriangle(i, r, o, e.side !== Bi, a)),
          l === null)
        )
          return null;
        nr.copy(a), nr.applyMatrix4(s.matrixWorld);
        const c = t.ray.origin.distanceTo(nr);
        return c < t.near || c > t.far
          ? null
          : { distance: c, point: nr.clone(), object: s };
      }
      function ir(s, e, t, n, i, r, o, a, l, c, h, u) {
        jt.fromBufferAttribute(i, c),
          Yt.fromBufferAttribute(i, h),
          Zt.fromBufferAttribute(i, u);
        const d = s.morphTargetInfluences;
        if (e.morphTargets && r && d) {
          Ji.set(0, 0, 0), Ki.set(0, 0, 0), Qi.set(0, 0, 0);
          for (let m = 0, x = r.length; m < x; m++) {
            const v = d[m],
              p = r[m];
            v !== 0 &&
              (ts.fromBufferAttribute(p, c),
              ns.fromBufferAttribute(p, h),
              is.fromBufferAttribute(p, u),
              o
                ? (Ji.addScaledVector(ts, v),
                  Ki.addScaledVector(ns, v),
                  Qi.addScaledVector(is, v))
                : (Ji.addScaledVector(ts.sub(jt), v),
                  Ki.addScaledVector(ns.sub(Yt), v),
                  Qi.addScaledVector(is.sub(Zt), v)));
          }
          jt.add(Ji), Yt.add(Ki), Zt.add(Qi);
        }
        s.isSkinnedMesh &&
          (s.boneTransform(c, jt),
          s.boneTransform(h, Yt),
          s.boneTransform(u, Zt));
        const f = eu(s, e, t, n, jt, Yt, Zt, rs);
        if (f) {
          a &&
            ($i.fromBufferAttribute(a, c),
            er.fromBufferAttribute(a, h),
            tr.fromBufferAttribute(a, u),
            (f.uv = qe.getUV(rs, jt, Yt, Zt, $i, er, tr, new Y()))),
            l &&
              ($i.fromBufferAttribute(l, c),
              er.fromBufferAttribute(l, h),
              tr.fromBufferAttribute(l, u),
              (f.uv2 = qe.getUV(rs, jt, Yt, Zt, $i, er, tr, new Y())));
          const m = { a: c, b: h, c: u, normal: new b(), materialIndex: 0 };
          qe.getNormal(jt, Yt, Zt, m.normal), (f.face = m);
        }
        return f;
      }
      class Fs extends ze {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: o,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
          const l = [],
            c = [],
            h = [],
            u = [];
          let d = 0,
            f = 0;
          m("z", "y", "x", -1, -1, n, t, e, o, r, 0),
            m("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
            m("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            m("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            m("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            m("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(l),
            this.setAttribute("position", new Je(c, 3)),
            this.setAttribute("normal", new Je(h, 3)),
            this.setAttribute("uv", new Je(u, 2));
          function m(x, v, p, g, S, L, E, _, C, F, O) {
            const V = L / C,
              W = E / F,
              z = L / 2,
              T = E / 2,
              I = _ / 2,
              P = C + 1,
              R = F + 1;
            let G = 0,
              ee = 0;
            const Z = new b();
            for (let se = 0; se < R; se++) {
              const ie = se * W - T;
              for (let ye = 0; ye < P; ye++) {
                const ve = ye * V - z;
                (Z[x] = ve * g),
                  (Z[v] = ie * S),
                  (Z[p] = I),
                  c.push(Z.x, Z.y, Z.z),
                  (Z[x] = 0),
                  (Z[v] = 0),
                  (Z[p] = _ > 0 ? 1 : -1),
                  h.push(Z.x, Z.y, Z.z),
                  u.push(ye / C),
                  u.push(1 - se / F),
                  (G += 1);
              }
            }
            for (let se = 0; se < F; se++)
              for (let ie = 0; ie < C; ie++) {
                const ye = d + ie + P * se,
                  ve = d + ie + P * (se + 1),
                  Ce = d + (ie + 1) + P * (se + 1),
                  Ee = d + (ie + 1) + P * se;
                l.push(ye, ve, Ee), l.push(ve, Ce, Ee), (ee += 6);
              }
            a.addGroup(f, ee, O), (f += ee), (d += G);
          }
        }
      }
      function kn(s) {
        const e = {};
        for (const t in s) {
          e[t] = {};
          for (const n in s[t]) {
            const i = s[t][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (e[t][n] = i.clone())
              : Array.isArray(i)
              ? (e[t][n] = i.slice())
              : (e[t][n] = i);
          }
        }
        return e;
      }
      function st(s) {
        const e = {};
        for (let t = 0; t < s.length; t++) {
          const n = kn(s[t]);
          for (const i in n) e[i] = n[i];
        }
        return e;
      }
      const tu = { clone: kn, merge: st };
      var nu = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        iu = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class fn extends Ke {
        constructor(e) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = nu),
            (this.fragmentShader = iu),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 &&
              (e.attributes !== void 0 &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = kn(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture
              ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
              : o && o.isColor
              ? (t.uniforms[i] = { type: "c", value: o.getHex() })
              : o && o.isVector2
              ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
              : o && o.isVector3
              ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
              ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
              : o && o.isMatrix3
              ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
              : o && o.isMatrix4
              ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
              : (t.uniforms[i] = { value: o });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      fn.prototype.isShaderMaterial = !0;
      class Bs extends Ie {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new le()),
            (this.projectionMatrix = new le()),
            (this.projectionMatrixInverse = new le());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          e === void 0 &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required"
            ),
            (e = new b())),
            this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Bs.prototype.isCamera = !0;
      class lt extends Bs {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = Ri * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(Mi * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return Ri * 2 * Math.atan(Math.tan(Mi * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, r, o) {
          (this.aspect = e / t),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(Mi * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const o = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
              c = o.fullHeight;
            (r += (o.offsetX * i) / l),
              (t -= (o.offsetY * n) / c),
              (i *= o.width / l),
              (n *= o.height / c);
          }
          const a = this.filmOffset;
          a !== 0 && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      lt.prototype.isPerspectiveCamera = !0;
      const An = 90,
        Ln = 1;
      class Os extends Ie {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            n.isWebGLCubeRenderTarget !== !0)
          ) {
            console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
            return;
          }
          this.renderTarget = n;
          const i = new lt(An, Ln, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new b(1, 0, 0)),
            this.add(i);
          const r = new lt(An, Ln, e, t);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new b(-1, 0, 0)),
            this.add(r);
          const o = new lt(An, Ln, e, t);
          (o.layers = this.layers),
            o.up.set(0, 0, 1),
            o.lookAt(new b(0, 1, 0)),
            this.add(o);
          const a = new lt(An, Ln, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new b(0, -1, 0)),
            this.add(a);
          const l = new lt(An, Ln, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new b(0, 0, 1)),
            this.add(l);
          const c = new lt(An, Ln, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new b(0, 0, -1)),
            this.add(c);
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, o, a, l, c] = this.children,
            h = e.xr.enabled,
            u = e.getRenderTarget();
          e.xr.enabled = !1;
          const d = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, r),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            (n.texture.generateMipmaps = d),
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            (e.xr.enabled = h);
        }
      }
      class Tr extends tt {
        constructor(e, t, n, i, r, o, a, l, c, h) {
          (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : Ls),
            (a = a !== void 0 ? a : tn),
            super(e, t, n, i, r, o, a, l, c, h),
            (this._needsFlipEnvMap = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      Tr.prototype.isCubeTexture = !0;
      class Ya extends Ht {
        constructor(e, t, n) {
          Number.isInteger(t) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (t = n)),
            super(e, e, t),
            (t = t || {}),
            (this.texture = new Tr(
              void 0,
              t.mapping,
              t.wrapS,
              t.wrapT,
              t.magFilter,
              t.minFilter,
              t.format,
              t.type,
              t.anisotropy,
              t.encoding
            )),
            (this.texture.generateMipmaps =
              t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
              t.minFilter !== void 0 ? t.minFilter : ft),
            (this.texture._needsFlipEnvMap = !1);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.format = Et),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new Fs(5, 5, 5),
            r = new fn({
              name: "CubemapFromEquirect",
              uniforms: kn(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: Ze,
              blending: xi,
            });
          r.uniforms.tEquirect.value = t;
          const o = new _t(i, r),
            a = t.minFilter;
          return (
            t.minFilter === Xn && (t.minFilter = ft),
            new Os(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      Ya.prototype.isWebGLCubeRenderTarget = !0;
      const Rn = new gn(),
        rr = new b();
      class Er {
        constructor(
          e = new Lt(),
          t = new Lt(),
          n = new Lt(),
          i = new Lt(),
          r = new Lt(),
          o = new Lt()
        ) {
          this.planes = [e, t, n, i, r, o];
        }
        set(e, t, n, i, r, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            r = n[1],
            o = n[2],
            a = n[3],
            l = n[4],
            c = n[5],
            h = n[6],
            u = n[7],
            d = n[8],
            f = n[9],
            m = n[10],
            x = n[11],
            v = n[12],
            p = n[13],
            g = n[14],
            S = n[15];
          return (
            t[0].setComponents(a - i, u - l, x - d, S - v).normalize(),
            t[1].setComponents(a + i, u + l, x + d, S + v).normalize(),
            t[2].setComponents(a + r, u + c, x + f, S + p).normalize(),
            t[3].setComponents(a - r, u - c, x - f, S - p).normalize(),
            t[4].setComponents(a - o, u - h, x - m, S - g).normalize(),
            t[5].setComponents(a + o, u + h, x + m, S + g).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            t.boundingSphere === null && t.computeBoundingSphere(),
            Rn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Rn)
          );
        }
        intersectsSprite(e) {
          return (
            Rn.center.set(0, 0, 0),
            (Rn.radius = 0.7071067811865476),
            Rn.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Rn)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((rr.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (rr.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (rr.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(rr) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Za() {
        let s = null,
          e = !1,
          t = null,
          n = null;
        function i(r, o) {
          t(r, o), (n = s.requestAnimationFrame(i));
        }
        return {
          start: function () {
            e !== !0 &&
              t !== null &&
              ((n = s.requestAnimationFrame(i)), (e = !0));
          },
          stop: function () {
            s.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (r) {
            t = r;
          },
          setContext: function (r) {
            s = r;
          },
        };
      }
      function ru(s, e) {
        const t = e.isWebGL2,
          n = new WeakMap();
        function i(c, h) {
          const u = c.array,
            d = c.usage,
            f = s.createBuffer();
          s.bindBuffer(h, f), s.bufferData(h, u, d), c.onUploadCallback();
          let m = 5126;
          return (
            u instanceof Float32Array
              ? (m = 5126)
              : u instanceof Float64Array
              ? console.warn(
                  "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                )
              : u instanceof Uint16Array
              ? c.isFloat16BufferAttribute
                ? t
                  ? (m = 5131)
                  : console.warn(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    )
                : (m = 5123)
              : u instanceof Int16Array
              ? (m = 5122)
              : u instanceof Uint32Array
              ? (m = 5125)
              : u instanceof Int32Array
              ? (m = 5124)
              : u instanceof Int8Array
              ? (m = 5120)
              : (u instanceof Uint8Array || u instanceof Uint8ClampedArray) &&
                (m = 5121),
            {
              buffer: f,
              type: m,
              bytesPerElement: u.BYTES_PER_ELEMENT,
              version: c.version,
            }
          );
        }
        function r(c, h, u) {
          const d = h.array,
            f = h.updateRange;
          s.bindBuffer(u, c),
            f.count === -1
              ? s.bufferSubData(u, 0, d)
              : (t
                  ? s.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d,
                      f.offset,
                      f.count
                    )
                  : s.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d.subarray(f.offset, f.offset + f.count)
                    ),
                (f.count = -1));
        }
        function o(c) {
          return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
        }
        function a(c) {
          c.isInterleavedBufferAttribute && (c = c.data);
          const h = n.get(c);
          h && (s.deleteBuffer(h.buffer), n.delete(c));
        }
        function l(c, h) {
          if (c.isGLBufferAttribute) {
            const d = n.get(c);
            (!d || d.version < c.version) &&
              n.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version,
              });
            return;
          }
          c.isInterleavedBufferAttribute && (c = c.data);
          const u = n.get(c);
          u === void 0
            ? n.set(c, i(c, h))
            : u.version < c.version &&
              (r(u.buffer, c, h), (u.version = c.version));
        }
        return { get: o, remove: a, update: l };
      }
      class su extends ze {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            o = t / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            h = l + 1,
            u = e / a,
            d = t / l,
            f = [],
            m = [],
            x = [],
            v = [];
          for (let p = 0; p < h; p++) {
            const g = p * d - o;
            for (let S = 0; S < c; S++) {
              const L = S * u - r;
              m.push(L, -g, 0),
                x.push(0, 0, 1),
                v.push(S / a),
                v.push(1 - p / l);
            }
          }
          for (let p = 0; p < l; p++)
            for (let g = 0; g < a; g++) {
              const S = g + c * p,
                L = g + c * (p + 1),
                E = g + 1 + c * (p + 1),
                _ = g + 1 + c * p;
              f.push(S, L, _), f.push(L, E, _);
            }
          this.setIndex(f),
            this.setAttribute("position", new Je(m, 3)),
            this.setAttribute("normal", new Je(x, 3)),
            this.setAttribute("uv", new Je(v, 2));
        }
      }
      var ou = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
        au = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        lu = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,
        cu = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,
        hu = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        uu = "vec3 transformed = vec3( position );",
        du = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        fu = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,
        pu = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        mu = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
        gu = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        xu = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        vu = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        _u = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        yu = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        Mu = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
        wu = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
        bu = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
        Su = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        Tu = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Eu = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        Au = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
        Lu = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        Ru = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        Cu = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        Pu = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
        Iu = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        Du = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        Nu = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        Fu = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        Bu = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        Ou = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,
        zu = `#ifdef USE_FOG
	varying float fogDepth;
#endif`,
        Uu = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        Hu = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        Gu = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
        ku = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,
        Vu = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        Wu = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
        qu = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,
        Xu = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,
        ju = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        Yu = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
        Zu = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        Ju = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
        Ku = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,
        Qu = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        $u = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        ed = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,
        td = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
        nd = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        id = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        rd = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
        sd = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
        od = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
        ad = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        ld = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        cd = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        hd = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        ud = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        dd = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,
        fd = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
        pd = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,
        md = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
        gd = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        xd = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
        vd = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
        _d = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
        yd = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
        Md = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
        wd = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        bd = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        Sd = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        Td = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        Ed = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        Ad = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        Ld = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
        Rd = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        Cd = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
        Pd = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        Id = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        Dd = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
        Nd = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        Fd = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        Bd = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        Od = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        zd = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        Ud = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        Hd = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		totalTransmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSNMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	vec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );
	vec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );
	vec3 f90 = vec3( 1.0 );
	vec3 f_transmission = totalTransmission * getIBLVolumeRefraction(
		normal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance);
	diffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );
#endif`,
        Gd = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec4 vWorldPosition;
	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));
		return normalize(refractionVector) * thickness * modelScale;
	}
	float applyIorToRoughness(float roughness, float ior) {
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}
	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}
	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;
		}
	}
	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);
		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);
		float NdotV = saturate(dot(n, viewDir));
		vec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);
		vec3 specularColor = f0 * brdf.x + f90 * brdf.y;
		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif`,
        kd = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
        Vd = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
        Wd = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
        qd = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
        Xd = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
        jd = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
        Yd = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
        Zd = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        Jd = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        Kd = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        Qd = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        $d = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
        ef = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        tf = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        nf = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        rf = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        sf = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        of = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        af = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        lf = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        cf = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        hf = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        uf = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        df = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        ff = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        pf = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        mf = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        gf = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        xf = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        vf = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform vec3 attenuationColor;
	uniform float attenuationDistance;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef USE_TRANSMISSION
		float totalTransmission = transmission;
		float thicknessFactor = thickness;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	vec3 rawDiffuseColor = diffuseColor.rgb;
	#include <transmission_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        _f = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#ifdef USE_TRANSMISSION
	varying vec4 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition;
#endif
}`,
        yf = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
        Mf = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        wf = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        bf = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        Sf = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Tf = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Ef = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        Af = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
      const be = {
          alphamap_fragment: ou,
          alphamap_pars_fragment: au,
          alphatest_fragment: lu,
          aomap_fragment: cu,
          aomap_pars_fragment: hu,
          begin_vertex: uu,
          beginnormal_vertex: du,
          bsdfs: fu,
          bumpmap_pars_fragment: pu,
          clipping_planes_fragment: mu,
          clipping_planes_pars_fragment: gu,
          clipping_planes_pars_vertex: xu,
          clipping_planes_vertex: vu,
          color_fragment: _u,
          color_pars_fragment: yu,
          color_pars_vertex: Mu,
          color_vertex: wu,
          common: bu,
          cube_uv_reflection_fragment: Su,
          defaultnormal_vertex: Tu,
          displacementmap_pars_vertex: Eu,
          displacementmap_vertex: Au,
          emissivemap_fragment: Lu,
          emissivemap_pars_fragment: Ru,
          encodings_fragment: Cu,
          encodings_pars_fragment: Pu,
          envmap_fragment: Iu,
          envmap_common_pars_fragment: Du,
          envmap_pars_fragment: Nu,
          envmap_pars_vertex: Fu,
          envmap_physical_pars_fragment: Xu,
          envmap_vertex: Bu,
          fog_vertex: Ou,
          fog_pars_vertex: zu,
          fog_fragment: Uu,
          fog_pars_fragment: Hu,
          gradientmap_pars_fragment: Gu,
          lightmap_fragment: ku,
          lightmap_pars_fragment: Vu,
          lights_lambert_vertex: Wu,
          lights_pars_begin: qu,
          lights_toon_fragment: ju,
          lights_toon_pars_fragment: Yu,
          lights_phong_fragment: Zu,
          lights_phong_pars_fragment: Ju,
          lights_physical_fragment: Ku,
          lights_physical_pars_fragment: Qu,
          lights_fragment_begin: $u,
          lights_fragment_maps: ed,
          lights_fragment_end: td,
          logdepthbuf_fragment: nd,
          logdepthbuf_pars_fragment: id,
          logdepthbuf_pars_vertex: rd,
          logdepthbuf_vertex: sd,
          map_fragment: od,
          map_pars_fragment: ad,
          map_particle_fragment: ld,
          map_particle_pars_fragment: cd,
          metalnessmap_fragment: hd,
          metalnessmap_pars_fragment: ud,
          morphnormal_vertex: dd,
          morphtarget_pars_vertex: fd,
          morphtarget_vertex: pd,
          normal_fragment_begin: md,
          normal_fragment_maps: gd,
          normalmap_pars_fragment: xd,
          clearcoat_normal_fragment_begin: vd,
          clearcoat_normal_fragment_maps: _d,
          clearcoat_pars_fragment: yd,
          packing: Md,
          premultiplied_alpha_fragment: wd,
          project_vertex: bd,
          dithering_fragment: Sd,
          dithering_pars_fragment: Td,
          roughnessmap_fragment: Ed,
          roughnessmap_pars_fragment: Ad,
          shadowmap_pars_fragment: Ld,
          shadowmap_pars_vertex: Rd,
          shadowmap_vertex: Cd,
          shadowmask_pars_fragment: Pd,
          skinbase_vertex: Id,
          skinning_pars_vertex: Dd,
          skinning_vertex: Nd,
          skinnormal_vertex: Fd,
          specularmap_fragment: Bd,
          specularmap_pars_fragment: Od,
          tonemapping_fragment: zd,
          tonemapping_pars_fragment: Ud,
          transmission_fragment: Hd,
          transmission_pars_fragment: Gd,
          uv_pars_fragment: kd,
          uv_pars_vertex: Vd,
          uv_vertex: Wd,
          uv2_pars_fragment: qd,
          uv2_pars_vertex: Xd,
          uv2_vertex: jd,
          worldpos_vertex: Yd,
          background_frag: Zd,
          background_vert: Jd,
          cube_frag: Kd,
          cube_vert: Qd,
          depth_frag: $d,
          depth_vert: ef,
          distanceRGBA_frag: tf,
          distanceRGBA_vert: nf,
          equirect_frag: rf,
          equirect_vert: sf,
          linedashed_frag: of,
          linedashed_vert: af,
          meshbasic_frag: lf,
          meshbasic_vert: cf,
          meshlambert_frag: hf,
          meshlambert_vert: uf,
          meshmatcap_frag: df,
          meshmatcap_vert: ff,
          meshtoon_frag: pf,
          meshtoon_vert: mf,
          meshphong_frag: gf,
          meshphong_vert: xf,
          meshphysical_frag: vf,
          meshphysical_vert: _f,
          normal_frag: yf,
          normal_vert: Mf,
          points_frag: wf,
          points_vert: bf,
          shadow_frag: Sf,
          shadow_vert: Tf,
          sprite_frag: Ef,
          sprite_vert: Af,
        },
        $ = {
          common: {
            diffuse: { value: new ae(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new et() },
            uv2Transform: { value: new et() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new Y(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new ae(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new ae(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new et() },
          },
          sprite: {
            diffuse: { value: new ae(16777215) },
            opacity: { value: 1 },
            center: { value: new Y(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new et() },
          },
        },
        Rt = {
          basic: {
            uniforms: st([
              $.common,
              $.specularmap,
              $.envmap,
              $.aomap,
              $.lightmap,
              $.fog,
            ]),
            vertexShader: be.meshbasic_vert,
            fragmentShader: be.meshbasic_frag,
          },
          lambert: {
            uniforms: st([
              $.common,
              $.specularmap,
              $.envmap,
              $.aomap,
              $.lightmap,
              $.emissivemap,
              $.fog,
              $.lights,
              { emissive: { value: new ae(0) } },
            ]),
            vertexShader: be.meshlambert_vert,
            fragmentShader: be.meshlambert_frag,
          },
          phong: {
            uniforms: st([
              $.common,
              $.specularmap,
              $.envmap,
              $.aomap,
              $.lightmap,
              $.emissivemap,
              $.bumpmap,
              $.normalmap,
              $.displacementmap,
              $.fog,
              $.lights,
              {
                emissive: { value: new ae(0) },
                specular: { value: new ae(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: be.meshphong_vert,
            fragmentShader: be.meshphong_frag,
          },
          standard: {
            uniforms: st([
              $.common,
              $.envmap,
              $.aomap,
              $.lightmap,
              $.emissivemap,
              $.bumpmap,
              $.normalmap,
              $.displacementmap,
              $.roughnessmap,
              $.metalnessmap,
              $.fog,
              $.lights,
              {
                emissive: { value: new ae(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: be.meshphysical_vert,
            fragmentShader: be.meshphysical_frag,
          },
          toon: {
            uniforms: st([
              $.common,
              $.aomap,
              $.lightmap,
              $.emissivemap,
              $.bumpmap,
              $.normalmap,
              $.displacementmap,
              $.gradientmap,
              $.fog,
              $.lights,
              { emissive: { value: new ae(0) } },
            ]),
            vertexShader: be.meshtoon_vert,
            fragmentShader: be.meshtoon_frag,
          },
          matcap: {
            uniforms: st([
              $.common,
              $.bumpmap,
              $.normalmap,
              $.displacementmap,
              $.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: be.meshmatcap_vert,
            fragmentShader: be.meshmatcap_frag,
          },
          points: {
            uniforms: st([$.points, $.fog]),
            vertexShader: be.points_vert,
            fragmentShader: be.points_frag,
          },
          dashed: {
            uniforms: st([
              $.common,
              $.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: be.linedashed_vert,
            fragmentShader: be.linedashed_frag,
          },
          depth: {
            uniforms: st([$.common, $.displacementmap]),
            vertexShader: be.depth_vert,
            fragmentShader: be.depth_frag,
          },
          normal: {
            uniforms: st([
              $.common,
              $.bumpmap,
              $.normalmap,
              $.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: be.normal_vert,
            fragmentShader: be.normal_frag,
          },
          sprite: {
            uniforms: st([$.sprite, $.fog]),
            vertexShader: be.sprite_vert,
            fragmentShader: be.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new et() },
              t2D: { value: null },
            },
            vertexShader: be.background_vert,
            fragmentShader: be.background_frag,
          },
          cube: {
            uniforms: st([$.envmap, { opacity: { value: 1 } }]),
            vertexShader: be.cube_vert,
            fragmentShader: be.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: be.equirect_vert,
            fragmentShader: be.equirect_frag,
          },
          distanceRGBA: {
            uniforms: st([
              $.common,
              $.displacementmap,
              {
                referencePosition: { value: new b() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: be.distanceRGBA_vert,
            fragmentShader: be.distanceRGBA_frag,
          },
          shadow: {
            uniforms: st([
              $.lights,
              $.fog,
              { color: { value: new ae(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: be.shadow_vert,
            fragmentShader: be.shadow_frag,
          },
        };
      Rt.physical = {
        uniforms: st([
          Rt.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Y(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new ae(0) },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new Y() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new ae(0) },
          },
        ]),
        vertexShader: be.meshphysical_vert,
        fragmentShader: be.meshphysical_frag,
      };
      function Lf(s, e, t, n, i) {
        const r = new ae(0);
        let o = 0,
          a,
          l,
          c = null,
          h = 0,
          u = null;
        function d(m, x) {
          let v = !1,
            p = x.isScene === !0 ? x.background : null;
          p && p.isTexture && (p = e.get(p));
          const g = s.xr,
            S = g.getSession && g.getSession();
          S && S.environmentBlendMode === "additive" && (p = null),
            p === null ? f(r, o) : p && p.isColor && (f(p, 1), (v = !0)),
            (s.autoClear || v) &&
              s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
            p && (p.isCubeTexture || p.mapping === Cs)
              ? (l === void 0 &&
                  ((l = new _t(
                    new Fs(1, 1, 1),
                    new fn({
                      name: "BackgroundCubeMaterial",
                      uniforms: kn(Rt.cube.uniforms),
                      vertexShader: Rt.cube.vertexShader,
                      fragmentShader: Rt.cube.fragmentShader,
                      side: Ze,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  l.geometry.deleteAttribute("uv"),
                  (l.onBeforeRender = function (L, E, _) {
                    this.matrixWorld.copyPosition(_.matrixWorld);
                  }),
                  Object.defineProperty(l.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(l)),
                (l.material.uniforms.envMap.value = p),
                (l.material.uniforms.flipEnvMap.value =
                  p.isCubeTexture && p._needsFlipEnvMap ? -1 : 1),
                (c !== p || h !== p.version || u !== s.toneMapping) &&
                  ((l.material.needsUpdate = !0),
                  (c = p),
                  (h = p.version),
                  (u = s.toneMapping)),
                m.unshift(l, l.geometry, l.material, 0, 0, null))
              : p &&
                p.isTexture &&
                (a === void 0 &&
                  ((a = new _t(
                    new su(2, 2),
                    new fn({
                      name: "BackgroundMaterial",
                      uniforms: kn(Rt.background.uniforms),
                      vertexShader: Rt.background.vertexShader,
                      fragmentShader: Rt.background.fragmentShader,
                      side: Ti,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(a)),
                (a.material.uniforms.t2D.value = p),
                p.matrixAutoUpdate === !0 && p.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(p.matrix),
                (c !== p || h !== p.version || u !== s.toneMapping) &&
                  ((a.material.needsUpdate = !0),
                  (c = p),
                  (h = p.version),
                  (u = s.toneMapping)),
                m.unshift(a, a.geometry, a.material, 0, 0, null));
        }
        function f(m, x) {
          t.buffers.color.setClear(m.r, m.g, m.b, x, i);
        }
        return {
          getClearColor: function () {
            return r;
          },
          setClearColor: function (m, x = 1) {
            r.set(m), (o = x), f(r, o);
          },
          getClearAlpha: function () {
            return o;
          },
          setClearAlpha: function (m) {
            (o = m), f(r, o);
          },
          render: d,
        };
      }
      function Rf(s, e, t, n) {
        const i = s.getParameter(34921),
          r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = n.isWebGL2 || r !== null,
          a = {},
          l = x(null);
        let c = l;
        function h(T, I, P, R, G) {
          let ee = !1;
          if (o) {
            const Z = m(R, P, I);
            c !== Z && ((c = Z), d(c.object)), (ee = v(R, G)), ee && p(R, G);
          } else {
            const Z = I.wireframe === !0;
            (c.geometry !== R.id || c.program !== P.id || c.wireframe !== Z) &&
              ((c.geometry = R.id),
              (c.program = P.id),
              (c.wireframe = Z),
              (ee = !0));
          }
          T.isInstancedMesh === !0 && (ee = !0),
            G !== null && t.update(G, 34963),
            ee &&
              (C(T, I, P, R),
              G !== null && s.bindBuffer(34963, t.get(G).buffer));
        }
        function u() {
          return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
        }
        function d(T) {
          return n.isWebGL2 ? s.bindVertexArray(T) : r.bindVertexArrayOES(T);
        }
        function f(T) {
          return n.isWebGL2
            ? s.deleteVertexArray(T)
            : r.deleteVertexArrayOES(T);
        }
        function m(T, I, P) {
          const R = P.wireframe === !0;
          let G = a[T.id];
          G === void 0 && ((G = {}), (a[T.id] = G));
          let ee = G[I.id];
          ee === void 0 && ((ee = {}), (G[I.id] = ee));
          let Z = ee[R];
          return Z === void 0 && ((Z = x(u())), (ee[R] = Z)), Z;
        }
        function x(T) {
          const I = [],
            P = [],
            R = [];
          for (let G = 0; G < i; G++) (I[G] = 0), (P[G] = 0), (R[G] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: I,
            enabledAttributes: P,
            attributeDivisors: R,
            object: T,
            attributes: {},
            index: null,
          };
        }
        function v(T, I) {
          const P = c.attributes,
            R = T.attributes;
          let G = 0;
          for (const ee in R) {
            const Z = P[ee],
              se = R[ee];
            if (Z === void 0 || Z.attribute !== se || Z.data !== se.data)
              return !0;
            G++;
          }
          return c.attributesNum !== G || c.index !== I;
        }
        function p(T, I) {
          const P = {},
            R = T.attributes;
          let G = 0;
          for (const ee in R) {
            const Z = R[ee],
              se = {};
            (se.attribute = Z), Z.data && (se.data = Z.data), (P[ee] = se), G++;
          }
          (c.attributes = P), (c.attributesNum = G), (c.index = I);
        }
        function g() {
          const T = c.newAttributes;
          for (let I = 0, P = T.length; I < P; I++) T[I] = 0;
        }
        function S(T) {
          L(T, 0);
        }
        function L(T, I) {
          const P = c.newAttributes,
            R = c.enabledAttributes,
            G = c.attributeDivisors;
          (P[T] = 1),
            R[T] === 0 && (s.enableVertexAttribArray(T), (R[T] = 1)),
            G[T] !== I &&
              ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](T, I),
              (G[T] = I));
        }
        function E() {
          const T = c.newAttributes,
            I = c.enabledAttributes;
          for (let P = 0, R = I.length; P < R; P++)
            I[P] !== T[P] && (s.disableVertexAttribArray(P), (I[P] = 0));
        }
        function _(T, I, P, R, G, ee) {
          n.isWebGL2 === !0 && (P === 5124 || P === 5125)
            ? s.vertexAttribIPointer(T, I, P, G, ee)
            : s.vertexAttribPointer(T, I, P, R, G, ee);
        }
        function C(T, I, P, R) {
          if (
            n.isWebGL2 === !1 &&
            (T.isInstancedMesh || R.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
          )
            return;
          g();
          const G = R.attributes,
            ee = P.getAttributes(),
            Z = I.defaultAttributeValues;
          for (const se in ee) {
            const ie = ee[se];
            if (ie >= 0) {
              const ye = G[se];
              if (ye !== void 0) {
                const ve = ye.normalized,
                  Ce = ye.itemSize,
                  Ee = t.get(ye);
                if (Ee === void 0) continue;
                const H = Ee.buffer,
                  Ge = Ee.type,
                  Ae = Ee.bytesPerElement;
                if (ye.isInterleavedBufferAttribute) {
                  const _e = ye.data,
                    fe = _e.stride,
                    Se = ye.offset;
                  _e && _e.isInstancedInterleavedBuffer
                    ? (L(ie, _e.meshPerAttribute),
                      R._maxInstanceCount === void 0 &&
                        (R._maxInstanceCount = _e.meshPerAttribute * _e.count))
                    : S(ie),
                    s.bindBuffer(34962, H),
                    _(ie, Ce, Ge, ve, fe * Ae, Se * Ae);
                } else
                  ye.isInstancedBufferAttribute
                    ? (L(ie, ye.meshPerAttribute),
                      R._maxInstanceCount === void 0 &&
                        (R._maxInstanceCount = ye.meshPerAttribute * ye.count))
                    : S(ie),
                    s.bindBuffer(34962, H),
                    _(ie, Ce, Ge, ve, 0, 0);
              } else if (se === "instanceMatrix") {
                const ve = t.get(T.instanceMatrix);
                if (ve === void 0) continue;
                const Ce = ve.buffer,
                  Ee = ve.type;
                L(ie + 0, 1),
                  L(ie + 1, 1),
                  L(ie + 2, 1),
                  L(ie + 3, 1),
                  s.bindBuffer(34962, Ce),
                  s.vertexAttribPointer(ie + 0, 4, Ee, !1, 64, 0),
                  s.vertexAttribPointer(ie + 1, 4, Ee, !1, 64, 16),
                  s.vertexAttribPointer(ie + 2, 4, Ee, !1, 64, 32),
                  s.vertexAttribPointer(ie + 3, 4, Ee, !1, 64, 48);
              } else if (se === "instanceColor") {
                const ve = t.get(T.instanceColor);
                if (ve === void 0) continue;
                const Ce = ve.buffer,
                  Ee = ve.type;
                L(ie, 1),
                  s.bindBuffer(34962, Ce),
                  s.vertexAttribPointer(ie, 3, Ee, !1, 12, 0);
              } else if (Z !== void 0) {
                const ve = Z[se];
                if (ve !== void 0)
                  switch (ve.length) {
                    case 2:
                      s.vertexAttrib2fv(ie, ve);
                      break;
                    case 3:
                      s.vertexAttrib3fv(ie, ve);
                      break;
                    case 4:
                      s.vertexAttrib4fv(ie, ve);
                      break;
                    default:
                      s.vertexAttrib1fv(ie, ve);
                  }
              }
            }
          }
          E();
        }
        function F() {
          W();
          for (const T in a) {
            const I = a[T];
            for (const P in I) {
              const R = I[P];
              for (const G in R) f(R[G].object), delete R[G];
              delete I[P];
            }
            delete a[T];
          }
        }
        function O(T) {
          if (a[T.id] === void 0) return;
          const I = a[T.id];
          for (const P in I) {
            const R = I[P];
            for (const G in R) f(R[G].object), delete R[G];
            delete I[P];
          }
          delete a[T.id];
        }
        function V(T) {
          for (const I in a) {
            const P = a[I];
            if (P[T.id] === void 0) continue;
            const R = P[T.id];
            for (const G in R) f(R[G].object), delete R[G];
            delete P[T.id];
          }
        }
        function W() {
          z(), c !== l && ((c = l), d(c.object));
        }
        function z() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: h,
          reset: W,
          resetDefaultState: z,
          dispose: F,
          releaseStatesOfGeometry: O,
          releaseStatesOfProgram: V,
          initAttributes: g,
          enableAttribute: S,
          disableUnusedAttributes: E,
        };
      }
      function Cf(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(c) {
          r = c;
        }
        function a(c, h) {
          s.drawArrays(r, c, h), t.update(h, r, 1);
        }
        function l(c, h, u) {
          if (u === 0) return;
          let d, f;
          if (i) (d = s), (f = "drawArraysInstanced");
          else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
          ) {
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          d[f](r, c, h, u), t.update(h, r, u);
        }
        (this.setMode = o), (this.render = a), (this.renderInstances = l);
      }
      function Pf(s, e, t) {
        let n;
        function i() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            n = s.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function r(C) {
          if (C === "highp") {
            if (
              s.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              s.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            C = "mediump";
          }
          return C === "mediump" &&
            s.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            s.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          (typeof WebGL2RenderingContext != "undefined" &&
            s instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext != "undefined" &&
            s instanceof WebGL2ComputeRenderingContext);
        let a = t.precision !== void 0 ? t.precision : "highp";
        const l = r(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
          ),
          (a = l));
        const c = o || e.has("WEBGL_draw_buffers"),
          h = t.logarithmicDepthBuffer === !0,
          u = s.getParameter(34930),
          d = s.getParameter(35660),
          f = s.getParameter(3379),
          m = s.getParameter(34076),
          x = s.getParameter(34921),
          v = s.getParameter(36347),
          p = s.getParameter(36348),
          g = s.getParameter(36349),
          S = d > 0,
          L = o || e.has("OES_texture_float"),
          E = S && L,
          _ = o ? s.getParameter(36183) : 0;
        return {
          isWebGL2: o,
          drawBuffers: c,
          getMaxAnisotropy: i,
          getMaxPrecision: r,
          precision: a,
          logarithmicDepthBuffer: h,
          maxTextures: u,
          maxVertexTextures: d,
          maxTextureSize: f,
          maxCubemapSize: m,
          maxAttributes: x,
          maxVertexUniforms: v,
          maxVaryings: p,
          maxFragmentUniforms: g,
          vertexTextures: S,
          floatFragmentTextures: L,
          floatVertexTextures: E,
          maxSamples: _,
        };
      }
      function If(s) {
        const e = this;
        let t = null,
          n = 0,
          i = !1,
          r = !1;
        const o = new Lt(),
          a = new et(),
          l = { value: null, needsUpdate: !1 };
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (u, d, f) {
            const m = u.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = h(u, f, 0)), (n = u.length), m;
          }),
          (this.beginShadows = function () {
            (r = !0), h(null);
          }),
          (this.endShadows = function () {
            (r = !1), c();
          }),
          (this.setState = function (u, d, f) {
            const m = u.clippingPlanes,
              x = u.clipIntersection,
              v = u.clipShadows,
              p = s.get(u);
            if (!i || m === null || m.length === 0 || (r && !v))
              r ? h(null) : c();
            else {
              const g = r ? 0 : n,
                S = g * 4;
              let L = p.clippingState || null;
              (l.value = L), (L = h(m, d, S, f));
              for (let E = 0; E !== S; ++E) L[E] = t[E];
              (p.clippingState = L),
                (this.numIntersection = x ? this.numPlanes : 0),
                (this.numPlanes += g);
            }
          });
        function c() {
          l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function h(u, d, f, m) {
          const x = u !== null ? u.length : 0;
          let v = null;
          if (x !== 0) {
            if (((v = l.value), m !== !0 || v === null)) {
              const p = f + x * 4,
                g = d.matrixWorldInverse;
              a.getNormalMatrix(g),
                (v === null || v.length < p) && (v = new Float32Array(p));
              for (let S = 0, L = f; S !== x; ++S, L += 4)
                o.copy(u[S]).applyMatrix4(g, a),
                  o.normal.toArray(v, L),
                  (v[L + 3] = o.constant);
            }
            (l.value = v), (l.needsUpdate = !0);
          }
          return (e.numPlanes = x), (e.numIntersection = 0), v;
        }
      }
      function Df(s) {
        let e = new WeakMap();
        function t(o, a) {
          return a === mo ? (o.mapping = Ls) : a === go && (o.mapping = Rs), o;
        }
        function n(o) {
          if (o && o.isTexture) {
            const a = o.mapping;
            if (a === mo || a === go)
              if (e.has(o)) {
                const l = e.get(o).texture;
                return t(l, o.mapping);
              } else {
                const l = o.image;
                if (l && l.height > 0) {
                  const c = s.getRenderTarget(),
                    h = new Ya(l.height / 2);
                  return (
                    h.fromEquirectangularTexture(s, o),
                    e.set(o, h),
                    s.setRenderTarget(c),
                    o.addEventListener("dispose", i),
                    t(h.texture, o.mapping)
                  );
                } else return null;
              }
          }
          return o;
        }
        function i(o) {
          const a = o.target;
          a.removeEventListener("dispose", i);
          const l = e.get(a);
          l !== void 0 && (e.delete(a), l.dispose());
        }
        function r() {
          e = new WeakMap();
        }
        return { get: n, dispose: r };
      }
      function Nf(s) {
        const e = {};
        function t(n) {
          if (e[n] !== void 0) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                s.getExtension("WEBGL_depth_texture") ||
                s.getExtension("MOZ_WEBGL_depth_texture") ||
                s.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                s.getExtension("EXT_texture_filter_anisotropic") ||
                s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                s.getExtension("WEBGL_compressed_texture_s3tc") ||
                s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                s.getExtension("WEBGL_compressed_texture_pvrtc") ||
                s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = s.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (n) {
            return t(n) !== null;
          },
          init: function (n) {
            n.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float");
          },
          get: function (n) {
            const i = t(n);
            return (
              i === null &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              i
            );
          },
        };
      }
      function Ff(s, e, t, n) {
        const i = {},
          r = new WeakMap();
        function o(u) {
          const d = u.target;
          d.index !== null && e.remove(d.index);
          for (const m in d.attributes) e.remove(d.attributes[m]);
          d.removeEventListener("dispose", o), delete i[d.id];
          const f = r.get(d);
          f && (e.remove(f), r.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
        }
        function a(u, d) {
          return (
            i[d.id] === !0 ||
              (d.addEventListener("dispose", o),
              (i[d.id] = !0),
              t.memory.geometries++),
            d
          );
        }
        function l(u) {
          const d = u.attributes;
          for (const m in d) e.update(d[m], 34962);
          const f = u.morphAttributes;
          for (const m in f) {
            const x = f[m];
            for (let v = 0, p = x.length; v < p; v++) e.update(x[v], 34962);
          }
        }
        function c(u) {
          const d = [],
            f = u.index,
            m = u.attributes.position;
          let x = 0;
          if (f !== null) {
            const g = f.array;
            x = f.version;
            for (let S = 0, L = g.length; S < L; S += 3) {
              const E = g[S + 0],
                _ = g[S + 1],
                C = g[S + 2];
              d.push(E, _, _, C, C, E);
            }
          } else {
            const g = m.array;
            x = m.version;
            for (let S = 0, L = g.length / 3 - 1; S < L; S += 3) {
              const E = S + 0,
                _ = S + 1,
                C = S + 2;
              d.push(E, _, _, C, C, E);
            }
          }
          const v = new (ja(d) > 65535 ? Xa : qa)(d, 1);
          v.version = x;
          const p = r.get(u);
          p && e.remove(p), r.set(u, v);
        }
        function h(u) {
          const d = r.get(u);
          if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u);
          } else c(u);
          return r.get(u);
        }
        return { get: a, update: l, getWireframeAttribute: h };
      }
      function Bf(s, e, t, n) {
        const i = n.isWebGL2;
        let r;
        function o(d) {
          r = d;
        }
        let a, l;
        function c(d) {
          (a = d.type), (l = d.bytesPerElement);
        }
        function h(d, f) {
          s.drawElements(r, f, a, d * l), t.update(f, r, 1);
        }
        function u(d, f, m) {
          if (m === 0) return;
          let x, v;
          if (i) (x = s), (v = "drawElementsInstanced");
          else if (
            ((x = e.get("ANGLE_instanced_arrays")),
            (v = "drawElementsInstancedANGLE"),
            x === null)
          ) {
            console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          x[v](r, f, a, d * l, m), t.update(f, r, m);
        }
        (this.setMode = o),
          (this.setIndex = c),
          (this.render = h),
          (this.renderInstances = u);
      }
      function Of(s) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(r, o, a) {
          switch ((t.calls++, o)) {
            case 4:
              t.triangles += a * (r / 3);
              break;
            case 1:
              t.lines += a * (r / 2);
              break;
            case 3:
              t.lines += a * (r - 1);
              break;
            case 2:
              t.lines += a * r;
              break;
            case 0:
              t.points += a * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", o);
              break;
          }
        }
        function i() {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: !0,
          reset: i,
          update: n,
        };
      }
      function zf(s, e) {
        return s[0] - e[0];
      }
      function Uf(s, e) {
        return Math.abs(e[1]) - Math.abs(s[1]);
      }
      function Hf(s) {
        const e = {},
          t = new Float32Array(8),
          n = [];
        for (let r = 0; r < 8; r++) n[r] = [r, 0];
        function i(r, o, a, l) {
          const c = r.morphTargetInfluences,
            h = c === void 0 ? 0 : c.length;
          let u = e[o.id];
          if (u === void 0) {
            u = [];
            for (let v = 0; v < h; v++) u[v] = [v, 0];
            e[o.id] = u;
          }
          for (let v = 0; v < h; v++) {
            const p = u[v];
            (p[0] = v), (p[1] = c[v]);
          }
          u.sort(Uf);
          for (let v = 0; v < 8; v++)
            v < h && u[v][1]
              ? ((n[v][0] = u[v][0]), (n[v][1] = u[v][1]))
              : ((n[v][0] = Number.MAX_SAFE_INTEGER), (n[v][1] = 0));
          n.sort(zf);
          const d = a.morphTargets && o.morphAttributes.position,
            f = a.morphNormals && o.morphAttributes.normal;
          let m = 0;
          for (let v = 0; v < 8; v++) {
            const p = n[v],
              g = p[0],
              S = p[1];
            g !== Number.MAX_SAFE_INTEGER && S
              ? (d &&
                  o.getAttribute("morphTarget" + v) !== d[g] &&
                  o.setAttribute("morphTarget" + v, d[g]),
                f &&
                  o.getAttribute("morphNormal" + v) !== f[g] &&
                  o.setAttribute("morphNormal" + v, f[g]),
                (t[v] = S),
                (m += S))
              : (d &&
                  o.hasAttribute("morphTarget" + v) === !0 &&
                  o.deleteAttribute("morphTarget" + v),
                f &&
                  o.hasAttribute("morphNormal" + v) === !0 &&
                  o.deleteAttribute("morphNormal" + v),
                (t[v] = 0));
          }
          const x = o.morphTargetsRelative ? 1 : 1 - m;
          l.getUniforms().setValue(s, "morphTargetBaseInfluence", x),
            l.getUniforms().setValue(s, "morphTargetInfluences", t);
        }
        return { update: i };
      }
      function Gf(s, e, t, n) {
        let i = new WeakMap();
        function r(l) {
          const c = n.render.frame,
            h = l.geometry,
            u = e.get(l, h);
          return (
            i.get(u) !== c && (e.update(u), i.set(u, c)),
            l.isInstancedMesh &&
              (l.hasEventListener("dispose", a) === !1 &&
                l.addEventListener("dispose", a),
              t.update(l.instanceMatrix, 34962),
              l.instanceColor !== null && t.update(l.instanceColor, 34962)),
            u
          );
        }
        function o() {
          i = new WeakMap();
        }
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return { update: r, dispose: o };
      }
      class Ja extends tt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = $e),
            (this.minFilter = $e),
            (this.wrapR = dt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      Ja.prototype.isDataTexture2DArray = !0;
      class Ka extends tt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = $e),
            (this.minFilter = $e),
            (this.wrapR = dt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      Ka.prototype.isDataTexture3D = !0;
      const Qa = new tt(),
        kf = new Ja(),
        Vf = new Ka(),
        $a = new Tr(),
        Uo = [],
        Ho = [],
        Go = new Float32Array(16),
        ko = new Float32Array(9),
        Vo = new Float32Array(4);
      function Jn(s, e, t) {
        const n = s[0];
        if (n <= 0 || n > 0) return s;
        const i = e * t;
        let r = Uo[i];
        if (
          (r === void 0 && ((r = new Float32Array(i)), (Uo[i] = r)), e !== 0)
        ) {
          n.toArray(r, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), s[o].toArray(r, a);
        }
        return r;
      }
      function ht(s, e) {
        if (s.length !== e.length) return !1;
        for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
        return !0;
      }
      function ot(s, e) {
        for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
      }
      function el(s, e) {
        let t = Ho[e];
        t === void 0 && ((t = new Int32Array(e)), (Ho[e] = t));
        for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
        return t;
      }
      function Wf(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
      }
      function qf(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y) &&
            (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (ht(t, e)) return;
          s.uniform2fv(this.addr, e), ot(t, e);
        }
      }
      function Xf(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (s.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (s.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (ht(t, e)) return;
          s.uniform3fv(this.addr, e), ot(t, e);
        }
      }
      function jf(s, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (ht(t, e)) return;
          s.uniform4fv(this.addr, e), ot(t, e);
        }
      }
      function Yf(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (ht(t, e)) return;
          s.uniformMatrix2fv(this.addr, !1, e), ot(t, e);
        } else {
          if (ht(t, n)) return;
          Vo.set(n), s.uniformMatrix2fv(this.addr, !1, Vo), ot(t, n);
        }
      }
      function Zf(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (ht(t, e)) return;
          s.uniformMatrix3fv(this.addr, !1, e), ot(t, e);
        } else {
          if (ht(t, n)) return;
          ko.set(n), s.uniformMatrix3fv(this.addr, !1, ko), ot(t, n);
        }
      }
      function Jf(s, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (ht(t, e)) return;
          s.uniformMatrix4fv(this.addr, !1, e), ot(t, e);
        } else {
          if (ht(t, n)) return;
          Go.set(n), s.uniformMatrix4fv(this.addr, !1, Go), ot(t, n);
        }
      }
      function Kf(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
      }
      function Qf(s, e) {
        const t = this.cache;
        ht(t, e) || (s.uniform2iv(this.addr, e), ot(t, e));
      }
      function $f(s, e) {
        const t = this.cache;
        ht(t, e) || (s.uniform3iv(this.addr, e), ot(t, e));
      }
      function ep(s, e) {
        const t = this.cache;
        ht(t, e) || (s.uniform4iv(this.addr, e), ot(t, e));
      }
      function tp(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
      }
      function np(s, e) {
        const t = this.cache;
        ht(t, e) || (s.uniform2uiv(this.addr, e), ot(t, e));
      }
      function ip(s, e) {
        const t = this.cache;
        ht(t, e) || (s.uniform3uiv(this.addr, e), ot(t, e));
      }
      function rp(s, e) {
        const t = this.cache;
        ht(t, e) || (s.uniform4uiv(this.addr, e), ot(t, e));
      }
      function sp(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.safeSetTexture2D(e || Qa, i);
      }
      function op(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture3D(e || Vf, i);
      }
      function ap(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.safeSetTextureCube(e || $a, i);
      }
      function lp(s, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2DArray(e || kf, i);
      }
      function cp(s) {
        switch (s) {
          case 5126:
            return Wf;
          case 35664:
            return qf;
          case 35665:
            return Xf;
          case 35666:
            return jf;
          case 35674:
            return Yf;
          case 35675:
            return Zf;
          case 35676:
            return Jf;
          case 5124:
          case 35670:
            return Kf;
          case 35667:
          case 35671:
            return Qf;
          case 35668:
          case 35672:
            return $f;
          case 35669:
          case 35673:
            return ep;
          case 5125:
            return tp;
          case 36294:
            return np;
          case 36295:
            return ip;
          case 36296:
            return rp;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return sp;
          case 35679:
          case 36299:
          case 36307:
            return op;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return ap;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return lp;
        }
      }
      function hp(s, e) {
        s.uniform1fv(this.addr, e);
      }
      function up(s, e) {
        const t = Jn(e, this.size, 2);
        s.uniform2fv(this.addr, t);
      }
      function dp(s, e) {
        const t = Jn(e, this.size, 3);
        s.uniform3fv(this.addr, t);
      }
      function fp(s, e) {
        const t = Jn(e, this.size, 4);
        s.uniform4fv(this.addr, t);
      }
      function pp(s, e) {
        const t = Jn(e, this.size, 4);
        s.uniformMatrix2fv(this.addr, !1, t);
      }
      function mp(s, e) {
        const t = Jn(e, this.size, 9);
        s.uniformMatrix3fv(this.addr, !1, t);
      }
      function gp(s, e) {
        const t = Jn(e, this.size, 16);
        s.uniformMatrix4fv(this.addr, !1, t);
      }
      function xp(s, e) {
        s.uniform1iv(this.addr, e);
      }
      function vp(s, e) {
        s.uniform2iv(this.addr, e);
      }
      function _p(s, e) {
        s.uniform3iv(this.addr, e);
      }
      function yp(s, e) {
        s.uniform4iv(this.addr, e);
      }
      function Mp(s, e) {
        s.uniform1uiv(this.addr, e);
      }
      function wp(s, e) {
        s.uniform2uiv(this.addr, e);
      }
      function bp(s, e) {
        s.uniform3uiv(this.addr, e);
      }
      function Sp(s, e) {
        s.uniform4uiv(this.addr, e);
      }
      function Tp(s, e, t) {
        const n = e.length,
          i = el(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.safeSetTexture2D(e[r] || Qa, i[r]);
      }
      function Ep(s, e, t) {
        const n = e.length,
          i = el(t, n);
        s.uniform1iv(this.addr, i);
        for (let r = 0; r !== n; ++r) t.safeSetTextureCube(e[r] || $a, i[r]);
      }
      function Ap(s) {
        switch (s) {
          case 5126:
            return hp;
          case 35664:
            return up;
          case 35665:
            return dp;
          case 35666:
            return fp;
          case 35674:
            return pp;
          case 35675:
            return mp;
          case 35676:
            return gp;
          case 5124:
          case 35670:
            return xp;
          case 35667:
          case 35671:
            return vp;
          case 35668:
          case 35672:
            return _p;
          case 35669:
          case 35673:
            return yp;
          case 5125:
            return Mp;
          case 36294:
            return wp;
          case 36295:
            return bp;
          case 36296:
            return Sp;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Tp;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Ep;
        }
      }
      function Lp(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.setValue = cp(e.type));
      }
      function tl(s, e, t) {
        (this.id = s),
          (this.addr = t),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = Ap(e.type));
      }
      tl.prototype.updateCache = function (s) {
        const e = this.cache;
        s instanceof Float32Array &&
          e.length !== s.length &&
          (this.cache = new Float32Array(s.length)),
          ot(e, s);
      };
      function nl(s) {
        (this.id = s), (this.seq = []), (this.map = {});
      }
      nl.prototype.setValue = function (s, e, t) {
        const n = this.seq;
        for (let i = 0, r = n.length; i !== r; ++i) {
          const o = n[i];
          o.setValue(s, e[o.id], t);
        }
      };
      const ss = /(\w+)(\])?(\[|\.)?/g;
      function Wo(s, e) {
        s.seq.push(e), (s.map[e.id] = e);
      }
      function Rp(s, e, t) {
        const n = s.name,
          i = n.length;
        for (ss.lastIndex = 0; ; ) {
          const r = ss.exec(n),
            o = ss.lastIndex;
          let a = r[1];
          const l = r[2] === "]",
            c = r[3];
          if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
            Wo(t, c === void 0 ? new Lp(a, s, e) : new tl(a, s, e));
            break;
          } else {
            let u = t.map[a];
            u === void 0 && ((u = new nl(a)), Wo(t, u)), (t = u);
          }
        }
      }
      function nn(s, e) {
        (this.seq = []), (this.map = {});
        const t = s.getProgramParameter(e, 35718);
        for (let n = 0; n < t; ++n) {
          const i = s.getActiveUniform(e, n),
            r = s.getUniformLocation(e, i.name);
          Rp(i, r, this);
        }
      }
      nn.prototype.setValue = function (s, e, t, n) {
        const i = this.map[e];
        i !== void 0 && i.setValue(s, t, n);
      };
      nn.prototype.setOptional = function (s, e, t) {
        const n = e[t];
        n !== void 0 && this.setValue(s, t, n);
      };
      nn.upload = function (s, e, t, n) {
        for (let i = 0, r = e.length; i !== r; ++i) {
          const o = e[i],
            a = t[o.id];
          a.needsUpdate !== !1 && o.setValue(s, a.value, n);
        }
      };
      nn.seqWithValue = function (s, e) {
        const t = [];
        for (let n = 0, i = s.length; n !== i; ++n) {
          const r = s[n];
          r.id in e && t.push(r);
        }
        return t;
      };
      function qo(s, e, t) {
        const n = s.createShader(e);
        return s.shaderSource(n, t), s.compileShader(n), n;
      }
      let Cp = 0;
      function Pp(s) {
        const e = s.split(`
`);
        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join(`
`);
      }
      function il(s) {
        switch (s) {
          case Oi:
            return ["Linear", "( value )"];
          case wr:
            return ["sRGB", "( value )"];
          case mh:
            return ["RGBE", "( value )"];
          case xh:
            return ["RGBM", "( value, 7.0 )"];
          case vh:
            return ["RGBM", "( value, 16.0 )"];
          case _h:
            return ["RGBD", "( value, 256.0 )"];
          case ph:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case gh:
            return ["LogLuv", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", s),
              ["Linear", "( value )"]
            );
        }
      }
      function Xo(s, e, t) {
        const n = s.getShaderParameter(e, 35713),
          i = s.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const r = s.getShaderSource(e);
        return (
          "THREE.WebGLShader: gl.getShaderInfoLog() " +
          t +
          `
` +
          i +
          Pp(r)
        );
      }
      function ai(s, e) {
        const t = il(e);
        return (
          "vec4 " +
          s +
          "( vec4 value ) { return " +
          t[0] +
          "ToLinear" +
          t[1] +
          "; }"
        );
      }
      function Ip(s, e) {
        const t = il(e);
        return (
          "vec4 " + s + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function Dp(s, e) {
        let t;
        switch (e) {
          case fc:
            t = "Linear";
            break;
          case pc:
            t = "Reinhard";
            break;
          case mc:
            t = "OptimizedCineon";
            break;
          case gc:
            t = "ACESFilmic";
            break;
          case xc:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          s +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function Np(s) {
        return [
          s.extensionDerivatives ||
          s.envMapCubeUV ||
          s.bumpMap ||
          s.tangentSpaceNormalMap ||
          s.clearcoatNormalMap ||
          s.flatShading ||
          s.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
          s.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (s.extensionShaderTextureLOD || s.envMap || s.transmission > 0) &&
          s.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ].filter(gi).join(`
`);
      }
      function Fp(s) {
        const e = [];
        for (const t in s) {
          const n = s[t];
          n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
      }
      function Bp(s, e) {
        const t = {},
          n = s.getProgramParameter(e, 35721);
        for (let i = 0; i < n; i++) {
          const o = s.getActiveAttrib(e, i).name;
          t[o] = s.getAttribLocation(e, o);
        }
        return t;
      }
      function gi(s) {
        return s !== "";
      }
      function jo(s, e) {
        return s
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Yo(s, e) {
        return s
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const Op = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function _s(s) {
        return s.replace(Op, zp);
      }
      function zp(s, e) {
        const t = be[e];
        if (t === void 0)
          throw new Error("Can not resolve #include <" + e + ">");
        return _s(t);
      }
      const Up =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Hp =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Zo(s) {
        return s.replace(Hp, rl).replace(Up, Gp);
      }
      function Gp(s, e, t, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          rl(s, e, t, n)
        );
      }
      function rl(s, e, t, n) {
        let i = "";
        for (let r = parseInt(e); r < parseInt(t); r++)
          i += n
            .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, r);
        return i;
      }
      function Jo(s) {
        let e =
          "precision " +
          s.precision +
          ` float;
precision ` +
          s.precision +
          " int;";
        return (
          s.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : s.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : s.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function kp(s) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          s.shadowMapType === Na
            ? (e = "SHADOWMAP_TYPE_PCF")
            : s.shadowMapType === ql
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : s.shadowMapType === mi && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function Vp(s) {
        let e = "ENVMAP_TYPE_CUBE";
        if (s.envMap)
          switch (s.envMapMode) {
            case Ls:
            case Rs:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case Cs:
            case Ps:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function Wp(s) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (s.envMap)
          switch (s.envMapMode) {
            case Rs:
            case Ps:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function qp(s) {
        let e = "ENVMAP_BLENDING_NONE";
        if (s.envMap)
          switch (s.combine) {
            case Sr:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case uc:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case dc:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function Xp(s, e, t, n) {
        const i = s.getContext(),
          r = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const l = kp(t),
          c = Vp(t),
          h = Wp(t),
          u = qp(t),
          d = s.gammaFactor > 0 ? s.gammaFactor : 1,
          f = t.isWebGL2 ? "" : Np(t),
          m = Fp(r),
          x = i.createProgram();
        let v,
          p,
          g = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((v = [m].filter(gi).join(`
`)),
            v.length > 0 &&
              (v += `
`),
            (p = [f, m].filter(gi).join(`
`)),
            p.length > 0 &&
              (p += `
`))
          : ((v = [
              Jo(t),
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + d,
              "#define MAX_BONES " + t.maxBones,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + h : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.useVertexTexture ? "#define BONE_TEXTURE" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(gi).join(`
`)),
            (p = [
              f,
              Jo(t),
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.alphaTest
                ? "#define ALPHATEST " +
                  t.alphaTest +
                  (t.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + d,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + h : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (t.extensionShaderTextureLOD || t.envMap) &&
              t.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== _i ? "#define TONE_MAPPING" : "",
              t.toneMapping !== _i ? be.tonemapping_pars_fragment : "",
              t.toneMapping !== _i ? Dp("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              be.encodings_pars_fragment,
              t.map ? ai("mapTexelToLinear", t.mapEncoding) : "",
              t.matcap ? ai("matcapTexelToLinear", t.matcapEncoding) : "",
              t.envMap ? ai("envMapTexelToLinear", t.envMapEncoding) : "",
              t.emissiveMap
                ? ai("emissiveMapTexelToLinear", t.emissiveMapEncoding)
                : "",
              t.lightMap ? ai("lightMapTexelToLinear", t.lightMapEncoding) : "",
              Ip("linearToOutputTexel", t.outputEncoding),
              t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
              `
`,
            ].filter(gi).join(`
`))),
          (o = _s(o)),
          (o = jo(o, t)),
          (o = Yo(o, t)),
          (a = _s(a)),
          (a = jo(a, t)),
          (a = Yo(a, t)),
          (o = Zo(o)),
          (a = Zo(a)),
          t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((g = `#version 300 es
`),
            (v =
              [
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              v),
            (p =
              [
                "#define varying in",
                t.glslVersion === Ao ? "" : "out highp vec4 pc_fragColor;",
                t.glslVersion === Ao ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              p));
        const S = g + v + o,
          L = g + p + a,
          E = qo(i, 35633, S),
          _ = qo(i, 35632, L);
        if (
          (i.attachShader(x, E),
          i.attachShader(x, _),
          t.index0AttributeName !== void 0
            ? i.bindAttribLocation(x, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"),
          i.linkProgram(x),
          s.debug.checkShaderErrors)
        ) {
          const O = i.getProgramInfoLog(x).trim(),
            V = i.getShaderInfoLog(E).trim(),
            W = i.getShaderInfoLog(_).trim();
          let z = !0,
            T = !0;
          if (i.getProgramParameter(x, 35714) === !1) {
            z = !1;
            const I = Xo(i, E, "vertex"),
              P = Xo(i, _, "fragment");
            console.error(
              "THREE.WebGLProgram: shader error: ",
              i.getError(),
              "35715",
              i.getProgramParameter(x, 35715),
              "gl.getProgramInfoLog",
              O,
              I,
              P
            );
          } else
            O !== ""
              ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", O)
              : (V === "" || W === "") && (T = !1);
          T &&
            (this.diagnostics = {
              runnable: z,
              programLog: O,
              vertexShader: { log: V, prefix: v },
              fragmentShader: { log: W, prefix: p },
            });
        }
        i.deleteShader(E), i.deleteShader(_);
        let C;
        this.getUniforms = function () {
          return C === void 0 && (C = new nn(i, x)), C;
        };
        let F;
        return (
          (this.getAttributes = function () {
            return F === void 0 && (F = Bp(i, x)), F;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              i.deleteProgram(x),
              (this.program = void 0);
          }),
          (this.name = t.shaderName),
          (this.id = Cp++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = x),
          (this.vertexShader = E),
          (this.fragmentShader = _),
          this
        );
      }
      function jp(s, e, t, n, i, r) {
        const o = [],
          a = n.isWebGL2,
          l = n.logarithmicDepthBuffer,
          c = n.floatVertexTextures,
          h = n.maxVertexUniforms,
          u = n.vertexTextures;
        let d = n.precision;
        const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
          m = [
            "precision",
            "isWebGL2",
            "supportsVertexTextures",
            "outputEncoding",
            "instancing",
            "instancingColor",
            "map",
            "mapEncoding",
            "matcap",
            "matcapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "envMapCubeUV",
            "lightMap",
            "lightMapEncoding",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "tangentSpaceNormalMap",
            "clearcoatMap",
            "clearcoatRoughnessMap",
            "clearcoatNormalMap",
            "displacementMap",
            "specularMap",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "vertexAlphas",
            "vertexTangents",
            "vertexUvs",
            "uvsVertexOnly",
            "fog",
            "useFog",
            "fogExp2",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "numDirLightShadows",
            "numPointLightShadows",
            "numSpotLightShadows",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
            "sheen",
            "transmission",
            "transmissionMap",
            "thicknessMap",
          ];
        function x(_) {
          const F = _.skeleton.bones;
          if (c) return 1024;
          {
            const V = Math.floor((h - 20) / 4),
              W = Math.min(V, F.length);
            return W < F.length
              ? (console.warn(
                  "THREE.WebGLRenderer: Skeleton has " +
                    F.length +
                    " bones. This GPU supports " +
                    W +
                    "."
                ),
                0)
              : W;
          }
        }
        function v(_) {
          let C;
          return (
            _ && _.isTexture
              ? (C = _.encoding)
              : _ && _.isWebGLRenderTarget
              ? (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (C = _.texture.encoding))
              : (C = Oi),
            C
          );
        }
        function p(_, C, F, O, V) {
          const W = O.fog,
            z = _.isMeshStandardMaterial ? O.environment : null,
            T = e.get(_.envMap || z),
            I = f[_.type],
            P = V.isSkinnedMesh ? x(V) : 0;
          _.precision !== null &&
            ((d = n.getMaxPrecision(_.precision)),
            d !== _.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                _.precision,
                "not supported, using",
                d,
                "instead."
              ));
          let R, G;
          if (I) {
            const se = Rt[I];
            (R = se.vertexShader), (G = se.fragmentShader);
          } else (R = _.vertexShader), (G = _.fragmentShader);
          const ee = s.getRenderTarget();
          return {
            isWebGL2: a,
            shaderID: I,
            shaderName: _.type,
            vertexShader: R,
            fragmentShader: G,
            defines: _.defines,
            isRawShaderMaterial: _.isRawShaderMaterial === !0,
            glslVersion: _.glslVersion,
            precision: d,
            instancing: V.isInstancedMesh === !0,
            instancingColor:
              V.isInstancedMesh === !0 && V.instanceColor !== null,
            supportsVertexTextures: u,
            outputEncoding: ee !== null ? v(ee.texture) : s.outputEncoding,
            map: !!_.map,
            mapEncoding: v(_.map),
            matcap: !!_.matcap,
            matcapEncoding: v(_.matcap),
            envMap: !!T,
            envMapMode: T && T.mapping,
            envMapEncoding: v(T),
            envMapCubeUV: !!T && (T.mapping === Cs || T.mapping === Ps),
            lightMap: !!_.lightMap,
            lightMapEncoding: v(_.lightMap),
            aoMap: !!_.aoMap,
            emissiveMap: !!_.emissiveMap,
            emissiveMapEncoding: v(_.emissiveMap),
            bumpMap: !!_.bumpMap,
            normalMap: !!_.normalMap,
            objectSpaceNormalMap: _.normalMapType === wh,
            tangentSpaceNormalMap: _.normalMapType === pn,
            clearcoatMap: !!_.clearcoatMap,
            clearcoatRoughnessMap: !!_.clearcoatRoughnessMap,
            clearcoatNormalMap: !!_.clearcoatNormalMap,
            displacementMap: !!_.displacementMap,
            roughnessMap: !!_.roughnessMap,
            metalnessMap: !!_.metalnessMap,
            specularMap: !!_.specularMap,
            alphaMap: !!_.alphaMap,
            gradientMap: !!_.gradientMap,
            sheen: !!_.sheen,
            transmission: !!_.transmission,
            transmissionMap: !!_.transmissionMap,
            thicknessMap: !!_.thicknessMap,
            combine: _.combine,
            vertexTangents: _.normalMap && _.vertexTangents,
            vertexColors: _.vertexColors,
            vertexAlphas:
              _.vertexColors === !0 &&
              V.geometry &&
              V.geometry.attributes.color &&
              V.geometry.attributes.color.itemSize === 4,
            vertexUvs:
              !!_.map ||
              !!_.bumpMap ||
              !!_.normalMap ||
              !!_.specularMap ||
              !!_.alphaMap ||
              !!_.emissiveMap ||
              !!_.roughnessMap ||
              !!_.metalnessMap ||
              !!_.clearcoatMap ||
              !!_.clearcoatRoughnessMap ||
              !!_.clearcoatNormalMap ||
              !!_.displacementMap ||
              !!_.transmission ||
              !!_.transmissionMap ||
              !!_.thicknessMap,
            uvsVertexOnly:
              !(
                !!_.map ||
                !!_.bumpMap ||
                !!_.normalMap ||
                !!_.specularMap ||
                !!_.alphaMap ||
                !!_.emissiveMap ||
                !!_.roughnessMap ||
                !!_.metalnessMap ||
                !!_.clearcoatNormalMap ||
                !!_.transmission ||
                !!_.transmissionMap ||
                !!_.thicknessMap
              ) && !!_.displacementMap,
            fog: !!W,
            useFog: _.fog,
            fogExp2: W && W.isFogExp2,
            flatShading: !!_.flatShading,
            sizeAttenuation: _.sizeAttenuation,
            logarithmicDepthBuffer: l,
            skinning: V.isSkinnedMesh === !0 && P > 0,
            maxBones: P,
            useVertexTexture: c,
            morphTargets: _.morphTargets,
            morphNormals: _.morphNormals,
            numDirLights: C.directional.length,
            numPointLights: C.point.length,
            numSpotLights: C.spot.length,
            numRectAreaLights: C.rectArea.length,
            numHemiLights: C.hemi.length,
            numDirLightShadows: C.directionalShadowMap.length,
            numPointLightShadows: C.pointShadowMap.length,
            numSpotLightShadows: C.spotShadowMap.length,
            numClippingPlanes: r.numPlanes,
            numClipIntersection: r.numIntersection,
            dithering: _.dithering,
            shadowMapEnabled: s.shadowMap.enabled && F.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: _.toneMapped ? s.toneMapping : _i,
            physicallyCorrectLights: s.physicallyCorrectLights,
            premultipliedAlpha: _.premultipliedAlpha,
            alphaTest: _.alphaTest,
            doubleSided: _.side === Bi,
            flipSided: _.side === Ze,
            depthPacking: _.depthPacking !== void 0 ? _.depthPacking : !1,
            index0AttributeName: _.index0AttributeName,
            extensionDerivatives: _.extensions && _.extensions.derivatives,
            extensionFragDepth: _.extensions && _.extensions.fragDepth,
            extensionDrawBuffers: _.extensions && _.extensions.drawBuffers,
            extensionShaderTextureLOD:
              _.extensions && _.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: a || t.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: a || t.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              a || t.has("EXT_shader_texture_lod"),
            customProgramCacheKey: _.customProgramCacheKey(),
          };
        }
        function g(_) {
          const C = [];
          if (
            (_.shaderID
              ? C.push(_.shaderID)
              : (C.push(_.fragmentShader), C.push(_.vertexShader)),
            _.defines !== void 0)
          )
            for (const F in _.defines) C.push(F), C.push(_.defines[F]);
          if (_.isRawShaderMaterial === !1) {
            for (let F = 0; F < m.length; F++) C.push(_[m[F]]);
            C.push(s.outputEncoding), C.push(s.gammaFactor);
          }
          return C.push(_.customProgramCacheKey), C.join();
        }
        function S(_) {
          const C = f[_.type];
          let F;
          if (C) {
            const O = Rt[C];
            F = tu.clone(O.uniforms);
          } else F = _.uniforms;
          return F;
        }
        function L(_, C) {
          let F;
          for (let O = 0, V = o.length; O < V; O++) {
            const W = o[O];
            if (W.cacheKey === C) {
              (F = W), ++F.usedTimes;
              break;
            }
          }
          return F === void 0 && ((F = new Xp(s, C, _, i)), o.push(F)), F;
        }
        function E(_) {
          if (--_.usedTimes === 0) {
            const C = o.indexOf(_);
            (o[C] = o[o.length - 1]), o.pop(), _.destroy();
          }
        }
        return {
          getParameters: p,
          getProgramCacheKey: g,
          getUniforms: S,
          acquireProgram: L,
          releaseProgram: E,
          programs: o,
        };
      }
      function Yp() {
        let s = new WeakMap();
        function e(r) {
          let o = s.get(r);
          return o === void 0 && ((o = {}), s.set(r, o)), o;
        }
        function t(r) {
          s.delete(r);
        }
        function n(r, o, a) {
          s.get(r)[o] = a;
        }
        function i() {
          s = new WeakMap();
        }
        return { get: e, remove: t, update: n, dispose: i };
      }
      function Zp(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.program !== e.program
          ? s.program.id - e.program.id
          : s.material.id !== e.material.id
          ? s.material.id - e.material.id
          : s.z !== e.z
          ? s.z - e.z
          : s.id - e.id;
      }
      function Ko(s, e) {
        return s.groupOrder !== e.groupOrder
          ? s.groupOrder - e.groupOrder
          : s.renderOrder !== e.renderOrder
          ? s.renderOrder - e.renderOrder
          : s.z !== e.z
          ? e.z - s.z
          : s.id - e.id;
      }
      function Qo(s) {
        const e = [];
        let t = 0;
        const n = [],
          i = [],
          r = [],
          o = { id: -1 };
        function a() {
          (t = 0), (n.length = 0), (i.length = 0), (r.length = 0);
        }
        function l(f, m, x, v, p, g) {
          let S = e[t];
          const L = s.get(x);
          return (
            S === void 0
              ? ((S = {
                  id: f.id,
                  object: f,
                  geometry: m,
                  material: x,
                  program: L.program || o,
                  groupOrder: v,
                  renderOrder: f.renderOrder,
                  z: p,
                  group: g,
                }),
                (e[t] = S))
              : ((S.id = f.id),
                (S.object = f),
                (S.geometry = m),
                (S.material = x),
                (S.program = L.program || o),
                (S.groupOrder = v),
                (S.renderOrder = f.renderOrder),
                (S.z = p),
                (S.group = g)),
            t++,
            S
          );
        }
        function c(f, m, x, v, p, g) {
          const S = l(f, m, x, v, p, g);
          x.transmission > 0
            ? i.push(S)
            : x.transparent === !0
            ? r.push(S)
            : n.push(S);
        }
        function h(f, m, x, v, p, g) {
          const S = l(f, m, x, v, p, g);
          x.transmission > 0
            ? i.unshift(S)
            : x.transparent === !0
            ? r.unshift(S)
            : n.unshift(S);
        }
        function u(f, m) {
          n.length > 1 && n.sort(f || Zp),
            i.length > 1 && i.sort(m || Ko),
            r.length > 1 && r.sort(m || Ko);
        }
        function d() {
          for (let f = t, m = e.length; f < m; f++) {
            const x = e[f];
            if (x.id === null) break;
            (x.id = null),
              (x.object = null),
              (x.geometry = null),
              (x.material = null),
              (x.program = null),
              (x.group = null);
          }
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: a,
          push: c,
          unshift: h,
          finish: d,
          sort: u,
        };
      }
      function Jp(s) {
        let e = new WeakMap();
        function t(i, r) {
          let o;
          return (
            e.has(i) === !1
              ? ((o = new Qo(s)), e.set(i, [o]))
              : r >= e.get(i).length
              ? ((o = new Qo(s)), e.get(i).push(o))
              : (o = e.get(i)[r]),
            o
          );
        }
        function n() {
          e = new WeakMap();
        }
        return { get: t, dispose: n };
      }
      function Kp() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new b(), color: new ae() };
                break;
              case "SpotLight":
                t = {
                  position: new b(),
                  direction: new b(),
                  color: new ae(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new b(),
                  color: new ae(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new b(),
                  skyColor: new ae(),
                  groundColor: new ae(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new ae(),
                  position: new b(),
                  halfWidth: new b(),
                  halfHeight: new b(),
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      function Qp() {
        const s = {};
        return {
          get: function (e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Y(),
                };
                break;
              case "SpotLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Y(),
                };
                break;
              case "PointLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Y(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (s[e.id] = t), t;
          },
        };
      }
      let $p = 0;
      function em(s, e) {
        return (e.castShadow ? 1 : 0) - (s.castShadow ? 1 : 0);
      }
      function tm(s, e) {
        const t = new Kp(),
          n = Qp(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let h = 0; h < 9; h++) i.probe.push(new b());
        const r = new b(),
          o = new le(),
          a = new le();
        function l(h) {
          let u = 0,
            d = 0,
            f = 0;
          for (let C = 0; C < 9; C++) i.probe[C].set(0, 0, 0);
          let m = 0,
            x = 0,
            v = 0,
            p = 0,
            g = 0,
            S = 0,
            L = 0,
            E = 0;
          h.sort(em);
          for (let C = 0, F = h.length; C < F; C++) {
            const O = h[C],
              V = O.color,
              W = O.intensity,
              z = O.distance,
              T = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
            if (O.isAmbientLight)
              (u += V.r * W), (d += V.g * W), (f += V.b * W);
            else if (O.isLightProbe)
              for (let I = 0; I < 9; I++)
                i.probe[I].addScaledVector(O.sh.coefficients[I], W);
            else if (O.isDirectionalLight) {
              const I = t.get(O);
              if (
                (I.color.copy(O.color).multiplyScalar(O.intensity),
                O.castShadow)
              ) {
                const P = O.shadow,
                  R = n.get(O);
                (R.shadowBias = P.bias),
                  (R.shadowNormalBias = P.normalBias),
                  (R.shadowRadius = P.radius),
                  (R.shadowMapSize = P.mapSize),
                  (i.directionalShadow[m] = R),
                  (i.directionalShadowMap[m] = T),
                  (i.directionalShadowMatrix[m] = O.shadow.matrix),
                  S++;
              }
              (i.directional[m] = I), m++;
            } else if (O.isSpotLight) {
              const I = t.get(O);
              if (
                (I.position.setFromMatrixPosition(O.matrixWorld),
                I.color.copy(V).multiplyScalar(W),
                (I.distance = z),
                (I.coneCos = Math.cos(O.angle)),
                (I.penumbraCos = Math.cos(O.angle * (1 - O.penumbra))),
                (I.decay = O.decay),
                O.castShadow)
              ) {
                const P = O.shadow,
                  R = n.get(O);
                (R.shadowBias = P.bias),
                  (R.shadowNormalBias = P.normalBias),
                  (R.shadowRadius = P.radius),
                  (R.shadowMapSize = P.mapSize),
                  (i.spotShadow[v] = R),
                  (i.spotShadowMap[v] = T),
                  (i.spotShadowMatrix[v] = O.shadow.matrix),
                  E++;
              }
              (i.spot[v] = I), v++;
            } else if (O.isRectAreaLight) {
              const I = t.get(O);
              I.color.copy(V).multiplyScalar(W),
                I.halfWidth.set(O.width * 0.5, 0, 0),
                I.halfHeight.set(0, O.height * 0.5, 0),
                (i.rectArea[p] = I),
                p++;
            } else if (O.isPointLight) {
              const I = t.get(O);
              if (
                (I.color.copy(O.color).multiplyScalar(O.intensity),
                (I.distance = O.distance),
                (I.decay = O.decay),
                O.castShadow)
              ) {
                const P = O.shadow,
                  R = n.get(O);
                (R.shadowBias = P.bias),
                  (R.shadowNormalBias = P.normalBias),
                  (R.shadowRadius = P.radius),
                  (R.shadowMapSize = P.mapSize),
                  (R.shadowCameraNear = P.camera.near),
                  (R.shadowCameraFar = P.camera.far),
                  (i.pointShadow[x] = R),
                  (i.pointShadowMap[x] = T),
                  (i.pointShadowMatrix[x] = O.shadow.matrix),
                  L++;
              }
              (i.point[x] = I), x++;
            } else if (O.isHemisphereLight) {
              const I = t.get(O);
              I.skyColor.copy(O.color).multiplyScalar(W),
                I.groundColor.copy(O.groundColor).multiplyScalar(W),
                (i.hemi[g] = I),
                g++;
            }
          }
          p > 0 &&
            (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = $.LTC_FLOAT_1),
                (i.rectAreaLTC2 = $.LTC_FLOAT_2))
              : s.has("OES_texture_half_float_linear") === !0
              ? ((i.rectAreaLTC1 = $.LTC_HALF_1),
                (i.rectAreaLTC2 = $.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = u),
            (i.ambient[1] = d),
            (i.ambient[2] = f);
          const _ = i.hash;
          (_.directionalLength !== m ||
            _.pointLength !== x ||
            _.spotLength !== v ||
            _.rectAreaLength !== p ||
            _.hemiLength !== g ||
            _.numDirectionalShadows !== S ||
            _.numPointShadows !== L ||
            _.numSpotShadows !== E) &&
            ((i.directional.length = m),
            (i.spot.length = v),
            (i.rectArea.length = p),
            (i.point.length = x),
            (i.hemi.length = g),
            (i.directionalShadow.length = S),
            (i.directionalShadowMap.length = S),
            (i.pointShadow.length = L),
            (i.pointShadowMap.length = L),
            (i.spotShadow.length = E),
            (i.spotShadowMap.length = E),
            (i.directionalShadowMatrix.length = S),
            (i.pointShadowMatrix.length = L),
            (i.spotShadowMatrix.length = E),
            (_.directionalLength = m),
            (_.pointLength = x),
            (_.spotLength = v),
            (_.rectAreaLength = p),
            (_.hemiLength = g),
            (_.numDirectionalShadows = S),
            (_.numPointShadows = L),
            (_.numSpotShadows = E),
            (i.version = $p++));
        }
        function c(h, u) {
          let d = 0,
            f = 0,
            m = 0,
            x = 0,
            v = 0;
          const p = u.matrixWorldInverse;
          for (let g = 0, S = h.length; g < S; g++) {
            const L = h[g];
            if (L.isDirectionalLight) {
              const E = i.directional[d];
              E.direction.setFromMatrixPosition(L.matrixWorld),
                r.setFromMatrixPosition(L.target.matrixWorld),
                E.direction.sub(r),
                E.direction.transformDirection(p),
                d++;
            } else if (L.isSpotLight) {
              const E = i.spot[m];
              E.position.setFromMatrixPosition(L.matrixWorld),
                E.position.applyMatrix4(p),
                E.direction.setFromMatrixPosition(L.matrixWorld),
                r.setFromMatrixPosition(L.target.matrixWorld),
                E.direction.sub(r),
                E.direction.transformDirection(p),
                m++;
            } else if (L.isRectAreaLight) {
              const E = i.rectArea[x];
              E.position.setFromMatrixPosition(L.matrixWorld),
                E.position.applyMatrix4(p),
                a.identity(),
                o.copy(L.matrixWorld),
                o.premultiply(p),
                a.extractRotation(o),
                E.halfWidth.set(L.width * 0.5, 0, 0),
                E.halfHeight.set(0, L.height * 0.5, 0),
                E.halfWidth.applyMatrix4(a),
                E.halfHeight.applyMatrix4(a),
                x++;
            } else if (L.isPointLight) {
              const E = i.point[f];
              E.position.setFromMatrixPosition(L.matrixWorld),
                E.position.applyMatrix4(p),
                f++;
            } else if (L.isHemisphereLight) {
              const E = i.hemi[v];
              E.direction.setFromMatrixPosition(L.matrixWorld),
                E.direction.transformDirection(p),
                E.direction.normalize(),
                v++;
            }
          }
        }
        return { setup: l, setupView: c, state: i };
      }
      function $o(s, e) {
        const t = new tm(s, e),
          n = [],
          i = [];
        function r() {
          (n.length = 0), (i.length = 0);
        }
        function o(u) {
          n.push(u);
        }
        function a(u) {
          i.push(u);
        }
        function l() {
          t.setup(n);
        }
        function c(u) {
          t.setupView(n, u);
        }
        return {
          init: r,
          state: { lightsArray: n, shadowsArray: i, lights: t },
          setupLights: l,
          setupLightsView: c,
          pushLight: o,
          pushShadow: a,
        };
      }
      function nm(s, e) {
        let t = new WeakMap();
        function n(r, o = 0) {
          let a;
          return (
            t.has(r) === !1
              ? ((a = new $o(s, e)), t.set(r, [a]))
              : o >= t.get(r).length
              ? ((a = new $o(s, e)), t.get(r).push(a))
              : (a = t.get(r)[o]),
            a
          );
        }
        function i() {
          t = new WeakMap();
        }
        return { get: n, dispose: i };
      }
      class sl extends Ke {
        constructor(e) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = yh),
            (this.morphTargets = !1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      sl.prototype.isMeshDepthMaterial = !0;
      class ol extends Ke {
        constructor(e) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new b()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.morphTargets = !1),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.morphTargets = e.morphTargets),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      ol.prototype.isMeshDistanceMaterial = !0;
      var im = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,
        rm = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
      function al(s, e, t) {
        let n = new Er();
        const i = new Y(),
          r = new Y(),
          o = new Fe(),
          a = [],
          l = [],
          c = {},
          h = t.maxTextureSize,
          u = { 0: Ze, 1: Ti, 2: Bi },
          d = new fn({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Y() },
              radius: { value: 4 },
            },
            vertexShader: rm,
            fragmentShader: im,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const m = new ze();
        m.setAttribute(
          "position",
          new Xe(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const x = new _t(m, d),
          v = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = Na),
          (this.render = function (_, C, F) {
            if (
              v.enabled === !1 ||
              (v.autoUpdate === !1 && v.needsUpdate === !1) ||
              _.length === 0
            )
              return;
            const O = s.getRenderTarget(),
              V = s.getActiveCubeFace(),
              W = s.getActiveMipmapLevel(),
              z = s.state;
            z.setBlending(xi),
              z.buffers.color.setClear(1, 1, 1, 1),
              z.buffers.depth.setTest(!0),
              z.setScissorTest(!1);
            for (let T = 0, I = _.length; T < I; T++) {
              const P = _[T],
                R = P.shadow;
              if (R === void 0) {
                console.warn("THREE.WebGLShadowMap:", P, "has no shadow.");
                continue;
              }
              if (R.autoUpdate === !1 && R.needsUpdate === !1) continue;
              i.copy(R.mapSize);
              const G = R.getFrameExtents();
              if (
                (i.multiply(G),
                r.copy(R.mapSize),
                (i.x > h || i.y > h) &&
                  (i.x > h &&
                    ((r.x = Math.floor(h / G.x)),
                    (i.x = r.x * G.x),
                    (R.mapSize.x = r.x)),
                  i.y > h &&
                    ((r.y = Math.floor(h / G.y)),
                    (i.y = r.y * G.y),
                    (R.mapSize.y = r.y))),
                R.map === null && !R.isPointLightShadow && this.type === mi)
              ) {
                const Z = { minFilter: ft, magFilter: ft, format: Et };
                (R.map = new Ht(i.x, i.y, Z)),
                  (R.map.texture.name = P.name + ".shadowMap"),
                  (R.mapPass = new Ht(i.x, i.y, Z)),
                  R.camera.updateProjectionMatrix();
              }
              if (R.map === null) {
                const Z = { minFilter: $e, magFilter: $e, format: Et };
                (R.map = new Ht(i.x, i.y, Z)),
                  (R.map.texture.name = P.name + ".shadowMap"),
                  R.camera.updateProjectionMatrix();
              }
              s.setRenderTarget(R.map), s.clear();
              const ee = R.getViewportCount();
              for (let Z = 0; Z < ee; Z++) {
                const se = R.getViewport(Z);
                o.set(r.x * se.x, r.y * se.y, r.x * se.z, r.y * se.w),
                  z.viewport(o),
                  R.updateMatrices(P, Z),
                  (n = R.getFrustum()),
                  E(C, F, R.camera, P, this.type);
              }
              !R.isPointLightShadow && this.type === mi && p(R, F),
                (R.needsUpdate = !1);
            }
            (v.needsUpdate = !1), s.setRenderTarget(O, V, W);
          });
        function p(_, C) {
          const F = e.update(x);
          (d.uniforms.shadow_pass.value = _.map.texture),
            (d.uniforms.resolution.value = _.mapSize),
            (d.uniforms.radius.value = _.radius),
            s.setRenderTarget(_.mapPass),
            s.clear(),
            s.renderBufferDirect(C, null, F, d, x, null),
            (f.uniforms.shadow_pass.value = _.mapPass.texture),
            (f.uniforms.resolution.value = _.mapSize),
            (f.uniforms.radius.value = _.radius),
            s.setRenderTarget(_.map),
            s.clear(),
            s.renderBufferDirect(C, null, F, f, x, null);
        }
        function g(_) {
          const C = _ << 0;
          let F = a[C];
          return (
            F === void 0 &&
              ((F = new sl({ depthPacking: Mh, morphTargets: _ })), (a[C] = F)),
            F
          );
        }
        function S(_) {
          const C = _ << 0;
          let F = l[C];
          return (
            F === void 0 && ((F = new ol({ morphTargets: _ })), (l[C] = F)), F
          );
        }
        function L(_, C, F, O, V, W, z) {
          let T = null,
            I = g,
            P = _.customDepthMaterial;
          if (
            (O.isPointLight === !0 && ((I = S), (P = _.customDistanceMaterial)),
            P === void 0)
          ) {
            let R = !1;
            F.morphTargets === !0 &&
              (R =
                C.morphAttributes &&
                C.morphAttributes.position &&
                C.morphAttributes.position.length > 0),
              (T = I(R));
          } else T = P;
          if (
            s.localClippingEnabled &&
            F.clipShadows === !0 &&
            F.clippingPlanes.length !== 0
          ) {
            const R = T.uuid,
              G = F.uuid;
            let ee = c[R];
            ee === void 0 && ((ee = {}), (c[R] = ee));
            let Z = ee[G];
            Z === void 0 && ((Z = T.clone()), (ee[G] = Z)), (T = Z);
          }
          return (
            (T.visible = F.visible),
            (T.wireframe = F.wireframe),
            z === mi
              ? (T.side = F.shadowSide !== null ? F.shadowSide : F.side)
              : (T.side = F.shadowSide !== null ? F.shadowSide : u[F.side]),
            (T.clipShadows = F.clipShadows),
            (T.clippingPlanes = F.clippingPlanes),
            (T.clipIntersection = F.clipIntersection),
            (T.wireframeLinewidth = F.wireframeLinewidth),
            (T.linewidth = F.linewidth),
            O.isPointLight === !0 &&
              T.isMeshDistanceMaterial === !0 &&
              (T.referencePosition.setFromMatrixPosition(O.matrixWorld),
              (T.nearDistance = V),
              (T.farDistance = W)),
            T
          );
        }
        function E(_, C, F, O, V) {
          if (_.visible === !1) return;
          if (
            _.layers.test(C.layers) &&
            (_.isMesh || _.isLine || _.isPoints) &&
            (_.castShadow || (_.receiveShadow && V === mi)) &&
            (!_.frustumCulled || n.intersectsObject(_))
          ) {
            _.modelViewMatrix.multiplyMatrices(
              F.matrixWorldInverse,
              _.matrixWorld
            );
            const T = e.update(_),
              I = _.material;
            if (Array.isArray(I)) {
              const P = T.groups;
              for (let R = 0, G = P.length; R < G; R++) {
                const ee = P[R],
                  Z = I[ee.materialIndex];
                if (Z && Z.visible) {
                  const se = L(_, T, Z, O, F.near, F.far, V);
                  s.renderBufferDirect(F, null, T, se, _, ee);
                }
              }
            } else if (I.visible) {
              const P = L(_, T, I, O, F.near, F.far, V);
              s.renderBufferDirect(F, null, T, P, _, null);
            }
          }
          const z = _.children;
          for (let T = 0, I = z.length; T < I; T++) E(z[T], C, F, O, V);
        }
      }
      function sm(s, e, t) {
        const n = t.isWebGL2;
        function i() {
          let A = !1;
          const J = new Fe();
          let k = null;
          const ue = new Fe(0, 0, 0, 0);
          return {
            setMask: function (ne) {
              k !== ne && !A && (s.colorMask(ne, ne, ne, ne), (k = ne));
            },
            setLocked: function (ne) {
              A = ne;
            },
            setClear: function (ne, Ue, nt, it, on) {
              on === !0 && ((ne *= it), (Ue *= it), (nt *= it)),
                J.set(ne, Ue, nt, it),
                ue.equals(J) === !1 &&
                  (s.clearColor(ne, Ue, nt, it), ue.copy(J));
            },
            reset: function () {
              (A = !1), (k = null), ue.set(-1, 0, 0, 0);
            },
          };
        }
        function r() {
          let A = !1,
            J = null,
            k = null,
            ue = null;
          return {
            setTest: function (ne) {
              ne ? Ce(2929) : Ee(2929);
            },
            setMask: function (ne) {
              J !== ne && !A && (s.depthMask(ne), (J = ne));
            },
            setFunc: function (ne) {
              if (k !== ne) {
                if (ne)
                  switch (ne) {
                    case rc:
                      s.depthFunc(512);
                      break;
                    case sc:
                      s.depthFunc(519);
                      break;
                    case oc:
                      s.depthFunc(513);
                      break;
                    case ms:
                      s.depthFunc(515);
                      break;
                    case ac:
                      s.depthFunc(514);
                      break;
                    case lc:
                      s.depthFunc(518);
                      break;
                    case cc:
                      s.depthFunc(516);
                      break;
                    case hc:
                      s.depthFunc(517);
                      break;
                    default:
                      s.depthFunc(515);
                  }
                else s.depthFunc(515);
                k = ne;
              }
            },
            setLocked: function (ne) {
              A = ne;
            },
            setClear: function (ne) {
              ue !== ne && (s.clearDepth(ne), (ue = ne));
            },
            reset: function () {
              (A = !1), (J = null), (k = null), (ue = null);
            },
          };
        }
        function o() {
          let A = !1,
            J = null,
            k = null,
            ue = null,
            ne = null,
            Ue = null,
            nt = null,
            it = null,
            on = null;
          return {
            setTest: function (Ve) {
              A || (Ve ? Ce(2960) : Ee(2960));
            },
            setMask: function (Ve) {
              J !== Ve && !A && (s.stencilMask(Ve), (J = Ve));
            },
            setFunc: function (Ve, It, Mt) {
              (k !== Ve || ue !== It || ne !== Mt) &&
                (s.stencilFunc(Ve, It, Mt), (k = Ve), (ue = It), (ne = Mt));
            },
            setOp: function (Ve, It, Mt) {
              (Ue !== Ve || nt !== It || it !== Mt) &&
                (s.stencilOp(Ve, It, Mt), (Ue = Ve), (nt = It), (it = Mt));
            },
            setLocked: function (Ve) {
              A = Ve;
            },
            setClear: function (Ve) {
              on !== Ve && (s.clearStencil(Ve), (on = Ve));
            },
            reset: function () {
              (A = !1),
                (J = null),
                (k = null),
                (ue = null),
                (ne = null),
                (Ue = null),
                (nt = null),
                (it = null),
                (on = null);
            },
          };
        }
        const a = new i(),
          l = new r(),
          c = new o();
        let h = {},
          u = null,
          d = {},
          f = null,
          m = !1,
          x = null,
          v = null,
          p = null,
          g = null,
          S = null,
          L = null,
          E = null,
          _ = !1,
          C = null,
          F = null,
          O = null,
          V = null,
          W = null;
        const z = s.getParameter(35661);
        let T = !1,
          I = 0;
        const P = s.getParameter(7938);
        P.indexOf("WebGL") !== -1
          ? ((I = parseFloat(/^WebGL (\d)/.exec(P)[1])), (T = I >= 1))
          : P.indexOf("OpenGL ES") !== -1 &&
            ((I = parseFloat(/^OpenGL ES (\d)/.exec(P)[1])), (T = I >= 2));
        let R = null,
          G = {};
        const ee = s.getParameter(3088),
          Z = s.getParameter(2978),
          se = new Fe().fromArray(ee),
          ie = new Fe().fromArray(Z);
        function ye(A, J, k) {
          const ue = new Uint8Array(4),
            ne = s.createTexture();
          s.bindTexture(A, ne),
            s.texParameteri(A, 10241, 9728),
            s.texParameteri(A, 10240, 9728);
          for (let Ue = 0; Ue < k; Ue++)
            s.texImage2D(J + Ue, 0, 6408, 1, 1, 0, 6408, 5121, ue);
          return ne;
        }
        const ve = {};
        (ve[3553] = ye(3553, 3553, 1)),
          (ve[34067] = ye(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          Ce(2929),
          l.setFunc(ms),
          j(!1),
          K(lo),
          Ce(2884),
          Se(xi);
        function Ce(A) {
          h[A] !== !0 && (s.enable(A), (h[A] = !0));
        }
        function Ee(A) {
          h[A] !== !1 && (s.disable(A), (h[A] = !1));
        }
        function H(A) {
          A !== u && (s.bindFramebuffer(36160, A), (u = A));
        }
        function Ge(A, J) {
          return (
            J === null && u !== null && (J = u),
            d[A] !== J
              ? (s.bindFramebuffer(A, J),
                (d[A] = J),
                n &&
                  (A === 36009 && (d[36160] = J),
                  A === 36160 && (d[36009] = J)),
                !0)
              : !1
          );
        }
        function Ae(A) {
          return f !== A ? (s.useProgram(A), (f = A), !0) : !1;
        }
        const _e = { [Nn]: 32774, [jl]: 32778, [Yl]: 32779 };
        if (n) (_e[fo] = 32775), (_e[po] = 32776);
        else {
          const A = e.get("EXT_blend_minmax");
          A !== null && ((_e[fo] = A.MIN_EXT), (_e[po] = A.MAX_EXT));
        }
        const fe = {
          [Zl]: 0,
          [Jl]: 1,
          [Kl]: 768,
          [Ba]: 770,
          [ic]: 776,
          [tc]: 774,
          [$l]: 772,
          [Ql]: 769,
          [Oa]: 771,
          [nc]: 775,
          [ec]: 773,
        };
        function Se(A, J, k, ue, ne, Ue, nt, it) {
          if (A === xi) {
            m === !0 && (Ee(3042), (m = !1));
            return;
          }
          if ((m === !1 && (Ce(3042), (m = !0)), A !== Xl)) {
            if (A !== x || it !== _) {
              if (
                ((v !== Nn || S !== Nn) &&
                  (s.blendEquation(32774), (v = Nn), (S = Nn)),
                it)
              )
                switch (A) {
                  case vi:
                    s.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case co:
                    s.blendFunc(1, 1);
                    break;
                  case ho:
                    s.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case uo:
                    s.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", A);
                    break;
                }
              else
                switch (A) {
                  case vi:
                    s.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case co:
                    s.blendFunc(770, 1);
                    break;
                  case ho:
                    s.blendFunc(0, 769);
                    break;
                  case uo:
                    s.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", A);
                    break;
                }
              (p = null), (g = null), (L = null), (E = null), (x = A), (_ = it);
            }
            return;
          }
          (ne = ne || J),
            (Ue = Ue || k),
            (nt = nt || ue),
            (J !== v || ne !== S) &&
              (s.blendEquationSeparate(_e[J], _e[ne]), (v = J), (S = ne)),
            (k !== p || ue !== g || Ue !== L || nt !== E) &&
              (s.blendFuncSeparate(fe[k], fe[ue], fe[Ue], fe[nt]),
              (p = k),
              (g = ue),
              (L = Ue),
              (E = nt)),
            (x = A),
            (_ = null);
        }
        function q(A, J) {
          A.side === Bi ? Ee(2884) : Ce(2884);
          let k = A.side === Ze;
          J && (k = !k),
            j(k),
            A.blending === vi && A.transparent === !1
              ? Se(xi)
              : Se(
                  A.blending,
                  A.blendEquation,
                  A.blendSrc,
                  A.blendDst,
                  A.blendEquationAlpha,
                  A.blendSrcAlpha,
                  A.blendDstAlpha,
                  A.premultipliedAlpha
                ),
            l.setFunc(A.depthFunc),
            l.setTest(A.depthTest),
            l.setMask(A.depthWrite),
            a.setMask(A.colorWrite);
          const ue = A.stencilWrite;
          c.setTest(ue),
            ue &&
              (c.setMask(A.stencilWriteMask),
              c.setFunc(A.stencilFunc, A.stencilRef, A.stencilFuncMask),
              c.setOp(A.stencilFail, A.stencilZFail, A.stencilZPass)),
            re(A.polygonOffset, A.polygonOffsetFactor, A.polygonOffsetUnits),
            A.alphaToCoverage === !0 ? Ce(32926) : Ee(32926);
        }
        function j(A) {
          C !== A && (A ? s.frontFace(2304) : s.frontFace(2305), (C = A));
        }
        function K(A) {
          A !== Vl
            ? (Ce(2884),
              A !== F &&
                (A === lo
                  ? s.cullFace(1029)
                  : A === Wl
                  ? s.cullFace(1028)
                  : s.cullFace(1032)))
            : Ee(2884),
            (F = A);
        }
        function he(A) {
          A !== O && (T && s.lineWidth(A), (O = A));
        }
        function re(A, J, k) {
          A
            ? (Ce(32823),
              (V !== J || W !== k) && (s.polygonOffset(J, k), (V = J), (W = k)))
            : Ee(32823);
        }
        function w(A) {
          A ? Ce(3089) : Ee(3089);
        }
        function M(A) {
          A === void 0 && (A = 33984 + z - 1),
            R !== A && (s.activeTexture(A), (R = A));
        }
        function U(A, J) {
          R === null && M();
          let k = G[R];
          k === void 0 && ((k = { type: void 0, texture: void 0 }), (G[R] = k)),
            (k.type !== A || k.texture !== J) &&
              (s.bindTexture(A, J || ve[A]), (k.type = A), (k.texture = J));
        }
        function X() {
          const A = G[R];
          A !== void 0 &&
            A.type !== void 0 &&
            (s.bindTexture(A.type, null),
            (A.type = void 0),
            (A.texture = void 0));
        }
        function te() {
          try {
            s.compressedTexImage2D.apply(s, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function oe() {
          try {
            s.texImage2D.apply(s, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function ge() {
          try {
            s.texImage3D.apply(s, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function pe(A) {
          se.equals(A) === !1 && (s.scissor(A.x, A.y, A.z, A.w), se.copy(A));
        }
        function Me(A) {
          ie.equals(A) === !1 && (s.viewport(A.x, A.y, A.z, A.w), ie.copy(A));
        }
        function ce() {
          s.disable(3042),
            s.disable(2884),
            s.disable(2929),
            s.disable(32823),
            s.disable(3089),
            s.disable(2960),
            s.disable(32926),
            s.blendEquation(32774),
            s.blendFunc(1, 0),
            s.blendFuncSeparate(1, 0, 1, 0),
            s.colorMask(!0, !0, !0, !0),
            s.clearColor(0, 0, 0, 0),
            s.depthMask(!0),
            s.depthFunc(513),
            s.clearDepth(1),
            s.stencilMask(4294967295),
            s.stencilFunc(519, 0, 4294967295),
            s.stencilOp(7680, 7680, 7680),
            s.clearStencil(0),
            s.cullFace(1029),
            s.frontFace(2305),
            s.polygonOffset(0, 0),
            s.activeTexture(33984),
            s.bindFramebuffer(36160, null),
            n === !0 &&
              (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)),
            s.useProgram(null),
            s.lineWidth(1),
            s.scissor(0, 0, s.canvas.width, s.canvas.height),
            s.viewport(0, 0, s.canvas.width, s.canvas.height),
            (h = {}),
            (R = null),
            (G = {}),
            (u = null),
            (d = {}),
            (f = null),
            (m = !1),
            (x = null),
            (v = null),
            (p = null),
            (g = null),
            (S = null),
            (L = null),
            (E = null),
            (_ = !1),
            (C = null),
            (F = null),
            (O = null),
            (V = null),
            (W = null),
            se.set(0, 0, s.canvas.width, s.canvas.height),
            ie.set(0, 0, s.canvas.width, s.canvas.height),
            a.reset(),
            l.reset(),
            c.reset();
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: Ce,
          disable: Ee,
          bindFramebuffer: Ge,
          bindXRFramebuffer: H,
          useProgram: Ae,
          setBlending: Se,
          setMaterial: q,
          setFlipSided: j,
          setCullFace: K,
          setLineWidth: he,
          setPolygonOffset: re,
          setScissorTest: w,
          activeTexture: M,
          bindTexture: U,
          unbindTexture: X,
          compressedTexImage2D: te,
          texImage2D: oe,
          texImage3D: ge,
          scissor: pe,
          viewport: Me,
          reset: ce,
        };
      }
      function om(s, e, t, n, i, r, o) {
        const a = i.isWebGL2,
          l = i.maxTextures,
          c = i.maxCubemapSize,
          h = i.maxTextureSize,
          u = i.maxSamples,
          d = new WeakMap();
        let f,
          m = !1;
        try {
          m =
            typeof OffscreenCanvas != "undefined" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function x(w, M) {
          return m
            ? new OffscreenCanvas(w, M)
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
        }
        function v(w, M, U, X) {
          let te = 1;
          if (
            ((w.width > X || w.height > X) &&
              (te = X / Math.max(w.width, w.height)),
            te < 1 || M === !0)
          )
            if (
              (typeof HTMLImageElement != "undefined" &&
                w instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement != "undefined" &&
                w instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap != "undefined" && w instanceof ImageBitmap)
            ) {
              const oe = M ? Va : Math.floor,
                ge = oe(te * w.width),
                pe = oe(te * w.height);
              f === void 0 && (f = x(ge, pe));
              const Me = U ? x(ge, pe) : f;
              return (
                (Me.width = ge),
                (Me.height = pe),
                Me.getContext("2d").drawImage(w, 0, 0, ge, pe),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    w.width +
                    "x" +
                    w.height +
                    ") to (" +
                    ge +
                    "x" +
                    pe +
                    ")."
                ),
                Me
              );
            } else
              return (
                "data" in w &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      w.width +
                      "x" +
                      w.height +
                      ")."
                  ),
                w
              );
          return w;
        }
        function p(w) {
          return vs(w.width) && vs(w.height);
        }
        function g(w) {
          return a
            ? !1
            : w.wrapS !== dt ||
                w.wrapT !== dt ||
                (w.minFilter !== $e && w.minFilter !== ft);
        }
        function S(w, M) {
          return (
            w.generateMipmaps && M && w.minFilter !== $e && w.minFilter !== ft
          );
        }
        function L(w, M, U, X) {
          s.generateMipmap(w);
          const te = n.get(M);
          te.__maxMipLevel = Math.log2(Math.max(U, X));
        }
        function E(w, M, U) {
          if (a === !1) return M;
          if (w !== null) {
            if (s[w] !== void 0) return s[w];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                w +
                "'"
            );
          }
          let X = M;
          return (
            M === 6403 &&
              (U === 5126 && (X = 33326),
              U === 5131 && (X = 33325),
              U === 5121 && (X = 33321)),
            M === 6407 &&
              (U === 5126 && (X = 34837),
              U === 5131 && (X = 34843),
              U === 5121 && (X = 32849)),
            M === 6408 &&
              (U === 5126 && (X = 34836),
              U === 5131 && (X = 34842),
              U === 5121 && (X = 32856)),
            (X === 33325 || X === 33326 || X === 34842 || X === 34836) &&
              e.get("EXT_color_buffer_float"),
            X
          );
        }
        function _(w) {
          return w === $e || w === gs || w === xs ? 9728 : 9729;
        }
        function C(w) {
          const M = w.target;
          M.removeEventListener("dispose", C),
            O(M),
            M.isVideoTexture && d.delete(M),
            o.memory.textures--;
        }
        function F(w) {
          const M = w.target;
          M.removeEventListener("dispose", F), V(M);
        }
        function O(w) {
          const M = n.get(w);
          M.__webglInit !== void 0 &&
            (s.deleteTexture(M.__webglTexture), n.remove(w));
        }
        function V(w) {
          const M = w.texture,
            U = n.get(w),
            X = n.get(M);
          if (!!w) {
            if (
              (X.__webglTexture !== void 0 &&
                (s.deleteTexture(X.__webglTexture), o.memory.textures--),
              w.depthTexture && w.depthTexture.dispose(),
              w.isWebGLCubeRenderTarget)
            )
              for (let te = 0; te < 6; te++)
                s.deleteFramebuffer(U.__webglFramebuffer[te]),
                  U.__webglDepthbuffer &&
                    s.deleteRenderbuffer(U.__webglDepthbuffer[te]);
            else
              s.deleteFramebuffer(U.__webglFramebuffer),
                U.__webglDepthbuffer &&
                  s.deleteRenderbuffer(U.__webglDepthbuffer),
                U.__webglMultisampledFramebuffer &&
                  s.deleteFramebuffer(U.__webglMultisampledFramebuffer),
                U.__webglColorRenderbuffer &&
                  s.deleteRenderbuffer(U.__webglColorRenderbuffer),
                U.__webglDepthRenderbuffer &&
                  s.deleteRenderbuffer(U.__webglDepthRenderbuffer);
            if (w.isWebGLMultipleRenderTargets)
              for (let te = 0, oe = M.length; te < oe; te++) {
                const ge = n.get(M[te]);
                ge.__webglTexture &&
                  (s.deleteTexture(ge.__webglTexture), o.memory.textures--),
                  n.remove(M[te]);
              }
            n.remove(M), n.remove(w);
          }
        }
        let W = 0;
        function z() {
          W = 0;
        }
        function T() {
          const w = W;
          return (
            w >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  w +
                  " texture units while this GPU supports only " +
                  l
              ),
            (W += 1),
            w
          );
        }
        function I(w, M) {
          const U = n.get(w);
          if (
            (w.isVideoTexture && q(w),
            w.version > 0 && U.__version !== w.version)
          ) {
            const X = w.image;
            if (X === void 0)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else if (X.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              ye(U, w, M);
              return;
            }
          }
          t.activeTexture(33984 + M), t.bindTexture(3553, U.__webglTexture);
        }
        function P(w, M) {
          const U = n.get(w);
          if (w.version > 0 && U.__version !== w.version) {
            ye(U, w, M);
            return;
          }
          t.activeTexture(33984 + M), t.bindTexture(35866, U.__webglTexture);
        }
        function R(w, M) {
          const U = n.get(w);
          if (w.version > 0 && U.__version !== w.version) {
            ye(U, w, M);
            return;
          }
          t.activeTexture(33984 + M), t.bindTexture(32879, U.__webglTexture);
        }
        function G(w, M) {
          const U = n.get(w);
          if (w.version > 0 && U.__version !== w.version) {
            ve(U, w, M);
            return;
          }
          t.activeTexture(33984 + M), t.bindTexture(34067, U.__webglTexture);
        }
        const ee = { [Hn]: 10497, [dt]: 33071, [vr]: 33648 },
          Z = {
            [$e]: 9728,
            [gs]: 9984,
            [xs]: 9986,
            [ft]: 9729,
            [Ua]: 9985,
            [Xn]: 9987,
          };
        function se(w, M, U) {
          if (
            (U
              ? (s.texParameteri(w, 10242, ee[M.wrapS]),
                s.texParameteri(w, 10243, ee[M.wrapT]),
                (w === 32879 || w === 35866) &&
                  s.texParameteri(w, 32882, ee[M.wrapR]),
                s.texParameteri(w, 10240, Z[M.magFilter]),
                s.texParameteri(w, 10241, Z[M.minFilter]))
              : (s.texParameteri(w, 10242, 33071),
                s.texParameteri(w, 10243, 33071),
                (w === 32879 || w === 35866) &&
                  s.texParameteri(w, 32882, 33071),
                (M.wrapS !== dt || M.wrapT !== dt) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                s.texParameteri(w, 10240, _(M.magFilter)),
                s.texParameteri(w, 10241, _(M.minFilter)),
                M.minFilter !== $e &&
                  M.minFilter !== ft &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            const X = e.get("EXT_texture_filter_anisotropic");
            if (
              (M.type === Qt && e.has("OES_texture_float_linear") === !1) ||
              (a === !1 &&
                M.type === yr &&
                e.has("OES_texture_half_float_linear") === !1)
            )
              return;
            (M.anisotropy > 1 || n.get(M).__currentAnisotropy) &&
              (s.texParameterf(
                w,
                X.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(M.anisotropy, i.getMaxAnisotropy())
              ),
              (n.get(M).__currentAnisotropy = M.anisotropy));
          }
        }
        function ie(w, M) {
          w.__webglInit === void 0 &&
            ((w.__webglInit = !0),
            M.addEventListener("dispose", C),
            (w.__webglTexture = s.createTexture()),
            o.memory.textures++);
        }
        function ye(w, M, U) {
          let X = 3553;
          M.isDataTexture2DArray && (X = 35866),
            M.isDataTexture3D && (X = 32879),
            ie(w, M),
            t.activeTexture(33984 + U),
            t.bindTexture(X, w.__webglTexture),
            s.pixelStorei(37440, M.flipY),
            s.pixelStorei(37441, M.premultiplyAlpha),
            s.pixelStorei(3317, M.unpackAlignment),
            s.pixelStorei(37443, 0);
          const te = g(M) && p(M.image) === !1,
            oe = v(M.image, te, !1, h),
            ge = p(oe) || a,
            pe = r.convert(M.format);
          let Me = r.convert(M.type),
            ce = E(M.internalFormat, pe, Me);
          se(X, M, ge);
          let A;
          const J = M.mipmaps;
          if (M.isDepthTexture)
            (ce = 6402),
              a
                ? M.type === Qt
                  ? (ce = 36012)
                  : M.type === xr
                  ? (ce = 33190)
                  : M.type === yi
                  ? (ce = 35056)
                  : (ce = 33189)
                : M.type === Qt &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              M.format === zn &&
                ce === 6402 &&
                M.type !== _r &&
                M.type !== xr &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (M.type = _r),
                (Me = r.convert(M.type))),
              M.format === Ei &&
                ce === 6402 &&
                ((ce = 34041),
                M.type !== yi &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (M.type = yi),
                  (Me = r.convert(M.type)))),
              t.texImage2D(3553, 0, ce, oe.width, oe.height, 0, pe, Me, null);
          else if (M.isDataTexture)
            if (J.length > 0 && ge) {
              for (let k = 0, ue = J.length; k < ue; k++)
                (A = J[k]),
                  t.texImage2D(
                    3553,
                    k,
                    ce,
                    A.width,
                    A.height,
                    0,
                    pe,
                    Me,
                    A.data
                  );
              (M.generateMipmaps = !1), (w.__maxMipLevel = J.length - 1);
            } else
              t.texImage2D(
                3553,
                0,
                ce,
                oe.width,
                oe.height,
                0,
                pe,
                Me,
                oe.data
              ),
                (w.__maxMipLevel = 0);
          else if (M.isCompressedTexture) {
            for (let k = 0, ue = J.length; k < ue; k++)
              (A = J[k]),
                M.format !== Et && M.format !== tn
                  ? pe !== null
                    ? t.compressedTexImage2D(
                        3553,
                        k,
                        ce,
                        A.width,
                        A.height,
                        0,
                        A.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : t.texImage2D(
                      3553,
                      k,
                      ce,
                      A.width,
                      A.height,
                      0,
                      pe,
                      Me,
                      A.data
                    );
            w.__maxMipLevel = J.length - 1;
          } else if (M.isDataTexture2DArray)
            t.texImage3D(
              35866,
              0,
              ce,
              oe.width,
              oe.height,
              oe.depth,
              0,
              pe,
              Me,
              oe.data
            ),
              (w.__maxMipLevel = 0);
          else if (M.isDataTexture3D)
            t.texImage3D(
              32879,
              0,
              ce,
              oe.width,
              oe.height,
              oe.depth,
              0,
              pe,
              Me,
              oe.data
            ),
              (w.__maxMipLevel = 0);
          else if (J.length > 0 && ge) {
            for (let k = 0, ue = J.length; k < ue; k++)
              (A = J[k]), t.texImage2D(3553, k, ce, pe, Me, A);
            (M.generateMipmaps = !1), (w.__maxMipLevel = J.length - 1);
          } else t.texImage2D(3553, 0, ce, pe, Me, oe), (w.__maxMipLevel = 0);
          S(M, ge) && L(X, M, oe.width, oe.height),
            (w.__version = M.version),
            M.onUpdate && M.onUpdate(M);
        }
        function ve(w, M, U) {
          if (M.image.length !== 6) return;
          ie(w, M),
            t.activeTexture(33984 + U),
            t.bindTexture(34067, w.__webglTexture),
            s.pixelStorei(37440, M.flipY),
            s.pixelStorei(37441, M.premultiplyAlpha),
            s.pixelStorei(3317, M.unpackAlignment),
            s.pixelStorei(37443, 0);
          const X =
              M && (M.isCompressedTexture || M.image[0].isCompressedTexture),
            te = M.image[0] && M.image[0].isDataTexture,
            oe = [];
          for (let k = 0; k < 6; k++)
            !X && !te
              ? (oe[k] = v(M.image[k], !1, !0, c))
              : (oe[k] = te ? M.image[k].image : M.image[k]);
          const ge = oe[0],
            pe = p(ge) || a,
            Me = r.convert(M.format),
            ce = r.convert(M.type),
            A = E(M.internalFormat, Me, ce);
          se(34067, M, pe);
          let J;
          if (X) {
            for (let k = 0; k < 6; k++) {
              J = oe[k].mipmaps;
              for (let ue = 0; ue < J.length; ue++) {
                const ne = J[ue];
                M.format !== Et && M.format !== tn
                  ? Me !== null
                    ? t.compressedTexImage2D(
                        34069 + k,
                        ue,
                        A,
                        ne.width,
                        ne.height,
                        0,
                        ne.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                      )
                  : t.texImage2D(
                      34069 + k,
                      ue,
                      A,
                      ne.width,
                      ne.height,
                      0,
                      Me,
                      ce,
                      ne.data
                    );
              }
            }
            w.__maxMipLevel = J.length - 1;
          } else {
            J = M.mipmaps;
            for (let k = 0; k < 6; k++)
              if (te) {
                t.texImage2D(
                  34069 + k,
                  0,
                  A,
                  oe[k].width,
                  oe[k].height,
                  0,
                  Me,
                  ce,
                  oe[k].data
                );
                for (let ue = 0; ue < J.length; ue++) {
                  const Ue = J[ue].image[k].image;
                  t.texImage2D(
                    34069 + k,
                    ue + 1,
                    A,
                    Ue.width,
                    Ue.height,
                    0,
                    Me,
                    ce,
                    Ue.data
                  );
                }
              } else {
                t.texImage2D(34069 + k, 0, A, Me, ce, oe[k]);
                for (let ue = 0; ue < J.length; ue++) {
                  const ne = J[ue];
                  t.texImage2D(34069 + k, ue + 1, A, Me, ce, ne.image[k]);
                }
              }
            w.__maxMipLevel = J.length;
          }
          S(M, pe) && L(34067, M, ge.width, ge.height),
            (w.__version = M.version),
            M.onUpdate && M.onUpdate(M);
        }
        function Ce(w, M, U, X, te) {
          const oe = r.convert(U.format),
            ge = r.convert(U.type),
            pe = E(U.internalFormat, oe, ge);
          te === 32879 || te === 35866
            ? t.texImage3D(
                te,
                0,
                pe,
                M.width,
                M.height,
                M.depth,
                0,
                oe,
                ge,
                null
              )
            : t.texImage2D(te, 0, pe, M.width, M.height, 0, oe, ge, null),
            t.bindFramebuffer(36160, w),
            s.framebufferTexture2D(36160, X, te, n.get(U).__webglTexture, 0),
            t.bindFramebuffer(36160, null);
        }
        function Ee(w, M, U) {
          if (
            (s.bindRenderbuffer(36161, w), M.depthBuffer && !M.stencilBuffer)
          ) {
            let X = 33189;
            if (U) {
              const te = M.depthTexture;
              te &&
                te.isDepthTexture &&
                (te.type === Qt ? (X = 36012) : te.type === xr && (X = 33190));
              const oe = Se(M);
              s.renderbufferStorageMultisample(36161, oe, X, M.width, M.height);
            } else s.renderbufferStorage(36161, X, M.width, M.height);
            s.framebufferRenderbuffer(36160, 36096, 36161, w);
          } else if (M.depthBuffer && M.stencilBuffer) {
            if (U) {
              const X = Se(M);
              s.renderbufferStorageMultisample(
                36161,
                X,
                35056,
                M.width,
                M.height
              );
            } else s.renderbufferStorage(36161, 34041, M.width, M.height);
            s.framebufferRenderbuffer(36160, 33306, 36161, w);
          } else {
            const X =
                M.isWebGLMultipleRenderTargets === !0
                  ? M.texture[0]
                  : M.texture,
              te = r.convert(X.format),
              oe = r.convert(X.type),
              ge = E(X.internalFormat, te, oe);
            if (U) {
              const pe = Se(M);
              s.renderbufferStorageMultisample(
                36161,
                pe,
                ge,
                M.width,
                M.height
              );
            } else s.renderbufferStorage(36161, ge, M.width, M.height);
          }
          s.bindRenderbuffer(36161, null);
        }
        function H(w, M) {
          if (M && M.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(36160, w),
            !(M.depthTexture && M.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(M.depthTexture).__webglTexture ||
            M.depthTexture.image.width !== M.width ||
            M.depthTexture.image.height !== M.height) &&
            ((M.depthTexture.image.width = M.width),
            (M.depthTexture.image.height = M.height),
            (M.depthTexture.needsUpdate = !0)),
            I(M.depthTexture, 0);
          const X = n.get(M.depthTexture).__webglTexture;
          if (M.depthTexture.format === zn)
            s.framebufferTexture2D(36160, 36096, 3553, X, 0);
          else if (M.depthTexture.format === Ei)
            s.framebufferTexture2D(36160, 33306, 3553, X, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Ge(w) {
          const M = n.get(w),
            U = w.isWebGLCubeRenderTarget === !0;
          if (w.depthTexture) {
            if (U)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            H(M.__webglFramebuffer, w);
          } else if (U) {
            M.__webglDepthbuffer = [];
            for (let X = 0; X < 6; X++)
              t.bindFramebuffer(36160, M.__webglFramebuffer[X]),
                (M.__webglDepthbuffer[X] = s.createRenderbuffer()),
                Ee(M.__webglDepthbuffer[X], w, !1);
          } else
            t.bindFramebuffer(36160, M.__webglFramebuffer),
              (M.__webglDepthbuffer = s.createRenderbuffer()),
              Ee(M.__webglDepthbuffer, w, !1);
          t.bindFramebuffer(36160, null);
        }
        function Ae(w) {
          const M = w.texture,
            U = n.get(w),
            X = n.get(M);
          w.addEventListener("dispose", F),
            w.isWebGLMultipleRenderTargets !== !0 &&
              ((X.__webglTexture = s.createTexture()),
              (X.__version = M.version),
              o.memory.textures++);
          const te = w.isWebGLCubeRenderTarget === !0,
            oe = w.isWebGLMultipleRenderTargets === !0,
            ge = w.isWebGLMultisampleRenderTarget === !0,
            pe = M.isDataTexture3D || M.isDataTexture2DArray,
            Me = p(w) || a;
          if (
            (a &&
              M.format === tn &&
              (M.type === Qt || M.type === yr) &&
              ((M.format = Et),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            te)
          ) {
            U.__webglFramebuffer = [];
            for (let ce = 0; ce < 6; ce++)
              U.__webglFramebuffer[ce] = s.createFramebuffer();
          } else if (((U.__webglFramebuffer = s.createFramebuffer()), oe))
            if (i.drawBuffers) {
              const ce = w.texture;
              for (let A = 0, J = ce.length; A < J; A++) {
                const k = n.get(ce[A]);
                k.__webglTexture === void 0 &&
                  ((k.__webglTexture = s.createTexture()), o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (ge)
            if (a) {
              (U.__webglMultisampledFramebuffer = s.createFramebuffer()),
                (U.__webglColorRenderbuffer = s.createRenderbuffer()),
                s.bindRenderbuffer(36161, U.__webglColorRenderbuffer);
              const ce = r.convert(M.format),
                A = r.convert(M.type),
                J = E(M.internalFormat, ce, A),
                k = Se(w);
              s.renderbufferStorageMultisample(36161, k, J, w.width, w.height),
                t.bindFramebuffer(36160, U.__webglMultisampledFramebuffer),
                s.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  U.__webglColorRenderbuffer
                ),
                s.bindRenderbuffer(36161, null),
                w.depthBuffer &&
                  ((U.__webglDepthRenderbuffer = s.createRenderbuffer()),
                  Ee(U.__webglDepthRenderbuffer, w, !0)),
                t.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (te) {
            t.bindTexture(34067, X.__webglTexture), se(34067, M, Me);
            for (let ce = 0; ce < 6; ce++)
              Ce(U.__webglFramebuffer[ce], w, M, 36064, 34069 + ce);
            S(M, Me) && L(34067, M, w.width, w.height),
              t.bindTexture(34067, null);
          } else if (oe) {
            const ce = w.texture;
            for (let A = 0, J = ce.length; A < J; A++) {
              const k = ce[A],
                ue = n.get(k);
              t.bindTexture(3553, ue.__webglTexture),
                se(3553, k, Me),
                Ce(U.__webglFramebuffer, w, k, 36064 + A, 3553),
                S(k, Me) && L(3553, k, w.width, w.height);
            }
            t.bindTexture(3553, null);
          } else {
            let ce = 3553;
            pe &&
              (a
                ? (ce = M.isDataTexture3D ? 32879 : 35866)
                : console.warn(
                    "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                  )),
              t.bindTexture(ce, X.__webglTexture),
              se(ce, M, Me),
              Ce(U.__webglFramebuffer, w, M, 36064, ce),
              S(M, Me) && L(3553, M, w.width, w.height),
              t.bindTexture(3553, null);
          }
          w.depthBuffer && Ge(w);
        }
        function _e(w) {
          const M = p(w) || a,
            U = w.isWebGLMultipleRenderTargets === !0 ? w.texture : [w.texture];
          for (let X = 0, te = U.length; X < te; X++) {
            const oe = U[X];
            if (S(oe, M)) {
              const ge = w.isWebGLCubeRenderTarget ? 34067 : 3553,
                pe = n.get(oe).__webglTexture;
              t.bindTexture(ge, pe),
                L(ge, oe, w.width, w.height),
                t.bindTexture(ge, null);
            }
          }
        }
        function fe(w) {
          if (w.isWebGLMultisampleRenderTarget)
            if (a) {
              const M = w.width,
                U = w.height;
              let X = 16384;
              w.depthBuffer && (X |= 256), w.stencilBuffer && (X |= 1024);
              const te = n.get(w);
              t.bindFramebuffer(36008, te.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, te.__webglFramebuffer),
                s.blitFramebuffer(0, 0, M, U, 0, 0, M, U, X, 9728),
                t.bindFramebuffer(36008, null),
                t.bindFramebuffer(36009, te.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }
        function Se(w) {
          return a && w.isWebGLMultisampleRenderTarget
            ? Math.min(u, w.samples)
            : 0;
        }
        function q(w) {
          const M = o.render.frame;
          d.get(w) !== M && (d.set(w, M), w.update());
        }
        let j = !1,
          K = !1;
        function he(w, M) {
          w &&
            w.isWebGLRenderTarget &&
            (j === !1 &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (j = !0)),
            (w = w.texture)),
            I(w, M);
        }
        function re(w, M) {
          w &&
            w.isWebGLCubeRenderTarget &&
            (K === !1 &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (K = !0)),
            (w = w.texture)),
            G(w, M);
        }
        (this.allocateTextureUnit = T),
          (this.resetTextureUnits = z),
          (this.setTexture2D = I),
          (this.setTexture2DArray = P),
          (this.setTexture3D = R),
          (this.setTextureCube = G),
          (this.setupRenderTarget = Ae),
          (this.updateRenderTargetMipmap = _e),
          (this.updateMultisampleRenderTarget = fe),
          (this.safeSetTexture2D = he),
          (this.safeSetTextureCube = re);
      }
      function am(s, e, t) {
        const n = t.isWebGL2;
        function i(r) {
          let o;
          if (r === Is) return 5121;
          if (r === Mc) return 32819;
          if (r === wc) return 32820;
          if (r === bc) return 33635;
          if (r === vc) return 5120;
          if (r === _c) return 5122;
          if (r === _r) return 5123;
          if (r === yc) return 5124;
          if (r === xr) return 5125;
          if (r === Qt) return 5126;
          if (r === yr)
            return n
              ? 5131
              : ((o = e.get("OES_texture_half_float")),
                o !== null ? o.HALF_FLOAT_OES : null);
          if (r === Sc) return 6406;
          if (r === tn) return 6407;
          if (r === Et) return 6408;
          if (r === Tc) return 6409;
          if (r === Ec) return 6410;
          if (r === zn) return 6402;
          if (r === Ei) return 34041;
          if (r === Ac) return 6403;
          if (r === Lc) return 36244;
          if (r === Rc) return 33319;
          if (r === Cc) return 33320;
          if (r === Pc) return 36248;
          if (r === Ic) return 36249;
          if (r === xo || r === vo || r === _o || r === yo)
            if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
              if (r === xo) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (r === vo) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (r === _o) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (r === yo) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (r === Mo || r === wo || r === bo || r === So)
            if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
              if (r === Mo) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (r === wo) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (r === bo) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (r === So) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (r === Dc)
            return (
              (o = e.get("WEBGL_compressed_texture_etc1")),
              o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (r === To || r === Eo) &&
            ((o = e.get("WEBGL_compressed_texture_etc")), o !== null)
          ) {
            if (r === To) return o.COMPRESSED_RGB8_ETC2;
            if (r === Eo) return o.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            r === Nc ||
            r === Fc ||
            r === Bc ||
            r === Oc ||
            r === zc ||
            r === Uc ||
            r === Hc ||
            r === Gc ||
            r === kc ||
            r === Vc ||
            r === Wc ||
            r === qc ||
            r === Xc ||
            r === jc ||
            r === Zc ||
            r === Jc ||
            r === Kc ||
            r === Qc ||
            r === $c ||
            r === eh ||
            r === th ||
            r === nh ||
            r === ih ||
            r === rh ||
            r === sh ||
            r === oh ||
            r === ah ||
            r === lh
          )
            return (
              (o = e.get("WEBGL_compressed_texture_astc")),
              o !== null ? r : null
            );
          if (r === Yc)
            return (
              (o = e.get("EXT_texture_compression_bptc")), o !== null ? r : null
            );
          if (r === yi)
            return n
              ? 34042
              : ((o = e.get("WEBGL_depth_texture")),
                o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
        }
        return { convert: i };
      }
      class ll extends lt {
        constructor(e = []) {
          super(), (this.cameras = e);
        }
      }
      ll.prototype.isArrayCamera = !0;
      class en extends Ie {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      en.prototype.isGroup = !0;
      const lm = { type: "move" };
      class os {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new en()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new en()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new b()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new b())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new en()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new b()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new b())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            o = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred")
            if (
              (a !== null &&
                ((i = t.getPose(e.targetRaySpace, n)),
                i !== null &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(lm))),
              c && e.hand)
            ) {
              o = !0;
              for (const x of e.hand.values()) {
                const v = t.getJointPose(x, n);
                if (c.joints[x.jointName] === void 0) {
                  const g = new en();
                  (g.matrixAutoUpdate = !1),
                    (g.visible = !1),
                    (c.joints[x.jointName] = g),
                    c.add(g);
                }
                const p = c.joints[x.jointName];
                v !== null &&
                  (p.matrix.fromArray(v.transform.matrix),
                  p.matrix.decompose(p.position, p.rotation, p.scale),
                  (p.jointRadius = v.radius)),
                  (p.visible = v !== null);
              }
              const h = c.joints["index-finger-tip"],
                u = c.joints["thumb-tip"],
                d = h.position.distanceTo(u.position),
                f = 0.02,
                m = 0.005;
              c.inputState.pinching && d > f + m
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  d <= f - m &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              l !== null &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                r !== null &&
                  (l.matrix.fromArray(r.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  r.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(r.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(r.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
          return (
            a !== null && (a.visible = i !== null),
            l !== null && (l.visible = r !== null),
            c !== null && (c.visible = o !== null),
            this
          );
        }
      }
      class cm extends mn {
        constructor(e, t) {
          super();
          const n = this,
            i = e.state;
          let r = null,
            o = 1,
            a = null,
            l = "local-floor",
            c = null;
          const h = [],
            u = new Map(),
            d = new lt();
          d.layers.enable(1), (d.viewport = new Fe());
          const f = new lt();
          f.layers.enable(2), (f.viewport = new Fe());
          const m = [d, f],
            x = new ll();
          x.layers.enable(1), x.layers.enable(2);
          let v = null,
            p = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (z) {
              let T = h[z];
              return (
                T === void 0 && ((T = new os()), (h[z] = T)),
                T.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (z) {
              let T = h[z];
              return (
                T === void 0 && ((T = new os()), (h[z] = T)), T.getGripSpace()
              );
            }),
            (this.getHand = function (z) {
              let T = h[z];
              return (
                T === void 0 && ((T = new os()), (h[z] = T)), T.getHandSpace()
              );
            });
          function g(z) {
            const T = u.get(z.inputSource);
            T && T.dispatchEvent({ type: z.type, data: z.inputSource });
          }
          function S() {
            u.forEach(function (z, T) {
              z.disconnect(T);
            }),
              u.clear(),
              (v = null),
              (p = null),
              i.bindXRFramebuffer(null),
              e.setRenderTarget(e.getRenderTarget()),
              W.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (z) {
            (o = z),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (z) {
              (l = z),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return a;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = async function (z) {
              if (((r = z), r !== null)) {
                r.addEventListener("select", g),
                  r.addEventListener("selectstart", g),
                  r.addEventListener("selectend", g),
                  r.addEventListener("squeeze", g),
                  r.addEventListener("squeezestart", g),
                  r.addEventListener("squeezeend", g),
                  r.addEventListener("end", S),
                  r.addEventListener("inputsourceschange", L);
                const T = t.getContextAttributes();
                T.xrCompatible !== !0 && (await t.makeXRCompatible());
                const I = {
                    antialias: T.antialias,
                    alpha: T.alpha,
                    depth: T.depth,
                    stencil: T.stencil,
                    framebufferScaleFactor: o,
                  },
                  P = new XRWebGLLayer(r, t, I);
                r.updateRenderState({ baseLayer: P }),
                  (a = await r.requestReferenceSpace(l)),
                  W.setContext(r),
                  W.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          function L(z) {
            const T = r.inputSources;
            for (let I = 0; I < h.length; I++) u.set(T[I], h[I]);
            for (let I = 0; I < z.removed.length; I++) {
              const P = z.removed[I],
                R = u.get(P);
              R &&
                (R.dispatchEvent({ type: "disconnected", data: P }),
                u.delete(P));
            }
            for (let I = 0; I < z.added.length; I++) {
              const P = z.added[I],
                R = u.get(P);
              R && R.dispatchEvent({ type: "connected", data: P });
            }
          }
          const E = new b(),
            _ = new b();
          function C(z, T, I) {
            E.setFromMatrixPosition(T.matrixWorld),
              _.setFromMatrixPosition(I.matrixWorld);
            const P = E.distanceTo(_),
              R = T.projectionMatrix.elements,
              G = I.projectionMatrix.elements,
              ee = R[14] / (R[10] - 1),
              Z = R[14] / (R[10] + 1),
              se = (R[9] + 1) / R[5],
              ie = (R[9] - 1) / R[5],
              ye = (R[8] - 1) / R[0],
              ve = (G[8] + 1) / G[0],
              Ce = ee * ye,
              Ee = ee * ve,
              H = P / (-ye + ve),
              Ge = H * -ye;
            T.matrixWorld.decompose(z.position, z.quaternion, z.scale),
              z.translateX(Ge),
              z.translateZ(H),
              z.matrixWorld.compose(z.position, z.quaternion, z.scale),
              z.matrixWorldInverse.copy(z.matrixWorld).invert();
            const Ae = ee + H,
              _e = Z + H,
              fe = Ce - Ge,
              Se = Ee + (P - Ge),
              q = ((se * Z) / _e) * Ae,
              j = ((ie * Z) / _e) * Ae;
            z.projectionMatrix.makePerspective(fe, Se, q, j, Ae, _e);
          }
          function F(z, T) {
            T === null
              ? z.matrixWorld.copy(z.matrix)
              : z.matrixWorld.multiplyMatrices(T.matrixWorld, z.matrix),
              z.matrixWorldInverse.copy(z.matrixWorld).invert();
          }
          (this.updateCamera = function (z) {
            if (r === null) return;
            (x.near = f.near = d.near = z.near),
              (x.far = f.far = d.far = z.far),
              (v !== x.near || p !== x.far) &&
                (r.updateRenderState({ depthNear: x.near, depthFar: x.far }),
                (v = x.near),
                (p = x.far));
            const T = z.parent,
              I = x.cameras;
            F(x, T);
            for (let R = 0; R < I.length; R++) F(I[R], T);
            z.matrixWorld.copy(x.matrixWorld),
              z.matrix.copy(x.matrix),
              z.matrix.decompose(z.position, z.quaternion, z.scale);
            const P = z.children;
            for (let R = 0, G = P.length; R < G; R++)
              P[R].updateMatrixWorld(!0);
            I.length === 2
              ? C(x, d, f)
              : x.projectionMatrix.copy(d.projectionMatrix);
          }),
            (this.getCamera = function () {
              return x;
            });
          let O = null;
          function V(z, T) {
            if (((c = T.getViewerPose(a)), c !== null)) {
              const P = c.views,
                R = r.renderState.baseLayer;
              i.bindXRFramebuffer(R.framebuffer);
              let G = !1;
              P.length !== x.cameras.length &&
                ((x.cameras.length = 0), (G = !0));
              for (let ee = 0; ee < P.length; ee++) {
                const Z = P[ee],
                  se = R.getViewport(Z),
                  ie = m[ee];
                ie.matrix.fromArray(Z.transform.matrix),
                  ie.projectionMatrix.fromArray(Z.projectionMatrix),
                  ie.viewport.set(se.x, se.y, se.width, se.height),
                  ee === 0 && x.matrix.copy(ie.matrix),
                  G === !0 && x.cameras.push(ie);
              }
            }
            const I = r.inputSources;
            for (let P = 0; P < h.length; P++) {
              const R = h[P],
                G = I[P];
              R.update(G, T, a);
            }
            O && O(z, T);
          }
          const W = new Za();
          W.setAnimationLoop(V),
            (this.setAnimationLoop = function (z) {
              O = z;
            }),
            (this.dispose = function () {});
        }
      }
      function hm(s) {
        function e(p, g) {
          p.fogColor.value.copy(g.color),
            g.isFog
              ? ((p.fogNear.value = g.near), (p.fogFar.value = g.far))
              : g.isFogExp2 && (p.fogDensity.value = g.density);
        }
        function t(p, g, S, L, E) {
          g.isMeshBasicMaterial
            ? n(p, g)
            : g.isMeshLambertMaterial
            ? (n(p, g), l(p, g))
            : g.isMeshToonMaterial
            ? (n(p, g), h(p, g))
            : g.isMeshPhongMaterial
            ? (n(p, g), c(p, g))
            : g.isMeshStandardMaterial
            ? (n(p, g), g.isMeshPhysicalMaterial ? d(p, g, E) : u(p, g))
            : g.isMeshMatcapMaterial
            ? (n(p, g), f(p, g))
            : g.isMeshDepthMaterial
            ? (n(p, g), m(p, g))
            : g.isMeshDistanceMaterial
            ? (n(p, g), x(p, g))
            : g.isMeshNormalMaterial
            ? (n(p, g), v(p, g))
            : g.isLineBasicMaterial
            ? (i(p, g), g.isLineDashedMaterial && r(p, g))
            : g.isPointsMaterial
            ? o(p, g, S, L)
            : g.isSpriteMaterial
            ? a(p, g)
            : g.isShadowMaterial
            ? (p.color.value.copy(g.color), (p.opacity.value = g.opacity))
            : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
        }
        function n(p, g) {
          (p.opacity.value = g.opacity),
            g.color && p.diffuse.value.copy(g.color),
            g.emissive &&
              p.emissive.value
                .copy(g.emissive)
                .multiplyScalar(g.emissiveIntensity),
            g.map && (p.map.value = g.map),
            g.alphaMap && (p.alphaMap.value = g.alphaMap),
            g.specularMap && (p.specularMap.value = g.specularMap);
          const S = s.get(g).envMap;
          if (S) {
            (p.envMap.value = S),
              (p.flipEnvMap.value =
                S.isCubeTexture && S._needsFlipEnvMap ? -1 : 1),
              (p.reflectivity.value = g.reflectivity),
              (p.refractionRatio.value = g.refractionRatio);
            const _ = s.get(S).__maxMipLevel;
            _ !== void 0 && (p.maxMipLevel.value = _);
          }
          g.lightMap &&
            ((p.lightMap.value = g.lightMap),
            (p.lightMapIntensity.value = g.lightMapIntensity)),
            g.aoMap &&
              ((p.aoMap.value = g.aoMap),
              (p.aoMapIntensity.value = g.aoMapIntensity));
          let L;
          g.map
            ? (L = g.map)
            : g.specularMap
            ? (L = g.specularMap)
            : g.displacementMap
            ? (L = g.displacementMap)
            : g.normalMap
            ? (L = g.normalMap)
            : g.bumpMap
            ? (L = g.bumpMap)
            : g.roughnessMap
            ? (L = g.roughnessMap)
            : g.metalnessMap
            ? (L = g.metalnessMap)
            : g.alphaMap
            ? (L = g.alphaMap)
            : g.emissiveMap
            ? (L = g.emissiveMap)
            : g.clearcoatMap
            ? (L = g.clearcoatMap)
            : g.clearcoatNormalMap
            ? (L = g.clearcoatNormalMap)
            : g.clearcoatRoughnessMap && (L = g.clearcoatRoughnessMap),
            L !== void 0 &&
              (L.isWebGLRenderTarget && (L = L.texture),
              L.matrixAutoUpdate === !0 && L.updateMatrix(),
              p.uvTransform.value.copy(L.matrix));
          let E;
          g.aoMap ? (E = g.aoMap) : g.lightMap && (E = g.lightMap),
            E !== void 0 &&
              (E.isWebGLRenderTarget && (E = E.texture),
              E.matrixAutoUpdate === !0 && E.updateMatrix(),
              p.uv2Transform.value.copy(E.matrix));
        }
        function i(p, g) {
          p.diffuse.value.copy(g.color), (p.opacity.value = g.opacity);
        }
        function r(p, g) {
          (p.dashSize.value = g.dashSize),
            (p.totalSize.value = g.dashSize + g.gapSize),
            (p.scale.value = g.scale);
        }
        function o(p, g, S, L) {
          p.diffuse.value.copy(g.color),
            (p.opacity.value = g.opacity),
            (p.size.value = g.size * S),
            (p.scale.value = L * 0.5),
            g.map && (p.map.value = g.map),
            g.alphaMap && (p.alphaMap.value = g.alphaMap);
          let E;
          g.map ? (E = g.map) : g.alphaMap && (E = g.alphaMap),
            E !== void 0 &&
              (E.matrixAutoUpdate === !0 && E.updateMatrix(),
              p.uvTransform.value.copy(E.matrix));
        }
        function a(p, g) {
          p.diffuse.value.copy(g.color),
            (p.opacity.value = g.opacity),
            (p.rotation.value = g.rotation),
            g.map && (p.map.value = g.map),
            g.alphaMap && (p.alphaMap.value = g.alphaMap);
          let S;
          g.map ? (S = g.map) : g.alphaMap && (S = g.alphaMap),
            S !== void 0 &&
              (S.matrixAutoUpdate === !0 && S.updateMatrix(),
              p.uvTransform.value.copy(S.matrix));
        }
        function l(p, g) {
          g.emissiveMap && (p.emissiveMap.value = g.emissiveMap);
        }
        function c(p, g) {
          p.specular.value.copy(g.specular),
            (p.shininess.value = Math.max(g.shininess, 1e-4)),
            g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
            g.bumpMap &&
              ((p.bumpMap.value = g.bumpMap),
              (p.bumpScale.value = g.bumpScale),
              g.side === Ze && (p.bumpScale.value *= -1)),
            g.normalMap &&
              ((p.normalMap.value = g.normalMap),
              p.normalScale.value.copy(g.normalScale),
              g.side === Ze && p.normalScale.value.negate()),
            g.displacementMap &&
              ((p.displacementMap.value = g.displacementMap),
              (p.displacementScale.value = g.displacementScale),
              (p.displacementBias.value = g.displacementBias));
        }
        function h(p, g) {
          g.gradientMap && (p.gradientMap.value = g.gradientMap),
            g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
            g.bumpMap &&
              ((p.bumpMap.value = g.bumpMap),
              (p.bumpScale.value = g.bumpScale),
              g.side === Ze && (p.bumpScale.value *= -1)),
            g.normalMap &&
              ((p.normalMap.value = g.normalMap),
              p.normalScale.value.copy(g.normalScale),
              g.side === Ze && p.normalScale.value.negate()),
            g.displacementMap &&
              ((p.displacementMap.value = g.displacementMap),
              (p.displacementScale.value = g.displacementScale),
              (p.displacementBias.value = g.displacementBias));
        }
        function u(p, g) {
          (p.roughness.value = g.roughness),
            (p.metalness.value = g.metalness),
            g.roughnessMap && (p.roughnessMap.value = g.roughnessMap),
            g.metalnessMap && (p.metalnessMap.value = g.metalnessMap),
            g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
            g.bumpMap &&
              ((p.bumpMap.value = g.bumpMap),
              (p.bumpScale.value = g.bumpScale),
              g.side === Ze && (p.bumpScale.value *= -1)),
            g.normalMap &&
              ((p.normalMap.value = g.normalMap),
              p.normalScale.value.copy(g.normalScale),
              g.side === Ze && p.normalScale.value.negate()),
            g.displacementMap &&
              ((p.displacementMap.value = g.displacementMap),
              (p.displacementScale.value = g.displacementScale),
              (p.displacementBias.value = g.displacementBias)),
            s.get(g).envMap && (p.envMapIntensity.value = g.envMapIntensity);
        }
        function d(p, g, S) {
          u(p, g),
            (p.reflectivity.value = g.reflectivity),
            (p.clearcoat.value = g.clearcoat),
            (p.clearcoatRoughness.value = g.clearcoatRoughness),
            g.sheen && p.sheen.value.copy(g.sheen),
            g.clearcoatMap && (p.clearcoatMap.value = g.clearcoatMap),
            g.clearcoatRoughnessMap &&
              (p.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
            g.clearcoatNormalMap &&
              (p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
              (p.clearcoatNormalMap.value = g.clearcoatNormalMap),
              g.side === Ze && p.clearcoatNormalScale.value.negate()),
            (p.transmission.value = g.transmission),
            g.transmissionMap && (p.transmissionMap.value = g.transmissionMap),
            g.transmission > 0 &&
              ((p.transmissionSamplerMap.value = S.texture),
              p.transmissionSamplerSize.value.set(S.width, S.height)),
            (p.thickness.value = g.thickness),
            g.thicknessMap && (p.thicknessMap.value = g.thicknessMap),
            (p.attenuationDistance.value = g.attenuationDistance),
            p.attenuationColor.value.copy(g.attenuationColor);
        }
        function f(p, g) {
          g.matcap && (p.matcap.value = g.matcap),
            g.bumpMap &&
              ((p.bumpMap.value = g.bumpMap),
              (p.bumpScale.value = g.bumpScale),
              g.side === Ze && (p.bumpScale.value *= -1)),
            g.normalMap &&
              ((p.normalMap.value = g.normalMap),
              p.normalScale.value.copy(g.normalScale),
              g.side === Ze && p.normalScale.value.negate()),
            g.displacementMap &&
              ((p.displacementMap.value = g.displacementMap),
              (p.displacementScale.value = g.displacementScale),
              (p.displacementBias.value = g.displacementBias));
        }
        function m(p, g) {
          g.displacementMap &&
            ((p.displacementMap.value = g.displacementMap),
            (p.displacementScale.value = g.displacementScale),
            (p.displacementBias.value = g.displacementBias));
        }
        function x(p, g) {
          g.displacementMap &&
            ((p.displacementMap.value = g.displacementMap),
            (p.displacementScale.value = g.displacementScale),
            (p.displacementBias.value = g.displacementBias)),
            p.referencePosition.value.copy(g.referencePosition),
            (p.nearDistance.value = g.nearDistance),
            (p.farDistance.value = g.farDistance);
        }
        function v(p, g) {
          g.bumpMap &&
            ((p.bumpMap.value = g.bumpMap),
            (p.bumpScale.value = g.bumpScale),
            g.side === Ze && (p.bumpScale.value *= -1)),
            g.normalMap &&
              ((p.normalMap.value = g.normalMap),
              p.normalScale.value.copy(g.normalScale),
              g.side === Ze && p.normalScale.value.negate()),
            g.displacementMap &&
              ((p.displacementMap.value = g.displacementMap),
              (p.displacementScale.value = g.displacementScale),
              (p.displacementBias.value = g.displacementBias));
        }
        return { refreshFogUniforms: e, refreshMaterialUniforms: t };
      }
      function um() {
        const s = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return (s.style.display = "block"), s;
      }
      function Be(s) {
        s = s || {};
        const e = s.canvas !== void 0 ? s.canvas : um(),
          t = s.context !== void 0 ? s.context : null,
          n = s.alpha !== void 0 ? s.alpha : !1,
          i = s.depth !== void 0 ? s.depth : !0,
          r = s.stencil !== void 0 ? s.stencil : !0,
          o = s.antialias !== void 0 ? s.antialias : !1,
          a = s.premultipliedAlpha !== void 0 ? s.premultipliedAlpha : !0,
          l = s.preserveDrawingBuffer !== void 0 ? s.preserveDrawingBuffer : !1,
          c = s.powerPreference !== void 0 ? s.powerPreference : "default",
          h =
            s.failIfMajorPerformanceCaveat !== void 0
              ? s.failIfMajorPerformanceCaveat
              : !1;
        let u = null,
          d = null;
        const f = [],
          m = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = Oi),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = _i),
          (this.toneMappingExposure = 1);
        const x = this;
        let v = !1,
          p = 0,
          g = 0,
          S = null,
          L = -1,
          E = null;
        const _ = new Fe(),
          C = new Fe();
        let F = null,
          O = e.width,
          V = e.height,
          W = 1,
          z = null,
          T = null;
        const I = new Fe(0, 0, O, V),
          P = new Fe(0, 0, O, V);
        let R = !1;
        const G = [],
          ee = new Er();
        let Z = !1,
          se = !1,
          ie = null;
        const ye = new le(),
          ve = new b(),
          Ce = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Ee() {
          return S === null ? W : 1;
        }
        let H = t;
        function Ge(y, N) {
          for (let D = 0; D < y.length; D++) {
            const B = y[D],
              Q = e.getContext(B, N);
            if (Q !== null) return Q;
          }
          return null;
        }
        try {
          const y = {
            alpha: n,
            depth: i,
            stencil: r,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: h,
          };
          if (
            (e.addEventListener("webglcontextlost", Ue, !1),
            e.addEventListener("webglcontextrestored", nt, !1),
            H === null)
          ) {
            const N = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (x.isWebGL1Renderer === !0 && N.shift(),
              (H = Ge(N, y)),
              H === null)
            )
              throw Ge(N)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          H.getShaderPrecisionFormat === void 0 &&
            (H.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (y) {
          throw (console.error("THREE.WebGLRenderer: " + y.message), y);
        }
        let Ae,
          _e,
          fe,
          Se,
          q,
          j,
          K,
          he,
          re,
          w,
          M,
          U,
          X,
          te,
          oe,
          ge,
          pe,
          Me,
          ce,
          A,
          J,
          k;
        function ue() {
          (Ae = new Nf(H)),
            (_e = new Pf(H, Ae, s)),
            Ae.init(_e),
            (J = new am(H, Ae, _e)),
            (fe = new sm(H, Ae, _e)),
            (G[0] = 1029),
            (Se = new Of(H)),
            (q = new Yp()),
            (j = new om(H, Ae, fe, q, _e, J, Se)),
            (K = new Df(x)),
            (he = new ru(H, _e)),
            (k = new Rf(H, Ae, he, _e)),
            (re = new Ff(H, he, Se, k)),
            (w = new Gf(H, re, he, Se)),
            (Me = new Hf(H)),
            (oe = new If(q)),
            (M = new jp(x, K, Ae, _e, k, oe)),
            (U = new hm(q)),
            (X = new Jp(q)),
            (te = new nm(Ae, _e)),
            (pe = new Lf(x, K, fe, w, a)),
            (ge = new al(x, w, _e)),
            (ce = new Cf(H, Ae, Se, _e)),
            (A = new Bf(H, Ae, Se, _e)),
            (Se.programs = M.programs),
            (x.capabilities = _e),
            (x.extensions = Ae),
            (x.properties = q),
            (x.renderLists = X),
            (x.shadowMap = ge),
            (x.state = fe),
            (x.info = Se);
        }
        ue();
        const ne = new cm(x, H);
        (this.xr = ne),
          (this.getContext = function () {
            return H;
          }),
          (this.getContextAttributes = function () {
            return H.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const y = Ae.get("WEBGL_lose_context");
            y && y.loseContext();
          }),
          (this.forceContextRestore = function () {
            const y = Ae.get("WEBGL_lose_context");
            y && y.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return W;
          }),
          (this.setPixelRatio = function (y) {
            y !== void 0 && ((W = y), this.setSize(O, V, !1));
          }),
          (this.getSize = function (y) {
            return (
              y === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                ),
                (y = new Y())),
              y.set(O, V)
            );
          }),
          (this.setSize = function (y, N, D) {
            if (ne.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (O = y),
              (V = N),
              (e.width = Math.floor(y * W)),
              (e.height = Math.floor(N * W)),
              D !== !1 &&
                ((e.style.width = y + "px"), (e.style.height = N + "px")),
              this.setViewport(0, 0, y, N);
          }),
          (this.getDrawingBufferSize = function (y) {
            return (
              y === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                ),
                (y = new Y())),
              y.set(O * W, V * W).floor()
            );
          }),
          (this.setDrawingBufferSize = function (y, N, D) {
            (O = y),
              (V = N),
              (W = D),
              (e.width = Math.floor(y * D)),
              (e.height = Math.floor(N * D)),
              this.setViewport(0, 0, y, N);
          }),
          (this.getCurrentViewport = function (y) {
            return (
              y === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                ),
                (y = new Fe())),
              y.copy(_)
            );
          }),
          (this.getViewport = function (y) {
            return y.copy(I);
          }),
          (this.setViewport = function (y, N, D, B) {
            y.isVector4 ? I.set(y.x, y.y, y.z, y.w) : I.set(y, N, D, B),
              fe.viewport(_.copy(I).multiplyScalar(W).floor());
          }),
          (this.getScissor = function (y) {
            return y.copy(P);
          }),
          (this.setScissor = function (y, N, D, B) {
            y.isVector4 ? P.set(y.x, y.y, y.z, y.w) : P.set(y, N, D, B),
              fe.scissor(C.copy(P).multiplyScalar(W).floor());
          }),
          (this.getScissorTest = function () {
            return R;
          }),
          (this.setScissorTest = function (y) {
            fe.setScissorTest((R = y));
          }),
          (this.setOpaqueSort = function (y) {
            z = y;
          }),
          (this.setTransparentSort = function (y) {
            T = y;
          }),
          (this.getClearColor = function (y) {
            return (
              y === void 0 &&
                (console.warn(
                  "WebGLRenderer: .getClearColor() now requires a Color as an argument"
                ),
                (y = new ae())),
              y.copy(pe.getClearColor())
            );
          }),
          (this.setClearColor = function () {
            pe.setClearColor.apply(pe, arguments);
          }),
          (this.getClearAlpha = function () {
            return pe.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            pe.setClearAlpha.apply(pe, arguments);
          }),
          (this.clear = function (y, N, D) {
            let B = 0;
            (y === void 0 || y) && (B |= 16384),
              (N === void 0 || N) && (B |= 256),
              (D === void 0 || D) && (B |= 1024),
              H.clear(B);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", Ue, !1),
              e.removeEventListener("webglcontextrestored", nt, !1),
              X.dispose(),
              te.dispose(),
              q.dispose(),
              K.dispose(),
              w.dispose(),
              k.dispose(),
              ne.dispose(),
              ne.removeEventListener("sessionstart", no),
              ne.removeEventListener("sessionend", io),
              ie && (ie.dispose(), (ie = null)),
              an.stop();
          });
        function Ue(y) {
          y.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (v = !0);
        }
        function nt() {
          console.log("THREE.WebGLRenderer: Context Restored."), (v = !1);
          const y = Se.autoReset,
            N = ge.enabled,
            D = ge.autoUpdate,
            B = ge.needsUpdate,
            Q = ge.type;
          ue(),
            (Se.autoReset = y),
            (ge.enabled = N),
            (ge.autoUpdate = D),
            (ge.needsUpdate = B),
            (ge.type = Q);
        }
        function it(y) {
          const N = y.target;
          N.removeEventListener("dispose", it), on(N);
        }
        function on(y) {
          Ve(y), q.remove(y);
        }
        function Ve(y) {
          const N = q.get(y).programs;
          N !== void 0 &&
            N.forEach(function (D) {
              M.releaseProgram(D);
            });
        }
        function It(y, N) {
          y.render(function (D) {
            x.renderBufferImmediate(D, N);
          });
        }
        (this.renderBufferImmediate = function (y, N) {
          k.initAttributes();
          const D = q.get(y);
          y.hasPositions && !D.position && (D.position = H.createBuffer()),
            y.hasNormals && !D.normal && (D.normal = H.createBuffer()),
            y.hasUvs && !D.uv && (D.uv = H.createBuffer()),
            y.hasColors && !D.color && (D.color = H.createBuffer());
          const B = N.getAttributes();
          y.hasPositions &&
            (H.bindBuffer(34962, D.position),
            H.bufferData(34962, y.positionArray, 35048),
            k.enableAttribute(B.position),
            H.vertexAttribPointer(B.position, 3, 5126, !1, 0, 0)),
            y.hasNormals &&
              (H.bindBuffer(34962, D.normal),
              H.bufferData(34962, y.normalArray, 35048),
              k.enableAttribute(B.normal),
              H.vertexAttribPointer(B.normal, 3, 5126, !1, 0, 0)),
            y.hasUvs &&
              (H.bindBuffer(34962, D.uv),
              H.bufferData(34962, y.uvArray, 35048),
              k.enableAttribute(B.uv),
              H.vertexAttribPointer(B.uv, 2, 5126, !1, 0, 0)),
            y.hasColors &&
              (H.bindBuffer(34962, D.color),
              H.bufferData(34962, y.colorArray, 35048),
              k.enableAttribute(B.color),
              H.vertexAttribPointer(B.color, 3, 5126, !1, 0, 0)),
            k.disableUnusedAttributes(),
            H.drawArrays(4, 0, y.count),
            (y.count = 0);
        }),
          (this.renderBufferDirect = function (y, N, D, B, Q, Re) {
            N === null && (N = Ce);
            const we = Q.isMesh && Q.matrixWorld.determinant() < 0,
              me = ao(y, N, B, Q);
            fe.setMaterial(B, we);
            let Te = D.index;
            const de = D.attributes.position;
            if (Te === null) {
              if (de === void 0 || de.count === 0) return;
            } else if (Te.count === 0) return;
            let Le = 1;
            B.wireframe === !0 &&
              ((Te = re.getWireframeAttribute(D)), (Le = 2)),
              (B.morphTargets || B.morphNormals) && Me.update(Q, D, B, me),
              k.setup(Q, B, me, D, Te);
            let xe,
              Ne = ce;
            Te !== null && ((xe = he.get(Te)), (Ne = A), Ne.setIndex(xe));
            const At = Te !== null ? Te.count : de.count,
              at = D.drawRange.start * Le,
              ln = D.drawRange.count * Le,
              je = Re !== null ? Re.start * Le : 0,
              cn = Re !== null ? Re.count * Le : 1 / 0,
              rt = Math.max(at, je),
              Gl = Math.min(At, at + ln, je + cn) - 1,
              Hi = Math.max(0, Gl - rt + 1);
            if (Hi !== 0) {
              if (Q.isMesh)
                B.wireframe === !0
                  ? (fe.setLineWidth(B.wireframeLinewidth * Ee()),
                    Ne.setMode(1))
                  : Ne.setMode(4);
              else if (Q.isLine) {
                let ni = B.linewidth;
                ni === void 0 && (ni = 1),
                  fe.setLineWidth(ni * Ee()),
                  Q.isLineSegments
                    ? Ne.setMode(1)
                    : Q.isLineLoop
                    ? Ne.setMode(2)
                    : Ne.setMode(3);
              } else Q.isPoints ? Ne.setMode(0) : Q.isSprite && Ne.setMode(4);
              if (Q.isInstancedMesh) Ne.renderInstances(rt, Hi, Q.count);
              else if (D.isInstancedBufferGeometry) {
                const ni = Math.min(D.instanceCount, D._maxInstanceCount);
                Ne.renderInstances(rt, Hi, ni);
              } else Ne.render(rt, Hi);
            }
          }),
          (this.compile = function (y, N) {
            (d = te.get(y)),
              d.init(),
              y.traverseVisible(function (D) {
                D.isLight &&
                  D.layers.test(N.layers) &&
                  (d.pushLight(D), D.castShadow && d.pushShadow(D));
              }),
              d.setupLights(),
              y.traverse(function (D) {
                const B = D.material;
                if (B)
                  if (Array.isArray(B))
                    for (let Q = 0; Q < B.length; Q++) {
                      const Re = B[Q];
                      Dr(Re, y, D);
                    }
                  else Dr(B, y, D);
              });
          });
        let Mt = null;
        function Ol(y) {
          Mt && Mt(y);
        }
        function no() {
          an.stop();
        }
        function io() {
          an.start();
        }
        const an = new Za();
        an.setAnimationLoop(Ol),
          typeof window != "undefined" && an.setContext(window),
          (this.setAnimationLoop = function (y) {
            (Mt = y),
              ne.setAnimationLoop(y),
              y === null ? an.stop() : an.start();
          }),
          ne.addEventListener("sessionstart", no),
          ne.addEventListener("sessionend", io),
          (this.render = function (y, N) {
            if (N !== void 0 && N.isCamera !== !0) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (v === !0) return;
            y.autoUpdate === !0 && y.updateMatrixWorld(),
              N.parent === null && N.updateMatrixWorld(),
              ne.enabled === !0 &&
                ne.isPresenting === !0 &&
                (ne.cameraAutoUpdate === !0 && ne.updateCamera(N),
                (N = ne.getCamera())),
              y.isScene === !0 && y.onBeforeRender(x, y, N, S),
              (d = te.get(y, m.length)),
              d.init(),
              m.push(d),
              ye.multiplyMatrices(N.projectionMatrix, N.matrixWorldInverse),
              ee.setFromProjectionMatrix(ye),
              (se = this.localClippingEnabled),
              (Z = oe.init(this.clippingPlanes, se, N)),
              (u = X.get(y, f.length)),
              u.init(),
              f.push(u),
              ro(y, N, 0, x.sortObjects),
              u.finish(),
              x.sortObjects === !0 && u.sort(z, T),
              Z === !0 && oe.beginShadows();
            const D = d.state.shadowsArray;
            ge.render(D, y, N),
              d.setupLights(),
              d.setupLightsView(N),
              Z === !0 && oe.endShadows(),
              this.info.autoReset === !0 && this.info.reset(),
              pe.render(u, y);
            const B = u.opaque,
              Q = u.transmissive,
              Re = u.transparent;
            B.length > 0 && Ui(B, y, N),
              Q.length > 0 && zl(B, Q, y, N),
              Re.length > 0 && Ui(Re, y, N),
              S !== null &&
                (j.updateRenderTargetMipmap(S),
                j.updateMultisampleRenderTarget(S)),
              y.isScene === !0 && y.onAfterRender(x, y, N),
              fe.buffers.depth.setTest(!0),
              fe.buffers.depth.setMask(!0),
              fe.buffers.color.setMask(!0),
              fe.setPolygonOffset(!1),
              k.resetDefaultState(),
              (L = -1),
              (E = null),
              m.pop(),
              m.length > 0 ? (d = m[m.length - 1]) : (d = null),
              f.pop(),
              f.length > 0 ? (u = f[f.length - 1]) : (u = null);
          });
        function ro(y, N, D, B) {
          if (y.visible === !1) return;
          if (y.layers.test(N.layers)) {
            if (y.isGroup) D = y.renderOrder;
            else if (y.isLOD) y.autoUpdate === !0 && y.update(N);
            else if (y.isLight) d.pushLight(y), y.castShadow && d.pushShadow(y);
            else if (y.isSprite) {
              if (!y.frustumCulled || ee.intersectsSprite(y)) {
                B && ve.setFromMatrixPosition(y.matrixWorld).applyMatrix4(ye);
                const we = w.update(y),
                  me = y.material;
                me.visible && u.push(y, we, me, D, ve.z, null);
              }
            } else if (y.isImmediateRenderObject)
              B && ve.setFromMatrixPosition(y.matrixWorld).applyMatrix4(ye),
                u.push(y, null, y.material, D, ve.z, null);
            else if (
              (y.isMesh || y.isLine || y.isPoints) &&
              (y.isSkinnedMesh &&
                y.skeleton.frame !== Se.render.frame &&
                (y.skeleton.update(), (y.skeleton.frame = Se.render.frame)),
              !y.frustumCulled || ee.intersectsObject(y))
            ) {
              B && ve.setFromMatrixPosition(y.matrixWorld).applyMatrix4(ye);
              const we = w.update(y),
                me = y.material;
              if (Array.isArray(me)) {
                const Te = we.groups;
                for (let de = 0, Le = Te.length; de < Le; de++) {
                  const xe = Te[de],
                    Ne = me[xe.materialIndex];
                  Ne && Ne.visible && u.push(y, we, Ne, D, ve.z, xe);
                }
              } else me.visible && u.push(y, we, me, D, ve.z, null);
            }
          }
          const Re = y.children;
          for (let we = 0, me = Re.length; we < me; we++) ro(Re[we], N, D, B);
        }
        function zl(y, N, D, B) {
          ie === null &&
            (ie = new Ht(1024, 1024, {
              generateMipmaps: !0,
              minFilter: Xn,
              magFilter: $e,
              wrapS: dt,
              wrapT: dt,
            }));
          const Q = x.getRenderTarget();
          x.setRenderTarget(ie),
            x.clear(),
            Ui(y, D, B),
            j.updateRenderTargetMipmap(ie),
            x.setRenderTarget(Q),
            Ui(N, D, B);
        }
        function Ui(y, N, D) {
          const B = N.isScene === !0 ? N.overrideMaterial : null;
          for (let Q = 0, Re = y.length; Q < Re; Q++) {
            const we = y[Q],
              me = we.object,
              Te = we.geometry,
              de = B === null ? we.material : B,
              Le = we.group;
            if (D.isArrayCamera) {
              const xe = D.cameras;
              for (let Ne = 0, At = xe.length; Ne < At; Ne++) {
                const at = xe[Ne];
                me.layers.test(at.layers) &&
                  (fe.viewport(_.copy(at.viewport)),
                  d.setupLightsView(at),
                  so(me, N, at, Te, de, Le));
              }
            } else so(me, N, D, Te, de, Le);
          }
        }
        function so(y, N, D, B, Q, Re) {
          if (
            (y.onBeforeRender(x, N, D, B, Q, Re),
            y.modelViewMatrix.multiplyMatrices(
              D.matrixWorldInverse,
              y.matrixWorld
            ),
            y.normalMatrix.getNormalMatrix(y.modelViewMatrix),
            y.isImmediateRenderObject)
          ) {
            const we = ao(D, N, Q, y);
            fe.setMaterial(Q), k.reset(), It(y, we);
          } else x.renderBufferDirect(D, N, B, Q, y, Re);
          y.onAfterRender(x, N, D, B, Q, Re);
        }
        function Dr(y, N, D) {
          N.isScene !== !0 && (N = Ce);
          const B = q.get(y),
            Q = d.state.lights,
            Re = d.state.shadowsArray,
            we = Q.state.version,
            me = M.getParameters(y, Q.state, Re, N, D),
            Te = M.getProgramCacheKey(me);
          let de = B.programs;
          (B.environment = y.isMeshStandardMaterial ? N.environment : null),
            (B.fog = N.fog),
            (B.envMap = K.get(y.envMap || B.environment)),
            de === void 0 &&
              (y.addEventListener("dispose", it),
              (de = new Map()),
              (B.programs = de));
          let Le = de.get(Te);
          if (Le !== void 0) {
            if (B.currentProgram === Le && B.lightsStateVersion === we)
              return oo(y, me), Le;
          } else
            (me.uniforms = M.getUniforms(y)),
              y.onBuild(me, x),
              y.onBeforeCompile(me, x),
              (Le = M.acquireProgram(me, Te)),
              de.set(Te, Le),
              (B.uniforms = me.uniforms);
          const xe = B.uniforms;
          ((!y.isShaderMaterial && !y.isRawShaderMaterial) ||
            y.clipping === !0) &&
            (xe.clippingPlanes = oe.uniform),
            oo(y, me),
            (B.needsLights = Hl(y)),
            (B.lightsStateVersion = we),
            B.needsLights &&
              ((xe.ambientLightColor.value = Q.state.ambient),
              (xe.lightProbe.value = Q.state.probe),
              (xe.directionalLights.value = Q.state.directional),
              (xe.directionalLightShadows.value = Q.state.directionalShadow),
              (xe.spotLights.value = Q.state.spot),
              (xe.spotLightShadows.value = Q.state.spotShadow),
              (xe.rectAreaLights.value = Q.state.rectArea),
              (xe.ltc_1.value = Q.state.rectAreaLTC1),
              (xe.ltc_2.value = Q.state.rectAreaLTC2),
              (xe.pointLights.value = Q.state.point),
              (xe.pointLightShadows.value = Q.state.pointShadow),
              (xe.hemisphereLights.value = Q.state.hemi),
              (xe.directionalShadowMap.value = Q.state.directionalShadowMap),
              (xe.directionalShadowMatrix.value =
                Q.state.directionalShadowMatrix),
              (xe.spotShadowMap.value = Q.state.spotShadowMap),
              (xe.spotShadowMatrix.value = Q.state.spotShadowMatrix),
              (xe.pointShadowMap.value = Q.state.pointShadowMap),
              (xe.pointShadowMatrix.value = Q.state.pointShadowMatrix));
          const Ne = Le.getUniforms(),
            At = nn.seqWithValue(Ne.seq, xe);
          return (B.currentProgram = Le), (B.uniformsList = At), Le;
        }
        function oo(y, N) {
          const D = q.get(y);
          (D.outputEncoding = N.outputEncoding),
            (D.instancing = N.instancing),
            (D.skinning = N.skinning),
            (D.numClippingPlanes = N.numClippingPlanes),
            (D.numIntersection = N.numClipIntersection),
            (D.vertexAlphas = N.vertexAlphas);
        }
        function ao(y, N, D, B) {
          N.isScene !== !0 && (N = Ce), j.resetTextureUnits();
          const Q = N.fog,
            Re = D.isMeshStandardMaterial ? N.environment : null,
            we = S === null ? x.outputEncoding : S.texture.encoding,
            me = K.get(D.envMap || Re),
            Te =
              D.vertexColors === !0 &&
              B.geometry &&
              B.geometry.attributes.color &&
              B.geometry.attributes.color.itemSize === 4,
            de = q.get(D),
            Le = d.state.lights;
          if (Z === !0 && (se === !0 || y !== E)) {
            const rt = y === E && D.id === L;
            oe.setState(D, y, rt);
          }
          let xe = !1;
          D.version === de.__version
            ? ((de.needsLights && de.lightsStateVersion !== Le.state.version) ||
                de.outputEncoding !== we ||
                (B.isInstancedMesh && de.instancing === !1) ||
                (!B.isInstancedMesh && de.instancing === !0) ||
                (B.isSkinnedMesh && de.skinning === !1) ||
                (!B.isSkinnedMesh && de.skinning === !0) ||
                de.envMap !== me ||
                (D.fog && de.fog !== Q) ||
                (de.numClippingPlanes !== void 0 &&
                  (de.numClippingPlanes !== oe.numPlanes ||
                    de.numIntersection !== oe.numIntersection)) ||
                de.vertexAlphas !== Te) &&
              (xe = !0)
            : ((xe = !0), (de.__version = D.version));
          let Ne = de.currentProgram;
          xe === !0 && (Ne = Dr(D, N, B));
          let At = !1,
            at = !1,
            ln = !1;
          const je = Ne.getUniforms(),
            cn = de.uniforms;
          if (
            (fe.useProgram(Ne.program) && ((At = !0), (at = !0), (ln = !0)),
            D.id !== L && ((L = D.id), (at = !0)),
            At || E !== y)
          ) {
            if (
              (je.setValue(H, "projectionMatrix", y.projectionMatrix),
              _e.logarithmicDepthBuffer &&
                je.setValue(
                  H,
                  "logDepthBufFC",
                  2 / (Math.log(y.far + 1) / Math.LN2)
                ),
              E !== y && ((E = y), (at = !0), (ln = !0)),
              D.isShaderMaterial ||
                D.isMeshPhongMaterial ||
                D.isMeshToonMaterial ||
                D.isMeshStandardMaterial ||
                D.envMap)
            ) {
              const rt = je.map.cameraPosition;
              rt !== void 0 &&
                rt.setValue(H, ve.setFromMatrixPosition(y.matrixWorld));
            }
            (D.isMeshPhongMaterial ||
              D.isMeshToonMaterial ||
              D.isMeshLambertMaterial ||
              D.isMeshBasicMaterial ||
              D.isMeshStandardMaterial ||
              D.isShaderMaterial) &&
              je.setValue(H, "isOrthographic", y.isOrthographicCamera === !0),
              (D.isMeshPhongMaterial ||
                D.isMeshToonMaterial ||
                D.isMeshLambertMaterial ||
                D.isMeshBasicMaterial ||
                D.isMeshStandardMaterial ||
                D.isShaderMaterial ||
                D.isShadowMaterial ||
                B.isSkinnedMesh) &&
                je.setValue(H, "viewMatrix", y.matrixWorldInverse);
          }
          if (B.isSkinnedMesh) {
            je.setOptional(H, B, "bindMatrix"),
              je.setOptional(H, B, "bindMatrixInverse");
            const rt = B.skeleton;
            rt &&
              (_e.floatVertexTextures
                ? (rt.boneTexture === null && rt.computeBoneTexture(),
                  je.setValue(H, "boneTexture", rt.boneTexture, j),
                  je.setValue(H, "boneTextureSize", rt.boneTextureSize))
                : je.setOptional(H, rt, "boneMatrices"));
          }
          return (
            (at || de.receiveShadow !== B.receiveShadow) &&
              ((de.receiveShadow = B.receiveShadow),
              je.setValue(H, "receiveShadow", B.receiveShadow)),
            at &&
              (je.setValue(H, "toneMappingExposure", x.toneMappingExposure),
              de.needsLights && Ul(cn, ln),
              Q && D.fog && U.refreshFogUniforms(cn, Q),
              U.refreshMaterialUniforms(cn, D, W, V, ie),
              nn.upload(H, de.uniformsList, cn, j)),
            D.isShaderMaterial &&
              D.uniformsNeedUpdate === !0 &&
              (nn.upload(H, de.uniformsList, cn, j),
              (D.uniformsNeedUpdate = !1)),
            D.isSpriteMaterial && je.setValue(H, "center", B.center),
            je.setValue(H, "modelViewMatrix", B.modelViewMatrix),
            je.setValue(H, "normalMatrix", B.normalMatrix),
            je.setValue(H, "modelMatrix", B.matrixWorld),
            Ne
          );
        }
        function Ul(y, N) {
          (y.ambientLightColor.needsUpdate = N),
            (y.lightProbe.needsUpdate = N),
            (y.directionalLights.needsUpdate = N),
            (y.directionalLightShadows.needsUpdate = N),
            (y.pointLights.needsUpdate = N),
            (y.pointLightShadows.needsUpdate = N),
            (y.spotLights.needsUpdate = N),
            (y.spotLightShadows.needsUpdate = N),
            (y.rectAreaLights.needsUpdate = N),
            (y.hemisphereLights.needsUpdate = N);
        }
        function Hl(y) {
          return (
            y.isMeshLambertMaterial ||
            y.isMeshToonMaterial ||
            y.isMeshPhongMaterial ||
            y.isMeshStandardMaterial ||
            y.isShadowMaterial ||
            (y.isShaderMaterial && y.lights === !0)
          );
        }
        (this.getActiveCubeFace = function () {
          return p;
        }),
          (this.getActiveMipmapLevel = function () {
            return g;
          }),
          (this.getRenderTarget = function () {
            return S;
          }),
          (this.setRenderTarget = function (y, N = 0, D = 0) {
            (S = y),
              (p = N),
              (g = D),
              y &&
                q.get(y).__webglFramebuffer === void 0 &&
                j.setupRenderTarget(y);
            let B = null,
              Q = !1,
              Re = !1;
            if (y) {
              const me = y.texture;
              (me.isDataTexture3D || me.isDataTexture2DArray) && (Re = !0);
              const Te = q.get(y).__webglFramebuffer;
              y.isWebGLCubeRenderTarget
                ? ((B = Te[N]), (Q = !0))
                : y.isWebGLMultisampleRenderTarget
                ? (B = q.get(y).__webglMultisampledFramebuffer)
                : (B = Te),
                _.copy(y.viewport),
                C.copy(y.scissor),
                (F = y.scissorTest);
            } else
              _.copy(I).multiplyScalar(W).floor(),
                C.copy(P).multiplyScalar(W).floor(),
                (F = R);
            if (fe.bindFramebuffer(36160, B) && _e.drawBuffers) {
              let me = !1;
              if (y)
                if (y.isWebGLMultipleRenderTargets) {
                  const Te = y.texture;
                  if (G.length !== Te.length || G[0] !== 36064) {
                    for (let de = 0, Le = Te.length; de < Le; de++)
                      G[de] = 36064 + de;
                    (G.length = Te.length), (me = !0);
                  }
                } else
                  (G.length !== 1 || G[0] !== 36064) &&
                    ((G[0] = 36064), (G.length = 1), (me = !0));
              else
                (G.length !== 1 || G[0] !== 1029) &&
                  ((G[0] = 1029), (G.length = 1), (me = !0));
              me &&
                (_e.isWebGL2
                  ? H.drawBuffers(G)
                  : Ae.get("WEBGL_draw_buffers").drawBuffersWEBGL(G));
            }
            if ((fe.viewport(_), fe.scissor(C), fe.setScissorTest(F), Q)) {
              const me = q.get(y.texture);
              H.framebufferTexture2D(
                36160,
                36064,
                34069 + N,
                me.__webglTexture,
                D
              );
            } else if (Re) {
              const me = q.get(y.texture),
                Te = N || 0;
              H.framebufferTextureLayer(
                36160,
                36064,
                me.__webglTexture,
                D || 0,
                Te
              );
            }
          }),
          (this.readRenderTargetPixels = function (y, N, D, B, Q, Re, we) {
            if (!(y && y.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let me = q.get(y).__webglFramebuffer;
            if (
              (y.isWebGLCubeRenderTarget && we !== void 0 && (me = me[we]), me)
            ) {
              fe.bindFramebuffer(36160, me);
              try {
                const Te = y.texture,
                  de = Te.format,
                  Le = Te.type;
                if (de !== Et && J.convert(de) !== H.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                const xe =
                  Le === yr &&
                  (Ae.has("EXT_color_buffer_half_float") ||
                    (_e.isWebGL2 && Ae.has("EXT_color_buffer_float")));
                if (
                  Le !== Is &&
                  J.convert(Le) !== H.getParameter(35738) &&
                  !(
                    Le === Qt &&
                    (_e.isWebGL2 ||
                      Ae.has("OES_texture_float") ||
                      Ae.has("WEBGL_color_buffer_float"))
                  ) &&
                  !xe
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                H.checkFramebufferStatus(36160) === 36053
                  ? N >= 0 &&
                    N <= y.width - B &&
                    D >= 0 &&
                    D <= y.height - Q &&
                    H.readPixels(N, D, B, Q, J.convert(de), J.convert(Le), Re)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                const Te = S !== null ? q.get(S).__webglFramebuffer : null;
                fe.bindFramebuffer(36160, Te);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (y, N, D = 0) {
            const B = Math.pow(2, -D),
              Q = Math.floor(N.image.width * B),
              Re = Math.floor(N.image.height * B);
            let we = J.convert(N.format);
            _e.isWebGL2 &&
              (we === 6407 && (we = 32849), we === 6408 && (we = 32856)),
              j.setTexture2D(N, 0),
              H.copyTexImage2D(3553, D, we, y.x, y.y, Q, Re, 0),
              fe.unbindTexture();
          }),
          (this.copyTextureToTexture = function (y, N, D, B = 0) {
            const Q = N.image.width,
              Re = N.image.height,
              we = J.convert(D.format),
              me = J.convert(D.type);
            j.setTexture2D(D, 0),
              H.pixelStorei(37440, D.flipY),
              H.pixelStorei(37441, D.premultiplyAlpha),
              H.pixelStorei(3317, D.unpackAlignment),
              N.isDataTexture
                ? H.texSubImage2D(
                    3553,
                    B,
                    y.x,
                    y.y,
                    Q,
                    Re,
                    we,
                    me,
                    N.image.data
                  )
                : N.isCompressedTexture
                ? H.compressedTexSubImage2D(
                    3553,
                    B,
                    y.x,
                    y.y,
                    N.mipmaps[0].width,
                    N.mipmaps[0].height,
                    we,
                    N.mipmaps[0].data
                  )
                : H.texSubImage2D(3553, B, y.x, y.y, we, me, N.image),
              B === 0 && D.generateMipmaps && H.generateMipmap(3553),
              fe.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (y, N, D, B, Q = 0) {
            if (x.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            const { width: Re, height: we, data: me } = D.image,
              Te = J.convert(B.format),
              de = J.convert(B.type);
            let Le;
            if (B.isDataTexture3D) j.setTexture3D(B, 0), (Le = 32879);
            else if (B.isDataTexture2DArray)
              j.setTexture2DArray(B, 0), (Le = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            H.pixelStorei(37440, B.flipY),
              H.pixelStorei(37441, B.premultiplyAlpha),
              H.pixelStorei(3317, B.unpackAlignment);
            const xe = H.getParameter(3314),
              Ne = H.getParameter(32878),
              At = H.getParameter(3316),
              at = H.getParameter(3315),
              ln = H.getParameter(32877);
            H.pixelStorei(3314, Re),
              H.pixelStorei(32878, we),
              H.pixelStorei(3316, y.min.x),
              H.pixelStorei(3315, y.min.y),
              H.pixelStorei(32877, y.min.z),
              H.texSubImage3D(
                Le,
                Q,
                N.x,
                N.y,
                N.z,
                y.max.x - y.min.x + 1,
                y.max.y - y.min.y + 1,
                y.max.z - y.min.z + 1,
                Te,
                de,
                me
              ),
              H.pixelStorei(3314, xe),
              H.pixelStorei(32878, Ne),
              H.pixelStorei(3316, At),
              H.pixelStorei(3315, at),
              H.pixelStorei(32877, ln),
              Q === 0 && B.generateMipmaps && H.generateMipmap(Le),
              fe.unbindTexture();
          }),
          (this.initTexture = function (y) {
            j.setTexture2D(y, 0), fe.unbindTexture();
          }),
          (this.resetState = function () {
            (p = 0), (g = 0), (S = null), fe.reset(), k.reset();
          }),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      class dm extends Be {}
      dm.prototype.isWebGL1Renderer = !0;
      class zs extends Ie {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ != "undefined" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
              (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            this.background !== null &&
              (t.object.background = this.background.toJSON(e)),
            this.environment !== null &&
              (t.object.environment = this.environment.toJSON(e)),
            this.fog !== null && (t.object.fog = this.fog.toJSON()),
            t
          );
        }
      }
      zs.prototype.isScene = !0;
      class Kn {
        constructor(e, t) {
          (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = Li),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = vt());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = vt()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = vt()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Kn.prototype.isInterleavedBuffer = !0;
      const We = new b();
      class Vn {
        constructor(e, t, n, i) {
          (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i === !0);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            (We.x = this.getX(t)),
              (We.y = this.getY(t)),
              (We.z = this.getZ(t)),
              We.applyMatrix4(e),
              this.setXYZ(t, We.x, We.y, We.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (We.x = this.getX(t)),
              (We.y = this.getY(t)),
              (We.z = this.getZ(t)),
              We.applyNormalMatrix(e),
              this.setXYZ(t, We.x, We.y, We.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            (We.x = this.getX(t)),
              (We.y = this.getY(t)),
              (We.z = this.getZ(t)),
              We.transformDirection(e),
              this.setXYZ(t, We.x, We.y, We.z);
          return this;
        }
        setX(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset] = t), this
          );
        }
        setY(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 1] = t), this
          );
        }
        setZ(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 2] = t), this
          );
        }
        setW(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 3] = t), this
          );
        }
        getX(e) {
          return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
          return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
          return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
          return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return new Xe(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Vn(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++)
                t.push(this.data.array[i + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
        }
      }
      Vn.prototype.isInterleavedBufferAttribute = !0;
      class cl extends Ke {
        constructor(e) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new ae(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
          );
        }
      }
      cl.prototype.isSpriteMaterial = !0;
      let Cn;
      const li = new b(),
        Pn = new b(),
        In = new b(),
        Dn = new Y(),
        ci = new Y(),
        hl = new le(),
        sr = new b(),
        hi = new b(),
        or = new b(),
        ea = new Y(),
        as = new Y(),
        ta = new Y();
      class fm extends Ie {
        constructor(e) {
          if ((super(), (this.type = "Sprite"), Cn === void 0)) {
            Cn = new ze();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              n = new Kn(t, 5);
            Cn.setIndex([0, 1, 2, 0, 2, 3]),
              Cn.setAttribute("position", new Vn(n, 3, 0, !1)),
              Cn.setAttribute("uv", new Vn(n, 2, 3, !1));
          }
          (this.geometry = Cn),
            (this.material = e !== void 0 ? e : new cl()),
            (this.center = new Y(0.5, 0.5));
        }
        raycast(e, t) {
          e.camera === null &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Pn.setFromMatrixScale(this.matrixWorld),
            hl.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            In.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              this.material.sizeAttenuation === !1 &&
              Pn.multiplyScalar(-In.z);
          const n = this.material.rotation;
          let i, r;
          n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
          const o = this.center;
          ar(sr.set(-0.5, -0.5, 0), In, o, Pn, i, r),
            ar(hi.set(0.5, -0.5, 0), In, o, Pn, i, r),
            ar(or.set(0.5, 0.5, 0), In, o, Pn, i, r),
            ea.set(0, 0),
            as.set(1, 0),
            ta.set(1, 1);
          let a = e.ray.intersectTriangle(sr, hi, or, !1, li);
          if (
            a === null &&
            (ar(hi.set(-0.5, 0.5, 0), In, o, Pn, i, r),
            as.set(0, 1),
            (a = e.ray.intersectTriangle(sr, or, hi, !1, li)),
            a === null)
          )
            return;
          const l = e.ray.origin.distanceTo(li);
          l < e.near ||
            l > e.far ||
            t.push({
              distance: l,
              point: li.clone(),
              uv: qe.getUV(li, sr, hi, or, ea, as, ta, new Y()),
              face: null,
              object: this,
            });
        }
        copy(e) {
          return (
            super.copy(e),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        }
      }
      fm.prototype.isSprite = !0;
      function ar(s, e, t, n, i, r) {
        Dn.subVectors(s, t).addScalar(0.5).multiply(n),
          i !== void 0
            ? ((ci.x = r * Dn.x - i * Dn.y), (ci.y = i * Dn.x + r * Dn.y))
            : ci.copy(Dn),
          s.copy(e),
          (s.x += ci.x),
          (s.y += ci.y),
          s.applyMatrix4(hl);
      }
      const na = new b(),
        ia = new Fe(),
        ra = new Fe(),
        pm = new b(),
        sa = new le();
      class Us extends _t {
        constructor(e, t) {
          super(e, t),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new le()),
            (this.bindMatrixInverse = new le());
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new Fe(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            (e.x = t.getX(n)),
              (e.y = t.getY(n)),
              (e.z = t.getZ(n)),
              (e.w = t.getW(n));
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === "attached"
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === "detached"
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          ia.fromBufferAttribute(i.attributes.skinIndex, e),
            ra.fromBufferAttribute(i.attributes.skinWeight, e),
            na
              .fromBufferAttribute(i.attributes.position, e)
              .applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const o = ra.getComponent(r);
            if (o !== 0) {
              const a = ia.getComponent(r);
              sa.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(pm.copy(na).applyMatrix4(sa), o);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      Us.prototype.isSkinnedMesh = !0;
      class Hs extends Ie {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      Hs.prototype.isBone = !0;
      class ul extends tt {
        constructor(e, t, n, i, r, o, a, l, c, h, u, d) {
          super(null, o, a, l, c, h, i, r, u, d),
            (this.image = { data: e || null, width: t || 1, height: n || 1 }),
            (this.magFilter = c !== void 0 ? c : $e),
            (this.minFilter = h !== void 0 ? h : $e),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      ul.prototype.isDataTexture = !0;
      const oa = new le(),
        mm = new le();
      class Gs {
        constructor(e = [], t = []) {
          (this.uuid = vt()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(e.length * 16)),
            t.length === 0)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let n = 0, i = this.bones.length; n < i; n++)
              this.boneInverses.push(new le());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new le();
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(n);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n &&
              (n.parent && n.parent.isBone
                ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                  n.matrix.multiply(n.matrixWorld))
                : n.matrix.copy(n.matrixWorld),
              n.matrix.decompose(n.position, n.quaternion, n.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let r = 0, o = e.length; r < o; r++) {
            const a = e[r] ? e[r].matrixWorld : mm;
            oa.multiplyMatrices(a, t[r]), oa.toArray(n, r * 16);
          }
          i !== null && (i.needsUpdate = !0);
        }
        clone() {
          return new Gs(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          (e = ka(e)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new ul(t, e, e, Et, Qt);
          return (
            (this.boneMatrices = t),
            (this.boneTexture = n),
            (this.boneTextureSize = e),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e) return i;
          }
        }
        dispose() {
          this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const r = e.bones[n];
            let o = t[r];
            o === void 0 &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", r),
              (o = new Hs())),
              this.bones.push(o),
              this.boneInverses.push(new le().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray());
          }
          return e;
        }
      }
      const aa = new le(),
        la = new le(),
        lr = [],
        ui = new _t();
      class gm extends _t {
        constructor(e, t, n) {
          super(e, t),
            (this.instanceMatrix = new Xe(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(e) {
          return (
            super.copy(e),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((ui.geometry = this.geometry),
            (ui.material = this.material),
            ui.material !== void 0)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, aa),
                la.multiplyMatrices(n, aa),
                (ui.matrixWorld = la),
                ui.raycast(e, lr);
              for (let o = 0, a = lr.length; o < a; o++) {
                const l = lr[o];
                (l.instanceId = r), (l.object = this), t.push(l);
              }
              lr.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null &&
            (this.instanceColor = new Xe(new Float32Array(this.count * 3), 3)),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      gm.prototype.isInstancedMesh = !0;
      class Qn extends Ke {
        constructor(e) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new ae(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      Qn.prototype.isLineBasicMaterial = !0;
      const ca = new b(),
        ha = new b(),
        ua = new le(),
        ls = new Yn(),
        cr = new gn();
      class Ar extends Ie {
        constructor(e = new ze(), t = new Qn()) {
          super(),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [0];
              for (let i = 1, r = t.count; i < r; i++)
                ca.fromBufferAttribute(t, i - 1),
                  ha.fromBufferAttribute(t, i),
                  (n[i] = n[i - 1]),
                  (n[i] += ca.distanceTo(ha));
              e.setAttribute("lineDistance", new Je(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            cr.copy(n.boundingSphere),
            cr.applyMatrix4(i),
            (cr.radius += r),
            e.ray.intersectsSphere(cr) === !1)
          )
            return;
          ua.copy(i).invert(), ls.copy(e.ray).applyMatrix4(ua);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new b(),
            h = new b(),
            u = new b(),
            d = new b(),
            f = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const m = n.index,
              v = n.attributes.position;
            if (m !== null) {
              const p = Math.max(0, o.start),
                g = Math.min(m.count, o.start + o.count);
              for (let S = p, L = g - 1; S < L; S += f) {
                const E = m.getX(S),
                  _ = m.getX(S + 1);
                if (
                  (c.fromBufferAttribute(v, E),
                  h.fromBufferAttribute(v, _),
                  ls.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const F = e.ray.origin.distanceTo(d);
                F < e.near ||
                  F > e.far ||
                  t.push({
                    distance: F,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: S,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const p = Math.max(0, o.start),
                g = Math.min(v.count, o.start + o.count);
              for (let S = p, L = g - 1; S < L; S += f) {
                if (
                  (c.fromBufferAttribute(v, S),
                  h.fromBufferAttribute(v, S + 1),
                  ls.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const _ = e.ray.origin.distanceTo(d);
                _ < e.near ||
                  _ > e.far ||
                  t.push({
                    distance: _,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: S,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      Ar.prototype.isLine = !0;
      const da = new b(),
        fa = new b();
      class Lr extends Ar {
        constructor(e, t) {
          super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [];
              for (let i = 0, r = t.count; i < r; i += 2)
                da.fromBufferAttribute(t, i),
                  fa.fromBufferAttribute(t, i + 1),
                  (n[i] = i === 0 ? 0 : n[i - 1]),
                  (n[i + 1] = n[i] + da.distanceTo(fa));
              e.setAttribute("lineDistance", new Je(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      Lr.prototype.isLineSegments = !0;
      class dl extends Ar {
        constructor(e, t) {
          super(e, t), (this.type = "LineLoop");
        }
      }
      dl.prototype.isLineLoop = !0;
      class ks extends Ke {
        constructor(e) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new ae(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.morphTargets = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.morphTargets = e.morphTargets),
            this
          );
        }
      }
      ks.prototype.isPointsMaterial = !0;
      const pa = new le(),
        ys = new Yn(),
        hr = new gn(),
        ur = new b();
      class fl extends Ie {
        constructor(e = new ze(), t = new ks()) {
          super(),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            hr.copy(n.boundingSphere),
            hr.applyMatrix4(i),
            (hr.radius += r),
            e.ray.intersectsSphere(hr) === !1)
          )
            return;
          pa.copy(i).invert(), ys.copy(e.ray).applyMatrix4(pa);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a;
          if (n.isBufferGeometry) {
            const c = n.index,
              u = n.attributes.position;
            if (c !== null) {
              const d = Math.max(0, o.start),
                f = Math.min(c.count, o.start + o.count);
              for (let m = d, x = f; m < x; m++) {
                const v = c.getX(m);
                ur.fromBufferAttribute(u, v), ma(ur, v, l, i, e, t, this);
              }
            } else {
              const d = Math.max(0, o.start),
                f = Math.min(u.count, o.start + o.count);
              for (let m = d, x = f; m < x; m++)
                ur.fromBufferAttribute(u, m), ma(ur, m, l, i, e, t, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let r = 0, o = i.length; r < o; r++) {
                  const a = i[r].name || String(r);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = r);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      fl.prototype.isPoints = !0;
      function ma(s, e, t, n, i, r, o) {
        const a = ys.distanceSqToPoint(s);
        if (a < t) {
          const l = new b();
          ys.closestPointToPoint(s, l), l.applyMatrix4(n);
          const c = i.ray.origin.distanceTo(l);
          if (c < i.near || c > i.far) return;
          r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      class xm extends tt {
        constructor(e, t, n, i, r, o, a, l, c) {
          super(e, t, n, i, r, o, a, l, c),
            (this.format = a !== void 0 ? a : tn),
            (this.minFilter = o !== void 0 ? o : ft),
            (this.magFilter = r !== void 0 ? r : ft),
            (this.generateMipmaps = !1);
          const h = this;
          function u() {
            (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
          }
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      xm.prototype.isVideoTexture = !0;
      class vm extends tt {
        constructor(e, t, n, i, r, o, a, l, c, h, u, d) {
          super(null, o, a, l, c, h, i, r, u, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      vm.prototype.isCompressedTexture = !0;
      class pl extends tt {
        constructor(e, t, n, i, r, o, a, l, c) {
          super(e, t, n, i, r, o, a, l, c), (this.needsUpdate = !0);
        }
      }
      pl.prototype.isCanvasTexture = !0;
      class _m extends tt {
        constructor(e, t, n, i, r, o, a, l, c, h) {
          if (((h = h !== void 0 ? h : zn), h !== zn && h !== Ei))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && h === zn && (n = _r),
            n === void 0 && h === Ei && (n = yi),
            super(null, i, r, o, a, l, h, n, c),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : $e),
            (this.minFilter = l !== void 0 ? l : $e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      _m.prototype.isDepthTexture = !0;
      new b();
      new b();
      new b();
      new qe();
      const ym = {
        triangulate: function (s, e, t) {
          t = t || 2;
          const n = e && e.length,
            i = n ? e[0] * t : s.length;
          let r = ml(s, 0, i, t, !0);
          const o = [];
          if (!r || r.next === r.prev) return o;
          let a, l, c, h, u, d, f;
          if ((n && (r = Tm(s, e, r, t)), s.length > 80 * t)) {
            (a = c = s[0]), (l = h = s[1]);
            for (let m = t; m < i; m += t)
              (u = s[m]),
                (d = s[m + 1]),
                u < a && (a = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            (f = Math.max(c - a, h - l)), (f = f !== 0 ? 1 / f : 0);
          }
          return Ci(r, o, t, a, l, f), o;
        },
      };
      function ml(s, e, t, n, i) {
        let r, o;
        if (i === Bm(s, e, t, n) > 0)
          for (r = e; r < t; r += n) o = ga(r, s[r], s[r + 1], o);
        else for (r = t - n; r >= e; r -= n) o = ga(r, s[r], s[r + 1], o);
        return o && Rr(o, o.next) && (Ii(o), (o = o.next)), o;
      }
      function sn(s, e) {
        if (!s) return s;
        e || (e = s);
        let t = s,
          n;
        do
          if (
            ((n = !1),
            !t.steiner && (Rr(t, t.next) || ke(t.prev, t, t.next) === 0))
          ) {
            if ((Ii(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
          } else t = t.next;
        while (n || t !== e);
        return e;
      }
      function Ci(s, e, t, n, i, r, o) {
        if (!s) return;
        !o && r && Cm(s, n, i, r);
        let a = s,
          l,
          c;
        for (; s.prev !== s.next; ) {
          if (((l = s.prev), (c = s.next), r ? wm(s, n, i, r) : Mm(s))) {
            e.push(l.i / t),
              e.push(s.i / t),
              e.push(c.i / t),
              Ii(s),
              (s = c.next),
              (a = c.next);
            continue;
          }
          if (((s = c), s === a)) {
            o
              ? o === 1
                ? ((s = bm(sn(s), e, t)), Ci(s, e, t, n, i, r, 2))
                : o === 2 && Sm(s, e, t, n, i, r)
              : Ci(sn(s), e, t, n, i, r, 1);
            break;
          }
        }
      }
      function Mm(s) {
        const e = s.prev,
          t = s,
          n = s.next;
        if (ke(e, t, n) >= 0) return !1;
        let i = s.next.next;
        for (; i !== s.prev; ) {
          if (
            On(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            ke(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function wm(s, e, t, n) {
        const i = s.prev,
          r = s,
          o = s.next;
        if (ke(i, r, o) >= 0) return !1;
        const a = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
          l = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
          c = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
          h = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
          u = Ms(a, l, e, t, n),
          d = Ms(c, h, e, t, n);
        let f = s.prevZ,
          m = s.nextZ;
        for (; f && f.z >= u && m && m.z <= d; ) {
          if (
            (f !== s.prev &&
              f !== s.next &&
              On(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
              ke(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            m !== s.prev &&
              m !== s.next &&
              On(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
              ke(m.prev, m, m.next) >= 0)
          )
            return !1;
          m = m.nextZ;
        }
        for (; f && f.z >= u; ) {
          if (
            f !== s.prev &&
            f !== s.next &&
            On(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
            ke(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; m && m.z <= d; ) {
          if (
            m !== s.prev &&
            m !== s.next &&
            On(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
            ke(m.prev, m, m.next) >= 0
          )
            return !1;
          m = m.nextZ;
        }
        return !0;
      }
      function bm(s, e, t) {
        let n = s;
        do {
          const i = n.prev,
            r = n.next.next;
          !Rr(i, r) &&
            gl(i, n, n.next, r) &&
            Pi(i, r) &&
            Pi(r, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(r.i / t),
            Ii(n),
            Ii(n.next),
            (n = s = r)),
            (n = n.next);
        } while (n !== s);
        return sn(n);
      }
      function Sm(s, e, t, n, i, r) {
        let o = s;
        do {
          let a = o.next.next;
          for (; a !== o.prev; ) {
            if (o.i !== a.i && Dm(o, a)) {
              let l = xl(o, a);
              (o = sn(o, o.next)),
                (l = sn(l, l.next)),
                Ci(o, e, t, n, i, r),
                Ci(l, e, t, n, i, r);
              return;
            }
            a = a.next;
          }
          o = o.next;
        } while (o !== s);
      }
      function Tm(s, e, t, n) {
        const i = [];
        let r, o, a, l, c;
        for (r = 0, o = e.length; r < o; r++)
          (a = e[r] * n),
            (l = r < o - 1 ? e[r + 1] * n : s.length),
            (c = ml(s, a, l, n, !1)),
            c === c.next && (c.steiner = !0),
            i.push(Im(c));
        for (i.sort(Em), r = 0; r < i.length; r++)
          Am(i[r], t), (t = sn(t, t.next));
        return t;
      }
      function Em(s, e) {
        return s.x - e.x;
      }
      function Am(s, e) {
        if (((e = Lm(s, e)), e)) {
          const t = xl(e, s);
          sn(e, e.next), sn(t, t.next);
        }
      }
      function Lm(s, e) {
        let t = e;
        const n = s.x,
          i = s.y;
        let r = -1 / 0,
          o;
        do {
          if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > r) {
              if (((r = d), d === n)) {
                if (i === t.y) return t;
                if (i === t.next.y) return t.next;
              }
              o = t.x < t.next.x ? t : t.next;
            }
          }
          t = t.next;
        } while (t !== e);
        if (!o) return null;
        if (n === r) return o;
        const a = o,
          l = o.x,
          c = o.y;
        let h = 1 / 0,
          u;
        t = o;
        do
          n >= t.x &&
            t.x >= l &&
            n !== t.x &&
            On(i < c ? n : r, i, l, c, i < c ? r : n, i, t.x, t.y) &&
            ((u = Math.abs(i - t.y) / (n - t.x)),
            Pi(t, s) &&
              (u < h ||
                (u === h && (t.x > o.x || (t.x === o.x && Rm(o, t))))) &&
              ((o = t), (h = u))),
            (t = t.next);
        while (t !== a);
        return o;
      }
      function Rm(s, e) {
        return ke(s.prev, s, e.prev) < 0 && ke(e.next, s, s.next) < 0;
      }
      function Cm(s, e, t, n) {
        let i = s;
        do
          i.z === null && (i.z = Ms(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
        while (i !== s);
        (i.prevZ.nextZ = null), (i.prevZ = null), Pm(i);
      }
      function Pm(s) {
        let e,
          t,
          n,
          i,
          r,
          o,
          a,
          l,
          c = 1;
        do {
          for (t = s, s = null, r = null, o = 0; t; ) {
            for (
              o++, n = t, a = 0, e = 0;
              e < c && (a++, (n = n.nextZ), !!n);
              e++
            );
            for (l = c; a > 0 || (l > 0 && n); )
              a !== 0 && (l === 0 || !n || t.z <= n.z)
                ? ((i = t), (t = t.nextZ), a--)
                : ((i = n), (n = n.nextZ), l--),
                r ? (r.nextZ = i) : (s = i),
                (i.prevZ = r),
                (r = i);
            t = n;
          }
          (r.nextZ = null), (c *= 2);
        } while (o > 1);
        return s;
      }
      function Ms(s, e, t, n, i) {
        return (
          (s = 32767 * (s - t) * i),
          (e = 32767 * (e - n) * i),
          (s = (s | (s << 8)) & 16711935),
          (s = (s | (s << 4)) & 252645135),
          (s = (s | (s << 2)) & 858993459),
          (s = (s | (s << 1)) & 1431655765),
          (e = (e | (e << 8)) & 16711935),
          (e = (e | (e << 4)) & 252645135),
          (e = (e | (e << 2)) & 858993459),
          (e = (e | (e << 1)) & 1431655765),
          s | (e << 1)
        );
      }
      function Im(s) {
        let e = s,
          t = s;
        do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
        while (e !== s);
        return t;
      }
      function On(s, e, t, n, i, r, o, a) {
        return (
          (i - o) * (e - a) - (s - o) * (r - a) >= 0 &&
          (s - o) * (n - a) - (t - o) * (e - a) >= 0 &&
          (t - o) * (r - a) - (i - o) * (n - a) >= 0
        );
      }
      function Dm(s, e) {
        return (
          s.next.i !== e.i &&
          s.prev.i !== e.i &&
          !Nm(s, e) &&
          ((Pi(s, e) &&
            Pi(e, s) &&
            Fm(s, e) &&
            (ke(s.prev, s, e.prev) || ke(s, e.prev, e))) ||
            (Rr(s, e) &&
              ke(s.prev, s, s.next) > 0 &&
              ke(e.prev, e, e.next) > 0))
        );
      }
      function ke(s, e, t) {
        return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
      }
      function Rr(s, e) {
        return s.x === e.x && s.y === e.y;
      }
      function gl(s, e, t, n) {
        const i = fr(ke(s, e, t)),
          r = fr(ke(s, e, n)),
          o = fr(ke(t, n, s)),
          a = fr(ke(t, n, e));
        return !!(
          (i !== r && o !== a) ||
          (i === 0 && dr(s, t, e)) ||
          (r === 0 && dr(s, n, e)) ||
          (o === 0 && dr(t, s, n)) ||
          (a === 0 && dr(t, e, n))
        );
      }
      function dr(s, e, t) {
        return (
          e.x <= Math.max(s.x, t.x) &&
          e.x >= Math.min(s.x, t.x) &&
          e.y <= Math.max(s.y, t.y) &&
          e.y >= Math.min(s.y, t.y)
        );
      }
      function fr(s) {
        return s > 0 ? 1 : s < 0 ? -1 : 0;
      }
      function Nm(s, e) {
        let t = s;
        do {
          if (
            t.i !== s.i &&
            t.next.i !== s.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            gl(t, t.next, s, e)
          )
            return !0;
          t = t.next;
        } while (t !== s);
        return !1;
      }
      function Pi(s, e) {
        return ke(s.prev, s, s.next) < 0
          ? ke(s, e, s.next) >= 0 && ke(s, s.prev, e) >= 0
          : ke(s, e, s.prev) < 0 || ke(s, s.next, e) < 0;
      }
      function Fm(s, e) {
        let t = s,
          n = !1;
        const i = (s.x + e.x) / 2,
          r = (s.y + e.y) / 2;
        do
          t.y > r != t.next.y > r &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
        while (t !== s);
        return n;
      }
      function xl(s, e) {
        const t = new ws(s.i, s.x, s.y),
          n = new ws(e.i, e.x, e.y),
          i = s.next,
          r = e.prev;
        return (
          (s.next = e),
          (e.prev = s),
          (t.next = i),
          (i.prev = t),
          (n.next = t),
          (t.prev = n),
          (r.next = n),
          (n.prev = r),
          n
        );
      }
      function ga(s, e, t, n) {
        const i = new ws(s, e, t);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function Ii(s) {
        (s.next.prev = s.prev),
          (s.prev.next = s.next),
          s.prevZ && (s.prevZ.nextZ = s.nextZ),
          s.nextZ && (s.nextZ.prevZ = s.prevZ);
      }
      function ws(s, e, t) {
        (this.i = s),
          (this.x = e),
          (this.y = t),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function Bm(s, e, t, n) {
        let i = 0;
        for (let r = e, o = t - n; r < t; r += n)
          (i += (s[o] - s[r]) * (s[r + 1] + s[o + 1])), (o = r);
        return i;
      }
      class rn {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return n * 0.5;
        }
        static isClockWise(e) {
          return rn.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          xa(e), va(n, e);
          let o = e.length;
          t.forEach(xa);
          for (let l = 0; l < t.length; l++)
            i.push(o), (o += t[l].length), va(n, t[l]);
          const a = ym.triangulate(n, i);
          for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
          return r;
        }
      }
      function xa(s) {
        const e = s.length;
        e > 2 && s[e - 1].equals(s[0]) && s.pop();
      }
      function va(s, e) {
        for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
      }
      class Cr extends ze {
        constructor(e, t) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            r = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c);
          }
          this.setAttribute("position", new Je(i, 3)),
            this.setAttribute("uv", new Je(r, 2)),
            this.computeVertexNormals();
          function o(a) {
            const l = [],
              c = t.curveSegments !== void 0 ? t.curveSegments : 12,
              h = t.steps !== void 0 ? t.steps : 1;
            let u = t.depth !== void 0 ? t.depth : 100,
              d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
              f = t.bevelThickness !== void 0 ? t.bevelThickness : 6,
              m = t.bevelSize !== void 0 ? t.bevelSize : f - 2,
              x = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
              v = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const p = t.extrudePath,
              g = t.UVGenerator !== void 0 ? t.UVGenerator : Om;
            t.amount !== void 0 &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (u = t.amount));
            let S,
              L = !1,
              E,
              _,
              C,
              F;
            p &&
              ((S = p.getSpacedPoints(h)),
              (L = !0),
              (d = !1),
              (E = p.computeFrenetFrames(h, !1)),
              (_ = new b()),
              (C = new b()),
              (F = new b())),
              d || ((v = 0), (f = 0), (m = 0), (x = 0));
            const O = a.extractPoints(c);
            let V = O.shape;
            const W = O.holes;
            if (!rn.isClockWise(V)) {
              V = V.reverse();
              for (let q = 0, j = W.length; q < j; q++) {
                const K = W[q];
                rn.isClockWise(K) && (W[q] = K.reverse());
              }
            }
            const T = rn.triangulateShape(V, W),
              I = V;
            for (let q = 0, j = W.length; q < j; q++) {
              const K = W[q];
              V = V.concat(K);
            }
            function P(q, j, K) {
              return (
                j || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                j.clone().multiplyScalar(K).add(q)
              );
            }
            const R = V.length,
              G = T.length;
            function ee(q, j, K) {
              let he, re, w;
              const M = q.x - j.x,
                U = q.y - j.y,
                X = K.x - q.x,
                te = K.y - q.y,
                oe = M * M + U * U,
                ge = M * te - U * X;
              if (Math.abs(ge) > Number.EPSILON) {
                const pe = Math.sqrt(oe),
                  Me = Math.sqrt(X * X + te * te),
                  ce = j.x - U / pe,
                  A = j.y + M / pe,
                  J = K.x - te / Me,
                  k = K.y + X / Me,
                  ue = ((J - ce) * te - (k - A) * X) / (M * te - U * X);
                (he = ce + M * ue - q.x), (re = A + U * ue - q.y);
                const ne = he * he + re * re;
                if (ne <= 2) return new Y(he, re);
                w = Math.sqrt(ne / 2);
              } else {
                let pe = !1;
                M > Number.EPSILON
                  ? X > Number.EPSILON && (pe = !0)
                  : M < -Number.EPSILON
                  ? X < -Number.EPSILON && (pe = !0)
                  : Math.sign(U) === Math.sign(te) && (pe = !0),
                  pe
                    ? ((he = -U), (re = M), (w = Math.sqrt(oe)))
                    : ((he = M), (re = U), (w = Math.sqrt(oe / 2)));
              }
              return new Y(he / w, re / w);
            }
            const Z = [];
            for (
              let q = 0, j = I.length, K = j - 1, he = q + 1;
              q < j;
              q++, K++, he++
            )
              K === j && (K = 0),
                he === j && (he = 0),
                (Z[q] = ee(I[q], I[K], I[he]));
            const se = [];
            let ie,
              ye = Z.concat();
            for (let q = 0, j = W.length; q < j; q++) {
              const K = W[q];
              ie = [];
              for (
                let he = 0, re = K.length, w = re - 1, M = he + 1;
                he < re;
                he++, w++, M++
              )
                w === re && (w = 0),
                  M === re && (M = 0),
                  (ie[he] = ee(K[he], K[w], K[M]));
              se.push(ie), (ye = ye.concat(ie));
            }
            for (let q = 0; q < v; q++) {
              const j = q / v,
                K = f * Math.cos((j * Math.PI) / 2),
                he = m * Math.sin((j * Math.PI) / 2) + x;
              for (let re = 0, w = I.length; re < w; re++) {
                const M = P(I[re], Z[re], he);
                Ge(M.x, M.y, -K);
              }
              for (let re = 0, w = W.length; re < w; re++) {
                const M = W[re];
                ie = se[re];
                for (let U = 0, X = M.length; U < X; U++) {
                  const te = P(M[U], ie[U], he);
                  Ge(te.x, te.y, -K);
                }
              }
            }
            const ve = m + x;
            for (let q = 0; q < R; q++) {
              const j = d ? P(V[q], ye[q], ve) : V[q];
              L
                ? (C.copy(E.normals[0]).multiplyScalar(j.x),
                  _.copy(E.binormals[0]).multiplyScalar(j.y),
                  F.copy(S[0]).add(C).add(_),
                  Ge(F.x, F.y, F.z))
                : Ge(j.x, j.y, 0);
            }
            for (let q = 1; q <= h; q++)
              for (let j = 0; j < R; j++) {
                const K = d ? P(V[j], ye[j], ve) : V[j];
                L
                  ? (C.copy(E.normals[q]).multiplyScalar(K.x),
                    _.copy(E.binormals[q]).multiplyScalar(K.y),
                    F.copy(S[q]).add(C).add(_),
                    Ge(F.x, F.y, F.z))
                  : Ge(K.x, K.y, (u / h) * q);
              }
            for (let q = v - 1; q >= 0; q--) {
              const j = q / v,
                K = f * Math.cos((j * Math.PI) / 2),
                he = m * Math.sin((j * Math.PI) / 2) + x;
              for (let re = 0, w = I.length; re < w; re++) {
                const M = P(I[re], Z[re], he);
                Ge(M.x, M.y, u + K);
              }
              for (let re = 0, w = W.length; re < w; re++) {
                const M = W[re];
                ie = se[re];
                for (let U = 0, X = M.length; U < X; U++) {
                  const te = P(M[U], ie[U], he);
                  L
                    ? Ge(te.x, te.y + S[h - 1].y, S[h - 1].x + K)
                    : Ge(te.x, te.y, u + K);
                }
              }
            }
            Ce(), Ee();
            function Ce() {
              const q = i.length / 3;
              if (d) {
                let j = 0,
                  K = R * j;
                for (let he = 0; he < G; he++) {
                  const re = T[he];
                  Ae(re[2] + K, re[1] + K, re[0] + K);
                }
                (j = h + v * 2), (K = R * j);
                for (let he = 0; he < G; he++) {
                  const re = T[he];
                  Ae(re[0] + K, re[1] + K, re[2] + K);
                }
              } else {
                for (let j = 0; j < G; j++) {
                  const K = T[j];
                  Ae(K[2], K[1], K[0]);
                }
                for (let j = 0; j < G; j++) {
                  const K = T[j];
                  Ae(K[0] + R * h, K[1] + R * h, K[2] + R * h);
                }
              }
              n.addGroup(q, i.length / 3 - q, 0);
            }
            function Ee() {
              const q = i.length / 3;
              let j = 0;
              H(I, j), (j += I.length);
              for (let K = 0, he = W.length; K < he; K++) {
                const re = W[K];
                H(re, j), (j += re.length);
              }
              n.addGroup(q, i.length / 3 - q, 1);
            }
            function H(q, j) {
              let K = q.length;
              for (; --K >= 0; ) {
                const he = K;
                let re = K - 1;
                re < 0 && (re = q.length - 1);
                for (let w = 0, M = h + v * 2; w < M; w++) {
                  const U = R * w,
                    X = R * (w + 1),
                    te = j + he + U,
                    oe = j + re + U,
                    ge = j + re + X,
                    pe = j + he + X;
                  _e(te, oe, ge, pe);
                }
              }
            }
            function Ge(q, j, K) {
              l.push(q), l.push(j), l.push(K);
            }
            function Ae(q, j, K) {
              fe(q), fe(j), fe(K);
              const he = i.length / 3,
                re = g.generateTopUV(n, i, he - 3, he - 2, he - 1);
              Se(re[0]), Se(re[1]), Se(re[2]);
            }
            function _e(q, j, K, he) {
              fe(q), fe(j), fe(he), fe(j), fe(K), fe(he);
              const re = i.length / 3,
                w = g.generateSideWallUV(n, i, re - 6, re - 3, re - 2, re - 1);
              Se(w[0]), Se(w[1]), Se(w[3]), Se(w[1]), Se(w[2]), Se(w[3]);
            }
            function fe(q) {
              i.push(l[q * 3 + 0]), i.push(l[q * 3 + 1]), i.push(l[q * 3 + 2]);
            }
            function Se(q) {
              r.push(q.x), r.push(q.y);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
          return zm(t, n, e);
        }
      }
      const Om = {
        generateTopUV: function (s, e, t, n, i) {
          const r = e[t * 3],
            o = e[t * 3 + 1],
            a = e[n * 3],
            l = e[n * 3 + 1],
            c = e[i * 3],
            h = e[i * 3 + 1];
          return [new Y(r, o), new Y(a, l), new Y(c, h)];
        },
        generateSideWallUV: function (s, e, t, n, i, r) {
          const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[n * 3],
            h = e[n * 3 + 1],
            u = e[n * 3 + 2],
            d = e[i * 3],
            f = e[i * 3 + 1],
            m = e[i * 3 + 2],
            x = e[r * 3],
            v = e[r * 3 + 1],
            p = e[r * 3 + 2];
          return Math.abs(a - h) < Math.abs(o - c)
            ? [
                new Y(o, 1 - l),
                new Y(c, 1 - u),
                new Y(d, 1 - m),
                new Y(x, 1 - p),
              ]
            : [
                new Y(a, 1 - l),
                new Y(h, 1 - u),
                new Y(f, 1 - m),
                new Y(v, 1 - p),
              ];
        },
      };
      function zm(s, e, t) {
        if (((t.shapes = []), Array.isArray(s)))
          for (let n = 0, i = s.length; n < i; n++) {
            const r = s[n];
            t.shapes.push(r.uuid);
          }
        else t.shapes.push(s.uuid);
        return (
          e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
          t
        );
      }
      class Um extends ze {
        constructor(e, t = 12) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            r = [],
            o = [];
          let a = 0,
            l = 0;
          if (Array.isArray(e) === !1) c(e);
          else
            for (let h = 0; h < e.length; h++)
              c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
          this.setIndex(n),
            this.setAttribute("position", new Je(i, 3)),
            this.setAttribute("normal", new Je(r, 3)),
            this.setAttribute("uv", new Je(o, 2));
          function c(h) {
            const u = i.length / 3,
              d = h.extractPoints(t);
            let f = d.shape;
            const m = d.holes;
            rn.isClockWise(f) === !1 && (f = f.reverse());
            for (let v = 0, p = m.length; v < p; v++) {
              const g = m[v];
              rn.isClockWise(g) === !0 && (m[v] = g.reverse());
            }
            const x = rn.triangulateShape(f, m);
            for (let v = 0, p = m.length; v < p; v++) {
              const g = m[v];
              f = f.concat(g);
            }
            for (let v = 0, p = f.length; v < p; v++) {
              const g = f[v];
              i.push(g.x, g.y, 0), r.push(0, 0, 1), o.push(g.x, g.y);
            }
            for (let v = 0, p = x.length; v < p; v++) {
              const g = x[v],
                S = g[0] + u,
                L = g[1] + u,
                E = g[2] + u;
              n.push(S, L, E), (l += 3);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes;
          return Hm(t, e);
        }
      }
      function Hm(s, e) {
        if (((e.shapes = []), Array.isArray(s)))
          for (let t = 0, n = s.length; t < n; t++) {
            const i = s[t];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(s.uuid);
        return e;
      }
      class Gm extends Ke {
        constructor(e) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new ae(0)),
            (this.transparent = !0),
            this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this;
        }
      }
      Gm.prototype.isShadowMaterial = !0;
      class km extends fn {
        constructor(e) {
          super(e), (this.type = "RawShaderMaterial");
        }
      }
      km.prototype.isRawShaderMaterial = !0;
      class zi extends Ke {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new ae(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ae(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = pn),
            (this.normalScale = new Y(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            (this.vertexTangents = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            (this.vertexTangents = e.vertexTangents),
            this
          );
        }
      }
      zi.prototype.isMeshStandardMaterial = !0;
      class Vs extends zi {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Y(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, "ior", {
              get: function () {
                return (
                  (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
                );
              },
              set: function (t) {
                this.reflectivity = ut((2.5 * (t - 1)) / (t + 1), 0, 1);
              },
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            (this.thickness = 0.01),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new ae(1, 1, 1)),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.reflectivity = e.reflectivity),
            e.sheen
              ? (this.sheen = (this.sheen || new ae()).copy(e.sheen))
              : (this.sheen = null),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            this
          );
        }
      }
      Vs.prototype.isMeshPhysicalMaterial = !0;
      class Vm extends Ke {
        constructor(e) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new ae(16777215)),
            (this.specular = new ae(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ae(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = pn),
            (this.normalScale = new Y(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Sr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      Vm.prototype.isMeshPhongMaterial = !0;
      class Wm extends Ke {
        constructor(e) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new ae(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ae(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = pn),
            (this.normalScale = new Y(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }
      }
      Wm.prototype.isMeshToonMaterial = !0;
      class qm extends Ke {
        constructor(e) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = pn),
            (this.normalScale = new Y(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      qm.prototype.isMeshNormalMaterial = !0;
      class Xm extends Ke {
        constructor(e) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new ae(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ae(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Sr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            this
          );
        }
      }
      Xm.prototype.isMeshLambertMaterial = !0;
      class jm extends Ke {
        constructor(e) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new ae(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = pn),
            (this.normalScale = new Y(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.morphTargets = e.morphTargets),
            (this.morphNormals = e.morphNormals),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      jm.prototype.isMeshMatcapMaterial = !0;
      class Ym extends Qn {
        constructor(e) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        }
      }
      Ym.prototype.isLineDashedMaterial = !0;
      const He = {
        arraySlice: function (s, e, t) {
          return He.isTypedArray(s)
            ? new s.constructor(s.subarray(e, t !== void 0 ? t : s.length))
            : s.slice(e, t);
        },
        convertArray: function (s, e, t) {
          return !s || (!t && s.constructor === e)
            ? s
            : typeof e.BYTES_PER_ELEMENT == "number"
            ? new e(s)
            : Array.prototype.slice.call(s);
        },
        isTypedArray: function (s) {
          return ArrayBuffer.isView(s) && !(s instanceof DataView);
        },
        getKeyframeOrder: function (s) {
          function e(i, r) {
            return s[i] - s[r];
          }
          const t = s.length,
            n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = i;
          return n.sort(e), n;
        },
        sortedArray: function (s, e, t) {
          const n = s.length,
            i = new s.constructor(n);
          for (let r = 0, o = 0; o !== n; ++r) {
            const a = t[r] * e;
            for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
          }
          return i;
        },
        flattenJSON: function (s, e, t, n) {
          let i = 1,
            r = s[0];
          for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
          if (r === void 0) return;
          let o = r[n];
          if (o !== void 0)
            if (Array.isArray(o))
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push.apply(t, o)),
                  (r = s[i++]);
              while (r !== void 0);
            else if (o.toArray !== void 0)
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), o.toArray(t, t.length)),
                  (r = s[i++]);
              while (r !== void 0);
            else
              do
                (o = r[n]),
                  o !== void 0 && (e.push(r.time), t.push(o)),
                  (r = s[i++]);
              while (r !== void 0);
        },
        subclip: function (s, e, t, n, i = 30) {
          const r = s.clone();
          r.name = e;
          const o = [];
          for (let l = 0; l < r.tracks.length; ++l) {
            const c = r.tracks[l],
              h = c.getValueSize(),
              u = [],
              d = [];
            for (let f = 0; f < c.times.length; ++f) {
              const m = c.times[f] * i;
              if (!(m < t || m >= n)) {
                u.push(c.times[f]);
                for (let x = 0; x < h; ++x) d.push(c.values[f * h + x]);
              }
            }
            u.length !== 0 &&
              ((c.times = He.convertArray(u, c.times.constructor)),
              (c.values = He.convertArray(d, c.values.constructor)),
              o.push(c));
          }
          r.tracks = o;
          let a = 1 / 0;
          for (let l = 0; l < r.tracks.length; ++l)
            a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
          for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
          return r.resetDuration(), r;
        },
        makeClipAdditive: function (s, e = 0, t = s, n = 30) {
          n <= 0 && (n = 30);
          const i = t.tracks.length,
            r = e / n;
          for (let o = 0; o < i; ++o) {
            const a = t.tracks[o],
              l = a.ValueTypeName;
            if (l === "bool" || l === "string") continue;
            const c = s.tracks.find(function (p) {
              return p.name === a.name && p.ValueTypeName === l;
            });
            if (c === void 0) continue;
            let h = 0;
            const u = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (h = u / 3);
            let d = 0;
            const f = c.getValueSize();
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (d = f / 3);
            const m = a.times.length - 1;
            let x;
            if (r <= a.times[0]) {
              const p = h,
                g = u - h;
              x = He.arraySlice(a.values, p, g);
            } else if (r >= a.times[m]) {
              const p = m * u + h,
                g = p + u - h;
              x = He.arraySlice(a.values, p, g);
            } else {
              const p = a.createInterpolant(),
                g = h,
                S = u - h;
              p.evaluate(r), (x = He.arraySlice(p.resultBuffer, g, S));
            }
            l === "quaternion" &&
              new ct().fromArray(x).normalize().conjugate().toArray(x);
            const v = c.times.length;
            for (let p = 0; p < v; ++p) {
              const g = p * f + d;
              if (l === "quaternion")
                ct.multiplyQuaternionsFlat(c.values, g, x, 0, c.values, g);
              else {
                const S = f - d * 2;
                for (let L = 0; L < S; ++L) c.values[g + L] -= x[L];
              }
            }
          }
          return (s.blendMode = Ha), s;
        },
      };
      class Gt {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (i === void 0) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (!(e >= r)) {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let l = n - 2; ; ) {
                    if (r === void 0)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === l) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (o = n), (n = 0);
                  break n;
                }
                break e;
              }
              for (; n < o; ) {
                const a = (n + o) >>> 1;
                e < t[a] ? (o = a) : (n = a + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), r === void 0))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (i === void 0)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let o = 0; o !== i; ++o) t[o] = n[r + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      Gt.prototype.beforeStart_ = Gt.prototype.copySampleValue_;
      Gt.prototype.afterEnd_ = Gt.prototype.copySampleValue_;
      class Zm extends Gt {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Fn, endingEnd: Fn });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            o = e + 1,
            a = i[r],
            l = i[o];
          if (a === void 0)
            switch (this.getSettings_().endingStart) {
              case Bn:
                (r = e), (a = 2 * t - n);
                break;
              case Mr:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (l === void 0)
            switch (this.getSettings_().endingEnd) {
              case Bn:
                (o = e), (l = 2 * n - t);
                break;
              case Mr:
                (o = 1), (l = n + i[1] - i[0]);
                break;
              default:
                (o = e - 1), (l = t);
            }
          const c = (n - t) * 0.5,
            h = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - n)),
            (this._offsetPrev = r * h),
            (this._offsetNext = o * h);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = this._offsetPrev,
            u = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            m = (n - t) / (i - t),
            x = m * m,
            v = x * m,
            p = -d * v + 2 * d * x - d * m,
            g = (1 + d) * v + (-1.5 - 2 * d) * x + (-0.5 + d) * m + 1,
            S = (-1 - f) * v + (1.5 + f) * x + 0.5 * m,
            L = f * v - f * x;
          for (let E = 0; E !== a; ++E)
            r[E] = p * o[h + E] + g * o[c + E] + S * o[l + E] + L * o[u + E];
          return r;
        }
      }
      class vl extends Gt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = (n - t) / (i - t),
            u = 1 - h;
          for (let d = 0; d !== a; ++d) r[d] = o[c + d] * u + o[l + d] * h;
          return r;
        }
      }
      class Jm extends Gt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class Pt {
        constructor(e, t, n, i) {
          if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = He.convertArray(t, this.TimeBufferType)),
            (this.values = He.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: He.convertArray(e.times, Array),
              values: He.convertArray(e.values, Array),
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new Jm(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new vl(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new Zm(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Ai:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case Gn:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Nr:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Ai;
            case this.InterpolantFactoryMethodLinear:
              return Gn;
            case this.InterpolantFactoryMethodSmooth:
              return Nr;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            o = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; o !== -1 && n[o] > t; ) --o;
          if ((++o, r !== 0 || o !== i)) {
            r >= o && ((o = Math.max(o, 1)), (r = o - 1));
            const a = this.getValueSize();
            (this.times = He.arraySlice(n, r, o)),
              (this.values = He.arraySlice(this.values, r * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          r === 0 &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l
              ),
                (e = !1);
              break;
            }
            if (o !== null && o > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                o
              ),
                (e = !1);
              break;
            }
            o = l;
          }
          if (i !== void 0 && He.isTypedArray(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
              const c = i[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = He.arraySlice(this.times),
            t = He.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === Nr,
            r = e.length - 1;
          let o = 1;
          for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a],
              h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0]))
              if (i) l = !0;
              else {
                const u = a * n,
                  d = u - n,
                  f = u + n;
                for (let m = 0; m !== n; ++m) {
                  const x = t[u + m];
                  if (x !== t[d + m] || x !== t[f + m]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== o) {
                e[o] = e[a];
                const u = a * n,
                  d = o * n;
                for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
              }
              ++o;
            }
          }
          if (r > 0) {
            e[o] = e[r];
            for (let a = r * n, l = o * n, c = 0; c !== n; ++c)
              t[l + c] = t[a + c];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = He.arraySlice(e, 0, o)),
                (this.values = He.arraySlice(t, 0, o * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = He.arraySlice(this.times, 0),
            t = He.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, e, t);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      Pt.prototype.TimeBufferType = Float32Array;
      Pt.prototype.ValueBufferType = Float32Array;
      Pt.prototype.DefaultInterpolation = Gn;
      class $n extends Pt {}
      $n.prototype.ValueTypeName = "bool";
      $n.prototype.ValueBufferType = Array;
      $n.prototype.DefaultInterpolation = Ai;
      $n.prototype.InterpolantFactoryMethodLinear = void 0;
      $n.prototype.InterpolantFactoryMethodSmooth = void 0;
      class _l extends Pt {}
      _l.prototype.ValueTypeName = "color";
      class Di extends Pt {}
      Di.prototype.ValueTypeName = "number";
      class Km extends Gt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (n - t) / (i - t);
          let c = e * a;
          for (let h = c + a; c !== h; c += 4)
            ct.slerpFlat(r, 0, o, c - a, o, c, l);
          return r;
        }
      }
      class ei extends Pt {
        InterpolantFactoryMethodLinear(e) {
          return new Km(this.times, this.values, this.getValueSize(), e);
        }
      }
      ei.prototype.ValueTypeName = "quaternion";
      ei.prototype.DefaultInterpolation = Gn;
      ei.prototype.InterpolantFactoryMethodSmooth = void 0;
      class ti extends Pt {}
      ti.prototype.ValueTypeName = "string";
      ti.prototype.ValueBufferType = Array;
      ti.prototype.DefaultInterpolation = Ai;
      ti.prototype.InterpolantFactoryMethodLinear = void 0;
      ti.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Ni extends Pt {}
      Ni.prototype.ValueTypeName = "vector";
      class bs {
        constructor(e, t = -1, n, i = Ds) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = vt()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let o = 0, a = n.length; o !== a; ++o) t.push($m(n[o]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let r = 0, o = n.length; r !== o; ++r) t.push(Pt.toJSON(n[r]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            o = [];
          for (let a = 0; a < r; a++) {
            let l = [],
              c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            const h = He.getKeyframeOrder(l);
            (l = He.sortedArray(l, 1, h)),
              (c = He.sortedArray(c, 1, h)),
              !i && l[0] === 0 && (l.push(r), c.push(c[0])),
              o.push(
                new Di(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, o);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = c.name.match(r);
            if (h && h.length > 1) {
              const u = h[1];
              let d = i[u];
              d || (i[u] = d = []), d.push(c);
            }
          }
          const o = [];
          for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
          return o;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (u, d, f, m, x) {
              if (f.length !== 0) {
                const v = [],
                  p = [];
                He.flattenJSON(f, v, p, m),
                  v.length !== 0 && x.push(new u(d, v, p));
              }
            },
            i = [],
            r = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0))
              if (d[0].morphTargets) {
                const f = {};
                let m;
                for (m = 0; m < d.length; m++)
                  if (d[m].morphTargets)
                    for (let x = 0; x < d[m].morphTargets.length; x++)
                      f[d[m].morphTargets[x]] = -1;
                for (const x in f) {
                  const v = [],
                    p = [];
                  for (let g = 0; g !== d[m].morphTargets.length; ++g) {
                    const S = d[m];
                    v.push(S.time), p.push(S.morphTarget === x ? 1 : 0);
                  }
                  i.push(new Di(".morphTargetInfluence[" + x + "]", v, p));
                }
                l = f.length * (o || 1);
              } else {
                const f = ".bones[" + t[u].name + "]";
                n(Ni, f + ".position", d, "pos", i),
                  n(ei, f + ".quaternion", d, "rot", i),
                  n(Ni, f + ".scale", d, "scl", i);
              }
          }
          return i.length === 0 ? null : new this(r, l, i, a);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Qm(s) {
        switch (s.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Di;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Ni;
          case "color":
            return _l;
          case "quaternion":
            return ei;
          case "bool":
          case "boolean":
            return $n;
          case "string":
            return ti;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
      }
      function $m(s) {
        if (s.type === void 0)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = Qm(s.type);
        if (s.times === void 0) {
          const t = [],
            n = [];
          He.flattenJSON(s.keys, t, n, "value"), (s.times = t), (s.values = n);
        }
        return e.parse !== void 0
          ? e.parse(s)
          : new e(s.name, s.times, s.values, s.interpolation);
      }
      const Wn = {
        enabled: !1,
        files: {},
        add: function (s, e) {
          this.enabled !== !1 && (this.files[s] = e);
        },
        get: function (s) {
          if (this.enabled !== !1) return this.files[s];
        },
        remove: function (s) {
          delete this.files[s];
        },
        clear: function () {
          this.files = {};
        },
      };
      class eg {
        constructor(e, t, n) {
          const i = this;
          let r = !1,
            o = 0,
            a = 0,
            l;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (h) {
              a++,
                r === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
                (r = !0);
            }),
            (this.itemEnd = function (h) {
              o++,
                i.onProgress !== void 0 && i.onProgress(h, o, a),
                o === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
            }),
            (this.itemError = function (h) {
              i.onError !== void 0 && i.onError(h);
            }),
            (this.resolveURL = function (h) {
              return l ? l(h) : h;
            }),
            (this.setURLModifier = function (h) {
              return (l = h), this;
            }),
            (this.addHandler = function (h, u) {
              return c.push(h, u), this;
            }),
            (this.removeHandler = function (h) {
              const u = c.indexOf(h);
              return u !== -1 && c.splice(u, 2), this;
            }),
            (this.getHandler = function (h) {
              for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u],
                  m = c[u + 1];
                if ((f.global && (f.lastIndex = 0), f.test(h))) return m;
              }
              return null;
            });
        }
      }
      const tg = new eg();
      class kt {
        constructor(e) {
          (this.manager = e !== void 0 ? e : tg),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      const Tt = {};
      class Ws extends kt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = Wn.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          if (Tt[e] !== void 0) {
            Tt[e].push({ onLoad: t, onProgress: n, onError: i });
            return;
          }
          const a = /^data:(.*?)(;base64)?,(.*)$/,
            l = e.match(a);
          let c;
          if (l) {
            const h = l[1],
              u = !!l[2];
            let d = l[3];
            (d = decodeURIComponent(d)), u && (d = atob(d));
            try {
              let f;
              const m = (this.responseType || "").toLowerCase();
              switch (m) {
                case "arraybuffer":
                case "blob":
                  const x = new Uint8Array(d.length);
                  for (let p = 0; p < d.length; p++) x[p] = d.charCodeAt(p);
                  m === "blob"
                    ? (f = new Blob([x.buffer], { type: h }))
                    : (f = x.buffer);
                  break;
                case "document":
                  f = new DOMParser().parseFromString(d, h);
                  break;
                case "json":
                  f = JSON.parse(d);
                  break;
                default:
                  f = d;
                  break;
              }
              setTimeout(function () {
                t && t(f), r.manager.itemEnd(e);
              }, 0);
            } catch (f) {
              setTimeout(function () {
                i && i(f), r.manager.itemError(e), r.manager.itemEnd(e);
              }, 0);
            }
          } else {
            (Tt[e] = []),
              Tt[e].push({ onLoad: t, onProgress: n, onError: i }),
              (c = new XMLHttpRequest()),
              c.open("GET", e, !0),
              c.addEventListener(
                "load",
                function (h) {
                  const u = this.response,
                    d = Tt[e];
                  if (
                    (delete Tt[e], this.status === 200 || this.status === 0)
                  ) {
                    this.status === 0 &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                      Wn.add(e, u);
                    for (let f = 0, m = d.length; f < m; f++) {
                      const x = d[f];
                      x.onLoad && x.onLoad(u);
                    }
                    r.manager.itemEnd(e);
                  } else {
                    for (let f = 0, m = d.length; f < m; f++) {
                      const x = d[f];
                      x.onError && x.onError(h);
                    }
                    r.manager.itemError(e), r.manager.itemEnd(e);
                  }
                },
                !1
              ),
              c.addEventListener(
                "progress",
                function (h) {
                  const u = Tt[e];
                  for (let d = 0, f = u.length; d < f; d++) {
                    const m = u[d];
                    m.onProgress && m.onProgress(h);
                  }
                },
                !1
              ),
              c.addEventListener(
                "error",
                function (h) {
                  const u = Tt[e];
                  delete Tt[e];
                  for (let d = 0, f = u.length; d < f; d++) {
                    const m = u[d];
                    m.onError && m.onError(h);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              c.addEventListener(
                "abort",
                function (h) {
                  const u = Tt[e];
                  delete Tt[e];
                  for (let d = 0, f = u.length; d < f; d++) {
                    const m = u[d];
                    m.onError && m.onError(h);
                  }
                  r.manager.itemError(e), r.manager.itemEnd(e);
                },
                !1
              ),
              this.responseType !== void 0 &&
                (c.responseType = this.responseType),
              this.withCredentials !== void 0 &&
                (c.withCredentials = this.withCredentials),
              c.overrideMimeType &&
                c.overrideMimeType(
                  this.mimeType !== void 0 ? this.mimeType : "text/plain"
                );
            for (const h in this.requestHeader)
              c.setRequestHeader(h, this.requestHeader[h]);
            c.send(null);
          }
          return r.manager.itemStart(e), c;
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class yl extends kt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = Wn.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function l() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1),
              Wn.add(e, this),
              t && t(this),
              r.manager.itemEnd(e);
          }
          function c(h) {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1),
              i && i(h),
              r.manager.itemError(e),
              r.manager.itemEnd(e);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            e.substr(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class ng extends kt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Tr(),
            o = new yl(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let a = 0;
          function l(c) {
            o.load(
              e[c],
              function (h) {
                (r.images[c] = h),
                  a++,
                  a === 6 && ((r.needsUpdate = !0), t && t(r));
              },
              void 0,
              i
            );
          }
          for (let c = 0; c < e.length; ++c) l(c);
          return r;
        }
      }
      class Ml extends kt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new tt(),
            o = new yl(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                r.image = a;
                const l =
                  e.search(/\.jpe?g($|\?)/i) > 0 ||
                  e.search(/^data\:image\/jpeg/) === 0;
                (r.format = l ? tn : Et),
                  (r.needsUpdate = !0),
                  t !== void 0 && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class yt {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let o = 1; o <= e; o++)
            (n = this.getPoint(o / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let o;
          t ? (o = t) : (o = e * n[r - 1]);
          let a = 0,
            l = r - 1,
            c;
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - o), c < 0))
              a = i + 1;
            else if (c > 0) l = i - 1;
            else {
              l = i;
              break;
            }
          if (((i = l), n[i] === o)) return i / (r - 1);
          const h = n[i],
            d = n[i + 1] - h,
            f = (o - h) / d;
          return (i + f) / (r - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4,
            r = e + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const o = this.getPoint(i),
            a = this.getPoint(r),
            l = t || (o.isVector2 ? new Y() : new b());
          return l.copy(a).sub(o).normalize(), l;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new b(),
            i = [],
            r = [],
            o = [],
            a = new b(),
            l = new le();
          for (let f = 0; f <= e; f++) {
            const m = f / e;
            (i[f] = this.getTangentAt(m, new b())), i[f].normalize();
          }
          (r[0] = new b()), (o[0] = new b());
          let c = Number.MAX_VALUE;
          const h = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
          h <= c && ((c = h), n.set(1, 0, 0)),
            u <= c && ((c = u), n.set(0, 1, 0)),
            d <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], r[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((r[f] = r[f - 1].clone()),
              (o[f] = o[f - 1].clone()),
              a.crossVectors(i[f - 1], i[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const m = Math.acos(ut(i[f - 1].dot(i[f]), -1, 1));
              r[f].applyMatrix4(l.makeRotationAxis(a, m));
            }
            o[f].crossVectors(i[f], r[f]);
          }
          if (t === !0) {
            let f = Math.acos(ut(r[0].dot(r[e]), -1, 1));
            (f /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let m = 1; m <= e; m++)
              r[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)),
                o[m].crossVectors(i[m], r[m]);
          }
          return { tangents: i, normals: r, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class Pr extends yt {
        constructor(
          e = 0,
          t = 0,
          n = 1,
          i = 1,
          r = 0,
          o = Math.PI * 2,
          a = !1,
          l = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = o),
            (this.aClockwise = a),
            (this.aRotation = l);
        }
        getPoint(e, t) {
          const n = t || new Y(),
            i = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const o = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (o ? (r = 0) : (r = i)),
            this.aClockwise === !0 && !o && (r === i ? (r = -i) : (r = r - i));
          const a = this.aStartAngle + e * r;
          let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
          if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation),
              u = Math.sin(this.aRotation),
              d = l - this.aX,
              f = c - this.aY;
            (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
          }
          return n.set(l, c);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
      }
      Pr.prototype.isEllipseCurve = !0;
      class wl extends Pr {
        constructor(e, t, n, i, r, o) {
          super(e, t, n, n, i, r, o), (this.type = "ArcCurve");
        }
      }
      wl.prototype.isArcCurve = !0;
      function qs() {
        let s = 0,
          e = 0,
          t = 0,
          n = 0;
        function i(r, o, a, l) {
          (s = r),
            (e = a),
            (t = -3 * r + 3 * o - 2 * a - l),
            (n = 2 * r - 2 * o + a + l);
        }
        return {
          initCatmullRom: function (r, o, a, l, c) {
            i(o, a, c * (a - r), c * (l - o));
          },
          initNonuniformCatmullRom: function (r, o, a, l, c, h, u) {
            let d = (o - r) / c - (a - r) / (c + h) + (a - o) / h,
              f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            (d *= h), (f *= h), i(o, a, d, f);
          },
          calc: function (r) {
            const o = r * r,
              a = o * r;
            return s + e * r + t * o + n * a;
          },
        };
      }
      const pr = new b(),
        cs = new qs(),
        hs = new qs(),
        us = new qs();
      class bl extends yt {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(e, t = new b()) {
          const n = t,
            i = this.points,
            r = i.length,
            o = (r - (this.closed ? 0 : 1)) * e;
          let a = Math.floor(o),
            l = o - a;
          this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r)
            : l === 0 && a === r - 1 && ((a = r - 2), (l = 1));
          let c, h;
          this.closed || a > 0
            ? (c = i[(a - 1) % r])
            : (pr.subVectors(i[0], i[1]).add(i[0]), (c = pr));
          const u = i[a % r],
            d = i[(a + 1) % r];
          if (
            (this.closed || a + 2 < r
              ? (h = i[(a + 2) % r])
              : (pr.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (h = pr)),
            this.curveType === "centripetal" || this.curveType === "chordal")
          ) {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let m = Math.pow(c.distanceToSquared(u), f),
              x = Math.pow(u.distanceToSquared(d), f),
              v = Math.pow(d.distanceToSquared(h), f);
            x < 1e-4 && (x = 1),
              m < 1e-4 && (m = x),
              v < 1e-4 && (v = x),
              cs.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, x, v),
              hs.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, x, v),
              us.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, x, v);
          } else
            this.curveType === "catmullrom" &&
              (cs.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
              hs.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
              us.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
          return n.set(cs.calc(l), hs.calc(l), us.calc(l)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new b().fromArray(i));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
      }
      bl.prototype.isCatmullRomCurve3 = !0;
      function _a(s, e, t, n, i) {
        const r = (n - e) * 0.5,
          o = (i - t) * 0.5,
          a = s * s,
          l = s * a;
        return (
          (2 * t - 2 * n + r + o) * l +
          (-3 * t + 3 * n - 2 * r - o) * a +
          r * s +
          t
        );
      }
      function ig(s, e) {
        const t = 1 - s;
        return t * t * e;
      }
      function rg(s, e) {
        return 2 * (1 - s) * s * e;
      }
      function sg(s, e) {
        return s * s * e;
      }
      function bi(s, e, t, n) {
        return ig(s, e) + rg(s, t) + sg(s, n);
      }
      function og(s, e) {
        const t = 1 - s;
        return t * t * t * e;
      }
      function ag(s, e) {
        const t = 1 - s;
        return 3 * t * t * s * e;
      }
      function lg(s, e) {
        return 3 * (1 - s) * s * s * e;
      }
      function cg(s, e) {
        return s * s * s * e;
      }
      function Si(s, e, t, n, i) {
        return og(s, e) + ag(s, t) + lg(s, n) + cg(s, i);
      }
      class Xs extends yt {
        constructor(e = new Y(), t = new Y(), n = new Y(), i = new Y()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new Y()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return n.set(Si(e, i.x, r.x, o.x, a.x), Si(e, i.y, r.y, o.y, a.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      Xs.prototype.isCubicBezierCurve = !0;
      class Sl extends yt {
        constructor(e = new b(), t = new b(), n = new b(), i = new b()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new b()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
          return (
            n.set(
              Si(e, i.x, r.x, o.x, a.x),
              Si(e, i.y, r.y, o.y, a.y),
              Si(e, i.z, r.z, o.z, a.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      Sl.prototype.isCubicBezierCurve3 = !0;
      class Ir extends yt {
        constructor(e = new Y(), t = new Y()) {
          super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new Y()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const n = t || new Y();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Ir.prototype.isLineCurve = !0;
      class hg extends yt {
        constructor(e = new b(), t = new b()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new b()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      class js extends yt {
        constructor(e = new Y(), t = new Y(), n = new Y()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new Y()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return n.set(bi(e, i.x, r.x, o.x), bi(e, i.y, r.y, o.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      js.prototype.isQuadraticBezierCurve = !0;
      class Tl extends yt {
        constructor(e = new b(), t = new b(), n = new b()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new b()) {
          const n = t,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return (
            n.set(
              bi(e, i.x, r.x, o.x),
              bi(e, i.y, r.y, o.y),
              bi(e, i.z, r.z, o.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Tl.prototype.isQuadraticBezierCurve3 = !0;
      class Ys extends yt {
        constructor(e = []) {
          super(), (this.type = "SplineCurve"), (this.points = e);
        }
        getPoint(e, t = new Y()) {
          const n = t,
            i = this.points,
            r = (i.length - 1) * e,
            o = Math.floor(r),
            a = r - o,
            l = i[o === 0 ? o : o - 1],
            c = i[o],
            h = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
          return n.set(_a(a, l.x, c.x, h.x, u.x), _a(a, l.y, c.y, h.y, u.y)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new Y().fromArray(i));
          }
          return this;
        }
      }
      Ys.prototype.isSplineCurve = !0;
      var ug = Object.freeze({
        __proto__: null,
        ArcCurve: wl,
        CatmullRomCurve3: bl,
        CubicBezierCurve: Xs,
        CubicBezierCurve3: Sl,
        EllipseCurve: Pr,
        LineCurve: Ir,
        LineCurve3: hg,
        QuadraticBezierCurve: js,
        QuadraticBezierCurve3: Tl,
        SplineCurve: Ys,
      });
      class dg extends yt {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new Ir(t, e));
        }
        getPoint(e) {
          const t = e * this.getLength(),
            n = this.getCurveLengths();
          let i = 0;
          for (; i < n.length; ) {
            if (n[i] >= t) {
              const r = n[i] - t,
                o = this.curves[i],
                a = o.getLength(),
                l = a === 0 ? 0 : 1 - r / a;
              return o.getPointAt(l);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const o = r[i],
              a =
                o && o.isEllipseCurve
                  ? e * 2
                  : o && (o.isLineCurve || o.isLineCurve3)
                  ? 1
                  : o && o.isSplineCurve
                  ? e * o.points.length
                  : e,
              l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
              const h = l[c];
              (n && n.equals(h)) || (t.push(h), (n = h));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        }
        copy(e) {
          super.copy(e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone());
          }
          return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new ug[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class Ss extends dg {
        constructor(e) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new Y()),
            e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const n = new Ir(this.currentPoint.clone(), new Y(e, t));
          return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          const r = new js(this.currentPoint.clone(), new Y(e, t), new Y(n, i));
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, r, o) {
          const a = new Xs(
            this.currentPoint.clone(),
            new Y(e, t),
            new Y(n, i),
            new Y(r, o)
          );
          return this.curves.push(a), this.currentPoint.set(r, o), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            n = new Ys(t);
          return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
          );
        }
        arc(e, t, n, i, r, o) {
          const a = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absarc(e + a, t + l, n, i, r, o), this;
        }
        absarc(e, t, n, i, r, o) {
          return this.absellipse(e, t, n, n, i, r, o), this;
        }
        ellipse(e, t, n, i, r, o, a, l) {
          const c = this.currentPoint.x,
            h = this.currentPoint.y;
          return this.absellipse(e + c, t + h, n, i, r, o, a, l), this;
        }
        absellipse(e, t, n, i, r, o, a, l) {
          const c = new Pr(e, t, n, i, r, o, a, l);
          if (this.curves.length > 0) {
            const u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
          }
          this.curves.push(c);
          const h = c.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
          );
        }
      }
      class Zs extends Ss {
        constructor(e) {
          super(e),
            (this.uuid = vt()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(e) {
          const t = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
          super.copy(e), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.uuid = this.uuid), (e.holes = []);
          for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new Ss().fromJSON(i));
          }
          return this;
        }
      }
      class Ct extends Ie {
        constructor(e, t = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new ae(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      Ct.prototype.isLight = !0;
      class fg extends Ct {
        constructor(e, t, n) {
          super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Ie.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new ae(t));
        }
        copy(e) {
          return (
            Ct.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
          );
        }
      }
      fg.prototype.isHemisphereLight = !0;
      const ya = new le(),
        Ma = new b(),
        wa = new b();
      class Js {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.mapSize = new Y(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new le()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Er()),
            (this._frameExtents = new Y(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Fe(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          Ma.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(Ma),
            wa.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(wa),
            t.updateMatrixWorld(),
            ya.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(ya),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class El extends Js {
        constructor() {
          super(new lt(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = Ri * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n !== t.fov || i !== t.aspect || r !== t.far) &&
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      El.prototype.isSpotLightShadow = !0;
      class Al extends Ct {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 1) {
          super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(Ie.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ie()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = o),
            (this.shadow = new El());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Al.prototype.isSpotLight = !0;
      const ba = new le(),
        di = new b(),
        ds = new b();
      class Ll extends Js {
        constructor() {
          super(new lt(90, 1, 0.5, 500)),
            (this._frameExtents = new Y(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Fe(2, 1, 1, 1),
              new Fe(0, 1, 1, 1),
              new Fe(3, 1, 1, 1),
              new Fe(1, 1, 1, 1),
              new Fe(3, 0, 1, 1),
              new Fe(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new b(1, 0, 0),
              new b(-1, 0, 0),
              new b(0, 0, 1),
              new b(0, 0, -1),
              new b(0, 1, 0),
              new b(0, -1, 0),
            ]),
            (this._cubeUps = [
              new b(0, 1, 0),
              new b(0, 1, 0),
              new b(0, 1, 0),
              new b(0, 1, 0),
              new b(0, 0, 1),
              new b(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            di.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(di),
            ds.copy(n.position),
            ds.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(ds),
            n.updateMatrixWorld(),
            i.makeTranslation(-di.x, -di.y, -di.z),
            ba.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(ba);
        }
      }
      Ll.prototype.isPointLightShadow = !0;
      class Rl extends Ct {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Ll());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Rl.prototype.isPointLight = !0;
      class Ks extends Bs {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, o) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            o = n + e,
            a = i + t,
            l = i - t;
          if (this.view !== null && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += c * this.view.offsetX),
              (o = r + c * this.view.width),
              (a -= h * this.view.offsetY),
              (l = a - h * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            a,
            l,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      Ks.prototype.isOrthographicCamera = !0;
      class Cl extends Js {
        constructor() {
          super(new Ks(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Cl.prototype.isDirectionalLightShadow = !0;
      class Qs extends Ct {
        constructor(e, t) {
          super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(Ie.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ie()),
            (this.shadow = new Cl());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Qs.prototype.isDirectionalLight = !0;
      class Pl extends Ct {
        constructor(e, t) {
          super(e, t), (this.type = "AmbientLight");
        }
      }
      Pl.prototype.isAmbientLight = !0;
      class pg extends Ct {
        constructor(e, t, n = 10, i = 10) {
          super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.width = this.width), (t.object.height = this.height), t
          );
        }
      }
      pg.prototype.isRectAreaLight = !0;
      class Il {
        constructor() {
          this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new b());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * i),
            t.addScaledVector(o[2], 0.488603 * r),
            t.addScaledVector(o[3], 0.488603 * n),
            t.addScaledVector(o[4], 1.092548 * (n * i)),
            t.addScaledVector(o[5], 1.092548 * (i * r)),
            t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
            t.addScaledVector(o[7], 1.092548 * (n * r)),
            t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * i),
            t.addScaledVector(o[2], 2 * 0.511664 * r),
            t.addScaledVector(o[3], 2 * 0.511664 * n),
            t.addScaledVector(o[4], 2 * 0.429043 * n * i),
            t.addScaledVector(o[5], 2 * 0.429043 * i * r),
            t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * n * r),
            t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * r),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * r),
            (t[6] = 0.315392 * (3 * r * r - 1)),
            (t[7] = 1.092548 * n * r),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      Il.prototype.isSphericalHarmonics3 = !0;
      class $s extends Ct {
        constructor(e = new Il(), t = 1) {
          super(void 0, t), (this.sh = e);
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (t.object.sh = this.sh.toArray()), t;
        }
      }
      $s.prototype.isLightProbe = !0;
      class Un {
        static decodeText(e) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.substr(0, t + 1);
        }
      }
      class mg extends ze {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(e) {
          return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        }
      }
      mg.prototype.isInstancedBufferGeometry = !0;
      class gg extends Xe {
        constructor(e, t, n, i) {
          typeof n == "number" &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(e, t, n),
            (this.meshPerAttribute = i || 1);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      gg.prototype.isInstancedBufferAttribute = !0;
      class Dl extends kt {
        constructor(e) {
          super(e),
            typeof createImageBitmap == "undefined" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch == "undefined" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            o = Wn.get(e);
          if (o !== void 0)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), r.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = {};
          (a.credentials =
            this.crossOrigin === "anonymous" ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (l) {
                return l.blob();
              })
              .then(function (l) {
                return createImageBitmap(
                  l,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (l) {
                Wn.add(e, l), t && t(l), r.manager.itemEnd(e);
              })
              .catch(function (l) {
                i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
              }),
            r.manager.itemStart(e);
        }
      }
      Dl.prototype.isImageBitmapLoader = !0;
      let mr;
      const xg = {
        getContext: function () {
          return (
            mr === void 0 &&
              (mr = new (window.AudioContext || window.webkitAudioContext)()),
            mr
          );
        },
        setContext: function (s) {
          mr = s;
        },
      };
      class vg extends kt {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            o = new Ws(this.manager);
          o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  const l = a.slice(0);
                  xg.getContext().decodeAudioData(l, function (h) {
                    t(h);
                  });
                } catch (l) {
                  i ? i(l) : console.error(l), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
      }
      class _g extends $s {
        constructor(e, t, n = 1) {
          super(void 0, n);
          const i = new ae().set(e),
            r = new ae().set(t),
            o = new b(i.r, i.g, i.b),
            a = new b(r.r, r.g, r.b),
            l = Math.sqrt(Math.PI),
            c = l * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
            this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
        }
      }
      _g.prototype.isHemisphereLightProbe = !0;
      class yg extends $s {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new ae().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      yg.prototype.isAmbientLightProbe = !0;
      class Mg extends Ie {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            this.isPlaying === !0 &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.loop === !0 &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            this._connected === !0
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), this.source.detune !== void 0))
            return (
              this.isPlaying === !0 &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return this.hasPlaybackControl === !1
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }
      class wg {
        constructor(e, t, n) {
          (this.binding = e), (this.valueSize = n);
          let i, r, o;
          switch (t) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(n * 6)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(n * 5));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(n * 5));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let o = this.cumulativeWeight;
          if (o === 0) {
            for (let a = 0; a !== i; ++a) n[r + a] = n[a];
            o = t;
          } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, r, 0, a, i);
          }
          this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const l = t * this._origIndex;
            this._mixBufferRegion(n, i, l, 1 - r, t);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let l = t, c = t + t; l !== c; ++l)
            if (n[l] !== n[l + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let r = n, o = i; r !== o; ++r) t[r] = t[i + (r % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
        }
        _slerp(e, t, n, i) {
          ct.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const o = this._workIndex * r;
          ct.multiplyQuaternionsFlat(e, o, e, t, e, n),
            ct.slerpFlat(e, t, e, t, e, o, i);
        }
        _lerp(e, t, n, i, r) {
          const o = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let o = 0; o !== r; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i;
          }
        }
      }
      const eo = "\\[\\]\\.:\\/",
        bg = new RegExp("[" + eo + "]", "g"),
        to = "[^" + eo + "]",
        Sg = "[^" + eo.replace("\\.", "") + "]",
        Tg = /((?:WC+[\/:])*)/.source.replace("WC", to),
        Eg = /(WCOD+)?/.source.replace("WCOD", Sg),
        Ag = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", to),
        Lg = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", to),
        Rg = new RegExp("^" + Tg + Eg + Ag + Lg + "$"),
        Cg = ["material", "materials", "bones"];
      class Pg {
        constructor(e, t, n) {
          const i = n || De.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }
      class De {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || De.parseTrackName(t)),
            (this.node = De.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new De.Composite(e, t, n)
            : new De(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(bg, "");
        }
        static parseTrackName(e) {
          const t = Rg.exec(e);
          if (!t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            Cg.indexOf(r) !== -1 &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
          }
          if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            !t ||
            t === "" ||
            t === "." ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
          }
          if (e.children) {
            const n = function (r) {
                for (let o = 0; o < r.length; o++) {
                  const a = r[o];
                  if (a.name === t || a.uuid === t) return a;
                  const l = n(a.children);
                  if (l) return l;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.node[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = De.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
            return;
          }
          if (n) {
            let c = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!e.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                  if (e[h].name === c) {
                    c = h;
                    break;
                  }
                break;
              default:
                if (e[n] === void 0) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                e = e[n];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
                return;
              }
              e = e[c];
            }
          }
          const o = e[i];
          if (o === void 0) {
            const c = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                c +
                "." +
                i +
                " but it wasn't found.",
              e
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            e.needsUpdate !== void 0
              ? (a = this.Versioning.NeedsUpdate)
              : e.matrixWorldNeedsUpdate !== void 0 &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let l = this.BindingType.Direct;
          if (r !== void 0) {
            if (i === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (e.geometry.isBufferGeometry) {
                if (!e.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                e.morphTargetDictionary[r] !== void 0 &&
                  (r = e.morphTargetDictionary[r]);
              } else {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
                return;
              }
            }
            (l = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = r);
          } else
            o.fromArray !== void 0 && o.toArray !== void 0
              ? ((l = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((l = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[l]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      De.Composite = Pg;
      De.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      };
      De.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      };
      De.prototype.GetterByBindingType = [
        De.prototype._getValue_direct,
        De.prototype._getValue_array,
        De.prototype._getValue_arrayElement,
        De.prototype._getValue_toArray,
      ];
      De.prototype.SetterByBindingTypeAndVersioning = [
        [
          De.prototype._setValue_direct,
          De.prototype._setValue_direct_setNeedsUpdate,
          De.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          De.prototype._setValue_array,
          De.prototype._setValue_array_setNeedsUpdate,
          De.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          De.prototype._setValue_arrayElement,
          De.prototype._setValue_arrayElement_setNeedsUpdate,
          De.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          De.prototype._setValue_fromArray,
          De.prototype._setValue_fromArray_setNeedsUpdate,
          De.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ];
      class Ig {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            o = r.length,
            a = new Array(o),
            l = { endingStart: Fn, endingEnd: Fn };
          for (let c = 0; c !== o; ++c) {
            const h = r[c].createInterpolant(null);
            (a[c] = h), (h.settings = l);
          }
          (this._interpolantSettings = l),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = hh),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const i = this._clip.duration,
              r = e._clip.duration,
              o = r / i,
              a = i / r;
            e.warp(1, o, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            e !== null &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            o = this.timeScale;
          let a = this._timeScaleInterpolant;
          a === null &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const l = a.parameterPositions,
            c = a.sampleValues;
          return (
            (l[0] = r), (l[1] = r + n), (c[0] = e / o), (c[1] = t / o), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            e !== null &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const l = (e - r) * n;
            if (l < 0 || n === 0) return;
            (this._startTime = null), (t = n * l);
          }
          t *= this._updateTimeScale(e);
          const o = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const l = this._interpolants,
              c = this._propertyBindings;
            switch (this.blendMode) {
              case Ha:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulateAdditive(a);
                break;
              case Ds:
              default:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulate(i, a);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), i === 0 && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            n !== null &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                t === 0 ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const o = n === uh;
          if (e === 0) return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
          if (n === ch) {
            r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else if (i < 0) i = 0;
              else {
                this.time = i;
                break e;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (r === -1 &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o))
                  : this._setEndings(this.repetitions === 0, !0, o)),
              i >= t || i < 0)
            ) {
              const a = Math.floor(i / t);
              (i -= t * a), (r += Math.abs(a));
              const l = this.repetitions - r;
              if (l <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (l === 1) {
                  const c = e < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = i;
            if (o && (r & 1) === 1) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = Bn), (i.endingEnd = Bn))
            : (e
                ? (i.endingStart = this.zeroSlopeAtStart ? Bn : Fn)
                : (i.endingStart = Mr),
              t
                ? (i.endingEnd = this.zeroSlopeAtEnd ? Bn : Fn)
                : (i.endingEnd = Mr));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let o = this._weightInterpolant;
          o === null &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const a = o.parameterPositions,
            l = o.sampleValues;
          return (a[0] = r), (l[0] = t), (a[1] = r + e), (l[1] = n), this;
        }
      }
      class Dg extends mn {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = n.uuid,
            c = this._bindingsByRootAndName;
          let h = c[l];
          h === void 0 && ((h = {}), (c[l] = h));
          for (let u = 0; u !== r; ++u) {
            const d = i[u],
              f = d.name;
            let m = h[f];
            if (m !== void 0) o[u] = m;
            else {
              if (((m = o[u]), m !== void 0)) {
                m._cacheIndex === null &&
                  (++m.referenceCount, this._addInactiveBinding(m, l, f));
                continue;
              }
              const x = t && t._propertyBindings[u].binding.parsedPath;
              (m = new wg(
                De.create(n, f, x),
                d.ValueTypeName,
                d.getValueSize()
              )),
                ++m.referenceCount,
                this._addInactiveBinding(m, l, f),
                (o[u] = m);
            }
            a[u].resultBuffer = m.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const n = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                r = this._actionsByClip[i];
              this._bindAction(e, r && r.knownActions[0]),
                this._addInactiveAction(e, i, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              r.useCount++ === 0 &&
                (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const r = t[n];
              --r.useCount === 0 &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let o = r[t];
          if (o === void 0)
            (o = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = o);
          else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            o = this._actionsByClip,
            a = o[r],
            l = a.knownActions,
            c = l[l.length - 1],
            h = e._byClipCacheIndex;
          (c._byClipCacheIndex = h),
            (l[h] = c),
            l.pop(),
            (e._byClipCacheIndex = null);
          const u = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
          delete u[d],
            l.length === 0 && delete o[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const r = t[n];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let o = i[t];
          o === void 0 && ((o = {}), (i[t] = o)),
            (o[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = t[t.length - 1],
            c = e._cacheIndex;
          (l._cacheIndex = c),
            (t[c] = l),
            t.pop(),
            delete a[r],
            Object.keys(a).length === 0 && delete o[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            n === void 0 &&
              ((n = new vl(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let o = typeof e == "string" ? bs.findByName(i, e) : e;
          const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
          let c = null;
          if (
            (n === void 0 && (o !== null ? (n = o.blendMode) : (n = Ds)),
            l !== void 0)
          ) {
            const u = l.actionByRoot[r];
            if (u !== void 0 && u.blendMode === n) return u;
            (c = l.knownActions[0]), o === null && (o = c._clip);
          }
          if (o === null) return null;
          const h = new Ig(this, o, t, n);
          return this._bindAction(h, c), this._addInactiveAction(h, a, r), h;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = typeof e == "string" ? bs.findByName(n, e) : e,
            o = r ? r.uuid : e,
            a = this._actionsByClip[o];
          return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions,
            t = this._nActiveActions;
          for (let n = t - 1; n >= 0; --n) e[n].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            o = (this._accuIndex ^= 1);
          for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, o);
          const a = this._bindings,
            l = this._nActiveBindings;
          for (let c = 0; c !== l; ++c) a[c].apply(o);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (r !== void 0) {
            const o = r.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
              const c = o[a];
              this._deactivateAction(c);
              const h = c._cacheIndex,
                u = t[t.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (u._cacheIndex = h),
                (t[h] = u),
                t.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const o in n) {
            const a = n[o].actionByRoot,
              l = a[t];
            l !== void 0 &&
              (this._deactivateAction(l), this._removeInactiveAction(l));
          }
          const i = this._bindingsByRootAndName,
            r = i[t];
          if (r !== void 0)
            for (const o in r) {
              const a = r[o];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      Dg.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Ng extends Kn {
        constructor(e, t, n = 1) {
          super(e, t), (this.meshPerAttribute = n || 1);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        clone(e) {
          const t = super.clone(e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        }
      }
      Ng.prototype.isInstancedInterleavedBuffer = !0;
      class Fg extends Ie {
        constructor(e) {
          super(),
            (this.material = e),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0);
        }
      }
      Fg.prototype.isImmediateRenderObject = !0;
      const Jt = new b(),
        gr = new le(),
        fs = new le();
      class Bg extends Lr {
        constructor(e) {
          const t = Nl(e),
            n = new ze(),
            i = [],
            r = [],
            o = new ae(0, 0, 1),
            a = new ae(0, 1, 0);
          for (let c = 0; c < t.length; c++) {
            const h = t[c];
            h.parent &&
              h.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(o.r, o.g, o.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new Je(i, 3)),
            n.setAttribute("color", new Je(r, 3));
          const l = new Qn({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, l),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          fs.copy(this.root.matrixWorld).invert();
          for (let r = 0, o = 0; r < t.length; r++) {
            const a = t[r];
            a.parent &&
              a.parent.isBone &&
              (gr.multiplyMatrices(fs, a.matrixWorld),
              Jt.setFromMatrixPosition(gr),
              i.setXYZ(o, Jt.x, Jt.y, Jt.z),
              gr.multiplyMatrices(fs, a.parent.matrixWorld),
              Jt.setFromMatrixPosition(gr),
              i.setXYZ(o + 1, Jt.x, Jt.y, Jt.z),
              (o += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }
      function Nl(s) {
        const e = [];
        s && s.isBone && e.push(s);
        for (let t = 0; t < s.children.length; t++)
          e.push.apply(e, Nl(s.children[t]));
        return e;
      }
      class Og extends Lr {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new ae(n)), (i = new ae(i));
          const r = t / 2,
            o = e / t,
            a = e / 2,
            l = [],
            c = [];
          for (let d = 0, f = 0, m = -a; d <= t; d++, m += o) {
            l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
            const x = d === r ? n : i;
            x.toArray(c, f),
              (f += 3),
              x.toArray(c, f),
              (f += 3),
              x.toArray(c, f),
              (f += 3),
              x.toArray(c, f),
              (f += 3);
          }
          const h = new ze();
          h.setAttribute("position", new Je(l, 3)),
            h.setAttribute("color", new Je(c, 3));
          const u = new Qn({ vertexColors: !0, toneMapped: !1 });
          super(h, u), (this.type = "GridHelper");
        }
      }
      const zg = new Float32Array(1);
      new Int32Array(zg.buffer);
      const Ug = new $t({ side: Ze, depthWrite: !1, depthTest: !1 });
      new _t(new Fs(), Ug);
      yt.create = function (s, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (s.prototype = Object.create(yt.prototype)),
          (s.prototype.constructor = s),
          (s.prototype.getPoint = e),
          s
        );
      };
      Ss.prototype.fromPoints = function (s) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(s)
        );
      };
      Og.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      };
      Bg.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      };
      kt.prototype.extractUrlBase = function (s) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Un.extractUrlBase(s)
        );
      };
      kt.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      };
      gt.prototype.center = function (s) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(s)
        );
      };
      gt.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      gt.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      gt.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      gt.prototype.size = function (s) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(s)
        );
      };
      gn.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      };
      Er.prototype.setFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(s)
        );
      };
      et.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      et.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      et.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      };
      et.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          s.applyMatrix3(this)
        );
      };
      et.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      };
      et.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      le.prototype.extractPosition = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(s)
        );
      };
      le.prototype.flattenToArrayOffset = function (s, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(s, e)
        );
      };
      le.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new b().setFromMatrixColumn(this, 3)
        );
      };
      le.prototype.setRotationFromQuaternion = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(s)
        );
      };
      le.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      le.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      le.prototype.multiplyVector4 = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      le.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      };
      le.prototype.rotateAxis = function (s) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          s.transformDirection(this);
      };
      le.prototype.crossVector = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      le.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      le.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      le.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      le.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      le.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      le.prototype.applyToBufferAttribute = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          s.applyMatrix4(this)
        );
      };
      le.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      };
      le.prototype.makeFrustum = function (s, e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(s, e, n, t, i, r)
        );
      };
      le.prototype.getInverse = function (s) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(s).invert()
        );
      };
      Lt.prototype.isIntersectionLine = function (s) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(s)
        );
      };
      ct.prototype.multiplyVector3 = function (s) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          s.applyQuaternion(this)
        );
      };
      ct.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      };
      Yn.prototype.isIntersectionBox = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(s)
        );
      };
      Yn.prototype.isIntersectionPlane = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(s)
        );
      };
      Yn.prototype.isIntersectionSphere = function (s) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(s)
        );
      };
      qe.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      };
      qe.prototype.barycoordFromPoint = function (s, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(s, e)
        );
      };
      qe.prototype.midpoint = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(s)
        );
      };
      qe.prototypenormal = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(s)
        );
      };
      qe.prototype.plane = function (s) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(s)
        );
      };
      qe.barycoordFromPoint = function (s, e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          qe.getBarycoord(s, e, t, n, i)
        );
      };
      qe.normal = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          qe.getNormal(s, e, t, n)
        );
      };
      Zs.prototype.extractAllPoints = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(s)
        );
      };
      Zs.prototype.extrude = function (s) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new Cr(this, s)
        );
      };
      Zs.prototype.makeGeometry = function (s) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new Um(this, s)
        );
      };
      Y.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      Y.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      Y.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      b.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      };
      b.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      };
      b.prototype.getPositionFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(s)
        );
      };
      b.prototype.getScaleFromMatrix = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(s)
        );
      };
      b.prototype.getColumnFromMatrix = function (s, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, s)
        );
      };
      b.prototype.applyProjection = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(s)
        );
      };
      b.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      b.prototype.distanceToManhattan = function (s) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(s)
        );
      };
      b.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Fe.prototype.fromAttribute = function (s, e, t) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(s, e, t)
        );
      };
      Fe.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Ie.prototype.getChildByName = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(s)
        );
      };
      Ie.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      };
      Ie.prototype.translate = function (s, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, s)
        );
      };
      Ie.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      };
      Ie.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(Ie.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (s) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = s);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      _t.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      };
      Object.defineProperties(_t.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              dh
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      });
      Us.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      lt.prototype.setLens = function (s, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          e !== void 0 && (this.filmGauge = e),
          this.setFocalLength(s);
      };
      Object.defineProperties(Ct.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = s);
          },
        },
        shadowCameraLeft: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = s);
          },
        },
        shadowCameraRight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = s);
          },
        },
        shadowCameraTop: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = s);
          },
        },
        shadowCameraBottom: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = s);
          },
        },
        shadowCameraNear: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = s);
          },
        },
        shadowCameraFar: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = s);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (s) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = s);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = s);
          },
        },
        shadowMapHeight: {
          set: function (s) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = s);
          },
        },
      });
      Object.defineProperties(Xe.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === br
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(br);
          },
        },
      });
      Xe.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? br : Li),
          this
        );
      };
      (Xe.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
        (Xe.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        });
      ze.prototype.addIndex = function (s) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(s);
      };
      ze.prototype.addAttribute = function (s, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(s, new Xe(arguments[1], arguments[2])))
            : s === "index"
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(s, e)
        );
      };
      ze.prototype.addDrawCall = function (s, e, t) {
        t !== void 0 &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(s, e);
      };
      ze.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      };
      ze.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      };
      ze.prototype.removeAttribute = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(s)
        );
      };
      ze.prototype.applyMatrix = function (s) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(s)
        );
      };
      Object.defineProperties(ze.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      });
      Kn.prototype.setDynamic = function (s) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(s === !0 ? br : Li),
          this
        );
      };
      Kn.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      };
      Cr.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      Cr.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      };
      Cr.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      zs.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Object.defineProperties(Ke.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new ae()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = s === Fa);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (s) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = s);
          },
        },
      });
      Object.defineProperties(fn.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (s) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = s);
          },
        },
      });
      Be.prototype.clearTarget = function (s, e, t, n) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(s),
          this.clear(e, t, n);
      };
      Be.prototype.animate = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(s);
      };
      Be.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      };
      Be.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      };
      Be.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      };
      Be.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      };
      Be.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      };
      Be.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      };
      Be.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      };
      Be.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      };
      Be.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      };
      Be.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      };
      Be.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      };
      Be.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      };
      Be.prototype.enableScissorTest = function (s) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(s);
      };
      Be.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      Be.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      Be.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      Be.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      };
      Be.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      };
      Be.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      };
      Be.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      Be.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      Be.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      };
      Be.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      };
      Object.defineProperties(Be.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = s);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = s);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = s === !0 ? wr : Oi);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      });
      Object.defineProperties(al.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      });
      Object.defineProperties(Ht.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = s);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = s);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = s);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = s);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = s);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = s);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = s);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = s);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = s);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (s) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = s);
          },
        },
      });
      Mg.prototype.load = function (s) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new vg().load(s, function (n) {
            e.setBuffer(n);
          }),
          this
        );
      };
      Os.prototype.updateCubeMap = function (s, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(s, e)
        );
      };
      Os.prototype.clear = function (s, e, t, n) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(s, e, t, n)
        );
      };
      jn.crossOrigin = void 0;
      jn.loadTexture = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new Ml();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      jn.loadTextureCube = function (s, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new ng();
        i.setCrossOrigin(this.crossOrigin);
        const r = i.load(s, t, void 0, n);
        return e && (r.mapping = e), r;
      };
      jn.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      };
      jn.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      };
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: Da } })
        );
      typeof window != "undefined" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = Da));
      class Hg extends kt {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new Wg(t);
            }),
            this.register(function (t) {
              return new Xg(t);
            }),
            this.register(function (t) {
              return new jg(t);
            }),
            this.register(function (t) {
              return new qg(t);
            }),
            this.register(function (t) {
              return new kg(t);
            }),
            this.register(function (t) {
              return new Yg(t);
            });
        }
        load(e, t, n, i) {
          const r = this;
          let o;
          this.resourcePath !== ""
            ? (o = this.resourcePath)
            : this.path !== ""
            ? (o = this.path)
            : (o = Un.extractUrlBase(e)),
            this.manager.itemStart(e);
          const a = function (c) {
              i ? i(c) : console.error(c),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            },
            l = new Ws(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
              e,
              function (c) {
                try {
                  r.parse(
                    c,
                    o,
                    function (h) {
                      t(h), r.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (h) {
                  a(h);
                }
              },
              n,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            this.pluginCallbacks.indexOf(e) === -1 &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            this.pluginCallbacks.indexOf(e) !== -1 &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let r;
          const o = {},
            a = {};
          if (typeof e == "string") r = e;
          else if (Un.decodeText(new Uint8Array(e, 0, 4)) === Fl) {
            try {
              o[Pe.KHR_BINARY_GLTF] = new Zg(e);
            } catch (u) {
              i && i(u);
              return;
            }
            r = o[Pe.KHR_BINARY_GLTF].content;
          } else r = Un.decodeText(new Uint8Array(e));
          const l = JSON.parse(r);
          if (l.asset === void 0 || l.asset.version[0] < 2) {
            i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              );
            return;
          }
          const c = new sx(l, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const u = this.pluginCallbacks[h](c);
            (a[u.name] = u), (o[u.name] = !0);
          }
          if (l.extensionsUsed)
            for (let h = 0; h < l.extensionsUsed.length; ++h) {
              const u = l.extensionsUsed[h],
                d = l.extensionsRequired || [];
              switch (u) {
                case Pe.KHR_MATERIALS_UNLIT:
                  o[u] = new Vg();
                  break;
                case Pe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  o[u] = new Qg();
                  break;
                case Pe.KHR_DRACO_MESH_COMPRESSION:
                  o[u] = new Jg(l, this.dracoLoader);
                  break;
                case Pe.KHR_TEXTURE_TRANSFORM:
                  o[u] = new Kg();
                  break;
                case Pe.KHR_MESH_QUANTIZATION:
                  o[u] = new $g();
                  break;
                default:
                  d.indexOf(u) >= 0 &&
                    a[u] === void 0 &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + u + '".'
                    );
              }
            }
          c.setExtensions(o), c.setPlugins(a), c.parse(n, i);
        }
      }
      function Gg() {
        let s = {};
        return {
          get: function (e) {
            return s[e];
          },
          add: function (e, t) {
            s[e] = t;
          },
          remove: function (e) {
            delete s[e];
          },
          removeAll: function () {
            s = {};
          },
        };
      }
      const Pe = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      };
      class kg {
        constructor(e) {
          (this.parser = e),
            (this.name = Pe.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            r.extensions &&
              r.extensions[this.name] &&
              r.extensions[this.name].light !== void 0 &&
              e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let i = t.cache.get(n);
          if (i) return i;
          const r = t.json,
            l = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[e];
          let c;
          const h = new ae(16777215);
          l.color !== void 0 && h.fromArray(l.color);
          const u = l.range !== void 0 ? l.range : 0;
          switch (l.type) {
            case "directional":
              (c = new Qs(h)), c.target.position.set(0, 0, -1), c.add(c.target);
              break;
            case "point":
              (c = new Rl(h)), (c.distance = u);
              break;
            case "spot":
              (c = new Al(h)),
                (c.distance = u),
                (l.spot = l.spot || {}),
                (l.spot.innerConeAngle =
                  l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
                (l.spot.outerConeAngle =
                  l.spot.outerConeAngle !== void 0
                    ? l.spot.outerConeAngle
                    : Math.PI / 4),
                (c.angle = l.spot.outerConeAngle),
                (c.penumbra =
                  1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
                c.target.position.set(0, 0, -1),
                c.add(c.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + l.type
              );
          }
          return (
            c.position.set(0, 0, 0),
            (c.decay = 2),
            l.intensity !== void 0 && (c.intensity = l.intensity),
            (c.name = t.createUniqueName(l.name || "light_" + e)),
            (i = Promise.resolve(c)),
            t.cache.add(n, i),
            i
          );
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            a = ((r.extensions && r.extensions[this.name]) || {}).light;
          return a === void 0
            ? null
            : this._loadLight(a).then(function (l) {
                return n._getNodeRef(t.cache, a, l);
              });
        }
      }
      class Vg {
        constructor() {
          this.name = Pe.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return $t;
        }
        extendParams(e, t, n) {
          const i = [];
          (e.color = new ae(1, 1, 1)), (e.opacity = 1);
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const o = r.baseColorFactor;
              e.color.fromArray(o), (e.opacity = o[3]);
            }
            r.baseColorTexture !== void 0 &&
              i.push(n.assignTexture(e, "map", r.baseColorTexture));
          }
          return Promise.all(i);
        }
      }
      class Wg {
        constructor(e) {
          (this.parser = e), (this.name = Pe.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : Vs;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          if (
            (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
            o.clearcoatTexture !== void 0 &&
              r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
            o.clearcoatRoughnessFactor !== void 0 &&
              (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
            o.clearcoatRoughnessTexture !== void 0 &&
              r.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  o.clearcoatRoughnessTexture
                )
              ),
            o.clearcoatNormalTexture !== void 0 &&
              (r.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  o.clearcoatNormalTexture
                )
              ),
              o.clearcoatNormalTexture.scale !== void 0))
          ) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Y(a, -a);
          }
          return Promise.all(r);
        }
      }
      class qg {
        constructor(e) {
          (this.parser = e), (this.name = Pe.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : Vs;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          return (
            o.transmissionFactor !== void 0 &&
              (t.transmission = o.transmissionFactor),
            o.transmissionTexture !== void 0 &&
              r.push(
                n.assignTexture(t, "transmissionMap", o.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class Xg {
        constructor(e) {
          (this.parser = e), (this.name = Pe.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            o = n.images[r.source],
            a = t.options.ktx2Loader;
          if (!a) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, o, a);
        }
      }
      class jg {
        constructor(e) {
          (this.parser = e),
            (this.name = Pe.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const o = r.extensions[t],
            a = i.images[o.source];
          let l = n.textureLoader;
          if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c);
          }
          return this.detectSupport().then(function (c) {
            if (c) return n.loadTextureImage(e, a, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(t.height === 1);
                    });
              })),
            this.isSupported
          );
        }
      }
      class Yg {
        constructor(e) {
          (this.name = Pe.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
              r = this.parser.getDependency("buffer", i.buffer),
              o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return Promise.all([r, o.ready]).then(function (a) {
              const l = i.byteOffset || 0,
                c = i.byteLength || 0,
                h = i.count,
                u = i.byteStride,
                d = new ArrayBuffer(h * u),
                f = new Uint8Array(a[0], l, c);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(d),
                  h,
                  u,
                  f,
                  i.mode,
                  i.filter
                ),
                d
              );
            });
          } else return null;
        }
      }
      const Fl = "glTF",
        fi = 12,
        Sa = { JSON: 1313821514, BIN: 5130562 };
      class Zg {
        constructor(e) {
          (this.name = Pe.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, fi);
          if (
            ((this.header = {
              magic: Un.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== Fl)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - fi,
            i = new DataView(e, fi);
          let r = 0;
          for (; r < n; ) {
            const o = i.getUint32(r, !0);
            r += 4;
            const a = i.getUint32(r, !0);
            if (((r += 4), a === Sa.JSON)) {
              const l = new Uint8Array(e, fi + r, o);
              this.content = Un.decodeText(l);
            } else if (a === Sa.BIN) {
              const l = fi + r;
              this.body = e.slice(l, l + o);
            }
            r += o;
          }
          if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class Jg {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = Pe.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            i = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
          for (const h in o) {
            const u = Es[h] || h.toLowerCase();
            a[u] = o[h];
          }
          for (const h in e.attributes) {
            const u = Es[h] || h.toLowerCase();
            if (o[h] !== void 0) {
              const d = n.accessors[e.attributes[h]],
                f = Fi[d.componentType];
              (c[u] = f), (l[u] = d.normalized === !0);
            }
          }
          return t.getDependency("bufferView", r).then(function (h) {
            return new Promise(function (u) {
              i.decodeDracoFile(
                h,
                function (d) {
                  for (const f in d.attributes) {
                    const m = d.attributes[f],
                      x = l[f];
                    x !== void 0 && (m.normalized = x);
                  }
                  u(d);
                },
                a,
                c
              );
            });
          });
        }
      }
      class Kg {
        constructor() {
          this.name = Pe.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            t.texCoord !== void 0 &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.'
              ),
            (t.offset === void 0 &&
              t.rotation === void 0 &&
              t.scale === void 0) ||
              ((e = e.clone()),
              t.offset !== void 0 && e.offset.fromArray(t.offset),
              t.rotation !== void 0 && (e.rotation = t.rotation),
              t.scale !== void 0 && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class Ts extends zi {
        constructor(e) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0);
          const t = [
              "#ifdef USE_SPECULARMAP",
              "	uniform sampler2D specularMap;",
              "#endif",
            ].join(`
`),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "	uniform sampler2D glossinessMap;",
              "#endif",
            ].join(`
`),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "	vec4 texelSpecular = texture2D( specularMap, vUv );",
              "	texelSpecular = sRGBToLinear( texelSpecular );",
              "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	specularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join(`
`),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	glossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join(`
`),
            o = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.specularRoughness += geometryRoughness;",
              "material.specularRoughness = min( material.specularRoughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join(`
`),
            a = {
              specular: { value: new ae().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = a),
            (this.onBeforeCompile = function (l) {
              for (const c in a) l.uniforms[c] = a[c];
              l.fragmentShader = l.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", t)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", r)
                .replace("#include <lights_physical_fragment>", o);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return a.specular.value;
                },
                set: function (l) {
                  a.specular.value = l;
                },
              },
              specularMap: {
                get: function () {
                  return a.specularMap.value;
                },
                set: function (l) {
                  (a.specularMap.value = l),
                    l
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return a.glossiness.value;
                },
                set: function (l) {
                  a.glossiness.value = l;
                },
              },
              glossinessMap: {
                get: function () {
                  return a.glossinessMap.value;
                },
                set: function (l) {
                  (a.glossinessMap.value = l),
                    l
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.specularMap = e.specularMap),
            this.specular.copy(e.specular),
            (this.glossinessMap = e.glossinessMap),
            (this.glossiness = e.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          );
        }
      }
      class Qg {
        constructor() {
          (this.name = Pe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
              "refractionRatio",
            ]);
        }
        getMaterialType() {
          return Ts;
        }
        extendParams(e, t, n) {
          const i = t.extensions[this.name];
          (e.color = new ae(1, 1, 1)), (e.opacity = 1);
          const r = [];
          if (Array.isArray(i.diffuseFactor)) {
            const o = i.diffuseFactor;
            e.color.fromArray(o), (e.opacity = o[3]);
          }
          if (
            (i.diffuseTexture !== void 0 &&
              r.push(n.assignTexture(e, "map", i.diffuseTexture)),
            (e.emissive = new ae(0, 0, 0)),
            (e.glossiness =
              i.glossinessFactor !== void 0 ? i.glossinessFactor : 1),
            (e.specular = new ae(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              e.specular.fromArray(i.specularFactor),
            i.specularGlossinessTexture !== void 0)
          ) {
            const o = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", o)),
              r.push(n.assignTexture(e, "specularMap", o));
          }
          return Promise.all(r);
        }
        createMaterial(e) {
          const t = new Ts(e);
          return (
            (t.fog = !0),
            (t.color = e.color),
            (t.map = e.map === void 0 ? null : e.map),
            (t.lightMap = null),
            (t.lightMapIntensity = 1),
            (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
            (t.aoMapIntensity = 1),
            (t.emissive = e.emissive),
            (t.emissiveIntensity = 1),
            (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
            (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
            (t.bumpScale = 1),
            (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
            (t.normalMapType = pn),
            e.normalScale && (t.normalScale = e.normalScale),
            (t.displacementMap = null),
            (t.displacementScale = 1),
            (t.displacementBias = 0),
            (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
            (t.specular = e.specular),
            (t.glossinessMap =
              e.glossinessMap === void 0 ? null : e.glossinessMap),
            (t.glossiness = e.glossiness),
            (t.alphaMap = null),
            (t.envMap = e.envMap === void 0 ? null : e.envMap),
            (t.envMapIntensity = 1),
            (t.refractionRatio = 0.98),
            t
          );
        }
      }
      class $g {
        constructor() {
          this.name = Pe.KHR_MESH_QUANTIZATION;
        }
      }
      class qn extends Gt {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i;
          for (let o = 0; o !== i; o++) t[o] = n[r + o];
          return t;
        }
      }
      qn.prototype.beforeStart_ = qn.prototype.copySampleValue_;
      qn.prototype.afterEnd_ = qn.prototype.copySampleValue_;
      qn.prototype.interpolate_ = function (s, e, t, n) {
        const i = this.resultBuffer,
          r = this.sampleValues,
          o = this.valueSize,
          a = o * 2,
          l = o * 3,
          c = n - e,
          h = (t - e) / c,
          u = h * h,
          d = u * h,
          f = s * l,
          m = f - l,
          x = -2 * d + 3 * u,
          v = d - u,
          p = 1 - x,
          g = v - u + h;
        for (let S = 0; S !== o; S++) {
          const L = r[m + S + o],
            E = r[m + S + a] * c,
            _ = r[f + S + o],
            C = r[f + S] * c;
          i[S] = p * L + g * E + x * _ + v * C;
        }
        return i;
      };
      const zt = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        Fi = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        Ta = { 9728: $e, 9729: ft, 9984: gs, 9985: Ua, 9986: xs, 9987: Xn },
        Ea = { 33071: dt, 33648: vr, 10497: Hn },
        Aa = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        Es = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        Kt = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        ex = { CUBICSPLINE: void 0, LINEAR: Gn, STEP: Ai },
        ps = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
      function La(s, e) {
        return typeof s != "string" || s === ""
          ? ""
          : (/^https?:\/\//i.test(e) &&
              /^\//.test(s) &&
              (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(s) ||
            /^data:.*,.*$/i.test(s) ||
            /^blob:.*$/i.test(s)
              ? s
              : e + s);
      }
      function tx(s) {
        return (
          s.DefaultMaterial === void 0 &&
            (s.DefaultMaterial = new zi({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: Ti,
            })),
          s.DefaultMaterial
        );
      }
      function pi(s, e, t) {
        for (const n in t.extensions)
          s[n] === void 0 &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[n] = t.extensions[n]));
      }
      function dn(s, e) {
        e.extras !== void 0 &&
          (typeof e.extras == "object"
            ? Object.assign(s.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function nx(s, e, t) {
        let n = !1,
          i = !1;
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          if (
            (c.POSITION !== void 0 && (n = !0),
            c.NORMAL !== void 0 && (i = !0),
            n && i)
          )
            break;
        }
        if (!n && !i) return Promise.resolve(s);
        const r = [],
          o = [];
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          if (n) {
            const h =
              c.POSITION !== void 0
                ? t.getDependency("accessor", c.POSITION)
                : s.attributes.position;
            r.push(h);
          }
          if (i) {
            const h =
              c.NORMAL !== void 0
                ? t.getDependency("accessor", c.NORMAL)
                : s.attributes.normal;
            o.push(h);
          }
        }
        return Promise.all([Promise.all(r), Promise.all(o)]).then(function (a) {
          const l = a[0],
            c = a[1];
          return (
            n && (s.morphAttributes.position = l),
            i && (s.morphAttributes.normal = c),
            (s.morphTargetsRelative = !0),
            s
          );
        });
      }
      function ix(s, e) {
        if ((s.updateMorphTargets(), e.weights !== void 0))
          for (let t = 0, n = e.weights.length; t < n; t++)
            s.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (s.morphTargetInfluences.length === t.length) {
            s.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
              s.morphTargetDictionary[t[n]] = n;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function rx(s) {
        const e = s.extensions && s.extensions[Pe.KHR_DRACO_MESH_COMPRESSION];
        let t;
        return (
          e
            ? (t =
                "draco:" +
                e.bufferView +
                ":" +
                e.indices +
                ":" +
                Ra(e.attributes))
            : (t = s.indices + ":" + Ra(s.attributes) + ":" + s.mode),
          t
        );
      }
      function Ra(s) {
        let e = "";
        const t = Object.keys(s).sort();
        for (let n = 0, i = t.length; n < i; n++)
          e += t[n] + ":" + s[t[n]] + ";";
        return e;
      }
      function As(s) {
        switch (s) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      class sx {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new Gg()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {}),
            typeof createImageBitmap != "undefined" &&
            /Firefox/.test(navigator.userAgent) === !1
              ? (this.textureLoader = new Dl(this.options.manager))
              : (this.textureLoader = new Ml(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new Ws(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            this.options.crossOrigin === "use-credentials" &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            this._invokeAll(function (o) {
              return o._markDefs && o._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (o) {
                return o.beforeRoot && o.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (o) {
                const a = {
                  scene: o[0][i.scene || 0],
                  scenes: o[0],
                  animations: o[1],
                  cameras: o[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                pi(r, a, i),
                  dn(a, i),
                  Promise.all(
                    n._invokeAll(function (l) {
                      return l.afterRoot && l.afterRoot(a);
                    })
                  ).then(function () {
                    e(a);
                  });
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
          }
          for (let i = 0, r = e.length; i < r; i++) {
            const o = e[i];
            o.mesh !== void 0 &&
              (this._addNodeRef(this.meshCache, o.mesh),
              o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
              o.camera !== void 0 &&
                this._addNodeRef(this.cameraCache, o.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 &&
            (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone();
          return (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this.loadNode(t);
                break;
              case "mesh":
                i = this._invokeOne(function (r) {
                  return r.loadMesh && r.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (r) {
                  return r.loadBufferView && r.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (r) {
                  return r.loadMaterial && r.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (r) {
                  return r.loadTexture && r.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this.loadAnimation(t);
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (r, o) {
                return n.getDependency(e, o);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && t.type !== "arraybuffer")
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Pe.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (r, o) {
            n.load(La(t.uri, i.path), r, void 0, function () {
              o(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (n) {
            const i = t.byteLength || 0,
              r = t.byteOffset || 0;
            return n.slice(r, r + i);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            i = this.json.accessors[e];
          if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
          const r = [];
          return (
            i.bufferView !== void 0
              ? r.push(this.getDependency("bufferView", i.bufferView))
              : r.push(null),
            i.sparse !== void 0 &&
              (r.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              r.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(r).then(function (o) {
              const a = o[0],
                l = Aa[i.type],
                c = Fi[i.componentType],
                h = c.BYTES_PER_ELEMENT,
                u = h * l,
                d = i.byteOffset || 0,
                f =
                  i.bufferView !== void 0
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                m = i.normalized === !0;
              let x, v;
              if (f && f !== u) {
                const p = Math.floor(d / f),
                  g =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    p +
                    ":" +
                    i.count;
                let S = t.cache.get(g);
                S ||
                  ((x = new c(a, p * f, (i.count * f) / h)),
                  (S = new Kn(x, f / h)),
                  t.cache.add(g, S)),
                  (v = new Vn(S, l, (d % f) / h, m));
              } else a === null ? (x = new c(i.count * l)) : (x = new c(a, d, i.count * l)), (v = new Xe(x, l, m));
              if (i.sparse !== void 0) {
                const p = Aa.SCALAR,
                  g = Fi[i.sparse.indices.componentType],
                  S = i.sparse.indices.byteOffset || 0,
                  L = i.sparse.values.byteOffset || 0,
                  E = new g(o[1], S, i.sparse.count * p),
                  _ = new c(o[2], L, i.sparse.count * l);
                a !== null &&
                  (v = new Xe(v.array.slice(), v.itemSize, v.normalized));
                for (let C = 0, F = E.length; C < F; C++) {
                  const O = E[C];
                  if (
                    (v.setX(O, _[C * l]),
                    l >= 2 && v.setY(O, _[C * l + 1]),
                    l >= 3 && v.setZ(O, _[C * l + 2]),
                    l >= 4 && v.setW(O, _[C * l + 3]),
                    l >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return v;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            i = t.textures[e],
            r = t.images[i.source];
          let o = this.textureLoader;
          if (r.uri) {
            const a = n.manager.getHandler(r.uri);
            a !== null && (o = a);
          }
          return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, n) {
          const i = this,
            r = this.json,
            o = this.options,
            a = r.textures[e],
            l = (t.uri || t.bufferView) + ":" + a.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = self.URL || self.webkitURL;
          let h = t.uri || "",
            u = !1,
            d = !0;
          const f =
            h.search(/\.jpe?g($|\?)/i) > 0 ||
            h.search(/^data\:image\/jpeg/) === 0;
          if (
            ((t.mimeType === "image/jpeg" || f) && (d = !1),
            t.bufferView !== void 0)
          )
            h = i.getDependency("bufferView", t.bufferView).then(function (x) {
              if (t.mimeType === "image/png") {
                const p = new DataView(x, 25, 1).getUint8(0, !1);
                d = p === 6 || p === 4 || p === 3;
              }
              u = !0;
              const v = new Blob([x], { type: t.mimeType });
              return (h = c.createObjectURL(v)), h;
            });
          else if (t.uri === void 0)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const m = Promise.resolve(h)
            .then(function (x) {
              return new Promise(function (v, p) {
                let g = v;
                n.isImageBitmapLoader === !0 &&
                  (g = function (S) {
                    v(new pl(S));
                  }),
                  n.load(La(x, o.path), g, void 0, p);
              });
            })
            .then(function (x) {
              u === !0 && c.revokeObjectURL(h),
                (x.flipY = !1),
                a.name && (x.name = a.name),
                d || (x.format = tn);
              const p = (r.samplers || {})[a.sampler] || {};
              return (
                (x.magFilter = Ta[p.magFilter] || ft),
                (x.minFilter = Ta[p.minFilter] || Xn),
                (x.wrapS = Ea[p.wrapS] || Hn),
                (x.wrapT = Ea[p.wrapT] || Hn),
                i.associations.set(x, { type: "textures", index: e }),
                x
              );
            });
          return (this.textureCache[l] = m), m;
        }
        assignTexture(e, t, n) {
          const i = this;
          return this.getDependency("texture", n.index).then(function (r) {
            if (
              (n.texCoord !== void 0 &&
                n.texCoord != 0 &&
                !(t === "aoMap" && n.texCoord == 1) &&
                console.warn(
                  "THREE.GLTFLoader: Custom UV set " +
                    n.texCoord +
                    " for texture " +
                    t +
                    " not yet supported."
                ),
              i.extensions[Pe.KHR_TEXTURE_TRANSFORM])
            ) {
              const o =
                n.extensions !== void 0
                  ? n.extensions[Pe.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (o) {
                const a = i.associations.get(r);
                (r = i.extensions[Pe.KHR_TEXTURE_TRANSFORM].extendTexture(
                  r,
                  o
                )),
                  i.associations.set(r, a);
              }
            }
            e[t] = r;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const i = t.attributes.tangent !== void 0,
            r = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0,
            a = Object.keys(t.morphAttributes).length > 0,
            l = a && t.morphAttributes.normal !== void 0;
          if (e.isPoints) {
            const c = "PointsMaterial:" + n.uuid;
            let h = this.cache.get(c);
            h ||
              ((h = new ks()),
              Ke.prototype.copy.call(h, n),
              h.color.copy(n.color),
              (h.map = n.map),
              (h.sizeAttenuation = !1),
              this.cache.add(c, h)),
              (n = h);
          } else if (e.isLine) {
            const c = "LineBasicMaterial:" + n.uuid;
            let h = this.cache.get(c);
            h ||
              ((h = new Qn()),
              Ke.prototype.copy.call(h, n),
              h.color.copy(n.color),
              this.cache.add(c, h)),
              (n = h);
          }
          if (i || r || o || a) {
            let c = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"),
              i && (c += "vertex-tangents:"),
              r && (c += "vertex-colors:"),
              o && (c += "flat-shading:"),
              a && (c += "morph-targets:"),
              l && (c += "morph-normals:");
            let h = this.cache.get(c);
            h ||
              ((h = n.clone()),
              r && (h.vertexColors = !0),
              o && (h.flatShading = !0),
              a && (h.morphTargets = !0),
              l && (h.morphNormals = !0),
              i &&
                ((h.vertexTangents = !0),
                h.normalScale && (h.normalScale.y *= -1),
                h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)),
              this.cache.add(c, h),
              this.associations.set(h, this.associations.get(n))),
              (n = h);
          }
          n.aoMap &&
            t.attributes.uv2 === void 0 &&
            t.attributes.uv !== void 0 &&
            t.setAttribute("uv2", t.attributes.uv),
            (e.material = n);
        }
        getMaterialType() {
          return zi;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[e];
          let o;
          const a = {},
            l = r.extensions || {},
            c = [];
          if (l[Pe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const u = i[Pe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
          } else if (l[Pe.KHR_MATERIALS_UNLIT]) {
            const u = i[Pe.KHR_MATERIALS_UNLIT];
            (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
          } else {
            const u = r.pbrMetallicRoughness || {};
            if (
              ((a.color = new ae(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(u.baseColorFactor))
            ) {
              const d = u.baseColorFactor;
              a.color.fromArray(d), (a.opacity = d[3]);
            }
            u.baseColorTexture !== void 0 &&
              c.push(t.assignTexture(a, "map", u.baseColorTexture)),
              (a.metalness =
                u.metallicFactor !== void 0 ? u.metallicFactor : 1),
              (a.roughness =
                u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
              u.metallicRoughnessTexture !== void 0 &&
                (c.push(
                  t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)
                ),
                c.push(
                  t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture)
                )),
              (o = this._invokeOne(function (d) {
                return d.getMaterialType && d.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (d) {
                    return (
                      d.extendMaterialParams && d.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          r.doubleSided === !0 && (a.side = Bi);
          const h = r.alphaMode || ps.OPAQUE;
          return (
            h === ps.BLEND
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                h === ps.MASK &&
                  (a.alphaTest =
                    r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
            r.normalTexture !== void 0 &&
              o !== $t &&
              (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
              (a.normalScale = new Y(1, -1)),
              r.normalTexture.scale !== void 0 &&
                a.normalScale.set(
                  r.normalTexture.scale,
                  -r.normalTexture.scale
                )),
            r.occlusionTexture !== void 0 &&
              o !== $t &&
              (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
              r.occlusionTexture.strength !== void 0 &&
                (a.aoMapIntensity = r.occlusionTexture.strength)),
            r.emissiveFactor !== void 0 &&
              o !== $t &&
              (a.emissive = new ae().fromArray(r.emissiveFactor)),
            r.emissiveTexture !== void 0 &&
              o !== $t &&
              c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
            Promise.all(c).then(function () {
              let u;
              return (
                o === Ts
                  ? (u =
                      i[
                        Pe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(a))
                  : (u = new o(a)),
                r.name && (u.name = r.name),
                u.map && (u.map.encoding = wr),
                u.emissiveMap && (u.emissiveMap.encoding = wr),
                dn(u, r),
                t.associations.set(u, { type: "materials", index: e }),
                r.extensions && pi(i, u, r),
                u
              );
            })
          );
        }
        createUniqueName(e) {
          const t = De.sanitizeNodeName(e || "");
          let n = t;
          for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
          return (this.nodeNamesUsed[n] = !0), n;
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            i = this.primitiveCache;
          function r(a) {
            return n[Pe.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(a, t)
              .then(function (l) {
                return Ca(l, a, t);
              });
          }
          const o = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = rx(c),
              u = i[h];
            if (u) o.push(u.promise);
            else {
              let d;
              c.extensions && c.extensions[Pe.KHR_DRACO_MESH_COMPRESSION]
                ? (d = r(c))
                : (d = Ca(new ze(), c, t)),
                (i[h] = { primitive: c, promise: d }),
                o.push(d);
            }
          }
          return Promise.all(o);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[e],
            o = r.primitives,
            a = [];
          for (let l = 0, c = o.length; l < c; l++) {
            const h =
              o[l].material === void 0
                ? tx(this.cache)
                : this.getDependency("material", o[l].material);
            a.push(h);
          }
          return (
            a.push(t.loadGeometries(o)),
            Promise.all(a).then(function (l) {
              const c = l.slice(0, l.length - 1),
                h = l[l.length - 1],
                u = [];
              for (let f = 0, m = h.length; f < m; f++) {
                const x = h[f],
                  v = o[f];
                let p;
                const g = c[f];
                if (
                  v.mode === zt.TRIANGLES ||
                  v.mode === zt.TRIANGLE_STRIP ||
                  v.mode === zt.TRIANGLE_FAN ||
                  v.mode === void 0
                )
                  (p = r.isSkinnedMesh === !0 ? new Us(x, g) : new _t(x, g)),
                    p.isSkinnedMesh === !0 &&
                      !p.geometry.attributes.skinWeight.normalized &&
                      p.normalizeSkinWeights(),
                    v.mode === zt.TRIANGLE_STRIP
                      ? (p.geometry = Pa(p.geometry, fh))
                      : v.mode === zt.TRIANGLE_FAN &&
                        (p.geometry = Pa(p.geometry, Ga));
                else if (v.mode === zt.LINES) p = new Lr(x, g);
                else if (v.mode === zt.LINE_STRIP) p = new Ar(x, g);
                else if (v.mode === zt.LINE_LOOP) p = new dl(x, g);
                else if (v.mode === zt.POINTS) p = new fl(x, g);
                else
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + v.mode
                  );
                Object.keys(p.geometry.morphAttributes).length > 0 && ix(p, r),
                  (p.name = t.createUniqueName(r.name || "mesh_" + e)),
                  dn(p, r),
                  v.extensions && pi(i, p, v),
                  t.assignFinalMaterial(p),
                  u.push(p);
              }
              if (u.length === 1) return u[0];
              const d = new en();
              for (let f = 0, m = u.length; f < m; f++) d.add(u[f]);
              return d;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            i = n[n.type];
          if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return (
            n.type === "perspective"
              ? (t = new lt(
                  Oh.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : n.type === "orthographic" &&
                (t = new Ks(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            dn(t, n),
            Promise.resolve(t)
          );
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = { joints: t.joints };
          return t.inverseBindMatrices === void 0
            ? Promise.resolve(n)
            : this.getDependency("accessor", t.inverseBindMatrices).then(
                function (i) {
                  return (n.inverseBindMatrices = i), n;
                }
              );
        }
        loadAnimation(e) {
          const n = this.json.animations[e],
            i = [],
            r = [],
            o = [],
            a = [],
            l = [];
          for (let c = 0, h = n.channels.length; c < h; c++) {
            const u = n.channels[c],
              d = n.samplers[u.sampler],
              f = u.target,
              m = f.node !== void 0 ? f.node : f.id,
              x = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
              v = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
            i.push(this.getDependency("node", m)),
              r.push(this.getDependency("accessor", x)),
              o.push(this.getDependency("accessor", v)),
              a.push(d),
              l.push(f);
          }
          return Promise.all([
            Promise.all(i),
            Promise.all(r),
            Promise.all(o),
            Promise.all(a),
            Promise.all(l),
          ]).then(function (c) {
            const h = c[0],
              u = c[1],
              d = c[2],
              f = c[3],
              m = c[4],
              x = [];
            for (let p = 0, g = h.length; p < g; p++) {
              const S = h[p],
                L = u[p],
                E = d[p],
                _ = f[p],
                C = m[p];
              if (S === void 0) continue;
              S.updateMatrix(), (S.matrixAutoUpdate = !0);
              let F;
              switch (Kt[C.path]) {
                case Kt.weights:
                  F = Di;
                  break;
                case Kt.rotation:
                  F = ei;
                  break;
                case Kt.position:
                case Kt.scale:
                default:
                  F = Ni;
                  break;
              }
              const O = S.name ? S.name : S.uuid,
                V = _.interpolation !== void 0 ? ex[_.interpolation] : Gn,
                W = [];
              Kt[C.path] === Kt.weights
                ? S.traverse(function (T) {
                    T.isMesh === !0 &&
                      T.morphTargetInfluences &&
                      W.push(T.name ? T.name : T.uuid);
                  })
                : W.push(O);
              let z = E.array;
              if (E.normalized) {
                const T = As(z.constructor),
                  I = new Float32Array(z.length);
                for (let P = 0, R = z.length; P < R; P++) I[P] = z[P] * T;
                z = I;
              }
              for (let T = 0, I = W.length; T < I; T++) {
                const P = new F(W[T] + "." + Kt[C.path], L.array, z, V);
                _.interpolation === "CUBICSPLINE" &&
                  ((P.createInterpolant = function (G) {
                    return new qn(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      G
                    );
                  }),
                  (P.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  x.push(P);
              }
            }
            const v = n.name ? n.name : "animation_" + e;
            return new bs(v, void 0, x);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return i.mesh === void 0
            ? null
            : n.getDependency("mesh", i.mesh).then(function (r) {
                const o = n._getNodeRef(n.meshCache, i.mesh, r);
                return (
                  i.weights !== void 0 &&
                    o.traverse(function (a) {
                      if (!!a.isMesh)
                        for (let l = 0, c = i.weights.length; l < c; l++)
                          a.morphTargetInfluences[l] = i.weights[l];
                    }),
                  o
                );
              });
        }
        loadNode(e) {
          const t = this.json,
            n = this.extensions,
            i = this,
            r = t.nodes[e],
            o = r.name ? i.createUniqueName(r.name) : "";
          return (function () {
            const a = [],
              l = i._invokeOne(function (c) {
                return c.createNodeMesh && c.createNodeMesh(e);
              });
            return (
              l && a.push(l),
              r.camera !== void 0 &&
                a.push(
                  i.getDependency("camera", r.camera).then(function (c) {
                    return i._getNodeRef(i.cameraCache, r.camera, c);
                  })
                ),
              i
                ._invokeAll(function (c) {
                  return c.createNodeAttachment && c.createNodeAttachment(e);
                })
                .forEach(function (c) {
                  a.push(c);
                }),
              Promise.all(a)
            );
          })().then(function (a) {
            let l;
            if (
              (r.isBone === !0
                ? (l = new Hs())
                : a.length > 1
                ? (l = new en())
                : a.length === 1
                ? (l = a[0])
                : (l = new Ie()),
              l !== a[0])
            )
              for (let c = 0, h = a.length; c < h; c++) l.add(a[c]);
            if (
              (r.name && ((l.userData.name = r.name), (l.name = o)),
              dn(l, r),
              r.extensions && pi(n, l, r),
              r.matrix !== void 0)
            ) {
              const c = new le();
              c.fromArray(r.matrix), l.applyMatrix4(c);
            } else r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
            return i.associations.set(l, { type: "nodes", index: e }), l;
          });
        }
        loadScene(e) {
          const t = this.json,
            n = this.extensions,
            i = this.json.scenes[e],
            r = this,
            o = new en();
          i.name && (o.name = r.createUniqueName(i.name)),
            dn(o, i),
            i.extensions && pi(n, o, i);
          const a = i.nodes || [],
            l = [];
          for (let c = 0, h = a.length; c < h; c++) l.push(Bl(a[c], o, t, r));
          return Promise.all(l).then(function () {
            return o;
          });
        }
      }
      function Bl(s, e, t, n) {
        const i = t.nodes[s];
        return n
          .getDependency("node", s)
          .then(function (r) {
            if (i.skin === void 0) return r;
            let o;
            return n
              .getDependency("skin", i.skin)
              .then(function (a) {
                o = a;
                const l = [];
                for (let c = 0, h = o.joints.length; c < h; c++)
                  l.push(n.getDependency("node", o.joints[c]));
                return Promise.all(l);
              })
              .then(function (a) {
                return (
                  r.traverse(function (l) {
                    if (!l.isMesh) return;
                    const c = [],
                      h = [];
                    for (let u = 0, d = a.length; u < d; u++) {
                      const f = a[u];
                      if (f) {
                        c.push(f);
                        const m = new le();
                        o.inverseBindMatrices !== void 0 &&
                          m.fromArray(o.inverseBindMatrices.array, u * 16),
                          h.push(m);
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          o.joints[u]
                        );
                    }
                    l.bind(new Gs(c, h), l.matrixWorld);
                  }),
                  r
                );
              });
          })
          .then(function (r) {
            e.add(r);
            const o = [];
            if (i.children) {
              const a = i.children;
              for (let l = 0, c = a.length; l < c; l++) {
                const h = a[l];
                o.push(Bl(h, r, t, n));
              }
            }
            return Promise.all(o);
          });
      }
      function ox(s, e, t) {
        const n = e.attributes,
          i = new gt();
        if (n.POSITION !== void 0) {
          const a = t.json.accessors[n.POSITION],
            l = a.min,
            c = a.max;
          if (l !== void 0 && c !== void 0) {
            if (
              (i.set(new b(l[0], l[1], l[2]), new b(c[0], c[1], c[2])),
              a.normalized)
            ) {
              const h = As(Fi[a.componentType]);
              i.min.multiplyScalar(h), i.max.multiplyScalar(h);
            }
          } else {
            console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
            return;
          }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
          const a = new b(),
            l = new b();
          for (let c = 0, h = r.length; c < h; c++) {
            const u = r[c];
            if (u.POSITION !== void 0) {
              const d = t.json.accessors[u.POSITION],
                f = d.min,
                m = d.max;
              if (f !== void 0 && m !== void 0) {
                if (
                  (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))),
                  l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))),
                  l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))),
                  d.normalized)
                ) {
                  const x = As(Fi[d.componentType]);
                  l.multiplyScalar(x);
                }
                a.max(l);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          i.expandByVector(a);
        }
        s.boundingBox = i;
        const o = new gn();
        i.getCenter(o.center),
          (o.radius = i.min.distanceTo(i.max) / 2),
          (s.boundingSphere = o);
      }
      function Ca(s, e, t) {
        const n = e.attributes,
          i = [];
        function r(o, a) {
          return t.getDependency("accessor", o).then(function (l) {
            s.setAttribute(a, l);
          });
        }
        for (const o in n) {
          const a = Es[o] || o.toLowerCase();
          a in s.attributes || i.push(r(n[o], a));
        }
        if (e.indices !== void 0 && !s.index) {
          const o = t.getDependency("accessor", e.indices).then(function (a) {
            s.setIndex(a);
          });
          i.push(o);
        }
        return (
          dn(s, e),
          ox(s, e, t),
          Promise.all(i).then(function () {
            return e.targets !== void 0 ? nx(s, e.targets, t) : s;
          })
        );
      }
      function Pa(s, e) {
        let t = s.getIndex();
        if (t === null) {
          const o = [],
            a = s.getAttribute("position");
          if (a !== void 0) {
            for (let l = 0; l < a.count; l++) o.push(l);
            s.setIndex(o), (t = s.getIndex());
          } else
            return (
              console.error(
                "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
              ),
              s
            );
        }
        const n = t.count - 2,
          i = [];
        if (e === Ga)
          for (let o = 1; o <= n; o++)
            i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
        else
          for (let o = 0; o < n; o++)
            o % 2 === 0
              ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2)))
              : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n &&
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
          );
        const r = s.clone();
        return r.setIndex(i), r;
      }
      /**
       * @license
       * Copyright 2021 Google LLC.
       * SPDX-License-Identifier: Apache-2.0
       */ let Ia;
      const Ut = {
        tilt: 0,
        heading: 0,
        zoom: 18,
        center: { lat: 35.6594945, lng: 139.6999859 },
        mapId: "15431d2b469f209e",
        disableDefaultUI: !0,
        gestureHandling: "none",
        keyboardShortcuts: !1,
      };
      function ax() {
        const s = document.getElementById("map");
        (Ia = new google.maps.Map(s, Ut)), lx(Ia);
      }
      function lx(s) {
        let e, t, n, i;
        const r = new google.maps.WebGLOverlayView();
        (r.onAdd = () => {
          (e = new zs()), (n = new lt());
          const o = new Pl(16777215, 0.75);
          e.add(o);
          const a = new Qs(16777215, 0.25);
          a.position.set(0.5, -1, 0.5), e.add(a), (i = new Hg());
          const l =
            "https://raw.githubusercontent.com/googlemaps/js-samples/main/assets/pin.gltf";
          i.load(l, (c) => {
            c.scene.scale.set(10, 10, 10),
              (c.scene.rotation.x = Math.PI),
              e.add(c.scene);
          });
        }),
          (r.onContextRestored = ({ gl: o }) => {
            (t = new Be({
              canvas: o.canvas,
              context: o,
              ...o.getContextAttributes(),
            })),
              (t.autoClear = !1),
              (i.manager.onLoad = () => {
                t.setAnimationLoop(() => {
                  r.requestRedraw();
                  const { tilt: a, heading: l, zoom: c } = Ut;
                  s.moveCamera({ tilt: a, heading: l, zoom: c }),
                    Ut.tilt < 67.5
                      ? (Ut.tilt += 0.5)
                      : Ut.heading <= 360
                      ? ((Ut.heading += 0.2), (Ut.zoom -= 5e-4))
                      : t.setAnimationLoop(null);
                });
              });
          }),
          (r.onDraw = ({ gl: o, transformer: a }) => {
            const l = { lat: Ut.center.lat, lng: Ut.center.lng, altitude: 100 },
              c = a.fromLatLngAltitude(l);
            (n.projectionMatrix = new le().fromArray(c)),
              r.requestRedraw(),
              t.render(e, n),
              t.resetState();
          }),
          r.setMap(s);
      }
      window.initMap = ax;
    </script>
    <link rel="stylesheet" href="./assets/index.cfe0d128.css" />
  </head>
  <body>
    <div id="map" class="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=beta"
      defer
    ></script>
  </body>
</html>
