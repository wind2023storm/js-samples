<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Simple WebGL Overlay</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://unpkg.com/three@0.129.0/build/three.min.js"></script>

    <script type="module" crossorigin>
      (function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
          n(i);
        new MutationObserver((i) => {
          for (const s of i)
            if (s.type === "childList")
              for (const o of s.addedNodes)
                o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(i) {
          const s = {};
          return (
            i.integrity && (s.integrity = i.integrity),
            i.referrerpolicy && (s.referrerPolicy = i.referrerpolicy),
            i.crossorigin === "use-credentials"
              ? (s.credentials = "include")
              : i.crossorigin === "anonymous"
              ? (s.credentials = "omit")
              : (s.credentials = "same-origin"),
            s
          );
        }
        function n(i) {
          if (i.ep) return;
          i.ep = !0;
          const s = t(i);
          fetch(i.href, s);
        }
      })();
      /**
       * @license
       * Copyright 2010-2022 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const bo = "140",
        Yc = 0,
        Ko = 1,
        Jc = 2,
        Bl = 1,
        Kc = 2,
        Ki = 3,
        Mi = 0,
        Nt = 1,
        On = 2,
        Ol = 1,
        vn = 0,
        yi = 1,
        Zo = 2,
        $o = 3,
        Qo = 4,
        Zc = 5,
        pi = 100,
        $c = 101,
        Qc = 102,
        ea = 103,
        ta = 104,
        eh = 200,
        th = 201,
        nh = 202,
        ih = 203,
        Ul = 204,
        zl = 205,
        sh = 206,
        rh = 207,
        oh = 208,
        ah = 209,
        lh = 210,
        ch = 0,
        hh = 1,
        uh = 2,
        so = 3,
        dh = 4,
        fh = 5,
        ph = 6,
        mh = 7,
        nr = 0,
        gh = 1,
        _h = 2,
        rn = 0,
        xh = 1,
        yh = 2,
        vh = 3,
        Mh = 4,
        bh = 5,
        Hl = 300,
        bi = 301,
        wi = 302,
        ro = 303,
        oo = 304,
        ir = 306,
        Si = 1e3,
        Et = 1001,
        $s = 1002,
        at = 1003,
        ao = 1004,
        lo = 1005,
        pt = 1006,
        Gl = 1007,
        Ci = 1008,
        Un = 1009,
        wh = 1010,
        Sh = 1011,
        ns = 1012,
        Th = 1013,
        Ks = 1014,
        xn = 1015,
        is = 1016,
        Eh = 1017,
        Ah = 1018,
        vi = 1020,
        Rh = 1021,
        Lh = 1022,
        At = 1023,
        Ch = 1024,
        Ph = 1025,
        Nn = 1026,
        Ti = 1027,
        Ih = 1028,
        Dh = 1029,
        Fh = 1030,
        Nh = 1031,
        Bh = 1033,
        xr = 33776,
        yr = 33777,
        vr = 33778,
        Mr = 33779,
        na = 35840,
        ia = 35841,
        sa = 35842,
        ra = 35843,
        Oh = 36196,
        oa = 37492,
        aa = 37496,
        la = 37808,
        ca = 37809,
        ha = 37810,
        ua = 37811,
        da = 37812,
        fa = 37813,
        pa = 37814,
        ma = 37815,
        ga = 37816,
        _a = 37817,
        xa = 37818,
        ya = 37819,
        va = 37820,
        Ma = 37821,
        ba = 36492,
        Uh = 2200,
        zh = 2201,
        Hh = 2202,
        ss = 2300,
        Ei = 2301,
        br = 2302,
        mi = 2400,
        gi = 2401,
        Qs = 2402,
        wo = 2500,
        kl = 2501,
        Gh = 0,
        kh = 1,
        Vl = 2,
        Sn = 3e3,
        ze = 3001,
        Vh = 3200,
        Wh = 3201,
        Gn = 0,
        qh = 1,
        tn = "srgb",
        Fn = "srgb-linear",
        wr = 7680,
        Xh = 519,
        rs = 35044,
        er = 35048,
        wa = "300 es",
        co = 1035;
      class kn {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e];
          if (i !== void 0) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e.type];
          if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
            e.target = null;
          }
        }
      }
      const ht = [];
      for (let r = 0; r < 256; r++)
        ht[r] = (r < 16 ? "0" : "") + r.toString(16);
      let Sa = 1234567;
      const $i = Math.PI / 180,
        os = 180 / Math.PI;
      function Rt() {
        const r = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          ht[r & 255] +
          ht[(r >> 8) & 255] +
          ht[(r >> 16) & 255] +
          ht[(r >> 24) & 255] +
          "-" +
          ht[e & 255] +
          ht[(e >> 8) & 255] +
          "-" +
          ht[((e >> 16) & 15) | 64] +
          ht[(e >> 24) & 255] +
          "-" +
          ht[(t & 63) | 128] +
          ht[(t >> 8) & 255] +
          "-" +
          ht[(t >> 16) & 255] +
          ht[(t >> 24) & 255] +
          ht[n & 255] +
          ht[(n >> 8) & 255] +
          ht[(n >> 16) & 255] +
          ht[(n >> 24) & 255]
        ).toLowerCase();
      }
      function ut(r, e, t) {
        return Math.max(e, Math.min(t, r));
      }
      function So(r, e) {
        return ((r % e) + e) % e;
      }
      function jh(r, e, t, n, i) {
        return n + ((r - e) * (i - n)) / (t - e);
      }
      function Yh(r, e, t) {
        return r !== e ? (t - r) / (e - r) : 0;
      }
      function Qi(r, e, t) {
        return (1 - t) * r + t * e;
      }
      function Jh(r, e, t, n) {
        return Qi(r, e, 1 - Math.exp(-t * n));
      }
      function Kh(r, e = 1) {
        return e - Math.abs(So(r, e * 2) - e);
      }
      function Zh(r, e, t) {
        return r <= e
          ? 0
          : r >= t
          ? 1
          : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
      }
      function $h(r, e, t) {
        return r <= e
          ? 0
          : r >= t
          ? 1
          : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
      }
      function Qh(r, e) {
        return r + Math.floor(Math.random() * (e - r + 1));
      }
      function eu(r, e) {
        return r + Math.random() * (e - r);
      }
      function tu(r) {
        return r * (0.5 - Math.random());
      }
      function nu(r) {
        r !== void 0 && (Sa = r);
        let e = (Sa += 1831565813);
        return (
          (e = Math.imul(e ^ (e >>> 15), e | 1)),
          (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
          ((e ^ (e >>> 14)) >>> 0) / 4294967296
        );
      }
      function iu(r) {
        return r * $i;
      }
      function su(r) {
        return r * os;
      }
      function ho(r) {
        return (r & (r - 1)) === 0 && r !== 0;
      }
      function Wl(r) {
        return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }
      function tr(r) {
        return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
      }
      function ru(r, e, t, n, i) {
        const s = Math.cos,
          o = Math.sin,
          a = s(t / 2),
          l = o(t / 2),
          c = s((e + n) / 2),
          h = o((e + n) / 2),
          u = s((e - n) / 2),
          d = o((e - n) / 2),
          f = s((n - e) / 2),
          g = o((n - e) / 2);
        switch (i) {
          case "XYX":
            r.set(a * h, l * u, l * d, a * c);
            break;
          case "YZY":
            r.set(l * d, a * h, l * u, a * c);
            break;
          case "ZXZ":
            r.set(l * u, l * d, a * h, a * c);
            break;
          case "XZX":
            r.set(a * h, l * g, l * f, a * c);
            break;
          case "YXY":
            r.set(l * f, a * h, l * g, a * c);
            break;
          case "ZYZ":
            r.set(l * g, l * f, a * h, a * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
            );
        }
      }
      function ou(r, e) {
        switch (e.constructor) {
          case Float32Array:
            return r;
          case Uint16Array:
            return r / 65535;
          case Uint8Array:
            return r / 255;
          case Int16Array:
            return Math.max(r / 32767, -1);
          case Int8Array:
            return Math.max(r / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function au(r, e) {
        switch (e.constructor) {
          case Float32Array:
            return r;
          case Uint16Array:
            return Math.round(r * 65535);
          case Uint8Array:
            return Math.round(r * 255);
          case Int16Array:
            return Math.round(r * 32767);
          case Int8Array:
            return Math.round(r * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      var lu = Object.freeze({
        __proto__: null,
        DEG2RAD: $i,
        RAD2DEG: os,
        generateUUID: Rt,
        clamp: ut,
        euclideanModulo: So,
        mapLinear: jh,
        inverseLerp: Yh,
        lerp: Qi,
        damp: Jh,
        pingpong: Kh,
        smoothstep: Zh,
        smootherstep: $h,
        randInt: Qh,
        randFloat: eu,
        randFloatSpread: tu,
        seededRandom: nu,
        degToRad: iu,
        radToDeg: su,
        isPowerOfTwo: ho,
        ceilPowerOfTwo: Wl,
        floorPowerOfTwo: tr,
        setQuaternionFromProperEuler: ru,
        normalize: au,
        denormalize: ou,
      });
      class $ {
        constructor(e = 0, t = 0) {
          (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            this
          );
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = s * n - o * i + e.x), (this.y = s * i + o * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      $.prototype.isVector2 = !0;
      class dt {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, s, o, a, l, c) {
          const h = this.elements;
          return (
            (h[0] = e),
            (h[1] = i),
            (h[2] = a),
            (h[3] = t),
            (h[4] = s),
            (h[5] = l),
            (h[6] = n),
            (h[7] = o),
            (h[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            s = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            u = n[7],
            d = n[2],
            f = n[5],
            g = n[8],
            m = i[0],
            p = i[3],
            _ = i[6],
            M = i[1],
            T = i[4],
            E = i[7],
            w = i[2],
            R = i[5],
            P = i[8];
          return (
            (s[0] = o * m + a * M + l * w),
            (s[3] = o * p + a * T + l * R),
            (s[6] = o * _ + a * E + l * P),
            (s[1] = c * m + h * M + u * w),
            (s[4] = c * p + h * T + u * R),
            (s[7] = c * _ + h * E + u * P),
            (s[2] = d * m + f * M + g * w),
            (s[5] = d * p + f * T + g * R),
            (s[8] = d * _ + f * E + g * P),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8];
          return (
            t * o * h -
            t * a * c -
            n * s * h +
            n * a * l +
            i * s * c -
            i * o * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = h * o - a * c,
            d = a * l - h * s,
            f = c * s - o * l,
            g = t * u + n * d + i * f;
          if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m = 1 / g;
          return (
            (e[0] = u * m),
            (e[1] = (i * c - h * n) * m),
            (e[2] = (a * n - i * o) * m),
            (e[3] = d * m),
            (e[4] = (h * t - i * l) * m),
            (e[5] = (i * s - a * t) * m),
            (e[6] = f * m),
            (e[7] = (n * l - c * t) * m),
            (e[8] = (o * t - n * s) * m),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, s, o, a) {
          const l = Math.cos(s),
            c = Math.sin(s);
          return (
            this.set(
              n * l,
              n * c,
              -n * (l * o + c * a) + o + e,
              -i * c,
              i * l,
              -i * (-c * o + l * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          const n = this.elements;
          return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
          );
        }
        rotate(e) {
          const t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            s = i[0],
            o = i[3],
            a = i[6],
            l = i[1],
            c = i[4],
            h = i[7];
          return (
            (i[0] = t * s + n * l),
            (i[3] = t * o + n * c),
            (i[6] = t * a + n * h),
            (i[1] = -n * s + t * l),
            (i[4] = -n * o + t * c),
            (i[7] = -n * a + t * h),
            this
          );
        }
        translate(e, t) {
          const n = this.elements;
          return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      dt.prototype.isMatrix3 = !0;
      function ql(r) {
        for (let e = r.length - 1; e >= 0; --e) if (r[e] > 65535) return !0;
        return !1;
      }
      function as(r) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", r);
      }
      function Bn(r) {
        return r < 0.04045
          ? r * 0.0773993808
          : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
      }
      function Zs(r) {
        return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
      }
      const Sr = { [tn]: { [Fn]: Bn }, [Fn]: { [tn]: Zs } },
        Pt = {
          legacyMode: !0,
          get workingColorSpace() {
            return Fn;
          },
          set workingColorSpace(r) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function (r, e, t) {
            if (this.legacyMode || e === t || !e || !t) return r;
            if (Sr[e] && Sr[e][t] !== void 0) {
              const n = Sr[e][t];
              return (r.r = n(r.r)), (r.g = n(r.g)), (r.b = n(r.b)), r;
            }
            throw new Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (r, e) {
            return this.convert(r, this.workingColorSpace, e);
          },
          toWorkingColorSpace: function (r, e) {
            return this.convert(r, e, this.workingColorSpace);
          },
        },
        Xl = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        ot = { r: 0, g: 0, b: 0 },
        It = { h: 0, s: 0, l: 0 },
        xs = { h: 0, s: 0, l: 0 };
      function Tr(r, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? r + (e - r) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? r + (e - r) * 6 * (2 / 3 - t)
            : r
        );
      }
      function ys(r, e) {
        return (e.r = r.r), (e.g = r.g), (e.b = r.b), e;
      }
      class he {
        constructor(e, t, n) {
          return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
        }
        set(e) {
          return (
            e && e.isColor
              ? this.copy(e)
              : typeof e == "number"
              ? this.setHex(e)
              : typeof e == "string" && this.setStyle(e),
            this
          );
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = tn) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            Pt.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, n, i = Fn) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            Pt.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(e, t, n, i = Fn) {
          if (((e = So(e, 1)), (t = ut(t, 0, 1)), (n = ut(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
          else {
            const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              o = 2 * n - s;
            (this.r = Tr(o, s, e + 1 / 3)),
              (this.g = Tr(o, s, e)),
              (this.b = Tr(o, s, e - 1 / 3));
          }
          return Pt.toWorkingColorSpace(this, i), this;
        }
        setStyle(e, t = tn) {
          function n(s) {
            s !== void 0 &&
              parseFloat(s) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let i;
          if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let s;
            const o = i[1],
              a = i[2];
            switch (o) {
              case "rgb":
              case "rgba":
                if (
                  (s =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(s[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(s[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(s[3], 10)) / 255),
                    Pt.toWorkingColorSpace(this, t),
                    n(s[4]),
                    this
                  );
                if (
                  (s =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(s[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(s[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(s[3], 10)) / 100),
                    Pt.toWorkingColorSpace(this, t),
                    n(s[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (s =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                ) {
                  const l = parseFloat(s[1]) / 360,
                    c = parseInt(s[2], 10) / 100,
                    h = parseInt(s[3], 10) / 100;
                  return n(s[4]), this.setHSL(l, c, h, t);
                }
                break;
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const s = i[1],
              o = s.length;
            if (o === 3)
              return (
                (this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255),
                (this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255),
                (this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255),
                Pt.toWorkingColorSpace(this, t),
                this
              );
            if (o === 6)
              return (
                (this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255),
                (this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255),
                (this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255),
                Pt.toWorkingColorSpace(this, t),
                this
              );
          }
          return e && e.length > 0 ? this.setColorName(e, t) : this;
        }
        setColorName(e, t = tn) {
          const n = Xl[e.toLowerCase()];
          return (
            n !== void 0
              ? this.setHex(n, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = Bn(e.r)), (this.g = Bn(e.g)), (this.b = Bn(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = Zs(e.r)), (this.g = Zs(e.g)), (this.b = Zs(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = tn) {
          return (
            Pt.fromWorkingColorSpace(ys(this, ot), e),
            (ut(ot.r * 255, 0, 255) << 16) ^
              (ut(ot.g * 255, 0, 255) << 8) ^
              (ut(ot.b * 255, 0, 255) << 0)
          );
        }
        getHexString(e = tn) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Fn) {
          Pt.fromWorkingColorSpace(ys(this, ot), t);
          const n = ot.r,
            i = ot.g,
            s = ot.b,
            o = Math.max(n, i, s),
            a = Math.min(n, i, s);
          let l, c;
          const h = (a + o) / 2;
          if (a === o) (l = 0), (c = 0);
          else {
            const u = o - a;
            switch (((c = h <= 0.5 ? u / (o + a) : u / (2 - o - a)), o)) {
              case n:
                l = (i - s) / u + (i < s ? 6 : 0);
                break;
              case i:
                l = (s - n) / u + 2;
                break;
              case s:
                l = (n - i) / u + 4;
                break;
            }
            l /= 6;
          }
          return (e.h = l), (e.s = c), (e.l = h), e;
        }
        getRGB(e, t = Fn) {
          return (
            Pt.fromWorkingColorSpace(ys(this, ot), t),
            (e.r = ot.r),
            (e.g = ot.g),
            (e.b = ot.b),
            e
          );
        }
        getStyle(e = tn) {
          return (
            Pt.fromWorkingColorSpace(ys(this, ot), e),
            e !== tn
              ? `color(${e} ${ot.r} ${ot.g} ${ot.b})`
              : `rgb(${(ot.r * 255) | 0},${(ot.g * 255) | 0},${
                  (ot.b * 255) | 0
                })`
          );
        }
        offsetHSL(e, t, n) {
          return (
            this.getHSL(It),
            (It.h += e),
            (It.s += t),
            (It.l += n),
            this.setHSL(It.h, It.s, It.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(It), e.getHSL(xs);
          const n = Qi(It.h, xs.h, t),
            i = Qi(It.s, xs.s, t),
            s = Qi(It.l, xs.l, t);
          return this.setHSL(n, i, s), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      he.NAMES = Xl;
      he.prototype.isColor = !0;
      he.prototype.r = 1;
      he.prototype.g = 1;
      he.prototype.b = 1;
      let Kn;
      class Vn {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            Kn === void 0 && (Kn = as("canvas")),
              (Kn.width = e.width),
              (Kn.height = e.height);
            const n = Kn.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = Kn);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            (typeof HTMLImageElement != "undefined" &&
              e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement != "undefined" &&
              e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
          ) {
            const t = as("canvas");
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
              s = i.data;
            for (let o = 0; o < s.length; o++) s[o] = Bn(s[o] / 255) * 255;
            return n.putImageData(i, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray
                ? (t[n] = Math.floor(Bn(t[n] / 255) * 255))
                : (t[n] = Bn(t[n]));
            return { data: t, width: e.width, height: e.height };
          } else
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              e
            );
        }
      }
      class To {
        constructor(e = null) {
          (this.uuid = Rt()), (this.data = e), (this.version = 0);
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            i = this.data;
          if (i !== null) {
            let s;
            if (Array.isArray(i)) {
              s = [];
              for (let o = 0, a = i.length; o < a; o++)
                i[o].isDataTexture ? s.push(Er(i[o].image)) : s.push(Er(i[o]));
            } else s = Er(i);
            n.url = s;
          }
          return t || (e.images[this.uuid] = n), n;
        }
      }
      function Er(r) {
        return (typeof HTMLImageElement != "undefined" &&
          r instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            r instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && r instanceof ImageBitmap)
          ? Vn.getDataURL(r)
          : r.data
          ? {
              data: Array.prototype.slice.call(r.data),
              width: r.width,
              height: r.height,
              type: r.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      To.prototype.isSource = !0;
      let cu = 0;
      class rt extends kn {
        constructor(
          e = rt.DEFAULT_IMAGE,
          t = rt.DEFAULT_MAPPING,
          n = Et,
          i = Et,
          s = pt,
          o = Ci,
          a = At,
          l = Un,
          c = 1,
          h = Sn
        ) {
          super(),
            Object.defineProperty(this, "id", { value: cu++ }),
            (this.uuid = Rt()),
            (this.name = ""),
            (this.source = new To(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = s),
            (this.minFilter = o),
            (this.anisotropy = c),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = l),
            (this.offset = new $(0, 0)),
            (this.repeat = new $(1, 1)),
            (this.center = new $(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new dt()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = h),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        get image() {
          return this.source.data;
        }
        set image(e) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.encoding = e.encoding),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== Hl) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case Si:
                e.x = e.x - Math.floor(e.x);
                break;
              case Et:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case $s:
                Math.abs(Math.floor(e.x) % 2) === 1
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case Si:
                e.y = e.y - Math.floor(e.y);
                break;
              case Et:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case $s:
                Math.abs(Math.floor(e.y) % 2) === 1
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && (this.version++, (this.source.needsUpdate = !0));
        }
      }
      rt.DEFAULT_IMAGE = null;
      rt.DEFAULT_MAPPING = Hl;
      rt.prototype.isTexture = !0;
      class je {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.x = e), (this.y = t), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
          );
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            s = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s),
            (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s),
            (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s),
            (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, s;
          const l = e.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            g = l[9],
            m = l[2],
            p = l[6],
            _ = l[10];
          if (
            Math.abs(h - d) < 0.01 &&
            Math.abs(u - m) < 0.01 &&
            Math.abs(g - p) < 0.01
          ) {
            if (
              Math.abs(h + d) < 0.1 &&
              Math.abs(u + m) < 0.1 &&
              Math.abs(g + p) < 0.1 &&
              Math.abs(c + f + _ - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const T = (c + 1) / 2,
              E = (f + 1) / 2,
              w = (_ + 1) / 2,
              R = (h + d) / 4,
              P = (u + m) / 4,
              y = (g + p) / 4;
            return (
              T > E && T > w
                ? T < 0.01
                  ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
                  : ((n = Math.sqrt(T)), (i = R / n), (s = P / n))
                : E > w
                ? E < 0.01
                  ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
                  : ((i = Math.sqrt(E)), (n = R / i), (s = y / i))
                : w < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
                : ((s = Math.sqrt(w)), (n = P / s), (i = y / s)),
              this.set(n, i, s, t),
              this
            );
          }
          let M = Math.sqrt(
            (p - g) * (p - g) + (u - m) * (u - m) + (d - h) * (d - h)
          );
          return (
            Math.abs(M) < 0.001 && (M = 1),
            (this.x = (p - g) / M),
            (this.y = (u - m) / M),
            (this.z = (d - h) / M),
            (this.w = Math.acos((c + f + _ - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      je.prototype.isVector4 = !0;
      class St extends kn {
        constructor(e, t, n = {}) {
          super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new je(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new je(0, 0, e, t));
          const i = { width: e, height: t, depth: 1 };
          (this.texture = new rt(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps =
              n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.internalFormat =
              n.internalFormat !== void 0 ? n.internalFormat : null),
            (this.texture.minFilter =
              n.minFilter !== void 0 ? n.minFilter : pt),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
              n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
              n.depthTexture !== void 0 ? n.depthTexture : null),
            (this.samples = n.samples !== void 0 ? n.samples : 0);
        }
        setSize(e, t, n = 1) {
          (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new To(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            e.depthTexture !== null &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      St.prototype.isWebGLRenderTarget = !0;
      class sr extends rt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = at),
            (this.minFilter = at),
            (this.wrapR = Et),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      sr.prototype.isDataArrayTexture = !0;
      class hu extends St {
        constructor(e, t, n) {
          super(e, t),
            (this.depth = n),
            (this.texture = new sr(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
        }
      }
      hu.prototype.isWebGLArrayRenderTarget = !0;
      class Eo extends rt {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = at),
            (this.minFilter = at),
            (this.wrapR = Et),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      Eo.prototype.isData3DTexture = !0;
      class uu extends St {
        constructor(e, t, n) {
          super(e, t),
            (this.depth = n),
            (this.texture = new Eo(null, e, t, n)),
            (this.texture.isRenderTargetTexture = !0);
        }
      }
      uu.prototype.isWebGL3DRenderTarget = !0;
      class du extends St {
        constructor(e, t, n, i = {}) {
          super(e, t, i);
          const s = this.texture;
          this.texture = [];
          for (let o = 0; o < n; o++)
            (this.texture[o] = s.clone()),
              (this.texture[o].isRenderTargetTexture = !0);
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, s = this.texture.length; i < s; i++)
              (this.texture[i].image.width = e),
                (this.texture[i].image.height = t),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
          );
        }
        copy(e) {
          this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            e.depthTexture !== null &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.texture.length = 0);
          for (let t = 0, n = e.texture.length; t < n; t++)
            (this.texture[t] = e.texture[t].clone()),
              (this.texture[t].isRenderTargetTexture = !0);
          return this;
        }
      }
      du.prototype.isWebGLMultipleRenderTargets = !0;
      class yt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this._x = e), (this._y = t), (this._z = n), (this._w = i);
        }
        static slerp(e, t, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
          );
        }
        static slerpFlat(e, t, n, i, s, o, a) {
          let l = n[i + 0],
            c = n[i + 1],
            h = n[i + 2],
            u = n[i + 3];
          const d = s[o + 0],
            f = s[o + 1],
            g = s[o + 2],
            m = s[o + 3];
          if (a === 0) {
            (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
            return;
          }
          if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = g), (e[t + 3] = m);
            return;
          }
          if (u !== m || l !== d || c !== f || h !== g) {
            let p = 1 - a;
            const _ = l * d + c * f + h * g + u * m,
              M = _ >= 0 ? 1 : -1,
              T = 1 - _ * _;
            if (T > Number.EPSILON) {
              const w = Math.sqrt(T),
                R = Math.atan2(w, _ * M);
              (p = Math.sin(p * R) / w), (a = Math.sin(a * R) / w);
            }
            const E = a * M;
            if (
              ((l = l * p + d * E),
              (c = c * p + f * E),
              (h = h * p + g * E),
              (u = u * p + m * E),
              p === 1 - a)
            ) {
              const w = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
              (l *= w), (c *= w), (h *= w), (u *= w);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, s, o) {
          const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            u = s[o],
            d = s[o + 1],
            f = s[o + 2],
            g = s[o + 3];
          return (
            (e[t] = a * g + h * u + l * f - c * d),
            (e[t + 1] = l * g + h * d + c * u - a * f),
            (e[t + 2] = c * g + h * f + a * d - l * u),
            (e[t + 3] = h * g - a * u - l * d - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          if (!(e && e.isEuler))
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = e._x,
            i = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            h = a(i / 2),
            u = a(s / 2),
            d = l(n / 2),
            f = l(i / 2),
            g = l(s / 2);
          switch (o) {
            case "XYZ":
              (this._x = d * h * u + c * f * g),
                (this._y = c * f * u - d * h * g),
                (this._z = c * h * g + d * f * u),
                (this._w = c * h * u - d * f * g);
              break;
            case "YXZ":
              (this._x = d * h * u + c * f * g),
                (this._y = c * f * u - d * h * g),
                (this._z = c * h * g - d * f * u),
                (this._w = c * h * u + d * f * g);
              break;
            case "ZXY":
              (this._x = d * h * u - c * f * g),
                (this._y = c * f * u + d * h * g),
                (this._z = c * h * g + d * f * u),
                (this._w = c * h * u - d * f * g);
              break;
            case "ZYX":
              (this._x = d * h * u - c * f * g),
                (this._y = c * f * u + d * h * g),
                (this._z = c * h * g - d * f * u),
                (this._w = c * h * u + d * f * g);
              break;
            case "YZX":
              (this._x = d * h * u + c * f * g),
                (this._y = c * f * u + d * h * g),
                (this._z = c * h * g - d * f * u),
                (this._w = c * h * u - d * f * g);
              break;
            case "XZY":
              (this._x = d * h * u - c * f * g),
                (this._y = c * f * u - d * h * g),
                (this._z = c * h * g + d * f * u),
                (this._w = c * h * u + d * f * g);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return t !== !1 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            h = t[6],
            u = t[10],
            d = n + a + u;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
              (this._x = (h - l) * f),
              (this._y = (s - c) * f),
              (this._z = (o - i) * f);
          } else if (n > a && n > u) {
            const f = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (h - l) / f),
              (this._x = 0.25 * f),
              (this._y = (i + o) / f),
              (this._z = (s + c) / f);
          } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (s - c) / f),
              (this._x = (i + o) / f),
              (this._y = 0.25 * f),
              (this._z = (l + h) / f);
          } else {
            const f = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (o - i) / f),
              (this._x = (s + c) / f),
              (this._y = (l + h) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(ut(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (n === 0) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            h = t._w;
          return (
            (this._x = n * h + o * a + i * c - s * l),
            (this._y = i * h + o * l + s * a - n * c),
            (this._z = s * h + o * c + n * l - i * a),
            (this._w = o * h - n * a - i * l - s * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const n = this._x,
            i = this._y,
            s = this._z,
            o = this._w;
          let a = o * e._w + n * e._x + i * e._y + s * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = s), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * n + t * this._x),
              (this._y = f * i + t * this._y),
              (this._z = f * s + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            h = Math.atan2(c, a),
            u = Math.sin((1 - t) * h) / c,
            d = Math.sin(t * h) / c;
          return (
            (this._w = o * u + this._w * d),
            (this._x = n * u + this._x * d),
            (this._y = i * u + this._y * d),
            (this._z = s * u + this._z * d),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          return this.copy(e).slerp(t, n);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            n = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
          return this.set(
            t * Math.cos(i),
            n * Math.sin(s),
            n * Math.cos(s),
            t * Math.sin(i)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      yt.prototype.isQuaternion = !0;
      class S {
        constructor(e = 0, t = 0, n = 0) {
          (this.x = e), (this.y = t), (this.z = n);
        }
        set(e, t, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return (
            (e && e.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(Ta.setFromEuler(e))
          );
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(Ta.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[3] * n + s[6] * i),
            (this.y = s[1] * t + s[4] * n + s[7] * i),
            (this.z = s[2] * t + s[5] * n + s[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
          return (
            (this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o),
            (this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o),
            (this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * i - a * n,
            h = l * n + a * t - s * i,
            u = l * i + s * n - o * t,
            d = -s * t - o * n - a * i;
          return (
            (this.x = c * l + d * -s + h * -a - u * -o),
            (this.y = h * l + d * -o + u * -s - c * -a),
            (this.z = u * l + d * -a + c * -o - h * -s),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * n + s[8] * i),
            (this.y = s[1] * t + s[5] * n + s[9] * i),
            (this.z = s[2] * t + s[6] * n + s[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = i * l - s * a),
            (this.y = s * o - n * l),
            (this.z = n * a - i * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return Ar.copy(this).projectOnVector(e), this.sub(Ar);
        }
        reflect(e) {
          return this.sub(Ar.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(ut(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t, n) {
          return (
            n !== void 0 &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = (Math.random() - 0.5) * 2,
            t = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - e ** 2);
          return (
            (this.x = n * Math.cos(t)),
            (this.y = n * Math.sin(t)),
            (this.z = e),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      S.prototype.isVector3 = !0;
      const Ar = new S(),
        Ta = new yt();
      class Ct {
        constructor(
          e = new S(1 / 0, 1 / 0, 1 / 0),
          t = new S(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            s = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.length; l < c; l += 3) {
            const h = e[l],
              u = e[l + 1],
              d = e[l + 2];
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > s && (s = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(s, o, a), this;
        }
        setFromBufferAttribute(e) {
          let t = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            s = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          for (let l = 0, c = e.count; l < c; l++) {
            const h = e.getX(l),
              u = e.getY(l),
              d = e.getZ(l);
            h < t && (t = h),
              u < n && (n = u),
              d < i && (i = d),
              h > s && (s = h),
              u > o && (o = u),
              d > a && (a = d);
          }
          return this.min.set(t, n, i), this.max.set(s, o, a), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Rn.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const n = e.geometry;
          if (n !== void 0)
            if (t && n.attributes != null && n.attributes.position !== void 0) {
              const s = n.attributes.position;
              for (let o = 0, a = s.count; o < a; o++)
                Rn.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                  this.expandByPoint(Rn);
            } else
              n.boundingBox === null && n.computeBoundingBox(),
                Rr.copy(n.boundingBox),
                Rr.applyMatrix4(e.matrixWorld),
                this.union(Rr);
          const i = e.children;
          for (let s = 0, o = i.length; s < o; s++)
            this.expandByObject(i[s], t);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, Rn),
            Rn.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(Hi),
            vs.subVectors(this.max, Hi),
            Zn.subVectors(e.a, Hi),
            $n.subVectors(e.b, Hi),
            Qn.subVectors(e.c, Hi),
            cn.subVectors($n, Zn),
            hn.subVectors(Qn, $n),
            Ln.subVectors(Zn, Qn);
          let t = [
            0,
            -cn.z,
            cn.y,
            0,
            -hn.z,
            hn.y,
            0,
            -Ln.z,
            Ln.y,
            cn.z,
            0,
            -cn.x,
            hn.z,
            0,
            -hn.x,
            Ln.z,
            0,
            -Ln.x,
            -cn.y,
            cn.x,
            0,
            -hn.y,
            hn.x,
            0,
            -Ln.y,
            Ln.x,
            0,
          ];
          return !Lr(t, Zn, $n, Qn, vs) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Lr(t, Zn, $n, Qn, vs))
            ? !1
            : (Ms.crossVectors(cn, hn),
              (t = [Ms.x, Ms.y, Ms.z]),
              Lr(t, Zn, $n, Qn, vs));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return Rn.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          return (
            this.getCenter(e.center),
            (e.radius = this.getSize(Rn).length() * 0.5),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (jt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              jt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              jt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              jt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              jt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              jt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              jt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              jt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(jt),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      Ct.prototype.isBox3 = !0;
      const jt = [
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
          new S(),
        ],
        Rn = new S(),
        Rr = new Ct(),
        Zn = new S(),
        $n = new S(),
        Qn = new S(),
        cn = new S(),
        hn = new S(),
        Ln = new S(),
        Hi = new S(),
        vs = new S(),
        Ms = new S(),
        Cn = new S();
      function Lr(r, e, t, n, i) {
        for (let s = 0, o = r.length - 3; s <= o; s += 3) {
          Cn.fromArray(r, s);
          const a =
              i.x * Math.abs(Cn.x) +
              i.y * Math.abs(Cn.y) +
              i.z * Math.abs(Cn.z),
            l = e.dot(Cn),
            c = t.dot(Cn),
            h = n.dot(Cn);
          if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
        }
        return !0;
      }
      const fu = new Ct(),
        Ea = new S(),
        bs = new S(),
        Cr = new S();
      class Wn {
        constructor(e = new S(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          t !== void 0 ? n.copy(t) : fu.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let s = 0, o = e.length; s < o; s++)
            i = Math.max(i, n.distanceToSquared(e[s]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          Cr.subVectors(e, this.center);
          const t = Cr.lengthSq();
          if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
              i = (n - this.radius) * 0.5;
            this.center.add(Cr.multiplyScalar(i / n)), (this.radius += i);
          }
          return this;
        }
        union(e) {
          return (
            this.center.equals(e.center) === !0
              ? bs.set(0, 0, 1).multiplyScalar(e.radius)
              : bs
                  .subVectors(e.center, this.center)
                  .normalize()
                  .multiplyScalar(e.radius),
            this.expandByPoint(Ea.copy(e.center).add(bs)),
            this.expandByPoint(Ea.copy(e.center).sub(bs)),
            this
          );
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Yt = new S(),
        Pr = new S(),
        ws = new S(),
        un = new S(),
        Ir = new S(),
        Ss = new S(),
        Dr = new S();
      class Pi {
        constructor(e = new S(), t = new S(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, Yt)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = Yt.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (Yt.copy(this.direction).multiplyScalar(t).add(this.origin),
              Yt.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          Pr.copy(e).add(t).multiplyScalar(0.5),
            ws.copy(t).sub(e).normalize(),
            un.copy(this.origin).sub(Pr);
          const s = e.distanceTo(t) * 0.5,
            o = -this.direction.dot(ws),
            a = un.dot(this.direction),
            l = -un.dot(ws),
            c = un.lengthSq(),
            h = Math.abs(1 - o * o);
          let u, d, f, g;
          if (h > 0)
            if (((u = o * l - a), (d = o * a - l), (g = s * h), u >= 0))
              if (d >= -g)
                if (d <= g) {
                  const m = 1 / h;
                  (u *= m),
                    (d *= m),
                    (f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c);
                } else
                  (d = s),
                    (u = Math.max(0, -(o * d + a))),
                    (f = -u * u + d * (d + 2 * l) + c);
              else
                (d = -s),
                  (u = Math.max(0, -(o * d + a))),
                  (f = -u * u + d * (d + 2 * l) + c);
            else
              d <= -g
                ? ((u = Math.max(0, -(-o * s + a))),
                  (d = u > 0 ? -s : Math.min(Math.max(-s, -l), s)),
                  (f = -u * u + d * (d + 2 * l) + c))
                : d <= g
                ? ((u = 0),
                  (d = Math.min(Math.max(-s, -l), s)),
                  (f = d * (d + 2 * l) + c))
                : ((u = Math.max(0, -(o * s + a))),
                  (d = u > 0 ? s : Math.min(Math.max(-s, -l), s)),
                  (f = -u * u + d * (d + 2 * l) + c));
          else
            (d = o > 0 ? -s : s),
              (u = Math.max(0, -(o * d + a))),
              (f = -u * u + d * (d + 2 * l) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(ws).multiplyScalar(d).add(Pr),
            f
          );
        }
        intersectSphere(e, t) {
          Yt.subVectors(e.center, this.origin);
          const n = Yt.dot(this.direction),
            i = Yt.dot(Yt) - n * n,
            s = e.radius * e.radius;
          if (i > s) return null;
          const o = Math.sqrt(s - i),
            a = n - o,
            l = n + o;
          return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, s, o, a, l;
          const c = 1 / this.direction.x,
            h = 1 / this.direction.y,
            u = 1 / this.direction.z,
            d = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
              : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
            h >= 0
              ? ((s = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h))
              : ((s = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
            n > o ||
            s > i ||
            ((s > n || n !== n) && (n = s),
            (o < i || i !== i) && (i = o),
            u >= 0
              ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
              : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
            n > l || a > i) ||
            ((a > n || n !== n) && (n = a),
            (l < i || i !== i) && (i = l),
            i < 0)
              ? null
              : this.at(n >= 0 ? n : i, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, Yt) !== null;
        }
        intersectTriangle(e, t, n, i, s) {
          Ir.subVectors(t, e), Ss.subVectors(n, e), Dr.crossVectors(Ir, Ss);
          let o = this.direction.dot(Dr),
            a;
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else if (o < 0) (a = -1), (o = -o);
          else return null;
          un.subVectors(this.origin, e);
          const l = a * this.direction.dot(Ss.crossVectors(un, Ss));
          if (l < 0) return null;
          const c = a * this.direction.dot(Ir.cross(un));
          if (c < 0 || l + c > o) return null;
          const h = -a * un.dot(Dr);
          return h < 0 ? null : this.at(h / o, s);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class me {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(e, t, n, i, s, o, a, l, c, h, u, d, f, g, m, p) {
          const _ = this.elements;
          return (
            (_[0] = e),
            (_[4] = t),
            (_[8] = n),
            (_[12] = i),
            (_[1] = s),
            (_[5] = o),
            (_[9] = a),
            (_[13] = l),
            (_[2] = c),
            (_[6] = h),
            (_[10] = u),
            (_[14] = d),
            (_[3] = f),
            (_[7] = g),
            (_[11] = m),
            (_[15] = p),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new me().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / ei.setFromMatrixColumn(e, 0).length(),
            s = 1 / ei.setFromMatrixColumn(e, 1).length(),
            o = 1 / ei.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * s),
            (t[5] = n[5] * s),
            (t[6] = n[6] * s),
            (t[7] = 0),
            (t[8] = n[8] * o),
            (t[9] = n[9] * o),
            (t[10] = n[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          (e && e.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const t = this.elements,
            n = e.x,
            i = e.y,
            s = e.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            h = Math.cos(s),
            u = Math.sin(s);
          if (e.order === "XYZ") {
            const d = o * h,
              f = o * u,
              g = a * h,
              m = a * u;
            (t[0] = l * h),
              (t[4] = -l * u),
              (t[8] = c),
              (t[1] = f + g * c),
              (t[5] = d - m * c),
              (t[9] = -a * l),
              (t[2] = m - d * c),
              (t[6] = g + f * c),
              (t[10] = o * l);
          } else if (e.order === "YXZ") {
            const d = l * h,
              f = l * u,
              g = c * h,
              m = c * u;
            (t[0] = d + m * a),
              (t[4] = g * a - f),
              (t[8] = o * c),
              (t[1] = o * u),
              (t[5] = o * h),
              (t[9] = -a),
              (t[2] = f * a - g),
              (t[6] = m + d * a),
              (t[10] = o * l);
          } else if (e.order === "ZXY") {
            const d = l * h,
              f = l * u,
              g = c * h,
              m = c * u;
            (t[0] = d - m * a),
              (t[4] = -o * u),
              (t[8] = g + f * a),
              (t[1] = f + g * a),
              (t[5] = o * h),
              (t[9] = m - d * a),
              (t[2] = -o * c),
              (t[6] = a),
              (t[10] = o * l);
          } else if (e.order === "ZYX") {
            const d = o * h,
              f = o * u,
              g = a * h,
              m = a * u;
            (t[0] = l * h),
              (t[4] = g * c - f),
              (t[8] = d * c + m),
              (t[1] = l * u),
              (t[5] = m * c + d),
              (t[9] = f * c - g),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = o * l);
          } else if (e.order === "YZX") {
            const d = o * l,
              f = o * c,
              g = a * l,
              m = a * c;
            (t[0] = l * h),
              (t[4] = m - d * u),
              (t[8] = g * u + f),
              (t[1] = u),
              (t[5] = o * h),
              (t[9] = -a * h),
              (t[2] = -c * h),
              (t[6] = f * u + g),
              (t[10] = d - m * u);
          } else if (e.order === "XZY") {
            const d = o * l,
              f = o * c,
              g = a * l,
              m = a * c;
            (t[0] = l * h),
              (t[4] = -u),
              (t[8] = c * h),
              (t[1] = d * u + m),
              (t[5] = o * h),
              (t[9] = f * u - g),
              (t[2] = g * u - f),
              (t[6] = a * h),
              (t[10] = m * u + d);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(pu, e, mu);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            bt.subVectors(e, t),
            bt.lengthSq() === 0 && (bt.z = 1),
            bt.normalize(),
            dn.crossVectors(n, bt),
            dn.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (bt.x += 1e-4) : (bt.z += 1e-4),
              bt.normalize(),
              dn.crossVectors(n, bt)),
            dn.normalize(),
            Ts.crossVectors(bt, dn),
            (i[0] = dn.x),
            (i[4] = Ts.x),
            (i[8] = bt.x),
            (i[1] = dn.y),
            (i[5] = Ts.y),
            (i[9] = bt.y),
            (i[2] = dn.z),
            (i[6] = Ts.z),
            (i[10] = bt.z),
            this
          );
        }
        multiply(e, t) {
          return t !== void 0
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(e, t))
            : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            s = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            u = n[5],
            d = n[9],
            f = n[13],
            g = n[2],
            m = n[6],
            p = n[10],
            _ = n[14],
            M = n[3],
            T = n[7],
            E = n[11],
            w = n[15],
            R = i[0],
            P = i[4],
            y = i[8],
            L = i[12],
            N = i[1],
            D = i[5],
            ie = i[9],
            J = i[13],
            C = i[2],
            H = i[6],
            B = i[10],
            V = i[14],
            X = i[3],
            U = i[7],
            W = i[11],
            Q = i[15];
          return (
            (s[0] = o * R + a * N + l * C + c * X),
            (s[4] = o * P + a * D + l * H + c * U),
            (s[8] = o * y + a * ie + l * B + c * W),
            (s[12] = o * L + a * J + l * V + c * Q),
            (s[1] = h * R + u * N + d * C + f * X),
            (s[5] = h * P + u * D + d * H + f * U),
            (s[9] = h * y + u * ie + d * B + f * W),
            (s[13] = h * L + u * J + d * V + f * Q),
            (s[2] = g * R + m * N + p * C + _ * X),
            (s[6] = g * P + m * D + p * H + _ * U),
            (s[10] = g * y + m * ie + p * B + _ * W),
            (s[14] = g * L + m * J + p * V + _ * Q),
            (s[3] = M * R + T * N + E * C + w * X),
            (s[7] = M * P + T * D + E * H + w * U),
            (s[11] = M * y + T * ie + E * B + w * W),
            (s[15] = M * L + T * J + E * V + w * Q),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            h = e[2],
            u = e[6],
            d = e[10],
            f = e[14],
            g = e[3],
            m = e[7],
            p = e[11],
            _ = e[15];
          return (
            g *
              (+s * l * u -
                i * c * u -
                s * a * d +
                n * c * d +
                i * a * f -
                n * l * f) +
            m *
              (+t * l * f -
                t * c * d +
                s * o * d -
                i * o * f +
                i * c * h -
                s * l * h) +
            p *
              (+t * c * u -
                t * a * f -
                s * o * u +
                n * o * f +
                s * a * h -
                n * c * h) +
            _ *
              (-i * a * h -
                t * l * u +
                t * a * d +
                i * o * u -
                n * o * d +
                n * l * h)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = e[9],
            d = e[10],
            f = e[11],
            g = e[12],
            m = e[13],
            p = e[14],
            _ = e[15],
            M =
              u * p * c -
              m * d * c +
              m * l * f -
              a * p * f -
              u * l * _ +
              a * d * _,
            T =
              g * d * c -
              h * p * c -
              g * l * f +
              o * p * f +
              h * l * _ -
              o * d * _,
            E =
              h * m * c -
              g * u * c +
              g * a * f -
              o * m * f -
              h * a * _ +
              o * u * _,
            w =
              g * u * l -
              h * m * l -
              g * a * d +
              o * m * d +
              h * a * p -
              o * u * p,
            R = t * M + n * T + i * E + s * w;
          if (R === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const P = 1 / R;
          return (
            (e[0] = M * P),
            (e[1] =
              (m * d * s -
                u * p * s -
                m * i * f +
                n * p * f +
                u * i * _ -
                n * d * _) *
              P),
            (e[2] =
              (a * p * s -
                m * l * s +
                m * i * c -
                n * p * c -
                a * i * _ +
                n * l * _) *
              P),
            (e[3] =
              (u * l * s -
                a * d * s -
                u * i * c +
                n * d * c +
                a * i * f -
                n * l * f) *
              P),
            (e[4] = T * P),
            (e[5] =
              (h * p * s -
                g * d * s +
                g * i * f -
                t * p * f -
                h * i * _ +
                t * d * _) *
              P),
            (e[6] =
              (g * l * s -
                o * p * s -
                g * i * c +
                t * p * c +
                o * i * _ -
                t * l * _) *
              P),
            (e[7] =
              (o * d * s -
                h * l * s +
                h * i * c -
                t * d * c -
                o * i * f +
                t * l * f) *
              P),
            (e[8] = E * P),
            (e[9] =
              (g * u * s -
                h * m * s -
                g * n * f +
                t * m * f +
                h * n * _ -
                t * u * _) *
              P),
            (e[10] =
              (o * m * s -
                g * a * s +
                g * n * c -
                t * m * c -
                o * n * _ +
                t * a * _) *
              P),
            (e[11] =
              (h * a * s -
                o * u * s -
                h * n * c +
                t * u * c +
                o * n * f -
                t * a * f) *
              P),
            (e[12] = w * P),
            (e[13] =
              (h * m * i -
                g * u * i +
                g * n * d -
                t * m * d -
                h * n * p +
                t * u * p) *
              P),
            (e[14] =
              (g * a * i -
                o * m * i -
                g * n * l +
                t * m * l +
                o * n * p -
                t * a * p) *
              P),
            (e[15] =
              (o * u * i -
                h * a * i +
                h * n * l -
                t * u * l -
                o * n * d +
                t * a * d) *
              P),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            s = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= s),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= s),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= s),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= s),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            s = 1 - n,
            o = e.x,
            a = e.y,
            l = e.z,
            c = s * o,
            h = s * a;
          return (
            this.set(
              c * o + n,
              c * a - i * l,
              c * l + i * a,
              0,
              c * a + i * l,
              h * a + n,
              h * l - i * o,
              0,
              c * l - i * a,
              h * l + i * o,
              s * l * l + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, s, o) {
          return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = s + s,
            h = o + o,
            u = a + a,
            d = s * c,
            f = s * h,
            g = s * u,
            m = o * h,
            p = o * u,
            _ = a * u,
            M = l * c,
            T = l * h,
            E = l * u,
            w = n.x,
            R = n.y,
            P = n.z;
          return (
            (i[0] = (1 - (m + _)) * w),
            (i[1] = (f + E) * w),
            (i[2] = (g - T) * w),
            (i[3] = 0),
            (i[4] = (f - E) * R),
            (i[5] = (1 - (d + _)) * R),
            (i[6] = (p + M) * R),
            (i[7] = 0),
            (i[8] = (g + T) * P),
            (i[9] = (p - M) * P),
            (i[10] = (1 - (d + m)) * P),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let s = ei.set(i[0], i[1], i[2]).length();
          const o = ei.set(i[4], i[5], i[6]).length(),
            a = ei.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (s = -s),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            Dt.copy(this);
          const c = 1 / s,
            h = 1 / o,
            u = 1 / a;
          return (
            (Dt.elements[0] *= c),
            (Dt.elements[1] *= c),
            (Dt.elements[2] *= c),
            (Dt.elements[4] *= h),
            (Dt.elements[5] *= h),
            (Dt.elements[6] *= h),
            (Dt.elements[8] *= u),
            (Dt.elements[9] *= u),
            (Dt.elements[10] *= u),
            t.setFromRotationMatrix(Dt),
            (n.x = s),
            (n.y = o),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, s, o) {
          o === void 0 &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const a = this.elements,
            l = (2 * s) / (t - e),
            c = (2 * s) / (n - i),
            h = (t + e) / (t - e),
            u = (n + i) / (n - i),
            d = -(o + s) / (o - s),
            f = (-2 * o * s) / (o - s);
          return (
            (a[0] = l),
            (a[4] = 0),
            (a[8] = h),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = u),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, s, o) {
          const a = this.elements,
            l = 1 / (t - e),
            c = 1 / (n - i),
            h = 1 / (o - s),
            u = (t + e) * l,
            d = (n + i) * c,
            f = (o + s) * h;
          return (
            (a[0] = 2 * l),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -u),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * h),
            (a[14] = -f),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      me.prototype.isMatrix4 = !0;
      const ei = new S(),
        Dt = new me(),
        pu = new S(0, 0, 0),
        mu = new S(1, 1, 1),
        dn = new S(),
        Ts = new S(),
        bt = new S(),
        Aa = new me(),
        Ra = new yt();
      class qn {
        constructor(e = 0, t = 0, n = 0, i = qn.DefaultOrder) {
          (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
          const i = e.elements,
            s = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            h = i[9],
            u = i[2],
            d = i[6],
            f = i[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin(ut(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-o, s)))
                  : ((this._x = Math.atan2(d, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-ut(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
                  : ((this._y = Math.atan2(-u, s)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(ut(d, -1, 1))),
                Math.abs(d) < 0.9999999
                  ? ((this._y = Math.atan2(-u, f)),
                    (this._z = Math.atan2(-o, c)))
                  : ((this._y = 0), (this._z = Math.atan2(l, s)));
              break;
            case "ZYX":
              (this._y = Math.asin(-ut(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, s)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, c)));
              break;
            case "YZX":
              (this._z = Math.asin(ut(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-h, c)),
                    (this._y = Math.atan2(-u, s)))
                  : ((this._x = 0), (this._y = Math.atan2(a, f)));
              break;
            case "XZY":
              (this._z = Math.asin(-ut(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, s)))
                  : ((this._x = Math.atan2(-h, f)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            Aa.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Aa, t, n)
          );
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return Ra.setFromEuler(this), this.setFromQuaternion(Ra, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      qn.prototype.isEuler = !0;
      qn.DefaultOrder = "XYZ";
      qn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class jl {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & ((1 << e) | 0)) !== 0;
        }
      }
      let gu = 0;
      const La = new S(),
        ti = new yt(),
        Jt = new me(),
        Es = new S(),
        Gi = new S(),
        _u = new S(),
        xu = new yt(),
        Ca = new S(1, 0, 0),
        Pa = new S(0, 1, 0),
        Ia = new S(0, 0, 1),
        yu = { type: "added" },
        Da = { type: "removed" };
      class Ve extends kn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: gu++ }),
            (this.uuid = Rt()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Ve.DefaultUp.clone());
          const e = new S(),
            t = new qn(),
            n = new yt(),
            i = new S(1, 1, 1);
          function s() {
            n.setFromEuler(t, !1);
          }
          function o() {
            t.setFromQuaternion(n, void 0, !1);
          }
          t._onChange(s),
            n._onChange(o),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new me() },
              normalMatrix: { value: new dt() },
            }),
            (this.matrix = new me()),
            (this.matrixWorld = new me()),
            (this.matrixAutoUpdate = Ve.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new jl()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return ti.setFromAxisAngle(e, t), this.quaternion.multiply(ti), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            ti.setFromAxisAngle(e, t), this.quaternion.premultiply(ti), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(Ca, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(Pa, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(Ia, e);
        }
        translateOnAxis(e, t) {
          return (
            La.copy(e).applyQuaternion(this.quaternion),
            this.position.add(La.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(Ca, e);
        }
        translateY(e) {
          return this.translateOnAxis(Pa, e);
        }
        translateZ(e) {
          return this.translateOnAxis(Ia, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(Jt.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
          e.isVector3 ? Es.copy(e) : Es.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            Gi.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Jt.lookAt(Gi, Es, this.up)
              : Jt.lookAt(Es, Gi, this.up),
            this.quaternion.setFromRotationMatrix(Jt),
            i &&
              (Jt.extractRotation(i.matrixWorld),
              ti.setFromRotationMatrix(Jt),
              this.quaternion.premultiply(ti.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.parent !== null && e.parent.remove(e),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(yu))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(Da)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            (t.parent = null), t.dispatchEvent(Da);
          }
          return (this.children.length = 0), this;
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            Jt.copy(this.matrixWorld).invert(),
            e.parent !== null &&
              (e.parent.updateWorldMatrix(!0, !1),
              Jt.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Jt),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0) return o;
          }
        }
        getWorldPosition(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Gi, e, _u),
            e
          );
        }
        getWorldScale(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Gi, xu, e),
            e
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            t === !0)
          ) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++)
              i[s].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            JSON.stringify(this.userData) !== "{}" &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (i.instanceColor = this.instanceColor.toJSON()));
          function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
          }
          if (this.isScene)
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const l = a.shapes;
              if (Array.isArray(l))
                for (let c = 0, h = l.length; c < h; c++) {
                  const u = l[c];
                  s(e.shapes, u);
                }
              else s(e.shapes, l);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (s(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const a = [];
              for (let l = 0, c = this.material.length; l < c; l++)
                a.push(s(e.materials, this.material[l]));
              i.material = a;
            } else i.material = s(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
              i.children.push(this.children[a].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const l = this.animations[a];
              i.animations.push(s(e.animations, l));
            }
          }
          if (t) {
            const a = o(e.geometries),
              l = o(e.materials),
              c = o(e.textures),
              h = o(e.images),
              u = o(e.shapes),
              d = o(e.skeletons),
              f = o(e.animations),
              g = o(e.nodes);
            a.length > 0 && (n.geometries = a),
              l.length > 0 && (n.materials = l),
              c.length > 0 && (n.textures = c),
              h.length > 0 && (n.images = h),
              u.length > 0 && (n.shapes = u),
              d.length > 0 && (n.skeletons = d),
              f.length > 0 && (n.animations = f),
              g.length > 0 && (n.nodes = g);
          }
          return (n.object = i), n;
          function o(a) {
            const l = [];
            for (const c in a) {
              const h = a[c];
              delete h.metadata, l.push(h);
            }
            return l;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let n = 0; n < e.children.length; n++) {
              const i = e.children[n];
              this.add(i.clone());
            }
          return this;
        }
      }
      Ve.DefaultUp = new S(0, 1, 0);
      Ve.DefaultMatrixAutoUpdate = !0;
      Ve.prototype.isObject3D = !0;
      const Ft = new S(),
        Kt = new S(),
        Fr = new S(),
        Zt = new S(),
        ni = new S(),
        ii = new S(),
        Fa = new S(),
        Nr = new S(),
        Br = new S(),
        Or = new S();
      class st {
        constructor(e = new S(), t = new S(), n = new S()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i.subVectors(n, t), Ft.subVectors(e, t), i.cross(Ft);
          const s = i.lengthSq();
          return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, s) {
          Ft.subVectors(i, t), Kt.subVectors(n, t), Fr.subVectors(e, t);
          const o = Ft.dot(Ft),
            a = Ft.dot(Kt),
            l = Ft.dot(Fr),
            c = Kt.dot(Kt),
            h = Kt.dot(Fr),
            u = o * c - a * a;
          if (u === 0) return s.set(-2, -1, -1);
          const d = 1 / u,
            f = (c * l - a * h) * d,
            g = (o * h - a * l) * d;
          return s.set(1 - f - g, g, f);
        }
        static containsPoint(e, t, n, i) {
          return (
            this.getBarycoord(e, t, n, i, Zt),
            Zt.x >= 0 && Zt.y >= 0 && Zt.x + Zt.y <= 1
          );
        }
        static getUV(e, t, n, i, s, o, a, l) {
          return (
            this.getBarycoord(e, t, n, i, Zt),
            l.set(0, 0),
            l.addScaledVector(s, Zt.x),
            l.addScaledVector(o, Zt.y),
            l.addScaledVector(a, Zt.z),
            l
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            Ft.subVectors(n, t), Kt.subVectors(e, t), Ft.cross(Kt).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            Ft.subVectors(this.c, this.b),
            Kt.subVectors(this.a, this.b),
            Ft.cross(Kt).length() * 0.5
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return st.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return st.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, s) {
          return st.getUV(e, this.a, this.b, this.c, t, n, i, s);
        }
        containsPoint(e) {
          return st.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return st.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const n = this.a,
            i = this.b,
            s = this.c;
          let o, a;
          ni.subVectors(i, n), ii.subVectors(s, n), Nr.subVectors(e, n);
          const l = ni.dot(Nr),
            c = ii.dot(Nr);
          if (l <= 0 && c <= 0) return t.copy(n);
          Br.subVectors(e, i);
          const h = ni.dot(Br),
            u = ii.dot(Br);
          if (h >= 0 && u <= h) return t.copy(i);
          const d = l * u - h * c;
          if (d <= 0 && l >= 0 && h <= 0)
            return (o = l / (l - h)), t.copy(n).addScaledVector(ni, o);
          Or.subVectors(e, s);
          const f = ni.dot(Or),
            g = ii.dot(Or);
          if (g >= 0 && f <= g) return t.copy(s);
          const m = f * c - l * g;
          if (m <= 0 && c >= 0 && g <= 0)
            return (a = c / (c - g)), t.copy(n).addScaledVector(ii, a);
          const p = h * g - f * u;
          if (p <= 0 && u - h >= 0 && f - g >= 0)
            return (
              Fa.subVectors(s, i),
              (a = (u - h) / (u - h + (f - g))),
              t.copy(i).addScaledVector(Fa, a)
            );
          const _ = 1 / (p + m + d);
          return (
            (o = m * _),
            (a = d * _),
            t.copy(n).addScaledVector(ni, o).addScaledVector(ii, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let vu = 0;
      class et extends kn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: vu++ }),
            (this.uuid = Rt()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = yi),
            (this.side = Mi),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = Ul),
            (this.blendDst = zl),
            (this.blendEquation = pi),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = so),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Xh),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = wr),
            (this.stencilZFail = wr),
            (this.stencilZPass = wr),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const n = e[t];
              if (n === void 0) {
                console.warn(
                  "THREE.Material: '" + t + "' parameter is undefined."
                );
                continue;
              }
              if (t === "shading") {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === Ol);
                continue;
              }
              const i = this[t];
              if (i === void 0) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
                continue;
              }
              i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen !== void 0 && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== yi && (n.blending = this.blending),
            this.side !== Mi && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation !== void 0 &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 &&
              (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            this.fog === !1 && (n.fog = !1),
            JSON.stringify(this.userData) !== "{}" &&
              (n.userData = this.userData);
          function i(s) {
            const o = [];
            for (const a in s) {
              const l = s[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (t) {
            const s = i(e.textures),
              o = i(e.images);
            s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      et.prototype.isMaterial = !0;
      et.fromType = function () {
        return null;
      };
      class sn extends et {
        constructor(e) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new he(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = nr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      sn.prototype.isMeshBasicMaterial = !0;
      const it = new S(),
        As = new $();
      class tt {
        constructor(e, t, n) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = n === !0),
            (this.usage = rs),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, s = this.itemSize; i < s; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        copyColorsArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, s = e.length; i < s; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (o = new he())),
              (t[n++] = o.r),
              (t[n++] = o.g),
              (t[n++] = o.b);
          }
          return this;
        }
        copyVector2sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, s = e.length; i < s; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (o = new $())),
              (t[n++] = o.x),
              (t[n++] = o.y);
          }
          return this;
        }
        copyVector3sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, s = e.length; i < s; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (o = new S())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z);
          }
          return this;
        }
        copyVector4sArray(e) {
          const t = this.array;
          let n = 0;
          for (let i = 0, s = e.length; i < s; i++) {
            let o = e[i];
            o === void 0 &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (o = new je())),
              (t[n++] = o.x),
              (t[n++] = o.y),
              (t[n++] = o.z),
              (t[n++] = o.w);
          }
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
              As.fromBufferAttribute(this, t),
                As.applyMatrix3(e),
                this.setXY(t, As.x, As.y);
          else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
              it.fromBufferAttribute(this, t),
                it.applyMatrix3(e),
                this.setXYZ(t, it.x, it.y, it.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            it.fromBufferAttribute(this, t),
              it.applyMatrix4(e),
              this.setXYZ(t, it.x, it.y, it.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            it.fromBufferAttribute(this, t),
              it.applyNormalMatrix(e),
              this.setXYZ(t, it.x, it.y, it.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            it.fromBufferAttribute(this, t),
              it.transformDirection(e),
              this.setXYZ(t, it.x, it.y, it.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          return this.array[e * this.itemSize];
        }
        setX(e, t) {
          return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
          return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
          return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
          return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, s) {
          return (
            (e *= this.itemSize),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = s),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (e.name = this.name),
            this.usage !== rs && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      tt.prototype.isBufferAttribute = !0;
      class Yl extends tt {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class Jl extends tt {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class Mu extends tt {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      Mu.prototype.isFloat16BufferAttribute = !0;
      class ct extends tt {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      let bu = 0;
      const Tt = new me(),
        Ur = new Ve(),
        si = new S(),
        wt = new Ct(),
        ki = new Ct(),
        lt = new S();
      class Ke extends kn {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: bu++ }),
            (this.uuid = Rt()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (ql(e) ? Jl : Yl)(e, 1))
              : (this.index = e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const s = new dt().getNormalMatrix(e);
            n.applyNormalMatrix(s), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Tt.makeRotationFromQuaternion(e), this.applyMatrix4(Tt), this;
        }
        rotateX(e) {
          return Tt.makeRotationX(e), this.applyMatrix4(Tt), this;
        }
        rotateY(e) {
          return Tt.makeRotationY(e), this.applyMatrix4(Tt), this;
        }
        rotateZ(e) {
          return Tt.makeRotationZ(e), this.applyMatrix4(Tt), this;
        }
        translate(e, t, n) {
          return Tt.makeTranslation(e, t, n), this.applyMatrix4(Tt), this;
        }
        scale(e, t, n) {
          return Tt.makeScale(e, t, n), this.applyMatrix4(Tt), this;
        }
        lookAt(e) {
          return (
            Ur.lookAt(e), Ur.updateMatrix(), this.applyMatrix4(Ur.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(si).negate(),
            this.translate(si.x, si.y, si.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const s = e[n];
            t.push(s.x, s.y, s.z || 0);
          }
          return this.setAttribute("position", new ct(t, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new Ct());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingBox.set(
                new S(-1 / 0, -1 / 0, -1 / 0),
                new S(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let n = 0, i = t.length; n < i; n++) {
                const s = t[n];
                wt.setFromBufferAttribute(s),
                  this.morphTargetsRelative
                    ? (lt.addVectors(this.boundingBox.min, wt.min),
                      this.boundingBox.expandByPoint(lt),
                      lt.addVectors(this.boundingBox.max, wt.max),
                      this.boundingBox.expandByPoint(lt))
                    : (this.boundingBox.expandByPoint(wt.min),
                      this.boundingBox.expandByPoint(wt.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new Wn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
              this.boundingSphere.set(new S(), 1 / 0);
            return;
          }
          if (e) {
            const n = this.boundingSphere.center;
            if ((wt.setFromBufferAttribute(e), t))
              for (let s = 0, o = t.length; s < o; s++) {
                const a = t[s];
                ki.setFromBufferAttribute(a),
                  this.morphTargetsRelative
                    ? (lt.addVectors(wt.min, ki.min),
                      wt.expandByPoint(lt),
                      lt.addVectors(wt.max, ki.max),
                      wt.expandByPoint(lt))
                    : (wt.expandByPoint(ki.min), wt.expandByPoint(ki.max));
              }
            wt.getCenter(n);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++)
              lt.fromBufferAttribute(e, s),
                (i = Math.max(i, n.distanceToSquared(lt)));
            if (t)
              for (let s = 0, o = t.length; s < o; s++) {
                const a = t[s],
                  l = this.morphTargetsRelative;
                for (let c = 0, h = a.count; c < h; c++)
                  lt.fromBufferAttribute(a, c),
                    l && (si.fromBufferAttribute(e, c), lt.add(si)),
                    (i = Math.max(i, n.distanceToSquared(lt)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.array,
            i = t.position.array,
            s = t.normal.array,
            o = t.uv.array,
            a = i.length / 3;
          this.hasAttribute("tangent") === !1 &&
            this.setAttribute("tangent", new tt(new Float32Array(4 * a), 4));
          const l = this.getAttribute("tangent").array,
            c = [],
            h = [];
          for (let N = 0; N < a; N++) (c[N] = new S()), (h[N] = new S());
          const u = new S(),
            d = new S(),
            f = new S(),
            g = new $(),
            m = new $(),
            p = new $(),
            _ = new S(),
            M = new S();
          function T(N, D, ie) {
            u.fromArray(i, N * 3),
              d.fromArray(i, D * 3),
              f.fromArray(i, ie * 3),
              g.fromArray(o, N * 2),
              m.fromArray(o, D * 2),
              p.fromArray(o, ie * 2),
              d.sub(u),
              f.sub(u),
              m.sub(g),
              p.sub(g);
            const J = 1 / (m.x * p.y - p.x * m.y);
            !isFinite(J) ||
              (_.copy(d)
                .multiplyScalar(p.y)
                .addScaledVector(f, -m.y)
                .multiplyScalar(J),
              M.copy(f)
                .multiplyScalar(m.x)
                .addScaledVector(d, -p.x)
                .multiplyScalar(J),
              c[N].add(_),
              c[D].add(_),
              c[ie].add(_),
              h[N].add(M),
              h[D].add(M),
              h[ie].add(M));
          }
          let E = this.groups;
          E.length === 0 && (E = [{ start: 0, count: n.length }]);
          for (let N = 0, D = E.length; N < D; ++N) {
            const ie = E[N],
              J = ie.start,
              C = ie.count;
            for (let H = J, B = J + C; H < B; H += 3)
              T(n[H + 0], n[H + 1], n[H + 2]);
          }
          const w = new S(),
            R = new S(),
            P = new S(),
            y = new S();
          function L(N) {
            P.fromArray(s, N * 3), y.copy(P);
            const D = c[N];
            w.copy(D),
              w.sub(P.multiplyScalar(P.dot(D))).normalize(),
              R.crossVectors(y, D);
            const J = R.dot(h[N]) < 0 ? -1 : 1;
            (l[N * 4] = w.x),
              (l[N * 4 + 1] = w.y),
              (l[N * 4 + 2] = w.z),
              (l[N * 4 + 3] = J);
          }
          for (let N = 0, D = E.length; N < D; ++N) {
            const ie = E[N],
              J = ie.start,
              C = ie.count;
            for (let H = J, B = J + C; H < B; H += 3)
              L(n[H + 0]), L(n[H + 1]), L(n[H + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new tt(new Float32Array(t.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const i = new S(),
              s = new S(),
              o = new S(),
              a = new S(),
              l = new S(),
              c = new S(),
              h = new S(),
              u = new S();
            if (e)
              for (let d = 0, f = e.count; d < f; d += 3) {
                const g = e.getX(d + 0),
                  m = e.getX(d + 1),
                  p = e.getX(d + 2);
                i.fromBufferAttribute(t, g),
                  s.fromBufferAttribute(t, m),
                  o.fromBufferAttribute(t, p),
                  h.subVectors(o, s),
                  u.subVectors(i, s),
                  h.cross(u),
                  a.fromBufferAttribute(n, g),
                  l.fromBufferAttribute(n, m),
                  c.fromBufferAttribute(n, p),
                  a.add(h),
                  l.add(h),
                  c.add(h),
                  n.setXYZ(g, a.x, a.y, a.z),
                  n.setXYZ(m, l.x, l.y, l.z),
                  n.setXYZ(p, c.x, c.y, c.z);
              }
            else
              for (let d = 0, f = t.count; d < f; d += 3)
                i.fromBufferAttribute(t, d + 0),
                  s.fromBufferAttribute(t, d + 1),
                  o.fromBufferAttribute(t, d + 2),
                  h.subVectors(o, s),
                  u.subVectors(i, s),
                  h.cross(u),
                  n.setXYZ(d + 0, h.x, h.y, h.z),
                  n.setXYZ(d + 1, h.x, h.y, h.z),
                  n.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(e, t) {
          if (!(e && e.isBufferGeometry)) {
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              e
            );
            return;
          }
          t === void 0 &&
            ((t = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (e.attributes[i] === void 0) continue;
            const o = n[i].array,
              a = e.attributes[i],
              l = a.array,
              c = a.itemSize * t,
              h = Math.min(l.length, o.length - c);
            for (let u = 0, d = c; u < h; u++, d++) o[d] = l[u];
          }
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            lt.fromBufferAttribute(e, t),
              lt.normalize(),
              e.setXYZ(t, lt.x, lt.y, lt.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              h = a.itemSize,
              u = a.normalized,
              d = new c.constructor(l.length * h);
            let f = 0,
              g = 0;
            for (let m = 0, p = l.length; m < p; m++) {
              a.isInterleavedBufferAttribute
                ? (f = l[m] * a.data.stride + a.offset)
                : (f = l[m] * h);
              for (let _ = 0; _ < h; _++) d[g++] = c[f++];
            }
            return new tt(d, h, u);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new Ke(),
            n = this.index.array,
            i = this.attributes;
          for (const a in i) {
            const l = i[a],
              c = e(l, n);
            t.setAttribute(a, c);
          }
          const s = this.morphAttributes;
          for (const a in s) {
            const l = [],
              c = s[a];
            for (let h = 0, u = c.length; h < u; h++) {
              const d = c[h],
                f = e(d, n);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data);
          }
          const i = {};
          let s = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              h = [];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = c[u];
              h.push(f.toJSON(e.data));
            }
            h.length > 0 && ((i[l] = h), (s = !0));
          }
          s &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            a !== null &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          n !== null && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const c in i) {
            const h = i[c];
            this.setAttribute(c, h.clone(t));
          }
          const s = e.morphAttributes;
          for (const c in s) {
            const h = [],
              u = s[c];
            for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
            this.morphAttributes[c] = h;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          const a = e.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            l !== null && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            e.parameters !== void 0 &&
              (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Ke.prototype.isBufferGeometry = !0;
      const Na = new me(),
        ri = new Pi(),
        zr = new Wn(),
        fn = new S(),
        pn = new S(),
        mn = new S(),
        Hr = new S(),
        Gr = new S(),
        kr = new S(),
        Rs = new S(),
        Ls = new S(),
        Cs = new S(),
        Ps = new $(),
        Is = new $(),
        Ds = new $(),
        Vr = new S(),
        Fs = new S();
      class xt extends Ve {
        constructor(e = new Ke(), t = new sn()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            e.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let s = 0, o = i.length; s < o; s++) {
                  const a = i[s].name || String(s);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = s);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            s = this.matrixWorld;
          if (
            i === void 0 ||
            (n.boundingSphere === null && n.computeBoundingSphere(),
            zr.copy(n.boundingSphere),
            zr.applyMatrix4(s),
            e.ray.intersectsSphere(zr) === !1) ||
            (Na.copy(s).invert(),
            ri.copy(e.ray).applyMatrix4(Na),
            n.boundingBox !== null && ri.intersectsBox(n.boundingBox) === !1)
          )
            return;
          let o;
          if (n.isBufferGeometry) {
            const a = n.index,
              l = n.attributes.position,
              c = n.morphAttributes.position,
              h = n.morphTargetsRelative,
              u = n.attributes.uv,
              d = n.attributes.uv2,
              f = n.groups,
              g = n.drawRange;
            if (a !== null)
              if (Array.isArray(i))
                for (let m = 0, p = f.length; m < p; m++) {
                  const _ = f[m],
                    M = i[_.materialIndex],
                    T = Math.max(_.start, g.start),
                    E = Math.min(
                      a.count,
                      Math.min(_.start + _.count, g.start + g.count)
                    );
                  for (let w = T, R = E; w < R; w += 3) {
                    const P = a.getX(w),
                      y = a.getX(w + 1),
                      L = a.getX(w + 2);
                    (o = Ns(this, M, e, ri, l, c, h, u, d, P, y, L)),
                      o &&
                        ((o.faceIndex = Math.floor(w / 3)),
                        (o.face.materialIndex = _.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const m = Math.max(0, g.start),
                  p = Math.min(a.count, g.start + g.count);
                for (let _ = m, M = p; _ < M; _ += 3) {
                  const T = a.getX(_),
                    E = a.getX(_ + 1),
                    w = a.getX(_ + 2);
                  (o = Ns(this, i, e, ri, l, c, h, u, d, T, E, w)),
                    o && ((o.faceIndex = Math.floor(_ / 3)), t.push(o));
                }
              }
            else if (l !== void 0)
              if (Array.isArray(i))
                for (let m = 0, p = f.length; m < p; m++) {
                  const _ = f[m],
                    M = i[_.materialIndex],
                    T = Math.max(_.start, g.start),
                    E = Math.min(
                      l.count,
                      Math.min(_.start + _.count, g.start + g.count)
                    );
                  for (let w = T, R = E; w < R; w += 3) {
                    const P = w,
                      y = w + 1,
                      L = w + 2;
                    (o = Ns(this, M, e, ri, l, c, h, u, d, P, y, L)),
                      o &&
                        ((o.faceIndex = Math.floor(w / 3)),
                        (o.face.materialIndex = _.materialIndex),
                        t.push(o));
                  }
                }
              else {
                const m = Math.max(0, g.start),
                  p = Math.min(l.count, g.start + g.count);
                for (let _ = m, M = p; _ < M; _ += 3) {
                  const T = _,
                    E = _ + 1,
                    w = _ + 2;
                  (o = Ns(this, i, e, ri, l, c, h, u, d, T, E, w)),
                    o && ((o.faceIndex = Math.floor(_ / 3)), t.push(o));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      xt.prototype.isMesh = !0;
      function wu(r, e, t, n, i, s, o, a) {
        let l;
        if (
          (e.side === Nt
            ? (l = n.intersectTriangle(o, s, i, !0, a))
            : (l = n.intersectTriangle(i, s, o, e.side !== On, a)),
          l === null)
        )
          return null;
        Fs.copy(a), Fs.applyMatrix4(r.matrixWorld);
        const c = t.ray.origin.distanceTo(Fs);
        return c < t.near || c > t.far
          ? null
          : { distance: c, point: Fs.clone(), object: r };
      }
      function Ns(r, e, t, n, i, s, o, a, l, c, h, u) {
        fn.fromBufferAttribute(i, c),
          pn.fromBufferAttribute(i, h),
          mn.fromBufferAttribute(i, u);
        const d = r.morphTargetInfluences;
        if (s && d) {
          Rs.set(0, 0, 0), Ls.set(0, 0, 0), Cs.set(0, 0, 0);
          for (let g = 0, m = s.length; g < m; g++) {
            const p = d[g],
              _ = s[g];
            p !== 0 &&
              (Hr.fromBufferAttribute(_, c),
              Gr.fromBufferAttribute(_, h),
              kr.fromBufferAttribute(_, u),
              o
                ? (Rs.addScaledVector(Hr, p),
                  Ls.addScaledVector(Gr, p),
                  Cs.addScaledVector(kr, p))
                : (Rs.addScaledVector(Hr.sub(fn), p),
                  Ls.addScaledVector(Gr.sub(pn), p),
                  Cs.addScaledVector(kr.sub(mn), p)));
          }
          fn.add(Rs), pn.add(Ls), mn.add(Cs);
        }
        r.isSkinnedMesh &&
          (r.boneTransform(c, fn),
          r.boneTransform(h, pn),
          r.boneTransform(u, mn));
        const f = wu(r, e, t, n, fn, pn, mn, Vr);
        if (f) {
          a &&
            (Ps.fromBufferAttribute(a, c),
            Is.fromBufferAttribute(a, h),
            Ds.fromBufferAttribute(a, u),
            (f.uv = st.getUV(Vr, fn, pn, mn, Ps, Is, Ds, new $()))),
            l &&
              (Ps.fromBufferAttribute(l, c),
              Is.fromBufferAttribute(l, h),
              Ds.fromBufferAttribute(l, u),
              (f.uv2 = st.getUV(Vr, fn, pn, mn, Ps, Is, Ds, new $())));
          const g = { a: c, b: h, c: u, normal: new S(), materialIndex: 0 };
          st.getNormal(fn, pn, mn, g.normal), (f.face = g);
        }
        return f;
      }
      class ps extends Ke {
        constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: s,
              depthSegments: o,
            });
          const a = this;
          (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
          const l = [],
            c = [],
            h = [],
            u = [];
          let d = 0,
            f = 0;
          g("z", "y", "x", -1, -1, n, t, e, o, s, 0),
            g("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
            g("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            g("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            g("x", "y", "z", 1, -1, e, t, n, i, s, 4),
            g("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
            this.setIndex(l),
            this.setAttribute("position", new ct(c, 3)),
            this.setAttribute("normal", new ct(h, 3)),
            this.setAttribute("uv", new ct(u, 2));
          function g(m, p, _, M, T, E, w, R, P, y, L) {
            const N = E / P,
              D = w / y,
              ie = E / 2,
              J = w / 2,
              C = R / 2,
              H = P + 1,
              B = y + 1;
            let V = 0,
              X = 0;
            const U = new S();
            for (let W = 0; W < B; W++) {
              const Q = W * D - J;
              for (let K = 0; K < H; K++) {
                const ee = K * N - ie;
                (U[m] = ee * M),
                  (U[p] = Q * T),
                  (U[_] = C),
                  c.push(U.x, U.y, U.z),
                  (U[m] = 0),
                  (U[p] = 0),
                  (U[_] = R > 0 ? 1 : -1),
                  h.push(U.x, U.y, U.z),
                  u.push(K / P),
                  u.push(1 - W / y),
                  (V += 1);
              }
            }
            for (let W = 0; W < y; W++)
              for (let Q = 0; Q < P; Q++) {
                const K = d + Q + H * W,
                  ee = d + Q + H * (W + 1),
                  ge = d + (Q + 1) + H * (W + 1),
                  _e = d + (Q + 1) + H * W;
                l.push(K, ee, _e), l.push(ee, ge, _e), (X += 6);
              }
            a.addGroup(f, X, L), (f += X), (d += V);
          }
        }
        static fromJSON(e) {
          return new ps(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function Ai(r) {
        const e = {};
        for (const t in r) {
          e[t] = {};
          for (const n in r[t]) {
            const i = r[t][n];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (e[t][n] = i.clone())
              : Array.isArray(i)
              ? (e[t][n] = i.slice())
              : (e[t][n] = i);
          }
        }
        return e;
      }
      function ft(r) {
        const e = {};
        for (let t = 0; t < r.length; t++) {
          const n = Ai(r[t]);
          for (const i in n) e[i] = n[i];
        }
        return e;
      }
      const Su = { clone: Ai, merge: ft };
      var Tu = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        Eu = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class Bt extends et {
        constructor(e) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = Tu),
            (this.fragmentShader = Eu),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 &&
              (e.attributes !== void 0 &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(e));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = Ai(e.uniforms)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture
              ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
              : o && o.isColor
              ? (t.uniforms[i] = { type: "c", value: o.getHex() })
              : o && o.isVector2
              ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
              : o && o.isVector3
              ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
              ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
              : o && o.isMatrix3
              ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
              : o && o.isMatrix4
              ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
              : (t.uniforms[i] = { value: o });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      Bt.prototype.isShaderMaterial = !0;
      class Ao extends Ve {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new me()),
            (this.projectionMatrix = new me()),
            (this.projectionMatrixInverse = new me());
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Ao.prototype.isCamera = !0;
      class mt extends Ao {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = os * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan($i * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return os * 2 * Math.atan(Math.tan($i * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, n, i, s, o) {
          (this.aspect = e / t),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan($i * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            s = -0.5 * i;
          const o = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
              c = o.fullHeight;
            (s += (o.offsetX * i) / l),
              (t -= (o.offsetY * n) / c),
              (i *= o.width / l),
              (n *= o.height / c);
          }
          const a = this.filmOffset;
          a !== 0 && (s += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              s,
              s + i,
              t,
              t - n,
              e,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      mt.prototype.isPerspectiveCamera = !0;
      const oi = 90,
        ai = 1;
      class Ro extends Ve {
        constructor(e, t, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            n.isWebGLCubeRenderTarget !== !0)
          ) {
            console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
            return;
          }
          this.renderTarget = n;
          const i = new mt(oi, ai, e, t);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new S(1, 0, 0)),
            this.add(i);
          const s = new mt(oi, ai, e, t);
          (s.layers = this.layers),
            s.up.set(0, -1, 0),
            s.lookAt(new S(-1, 0, 0)),
            this.add(s);
          const o = new mt(oi, ai, e, t);
          (o.layers = this.layers),
            o.up.set(0, 0, 1),
            o.lookAt(new S(0, 1, 0)),
            this.add(o);
          const a = new mt(oi, ai, e, t);
          (a.layers = this.layers),
            a.up.set(0, 0, -1),
            a.lookAt(new S(0, -1, 0)),
            this.add(a);
          const l = new mt(oi, ai, e, t);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new S(0, 0, 1)),
            this.add(l);
          const c = new mt(oi, ai, e, t);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new S(0, 0, -1)),
            this.add(c);
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, s, o, a, l, c] = this.children,
            h = e.getRenderTarget(),
            u = e.toneMapping,
            d = e.xr.enabled;
          (e.toneMapping = rn), (e.xr.enabled = !1);
          const f = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, s),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            (n.texture.generateMipmaps = f),
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(h),
            (e.toneMapping = u),
            (e.xr.enabled = d),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class rr extends rt {
        constructor(e, t, n, i, s, o, a, l, c, h) {
          (e = e !== void 0 ? e : []),
            (t = t !== void 0 ? t : bi),
            super(e, t, n, i, s, o, a, l, c, h),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      rr.prototype.isCubeTexture = !0;
      class Kl extends St {
        constructor(e, t = {}) {
          super(e, e, t);
          const n = { width: e, height: e, depth: 1 },
            i = [n, n, n, n, n, n];
          (this.texture = new rr(
            i,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
              t.minFilter !== void 0 ? t.minFilter : pt);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new ps(5, 5, 5),
            s = new Bt({
              name: "CubemapFromEquirect",
              uniforms: Ai(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: Nt,
              blending: vn,
            });
          s.uniforms.tEquirect.value = t;
          const o = new xt(i, s),
            a = t.minFilter;
          return (
            t.minFilter === Ci && (t.minFilter = pt),
            new Ro(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const s = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, n, i);
          e.setRenderTarget(s);
        }
      }
      Kl.prototype.isWebGLCubeRenderTarget = !0;
      const Wr = new S(),
        Au = new S(),
        Ru = new dt();
      class nn {
        constructor(e = new S(1, 0, 0), t = 0) {
          (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = Wr.subVectors(n, t).cross(Au.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(e))
            .add(e);
        }
        intersectLine(e, t) {
          const n = e.delta(Wr),
            i = this.normal.dot(n);
          if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const s = -(e.start.dot(this.normal) + this.constant) / i;
          return s < 0 || s > 1
            ? null
            : t.copy(n).multiplyScalar(s).add(e.start);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const n = t || Ru.getNormalMatrix(e),
            i = this.coplanarPoint(Wr).applyMatrix4(e),
            s = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(s)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      nn.prototype.isPlane = !0;
      const li = new Wn(),
        Bs = new S();
      class or {
        constructor(
          e = new nn(),
          t = new nn(),
          n = new nn(),
          i = new nn(),
          s = new nn(),
          o = new nn()
        ) {
          this.planes = [e, t, n, i, s, o];
        }
        set(e, t, n, i, s, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(s),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes,
            n = e.elements,
            i = n[0],
            s = n[1],
            o = n[2],
            a = n[3],
            l = n[4],
            c = n[5],
            h = n[6],
            u = n[7],
            d = n[8],
            f = n[9],
            g = n[10],
            m = n[11],
            p = n[12],
            _ = n[13],
            M = n[14],
            T = n[15];
          return (
            t[0].setComponents(a - i, u - l, m - d, T - p).normalize(),
            t[1].setComponents(a + i, u + l, m + d, T + p).normalize(),
            t[2].setComponents(a + s, u + c, m + f, T + _).normalize(),
            t[3].setComponents(a - s, u - c, m - f, T - _).normalize(),
            t[4].setComponents(a - o, u - h, m - g, T - M).normalize(),
            t[5].setComponents(a + o, u + h, m + g, T + M).normalize(),
            this
          );
        }
        intersectsObject(e) {
          const t = e.geometry;
          return (
            t.boundingSphere === null && t.computeBoundingSphere(),
            li.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(li)
          );
        }
        intersectsSprite(e) {
          return (
            li.center.set(0, 0, 0),
            (li.radius = 0.7071067811865476),
            li.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(li)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((Bs.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (Bs.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (Bs.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(Bs) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Zl() {
        let r = null,
          e = !1,
          t = null,
          n = null;
        function i(s, o) {
          t(s, o), (n = r.requestAnimationFrame(i));
        }
        return {
          start: function () {
            e !== !0 &&
              t !== null &&
              ((n = r.requestAnimationFrame(i)), (e = !0));
          },
          stop: function () {
            r.cancelAnimationFrame(n), (e = !1);
          },
          setAnimationLoop: function (s) {
            t = s;
          },
          setContext: function (s) {
            r = s;
          },
        };
      }
      function Lu(r, e) {
        const t = e.isWebGL2,
          n = new WeakMap();
        function i(c, h) {
          const u = c.array,
            d = c.usage,
            f = r.createBuffer();
          r.bindBuffer(h, f), r.bufferData(h, u, d), c.onUploadCallback();
          let g;
          if (u instanceof Float32Array) g = 5126;
          else if (u instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
              if (t) g = 5131;
              else
                throw new Error(
                  "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                );
            else g = 5123;
          else if (u instanceof Int16Array) g = 5122;
          else if (u instanceof Uint32Array) g = 5125;
          else if (u instanceof Int32Array) g = 5124;
          else if (u instanceof Int8Array) g = 5120;
          else if (u instanceof Uint8Array) g = 5121;
          else if (u instanceof Uint8ClampedArray) g = 5121;
          else
            throw new Error(
              "THREE.WebGLAttributes: Unsupported buffer data format: " + u
            );
          return {
            buffer: f,
            type: g,
            bytesPerElement: u.BYTES_PER_ELEMENT,
            version: c.version,
          };
        }
        function s(c, h, u) {
          const d = h.array,
            f = h.updateRange;
          r.bindBuffer(u, c),
            f.count === -1
              ? r.bufferSubData(u, 0, d)
              : (t
                  ? r.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d,
                      f.offset,
                      f.count
                    )
                  : r.bufferSubData(
                      u,
                      f.offset * d.BYTES_PER_ELEMENT,
                      d.subarray(f.offset, f.offset + f.count)
                    ),
                (f.count = -1));
        }
        function o(c) {
          return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
        }
        function a(c) {
          c.isInterleavedBufferAttribute && (c = c.data);
          const h = n.get(c);
          h && (r.deleteBuffer(h.buffer), n.delete(c));
        }
        function l(c, h) {
          if (c.isGLBufferAttribute) {
            const d = n.get(c);
            (!d || d.version < c.version) &&
              n.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version,
              });
            return;
          }
          c.isInterleavedBufferAttribute && (c = c.data);
          const u = n.get(c);
          u === void 0
            ? n.set(c, i(c, h))
            : u.version < c.version &&
              (s(u.buffer, c, h), (u.version = c.version));
        }
        return { get: o, remove: a, update: l };
      }
      class Lo extends Ke {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const s = e / 2,
            o = t / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            h = l + 1,
            u = e / a,
            d = t / l,
            f = [],
            g = [],
            m = [],
            p = [];
          for (let _ = 0; _ < h; _++) {
            const M = _ * d - o;
            for (let T = 0; T < c; T++) {
              const E = T * u - s;
              g.push(E, -M, 0),
                m.push(0, 0, 1),
                p.push(T / a),
                p.push(1 - _ / l);
            }
          }
          for (let _ = 0; _ < l; _++)
            for (let M = 0; M < a; M++) {
              const T = M + c * _,
                E = M + c * (_ + 1),
                w = M + 1 + c * (_ + 1),
                R = M + 1 + c * _;
              f.push(T, E, R), f.push(E, w, R);
            }
          this.setIndex(f),
            this.setAttribute("position", new ct(g, 3)),
            this.setAttribute("normal", new ct(m, 3)),
            this.setAttribute("uv", new ct(p, 2));
        }
        static fromJSON(e) {
          return new Lo(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      var Cu = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
        Pu = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        Iu = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
        Du = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        Fu = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        Nu = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        Bu = "vec3 transformed = vec3( position );",
        Ou = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        Uu = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
        zu = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        Hu = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
        Gu = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        ku = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        Vu = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        Wu = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        qu = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        Xu = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
        ju = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
        Yu = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
        Ju = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        Ku = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Zu = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        $u = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
        Qu = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        ed = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        td = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        nd = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        id = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        sd = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        rd = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        od = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        ad = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        ld = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        cd = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        hd = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        ud = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        dd = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
        fd = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
        pd = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        md = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
        gd = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        _d = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
        xd = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        yd = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
        vd = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        Md = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
        bd = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
        wd = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        Sd = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        Td = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        Ed = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
        Ad = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        Rd = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        Ld = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
        Cd = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
        Pd = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        Id = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        Dd = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        Fd = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        Nd = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        Bd = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        Od = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        Ud = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
        zd = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
        Hd = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
        Gd = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
        kd = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        Vd = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        Wd = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        qd = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        Xd = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
        jd = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
        Yd = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
        Jd = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
        Kd = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        Zd = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
        $d = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        Qd = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        ef = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        tf = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        nf = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        sf = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        rf = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
        of = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        af = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
        lf = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        cf = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        hf = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
        uf = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        df = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        ff = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        pf = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        mf = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        gf = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        _f = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
        xf = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
        yf = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
        vf = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
        Mf = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
        bf = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
        wf = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
        Sf = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
        Tf = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const Ef = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        Af = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        Rf = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        Lf = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        Cf = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        Pf = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
        If = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        Df = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        Ff = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        Nf = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
        Bf = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        Of = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        Uf = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        zf = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Hf = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Gf = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        kf = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        Vf = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Wf = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        qf = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
        Xf = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        jf = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Yf = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
        Jf = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Kf = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Zf = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        $f = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        Qf = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        ep = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        tp = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        np = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        ip = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        De = {
          alphamap_fragment: Cu,
          alphamap_pars_fragment: Pu,
          alphatest_fragment: Iu,
          alphatest_pars_fragment: Du,
          aomap_fragment: Fu,
          aomap_pars_fragment: Nu,
          begin_vertex: Bu,
          beginnormal_vertex: Ou,
          bsdfs: Uu,
          bumpmap_pars_fragment: zu,
          clipping_planes_fragment: Hu,
          clipping_planes_pars_fragment: Gu,
          clipping_planes_pars_vertex: ku,
          clipping_planes_vertex: Vu,
          color_fragment: Wu,
          color_pars_fragment: qu,
          color_pars_vertex: Xu,
          color_vertex: ju,
          common: Yu,
          cube_uv_reflection_fragment: Ju,
          defaultnormal_vertex: Ku,
          displacementmap_pars_vertex: Zu,
          displacementmap_vertex: $u,
          emissivemap_fragment: Qu,
          emissivemap_pars_fragment: ed,
          encodings_fragment: td,
          encodings_pars_fragment: nd,
          envmap_fragment: id,
          envmap_common_pars_fragment: sd,
          envmap_pars_fragment: rd,
          envmap_pars_vertex: od,
          envmap_physical_pars_fragment: _d,
          envmap_vertex: ad,
          fog_vertex: ld,
          fog_pars_vertex: cd,
          fog_fragment: hd,
          fog_pars_fragment: ud,
          gradientmap_pars_fragment: dd,
          lightmap_fragment: fd,
          lightmap_pars_fragment: pd,
          lights_lambert_vertex: md,
          lights_pars_begin: gd,
          lights_toon_fragment: xd,
          lights_toon_pars_fragment: yd,
          lights_phong_fragment: vd,
          lights_phong_pars_fragment: Md,
          lights_physical_fragment: bd,
          lights_physical_pars_fragment: wd,
          lights_fragment_begin: Sd,
          lights_fragment_maps: Td,
          lights_fragment_end: Ed,
          logdepthbuf_fragment: Ad,
          logdepthbuf_pars_fragment: Rd,
          logdepthbuf_pars_vertex: Ld,
          logdepthbuf_vertex: Cd,
          map_fragment: Pd,
          map_pars_fragment: Id,
          map_particle_fragment: Dd,
          map_particle_pars_fragment: Fd,
          metalnessmap_fragment: Nd,
          metalnessmap_pars_fragment: Bd,
          morphcolor_vertex: Od,
          morphnormal_vertex: Ud,
          morphtarget_pars_vertex: zd,
          morphtarget_vertex: Hd,
          normal_fragment_begin: Gd,
          normal_fragment_maps: kd,
          normal_pars_fragment: Vd,
          normal_pars_vertex: Wd,
          normal_vertex: qd,
          normalmap_pars_fragment: Xd,
          clearcoat_normal_fragment_begin: jd,
          clearcoat_normal_fragment_maps: Yd,
          clearcoat_pars_fragment: Jd,
          output_fragment: Kd,
          packing: Zd,
          premultiplied_alpha_fragment: $d,
          project_vertex: Qd,
          dithering_fragment: ef,
          dithering_pars_fragment: tf,
          roughnessmap_fragment: nf,
          roughnessmap_pars_fragment: sf,
          shadowmap_pars_fragment: rf,
          shadowmap_pars_vertex: of,
          shadowmap_vertex: af,
          shadowmask_pars_fragment: lf,
          skinbase_vertex: cf,
          skinning_pars_vertex: hf,
          skinning_vertex: uf,
          skinnormal_vertex: df,
          specularmap_fragment: ff,
          specularmap_pars_fragment: pf,
          tonemapping_fragment: mf,
          tonemapping_pars_fragment: gf,
          transmission_fragment: _f,
          transmission_pars_fragment: xf,
          uv_pars_fragment: yf,
          uv_pars_vertex: vf,
          uv_vertex: Mf,
          uv2_pars_fragment: bf,
          uv2_pars_vertex: wf,
          uv2_vertex: Sf,
          worldpos_vertex: Tf,
          background_vert: Ef,
          background_frag: Af,
          cube_vert: Rf,
          cube_frag: Lf,
          depth_vert: Cf,
          depth_frag: Pf,
          distanceRGBA_vert: If,
          distanceRGBA_frag: Df,
          equirect_vert: Ff,
          equirect_frag: Nf,
          linedashed_vert: Bf,
          linedashed_frag: Of,
          meshbasic_vert: Uf,
          meshbasic_frag: zf,
          meshlambert_vert: Hf,
          meshlambert_frag: Gf,
          meshmatcap_vert: kf,
          meshmatcap_frag: Vf,
          meshnormal_vert: Wf,
          meshnormal_frag: qf,
          meshphong_vert: Xf,
          meshphong_frag: jf,
          meshphysical_vert: Yf,
          meshphysical_frag: Jf,
          meshtoon_vert: Kf,
          meshtoon_frag: Zf,
          points_vert: $f,
          points_frag: Qf,
          shadow_vert: ep,
          shadow_frag: tp,
          sprite_vert: np,
          sprite_frag: ip,
        },
        oe = {
          common: {
            diffuse: { value: new he(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new dt() },
            uv2Transform: { value: new dt() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new $(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new he(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new he(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new dt() },
          },
          sprite: {
            diffuse: { value: new he(16777215) },
            opacity: { value: 1 },
            center: { value: new $(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new dt() },
          },
        },
        Wt = {
          basic: {
            uniforms: ft([
              oe.common,
              oe.specularmap,
              oe.envmap,
              oe.aomap,
              oe.lightmap,
              oe.fog,
            ]),
            vertexShader: De.meshbasic_vert,
            fragmentShader: De.meshbasic_frag,
          },
          lambert: {
            uniforms: ft([
              oe.common,
              oe.specularmap,
              oe.envmap,
              oe.aomap,
              oe.lightmap,
              oe.emissivemap,
              oe.fog,
              oe.lights,
              { emissive: { value: new he(0) } },
            ]),
            vertexShader: De.meshlambert_vert,
            fragmentShader: De.meshlambert_frag,
          },
          phong: {
            uniforms: ft([
              oe.common,
              oe.specularmap,
              oe.envmap,
              oe.aomap,
              oe.lightmap,
              oe.emissivemap,
              oe.bumpmap,
              oe.normalmap,
              oe.displacementmap,
              oe.fog,
              oe.lights,
              {
                emissive: { value: new he(0) },
                specular: { value: new he(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: De.meshphong_vert,
            fragmentShader: De.meshphong_frag,
          },
          standard: {
            uniforms: ft([
              oe.common,
              oe.envmap,
              oe.aomap,
              oe.lightmap,
              oe.emissivemap,
              oe.bumpmap,
              oe.normalmap,
              oe.displacementmap,
              oe.roughnessmap,
              oe.metalnessmap,
              oe.fog,
              oe.lights,
              {
                emissive: { value: new he(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: De.meshphysical_vert,
            fragmentShader: De.meshphysical_frag,
          },
          toon: {
            uniforms: ft([
              oe.common,
              oe.aomap,
              oe.lightmap,
              oe.emissivemap,
              oe.bumpmap,
              oe.normalmap,
              oe.displacementmap,
              oe.gradientmap,
              oe.fog,
              oe.lights,
              { emissive: { value: new he(0) } },
            ]),
            vertexShader: De.meshtoon_vert,
            fragmentShader: De.meshtoon_frag,
          },
          matcap: {
            uniforms: ft([
              oe.common,
              oe.bumpmap,
              oe.normalmap,
              oe.displacementmap,
              oe.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: De.meshmatcap_vert,
            fragmentShader: De.meshmatcap_frag,
          },
          points: {
            uniforms: ft([oe.points, oe.fog]),
            vertexShader: De.points_vert,
            fragmentShader: De.points_frag,
          },
          dashed: {
            uniforms: ft([
              oe.common,
              oe.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: De.linedashed_vert,
            fragmentShader: De.linedashed_frag,
          },
          depth: {
            uniforms: ft([oe.common, oe.displacementmap]),
            vertexShader: De.depth_vert,
            fragmentShader: De.depth_frag,
          },
          normal: {
            uniforms: ft([
              oe.common,
              oe.bumpmap,
              oe.normalmap,
              oe.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: De.meshnormal_vert,
            fragmentShader: De.meshnormal_frag,
          },
          sprite: {
            uniforms: ft([oe.sprite, oe.fog]),
            vertexShader: De.sprite_vert,
            fragmentShader: De.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new dt() },
              t2D: { value: null },
            },
            vertexShader: De.background_vert,
            fragmentShader: De.background_frag,
          },
          cube: {
            uniforms: ft([oe.envmap, { opacity: { value: 1 } }]),
            vertexShader: De.cube_vert,
            fragmentShader: De.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: De.equirect_vert,
            fragmentShader: De.equirect_frag,
          },
          distanceRGBA: {
            uniforms: ft([
              oe.common,
              oe.displacementmap,
              {
                referencePosition: { value: new S() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: De.distanceRGBA_vert,
            fragmentShader: De.distanceRGBA_frag,
          },
          shadow: {
            uniforms: ft([
              oe.lights,
              oe.fog,
              { color: { value: new he(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: De.shadow_vert,
            fragmentShader: De.shadow_frag,
          },
        };
      Wt.physical = {
        uniforms: ft([
          Wt.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new $(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new he(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new $() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new he(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new he(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: De.meshphysical_vert,
        fragmentShader: De.meshphysical_frag,
      };
      function sp(r, e, t, n, i, s) {
        const o = new he(0);
        let a = i === !0 ? 0 : 1,
          l,
          c,
          h = null,
          u = 0,
          d = null;
        function f(m, p) {
          let _ = !1,
            M = p.isScene === !0 ? p.background : null;
          M && M.isTexture && (M = e.get(M));
          const T = r.xr,
            E = T.getSession && T.getSession();
          E && E.environmentBlendMode === "additive" && (M = null),
            M === null ? g(o, a) : M && M.isColor && (g(M, 1), (_ = !0)),
            (r.autoClear || _) &&
              r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
            M && (M.isCubeTexture || M.mapping === ir)
              ? (c === void 0 &&
                  ((c = new xt(
                    new ps(1, 1, 1),
                    new Bt({
                      name: "BackgroundCubeMaterial",
                      uniforms: Ai(Wt.cube.uniforms),
                      vertexShader: Wt.cube.vertexShader,
                      fragmentShader: Wt.cube.fragmentShader,
                      side: Nt,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  c.geometry.deleteAttribute("uv"),
                  (c.onBeforeRender = function (w, R, P) {
                    this.matrixWorld.copyPosition(P.matrixWorld);
                  }),
                  Object.defineProperty(c.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(c)),
                (c.material.uniforms.envMap.value = M),
                (c.material.uniforms.flipEnvMap.value =
                  M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1),
                (h !== M || u !== M.version || d !== r.toneMapping) &&
                  ((c.material.needsUpdate = !0),
                  (h = M),
                  (u = M.version),
                  (d = r.toneMapping)),
                c.layers.enableAll(),
                m.unshift(c, c.geometry, c.material, 0, 0, null))
              : M &&
                M.isTexture &&
                (l === void 0 &&
                  ((l = new xt(
                    new Lo(2, 2),
                    new Bt({
                      name: "BackgroundMaterial",
                      uniforms: Ai(Wt.background.uniforms),
                      vertexShader: Wt.background.vertexShader,
                      fragmentShader: Wt.background.fragmentShader,
                      side: Mi,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  Object.defineProperty(l.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(l)),
                (l.material.uniforms.t2D.value = M),
                M.matrixAutoUpdate === !0 && M.updateMatrix(),
                l.material.uniforms.uvTransform.value.copy(M.matrix),
                (h !== M || u !== M.version || d !== r.toneMapping) &&
                  ((l.material.needsUpdate = !0),
                  (h = M),
                  (u = M.version),
                  (d = r.toneMapping)),
                l.layers.enableAll(),
                m.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function g(m, p) {
          t.buffers.color.setClear(m.r, m.g, m.b, p, s);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (m, p = 1) {
            o.set(m), (a = p), g(o, a);
          },
          getClearAlpha: function () {
            return a;
          },
          setClearAlpha: function (m) {
            (a = m), g(o, a);
          },
          render: f,
        };
      }
      function rp(r, e, t, n) {
        const i = r.getParameter(34921),
          s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = n.isWebGL2 || s !== null,
          a = {},
          l = p(null);
        let c = l,
          h = !1;
        function u(C, H, B, V, X) {
          let U = !1;
          if (o) {
            const W = m(V, B, H);
            c !== W && ((c = W), f(c.object)),
              (U = _(C, V, B, X)),
              U && M(C, V, B, X);
          } else {
            const W = H.wireframe === !0;
            (c.geometry !== V.id || c.program !== B.id || c.wireframe !== W) &&
              ((c.geometry = V.id),
              (c.program = B.id),
              (c.wireframe = W),
              (U = !0));
          }
          X !== null && t.update(X, 34963),
            (U || h) &&
              ((h = !1),
              y(C, H, B, V),
              X !== null && r.bindBuffer(34963, t.get(X).buffer));
        }
        function d() {
          return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES();
        }
        function f(C) {
          return n.isWebGL2 ? r.bindVertexArray(C) : s.bindVertexArrayOES(C);
        }
        function g(C) {
          return n.isWebGL2
            ? r.deleteVertexArray(C)
            : s.deleteVertexArrayOES(C);
        }
        function m(C, H, B) {
          const V = B.wireframe === !0;
          let X = a[C.id];
          X === void 0 && ((X = {}), (a[C.id] = X));
          let U = X[H.id];
          U === void 0 && ((U = {}), (X[H.id] = U));
          let W = U[V];
          return W === void 0 && ((W = p(d())), (U[V] = W)), W;
        }
        function p(C) {
          const H = [],
            B = [],
            V = [];
          for (let X = 0; X < i; X++) (H[X] = 0), (B[X] = 0), (V[X] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: H,
            enabledAttributes: B,
            attributeDivisors: V,
            object: C,
            attributes: {},
            index: null,
          };
        }
        function _(C, H, B, V) {
          const X = c.attributes,
            U = H.attributes;
          let W = 0;
          const Q = B.getAttributes();
          for (const K in Q)
            if (Q[K].location >= 0) {
              const ge = X[K];
              let _e = U[K];
              if (
                (_e === void 0 &&
                  (K === "instanceMatrix" &&
                    C.instanceMatrix &&
                    (_e = C.instanceMatrix),
                  K === "instanceColor" &&
                    C.instanceColor &&
                    (_e = C.instanceColor)),
                ge === void 0 ||
                  ge.attribute !== _e ||
                  (_e && ge.data !== _e.data))
              )
                return !0;
              W++;
            }
          return c.attributesNum !== W || c.index !== V;
        }
        function M(C, H, B, V) {
          const X = {},
            U = H.attributes;
          let W = 0;
          const Q = B.getAttributes();
          for (const K in Q)
            if (Q[K].location >= 0) {
              let ge = U[K];
              ge === void 0 &&
                (K === "instanceMatrix" &&
                  C.instanceMatrix &&
                  (ge = C.instanceMatrix),
                K === "instanceColor" &&
                  C.instanceColor &&
                  (ge = C.instanceColor));
              const _e = {};
              (_e.attribute = ge),
                ge && ge.data && (_e.data = ge.data),
                (X[K] = _e),
                W++;
            }
          (c.attributes = X), (c.attributesNum = W), (c.index = V);
        }
        function T() {
          const C = c.newAttributes;
          for (let H = 0, B = C.length; H < B; H++) C[H] = 0;
        }
        function E(C) {
          w(C, 0);
        }
        function w(C, H) {
          const B = c.newAttributes,
            V = c.enabledAttributes,
            X = c.attributeDivisors;
          (B[C] = 1),
            V[C] === 0 && (r.enableVertexAttribArray(C), (V[C] = 1)),
            X[C] !== H &&
              ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[
                n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](C, H),
              (X[C] = H));
        }
        function R() {
          const C = c.newAttributes,
            H = c.enabledAttributes;
          for (let B = 0, V = H.length; B < V; B++)
            H[B] !== C[B] && (r.disableVertexAttribArray(B), (H[B] = 0));
        }
        function P(C, H, B, V, X, U) {
          n.isWebGL2 === !0 && (B === 5124 || B === 5125)
            ? r.vertexAttribIPointer(C, H, B, X, U)
            : r.vertexAttribPointer(C, H, B, V, X, U);
        }
        function y(C, H, B, V) {
          if (
            n.isWebGL2 === !1 &&
            (C.isInstancedMesh || V.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
          )
            return;
          T();
          const X = V.attributes,
            U = B.getAttributes(),
            W = H.defaultAttributeValues;
          for (const Q in U) {
            const K = U[Q];
            if (K.location >= 0) {
              let ee = X[Q];
              if (
                (ee === void 0 &&
                  (Q === "instanceMatrix" &&
                    C.instanceMatrix &&
                    (ee = C.instanceMatrix),
                  Q === "instanceColor" &&
                    C.instanceColor &&
                    (ee = C.instanceColor)),
                ee !== void 0)
              ) {
                const ge = ee.normalized,
                  _e = ee.itemSize,
                  k = t.get(ee);
                if (k === void 0) continue;
                const He = k.buffer,
                  be = k.type,
                  Le = k.bytesPerElement;
                if (ee.isInterleavedBufferAttribute) {
                  const se = ee.data,
                    Ne = se.stride,
                    Y = ee.offset;
                  if (se.isInstancedInterleavedBuffer) {
                    for (let j = 0; j < K.locationSize; j++)
                      w(K.location + j, se.meshPerAttribute);
                    C.isInstancedMesh !== !0 &&
                      V._maxInstanceCount === void 0 &&
                      (V._maxInstanceCount = se.meshPerAttribute * se.count);
                  } else
                    for (let j = 0; j < K.locationSize; j++) E(K.location + j);
                  r.bindBuffer(34962, He);
                  for (let j = 0; j < K.locationSize; j++)
                    P(
                      K.location + j,
                      _e / K.locationSize,
                      be,
                      ge,
                      Ne * Le,
                      (Y + (_e / K.locationSize) * j) * Le
                    );
                } else {
                  if (ee.isInstancedBufferAttribute) {
                    for (let se = 0; se < K.locationSize; se++)
                      w(K.location + se, ee.meshPerAttribute);
                    C.isInstancedMesh !== !0 &&
                      V._maxInstanceCount === void 0 &&
                      (V._maxInstanceCount = ee.meshPerAttribute * ee.count);
                  } else
                    for (let se = 0; se < K.locationSize; se++)
                      E(K.location + se);
                  r.bindBuffer(34962, He);
                  for (let se = 0; se < K.locationSize; se++)
                    P(
                      K.location + se,
                      _e / K.locationSize,
                      be,
                      ge,
                      _e * Le,
                      (_e / K.locationSize) * se * Le
                    );
                }
              } else if (W !== void 0) {
                const ge = W[Q];
                if (ge !== void 0)
                  switch (ge.length) {
                    case 2:
                      r.vertexAttrib2fv(K.location, ge);
                      break;
                    case 3:
                      r.vertexAttrib3fv(K.location, ge);
                      break;
                    case 4:
                      r.vertexAttrib4fv(K.location, ge);
                      break;
                    default:
                      r.vertexAttrib1fv(K.location, ge);
                  }
              }
            }
          }
          R();
        }
        function L() {
          ie();
          for (const C in a) {
            const H = a[C];
            for (const B in H) {
              const V = H[B];
              for (const X in V) g(V[X].object), delete V[X];
              delete H[B];
            }
            delete a[C];
          }
        }
        function N(C) {
          if (a[C.id] === void 0) return;
          const H = a[C.id];
          for (const B in H) {
            const V = H[B];
            for (const X in V) g(V[X].object), delete V[X];
            delete H[B];
          }
          delete a[C.id];
        }
        function D(C) {
          for (const H in a) {
            const B = a[H];
            if (B[C.id] === void 0) continue;
            const V = B[C.id];
            for (const X in V) g(V[X].object), delete V[X];
            delete B[C.id];
          }
        }
        function ie() {
          J(), (h = !0), c !== l && ((c = l), f(c.object));
        }
        function J() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: u,
          reset: ie,
          resetDefaultState: J,
          dispose: L,
          releaseStatesOfGeometry: N,
          releaseStatesOfProgram: D,
          initAttributes: T,
          enableAttribute: E,
          disableUnusedAttributes: R,
        };
      }
      function op(r, e, t, n) {
        const i = n.isWebGL2;
        let s;
        function o(c) {
          s = c;
        }
        function a(c, h) {
          r.drawArrays(s, c, h), t.update(h, s, 1);
        }
        function l(c, h, u) {
          if (u === 0) return;
          let d, f;
          if (i) (d = r), (f = "drawArraysInstanced");
          else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
          ) {
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          d[f](s, c, h, u), t.update(h, s, u);
        }
        (this.setMode = o), (this.render = a), (this.renderInstances = l);
      }
      function ap(r, e, t) {
        let n;
        function i() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const P = e.get("EXT_texture_filter_anisotropic");
            n = r.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function s(P) {
          if (P === "highp") {
            if (
              r.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              r.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            P = "mediump";
          }
          return P === "mediump" &&
            r.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            r.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          (typeof WebGL2RenderingContext != "undefined" &&
            r instanceof WebGL2RenderingContext) ||
          (typeof WebGL2ComputeRenderingContext != "undefined" &&
            r instanceof WebGL2ComputeRenderingContext);
        let a = t.precision !== void 0 ? t.precision : "highp";
        const l = s(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
          ),
          (a = l));
        const c = o || e.has("WEBGL_draw_buffers"),
          h = t.logarithmicDepthBuffer === !0,
          u = r.getParameter(34930),
          d = r.getParameter(35660),
          f = r.getParameter(3379),
          g = r.getParameter(34076),
          m = r.getParameter(34921),
          p = r.getParameter(36347),
          _ = r.getParameter(36348),
          M = r.getParameter(36349),
          T = d > 0,
          E = o || e.has("OES_texture_float"),
          w = T && E,
          R = o ? r.getParameter(36183) : 0;
        return {
          isWebGL2: o,
          drawBuffers: c,
          getMaxAnisotropy: i,
          getMaxPrecision: s,
          precision: a,
          logarithmicDepthBuffer: h,
          maxTextures: u,
          maxVertexTextures: d,
          maxTextureSize: f,
          maxCubemapSize: g,
          maxAttributes: m,
          maxVertexUniforms: p,
          maxVaryings: _,
          maxFragmentUniforms: M,
          vertexTextures: T,
          floatFragmentTextures: E,
          floatVertexTextures: w,
          maxSamples: R,
        };
      }
      function lp(r) {
        const e = this;
        let t = null,
          n = 0,
          i = !1,
          s = !1;
        const o = new nn(),
          a = new dt(),
          l = { value: null, needsUpdate: !1 };
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (u, d, f) {
            const g = u.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = h(u, f, 0)), (n = u.length), g;
          }),
          (this.beginShadows = function () {
            (s = !0), h(null);
          }),
          (this.endShadows = function () {
            (s = !1), c();
          }),
          (this.setState = function (u, d, f) {
            const g = u.clippingPlanes,
              m = u.clipIntersection,
              p = u.clipShadows,
              _ = r.get(u);
            if (!i || g === null || g.length === 0 || (s && !p))
              s ? h(null) : c();
            else {
              const M = s ? 0 : n,
                T = M * 4;
              let E = _.clippingState || null;
              (l.value = E), (E = h(g, d, T, f));
              for (let w = 0; w !== T; ++w) E[w] = t[w];
              (_.clippingState = E),
                (this.numIntersection = m ? this.numPlanes : 0),
                (this.numPlanes += M);
            }
          });
        function c() {
          l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
        }
        function h(u, d, f, g) {
          const m = u !== null ? u.length : 0;
          let p = null;
          if (m !== 0) {
            if (((p = l.value), g !== !0 || p === null)) {
              const _ = f + m * 4,
                M = d.matrixWorldInverse;
              a.getNormalMatrix(M),
                (p === null || p.length < _) && (p = new Float32Array(_));
              for (let T = 0, E = f; T !== m; ++T, E += 4)
                o.copy(u[T]).applyMatrix4(M, a),
                  o.normal.toArray(p, E),
                  (p[E + 3] = o.constant);
            }
            (l.value = p), (l.needsUpdate = !0);
          }
          return (e.numPlanes = m), (e.numIntersection = 0), p;
        }
      }
      function cp(r) {
        let e = new WeakMap();
        function t(o, a) {
          return a === ro ? (o.mapping = bi) : a === oo && (o.mapping = wi), o;
        }
        function n(o) {
          if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === ro || a === oo)
              if (e.has(o)) {
                const l = e.get(o).texture;
                return t(l, o.mapping);
              } else {
                const l = o.image;
                if (l && l.height > 0) {
                  const c = new Kl(l.height / 2);
                  return (
                    c.fromEquirectangularTexture(r, o),
                    e.set(o, c),
                    o.addEventListener("dispose", i),
                    t(c.texture, o.mapping)
                  );
                } else return null;
              }
          }
          return o;
        }
        function i(o) {
          const a = o.target;
          a.removeEventListener("dispose", i);
          const l = e.get(a);
          l !== void 0 && (e.delete(a), l.dispose());
        }
        function s() {
          e = new WeakMap();
        }
        return { get: n, dispose: s };
      }
      class ar extends Ao {
        constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, o = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = s),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, s, o) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let s = n - e,
            o = n + e,
            a = i + t,
            l = i - t;
          if (this.view !== null && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += c * this.view.offsetX),
              (o = s + c * this.view.width),
              (a -= h * this.view.offsetY),
              (l = a - h * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            s,
            o,
            a,
            l,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      ar.prototype.isOrthographicCamera = !0;
      const _i = 4,
        Ba = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Dn = 20,
        qr = new ar(),
        Oa = new he();
      let Xr = null;
      const Pn = (1 + Math.sqrt(5)) / 2,
        ci = 1 / Pn,
        Ua = [
          new S(1, 1, 1),
          new S(-1, 1, 1),
          new S(1, 1, -1),
          new S(-1, 1, -1),
          new S(0, Pn, ci),
          new S(0, Pn, -ci),
          new S(ci, 0, Pn),
          new S(-ci, 0, Pn),
          new S(Pn, ci, 0),
          new S(-Pn, ci, 0),
        ];
      class za {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          (Xr = this._renderer.getRenderTarget()), this._setSize(256);
          const s = this._allocateTargets();
          return (
            (s.depthBuffer = !0),
            this._sceneToCubeUV(e, n, i, s),
            t > 0 && this._blur(s, 0, 0, t),
            this._applyPMREM(s),
            this._cleanup(s),
            s
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null &&
            ((this._cubemapMaterial = ka()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null &&
            ((this._equirectMaterial = Ga()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(Xr),
            (e.scissorTest = !1),
            Os(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === bi || e.mapping === wi
            ? this._setSize(
                e.image.length === 0
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            (Xr = this._renderer.getRenderTarget());
          const n = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
              magFilter: pt,
              minFilter: pt,
              generateMipmaps: !1,
              type: is,
              format: At,
              encoding: Sn,
              depthBuffer: !1,
            },
            i = Ha(e, t, n);
          if (
            this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== e
          ) {
            this._pingPongRenderTarget !== null && this._dispose(),
              (this._pingPongRenderTarget = Ha(e, t, n));
            const { _lodMax: s } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = hp(s)),
              (this._blurMaterial = up(s, e, t));
          }
          return i;
        }
        _compileMaterial(e) {
          const t = new xt(this._lodPlanes[0], e);
          this._renderer.compile(t, qr);
        }
        _sceneToCubeUV(e, t, n, i) {
          const a = new mt(90, 1, t, n),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            h = this._renderer,
            u = h.autoClear,
            d = h.toneMapping;
          h.getClearColor(Oa), (h.toneMapping = rn), (h.autoClear = !1);
          const f = new sn({
              name: "PMREM.Background",
              side: Nt,
              depthWrite: !1,
              depthTest: !1,
            }),
            g = new xt(new ps(), f);
          let m = !1;
          const p = e.background;
          p
            ? p.isColor && (f.color.copy(p), (e.background = null), (m = !0))
            : (f.color.copy(Oa), (m = !0));
          for (let _ = 0; _ < 6; _++) {
            const M = _ % 3;
            M === 0
              ? (a.up.set(0, l[_], 0), a.lookAt(c[_], 0, 0))
              : M === 1
              ? (a.up.set(0, 0, l[_]), a.lookAt(0, c[_], 0))
              : (a.up.set(0, l[_], 0), a.lookAt(0, 0, c[_]));
            const T = this._cubeSize;
            Os(i, M * T, _ > 2 ? T : 0, T, T),
              h.setRenderTarget(i),
              m && h.render(g, a),
              h.render(e, a);
          }
          g.geometry.dispose(),
            g.material.dispose(),
            (h.toneMapping = d),
            (h.autoClear = u),
            (e.background = p);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer,
            i = e.mapping === bi || e.mapping === wi;
          i
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = ka()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                e.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null &&
              (this._equirectMaterial = Ga());
          const s = i ? this._cubemapMaterial : this._equirectMaterial,
            o = new xt(this._lodPlanes[0], s),
            a = s.uniforms;
          a.envMap.value = e;
          const l = this._cubeSize;
          Os(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, qr);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          for (let i = 1; i < this._lodPlanes.length; i++) {
            const s = Math.sqrt(
                this._sigmas[i] * this._sigmas[i] -
                  this._sigmas[i - 1] * this._sigmas[i - 1]
              ),
              o = Ua[(i - 1) % Ua.length];
            this._blur(e, i - 1, i, s, o);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, s) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(e, o, t, n, i, "latitudinal", s),
            this._halfBlur(o, e, n, n, i, "longitudinal", s);
        }
        _halfBlur(e, t, n, i, s, o, a) {
          const l = this._renderer,
            c = this._blurMaterial;
          o !== "latitudinal" &&
            o !== "longitudinal" &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const h = 3,
            u = new xt(this._lodPlanes[i], c),
            d = c.uniforms,
            f = this._sizeLods[n] - 1,
            g = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * Dn - 1),
            m = s / g,
            p = isFinite(s) ? 1 + Math.floor(h * m) : Dn;
          p > Dn &&
            console.warn(
              `sigmaRadians, ${s}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Dn}`
            );
          const _ = [];
          let M = 0;
          for (let P = 0; P < Dn; ++P) {
            const y = P / m,
              L = Math.exp((-y * y) / 2);
            _.push(L), P === 0 ? (M += L) : P < p && (M += 2 * L);
          }
          for (let P = 0; P < _.length; P++) _[P] = _[P] / M;
          (d.envMap.value = e.texture),
            (d.samples.value = p),
            (d.weights.value = _),
            (d.latitudinal.value = o === "latitudinal"),
            a && (d.poleAxis.value = a);
          const { _lodMax: T } = this;
          (d.dTheta.value = g), (d.mipInt.value = T - n);
          const E = this._sizeLods[i],
            w = 3 * E * (i > T - _i ? i - T + _i : 0),
            R = 4 * (this._cubeSize - E);
          Os(t, w, R, 3 * E, 2 * E), l.setRenderTarget(t), l.render(u, qr);
        }
      }
      function hp(r) {
        const e = [],
          t = [],
          n = [];
        let i = r;
        const s = r - _i + 1 + Ba.length;
        for (let o = 0; o < s; o++) {
          const a = Math.pow(2, i);
          t.push(a);
          let l = 1 / a;
          o > r - _i ? (l = Ba[o - r + _i - 1]) : o === 0 && (l = 0), n.push(l);
          const c = 1 / (a - 2),
            h = -c,
            u = 1 + c,
            d = [h, h, u, h, u, u, h, h, u, u, h, u],
            f = 6,
            g = 6,
            m = 3,
            p = 2,
            _ = 1,
            M = new Float32Array(m * g * f),
            T = new Float32Array(p * g * f),
            E = new Float32Array(_ * g * f);
          for (let R = 0; R < f; R++) {
            const P = ((R % 3) * 2) / 3 - 1,
              y = R > 2 ? 0 : -1,
              L = [
                P,
                y,
                0,
                P + 2 / 3,
                y,
                0,
                P + 2 / 3,
                y + 1,
                0,
                P,
                y,
                0,
                P + 2 / 3,
                y + 1,
                0,
                P,
                y + 1,
                0,
              ];
            M.set(L, m * g * R), T.set(d, p * g * R);
            const N = [R, R, R, R, R, R];
            E.set(N, _ * g * R);
          }
          const w = new Ke();
          w.setAttribute("position", new tt(M, m)),
            w.setAttribute("uv", new tt(T, p)),
            w.setAttribute("faceIndex", new tt(E, _)),
            e.push(w),
            i > _i && i--;
        }
        return { lodPlanes: e, sizeLods: t, sigmas: n };
      }
      function Ha(r, e, t) {
        const n = new St(r, e, t);
        return (
          (n.texture.mapping = ir),
          (n.texture.name = "PMREM.cubeUv"),
          (n.scissorTest = !0),
          n
        );
      }
      function Os(r, e, t, n, i) {
        r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
      }
      function up(r, e, t) {
        const n = new Float32Array(Dn),
          i = new S(0, 1, 0);
        return new Bt({
          name: "SphericalGaussianBlur",
          defines: {
            n: Dn,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${r}.0`,
          },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: n },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: i },
          },
          vertexShader: Co(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: vn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Ga() {
        return new Bt({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: Co(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: vn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ka() {
        return new Bt({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: Co(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: vn,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Co() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function dp(r) {
        let e = new WeakMap(),
          t = null;
        function n(a) {
          if (a && a.isTexture) {
            const l = a.mapping,
              c = l === ro || l === oo,
              h = l === bi || l === wi;
            if (c || h)
              if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                a.needsPMREMUpdate = !1;
                let u = e.get(a);
                return (
                  t === null && (t = new za(r)),
                  (u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u)),
                  e.set(a, u),
                  u.texture
                );
              } else {
                if (e.has(a)) return e.get(a).texture;
                {
                  const u = a.image;
                  if ((c && u && u.height > 0) || (h && u && i(u))) {
                    t === null && (t = new za(r));
                    const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                    return (
                      e.set(a, d), a.addEventListener("dispose", s), d.texture
                    );
                  } else return null;
                }
              }
          }
          return a;
        }
        function i(a) {
          let l = 0;
          const c = 6;
          for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
          return l === c;
        }
        function s(a) {
          const l = a.target;
          l.removeEventListener("dispose", s);
          const c = e.get(l);
          c !== void 0 && (e.delete(l), c.dispose());
        }
        function o() {
          (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
        }
        return { get: n, dispose: o };
      }
      function fp(r) {
        const e = {};
        function t(n) {
          if (e[n] !== void 0) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                r.getExtension("WEBGL_depth_texture") ||
                r.getExtension("MOZ_WEBGL_depth_texture") ||
                r.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                r.getExtension("EXT_texture_filter_anisotropic") ||
                r.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                r.getExtension("WEBGL_compressed_texture_s3tc") ||
                r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                r.getExtension("WEBGL_compressed_texture_pvrtc") ||
                r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = r.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (n) {
            return t(n) !== null;
          },
          init: function (n) {
            n.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float"),
              t("WEBGL_multisampled_render_to_texture");
          },
          get: function (n) {
            const i = t(n);
            return (
              i === null &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              i
            );
          },
        };
      }
      function pp(r, e, t, n) {
        const i = {},
          s = new WeakMap();
        function o(u) {
          const d = u.target;
          d.index !== null && e.remove(d.index);
          for (const g in d.attributes) e.remove(d.attributes[g]);
          d.removeEventListener("dispose", o), delete i[d.id];
          const f = s.get(d);
          f && (e.remove(f), s.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
        }
        function a(u, d) {
          return (
            i[d.id] === !0 ||
              (d.addEventListener("dispose", o),
              (i[d.id] = !0),
              t.memory.geometries++),
            d
          );
        }
        function l(u) {
          const d = u.attributes;
          for (const g in d) e.update(d[g], 34962);
          const f = u.morphAttributes;
          for (const g in f) {
            const m = f[g];
            for (let p = 0, _ = m.length; p < _; p++) e.update(m[p], 34962);
          }
        }
        function c(u) {
          const d = [],
            f = u.index,
            g = u.attributes.position;
          let m = 0;
          if (f !== null) {
            const M = f.array;
            m = f.version;
            for (let T = 0, E = M.length; T < E; T += 3) {
              const w = M[T + 0],
                R = M[T + 1],
                P = M[T + 2];
              d.push(w, R, R, P, P, w);
            }
          } else {
            const M = g.array;
            m = g.version;
            for (let T = 0, E = M.length / 3 - 1; T < E; T += 3) {
              const w = T + 0,
                R = T + 1,
                P = T + 2;
              d.push(w, R, R, P, P, w);
            }
          }
          const p = new (ql(d) ? Jl : Yl)(d, 1);
          p.version = m;
          const _ = s.get(u);
          _ && e.remove(_), s.set(u, p);
        }
        function h(u) {
          const d = s.get(u);
          if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u);
          } else c(u);
          return s.get(u);
        }
        return { get: a, update: l, getWireframeAttribute: h };
      }
      function mp(r, e, t, n) {
        const i = n.isWebGL2;
        let s;
        function o(d) {
          s = d;
        }
        let a, l;
        function c(d) {
          (a = d.type), (l = d.bytesPerElement);
        }
        function h(d, f) {
          r.drawElements(s, f, a, d * l), t.update(f, s, 1);
        }
        function u(d, f, g) {
          if (g === 0) return;
          let m, p;
          if (i) (m = r), (p = "drawElementsInstanced");
          else if (
            ((m = e.get("ANGLE_instanced_arrays")),
            (p = "drawElementsInstancedANGLE"),
            m === null)
          ) {
            console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
          }
          m[p](s, f, a, d * l, g), t.update(f, s, g);
        }
        (this.setMode = o),
          (this.setIndex = c),
          (this.render = h),
          (this.renderInstances = u);
      }
      function gp(r) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(s, o, a) {
          switch ((t.calls++, o)) {
            case 4:
              t.triangles += a * (s / 3);
              break;
            case 1:
              t.lines += a * (s / 2);
              break;
            case 3:
              t.lines += a * (s - 1);
              break;
            case 2:
              t.lines += a * s;
              break;
            case 0:
              t.points += a * s;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", o);
              break;
          }
        }
        function i() {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: !0,
          reset: i,
          update: n,
        };
      }
      function _p(r, e) {
        return r[0] - e[0];
      }
      function xp(r, e) {
        return Math.abs(e[1]) - Math.abs(r[1]);
      }
      function jr(r, e) {
        let t = 1;
        const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
        n instanceof Int8Array
          ? (t = 127)
          : n instanceof Int16Array
          ? (t = 32767)
          : n instanceof Int32Array
          ? (t = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              n
            ),
          r.divideScalar(t);
      }
      function yp(r, e, t) {
        const n = {},
          i = new Float32Array(8),
          s = new WeakMap(),
          o = new je(),
          a = [];
        for (let c = 0; c < 8; c++) a[c] = [c, 0];
        function l(c, h, u, d) {
          const f = c.morphTargetInfluences;
          if (e.isWebGL2 === !0) {
            const m =
                h.morphAttributes.position ||
                h.morphAttributes.normal ||
                h.morphAttributes.color,
              p = m !== void 0 ? m.length : 0;
            let _ = s.get(h);
            if (_ === void 0 || _.count !== p) {
              let B = function () {
                C.dispose(), s.delete(h), h.removeEventListener("dispose", B);
              };
              var g = B;
              _ !== void 0 && _.texture.dispose();
              const E = h.morphAttributes.position !== void 0,
                w = h.morphAttributes.normal !== void 0,
                R = h.morphAttributes.color !== void 0,
                P = h.morphAttributes.position || [],
                y = h.morphAttributes.normal || [],
                L = h.morphAttributes.color || [];
              let N = 0;
              E === !0 && (N = 1), w === !0 && (N = 2), R === !0 && (N = 3);
              let D = h.attributes.position.count * N,
                ie = 1;
              D > e.maxTextureSize &&
                ((ie = Math.ceil(D / e.maxTextureSize)),
                (D = e.maxTextureSize));
              const J = new Float32Array(D * ie * 4 * p),
                C = new sr(J, D, ie, p);
              (C.type = xn), (C.needsUpdate = !0);
              const H = N * 4;
              for (let V = 0; V < p; V++) {
                const X = P[V],
                  U = y[V],
                  W = L[V],
                  Q = D * ie * 4 * V;
                for (let K = 0; K < X.count; K++) {
                  const ee = K * H;
                  E === !0 &&
                    (o.fromBufferAttribute(X, K),
                    X.normalized === !0 && jr(o, X),
                    (J[Q + ee + 0] = o.x),
                    (J[Q + ee + 1] = o.y),
                    (J[Q + ee + 2] = o.z),
                    (J[Q + ee + 3] = 0)),
                    w === !0 &&
                      (o.fromBufferAttribute(U, K),
                      U.normalized === !0 && jr(o, U),
                      (J[Q + ee + 4] = o.x),
                      (J[Q + ee + 5] = o.y),
                      (J[Q + ee + 6] = o.z),
                      (J[Q + ee + 7] = 0)),
                    R === !0 &&
                      (o.fromBufferAttribute(W, K),
                      W.normalized === !0 && jr(o, W),
                      (J[Q + ee + 8] = o.x),
                      (J[Q + ee + 9] = o.y),
                      (J[Q + ee + 10] = o.z),
                      (J[Q + ee + 11] = W.itemSize === 4 ? o.w : 1));
                }
              }
              (_ = { count: p, texture: C, size: new $(D, ie) }),
                s.set(h, _),
                h.addEventListener("dispose", B);
            }
            let M = 0;
            for (let E = 0; E < f.length; E++) M += f[E];
            const T = h.morphTargetsRelative ? 1 : 1 - M;
            d.getUniforms().setValue(r, "morphTargetBaseInfluence", T),
              d.getUniforms().setValue(r, "morphTargetInfluences", f),
              d.getUniforms().setValue(r, "morphTargetsTexture", _.texture, t),
              d.getUniforms().setValue(r, "morphTargetsTextureSize", _.size);
          } else {
            const m = f === void 0 ? 0 : f.length;
            let p = n[h.id];
            if (p === void 0 || p.length !== m) {
              p = [];
              for (let w = 0; w < m; w++) p[w] = [w, 0];
              n[h.id] = p;
            }
            for (let w = 0; w < m; w++) {
              const R = p[w];
              (R[0] = w), (R[1] = f[w]);
            }
            p.sort(xp);
            for (let w = 0; w < 8; w++)
              w < m && p[w][1]
                ? ((a[w][0] = p[w][0]), (a[w][1] = p[w][1]))
                : ((a[w][0] = Number.MAX_SAFE_INTEGER), (a[w][1] = 0));
            a.sort(_p);
            const _ = h.morphAttributes.position,
              M = h.morphAttributes.normal;
            let T = 0;
            for (let w = 0; w < 8; w++) {
              const R = a[w],
                P = R[0],
                y = R[1];
              P !== Number.MAX_SAFE_INTEGER && y
                ? (_ &&
                    h.getAttribute("morphTarget" + w) !== _[P] &&
                    h.setAttribute("morphTarget" + w, _[P]),
                  M &&
                    h.getAttribute("morphNormal" + w) !== M[P] &&
                    h.setAttribute("morphNormal" + w, M[P]),
                  (i[w] = y),
                  (T += y))
                : (_ &&
                    h.hasAttribute("morphTarget" + w) === !0 &&
                    h.deleteAttribute("morphTarget" + w),
                  M &&
                    h.hasAttribute("morphNormal" + w) === !0 &&
                    h.deleteAttribute("morphNormal" + w),
                  (i[w] = 0));
            }
            const E = h.morphTargetsRelative ? 1 : 1 - T;
            d.getUniforms().setValue(r, "morphTargetBaseInfluence", E),
              d.getUniforms().setValue(r, "morphTargetInfluences", i);
          }
        }
        return { update: l };
      }
      function vp(r, e, t, n) {
        let i = new WeakMap();
        function s(l) {
          const c = n.render.frame,
            h = l.geometry,
            u = e.get(l, h);
          return (
            i.get(u) !== c && (e.update(u), i.set(u, c)),
            l.isInstancedMesh &&
              (l.hasEventListener("dispose", a) === !1 &&
                l.addEventListener("dispose", a),
              t.update(l.instanceMatrix, 34962),
              l.instanceColor !== null && t.update(l.instanceColor, 34962)),
            u
          );
        }
        function o() {
          i = new WeakMap();
        }
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return { update: s, dispose: o };
      }
      const $l = new rt(),
        Ql = new sr(),
        ec = new Eo(),
        tc = new rr(),
        Va = [],
        Wa = [],
        qa = new Float32Array(16),
        Xa = new Float32Array(9),
        ja = new Float32Array(4);
      function Ii(r, e, t) {
        const n = r[0];
        if (n <= 0 || n > 0) return r;
        const i = e * t;
        let s = Va[i];
        if (
          (s === void 0 && ((s = new Float32Array(i)), (Va[i] = s)), e !== 0)
        ) {
          n.toArray(s, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), r[o].toArray(s, a);
        }
        return s;
      }
      function vt(r, e) {
        if (r.length !== e.length) return !1;
        for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
        return !0;
      }
      function Mt(r, e) {
        for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
      }
      function lr(r, e) {
        let t = Wa[e];
        t === void 0 && ((t = new Int32Array(e)), (Wa[e] = t));
        for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
        return t;
      }
      function Mp(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
      }
      function bp(r, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y) &&
            (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (vt(t, e)) return;
          r.uniform2fv(this.addr, e), Mt(t, e);
        }
      }
      function wp(r, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (r.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (r.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (vt(t, e)) return;
          r.uniform3fv(this.addr, e), Mt(t, e);
        }
      }
      function Sp(r, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (vt(t, e)) return;
          r.uniform4fv(this.addr, e), Mt(t, e);
        }
      }
      function Tp(r, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (vt(t, e)) return;
          r.uniformMatrix2fv(this.addr, !1, e), Mt(t, e);
        } else {
          if (vt(t, n)) return;
          ja.set(n), r.uniformMatrix2fv(this.addr, !1, ja), Mt(t, n);
        }
      }
      function Ep(r, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (vt(t, e)) return;
          r.uniformMatrix3fv(this.addr, !1, e), Mt(t, e);
        } else {
          if (vt(t, n)) return;
          Xa.set(n), r.uniformMatrix3fv(this.addr, !1, Xa), Mt(t, n);
        }
      }
      function Ap(r, e) {
        const t = this.cache,
          n = e.elements;
        if (n === void 0) {
          if (vt(t, e)) return;
          r.uniformMatrix4fv(this.addr, !1, e), Mt(t, e);
        } else {
          if (vt(t, n)) return;
          qa.set(n), r.uniformMatrix4fv(this.addr, !1, qa), Mt(t, n);
        }
      }
      function Rp(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
      }
      function Lp(r, e) {
        const t = this.cache;
        vt(t, e) || (r.uniform2iv(this.addr, e), Mt(t, e));
      }
      function Cp(r, e) {
        const t = this.cache;
        vt(t, e) || (r.uniform3iv(this.addr, e), Mt(t, e));
      }
      function Pp(r, e) {
        const t = this.cache;
        vt(t, e) || (r.uniform4iv(this.addr, e), Mt(t, e));
      }
      function Ip(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
      }
      function Dp(r, e) {
        const t = this.cache;
        vt(t, e) || (r.uniform2uiv(this.addr, e), Mt(t, e));
      }
      function Fp(r, e) {
        const t = this.cache;
        vt(t, e) || (r.uniform3uiv(this.addr, e), Mt(t, e));
      }
      function Np(r, e) {
        const t = this.cache;
        vt(t, e) || (r.uniform4uiv(this.addr, e), Mt(t, e));
      }
      function Bp(r, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2D(e || $l, i);
      }
      function Op(r, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture3D(e || ec, i);
      }
      function Up(r, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
          t.setTextureCube(e || tc, i);
      }
      function zp(r, e, t) {
        const n = this.cache,
          i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
          t.setTexture2DArray(e || Ql, i);
      }
      function Hp(r) {
        switch (r) {
          case 5126:
            return Mp;
          case 35664:
            return bp;
          case 35665:
            return wp;
          case 35666:
            return Sp;
          case 35674:
            return Tp;
          case 35675:
            return Ep;
          case 35676:
            return Ap;
          case 5124:
          case 35670:
            return Rp;
          case 35667:
          case 35671:
            return Lp;
          case 35668:
          case 35672:
            return Cp;
          case 35669:
          case 35673:
            return Pp;
          case 5125:
            return Ip;
          case 36294:
            return Dp;
          case 36295:
            return Fp;
          case 36296:
            return Np;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Bp;
          case 35679:
          case 36299:
          case 36307:
            return Op;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Up;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return zp;
        }
      }
      function Gp(r, e) {
        r.uniform1fv(this.addr, e);
      }
      function kp(r, e) {
        const t = Ii(e, this.size, 2);
        r.uniform2fv(this.addr, t);
      }
      function Vp(r, e) {
        const t = Ii(e, this.size, 3);
        r.uniform3fv(this.addr, t);
      }
      function Wp(r, e) {
        const t = Ii(e, this.size, 4);
        r.uniform4fv(this.addr, t);
      }
      function qp(r, e) {
        const t = Ii(e, this.size, 4);
        r.uniformMatrix2fv(this.addr, !1, t);
      }
      function Xp(r, e) {
        const t = Ii(e, this.size, 9);
        r.uniformMatrix3fv(this.addr, !1, t);
      }
      function jp(r, e) {
        const t = Ii(e, this.size, 16);
        r.uniformMatrix4fv(this.addr, !1, t);
      }
      function Yp(r, e) {
        r.uniform1iv(this.addr, e);
      }
      function Jp(r, e) {
        r.uniform2iv(this.addr, e);
      }
      function Kp(r, e) {
        r.uniform3iv(this.addr, e);
      }
      function Zp(r, e) {
        r.uniform4iv(this.addr, e);
      }
      function $p(r, e) {
        r.uniform1uiv(this.addr, e);
      }
      function Qp(r, e) {
        r.uniform2uiv(this.addr, e);
      }
      function em(r, e) {
        r.uniform3uiv(this.addr, e);
      }
      function tm(r, e) {
        r.uniform4uiv(this.addr, e);
      }
      function nm(r, e, t) {
        const n = e.length,
          i = lr(t, n);
        r.uniform1iv(this.addr, i);
        for (let s = 0; s !== n; ++s) t.setTexture2D(e[s] || $l, i[s]);
      }
      function im(r, e, t) {
        const n = e.length,
          i = lr(t, n);
        r.uniform1iv(this.addr, i);
        for (let s = 0; s !== n; ++s) t.setTexture3D(e[s] || ec, i[s]);
      }
      function sm(r, e, t) {
        const n = e.length,
          i = lr(t, n);
        r.uniform1iv(this.addr, i);
        for (let s = 0; s !== n; ++s) t.setTextureCube(e[s] || tc, i[s]);
      }
      function rm(r, e, t) {
        const n = e.length,
          i = lr(t, n);
        r.uniform1iv(this.addr, i);
        for (let s = 0; s !== n; ++s) t.setTexture2DArray(e[s] || Ql, i[s]);
      }
      function om(r) {
        switch (r) {
          case 5126:
            return Gp;
          case 35664:
            return kp;
          case 35665:
            return Vp;
          case 35666:
            return Wp;
          case 35674:
            return qp;
          case 35675:
            return Xp;
          case 35676:
            return jp;
          case 5124:
          case 35670:
            return Yp;
          case 35667:
          case 35671:
            return Jp;
          case 35668:
          case 35672:
            return Kp;
          case 35669:
          case 35673:
            return Zp;
          case 5125:
            return $p;
          case 36294:
            return Qp;
          case 36295:
            return em;
          case 36296:
            return tm;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return nm;
          case 35679:
          case 36299:
          case 36307:
            return im;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return sm;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return rm;
        }
      }
      function am(r, e, t) {
        (this.id = r),
          (this.addr = t),
          (this.cache = []),
          (this.setValue = Hp(e.type));
      }
      function lm(r, e, t) {
        (this.id = r),
          (this.addr = t),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = om(e.type));
      }
      function nc(r) {
        (this.id = r), (this.seq = []), (this.map = {});
      }
      nc.prototype.setValue = function (r, e, t) {
        const n = this.seq;
        for (let i = 0, s = n.length; i !== s; ++i) {
          const o = n[i];
          o.setValue(r, e[o.id], t);
        }
      };
      const Yr = /(\w+)(\])?(\[|\.)?/g;
      function Ya(r, e) {
        r.seq.push(e), (r.map[e.id] = e);
      }
      function cm(r, e, t) {
        const n = r.name,
          i = n.length;
        for (Yr.lastIndex = 0; ; ) {
          const s = Yr.exec(n),
            o = Yr.lastIndex;
          let a = s[1];
          const l = s[2] === "]",
            c = s[3];
          if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
            Ya(t, c === void 0 ? new am(a, r, e) : new lm(a, r, e));
            break;
          } else {
            let u = t.map[a];
            u === void 0 && ((u = new nc(a)), Ya(t, u)), (t = u);
          }
        }
      }
      function Mn(r, e) {
        (this.seq = []), (this.map = {});
        const t = r.getProgramParameter(e, 35718);
        for (let n = 0; n < t; ++n) {
          const i = r.getActiveUniform(e, n),
            s = r.getUniformLocation(e, i.name);
          cm(i, s, this);
        }
      }
      Mn.prototype.setValue = function (r, e, t, n) {
        const i = this.map[e];
        i !== void 0 && i.setValue(r, t, n);
      };
      Mn.prototype.setOptional = function (r, e, t) {
        const n = e[t];
        n !== void 0 && this.setValue(r, t, n);
      };
      Mn.upload = function (r, e, t, n) {
        for (let i = 0, s = e.length; i !== s; ++i) {
          const o = e[i],
            a = t[o.id];
          a.needsUpdate !== !1 && o.setValue(r, a.value, n);
        }
      };
      Mn.seqWithValue = function (r, e) {
        const t = [];
        for (let n = 0, i = r.length; n !== i; ++n) {
          const s = r[n];
          s.id in e && t.push(s);
        }
        return t;
      };
      function Ja(r, e, t) {
        const n = r.createShader(e);
        return r.shaderSource(n, t), r.compileShader(n), n;
      }
      let hm = 0;
      function um(r, e) {
        const t = r.split(`
`),
          n = [],
          i = Math.max(e - 6, 0),
          s = Math.min(e + 6, t.length);
        for (let o = i; o < s; o++) n.push(o + 1 + ": " + t[o]);
        return n.join(`
`);
      }
      function dm(r) {
        switch (r) {
          case Sn:
            return ["Linear", "( value )"];
          case ze:
            return ["sRGB", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", r),
              ["Linear", "( value )"]
            );
        }
      }
      function Ka(r, e, t) {
        const n = r.getShaderParameter(e, 35713),
          i = r.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const s = /ERROR: 0:(\d+)/.exec(i);
        if (s) {
          const o = parseInt(s[0]);
          return (
            t.toUpperCase() +
            `

` +
            i +
            `

` +
            um(r.getShaderSource(e), o)
          );
        } else return i;
      }
      function fm(r, e) {
        const t = dm(e);
        return (
          "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function pm(r, e) {
        let t;
        switch (e) {
          case xh:
            t = "Linear";
            break;
          case yh:
            t = "Reinhard";
            break;
          case vh:
            t = "OptimizedCineon";
            break;
          case Mh:
            t = "ACESFilmic";
            break;
          case bh:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          r +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function mm(r) {
        return [
          r.extensionDerivatives ||
          !!r.envMapCubeUVHeight ||
          r.bumpMap ||
          r.tangentSpaceNormalMap ||
          r.clearcoatNormalMap ||
          r.flatShading ||
          r.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (r.extensionFragDepth || r.logarithmicDepthBuffer) &&
          r.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
          r.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ].filter(Zi).join(`
`);
      }
      function gm(r) {
        const e = [];
        for (const t in r) {
          const n = r[t];
          n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
      }
      function _m(r, e) {
        const t = {},
          n = r.getProgramParameter(e, 35721);
        for (let i = 0; i < n; i++) {
          const s = r.getActiveAttrib(e, i),
            o = s.name;
          let a = 1;
          s.type === 35674 && (a = 2),
            s.type === 35675 && (a = 3),
            s.type === 35676 && (a = 4),
            (t[o] = {
              type: s.type,
              location: r.getAttribLocation(e, o),
              locationSize: a,
            });
        }
        return t;
      }
      function Zi(r) {
        return r !== "";
      }
      function Za(r, e) {
        return r
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function $a(r, e) {
        return r
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const xm = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function uo(r) {
        return r.replace(xm, ym);
      }
      function ym(r, e) {
        const t = De[e];
        if (t === void 0)
          throw new Error("Can not resolve #include <" + e + ">");
        return uo(t);
      }
      const vm =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Mm =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Qa(r) {
        return r.replace(Mm, ic).replace(vm, bm);
      }
      function bm(r, e, t, n) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          ic(r, e, t, n)
        );
      }
      function ic(r, e, t, n) {
        let i = "";
        for (let s = parseInt(e); s < parseInt(t); s++)
          i += n
            .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, s);
        return i;
      }
      function el(r) {
        let e =
          "precision " +
          r.precision +
          ` float;
precision ` +
          r.precision +
          " int;";
        return (
          r.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : r.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : r.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function wm(r) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          r.shadowMapType === Bl
            ? (e = "SHADOWMAP_TYPE_PCF")
            : r.shadowMapType === Kc
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : r.shadowMapType === Ki && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function Sm(r) {
        let e = "ENVMAP_TYPE_CUBE";
        if (r.envMap)
          switch (r.envMapMode) {
            case bi:
            case wi:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case ir:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function Tm(r) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (r.envMap)
          switch (r.envMapMode) {
            case wi:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function Em(r) {
        let e = "ENVMAP_BLENDING_NONE";
        if (r.envMap)
          switch (r.combine) {
            case nr:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case gh:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case _h:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function Am(r) {
        const e = r.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2,
          n = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
          texelHeight: n,
          maxMip: t,
        };
      }
      function Rm(r, e, t, n) {
        const i = r.getContext(),
          s = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const l = wm(t),
          c = Sm(t),
          h = Tm(t),
          u = Em(t),
          d = Am(t),
          f = t.isWebGL2 ? "" : mm(t),
          g = gm(s),
          m = i.createProgram();
        let p,
          _,
          M = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((p = [g].filter(Zi).join(`
`)),
            p.length > 0 &&
              (p += `
`),
            (_ = [f, g].filter(Zi).join(`
`)),
            _.length > 0 &&
              (_ += `
`))
          : ((p = [
              el(t),
              "#define SHADER_NAME " + t.shaderName,
              g,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + h : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(Zi).join(`
`)),
            (_ = [
              f,
              el(t),
              "#define SHADER_NAME " + t.shaderName,
              g,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + h : "",
              t.envMap ? "#define " + u : "",
              d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
              d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
              d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              t.normalMap && t.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== rn ? "#define TONE_MAPPING" : "",
              t.toneMapping !== rn ? De.tonemapping_pars_fragment : "",
              t.toneMapping !== rn ? pm("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.opaque ? "#define OPAQUE" : "",
              De.encodings_pars_fragment,
              fm("linearToOutputTexel", t.outputEncoding),
              t.useDepthPacking
                ? "#define DEPTH_PACKING " + t.depthPacking
                : "",
              `
`,
            ].filter(Zi).join(`
`))),
          (o = uo(o)),
          (o = Za(o, t)),
          (o = $a(o, t)),
          (a = uo(a)),
          (a = Za(a, t)),
          (a = $a(a, t)),
          (o = Qa(o)),
          (a = Qa(a)),
          t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((M = `#version 300 es
`),
            (p =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              p),
            (_ =
              [
                "#define varying in",
                t.glslVersion === wa
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                t.glslVersion === wa ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              _));
        const T = M + p + o,
          E = M + _ + a,
          w = Ja(i, 35633, T),
          R = Ja(i, 35632, E);
        if (
          (i.attachShader(m, w),
          i.attachShader(m, R),
          t.index0AttributeName !== void 0
            ? i.bindAttribLocation(m, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"),
          i.linkProgram(m),
          r.debug.checkShaderErrors)
        ) {
          const L = i.getProgramInfoLog(m).trim(),
            N = i.getShaderInfoLog(w).trim(),
            D = i.getShaderInfoLog(R).trim();
          let ie = !0,
            J = !0;
          if (i.getProgramParameter(m, 35714) === !1) {
            ie = !1;
            const C = Ka(i, w, "vertex"),
              H = Ka(i, R, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                i.getError() +
                " - VALIDATE_STATUS " +
                i.getProgramParameter(m, 35715) +
                `

Program Info Log: ` +
                L +
                `
` +
                C +
                `
` +
                H
            );
          } else
            L !== ""
              ? console.warn("THREE.WebGLProgram: Program Info Log:", L)
              : (N === "" || D === "") && (J = !1);
          J &&
            (this.diagnostics = {
              runnable: ie,
              programLog: L,
              vertexShader: { log: N, prefix: p },
              fragmentShader: { log: D, prefix: _ },
            });
        }
        i.deleteShader(w), i.deleteShader(R);
        let P;
        this.getUniforms = function () {
          return P === void 0 && (P = new Mn(i, m)), P;
        };
        let y;
        return (
          (this.getAttributes = function () {
            return y === void 0 && (y = _m(i, m)), y;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              i.deleteProgram(m),
              (this.program = void 0);
          }),
          (this.name = t.shaderName),
          (this.id = hm++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = m),
          (this.vertexShader = w),
          (this.fragmentShader = R),
          this
        );
      }
      let Lm = 0;
      class Cm {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            s = this._getShaderStage(n),
            o = this._getShaderCacheForMaterial(e);
          return (
            o.has(i) === !1 && (o.add(i), i.usedTimes++),
            o.has(s) === !1 && (o.add(s), s.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const n of t)
            n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          if (t.has(e) === !1) {
            const n = new Pm(e);
            t.set(e, n);
          }
          return t.get(e);
        }
      }
      class Pm {
        constructor(e) {
          (this.id = Lm++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function Im(r, e, t, n, i, s, o) {
        const a = new jl(),
          l = new Cm(),
          c = [],
          h = i.isWebGL2,
          u = i.logarithmicDepthBuffer,
          d = i.vertexTextures;
        let f = i.precision;
        const g = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function m(y, L, N, D, ie) {
          const J = D.fog,
            C = ie.geometry,
            H = y.isMeshStandardMaterial ? D.environment : null,
            B = (y.isMeshStandardMaterial ? t : e).get(y.envMap || H),
            V = !!B && B.mapping === ir ? B.image.height : null,
            X = g[y.type];
          y.precision !== null &&
            ((f = i.getMaxPrecision(y.precision)),
            f !== y.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                y.precision,
                "not supported, using",
                f,
                "instead."
              ));
          const U =
              C.morphAttributes.position ||
              C.morphAttributes.normal ||
              C.morphAttributes.color,
            W = U !== void 0 ? U.length : 0;
          let Q = 0;
          C.morphAttributes.position !== void 0 && (Q = 1),
            C.morphAttributes.normal !== void 0 && (Q = 2),
            C.morphAttributes.color !== void 0 && (Q = 3);
          let K, ee, ge, _e;
          if (X) {
            const se = Wt[X];
            (K = se.vertexShader), (ee = se.fragmentShader);
          } else
            (K = y.vertexShader),
              (ee = y.fragmentShader),
              l.update(y),
              (ge = l.getVertexShaderID(y)),
              (_e = l.getFragmentShaderID(y));
          const k = r.getRenderTarget(),
            He = y.alphaTest > 0,
            be = y.clearcoat > 0;
          return {
            isWebGL2: h,
            shaderID: X,
            shaderName: y.type,
            vertexShader: K,
            fragmentShader: ee,
            defines: y.defines,
            customVertexShaderID: ge,
            customFragmentShaderID: _e,
            isRawShaderMaterial: y.isRawShaderMaterial === !0,
            glslVersion: y.glslVersion,
            precision: f,
            instancing: ie.isInstancedMesh === !0,
            instancingColor:
              ie.isInstancedMesh === !0 && ie.instanceColor !== null,
            supportsVertexTextures: d,
            outputEncoding:
              k === null
                ? r.outputEncoding
                : k.isXRRenderTarget === !0
                ? k.texture.encoding
                : Sn,
            map: !!y.map,
            matcap: !!y.matcap,
            envMap: !!B,
            envMapMode: B && B.mapping,
            envMapCubeUVHeight: V,
            lightMap: !!y.lightMap,
            aoMap: !!y.aoMap,
            emissiveMap: !!y.emissiveMap,
            bumpMap: !!y.bumpMap,
            normalMap: !!y.normalMap,
            objectSpaceNormalMap: y.normalMapType === qh,
            tangentSpaceNormalMap: y.normalMapType === Gn,
            decodeVideoTexture:
              !!y.map && y.map.isVideoTexture === !0 && y.map.encoding === ze,
            clearcoat: be,
            clearcoatMap: be && !!y.clearcoatMap,
            clearcoatRoughnessMap: be && !!y.clearcoatRoughnessMap,
            clearcoatNormalMap: be && !!y.clearcoatNormalMap,
            displacementMap: !!y.displacementMap,
            roughnessMap: !!y.roughnessMap,
            metalnessMap: !!y.metalnessMap,
            specularMap: !!y.specularMap,
            specularIntensityMap: !!y.specularIntensityMap,
            specularColorMap: !!y.specularColorMap,
            opaque: y.transparent === !1 && y.blending === yi,
            alphaMap: !!y.alphaMap,
            alphaTest: He,
            gradientMap: !!y.gradientMap,
            sheen: y.sheen > 0,
            sheenColorMap: !!y.sheenColorMap,
            sheenRoughnessMap: !!y.sheenRoughnessMap,
            transmission: y.transmission > 0,
            transmissionMap: !!y.transmissionMap,
            thicknessMap: !!y.thicknessMap,
            combine: y.combine,
            vertexTangents: !!y.normalMap && !!C.attributes.tangent,
            vertexColors: y.vertexColors,
            vertexAlphas:
              y.vertexColors === !0 &&
              !!C.attributes.color &&
              C.attributes.color.itemSize === 4,
            vertexUvs:
              !!y.map ||
              !!y.bumpMap ||
              !!y.normalMap ||
              !!y.specularMap ||
              !!y.alphaMap ||
              !!y.emissiveMap ||
              !!y.roughnessMap ||
              !!y.metalnessMap ||
              !!y.clearcoatMap ||
              !!y.clearcoatRoughnessMap ||
              !!y.clearcoatNormalMap ||
              !!y.displacementMap ||
              !!y.transmissionMap ||
              !!y.thicknessMap ||
              !!y.specularIntensityMap ||
              !!y.specularColorMap ||
              !!y.sheenColorMap ||
              !!y.sheenRoughnessMap,
            uvsVertexOnly:
              !(
                !!y.map ||
                !!y.bumpMap ||
                !!y.normalMap ||
                !!y.specularMap ||
                !!y.alphaMap ||
                !!y.emissiveMap ||
                !!y.roughnessMap ||
                !!y.metalnessMap ||
                !!y.clearcoatNormalMap ||
                y.transmission > 0 ||
                !!y.transmissionMap ||
                !!y.thicknessMap ||
                !!y.specularIntensityMap ||
                !!y.specularColorMap ||
                y.sheen > 0 ||
                !!y.sheenColorMap ||
                !!y.sheenRoughnessMap
              ) && !!y.displacementMap,
            fog: !!J,
            useFog: y.fog === !0,
            fogExp2: J && J.isFogExp2,
            flatShading: !!y.flatShading,
            sizeAttenuation: y.sizeAttenuation,
            logarithmicDepthBuffer: u,
            skinning: ie.isSkinnedMesh === !0,
            morphTargets: C.morphAttributes.position !== void 0,
            morphNormals: C.morphAttributes.normal !== void 0,
            morphColors: C.morphAttributes.color !== void 0,
            morphTargetsCount: W,
            morphTextureStride: Q,
            numDirLights: L.directional.length,
            numPointLights: L.point.length,
            numSpotLights: L.spot.length,
            numRectAreaLights: L.rectArea.length,
            numHemiLights: L.hemi.length,
            numDirLightShadows: L.directionalShadowMap.length,
            numPointLightShadows: L.pointShadowMap.length,
            numSpotLightShadows: L.spotShadowMap.length,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: y.dithering,
            shadowMapEnabled: r.shadowMap.enabled && N.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: y.toneMapped ? r.toneMapping : rn,
            physicallyCorrectLights: r.physicallyCorrectLights,
            premultipliedAlpha: y.premultipliedAlpha,
            doubleSided: y.side === On,
            flipSided: y.side === Nt,
            useDepthPacking: !!y.depthPacking,
            depthPacking: y.depthPacking || 0,
            index0AttributeName: y.index0AttributeName,
            extensionDerivatives: y.extensions && y.extensions.derivatives,
            extensionFragDepth: y.extensions && y.extensions.fragDepth,
            extensionDrawBuffers: y.extensions && y.extensions.drawBuffers,
            extensionShaderTextureLOD:
              y.extensions && y.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              h || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: y.customProgramCacheKey(),
          };
        }
        function p(y) {
          const L = [];
          if (
            (y.shaderID
              ? L.push(y.shaderID)
              : (L.push(y.customVertexShaderID),
                L.push(y.customFragmentShaderID)),
            y.defines !== void 0)
          )
            for (const N in y.defines) L.push(N), L.push(y.defines[N]);
          return (
            y.isRawShaderMaterial === !1 &&
              (_(L, y), M(L, y), L.push(r.outputEncoding)),
            L.push(y.customProgramCacheKey),
            L.join()
          );
        }
        function _(y, L) {
          y.push(L.precision),
            y.push(L.outputEncoding),
            y.push(L.envMapMode),
            y.push(L.envMapCubeUVHeight),
            y.push(L.combine),
            y.push(L.vertexUvs),
            y.push(L.fogExp2),
            y.push(L.sizeAttenuation),
            y.push(L.morphTargetsCount),
            y.push(L.morphAttributeCount),
            y.push(L.numDirLights),
            y.push(L.numPointLights),
            y.push(L.numSpotLights),
            y.push(L.numHemiLights),
            y.push(L.numRectAreaLights),
            y.push(L.numDirLightShadows),
            y.push(L.numPointLightShadows),
            y.push(L.numSpotLightShadows),
            y.push(L.shadowMapType),
            y.push(L.toneMapping),
            y.push(L.numClippingPlanes),
            y.push(L.numClipIntersection),
            y.push(L.depthPacking);
        }
        function M(y, L) {
          a.disableAll(),
            L.isWebGL2 && a.enable(0),
            L.supportsVertexTextures && a.enable(1),
            L.instancing && a.enable(2),
            L.instancingColor && a.enable(3),
            L.map && a.enable(4),
            L.matcap && a.enable(5),
            L.envMap && a.enable(6),
            L.lightMap && a.enable(7),
            L.aoMap && a.enable(8),
            L.emissiveMap && a.enable(9),
            L.bumpMap && a.enable(10),
            L.normalMap && a.enable(11),
            L.objectSpaceNormalMap && a.enable(12),
            L.tangentSpaceNormalMap && a.enable(13),
            L.clearcoat && a.enable(14),
            L.clearcoatMap && a.enable(15),
            L.clearcoatRoughnessMap && a.enable(16),
            L.clearcoatNormalMap && a.enable(17),
            L.displacementMap && a.enable(18),
            L.specularMap && a.enable(19),
            L.roughnessMap && a.enable(20),
            L.metalnessMap && a.enable(21),
            L.gradientMap && a.enable(22),
            L.alphaMap && a.enable(23),
            L.alphaTest && a.enable(24),
            L.vertexColors && a.enable(25),
            L.vertexAlphas && a.enable(26),
            L.vertexUvs && a.enable(27),
            L.vertexTangents && a.enable(28),
            L.uvsVertexOnly && a.enable(29),
            L.fog && a.enable(30),
            y.push(a.mask),
            a.disableAll(),
            L.useFog && a.enable(0),
            L.flatShading && a.enable(1),
            L.logarithmicDepthBuffer && a.enable(2),
            L.skinning && a.enable(3),
            L.morphTargets && a.enable(4),
            L.morphNormals && a.enable(5),
            L.morphColors && a.enable(6),
            L.premultipliedAlpha && a.enable(7),
            L.shadowMapEnabled && a.enable(8),
            L.physicallyCorrectLights && a.enable(9),
            L.doubleSided && a.enable(10),
            L.flipSided && a.enable(11),
            L.useDepthPacking && a.enable(12),
            L.dithering && a.enable(13),
            L.specularIntensityMap && a.enable(14),
            L.specularColorMap && a.enable(15),
            L.transmission && a.enable(16),
            L.transmissionMap && a.enable(17),
            L.thicknessMap && a.enable(18),
            L.sheen && a.enable(19),
            L.sheenColorMap && a.enable(20),
            L.sheenRoughnessMap && a.enable(21),
            L.decodeVideoTexture && a.enable(22),
            L.opaque && a.enable(23),
            y.push(a.mask);
        }
        function T(y) {
          const L = g[y.type];
          let N;
          if (L) {
            const D = Wt[L];
            N = Su.clone(D.uniforms);
          } else N = y.uniforms;
          return N;
        }
        function E(y, L) {
          let N;
          for (let D = 0, ie = c.length; D < ie; D++) {
            const J = c[D];
            if (J.cacheKey === L) {
              (N = J), ++N.usedTimes;
              break;
            }
          }
          return N === void 0 && ((N = new Rm(r, L, y, s)), c.push(N)), N;
        }
        function w(y) {
          if (--y.usedTimes === 0) {
            const L = c.indexOf(y);
            (c[L] = c[c.length - 1]), c.pop(), y.destroy();
          }
        }
        function R(y) {
          l.remove(y);
        }
        function P() {
          l.dispose();
        }
        return {
          getParameters: m,
          getProgramCacheKey: p,
          getUniforms: T,
          acquireProgram: E,
          releaseProgram: w,
          releaseShaderCache: R,
          programs: c,
          dispose: P,
        };
      }
      function Dm() {
        let r = new WeakMap();
        function e(s) {
          let o = r.get(s);
          return o === void 0 && ((o = {}), r.set(s, o)), o;
        }
        function t(s) {
          r.delete(s);
        }
        function n(s, o, a) {
          r.get(s)[o] = a;
        }
        function i() {
          r = new WeakMap();
        }
        return { get: e, remove: t, update: n, dispose: i };
      }
      function Fm(r, e) {
        return r.groupOrder !== e.groupOrder
          ? r.groupOrder - e.groupOrder
          : r.renderOrder !== e.renderOrder
          ? r.renderOrder - e.renderOrder
          : r.material.id !== e.material.id
          ? r.material.id - e.material.id
          : r.z !== e.z
          ? r.z - e.z
          : r.id - e.id;
      }
      function tl(r, e) {
        return r.groupOrder !== e.groupOrder
          ? r.groupOrder - e.groupOrder
          : r.renderOrder !== e.renderOrder
          ? r.renderOrder - e.renderOrder
          : r.z !== e.z
          ? e.z - r.z
          : r.id - e.id;
      }
      function nl() {
        const r = [];
        let e = 0;
        const t = [],
          n = [],
          i = [];
        function s() {
          (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
        }
        function o(u, d, f, g, m, p) {
          let _ = r[e];
          return (
            _ === void 0
              ? ((_ = {
                  id: u.id,
                  object: u,
                  geometry: d,
                  material: f,
                  groupOrder: g,
                  renderOrder: u.renderOrder,
                  z: m,
                  group: p,
                }),
                (r[e] = _))
              : ((_.id = u.id),
                (_.object = u),
                (_.geometry = d),
                (_.material = f),
                (_.groupOrder = g),
                (_.renderOrder = u.renderOrder),
                (_.z = m),
                (_.group = p)),
            e++,
            _
          );
        }
        function a(u, d, f, g, m, p) {
          const _ = o(u, d, f, g, m, p);
          f.transmission > 0
            ? n.push(_)
            : f.transparent === !0
            ? i.push(_)
            : t.push(_);
        }
        function l(u, d, f, g, m, p) {
          const _ = o(u, d, f, g, m, p);
          f.transmission > 0
            ? n.unshift(_)
            : f.transparent === !0
            ? i.unshift(_)
            : t.unshift(_);
        }
        function c(u, d) {
          t.length > 1 && t.sort(u || Fm),
            n.length > 1 && n.sort(d || tl),
            i.length > 1 && i.sort(d || tl);
        }
        function h() {
          for (let u = e, d = r.length; u < d; u++) {
            const f = r[u];
            if (f.id === null) break;
            (f.id = null),
              (f.object = null),
              (f.geometry = null),
              (f.material = null),
              (f.group = null);
          }
        }
        return {
          opaque: t,
          transmissive: n,
          transparent: i,
          init: s,
          push: a,
          unshift: l,
          finish: h,
          sort: c,
        };
      }
      function Nm() {
        let r = new WeakMap();
        function e(n, i) {
          let s;
          return (
            r.has(n) === !1
              ? ((s = new nl()), r.set(n, [s]))
              : i >= r.get(n).length
              ? ((s = new nl()), r.get(n).push(s))
              : (s = r.get(n)[i]),
            s
          );
        }
        function t() {
          r = new WeakMap();
        }
        return { get: e, dispose: t };
      }
      function Bm() {
        const r = {};
        return {
          get: function (e) {
            if (r[e.id] !== void 0) return r[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new S(), color: new he() };
                break;
              case "SpotLight":
                t = {
                  position: new S(),
                  direction: new S(),
                  color: new he(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new S(),
                  color: new he(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new S(),
                  skyColor: new he(),
                  groundColor: new he(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new he(),
                  position: new S(),
                  halfWidth: new S(),
                  halfHeight: new S(),
                };
                break;
            }
            return (r[e.id] = t), t;
          },
        };
      }
      function Om() {
        const r = {};
        return {
          get: function (e) {
            if (r[e.id] !== void 0) return r[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new $(),
                };
                break;
              case "SpotLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new $(),
                };
                break;
              case "PointLight":
                t = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new $(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (r[e.id] = t), t;
          },
        };
      }
      let Um = 0;
      function zm(r, e) {
        return (e.castShadow ? 1 : 0) - (r.castShadow ? 1 : 0);
      }
      function Hm(r, e) {
        const t = new Bm(),
          n = Om(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let h = 0; h < 9; h++) i.probe.push(new S());
        const s = new S(),
          o = new me(),
          a = new me();
        function l(h, u) {
          let d = 0,
            f = 0,
            g = 0;
          for (let L = 0; L < 9; L++) i.probe[L].set(0, 0, 0);
          let m = 0,
            p = 0,
            _ = 0,
            M = 0,
            T = 0,
            E = 0,
            w = 0,
            R = 0;
          h.sort(zm);
          const P = u !== !0 ? Math.PI : 1;
          for (let L = 0, N = h.length; L < N; L++) {
            const D = h[L],
              ie = D.color,
              J = D.intensity,
              C = D.distance,
              H = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight)
              (d += ie.r * J * P), (f += ie.g * J * P), (g += ie.b * J * P);
            else if (D.isLightProbe)
              for (let B = 0; B < 9; B++)
                i.probe[B].addScaledVector(D.sh.coefficients[B], J);
            else if (D.isDirectionalLight) {
              const B = t.get(D);
              if (
                (B.color.copy(D.color).multiplyScalar(D.intensity * P),
                D.castShadow)
              ) {
                const V = D.shadow,
                  X = n.get(D);
                (X.shadowBias = V.bias),
                  (X.shadowNormalBias = V.normalBias),
                  (X.shadowRadius = V.radius),
                  (X.shadowMapSize = V.mapSize),
                  (i.directionalShadow[m] = X),
                  (i.directionalShadowMap[m] = H),
                  (i.directionalShadowMatrix[m] = D.shadow.matrix),
                  E++;
              }
              (i.directional[m] = B), m++;
            } else if (D.isSpotLight) {
              const B = t.get(D);
              if (
                (B.position.setFromMatrixPosition(D.matrixWorld),
                B.color.copy(ie).multiplyScalar(J * P),
                (B.distance = C),
                (B.coneCos = Math.cos(D.angle)),
                (B.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
                (B.decay = D.decay),
                D.castShadow)
              ) {
                const V = D.shadow,
                  X = n.get(D);
                (X.shadowBias = V.bias),
                  (X.shadowNormalBias = V.normalBias),
                  (X.shadowRadius = V.radius),
                  (X.shadowMapSize = V.mapSize),
                  (i.spotShadow[_] = X),
                  (i.spotShadowMap[_] = H),
                  (i.spotShadowMatrix[_] = D.shadow.matrix),
                  R++;
              }
              (i.spot[_] = B), _++;
            } else if (D.isRectAreaLight) {
              const B = t.get(D);
              B.color.copy(ie).multiplyScalar(J),
                B.halfWidth.set(D.width * 0.5, 0, 0),
                B.halfHeight.set(0, D.height * 0.5, 0),
                (i.rectArea[M] = B),
                M++;
            } else if (D.isPointLight) {
              const B = t.get(D);
              if (
                (B.color.copy(D.color).multiplyScalar(D.intensity * P),
                (B.distance = D.distance),
                (B.decay = D.decay),
                D.castShadow)
              ) {
                const V = D.shadow,
                  X = n.get(D);
                (X.shadowBias = V.bias),
                  (X.shadowNormalBias = V.normalBias),
                  (X.shadowRadius = V.radius),
                  (X.shadowMapSize = V.mapSize),
                  (X.shadowCameraNear = V.camera.near),
                  (X.shadowCameraFar = V.camera.far),
                  (i.pointShadow[p] = X),
                  (i.pointShadowMap[p] = H),
                  (i.pointShadowMatrix[p] = D.shadow.matrix),
                  w++;
              }
              (i.point[p] = B), p++;
            } else if (D.isHemisphereLight) {
              const B = t.get(D);
              B.skyColor.copy(D.color).multiplyScalar(J * P),
                B.groundColor.copy(D.groundColor).multiplyScalar(J * P),
                (i.hemi[T] = B),
                T++;
            }
          }
          M > 0 &&
            (e.isWebGL2 || r.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = oe.LTC_FLOAT_1),
                (i.rectAreaLTC2 = oe.LTC_FLOAT_2))
              : r.has("OES_texture_half_float_linear") === !0
              ? ((i.rectAreaLTC1 = oe.LTC_HALF_1),
                (i.rectAreaLTC2 = oe.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = d),
            (i.ambient[1] = f),
            (i.ambient[2] = g);
          const y = i.hash;
          (y.directionalLength !== m ||
            y.pointLength !== p ||
            y.spotLength !== _ ||
            y.rectAreaLength !== M ||
            y.hemiLength !== T ||
            y.numDirectionalShadows !== E ||
            y.numPointShadows !== w ||
            y.numSpotShadows !== R) &&
            ((i.directional.length = m),
            (i.spot.length = _),
            (i.rectArea.length = M),
            (i.point.length = p),
            (i.hemi.length = T),
            (i.directionalShadow.length = E),
            (i.directionalShadowMap.length = E),
            (i.pointShadow.length = w),
            (i.pointShadowMap.length = w),
            (i.spotShadow.length = R),
            (i.spotShadowMap.length = R),
            (i.directionalShadowMatrix.length = E),
            (i.pointShadowMatrix.length = w),
            (i.spotShadowMatrix.length = R),
            (y.directionalLength = m),
            (y.pointLength = p),
            (y.spotLength = _),
            (y.rectAreaLength = M),
            (y.hemiLength = T),
            (y.numDirectionalShadows = E),
            (y.numPointShadows = w),
            (y.numSpotShadows = R),
            (i.version = Um++));
        }
        function c(h, u) {
          let d = 0,
            f = 0,
            g = 0,
            m = 0,
            p = 0;
          const _ = u.matrixWorldInverse;
          for (let M = 0, T = h.length; M < T; M++) {
            const E = h[M];
            if (E.isDirectionalLight) {
              const w = i.directional[d];
              w.direction.setFromMatrixPosition(E.matrixWorld),
                s.setFromMatrixPosition(E.target.matrixWorld),
                w.direction.sub(s),
                w.direction.transformDirection(_),
                d++;
            } else if (E.isSpotLight) {
              const w = i.spot[g];
              w.position.setFromMatrixPosition(E.matrixWorld),
                w.position.applyMatrix4(_),
                w.direction.setFromMatrixPosition(E.matrixWorld),
                s.setFromMatrixPosition(E.target.matrixWorld),
                w.direction.sub(s),
                w.direction.transformDirection(_),
                g++;
            } else if (E.isRectAreaLight) {
              const w = i.rectArea[m];
              w.position.setFromMatrixPosition(E.matrixWorld),
                w.position.applyMatrix4(_),
                a.identity(),
                o.copy(E.matrixWorld),
                o.premultiply(_),
                a.extractRotation(o),
                w.halfWidth.set(E.width * 0.5, 0, 0),
                w.halfHeight.set(0, E.height * 0.5, 0),
                w.halfWidth.applyMatrix4(a),
                w.halfHeight.applyMatrix4(a),
                m++;
            } else if (E.isPointLight) {
              const w = i.point[f];
              w.position.setFromMatrixPosition(E.matrixWorld),
                w.position.applyMatrix4(_),
                f++;
            } else if (E.isHemisphereLight) {
              const w = i.hemi[p];
              w.direction.setFromMatrixPosition(E.matrixWorld),
                w.direction.transformDirection(_),
                p++;
            }
          }
        }
        return { setup: l, setupView: c, state: i };
      }
      function il(r, e) {
        const t = new Hm(r, e),
          n = [],
          i = [];
        function s() {
          (n.length = 0), (i.length = 0);
        }
        function o(u) {
          n.push(u);
        }
        function a(u) {
          i.push(u);
        }
        function l(u) {
          t.setup(n, u);
        }
        function c(u) {
          t.setupView(n, u);
        }
        return {
          init: s,
          state: { lightsArray: n, shadowsArray: i, lights: t },
          setupLights: l,
          setupLightsView: c,
          pushLight: o,
          pushShadow: a,
        };
      }
      function Gm(r, e) {
        let t = new WeakMap();
        function n(s, o = 0) {
          let a;
          return (
            t.has(s) === !1
              ? ((a = new il(r, e)), t.set(s, [a]))
              : o >= t.get(s).length
              ? ((a = new il(r, e)), t.get(s).push(a))
              : (a = t.get(s)[o]),
            a
          );
        }
        function i() {
          t = new WeakMap();
        }
        return { get: n, dispose: i };
      }
      class Po extends et {
        constructor(e) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = Vh),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      Po.prototype.isMeshDepthMaterial = !0;
      class Io extends et {
        constructor(e) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new S()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      Io.prototype.isMeshDistanceMaterial = !0;
      const km = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        Vm = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function sc(r, e, t) {
        let n = new or();
        const i = new $(),
          s = new $(),
          o = new je(),
          a = new Po({ depthPacking: Wh }),
          l = new Io(),
          c = {},
          h = t.maxTextureSize,
          u = { 0: Nt, 1: Mi, 2: On },
          d = new Bt({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new $() },
              radius: { value: 4 },
            },
            vertexShader: km,
            fragmentShader: Vm,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const g = new Ke();
        g.setAttribute(
          "position",
          new tt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const m = new xt(g, d),
          p = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = Bl),
          (this.render = function (E, w, R) {
            if (
              p.enabled === !1 ||
              (p.autoUpdate === !1 && p.needsUpdate === !1) ||
              E.length === 0
            )
              return;
            const P = r.getRenderTarget(),
              y = r.getActiveCubeFace(),
              L = r.getActiveMipmapLevel(),
              N = r.state;
            N.setBlending(vn),
              N.buffers.color.setClear(1, 1, 1, 1),
              N.buffers.depth.setTest(!0),
              N.setScissorTest(!1);
            for (let D = 0, ie = E.length; D < ie; D++) {
              const J = E[D],
                C = J.shadow;
              if (C === void 0) {
                console.warn("THREE.WebGLShadowMap:", J, "has no shadow.");
                continue;
              }
              if (C.autoUpdate === !1 && C.needsUpdate === !1) continue;
              i.copy(C.mapSize);
              const H = C.getFrameExtents();
              if (
                (i.multiply(H),
                s.copy(C.mapSize),
                (i.x > h || i.y > h) &&
                  (i.x > h &&
                    ((s.x = Math.floor(h / H.x)),
                    (i.x = s.x * H.x),
                    (C.mapSize.x = s.x)),
                  i.y > h &&
                    ((s.y = Math.floor(h / H.y)),
                    (i.y = s.y * H.y),
                    (C.mapSize.y = s.y))),
                C.map === null &&
                  !C.isPointLightShadow &&
                  this.type === Ki &&
                  ((C.map = new St(i.x, i.y)),
                  (C.map.texture.name = J.name + ".shadowMap"),
                  (C.mapPass = new St(i.x, i.y)),
                  C.camera.updateProjectionMatrix()),
                C.map === null)
              ) {
                const V = { minFilter: at, magFilter: at, format: At };
                (C.map = new St(i.x, i.y, V)),
                  (C.map.texture.name = J.name + ".shadowMap"),
                  C.camera.updateProjectionMatrix();
              }
              r.setRenderTarget(C.map), r.clear();
              const B = C.getViewportCount();
              for (let V = 0; V < B; V++) {
                const X = C.getViewport(V);
                o.set(s.x * X.x, s.y * X.y, s.x * X.z, s.y * X.w),
                  N.viewport(o),
                  C.updateMatrices(J, V),
                  (n = C.getFrustum()),
                  T(w, R, C.camera, J, this.type);
              }
              !C.isPointLightShadow && this.type === Ki && _(C, R),
                (C.needsUpdate = !1);
            }
            (p.needsUpdate = !1), r.setRenderTarget(P, y, L);
          });
        function _(E, w) {
          const R = e.update(m);
          d.defines.VSM_SAMPLES !== E.blurSamples &&
            ((d.defines.VSM_SAMPLES = E.blurSamples),
            (f.defines.VSM_SAMPLES = E.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            (d.uniforms.shadow_pass.value = E.map.texture),
            (d.uniforms.resolution.value = E.mapSize),
            (d.uniforms.radius.value = E.radius),
            r.setRenderTarget(E.mapPass),
            r.clear(),
            r.renderBufferDirect(w, null, R, d, m, null),
            (f.uniforms.shadow_pass.value = E.mapPass.texture),
            (f.uniforms.resolution.value = E.mapSize),
            (f.uniforms.radius.value = E.radius),
            r.setRenderTarget(E.map),
            r.clear(),
            r.renderBufferDirect(w, null, R, f, m, null);
        }
        function M(E, w, R, P, y, L) {
          let N = null;
          const D =
            R.isPointLight === !0
              ? E.customDistanceMaterial
              : E.customDepthMaterial;
          if (
            (D !== void 0 ? (N = D) : (N = R.isPointLight === !0 ? l : a),
            (r.localClippingEnabled &&
              w.clipShadows === !0 &&
              w.clippingPlanes.length !== 0) ||
              (w.displacementMap && w.displacementScale !== 0) ||
              (w.alphaMap && w.alphaTest > 0))
          ) {
            const ie = N.uuid,
              J = w.uuid;
            let C = c[ie];
            C === void 0 && ((C = {}), (c[ie] = C));
            let H = C[J];
            H === void 0 && ((H = N.clone()), (C[J] = H)), (N = H);
          }
          return (
            (N.visible = w.visible),
            (N.wireframe = w.wireframe),
            L === Ki
              ? (N.side = w.shadowSide !== null ? w.shadowSide : w.side)
              : (N.side = w.shadowSide !== null ? w.shadowSide : u[w.side]),
            (N.alphaMap = w.alphaMap),
            (N.alphaTest = w.alphaTest),
            (N.clipShadows = w.clipShadows),
            (N.clippingPlanes = w.clippingPlanes),
            (N.clipIntersection = w.clipIntersection),
            (N.displacementMap = w.displacementMap),
            (N.displacementScale = w.displacementScale),
            (N.displacementBias = w.displacementBias),
            (N.wireframeLinewidth = w.wireframeLinewidth),
            (N.linewidth = w.linewidth),
            R.isPointLight === !0 &&
              N.isMeshDistanceMaterial === !0 &&
              (N.referencePosition.setFromMatrixPosition(R.matrixWorld),
              (N.nearDistance = P),
              (N.farDistance = y)),
            N
          );
        }
        function T(E, w, R, P, y) {
          if (E.visible === !1) return;
          if (
            E.layers.test(w.layers) &&
            (E.isMesh || E.isLine || E.isPoints) &&
            (E.castShadow || (E.receiveShadow && y === Ki)) &&
            (!E.frustumCulled || n.intersectsObject(E))
          ) {
            E.modelViewMatrix.multiplyMatrices(
              R.matrixWorldInverse,
              E.matrixWorld
            );
            const D = e.update(E),
              ie = E.material;
            if (Array.isArray(ie)) {
              const J = D.groups;
              for (let C = 0, H = J.length; C < H; C++) {
                const B = J[C],
                  V = ie[B.materialIndex];
                if (V && V.visible) {
                  const X = M(E, V, P, R.near, R.far, y);
                  r.renderBufferDirect(R, null, D, X, E, B);
                }
              }
            } else if (ie.visible) {
              const J = M(E, ie, P, R.near, R.far, y);
              r.renderBufferDirect(R, null, D, J, E, null);
            }
          }
          const N = E.children;
          for (let D = 0, ie = N.length; D < ie; D++) T(N[D], w, R, P, y);
        }
      }
      function Wm(r, e, t) {
        const n = t.isWebGL2;
        function i() {
          let A = !1;
          const ae = new je();
          let re = null;
          const we = new je(0, 0, 0, 0);
          return {
            setMask: function (de) {
              re !== de && !A && (r.colorMask(de, de, de, de), (re = de));
            },
            setLocked: function (de) {
              A = de;
            },
            setClear: function (de, Me, ne, Se, We) {
              We === !0 && ((de *= Se), (Me *= Se), (ne *= Se)),
                ae.set(de, Me, ne, Se),
                we.equals(ae) === !1 &&
                  (r.clearColor(de, Me, ne, Se), we.copy(ae));
            },
            reset: function () {
              (A = !1), (re = null), we.set(-1, 0, 0, 0);
            },
          };
        }
        function s() {
          let A = !1,
            ae = null,
            re = null,
            we = null;
          return {
            setTest: function (de) {
              de ? _e(2929) : k(2929);
            },
            setMask: function (de) {
              ae !== de && !A && (r.depthMask(de), (ae = de));
            },
            setFunc: function (de) {
              if (re !== de) {
                if (de)
                  switch (de) {
                    case ch:
                      r.depthFunc(512);
                      break;
                    case hh:
                      r.depthFunc(519);
                      break;
                    case uh:
                      r.depthFunc(513);
                      break;
                    case so:
                      r.depthFunc(515);
                      break;
                    case dh:
                      r.depthFunc(514);
                      break;
                    case fh:
                      r.depthFunc(518);
                      break;
                    case ph:
                      r.depthFunc(516);
                      break;
                    case mh:
                      r.depthFunc(517);
                      break;
                    default:
                      r.depthFunc(515);
                  }
                else r.depthFunc(515);
                re = de;
              }
            },
            setLocked: function (de) {
              A = de;
            },
            setClear: function (de) {
              we !== de && (r.clearDepth(de), (we = de));
            },
            reset: function () {
              (A = !1), (ae = null), (re = null), (we = null);
            },
          };
        }
        function o() {
          let A = !1,
            ae = null,
            re = null,
            we = null,
            de = null,
            Me = null,
            ne = null,
            Se = null,
            We = null;
          return {
            setTest: function (Be) {
              A || (Be ? _e(2960) : k(2960));
            },
            setMask: function (Be) {
              ae !== Be && !A && (r.stencilMask(Be), (ae = Be));
            },
            setFunc: function (Be, Ot, Ut) {
              (re !== Be || we !== Ot || de !== Ut) &&
                (r.stencilFunc(Be, Ot, Ut), (re = Be), (we = Ot), (de = Ut));
            },
            setOp: function (Be, Ot, Ut) {
              (Me !== Be || ne !== Ot || Se !== Ut) &&
                (r.stencilOp(Be, Ot, Ut), (Me = Be), (ne = Ot), (Se = Ut));
            },
            setLocked: function (Be) {
              A = Be;
            },
            setClear: function (Be) {
              We !== Be && (r.clearStencil(Be), (We = Be));
            },
            reset: function () {
              (A = !1),
                (ae = null),
                (re = null),
                (we = null),
                (de = null),
                (Me = null),
                (ne = null),
                (Se = null),
                (We = null);
            },
          };
        }
        const a = new i(),
          l = new s(),
          c = new o();
        let h = {},
          u = {},
          d = new WeakMap(),
          f = [],
          g = null,
          m = !1,
          p = null,
          _ = null,
          M = null,
          T = null,
          E = null,
          w = null,
          R = null,
          P = !1,
          y = null,
          L = null,
          N = null,
          D = null,
          ie = null;
        const J = r.getParameter(35661);
        let C = !1,
          H = 0;
        const B = r.getParameter(7938);
        B.indexOf("WebGL") !== -1
          ? ((H = parseFloat(/^WebGL (\d)/.exec(B)[1])), (C = H >= 1))
          : B.indexOf("OpenGL ES") !== -1 &&
            ((H = parseFloat(/^OpenGL ES (\d)/.exec(B)[1])), (C = H >= 2));
        let V = null,
          X = {};
        const U = r.getParameter(3088),
          W = r.getParameter(2978),
          Q = new je().fromArray(U),
          K = new je().fromArray(W);
        function ee(A, ae, re) {
          const we = new Uint8Array(4),
            de = r.createTexture();
          r.bindTexture(A, de),
            r.texParameteri(A, 10241, 9728),
            r.texParameteri(A, 10240, 9728);
          for (let Me = 0; Me < re; Me++)
            r.texImage2D(ae + Me, 0, 6408, 1, 1, 0, 6408, 5121, we);
          return de;
        }
        const ge = {};
        (ge[3553] = ee(3553, 3553, 1)),
          (ge[34067] = ee(34067, 34069, 6)),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          _e(2929),
          l.setFunc(so),
          te(!1),
          fe(Ko),
          _e(2884),
          Y(vn);
        function _e(A) {
          h[A] !== !0 && (r.enable(A), (h[A] = !0));
        }
        function k(A) {
          h[A] !== !1 && (r.disable(A), (h[A] = !1));
        }
        function He(A, ae) {
          return u[A] !== ae
            ? (r.bindFramebuffer(A, ae),
              (u[A] = ae),
              n &&
                (A === 36009 && (u[36160] = ae),
                A === 36160 && (u[36009] = ae)),
              !0)
            : !1;
        }
        function be(A, ae) {
          let re = f,
            we = !1;
          if (A)
            if (
              ((re = d.get(ae)),
              re === void 0 && ((re = []), d.set(ae, re)),
              A.isWebGLMultipleRenderTargets)
            ) {
              const de = A.texture;
              if (re.length !== de.length || re[0] !== 36064) {
                for (let Me = 0, ne = de.length; Me < ne; Me++)
                  re[Me] = 36064 + Me;
                (re.length = de.length), (we = !0);
              }
            } else re[0] !== 36064 && ((re[0] = 36064), (we = !0));
          else re[0] !== 1029 && ((re[0] = 1029), (we = !0));
          we &&
            (t.isWebGL2
              ? r.drawBuffers(re)
              : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(re));
        }
        function Le(A) {
          return g !== A ? (r.useProgram(A), (g = A), !0) : !1;
        }
        const se = { [pi]: 32774, [$c]: 32778, [Qc]: 32779 };
        if (n) (se[ea] = 32775), (se[ta] = 32776);
        else {
          const A = e.get("EXT_blend_minmax");
          A !== null && ((se[ea] = A.MIN_EXT), (se[ta] = A.MAX_EXT));
        }
        const Ne = {
          [eh]: 0,
          [th]: 1,
          [nh]: 768,
          [Ul]: 770,
          [lh]: 776,
          [oh]: 774,
          [sh]: 772,
          [ih]: 769,
          [zl]: 771,
          [ah]: 775,
          [rh]: 773,
        };
        function Y(A, ae, re, we, de, Me, ne, Se) {
          if (A === vn) {
            m === !0 && (k(3042), (m = !1));
            return;
          }
          if ((m === !1 && (_e(3042), (m = !0)), A !== Zc)) {
            if (A !== p || Se !== P) {
              if (
                ((_ !== pi || E !== pi) &&
                  (r.blendEquation(32774), (_ = pi), (E = pi)),
                Se)
              )
                switch (A) {
                  case yi:
                    r.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case Zo:
                    r.blendFunc(1, 1);
                    break;
                  case $o:
                    r.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case Qo:
                    r.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", A);
                    break;
                }
              else
                switch (A) {
                  case yi:
                    r.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case Zo:
                    r.blendFunc(770, 1);
                    break;
                  case $o:
                    r.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case Qo:
                    r.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", A);
                    break;
                }
              (M = null), (T = null), (w = null), (R = null), (p = A), (P = Se);
            }
            return;
          }
          (de = de || ae),
            (Me = Me || re),
            (ne = ne || we),
            (ae !== _ || de !== E) &&
              (r.blendEquationSeparate(se[ae], se[de]), (_ = ae), (E = de)),
            (re !== M || we !== T || Me !== w || ne !== R) &&
              (r.blendFuncSeparate(Ne[re], Ne[we], Ne[Me], Ne[ne]),
              (M = re),
              (T = we),
              (w = Me),
              (R = ne)),
            (p = A),
            (P = null);
        }
        function j(A, ae) {
          A.side === On ? k(2884) : _e(2884);
          let re = A.side === Nt;
          ae && (re = !re),
            te(re),
            A.blending === yi && A.transparent === !1
              ? Y(vn)
              : Y(
                  A.blending,
                  A.blendEquation,
                  A.blendSrc,
                  A.blendDst,
                  A.blendEquationAlpha,
                  A.blendSrcAlpha,
                  A.blendDstAlpha,
                  A.premultipliedAlpha
                ),
            l.setFunc(A.depthFunc),
            l.setTest(A.depthTest),
            l.setMask(A.depthWrite),
            a.setMask(A.colorWrite);
          const we = A.stencilWrite;
          c.setTest(we),
            we &&
              (c.setMask(A.stencilWriteMask),
              c.setFunc(A.stencilFunc, A.stencilRef, A.stencilFuncMask),
              c.setOp(A.stencilFail, A.stencilZFail, A.stencilZPass)),
            Ee(A.polygonOffset, A.polygonOffsetFactor, A.polygonOffsetUnits),
            A.alphaToCoverage === !0 ? _e(32926) : k(32926);
        }
        function te(A) {
          y !== A && (A ? r.frontFace(2304) : r.frontFace(2305), (y = A));
        }
        function fe(A) {
          A !== Yc
            ? (_e(2884),
              A !== L &&
                (A === Ko
                  ? r.cullFace(1029)
                  : A === Jc
                  ? r.cullFace(1028)
                  : r.cullFace(1032)))
            : k(2884),
            (L = A);
        }
        function ce(A) {
          A !== N && (C && r.lineWidth(A), (N = A));
        }
        function Ee(A, ae, re) {
          A
            ? (_e(32823),
              (D !== ae || ie !== re) &&
                (r.polygonOffset(ae, re), (D = ae), (ie = re)))
            : k(32823);
        }
        function ve(A) {
          A ? _e(3089) : k(3089);
        }
        function xe(A) {
          A === void 0 && (A = 33984 + J - 1),
            V !== A && (r.activeTexture(A), (V = A));
        }
        function Je(A, ae) {
          V === null && xe();
          let re = X[V];
          re === void 0 &&
            ((re = { type: void 0, texture: void 0 }), (X[V] = re)),
            (re.type !== A || re.texture !== ae) &&
              (r.bindTexture(A, ae || ge[A]), (re.type = A), (re.texture = ae));
        }
        function Ye() {
          const A = X[V];
          A !== void 0 &&
            A.type !== void 0 &&
            (r.bindTexture(A.type, null),
            (A.type = void 0),
            (A.texture = void 0));
        }
        function b() {
          try {
            r.compressedTexImage2D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function x() {
          try {
            r.texSubImage2D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function z() {
          try {
            r.texSubImage3D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function Z() {
          try {
            r.compressedTexSubImage2D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function le() {
          try {
            r.texStorage2D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function ue() {
          try {
            r.texStorage3D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function ye() {
          try {
            r.texImage2D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function G() {
          try {
            r.texImage3D.apply(r, arguments);
          } catch (A) {
            console.error("THREE.WebGLState:", A);
          }
        }
        function Re(A) {
          Q.equals(A) === !1 && (r.scissor(A.x, A.y, A.z, A.w), Q.copy(A));
        }
        function Pe(A) {
          K.equals(A) === !1 && (r.viewport(A.x, A.y, A.z, A.w), K.copy(A));
        }
        function pe() {
          r.disable(3042),
            r.disable(2884),
            r.disable(2929),
            r.disable(32823),
            r.disable(3089),
            r.disable(2960),
            r.disable(32926),
            r.blendEquation(32774),
            r.blendFunc(1, 0),
            r.blendFuncSeparate(1, 0, 1, 0),
            r.colorMask(!0, !0, !0, !0),
            r.clearColor(0, 0, 0, 0),
            r.depthMask(!0),
            r.depthFunc(513),
            r.clearDepth(1),
            r.stencilMask(4294967295),
            r.stencilFunc(519, 0, 4294967295),
            r.stencilOp(7680, 7680, 7680),
            r.clearStencil(0),
            r.cullFace(1029),
            r.frontFace(2305),
            r.polygonOffset(0, 0),
            r.activeTexture(33984),
            r.bindFramebuffer(36160, null),
            n === !0 &&
              (r.bindFramebuffer(36009, null), r.bindFramebuffer(36008, null)),
            r.useProgram(null),
            r.lineWidth(1),
            r.scissor(0, 0, r.canvas.width, r.canvas.height),
            r.viewport(0, 0, r.canvas.width, r.canvas.height),
            (h = {}),
            (V = null),
            (X = {}),
            (u = {}),
            (d = new WeakMap()),
            (f = []),
            (g = null),
            (m = !1),
            (p = null),
            (_ = null),
            (M = null),
            (T = null),
            (E = null),
            (w = null),
            (R = null),
            (P = !1),
            (y = null),
            (L = null),
            (N = null),
            (D = null),
            (ie = null),
            Q.set(0, 0, r.canvas.width, r.canvas.height),
            K.set(0, 0, r.canvas.width, r.canvas.height),
            a.reset(),
            l.reset(),
            c.reset();
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: _e,
          disable: k,
          bindFramebuffer: He,
          drawBuffers: be,
          useProgram: Le,
          setBlending: Y,
          setMaterial: j,
          setFlipSided: te,
          setCullFace: fe,
          setLineWidth: ce,
          setPolygonOffset: Ee,
          setScissorTest: ve,
          activeTexture: xe,
          bindTexture: Je,
          unbindTexture: Ye,
          compressedTexImage2D: b,
          texImage2D: ye,
          texImage3D: G,
          texStorage2D: le,
          texStorage3D: ue,
          texSubImage2D: x,
          texSubImage3D: z,
          compressedTexSubImage2D: Z,
          scissor: Re,
          viewport: Pe,
          reset: pe,
        };
      }
      function qm(r, e, t, n, i, s, o) {
        const a = i.isWebGL2,
          l = i.maxTextures,
          c = i.maxCubemapSize,
          h = i.maxTextureSize,
          u = i.maxSamples,
          d = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : null,
          f = /OculusBrowser/g.test(navigator.userAgent),
          g = new WeakMap();
        let m;
        const p = new WeakMap();
        let _ = !1;
        try {
          _ =
            typeof OffscreenCanvas != "undefined" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function M(b, x) {
          return _ ? new OffscreenCanvas(b, x) : as("canvas");
        }
        function T(b, x, z, Z) {
          let le = 1;
          if (
            ((b.width > Z || b.height > Z) &&
              (le = Z / Math.max(b.width, b.height)),
            le < 1 || x === !0)
          )
            if (
              (typeof HTMLImageElement != "undefined" &&
                b instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement != "undefined" &&
                b instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap != "undefined" && b instanceof ImageBitmap)
            ) {
              const ue = x ? tr : Math.floor,
                ye = ue(le * b.width),
                G = ue(le * b.height);
              m === void 0 && (m = M(ye, G));
              const Re = z ? M(ye, G) : m;
              return (
                (Re.width = ye),
                (Re.height = G),
                Re.getContext("2d").drawImage(b, 0, 0, ye, G),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    b.width +
                    "x" +
                    b.height +
                    ") to (" +
                    ye +
                    "x" +
                    G +
                    ")."
                ),
                Re
              );
            } else
              return (
                "data" in b &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      b.width +
                      "x" +
                      b.height +
                      ")."
                  ),
                b
              );
          return b;
        }
        function E(b) {
          return ho(b.width) && ho(b.height);
        }
        function w(b) {
          return a
            ? !1
            : b.wrapS !== Et ||
                b.wrapT !== Et ||
                (b.minFilter !== at && b.minFilter !== pt);
        }
        function R(b, x) {
          return (
            b.generateMipmaps && x && b.minFilter !== at && b.minFilter !== pt
          );
        }
        function P(b) {
          r.generateMipmap(b);
        }
        function y(b, x, z, Z, le = !1) {
          if (a === !1) return x;
          if (b !== null) {
            if (r[b] !== void 0) return r[b];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                b +
                "'"
            );
          }
          let ue = x;
          return (
            x === 6403 &&
              (z === 5126 && (ue = 33326),
              z === 5131 && (ue = 33325),
              z === 5121 && (ue = 33321)),
            x === 33319 &&
              (z === 5126 && (ue = 33328),
              z === 5131 && (ue = 33327),
              z === 5121 && (ue = 33323)),
            x === 6408 &&
              (z === 5126 && (ue = 34836),
              z === 5131 && (ue = 34842),
              z === 5121 && (ue = Z === ze && le === !1 ? 35907 : 32856),
              z === 32819 && (ue = 32854),
              z === 32820 && (ue = 32855)),
            (ue === 33325 ||
              ue === 33326 ||
              ue === 33327 ||
              ue === 33328 ||
              ue === 34842 ||
              ue === 34836) &&
              e.get("EXT_color_buffer_float"),
            ue
          );
        }
        function L(b, x, z) {
          return R(b, z) === !0 ||
            (b.isFramebufferTexture && b.minFilter !== at && b.minFilter !== pt)
            ? Math.log2(Math.max(x.width, x.height)) + 1
            : b.mipmaps !== void 0 && b.mipmaps.length > 0
            ? b.mipmaps.length
            : b.isCompressedTexture && Array.isArray(b.image)
            ? x.mipmaps.length
            : 1;
        }
        function N(b) {
          return b === at || b === ao || b === lo ? 9728 : 9729;
        }
        function D(b) {
          const x = b.target;
          x.removeEventListener("dispose", D),
            J(x),
            x.isVideoTexture && g.delete(x);
        }
        function ie(b) {
          const x = b.target;
          x.removeEventListener("dispose", ie), H(x);
        }
        function J(b) {
          const x = n.get(b);
          if (x.__webglInit === void 0) return;
          const z = b.source,
            Z = p.get(z);
          if (Z) {
            const le = Z[x.__cacheKey];
            le.usedTimes--,
              le.usedTimes === 0 && C(b),
              Object.keys(Z).length === 0 && p.delete(z);
          }
          n.remove(b);
        }
        function C(b) {
          const x = n.get(b);
          r.deleteTexture(x.__webglTexture);
          const z = b.source,
            Z = p.get(z);
          delete Z[x.__cacheKey], o.memory.textures--;
        }
        function H(b) {
          const x = b.texture,
            z = n.get(b),
            Z = n.get(x);
          if (
            (Z.__webglTexture !== void 0 &&
              (r.deleteTexture(Z.__webglTexture), o.memory.textures--),
            b.depthTexture && b.depthTexture.dispose(),
            b.isWebGLCubeRenderTarget)
          )
            for (let le = 0; le < 6; le++)
              r.deleteFramebuffer(z.__webglFramebuffer[le]),
                z.__webglDepthbuffer &&
                  r.deleteRenderbuffer(z.__webglDepthbuffer[le]);
          else
            r.deleteFramebuffer(z.__webglFramebuffer),
              z.__webglDepthbuffer &&
                r.deleteRenderbuffer(z.__webglDepthbuffer),
              z.__webglMultisampledFramebuffer &&
                r.deleteFramebuffer(z.__webglMultisampledFramebuffer),
              z.__webglColorRenderbuffer &&
                r.deleteRenderbuffer(z.__webglColorRenderbuffer),
              z.__webglDepthRenderbuffer &&
                r.deleteRenderbuffer(z.__webglDepthRenderbuffer);
          if (b.isWebGLMultipleRenderTargets)
            for (let le = 0, ue = x.length; le < ue; le++) {
              const ye = n.get(x[le]);
              ye.__webglTexture &&
                (r.deleteTexture(ye.__webglTexture), o.memory.textures--),
                n.remove(x[le]);
            }
          n.remove(x), n.remove(b);
        }
        let B = 0;
        function V() {
          B = 0;
        }
        function X() {
          const b = B;
          return (
            b >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  b +
                  " texture units while this GPU supports only " +
                  l
              ),
            (B += 1),
            b
          );
        }
        function U(b) {
          const x = [];
          return (
            x.push(b.wrapS),
            x.push(b.wrapT),
            x.push(b.magFilter),
            x.push(b.minFilter),
            x.push(b.anisotropy),
            x.push(b.internalFormat),
            x.push(b.format),
            x.push(b.type),
            x.push(b.generateMipmaps),
            x.push(b.premultiplyAlpha),
            x.push(b.flipY),
            x.push(b.unpackAlignment),
            x.push(b.encoding),
            x.join()
          );
        }
        function W(b, x) {
          const z = n.get(b);
          if (
            (b.isVideoTexture && Je(b),
            b.isRenderTargetTexture === !1 &&
              b.version > 0 &&
              z.__version !== b.version)
          ) {
            const Z = b.image;
            if (Z === null)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else if (Z.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              be(z, b, x);
              return;
            }
          }
          t.activeTexture(33984 + x), t.bindTexture(3553, z.__webglTexture);
        }
        function Q(b, x) {
          const z = n.get(b);
          if (b.version > 0 && z.__version !== b.version) {
            be(z, b, x);
            return;
          }
          t.activeTexture(33984 + x), t.bindTexture(35866, z.__webglTexture);
        }
        function K(b, x) {
          const z = n.get(b);
          if (b.version > 0 && z.__version !== b.version) {
            be(z, b, x);
            return;
          }
          t.activeTexture(33984 + x), t.bindTexture(32879, z.__webglTexture);
        }
        function ee(b, x) {
          const z = n.get(b);
          if (b.version > 0 && z.__version !== b.version) {
            Le(z, b, x);
            return;
          }
          t.activeTexture(33984 + x), t.bindTexture(34067, z.__webglTexture);
        }
        const ge = { [Si]: 10497, [Et]: 33071, [$s]: 33648 },
          _e = {
            [at]: 9728,
            [ao]: 9984,
            [lo]: 9986,
            [pt]: 9729,
            [Gl]: 9985,
            [Ci]: 9987,
          };
        function k(b, x, z) {
          if (
            (z
              ? (r.texParameteri(b, 10242, ge[x.wrapS]),
                r.texParameteri(b, 10243, ge[x.wrapT]),
                (b === 32879 || b === 35866) &&
                  r.texParameteri(b, 32882, ge[x.wrapR]),
                r.texParameteri(b, 10240, _e[x.magFilter]),
                r.texParameteri(b, 10241, _e[x.minFilter]))
              : (r.texParameteri(b, 10242, 33071),
                r.texParameteri(b, 10243, 33071),
                (b === 32879 || b === 35866) &&
                  r.texParameteri(b, 32882, 33071),
                (x.wrapS !== Et || x.wrapT !== Et) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                r.texParameteri(b, 10240, N(x.magFilter)),
                r.texParameteri(b, 10241, N(x.minFilter)),
                x.minFilter !== at &&
                  x.minFilter !== pt &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            const Z = e.get("EXT_texture_filter_anisotropic");
            if (
              (x.type === xn && e.has("OES_texture_float_linear") === !1) ||
              (a === !1 &&
                x.type === is &&
                e.has("OES_texture_half_float_linear") === !1)
            )
              return;
            (x.anisotropy > 1 || n.get(x).__currentAnisotropy) &&
              (r.texParameterf(
                b,
                Z.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(x.anisotropy, i.getMaxAnisotropy())
              ),
              (n.get(x).__currentAnisotropy = x.anisotropy));
          }
        }
        function He(b, x) {
          let z = !1;
          b.__webglInit === void 0 &&
            ((b.__webglInit = !0), x.addEventListener("dispose", D));
          const Z = x.source;
          let le = p.get(Z);
          le === void 0 && ((le = {}), p.set(Z, le));
          const ue = U(x);
          if (ue !== b.__cacheKey) {
            le[ue] === void 0 &&
              ((le[ue] = { texture: r.createTexture(), usedTimes: 0 }),
              o.memory.textures++,
              (z = !0)),
              le[ue].usedTimes++;
            const ye = le[b.__cacheKey];
            ye !== void 0 &&
              (le[b.__cacheKey].usedTimes--, ye.usedTimes === 0 && C(x)),
              (b.__cacheKey = ue),
              (b.__webglTexture = le[ue].texture);
          }
          return z;
        }
        function be(b, x, z) {
          let Z = 3553;
          x.isDataArrayTexture && (Z = 35866), x.isData3DTexture && (Z = 32879);
          const le = He(b, x),
            ue = x.source;
          if (
            (t.activeTexture(33984 + z),
            t.bindTexture(Z, b.__webglTexture),
            ue.version !== ue.__currentVersion || le === !0)
          ) {
            r.pixelStorei(37440, x.flipY),
              r.pixelStorei(37441, x.premultiplyAlpha),
              r.pixelStorei(3317, x.unpackAlignment),
              r.pixelStorei(37443, 0);
            const ye = w(x) && E(x.image) === !1;
            let G = T(x.image, ye, !1, h);
            G = Ye(x, G);
            const Re = E(G) || a,
              Pe = s.convert(x.format, x.encoding);
            let pe = s.convert(x.type),
              A = y(x.internalFormat, Pe, pe, x.encoding, x.isVideoTexture);
            k(Z, x, Re);
            let ae;
            const re = x.mipmaps,
              we = a && x.isVideoTexture !== !0,
              de = b.__version === void 0 || le === !0,
              Me = L(x, G, Re);
            if (x.isDepthTexture)
              (A = 6402),
                a
                  ? x.type === xn
                    ? (A = 36012)
                    : x.type === Ks
                    ? (A = 33190)
                    : x.type === vi
                    ? (A = 35056)
                    : (A = 33189)
                  : x.type === xn &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                x.format === Nn &&
                  A === 6402 &&
                  x.type !== ns &&
                  x.type !== Ks &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (x.type = ns),
                  (pe = s.convert(x.type))),
                x.format === Ti &&
                  A === 6402 &&
                  ((A = 34041),
                  x.type !== vi &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (x.type = vi),
                    (pe = s.convert(x.type)))),
                de &&
                  (we
                    ? t.texStorage2D(3553, 1, A, G.width, G.height)
                    : t.texImage2D(
                        3553,
                        0,
                        A,
                        G.width,
                        G.height,
                        0,
                        Pe,
                        pe,
                        null
                      ));
            else if (x.isDataTexture)
              if (re.length > 0 && Re) {
                we &&
                  de &&
                  t.texStorage2D(3553, Me, A, re[0].width, re[0].height);
                for (let ne = 0, Se = re.length; ne < Se; ne++)
                  (ae = re[ne]),
                    we
                      ? t.texSubImage2D(
                          3553,
                          ne,
                          0,
                          0,
                          ae.width,
                          ae.height,
                          Pe,
                          pe,
                          ae.data
                        )
                      : t.texImage2D(
                          3553,
                          ne,
                          A,
                          ae.width,
                          ae.height,
                          0,
                          Pe,
                          pe,
                          ae.data
                        );
                x.generateMipmaps = !1;
              } else
                we
                  ? (de && t.texStorage2D(3553, Me, A, G.width, G.height),
                    t.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      G.width,
                      G.height,
                      Pe,
                      pe,
                      G.data
                    ))
                  : t.texImage2D(
                      3553,
                      0,
                      A,
                      G.width,
                      G.height,
                      0,
                      Pe,
                      pe,
                      G.data
                    );
            else if (x.isCompressedTexture) {
              we &&
                de &&
                t.texStorage2D(3553, Me, A, re[0].width, re[0].height);
              for (let ne = 0, Se = re.length; ne < Se; ne++)
                (ae = re[ne]),
                  x.format !== At
                    ? Pe !== null
                      ? we
                        ? t.compressedTexSubImage2D(
                            3553,
                            ne,
                            0,
                            0,
                            ae.width,
                            ae.height,
                            Pe,
                            ae.data
                          )
                        : t.compressedTexImage2D(
                            3553,
                            ne,
                            A,
                            ae.width,
                            ae.height,
                            0,
                            ae.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : we
                    ? t.texSubImage2D(
                        3553,
                        ne,
                        0,
                        0,
                        ae.width,
                        ae.height,
                        Pe,
                        pe,
                        ae.data
                      )
                    : t.texImage2D(
                        3553,
                        ne,
                        A,
                        ae.width,
                        ae.height,
                        0,
                        Pe,
                        pe,
                        ae.data
                      );
            } else if (x.isDataArrayTexture)
              we
                ? (de &&
                    t.texStorage3D(35866, Me, A, G.width, G.height, G.depth),
                  t.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    G.width,
                    G.height,
                    G.depth,
                    Pe,
                    pe,
                    G.data
                  ))
                : t.texImage3D(
                    35866,
                    0,
                    A,
                    G.width,
                    G.height,
                    G.depth,
                    0,
                    Pe,
                    pe,
                    G.data
                  );
            else if (x.isData3DTexture)
              we
                ? (de &&
                    t.texStorage3D(32879, Me, A, G.width, G.height, G.depth),
                  t.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    G.width,
                    G.height,
                    G.depth,
                    Pe,
                    pe,
                    G.data
                  ))
                : t.texImage3D(
                    32879,
                    0,
                    A,
                    G.width,
                    G.height,
                    G.depth,
                    0,
                    Pe,
                    pe,
                    G.data
                  );
            else if (x.isFramebufferTexture) {
              if (de)
                if (we) t.texStorage2D(3553, Me, A, G.width, G.height);
                else {
                  let ne = G.width,
                    Se = G.height;
                  for (let We = 0; We < Me; We++)
                    t.texImage2D(3553, We, A, ne, Se, 0, Pe, pe, null),
                      (ne >>= 1),
                      (Se >>= 1);
                }
            } else if (re.length > 0 && Re) {
              we &&
                de &&
                t.texStorage2D(3553, Me, A, re[0].width, re[0].height);
              for (let ne = 0, Se = re.length; ne < Se; ne++)
                (ae = re[ne]),
                  we
                    ? t.texSubImage2D(3553, ne, 0, 0, Pe, pe, ae)
                    : t.texImage2D(3553, ne, A, Pe, pe, ae);
              x.generateMipmaps = !1;
            } else
              we
                ? (de && t.texStorage2D(3553, Me, A, G.width, G.height),
                  t.texSubImage2D(3553, 0, 0, 0, Pe, pe, G))
                : t.texImage2D(3553, 0, A, Pe, pe, G);
            R(x, Re) && P(Z),
              (ue.__currentVersion = ue.version),
              x.onUpdate && x.onUpdate(x);
          }
          b.__version = x.version;
        }
        function Le(b, x, z) {
          if (x.image.length !== 6) return;
          const Z = He(b, x),
            le = x.source;
          if (
            (t.activeTexture(33984 + z),
            t.bindTexture(34067, b.__webglTexture),
            le.version !== le.__currentVersion || Z === !0)
          ) {
            r.pixelStorei(37440, x.flipY),
              r.pixelStorei(37441, x.premultiplyAlpha),
              r.pixelStorei(3317, x.unpackAlignment),
              r.pixelStorei(37443, 0);
            const ue = x.isCompressedTexture || x.image[0].isCompressedTexture,
              ye = x.image[0] && x.image[0].isDataTexture,
              G = [];
            for (let ne = 0; ne < 6; ne++)
              !ue && !ye
                ? (G[ne] = T(x.image[ne], !1, !0, c))
                : (G[ne] = ye ? x.image[ne].image : x.image[ne]),
                (G[ne] = Ye(x, G[ne]));
            const Re = G[0],
              Pe = E(Re) || a,
              pe = s.convert(x.format, x.encoding),
              A = s.convert(x.type),
              ae = y(x.internalFormat, pe, A, x.encoding),
              re = a && x.isVideoTexture !== !0,
              we = b.__version === void 0;
            let de = L(x, Re, Pe);
            k(34067, x, Pe);
            let Me;
            if (ue) {
              re && we && t.texStorage2D(34067, de, ae, Re.width, Re.height);
              for (let ne = 0; ne < 6; ne++) {
                Me = G[ne].mipmaps;
                for (let Se = 0; Se < Me.length; Se++) {
                  const We = Me[Se];
                  x.format !== At
                    ? pe !== null
                      ? re
                        ? t.compressedTexSubImage2D(
                            34069 + ne,
                            Se,
                            0,
                            0,
                            We.width,
                            We.height,
                            pe,
                            We.data
                          )
                        : t.compressedTexImage2D(
                            34069 + ne,
                            Se,
                            ae,
                            We.width,
                            We.height,
                            0,
                            We.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : re
                    ? t.texSubImage2D(
                        34069 + ne,
                        Se,
                        0,
                        0,
                        We.width,
                        We.height,
                        pe,
                        A,
                        We.data
                      )
                    : t.texImage2D(
                        34069 + ne,
                        Se,
                        ae,
                        We.width,
                        We.height,
                        0,
                        pe,
                        A,
                        We.data
                      );
                }
              }
            } else {
              (Me = x.mipmaps),
                re &&
                  we &&
                  (Me.length > 0 && de++,
                  t.texStorage2D(34067, de, ae, G[0].width, G[0].height));
              for (let ne = 0; ne < 6; ne++)
                if (ye) {
                  re
                    ? t.texSubImage2D(
                        34069 + ne,
                        0,
                        0,
                        0,
                        G[ne].width,
                        G[ne].height,
                        pe,
                        A,
                        G[ne].data
                      )
                    : t.texImage2D(
                        34069 + ne,
                        0,
                        ae,
                        G[ne].width,
                        G[ne].height,
                        0,
                        pe,
                        A,
                        G[ne].data
                      );
                  for (let Se = 0; Se < Me.length; Se++) {
                    const Be = Me[Se].image[ne].image;
                    re
                      ? t.texSubImage2D(
                          34069 + ne,
                          Se + 1,
                          0,
                          0,
                          Be.width,
                          Be.height,
                          pe,
                          A,
                          Be.data
                        )
                      : t.texImage2D(
                          34069 + ne,
                          Se + 1,
                          ae,
                          Be.width,
                          Be.height,
                          0,
                          pe,
                          A,
                          Be.data
                        );
                  }
                } else {
                  re
                    ? t.texSubImage2D(34069 + ne, 0, 0, 0, pe, A, G[ne])
                    : t.texImage2D(34069 + ne, 0, ae, pe, A, G[ne]);
                  for (let Se = 0; Se < Me.length; Se++) {
                    const We = Me[Se];
                    re
                      ? t.texSubImage2D(
                          34069 + ne,
                          Se + 1,
                          0,
                          0,
                          pe,
                          A,
                          We.image[ne]
                        )
                      : t.texImage2D(
                          34069 + ne,
                          Se + 1,
                          ae,
                          pe,
                          A,
                          We.image[ne]
                        );
                  }
                }
            }
            R(x, Pe) && P(34067),
              (le.__currentVersion = le.version),
              x.onUpdate && x.onUpdate(x);
          }
          b.__version = x.version;
        }
        function se(b, x, z, Z, le) {
          const ue = s.convert(z.format, z.encoding),
            ye = s.convert(z.type),
            G = y(z.internalFormat, ue, ye, z.encoding);
          n.get(x).__hasExternalTextures ||
            (le === 32879 || le === 35866
              ? t.texImage3D(
                  le,
                  0,
                  G,
                  x.width,
                  x.height,
                  x.depth,
                  0,
                  ue,
                  ye,
                  null
                )
              : t.texImage2D(le, 0, G, x.width, x.height, 0, ue, ye, null)),
            t.bindFramebuffer(36160, b),
            xe(x)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  Z,
                  le,
                  n.get(z).__webglTexture,
                  0,
                  ve(x)
                )
              : r.framebufferTexture2D(
                  36160,
                  Z,
                  le,
                  n.get(z).__webglTexture,
                  0
                ),
            t.bindFramebuffer(36160, null);
        }
        function Ne(b, x, z) {
          if (
            (r.bindRenderbuffer(36161, b), x.depthBuffer && !x.stencilBuffer)
          ) {
            let Z = 33189;
            if (z || xe(x)) {
              const le = x.depthTexture;
              le &&
                le.isDepthTexture &&
                (le.type === xn ? (Z = 36012) : le.type === Ks && (Z = 33190));
              const ue = ve(x);
              xe(x)
                ? d.renderbufferStorageMultisampleEXT(
                    36161,
                    ue,
                    Z,
                    x.width,
                    x.height
                  )
                : r.renderbufferStorageMultisample(
                    36161,
                    ue,
                    Z,
                    x.width,
                    x.height
                  );
            } else r.renderbufferStorage(36161, Z, x.width, x.height);
            r.framebufferRenderbuffer(36160, 36096, 36161, b);
          } else if (x.depthBuffer && x.stencilBuffer) {
            const Z = ve(x);
            z && xe(x) === !1
              ? r.renderbufferStorageMultisample(
                  36161,
                  Z,
                  35056,
                  x.width,
                  x.height
                )
              : xe(x)
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  Z,
                  35056,
                  x.width,
                  x.height
                )
              : r.renderbufferStorage(36161, 34041, x.width, x.height),
              r.framebufferRenderbuffer(36160, 33306, 36161, b);
          } else {
            const Z =
                x.isWebGLMultipleRenderTargets === !0
                  ? x.texture[0]
                  : x.texture,
              le = s.convert(Z.format, Z.encoding),
              ue = s.convert(Z.type),
              ye = y(Z.internalFormat, le, ue, Z.encoding),
              G = ve(x);
            z && xe(x) === !1
              ? r.renderbufferStorageMultisample(
                  36161,
                  G,
                  ye,
                  x.width,
                  x.height
                )
              : xe(x)
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  G,
                  ye,
                  x.width,
                  x.height
                )
              : r.renderbufferStorage(36161, ye, x.width, x.height);
          }
          r.bindRenderbuffer(36161, null);
        }
        function Y(b, x) {
          if (x && x.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(36160, b),
            !(x.depthTexture && x.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(x.depthTexture).__webglTexture ||
            x.depthTexture.image.width !== x.width ||
            x.depthTexture.image.height !== x.height) &&
            ((x.depthTexture.image.width = x.width),
            (x.depthTexture.image.height = x.height),
            (x.depthTexture.needsUpdate = !0)),
            W(x.depthTexture, 0);
          const Z = n.get(x.depthTexture).__webglTexture,
            le = ve(x);
          if (x.depthTexture.format === Nn)
            xe(x)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  36096,
                  3553,
                  Z,
                  0,
                  le
                )
              : r.framebufferTexture2D(36160, 36096, 3553, Z, 0);
          else if (x.depthTexture.format === Ti)
            xe(x)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  33306,
                  3553,
                  Z,
                  0,
                  le
                )
              : r.framebufferTexture2D(36160, 33306, 3553, Z, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function j(b) {
          const x = n.get(b),
            z = b.isWebGLCubeRenderTarget === !0;
          if (b.depthTexture && !x.__autoAllocateDepthBuffer) {
            if (z)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            Y(x.__webglFramebuffer, b);
          } else if (z) {
            x.__webglDepthbuffer = [];
            for (let Z = 0; Z < 6; Z++)
              t.bindFramebuffer(36160, x.__webglFramebuffer[Z]),
                (x.__webglDepthbuffer[Z] = r.createRenderbuffer()),
                Ne(x.__webglDepthbuffer[Z], b, !1);
          } else
            t.bindFramebuffer(36160, x.__webglFramebuffer),
              (x.__webglDepthbuffer = r.createRenderbuffer()),
              Ne(x.__webglDepthbuffer, b, !1);
          t.bindFramebuffer(36160, null);
        }
        function te(b, x, z) {
          const Z = n.get(b);
          x !== void 0 && se(Z.__webglFramebuffer, b, b.texture, 36064, 3553),
            z !== void 0 && j(b);
        }
        function fe(b) {
          const x = b.texture,
            z = n.get(b),
            Z = n.get(x);
          b.addEventListener("dispose", ie),
            b.isWebGLMultipleRenderTargets !== !0 &&
              (Z.__webglTexture === void 0 &&
                (Z.__webglTexture = r.createTexture()),
              (Z.__version = x.version),
              o.memory.textures++);
          const le = b.isWebGLCubeRenderTarget === !0,
            ue = b.isWebGLMultipleRenderTargets === !0,
            ye = E(b) || a;
          if (le) {
            z.__webglFramebuffer = [];
            for (let G = 0; G < 6; G++)
              z.__webglFramebuffer[G] = r.createFramebuffer();
          } else if (((z.__webglFramebuffer = r.createFramebuffer()), ue))
            if (i.drawBuffers) {
              const G = b.texture;
              for (let Re = 0, Pe = G.length; Re < Pe; Re++) {
                const pe = n.get(G[Re]);
                pe.__webglTexture === void 0 &&
                  ((pe.__webglTexture = r.createTexture()),
                  o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (a && b.samples > 0 && xe(b) === !1) {
            (z.__webglMultisampledFramebuffer = r.createFramebuffer()),
              (z.__webglColorRenderbuffer = r.createRenderbuffer()),
              r.bindRenderbuffer(36161, z.__webglColorRenderbuffer);
            const G = s.convert(x.format, x.encoding),
              Re = s.convert(x.type),
              Pe = y(x.internalFormat, G, Re, x.encoding),
              pe = ve(b);
            r.renderbufferStorageMultisample(36161, pe, Pe, b.width, b.height),
              t.bindFramebuffer(36160, z.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                36160,
                36064,
                36161,
                z.__webglColorRenderbuffer
              ),
              r.bindRenderbuffer(36161, null),
              b.depthBuffer &&
                ((z.__webglDepthRenderbuffer = r.createRenderbuffer()),
                Ne(z.__webglDepthRenderbuffer, b, !0)),
              t.bindFramebuffer(36160, null);
          }
          if (le) {
            t.bindTexture(34067, Z.__webglTexture), k(34067, x, ye);
            for (let G = 0; G < 6; G++)
              se(z.__webglFramebuffer[G], b, x, 36064, 34069 + G);
            R(x, ye) && P(34067), t.unbindTexture();
          } else if (ue) {
            const G = b.texture;
            for (let Re = 0, Pe = G.length; Re < Pe; Re++) {
              const pe = G[Re],
                A = n.get(pe);
              t.bindTexture(3553, A.__webglTexture),
                k(3553, pe, ye),
                se(z.__webglFramebuffer, b, pe, 36064 + Re, 3553),
                R(pe, ye) && P(3553);
            }
            t.unbindTexture();
          } else {
            let G = 3553;
            (b.isWebGL3DRenderTarget || b.isWebGLArrayRenderTarget) &&
              (a
                ? (G = b.isWebGL3DRenderTarget ? 32879 : 35866)
                : console.error(
                    "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                  )),
              t.bindTexture(G, Z.__webglTexture),
              k(G, x, ye),
              se(z.__webglFramebuffer, b, x, 36064, G),
              R(x, ye) && P(G),
              t.unbindTexture();
          }
          b.depthBuffer && j(b);
        }
        function ce(b) {
          const x = E(b) || a,
            z = b.isWebGLMultipleRenderTargets === !0 ? b.texture : [b.texture];
          for (let Z = 0, le = z.length; Z < le; Z++) {
            const ue = z[Z];
            if (R(ue, x)) {
              const ye = b.isWebGLCubeRenderTarget ? 34067 : 3553,
                G = n.get(ue).__webglTexture;
              t.bindTexture(ye, G), P(ye), t.unbindTexture();
            }
          }
        }
        function Ee(b) {
          if (a && b.samples > 0 && xe(b) === !1) {
            const x = b.width,
              z = b.height;
            let Z = 16384;
            const le = [36064],
              ue = b.stencilBuffer ? 33306 : 36096;
            b.depthBuffer && le.push(ue);
            const ye = n.get(b),
              G =
                ye.__ignoreDepthValues !== void 0 ? ye.__ignoreDepthValues : !1;
            G === !1 &&
              (b.depthBuffer && (Z |= 256), b.stencilBuffer && (Z |= 1024)),
              t.bindFramebuffer(36008, ye.__webglMultisampledFramebuffer),
              t.bindFramebuffer(36009, ye.__webglFramebuffer),
              G === !0 &&
                (r.invalidateFramebuffer(36008, [ue]),
                r.invalidateFramebuffer(36009, [ue])),
              r.blitFramebuffer(0, 0, x, z, 0, 0, x, z, Z, 9728),
              f && r.invalidateFramebuffer(36008, le),
              t.bindFramebuffer(36008, null),
              t.bindFramebuffer(36009, ye.__webglMultisampledFramebuffer);
          }
        }
        function ve(b) {
          return Math.min(u, b.samples);
        }
        function xe(b) {
          const x = n.get(b);
          return (
            a &&
            b.samples > 0 &&
            e.has("WEBGL_multisampled_render_to_texture") === !0 &&
            x.__useRenderToTexture !== !1
          );
        }
        function Je(b) {
          const x = o.render.frame;
          g.get(b) !== x && (g.set(b, x), b.update());
        }
        function Ye(b, x) {
          const z = b.encoding,
            Z = b.format,
            le = b.type;
          return (
            b.isCompressedTexture === !0 ||
              b.isVideoTexture === !0 ||
              b.format === co ||
              (z !== Sn &&
                (z === ze
                  ? a === !1
                    ? e.has("EXT_sRGB") === !0 && Z === At
                      ? ((b.format = co),
                        (b.minFilter = pt),
                        (b.generateMipmaps = !1))
                      : (x = Vn.sRGBToLinear(x))
                    : (Z !== At || le !== Un) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      z
                    ))),
            x
          );
        }
        (this.allocateTextureUnit = X),
          (this.resetTextureUnits = V),
          (this.setTexture2D = W),
          (this.setTexture2DArray = Q),
          (this.setTexture3D = K),
          (this.setTextureCube = ee),
          (this.rebindTextures = te),
          (this.setupRenderTarget = fe),
          (this.updateRenderTargetMipmap = ce),
          (this.updateMultisampleRenderTarget = Ee),
          (this.setupDepthRenderbuffer = j),
          (this.setupFrameBufferTexture = se),
          (this.useMultisampledRTT = xe);
      }
      function Xm(r, e, t) {
        const n = t.isWebGL2;
        function i(s, o = null) {
          let a;
          if (s === Un) return 5121;
          if (s === Eh) return 32819;
          if (s === Ah) return 32820;
          if (s === wh) return 5120;
          if (s === Sh) return 5122;
          if (s === ns) return 5123;
          if (s === Th) return 5124;
          if (s === Ks) return 5125;
          if (s === xn) return 5126;
          if (s === is)
            return n
              ? 5131
              : ((a = e.get("OES_texture_half_float")),
                a !== null ? a.HALF_FLOAT_OES : null);
          if (s === Rh) return 6406;
          if (s === At) return 6408;
          if (s === Ch) return 6409;
          if (s === Ph) return 6410;
          if (s === Nn) return 6402;
          if (s === Ti) return 34041;
          if (s === Ih) return 6403;
          if (s === Lh)
            return (
              console.warn(
                "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
              ),
              6408
            );
          if (s === co)
            return (
              (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null
            );
          if (s === Dh) return 36244;
          if (s === Fh) return 33319;
          if (s === Nh) return 33320;
          if (s === Bh) return 36249;
          if (s === xr || s === yr || s === vr || s === Mr)
            if (o === ze)
              if (
                ((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)
              ) {
                if (s === xr) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (s === yr) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (s === vr) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (s === Mr) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else return null;
            else if (
              ((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)
            ) {
              if (s === xr) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (s === yr) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (s === vr) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (s === Mr) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (s === na || s === ia || s === sa || s === ra)
            if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
              if (s === na) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (s === ia) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (s === sa) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (s === ra) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (s === Oh)
            return (
              (a = e.get("WEBGL_compressed_texture_etc1")),
              a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (s === oa || s === aa)
            if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
              if (s === oa)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ETC2
                  : a.COMPRESSED_RGB8_ETC2;
              if (s === aa)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : a.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
          if (
            s === la ||
            s === ca ||
            s === ha ||
            s === ua ||
            s === da ||
            s === fa ||
            s === pa ||
            s === ma ||
            s === ga ||
            s === _a ||
            s === xa ||
            s === ya ||
            s === va ||
            s === Ma
          )
            if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
              if (s === la)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (s === ca)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (s === ha)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (s === ua)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (s === da)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (s === fa)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (s === pa)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (s === ma)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (s === ga)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (s === _a)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (s === xa)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (s === ya)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (s === va)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (s === Ma)
                return o === ze
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
          if (s === ba)
            if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
              if (s === ba)
                return o === ze
                  ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else return null;
          return s === vi
            ? n
              ? 34042
              : ((a = e.get("WEBGL_depth_texture")),
                a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
            : r[s] !== void 0
            ? r[s]
            : null;
        }
        return { convert: i };
      }
      class rc extends mt {
        constructor(e = []) {
          super(), (this.cameras = e);
        }
      }
      rc.prototype.isArrayCamera = !0;
      class yn extends Ve {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      yn.prototype.isGroup = !0;
      const jm = { type: "move" };
      class Jr {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new yn()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new yn()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new S()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new S())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new yn()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new S()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new S())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            s = null,
            o = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred")
            if (
              (a !== null &&
                ((i = t.getPose(e.targetRaySpace, n)),
                i !== null &&
                  (a.matrix.fromArray(i.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  i.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(i.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(i.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(jm))),
              c && e.hand)
            ) {
              o = !0;
              for (const m of e.hand.values()) {
                const p = t.getJointPose(m, n);
                if (c.joints[m.jointName] === void 0) {
                  const M = new yn();
                  (M.matrixAutoUpdate = !1),
                    (M.visible = !1),
                    (c.joints[m.jointName] = M),
                    c.add(M);
                }
                const _ = c.joints[m.jointName];
                p !== null &&
                  (_.matrix.fromArray(p.transform.matrix),
                  _.matrix.decompose(_.position, _.rotation, _.scale),
                  (_.jointRadius = p.radius)),
                  (_.visible = p !== null);
              }
              const h = c.joints["index-finger-tip"],
                u = c.joints["thumb-tip"],
                d = h.position.distanceTo(u.position),
                f = 0.02,
                g = 0.005;
              c.inputState.pinching && d > f + g
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  d <= f - g &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              l !== null &&
                e.gripSpace &&
                ((s = t.getPose(e.gripSpace, n)),
                s !== null &&
                  (l.matrix.fromArray(s.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  s.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(s.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  s.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(s.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
          return (
            a !== null && (a.visible = i !== null),
            l !== null && (l.visible = s !== null),
            c !== null && (c.visible = o !== null),
            this
          );
        }
      }
      class oc extends rt {
        constructor(e, t, n, i, s, o, a, l, c, h) {
          if (((h = h !== void 0 ? h : Nn), h !== Nn && h !== Ti))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && h === Nn && (n = ns),
            n === void 0 && h === Ti && (n = vi),
            super(null, i, s, o, a, l, h, n, c),
            (this.image = { width: e, height: t }),
            (this.magFilter = a !== void 0 ? a : at),
            (this.minFilter = l !== void 0 ? l : at),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      oc.prototype.isDepthTexture = !0;
      class Ym extends kn {
        constructor(e, t) {
          super();
          const n = this;
          let i = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = null,
            c = null,
            h = null,
            u = null,
            d = null,
            f = null;
          const g = t.getContextAttributes();
          let m = null,
            p = null;
          const _ = [],
            M = new Map(),
            T = new mt();
          T.layers.enable(1), (T.viewport = new je());
          const E = new mt();
          E.layers.enable(2), (E.viewport = new je());
          const w = [T, E],
            R = new rc();
          R.layers.enable(1), R.layers.enable(2);
          let P = null,
            y = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (U) {
              let W = _[U];
              return (
                W === void 0 && ((W = new Jr()), (_[U] = W)),
                W.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (U) {
              let W = _[U];
              return (
                W === void 0 && ((W = new Jr()), (_[U] = W)), W.getGripSpace()
              );
            }),
            (this.getHand = function (U) {
              let W = _[U];
              return (
                W === void 0 && ((W = new Jr()), (_[U] = W)), W.getHandSpace()
              );
            });
          function L(U) {
            const W = M.get(U.inputSource);
            W && W.dispatchEvent({ type: U.type, data: U.inputSource });
          }
          function N() {
            M.forEach(function (U, W) {
              U.disconnect(W);
            }),
              M.clear(),
              (P = null),
              (y = null),
              e.setRenderTarget(m),
              (d = null),
              (u = null),
              (h = null),
              (i = null),
              (p = null),
              X.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (U) {
            (s = U),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (U) {
              (a = U),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return l || o;
            }),
            (this.setReferenceSpace = function (U) {
              l = U;
            }),
            (this.getBaseLayer = function () {
              return u !== null ? u : d;
            }),
            (this.getBinding = function () {
              return h;
            }),
            (this.getFrame = function () {
              return f;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (U) {
              if (((i = U), i !== null)) {
                if (
                  ((m = e.getRenderTarget()),
                  i.addEventListener("select", L),
                  i.addEventListener("selectstart", L),
                  i.addEventListener("selectend", L),
                  i.addEventListener("squeeze", L),
                  i.addEventListener("squeezestart", L),
                  i.addEventListener("squeezeend", L),
                  i.addEventListener("end", N),
                  i.addEventListener("inputsourceschange", D),
                  g.xrCompatible !== !0 && (await t.makeXRCompatible()),
                  i.renderState.layers === void 0 ||
                    e.capabilities.isWebGL2 === !1)
                ) {
                  const W = {
                    antialias:
                      i.renderState.layers === void 0 ? g.antialias : !0,
                    alpha: g.alpha,
                    depth: g.depth,
                    stencil: g.stencil,
                    framebufferScaleFactor: s,
                  };
                  (d = new XRWebGLLayer(i, t, W)),
                    i.updateRenderState({ baseLayer: d }),
                    (p = new St(d.framebufferWidth, d.framebufferHeight, {
                      format: At,
                      type: Un,
                      encoding: e.outputEncoding,
                    }));
                } else {
                  let W = null,
                    Q = null,
                    K = null;
                  g.depth &&
                    ((K = g.stencil ? 35056 : 33190),
                    (W = g.stencil ? Ti : Nn),
                    (Q = g.stencil ? vi : ns));
                  const ee = {
                    colorFormat: e.outputEncoding === ze ? 35907 : 32856,
                    depthFormat: K,
                    scaleFactor: s,
                  };
                  (h = new XRWebGLBinding(i, t)),
                    (u = h.createProjectionLayer(ee)),
                    i.updateRenderState({ layers: [u] }),
                    (p = new St(u.textureWidth, u.textureHeight, {
                      format: At,
                      type: Un,
                      depthTexture: new oc(
                        u.textureWidth,
                        u.textureHeight,
                        Q,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        W
                      ),
                      stencilBuffer: g.stencil,
                      encoding: e.outputEncoding,
                      samples: g.antialias ? 4 : 0,
                    }));
                  const ge = e.properties.get(p);
                  ge.__ignoreDepthValues = u.ignoreDepthValues;
                }
                (p.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (o = await i.requestReferenceSpace(a)),
                  X.setContext(i),
                  X.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          function D(U) {
            const W = i.inputSources;
            for (let Q = 0; Q < W.length; Q++) {
              const K = W[Q].handedness === "right" ? 1 : 0;
              M.set(W[Q], _[K]);
            }
            for (let Q = 0; Q < U.removed.length; Q++) {
              const K = U.removed[Q],
                ee = M.get(K);
              ee &&
                (ee.dispatchEvent({ type: "disconnected", data: K }),
                M.delete(K));
            }
            for (let Q = 0; Q < U.added.length; Q++) {
              const K = U.added[Q],
                ee = M.get(K);
              ee && ee.dispatchEvent({ type: "connected", data: K });
            }
          }
          const ie = new S(),
            J = new S();
          function C(U, W, Q) {
            ie.setFromMatrixPosition(W.matrixWorld),
              J.setFromMatrixPosition(Q.matrixWorld);
            const K = ie.distanceTo(J),
              ee = W.projectionMatrix.elements,
              ge = Q.projectionMatrix.elements,
              _e = ee[14] / (ee[10] - 1),
              k = ee[14] / (ee[10] + 1),
              He = (ee[9] + 1) / ee[5],
              be = (ee[9] - 1) / ee[5],
              Le = (ee[8] - 1) / ee[0],
              se = (ge[8] + 1) / ge[0],
              Ne = _e * Le,
              Y = _e * se,
              j = K / (-Le + se),
              te = j * -Le;
            W.matrixWorld.decompose(U.position, U.quaternion, U.scale),
              U.translateX(te),
              U.translateZ(j),
              U.matrixWorld.compose(U.position, U.quaternion, U.scale),
              U.matrixWorldInverse.copy(U.matrixWorld).invert();
            const fe = _e + j,
              ce = k + j,
              Ee = Ne - te,
              ve = Y + (K - te),
              xe = ((He * k) / ce) * fe,
              Je = ((be * k) / ce) * fe;
            U.projectionMatrix.makePerspective(Ee, ve, xe, Je, fe, ce);
          }
          function H(U, W) {
            W === null
              ? U.matrixWorld.copy(U.matrix)
              : U.matrixWorld.multiplyMatrices(W.matrixWorld, U.matrix),
              U.matrixWorldInverse.copy(U.matrixWorld).invert();
          }
          (this.updateCamera = function (U) {
            if (i === null) return;
            (R.near = E.near = T.near = U.near),
              (R.far = E.far = T.far = U.far),
              (P !== R.near || y !== R.far) &&
                (i.updateRenderState({ depthNear: R.near, depthFar: R.far }),
                (P = R.near),
                (y = R.far));
            const W = U.parent,
              Q = R.cameras;
            H(R, W);
            for (let ee = 0; ee < Q.length; ee++) H(Q[ee], W);
            R.matrixWorld.decompose(R.position, R.quaternion, R.scale),
              U.position.copy(R.position),
              U.quaternion.copy(R.quaternion),
              U.scale.copy(R.scale),
              U.matrix.copy(R.matrix),
              U.matrixWorld.copy(R.matrixWorld);
            const K = U.children;
            for (let ee = 0, ge = K.length; ee < ge; ee++)
              K[ee].updateMatrixWorld(!0);
            Q.length === 2
              ? C(R, T, E)
              : R.projectionMatrix.copy(T.projectionMatrix);
          }),
            (this.getCamera = function () {
              return R;
            }),
            (this.getFoveation = function () {
              if (u !== null) return u.fixedFoveation;
              if (d !== null) return d.fixedFoveation;
            }),
            (this.setFoveation = function (U) {
              u !== null && (u.fixedFoveation = U),
                d !== null &&
                  d.fixedFoveation !== void 0 &&
                  (d.fixedFoveation = U);
            });
          let B = null;
          function V(U, W) {
            if (((c = W.getViewerPose(l || o)), (f = W), c !== null)) {
              const K = c.views;
              d !== null &&
                (e.setRenderTargetFramebuffer(p, d.framebuffer),
                e.setRenderTarget(p));
              let ee = !1;
              K.length !== R.cameras.length &&
                ((R.cameras.length = 0), (ee = !0));
              for (let ge = 0; ge < K.length; ge++) {
                const _e = K[ge];
                let k = null;
                if (d !== null) k = d.getViewport(_e);
                else {
                  const be = h.getViewSubImage(u, _e);
                  (k = be.viewport),
                    ge === 0 &&
                      (e.setRenderTargetTextures(
                        p,
                        be.colorTexture,
                        u.ignoreDepthValues ? void 0 : be.depthStencilTexture
                      ),
                      e.setRenderTarget(p));
                }
                const He = w[ge];
                He.matrix.fromArray(_e.transform.matrix),
                  He.projectionMatrix.fromArray(_e.projectionMatrix),
                  He.viewport.set(k.x, k.y, k.width, k.height),
                  ge === 0 && R.matrix.copy(He.matrix),
                  ee === !0 && R.cameras.push(He);
              }
            }
            const Q = i.inputSources;
            for (let K = 0; K < _.length; K++) {
              const ee = Q[K],
                ge = M.get(ee);
              ge !== void 0 && ge.update(ee, W, l || o);
            }
            B && B(U, W), (f = null);
          }
          const X = new Zl();
          X.setAnimationLoop(V),
            (this.setAnimationLoop = function (U) {
              B = U;
            }),
            (this.dispose = function () {});
        }
      }
      function Jm(r, e) {
        function t(m, p) {
          m.fogColor.value.copy(p.color),
            p.isFog
              ? ((m.fogNear.value = p.near), (m.fogFar.value = p.far))
              : p.isFogExp2 && (m.fogDensity.value = p.density);
        }
        function n(m, p, _, M, T) {
          p.isMeshBasicMaterial || p.isMeshLambertMaterial
            ? i(m, p)
            : p.isMeshToonMaterial
            ? (i(m, p), h(m, p))
            : p.isMeshPhongMaterial
            ? (i(m, p), c(m, p))
            : p.isMeshStandardMaterial
            ? (i(m, p), u(m, p), p.isMeshPhysicalMaterial && d(m, p, T))
            : p.isMeshMatcapMaterial
            ? (i(m, p), f(m, p))
            : p.isMeshDepthMaterial
            ? i(m, p)
            : p.isMeshDistanceMaterial
            ? (i(m, p), g(m, p))
            : p.isMeshNormalMaterial
            ? i(m, p)
            : p.isLineBasicMaterial
            ? (s(m, p), p.isLineDashedMaterial && o(m, p))
            : p.isPointsMaterial
            ? a(m, p, _, M)
            : p.isSpriteMaterial
            ? l(m, p)
            : p.isShadowMaterial
            ? (m.color.value.copy(p.color), (m.opacity.value = p.opacity))
            : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
        }
        function i(m, p) {
          (m.opacity.value = p.opacity),
            p.color && m.diffuse.value.copy(p.color),
            p.emissive &&
              m.emissive.value
                .copy(p.emissive)
                .multiplyScalar(p.emissiveIntensity),
            p.map && (m.map.value = p.map),
            p.alphaMap && (m.alphaMap.value = p.alphaMap),
            p.bumpMap &&
              ((m.bumpMap.value = p.bumpMap),
              (m.bumpScale.value = p.bumpScale),
              p.side === Nt && (m.bumpScale.value *= -1)),
            p.displacementMap &&
              ((m.displacementMap.value = p.displacementMap),
              (m.displacementScale.value = p.displacementScale),
              (m.displacementBias.value = p.displacementBias)),
            p.emissiveMap && (m.emissiveMap.value = p.emissiveMap),
            p.normalMap &&
              ((m.normalMap.value = p.normalMap),
              m.normalScale.value.copy(p.normalScale),
              p.side === Nt && m.normalScale.value.negate()),
            p.specularMap && (m.specularMap.value = p.specularMap),
            p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          const _ = e.get(p).envMap;
          if (
            (_ &&
              ((m.envMap.value = _),
              (m.flipEnvMap.value =
                _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
              (m.reflectivity.value = p.reflectivity),
              (m.ior.value = p.ior),
              (m.refractionRatio.value = p.refractionRatio)),
            p.lightMap)
          ) {
            m.lightMap.value = p.lightMap;
            const E = r.physicallyCorrectLights !== !0 ? Math.PI : 1;
            m.lightMapIntensity.value = p.lightMapIntensity * E;
          }
          p.aoMap &&
            ((m.aoMap.value = p.aoMap),
            (m.aoMapIntensity.value = p.aoMapIntensity));
          let M;
          p.map
            ? (M = p.map)
            : p.specularMap
            ? (M = p.specularMap)
            : p.displacementMap
            ? (M = p.displacementMap)
            : p.normalMap
            ? (M = p.normalMap)
            : p.bumpMap
            ? (M = p.bumpMap)
            : p.roughnessMap
            ? (M = p.roughnessMap)
            : p.metalnessMap
            ? (M = p.metalnessMap)
            : p.alphaMap
            ? (M = p.alphaMap)
            : p.emissiveMap
            ? (M = p.emissiveMap)
            : p.clearcoatMap
            ? (M = p.clearcoatMap)
            : p.clearcoatNormalMap
            ? (M = p.clearcoatNormalMap)
            : p.clearcoatRoughnessMap
            ? (M = p.clearcoatRoughnessMap)
            : p.specularIntensityMap
            ? (M = p.specularIntensityMap)
            : p.specularColorMap
            ? (M = p.specularColorMap)
            : p.transmissionMap
            ? (M = p.transmissionMap)
            : p.thicknessMap
            ? (M = p.thicknessMap)
            : p.sheenColorMap
            ? (M = p.sheenColorMap)
            : p.sheenRoughnessMap && (M = p.sheenRoughnessMap),
            M !== void 0 &&
              (M.isWebGLRenderTarget && (M = M.texture),
              M.matrixAutoUpdate === !0 && M.updateMatrix(),
              m.uvTransform.value.copy(M.matrix));
          let T;
          p.aoMap ? (T = p.aoMap) : p.lightMap && (T = p.lightMap),
            T !== void 0 &&
              (T.isWebGLRenderTarget && (T = T.texture),
              T.matrixAutoUpdate === !0 && T.updateMatrix(),
              m.uv2Transform.value.copy(T.matrix));
        }
        function s(m, p) {
          m.diffuse.value.copy(p.color), (m.opacity.value = p.opacity);
        }
        function o(m, p) {
          (m.dashSize.value = p.dashSize),
            (m.totalSize.value = p.dashSize + p.gapSize),
            (m.scale.value = p.scale);
        }
        function a(m, p, _, M) {
          m.diffuse.value.copy(p.color),
            (m.opacity.value = p.opacity),
            (m.size.value = p.size * _),
            (m.scale.value = M * 0.5),
            p.map && (m.map.value = p.map),
            p.alphaMap && (m.alphaMap.value = p.alphaMap),
            p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          let T;
          p.map ? (T = p.map) : p.alphaMap && (T = p.alphaMap),
            T !== void 0 &&
              (T.matrixAutoUpdate === !0 && T.updateMatrix(),
              m.uvTransform.value.copy(T.matrix));
        }
        function l(m, p) {
          m.diffuse.value.copy(p.color),
            (m.opacity.value = p.opacity),
            (m.rotation.value = p.rotation),
            p.map && (m.map.value = p.map),
            p.alphaMap && (m.alphaMap.value = p.alphaMap),
            p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          let _;
          p.map ? (_ = p.map) : p.alphaMap && (_ = p.alphaMap),
            _ !== void 0 &&
              (_.matrixAutoUpdate === !0 && _.updateMatrix(),
              m.uvTransform.value.copy(_.matrix));
        }
        function c(m, p) {
          m.specular.value.copy(p.specular),
            (m.shininess.value = Math.max(p.shininess, 1e-4));
        }
        function h(m, p) {
          p.gradientMap && (m.gradientMap.value = p.gradientMap);
        }
        function u(m, p) {
          (m.roughness.value = p.roughness),
            (m.metalness.value = p.metalness),
            p.roughnessMap && (m.roughnessMap.value = p.roughnessMap),
            p.metalnessMap && (m.metalnessMap.value = p.metalnessMap),
            e.get(p).envMap && (m.envMapIntensity.value = p.envMapIntensity);
        }
        function d(m, p, _) {
          (m.ior.value = p.ior),
            p.sheen > 0 &&
              (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
              (m.sheenRoughness.value = p.sheenRoughness),
              p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap),
              p.sheenRoughnessMap &&
                (m.sheenRoughnessMap.value = p.sheenRoughnessMap)),
            p.clearcoat > 0 &&
              ((m.clearcoat.value = p.clearcoat),
              (m.clearcoatRoughness.value = p.clearcoatRoughness),
              p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap),
              p.clearcoatRoughnessMap &&
                (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
              p.clearcoatNormalMap &&
                (m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
                (m.clearcoatNormalMap.value = p.clearcoatNormalMap),
                p.side === Nt && m.clearcoatNormalScale.value.negate())),
            p.transmission > 0 &&
              ((m.transmission.value = p.transmission),
              (m.transmissionSamplerMap.value = _.texture),
              m.transmissionSamplerSize.value.set(_.width, _.height),
              p.transmissionMap &&
                (m.transmissionMap.value = p.transmissionMap),
              (m.thickness.value = p.thickness),
              p.thicknessMap && (m.thicknessMap.value = p.thicknessMap),
              (m.attenuationDistance.value = p.attenuationDistance),
              m.attenuationColor.value.copy(p.attenuationColor)),
            (m.specularIntensity.value = p.specularIntensity),
            m.specularColor.value.copy(p.specularColor),
            p.specularIntensityMap &&
              (m.specularIntensityMap.value = p.specularIntensityMap),
            p.specularColorMap &&
              (m.specularColorMap.value = p.specularColorMap);
        }
        function f(m, p) {
          p.matcap && (m.matcap.value = p.matcap);
        }
        function g(m, p) {
          m.referencePosition.value.copy(p.referencePosition),
            (m.nearDistance.value = p.nearDistance),
            (m.farDistance.value = p.farDistance);
        }
        return { refreshFogUniforms: t, refreshMaterialUniforms: n };
      }
      function Km() {
        const r = as("canvas");
        return (r.style.display = "block"), r;
      }
      function Xe(r = {}) {
        const e = r.canvas !== void 0 ? r.canvas : Km(),
          t = r.context !== void 0 ? r.context : null,
          n = r.depth !== void 0 ? r.depth : !0,
          i = r.stencil !== void 0 ? r.stencil : !0,
          s = r.antialias !== void 0 ? r.antialias : !1,
          o = r.premultipliedAlpha !== void 0 ? r.premultipliedAlpha : !0,
          a = r.preserveDrawingBuffer !== void 0 ? r.preserveDrawingBuffer : !1,
          l = r.powerPreference !== void 0 ? r.powerPreference : "default",
          c =
            r.failIfMajorPerformanceCaveat !== void 0
              ? r.failIfMajorPerformanceCaveat
              : !1;
        let h;
        t !== null
          ? (h = t.getContextAttributes().alpha)
          : (h = r.alpha !== void 0 ? r.alpha : !1);
        let u = null,
          d = null;
        const f = [],
          g = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = Sn),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = rn),
          (this.toneMappingExposure = 1);
        const m = this;
        let p = !1,
          _ = 0,
          M = 0,
          T = null,
          E = -1,
          w = null;
        const R = new je(),
          P = new je();
        let y = null,
          L = e.width,
          N = e.height,
          D = 1,
          ie = null,
          J = null;
        const C = new je(0, 0, L, N),
          H = new je(0, 0, L, N);
        let B = !1;
        const V = new or();
        let X = !1,
          U = !1,
          W = null;
        const Q = new me(),
          K = new $(),
          ee = new S(),
          ge = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function _e() {
          return T === null ? D : 1;
        }
        let k = t;
        function He(v, I) {
          for (let O = 0; O < v.length; O++) {
            const F = v[O],
              q = e.getContext(F, I);
            if (q !== null) return q;
          }
          return null;
        }
        try {
          const v = {
            alpha: !0,
            depth: n,
            stencil: i,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c,
          };
          if (
            ("setAttribute" in e &&
              e.setAttribute("data-engine", `three.js r${bo}`),
            e.addEventListener("webglcontextlost", A, !1),
            e.addEventListener("webglcontextrestored", ae, !1),
            k === null)
          ) {
            const I = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (m.isWebGL1Renderer === !0 && I.shift(),
              (k = He(I, v)),
              k === null)
            )
              throw He(I)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          k.getShaderPrecisionFormat === void 0 &&
            (k.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (v) {
          throw (console.error("THREE.WebGLRenderer: " + v.message), v);
        }
        let be,
          Le,
          se,
          Ne,
          Y,
          j,
          te,
          fe,
          ce,
          Ee,
          ve,
          xe,
          Je,
          Ye,
          b,
          x,
          z,
          Z,
          le,
          ue,
          ye,
          G,
          Re;
        function Pe() {
          (be = new fp(k)),
            (Le = new ap(k, be, r)),
            be.init(Le),
            (G = new Xm(k, be, Le)),
            (se = new Wm(k, be, Le)),
            (Ne = new gp()),
            (Y = new Dm()),
            (j = new qm(k, be, se, Y, Le, G, Ne)),
            (te = new cp(m)),
            (fe = new dp(m)),
            (ce = new Lu(k, Le)),
            (Re = new rp(k, be, ce, Le)),
            (Ee = new pp(k, ce, Ne, Re)),
            (ve = new vp(k, Ee, ce, Ne)),
            (le = new yp(k, Le, j)),
            (x = new lp(Y)),
            (xe = new Im(m, te, fe, be, Le, Re, x)),
            (Je = new Jm(m, Y)),
            (Ye = new Nm()),
            (b = new Gm(be, Le)),
            (Z = new sp(m, te, se, ve, h, o)),
            (z = new sc(m, ve, Le)),
            (ue = new op(k, be, Ne, Le)),
            (ye = new mp(k, be, Ne, Le)),
            (Ne.programs = xe.programs),
            (m.capabilities = Le),
            (m.extensions = be),
            (m.properties = Y),
            (m.renderLists = Ye),
            (m.shadowMap = z),
            (m.state = se),
            (m.info = Ne);
        }
        Pe();
        const pe = new Ym(m, k);
        (this.xr = pe),
          (this.getContext = function () {
            return k;
          }),
          (this.getContextAttributes = function () {
            return k.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const v = be.get("WEBGL_lose_context");
            v && v.loseContext();
          }),
          (this.forceContextRestore = function () {
            const v = be.get("WEBGL_lose_context");
            v && v.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return D;
          }),
          (this.setPixelRatio = function (v) {
            v !== void 0 && ((D = v), this.setSize(L, N, !1));
          }),
          (this.getSize = function (v) {
            return v.set(L, N);
          }),
          (this.setSize = function (v, I, O) {
            if (pe.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (L = v),
              (N = I),
              (e.width = Math.floor(v * D)),
              (e.height = Math.floor(I * D)),
              O !== !1 &&
                ((e.style.width = v + "px"), (e.style.height = I + "px")),
              this.setViewport(0, 0, v, I);
          }),
          (this.getDrawingBufferSize = function (v) {
            return v.set(L * D, N * D).floor();
          }),
          (this.setDrawingBufferSize = function (v, I, O) {
            (L = v),
              (N = I),
              (D = O),
              (e.width = Math.floor(v * O)),
              (e.height = Math.floor(I * O)),
              this.setViewport(0, 0, v, I);
          }),
          (this.getCurrentViewport = function (v) {
            return v.copy(R);
          }),
          (this.getViewport = function (v) {
            return v.copy(C);
          }),
          (this.setViewport = function (v, I, O, F) {
            v.isVector4 ? C.set(v.x, v.y, v.z, v.w) : C.set(v, I, O, F),
              se.viewport(R.copy(C).multiplyScalar(D).floor());
          }),
          (this.getScissor = function (v) {
            return v.copy(H);
          }),
          (this.setScissor = function (v, I, O, F) {
            v.isVector4 ? H.set(v.x, v.y, v.z, v.w) : H.set(v, I, O, F),
              se.scissor(P.copy(H).multiplyScalar(D).floor());
          }),
          (this.getScissorTest = function () {
            return B;
          }),
          (this.setScissorTest = function (v) {
            se.setScissorTest((B = v));
          }),
          (this.setOpaqueSort = function (v) {
            ie = v;
          }),
          (this.setTransparentSort = function (v) {
            J = v;
          }),
          (this.getClearColor = function (v) {
            return v.copy(Z.getClearColor());
          }),
          (this.setClearColor = function () {
            Z.setClearColor.apply(Z, arguments);
          }),
          (this.getClearAlpha = function () {
            return Z.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            Z.setClearAlpha.apply(Z, arguments);
          }),
          (this.clear = function (v = !0, I = !0, O = !0) {
            let F = 0;
            v && (F |= 16384), I && (F |= 256), O && (F |= 1024), k.clear(F);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", A, !1),
              e.removeEventListener("webglcontextrestored", ae, !1),
              Ye.dispose(),
              b.dispose(),
              Y.dispose(),
              te.dispose(),
              fe.dispose(),
              ve.dispose(),
              Re.dispose(),
              xe.dispose(),
              pe.dispose(),
              pe.removeEventListener("sessionstart", Se),
              pe.removeEventListener("sessionend", We),
              W && (W.dispose(), (W = null)),
              Be.stop();
          });
        function A(v) {
          v.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (p = !0);
        }
        function ae() {
          console.log("THREE.WebGLRenderer: Context Restored."), (p = !1);
          const v = Ne.autoReset,
            I = z.enabled,
            O = z.autoUpdate,
            F = z.needsUpdate,
            q = z.type;
          Pe(),
            (Ne.autoReset = v),
            (z.enabled = I),
            (z.autoUpdate = O),
            (z.needsUpdate = F),
            (z.type = q);
        }
        function re(v) {
          const I = v.target;
          I.removeEventListener("dispose", re), we(I);
        }
        function we(v) {
          de(v), Y.remove(v);
        }
        function de(v) {
          const I = Y.get(v).programs;
          I !== void 0 &&
            (I.forEach(function (O) {
              xe.releaseProgram(O);
            }),
            v.isShaderMaterial && xe.releaseShaderCache(v));
        }
        (this.renderBufferDirect = function (v, I, O, F, q, Te) {
          I === null && (I = ge);
          const Ae = q.isMesh && q.matrixWorld.determinant() < 0,
            Ie = qc(v, I, O, F, q);
          se.setMaterial(F, Ae);
          let Ce = O.index;
          const qe = O.attributes.position;
          if (Ce === null) {
            if (qe === void 0 || qe.count === 0) return;
          } else if (Ce.count === 0) return;
          let Oe = 1;
          F.wireframe === !0 && ((Ce = Ee.getWireframeAttribute(O)), (Oe = 2)),
            Re.setup(q, F, Ie, O, Ce);
          let Ue,
            Qe = ue;
          Ce !== null && ((Ue = ce.get(Ce)), (Qe = ye), Qe.setIndex(Ue));
          const An = Ce !== null ? Ce.count : qe.count,
            jn = O.drawRange.start * Oe,
            Yn = O.drawRange.count * Oe,
            zt = Te !== null ? Te.start * Oe : 0,
            Ge = Te !== null ? Te.count * Oe : 1 / 0,
            Jn = Math.max(jn, zt),
            nt = Math.min(An, jn + Yn, zt + Ge) - 1,
            Ht = Math.max(0, nt - Jn + 1);
          if (Ht !== 0) {
            if (q.isMesh)
              F.wireframe === !0
                ? (se.setLineWidth(F.wireframeLinewidth * _e()), Qe.setMode(1))
                : Qe.setMode(4);
            else if (q.isLine) {
              let ln = F.linewidth;
              ln === void 0 && (ln = 1),
                se.setLineWidth(ln * _e()),
                q.isLineSegments
                  ? Qe.setMode(1)
                  : q.isLineLoop
                  ? Qe.setMode(2)
                  : Qe.setMode(3);
            } else q.isPoints ? Qe.setMode(0) : q.isSprite && Qe.setMode(4);
            if (q.isInstancedMesh) Qe.renderInstances(Jn, Ht, q.count);
            else if (O.isInstancedBufferGeometry) {
              const ln = Math.min(O.instanceCount, O._maxInstanceCount);
              Qe.renderInstances(Jn, Ht, ln);
            } else Qe.render(Jn, Ht);
          }
        }),
          (this.compile = function (v, I) {
            (d = b.get(v)),
              d.init(),
              g.push(d),
              v.traverseVisible(function (O) {
                O.isLight &&
                  O.layers.test(I.layers) &&
                  (d.pushLight(O), O.castShadow && d.pushShadow(O));
              }),
              d.setupLights(m.physicallyCorrectLights),
              v.traverse(function (O) {
                const F = O.material;
                if (F)
                  if (Array.isArray(F))
                    for (let q = 0; q < F.length; q++) {
                      const Te = F[q];
                      mr(Te, v, O);
                    }
                  else mr(F, v, O);
              }),
              g.pop(),
              (d = null);
          });
        let Me = null;
        function ne(v) {
          Me && Me(v);
        }
        function Se() {
          Be.stop();
        }
        function We() {
          Be.start();
        }
        const Be = new Zl();
        Be.setAnimationLoop(ne),
          typeof self != "undefined" && Be.setContext(self),
          (this.setAnimationLoop = function (v) {
            (Me = v),
              pe.setAnimationLoop(v),
              v === null ? Be.stop() : Be.start();
          }),
          pe.addEventListener("sessionstart", Se),
          pe.addEventListener("sessionend", We),
          (this.render = function (v, I) {
            if (I !== void 0 && I.isCamera !== !0) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (p === !0) return;
            v.autoUpdate === !0 && v.updateMatrixWorld(),
              I.parent === null && I.updateMatrixWorld(),
              pe.enabled === !0 &&
                pe.isPresenting === !0 &&
                (pe.cameraAutoUpdate === !0 && pe.updateCamera(I),
                (I = pe.getCamera())),
              v.isScene === !0 && v.onBeforeRender(m, v, I, T),
              (d = b.get(v, g.length)),
              d.init(),
              g.push(d),
              Q.multiplyMatrices(I.projectionMatrix, I.matrixWorldInverse),
              V.setFromProjectionMatrix(Q),
              (U = this.localClippingEnabled),
              (X = x.init(this.clippingPlanes, U, I)),
              (u = Ye.get(v, f.length)),
              u.init(),
              f.push(u),
              Ot(v, I, 0, m.sortObjects),
              u.finish(),
              m.sortObjects === !0 && u.sort(ie, J),
              X === !0 && x.beginShadows();
            const O = d.state.shadowsArray;
            if (
              (z.render(O, v, I),
              X === !0 && x.endShadows(),
              this.info.autoReset === !0 && this.info.reset(),
              Z.render(u, v),
              d.setupLights(m.physicallyCorrectLights),
              I.isArrayCamera)
            ) {
              const F = I.cameras;
              for (let q = 0, Te = F.length; q < Te; q++) {
                const Ae = F[q];
                Ut(u, v, Ae, Ae.viewport);
              }
            } else Ut(u, v, I);
            T !== null &&
              (j.updateMultisampleRenderTarget(T),
              j.updateRenderTargetMipmap(T)),
              v.isScene === !0 && v.onAfterRender(m, v, I),
              Re.resetDefaultState(),
              (E = -1),
              (w = null),
              g.pop(),
              g.length > 0 ? (d = g[g.length - 1]) : (d = null),
              f.pop(),
              f.length > 0 ? (u = f[f.length - 1]) : (u = null);
          });
        function Ot(v, I, O, F) {
          if (v.visible === !1) return;
          if (v.layers.test(I.layers)) {
            if (v.isGroup) O = v.renderOrder;
            else if (v.isLOD) v.autoUpdate === !0 && v.update(I);
            else if (v.isLight) d.pushLight(v), v.castShadow && d.pushShadow(v);
            else if (v.isSprite) {
              if (!v.frustumCulled || V.intersectsSprite(v)) {
                F && ee.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q);
                const Ae = ve.update(v),
                  Ie = v.material;
                Ie.visible && u.push(v, Ae, Ie, O, ee.z, null);
              }
            } else if (
              (v.isMesh || v.isLine || v.isPoints) &&
              (v.isSkinnedMesh &&
                v.skeleton.frame !== Ne.render.frame &&
                (v.skeleton.update(), (v.skeleton.frame = Ne.render.frame)),
              !v.frustumCulled || V.intersectsObject(v))
            ) {
              F && ee.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q);
              const Ae = ve.update(v),
                Ie = v.material;
              if (Array.isArray(Ie)) {
                const Ce = Ae.groups;
                for (let qe = 0, Oe = Ce.length; qe < Oe; qe++) {
                  const Ue = Ce[qe],
                    Qe = Ie[Ue.materialIndex];
                  Qe && Qe.visible && u.push(v, Ae, Qe, O, ee.z, Ue);
                }
              } else Ie.visible && u.push(v, Ae, Ie, O, ee.z, null);
            }
          }
          const Te = v.children;
          for (let Ae = 0, Ie = Te.length; Ae < Ie; Ae++) Ot(Te[Ae], I, O, F);
        }
        function Ut(v, I, O, F) {
          const q = v.opaque,
            Te = v.transmissive,
            Ae = v.transparent;
          d.setupLightsView(O),
            Te.length > 0 && Vc(q, I, O),
            F && se.viewport(R.copy(F)),
            q.length > 0 && _s(q, I, O),
            Te.length > 0 && _s(Te, I, O),
            Ae.length > 0 && _s(Ae, I, O),
            se.buffers.depth.setTest(!0),
            se.buffers.depth.setMask(!0),
            se.buffers.color.setMask(!0),
            se.setPolygonOffset(!1);
        }
        function Vc(v, I, O) {
          const F = Le.isWebGL2;
          W === null &&
            (W = new St(1, 1, {
              generateMipmaps: !0,
              type: be.has("EXT_color_buffer_half_float") ? is : Un,
              minFilter: Ci,
              samples: F && s === !0 ? 4 : 0,
            })),
            m.getDrawingBufferSize(K),
            F ? W.setSize(K.x, K.y) : W.setSize(tr(K.x), tr(K.y));
          const q = m.getRenderTarget();
          m.setRenderTarget(W), m.clear();
          const Te = m.toneMapping;
          (m.toneMapping = rn),
            _s(v, I, O),
            (m.toneMapping = Te),
            j.updateMultisampleRenderTarget(W),
            j.updateRenderTargetMipmap(W),
            m.setRenderTarget(q);
        }
        function _s(v, I, O) {
          const F = I.isScene === !0 ? I.overrideMaterial : null;
          for (let q = 0, Te = v.length; q < Te; q++) {
            const Ae = v[q],
              Ie = Ae.object,
              Ce = Ae.geometry,
              qe = F === null ? Ae.material : F,
              Oe = Ae.group;
            Ie.layers.test(O.layers) && Wc(Ie, I, O, Ce, qe, Oe);
          }
        }
        function Wc(v, I, O, F, q, Te) {
          v.onBeforeRender(m, I, O, F, q, Te),
            v.modelViewMatrix.multiplyMatrices(
              O.matrixWorldInverse,
              v.matrixWorld
            ),
            v.normalMatrix.getNormalMatrix(v.modelViewMatrix),
            q.onBeforeRender(m, I, O, F, v, Te),
            q.transparent === !0 && q.side === On
              ? ((q.side = Nt),
                (q.needsUpdate = !0),
                m.renderBufferDirect(O, I, F, q, v, Te),
                (q.side = Mi),
                (q.needsUpdate = !0),
                m.renderBufferDirect(O, I, F, q, v, Te),
                (q.side = On))
              : m.renderBufferDirect(O, I, F, q, v, Te),
            v.onAfterRender(m, I, O, F, q, Te);
        }
        function mr(v, I, O) {
          I.isScene !== !0 && (I = ge);
          const F = Y.get(v),
            q = d.state.lights,
            Te = d.state.shadowsArray,
            Ae = q.state.version,
            Ie = xe.getParameters(v, q.state, Te, I, O),
            Ce = xe.getProgramCacheKey(Ie);
          let qe = F.programs;
          (F.environment = v.isMeshStandardMaterial ? I.environment : null),
            (F.fog = I.fog),
            (F.envMap = (v.isMeshStandardMaterial ? fe : te).get(
              v.envMap || F.environment
            )),
            qe === void 0 &&
              (v.addEventListener("dispose", re),
              (qe = new Map()),
              (F.programs = qe));
          let Oe = qe.get(Ce);
          if (Oe !== void 0) {
            if (F.currentProgram === Oe && F.lightsStateVersion === Ae)
              return Jo(v, Ie), Oe;
          } else
            (Ie.uniforms = xe.getUniforms(v)),
              v.onBuild(O, Ie, m),
              v.onBeforeCompile(Ie, m),
              (Oe = xe.acquireProgram(Ie, Ce)),
              qe.set(Ce, Oe),
              (F.uniforms = Ie.uniforms);
          const Ue = F.uniforms;
          ((!v.isShaderMaterial && !v.isRawShaderMaterial) ||
            v.clipping === !0) &&
            (Ue.clippingPlanes = x.uniform),
            Jo(v, Ie),
            (F.needsLights = jc(v)),
            (F.lightsStateVersion = Ae),
            F.needsLights &&
              ((Ue.ambientLightColor.value = q.state.ambient),
              (Ue.lightProbe.value = q.state.probe),
              (Ue.directionalLights.value = q.state.directional),
              (Ue.directionalLightShadows.value = q.state.directionalShadow),
              (Ue.spotLights.value = q.state.spot),
              (Ue.spotLightShadows.value = q.state.spotShadow),
              (Ue.rectAreaLights.value = q.state.rectArea),
              (Ue.ltc_1.value = q.state.rectAreaLTC1),
              (Ue.ltc_2.value = q.state.rectAreaLTC2),
              (Ue.pointLights.value = q.state.point),
              (Ue.pointLightShadows.value = q.state.pointShadow),
              (Ue.hemisphereLights.value = q.state.hemi),
              (Ue.directionalShadowMap.value = q.state.directionalShadowMap),
              (Ue.directionalShadowMatrix.value =
                q.state.directionalShadowMatrix),
              (Ue.spotShadowMap.value = q.state.spotShadowMap),
              (Ue.spotShadowMatrix.value = q.state.spotShadowMatrix),
              (Ue.pointShadowMap.value = q.state.pointShadowMap),
              (Ue.pointShadowMatrix.value = q.state.pointShadowMatrix));
          const Qe = Oe.getUniforms(),
            An = Mn.seqWithValue(Qe.seq, Ue);
          return (F.currentProgram = Oe), (F.uniformsList = An), Oe;
        }
        function Jo(v, I) {
          const O = Y.get(v);
          (O.outputEncoding = I.outputEncoding),
            (O.instancing = I.instancing),
            (O.skinning = I.skinning),
            (O.morphTargets = I.morphTargets),
            (O.morphNormals = I.morphNormals),
            (O.morphColors = I.morphColors),
            (O.morphTargetsCount = I.morphTargetsCount),
            (O.numClippingPlanes = I.numClippingPlanes),
            (O.numIntersection = I.numClipIntersection),
            (O.vertexAlphas = I.vertexAlphas),
            (O.vertexTangents = I.vertexTangents),
            (O.toneMapping = I.toneMapping);
        }
        function qc(v, I, O, F, q) {
          I.isScene !== !0 && (I = ge), j.resetTextureUnits();
          const Te = I.fog,
            Ae = F.isMeshStandardMaterial ? I.environment : null,
            Ie =
              T === null
                ? m.outputEncoding
                : T.isXRRenderTarget === !0
                ? T.texture.encoding
                : Sn,
            Ce = (F.isMeshStandardMaterial ? fe : te).get(F.envMap || Ae),
            qe =
              F.vertexColors === !0 &&
              !!O.attributes.color &&
              O.attributes.color.itemSize === 4,
            Oe = !!F.normalMap && !!O.attributes.tangent,
            Ue = !!O.morphAttributes.position,
            Qe = !!O.morphAttributes.normal,
            An = !!O.morphAttributes.color,
            jn = F.toneMapped ? m.toneMapping : rn,
            Yn =
              O.morphAttributes.position ||
              O.morphAttributes.normal ||
              O.morphAttributes.color,
            zt = Yn !== void 0 ? Yn.length : 0,
            Ge = Y.get(F),
            Jn = d.state.lights;
          if (X === !0 && (U === !0 || v !== w)) {
            const Gt = v === w && F.id === E;
            x.setState(F, v, Gt);
          }
          let nt = !1;
          F.version === Ge.__version
            ? ((Ge.needsLights && Ge.lightsStateVersion !== Jn.state.version) ||
                Ge.outputEncoding !== Ie ||
                (q.isInstancedMesh && Ge.instancing === !1) ||
                (!q.isInstancedMesh && Ge.instancing === !0) ||
                (q.isSkinnedMesh && Ge.skinning === !1) ||
                (!q.isSkinnedMesh && Ge.skinning === !0) ||
                Ge.envMap !== Ce ||
                (F.fog === !0 && Ge.fog !== Te) ||
                (Ge.numClippingPlanes !== void 0 &&
                  (Ge.numClippingPlanes !== x.numPlanes ||
                    Ge.numIntersection !== x.numIntersection)) ||
                Ge.vertexAlphas !== qe ||
                Ge.vertexTangents !== Oe ||
                Ge.morphTargets !== Ue ||
                Ge.morphNormals !== Qe ||
                Ge.morphColors !== An ||
                Ge.toneMapping !== jn ||
                (Le.isWebGL2 === !0 && Ge.morphTargetsCount !== zt)) &&
              (nt = !0)
            : ((nt = !0), (Ge.__version = F.version));
          let Ht = Ge.currentProgram;
          nt === !0 && (Ht = mr(F, I, q));
          let ln = !1,
            Ui = !1,
            gr = !1;
          const gt = Ht.getUniforms(),
            zi = Ge.uniforms;
          if (
            (se.useProgram(Ht.program) && ((ln = !0), (Ui = !0), (gr = !0)),
            F.id !== E && ((E = F.id), (Ui = !0)),
            ln || w !== v)
          ) {
            if (
              (gt.setValue(k, "projectionMatrix", v.projectionMatrix),
              Le.logarithmicDepthBuffer &&
                gt.setValue(
                  k,
                  "logDepthBufFC",
                  2 / (Math.log(v.far + 1) / Math.LN2)
                ),
              w !== v && ((w = v), (Ui = !0), (gr = !0)),
              F.isShaderMaterial ||
                F.isMeshPhongMaterial ||
                F.isMeshToonMaterial ||
                F.isMeshStandardMaterial ||
                F.envMap)
            ) {
              const Gt = gt.map.cameraPosition;
              Gt !== void 0 &&
                Gt.setValue(k, ee.setFromMatrixPosition(v.matrixWorld));
            }
            (F.isMeshPhongMaterial ||
              F.isMeshToonMaterial ||
              F.isMeshLambertMaterial ||
              F.isMeshBasicMaterial ||
              F.isMeshStandardMaterial ||
              F.isShaderMaterial) &&
              gt.setValue(k, "isOrthographic", v.isOrthographicCamera === !0),
              (F.isMeshPhongMaterial ||
                F.isMeshToonMaterial ||
                F.isMeshLambertMaterial ||
                F.isMeshBasicMaterial ||
                F.isMeshStandardMaterial ||
                F.isShaderMaterial ||
                F.isShadowMaterial ||
                q.isSkinnedMesh) &&
                gt.setValue(k, "viewMatrix", v.matrixWorldInverse);
          }
          if (q.isSkinnedMesh) {
            gt.setOptional(k, q, "bindMatrix"),
              gt.setOptional(k, q, "bindMatrixInverse");
            const Gt = q.skeleton;
            Gt &&
              (Le.floatVertexTextures
                ? (Gt.boneTexture === null && Gt.computeBoneTexture(),
                  gt.setValue(k, "boneTexture", Gt.boneTexture, j),
                  gt.setValue(k, "boneTextureSize", Gt.boneTextureSize))
                : console.warn(
                    "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                  ));
          }
          const _r = O.morphAttributes;
          return (
            (_r.position !== void 0 ||
              _r.normal !== void 0 ||
              (_r.color !== void 0 && Le.isWebGL2 === !0)) &&
              le.update(q, O, F, Ht),
            (Ui || Ge.receiveShadow !== q.receiveShadow) &&
              ((Ge.receiveShadow = q.receiveShadow),
              gt.setValue(k, "receiveShadow", q.receiveShadow)),
            Ui &&
              (gt.setValue(k, "toneMappingExposure", m.toneMappingExposure),
              Ge.needsLights && Xc(zi, gr),
              Te && F.fog === !0 && Je.refreshFogUniforms(zi, Te),
              Je.refreshMaterialUniforms(zi, F, D, N, W),
              Mn.upload(k, Ge.uniformsList, zi, j)),
            F.isShaderMaterial &&
              F.uniformsNeedUpdate === !0 &&
              (Mn.upload(k, Ge.uniformsList, zi, j),
              (F.uniformsNeedUpdate = !1)),
            F.isSpriteMaterial && gt.setValue(k, "center", q.center),
            gt.setValue(k, "modelViewMatrix", q.modelViewMatrix),
            gt.setValue(k, "normalMatrix", q.normalMatrix),
            gt.setValue(k, "modelMatrix", q.matrixWorld),
            Ht
          );
        }
        function Xc(v, I) {
          (v.ambientLightColor.needsUpdate = I),
            (v.lightProbe.needsUpdate = I),
            (v.directionalLights.needsUpdate = I),
            (v.directionalLightShadows.needsUpdate = I),
            (v.pointLights.needsUpdate = I),
            (v.pointLightShadows.needsUpdate = I),
            (v.spotLights.needsUpdate = I),
            (v.spotLightShadows.needsUpdate = I),
            (v.rectAreaLights.needsUpdate = I),
            (v.hemisphereLights.needsUpdate = I);
        }
        function jc(v) {
          return (
            v.isMeshLambertMaterial ||
            v.isMeshToonMaterial ||
            v.isMeshPhongMaterial ||
            v.isMeshStandardMaterial ||
            v.isShadowMaterial ||
            (v.isShaderMaterial && v.lights === !0)
          );
        }
        (this.getActiveCubeFace = function () {
          return _;
        }),
          (this.getActiveMipmapLevel = function () {
            return M;
          }),
          (this.getRenderTarget = function () {
            return T;
          }),
          (this.setRenderTargetTextures = function (v, I, O) {
            (Y.get(v.texture).__webglTexture = I),
              (Y.get(v.depthTexture).__webglTexture = O);
            const F = Y.get(v);
            (F.__hasExternalTextures = !0),
              F.__hasExternalTextures &&
                ((F.__autoAllocateDepthBuffer = O === void 0),
                F.__autoAllocateDepthBuffer ||
                  (be.has("WEBGL_multisampled_render_to_texture") === !0 &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (F.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (v, I) {
            const O = Y.get(v);
            (O.__webglFramebuffer = I),
              (O.__useDefaultFramebuffer = I === void 0);
          }),
          (this.setRenderTarget = function (v, I = 0, O = 0) {
            (T = v), (_ = I), (M = O);
            let F = !0;
            if (v) {
              const Ce = Y.get(v);
              Ce.__useDefaultFramebuffer !== void 0
                ? (se.bindFramebuffer(36160, null), (F = !1))
                : Ce.__webglFramebuffer === void 0
                ? j.setupRenderTarget(v)
                : Ce.__hasExternalTextures &&
                  j.rebindTextures(
                    v,
                    Y.get(v.texture).__webglTexture,
                    Y.get(v.depthTexture).__webglTexture
                  );
            }
            let q = null,
              Te = !1,
              Ae = !1;
            if (v) {
              const Ce = v.texture;
              (Ce.isData3DTexture || Ce.isDataArrayTexture) && (Ae = !0);
              const qe = Y.get(v).__webglFramebuffer;
              v.isWebGLCubeRenderTarget
                ? ((q = qe[I]), (Te = !0))
                : Le.isWebGL2 && v.samples > 0 && j.useMultisampledRTT(v) === !1
                ? (q = Y.get(v).__webglMultisampledFramebuffer)
                : (q = qe),
                R.copy(v.viewport),
                P.copy(v.scissor),
                (y = v.scissorTest);
            } else
              R.copy(C).multiplyScalar(D).floor(),
                P.copy(H).multiplyScalar(D).floor(),
                (y = B);
            if (
              (se.bindFramebuffer(36160, q) &&
                Le.drawBuffers &&
                F &&
                se.drawBuffers(v, q),
              se.viewport(R),
              se.scissor(P),
              se.setScissorTest(y),
              Te)
            ) {
              const Ce = Y.get(v.texture);
              k.framebufferTexture2D(
                36160,
                36064,
                34069 + I,
                Ce.__webglTexture,
                O
              );
            } else if (Ae) {
              const Ce = Y.get(v.texture),
                qe = I || 0;
              k.framebufferTextureLayer(
                36160,
                36064,
                Ce.__webglTexture,
                O || 0,
                qe
              );
            }
            E = -1;
          }),
          (this.readRenderTargetPixels = function (v, I, O, F, q, Te, Ae) {
            if (!(v && v.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let Ie = Y.get(v).__webglFramebuffer;
            if (
              (v.isWebGLCubeRenderTarget && Ae !== void 0 && (Ie = Ie[Ae]), Ie)
            ) {
              se.bindFramebuffer(36160, Ie);
              try {
                const Ce = v.texture,
                  qe = Ce.format,
                  Oe = Ce.type;
                if (qe !== At && G.convert(qe) !== k.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                const Ue =
                  Oe === is &&
                  (be.has("EXT_color_buffer_half_float") ||
                    (Le.isWebGL2 && be.has("EXT_color_buffer_float")));
                if (
                  Oe !== Un &&
                  G.convert(Oe) !== k.getParameter(35738) &&
                  !(
                    Oe === xn &&
                    (Le.isWebGL2 ||
                      be.has("OES_texture_float") ||
                      be.has("WEBGL_color_buffer_float"))
                  ) &&
                  !Ue
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                I >= 0 &&
                  I <= v.width - F &&
                  O >= 0 &&
                  O <= v.height - q &&
                  k.readPixels(I, O, F, q, G.convert(qe), G.convert(Oe), Te);
              } finally {
                const Ce = T !== null ? Y.get(T).__webglFramebuffer : null;
                se.bindFramebuffer(36160, Ce);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (v, I, O = 0) {
            if (I.isFramebufferTexture !== !0) {
              console.error(
                "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
              );
              return;
            }
            const F = Math.pow(2, -O),
              q = Math.floor(I.image.width * F),
              Te = Math.floor(I.image.height * F);
            j.setTexture2D(I, 0),
              k.copyTexSubImage2D(3553, O, 0, 0, v.x, v.y, q, Te),
              se.unbindTexture();
          }),
          (this.copyTextureToTexture = function (v, I, O, F = 0) {
            const q = I.image.width,
              Te = I.image.height,
              Ae = G.convert(O.format),
              Ie = G.convert(O.type);
            j.setTexture2D(O, 0),
              k.pixelStorei(37440, O.flipY),
              k.pixelStorei(37441, O.premultiplyAlpha),
              k.pixelStorei(3317, O.unpackAlignment),
              I.isDataTexture
                ? k.texSubImage2D(
                    3553,
                    F,
                    v.x,
                    v.y,
                    q,
                    Te,
                    Ae,
                    Ie,
                    I.image.data
                  )
                : I.isCompressedTexture
                ? k.compressedTexSubImage2D(
                    3553,
                    F,
                    v.x,
                    v.y,
                    I.mipmaps[0].width,
                    I.mipmaps[0].height,
                    Ae,
                    I.mipmaps[0].data
                  )
                : k.texSubImage2D(3553, F, v.x, v.y, Ae, Ie, I.image),
              F === 0 && O.generateMipmaps && k.generateMipmap(3553),
              se.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (v, I, O, F, q = 0) {
            if (m.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            const Te = v.max.x - v.min.x + 1,
              Ae = v.max.y - v.min.y + 1,
              Ie = v.max.z - v.min.z + 1,
              Ce = G.convert(F.format),
              qe = G.convert(F.type);
            let Oe;
            if (F.isData3DTexture) j.setTexture3D(F, 0), (Oe = 32879);
            else if (F.isDataArrayTexture)
              j.setTexture2DArray(F, 0), (Oe = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            k.pixelStorei(37440, F.flipY),
              k.pixelStorei(37441, F.premultiplyAlpha),
              k.pixelStorei(3317, F.unpackAlignment);
            const Ue = k.getParameter(3314),
              Qe = k.getParameter(32878),
              An = k.getParameter(3316),
              jn = k.getParameter(3315),
              Yn = k.getParameter(32877),
              zt = O.isCompressedTexture ? O.mipmaps[0] : O.image;
            k.pixelStorei(3314, zt.width),
              k.pixelStorei(32878, zt.height),
              k.pixelStorei(3316, v.min.x),
              k.pixelStorei(3315, v.min.y),
              k.pixelStorei(32877, v.min.z),
              O.isDataTexture || O.isData3DTexture
                ? k.texSubImage3D(
                    Oe,
                    q,
                    I.x,
                    I.y,
                    I.z,
                    Te,
                    Ae,
                    Ie,
                    Ce,
                    qe,
                    zt.data
                  )
                : O.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  k.compressedTexSubImage3D(
                    Oe,
                    q,
                    I.x,
                    I.y,
                    I.z,
                    Te,
                    Ae,
                    Ie,
                    Ce,
                    zt.data
                  ))
                : k.texSubImage3D(Oe, q, I.x, I.y, I.z, Te, Ae, Ie, Ce, qe, zt),
              k.pixelStorei(3314, Ue),
              k.pixelStorei(32878, Qe),
              k.pixelStorei(3316, An),
              k.pixelStorei(3315, jn),
              k.pixelStorei(32877, Yn),
              q === 0 && F.generateMipmaps && k.generateMipmap(Oe),
              se.unbindTexture();
          }),
          (this.initTexture = function (v) {
            j.setTexture2D(v, 0), se.unbindTexture();
          }),
          (this.resetState = function () {
            (_ = 0), (M = 0), (T = null), se.reset(), Re.reset();
          }),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      Xe.prototype.isWebGLRenderer = !0;
      class Zm extends Xe {}
      Zm.prototype.isWebGL1Renderer = !0;
      class Do extends Ve {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ != "undefined" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
              (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
        }
      }
      Do.prototype.isScene = !0;
      class Di {
        constructor(e, t) {
          (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = rs),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Rt());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, s = this.stride; i < s; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = Rt()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
              (this.array.buffer._uuid = Rt()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Di.prototype.isInterleavedBuffer = !0;
      const _t = new S();
      class Ri {
        constructor(e, t, n, i = !1) {
          (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i === !0);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            _t.fromBufferAttribute(this, t),
              _t.applyMatrix4(e),
              this.setXYZ(t, _t.x, _t.y, _t.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            _t.fromBufferAttribute(this, t),
              _t.applyNormalMatrix(e),
              this.setXYZ(t, _t.x, _t.y, _t.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            _t.fromBufferAttribute(this, t),
              _t.transformDirection(e),
              this.setXYZ(t, _t.x, _t.y, _t.z);
          return this;
        }
        setX(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset] = t), this
          );
        }
        setY(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 1] = t), this
          );
        }
        setZ(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 2] = t), this
          );
        }
        setW(e, t) {
          return (
            (this.data.array[e * this.data.stride + this.offset + 3] = t), this
          );
        }
        getX(e) {
          return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
          return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
          return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
          return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, s) {
          return (
            (e = e * this.data.stride + this.offset),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = s),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let s = 0; s < this.itemSize; s++)
                t.push(this.data.array[i + s]);
            }
            return new tt(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Ri(
                e.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let n = 0; n < this.count; n++) {
              const i = n * this.data.stride + this.offset;
              for (let s = 0; s < this.itemSize; s++)
                t.push(this.data.array[i + s]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 &&
                (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
        }
      }
      Ri.prototype.isInterleavedBufferAttribute = !0;
      class Fo extends et {
        constructor(e) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new he(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      Fo.prototype.isSpriteMaterial = !0;
      let hi;
      const Vi = new S(),
        ui = new S(),
        di = new S(),
        fi = new $(),
        Wi = new $(),
        ac = new me(),
        Us = new S(),
        qi = new S(),
        zs = new S(),
        sl = new $(),
        Kr = new $(),
        rl = new $();
      class $m extends Ve {
        constructor(e) {
          if ((super(), (this.type = "Sprite"), hi === void 0)) {
            hi = new Ke();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              n = new Di(t, 5);
            hi.setIndex([0, 1, 2, 0, 2, 3]),
              hi.setAttribute("position", new Ri(n, 3, 0, !1)),
              hi.setAttribute("uv", new Ri(n, 2, 3, !1));
          }
          (this.geometry = hi),
            (this.material = e !== void 0 ? e : new Fo()),
            (this.center = new $(0.5, 0.5));
        }
        raycast(e, t) {
          e.camera === null &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            ui.setFromMatrixScale(this.matrixWorld),
            ac.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              e.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            di.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera &&
              this.material.sizeAttenuation === !1 &&
              ui.multiplyScalar(-di.z);
          const n = this.material.rotation;
          let i, s;
          n !== 0 && ((s = Math.cos(n)), (i = Math.sin(n)));
          const o = this.center;
          Hs(Us.set(-0.5, -0.5, 0), di, o, ui, i, s),
            Hs(qi.set(0.5, -0.5, 0), di, o, ui, i, s),
            Hs(zs.set(0.5, 0.5, 0), di, o, ui, i, s),
            sl.set(0, 0),
            Kr.set(1, 0),
            rl.set(1, 1);
          let a = e.ray.intersectTriangle(Us, qi, zs, !1, Vi);
          if (
            a === null &&
            (Hs(qi.set(-0.5, 0.5, 0), di, o, ui, i, s),
            Kr.set(0, 1),
            (a = e.ray.intersectTriangle(Us, zs, qi, !1, Vi)),
            a === null)
          )
            return;
          const l = e.ray.origin.distanceTo(Vi);
          l < e.near ||
            l > e.far ||
            t.push({
              distance: l,
              point: Vi.clone(),
              uv: st.getUV(Vi, Us, qi, zs, sl, Kr, rl, new $()),
              face: null,
              object: this,
            });
        }
        copy(e) {
          return (
            super.copy(e),
            e.center !== void 0 && this.center.copy(e.center),
            (this.material = e.material),
            this
          );
        }
      }
      $m.prototype.isSprite = !0;
      function Hs(r, e, t, n, i, s) {
        fi.subVectors(r, t).addScalar(0.5).multiply(n),
          i !== void 0
            ? ((Wi.x = s * fi.x - i * fi.y), (Wi.y = i * fi.x + s * fi.y))
            : Wi.copy(fi),
          r.copy(e),
          (r.x += Wi.x),
          (r.y += Wi.y),
          r.applyMatrix4(ac);
      }
      const ol = new S(),
        al = new je(),
        ll = new je(),
        Qm = new S(),
        cl = new me();
      class No extends xt {
        constructor(e, t) {
          super(e, t),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new me()),
            (this.bindMatrixInverse = new me());
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            this
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new je(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === "attached"
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === "detached"
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          al.fromBufferAttribute(i.attributes.skinIndex, e),
            ll.fromBufferAttribute(i.attributes.skinWeight, e),
            ol.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let s = 0; s < 4; s++) {
            const o = ll.getComponent(s);
            if (o !== 0) {
              const a = al.getComponent(s);
              cl.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(Qm.copy(ol).applyMatrix4(cl), o);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      No.prototype.isSkinnedMesh = !0;
      class Bo extends Ve {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      Bo.prototype.isBone = !0;
      class lc extends rt {
        constructor(
          e = null,
          t = 1,
          n = 1,
          i,
          s,
          o,
          a,
          l,
          c = at,
          h = at,
          u,
          d
        ) {
          super(null, o, a, l, c, h, i, s, u, d),
            (this.image = { data: e, width: t, height: n }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      lc.prototype.isDataTexture = !0;
      const hl = new me(),
        eg = new me();
      class Oo {
        constructor(e = [], t = []) {
          (this.uuid = Rt()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(e.length * 16)),
            t.length === 0)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let n = 0, i = this.bones.length; n < i; n++)
              this.boneInverses.push(new me());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new me();
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(n);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n &&
              (n.parent && n.parent.isBone
                ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                  n.matrix.multiply(n.matrixWorld))
                : n.matrix.copy(n.matrixWorld),
              n.matrix.decompose(n.position, n.quaternion, n.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : eg;
            hl.multiplyMatrices(a, t[s]), hl.toArray(n, s * 16);
          }
          i !== null && (i.needsUpdate = !0);
        }
        clone() {
          return new Oo(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          (e = Wl(e)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new lc(t, e, e, At, xn);
          return (
            (n.needsUpdate = !0),
            (this.boneMatrices = t),
            (this.boneTexture = n),
            (this.boneTextureSize = e),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e) return i;
          }
        }
        dispose() {
          this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const s = e.bones[n];
            let o = t[s];
            o === void 0 &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", s),
              (o = new Bo())),
              this.bones.push(o),
              this.boneInverses.push(new me().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray());
          }
          return e;
        }
      }
      class fo extends tt {
        constructor(e, t, n, i = 1) {
          typeof n == "number" &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(e, t, n),
            (this.meshPerAttribute = i);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      fo.prototype.isInstancedBufferAttribute = !0;
      const ul = new me(),
        dl = new me(),
        Gs = [],
        Xi = new xt();
      class tg extends xt {
        constructor(e, t, n) {
          super(e, t),
            (this.instanceMatrix = new fo(new Float32Array(n * 16), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(e) {
          return (
            super.copy(e),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.instanceColor !== null &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((Xi.geometry = this.geometry),
            (Xi.material = this.material),
            Xi.material !== void 0)
          )
            for (let s = 0; s < i; s++) {
              this.getMatrixAt(s, ul),
                dl.multiplyMatrices(n, ul),
                (Xi.matrixWorld = dl),
                Xi.raycast(e, Gs);
              for (let o = 0, a = Gs.length; o < a; o++) {
                const l = Gs[o];
                (l.instanceId = s), (l.object = this), t.push(l);
              }
              Gs.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null &&
            (this.instanceColor = new fo(
              new Float32Array(this.instanceMatrix.count * 3),
              3
            )),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      tg.prototype.isInstancedMesh = !0;
      class Xn extends et {
        constructor(e) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new he(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      Xn.prototype.isLineBasicMaterial = !0;
      const fl = new S(),
        pl = new S(),
        ml = new me(),
        Zr = new Pi(),
        ks = new Wn();
      class cr extends Ve {
        constructor(e = new Ke(), t = new Xn()) {
          super(),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [0];
              for (let i = 1, s = t.count; i < s; i++)
                fl.fromBufferAttribute(t, i - 1),
                  pl.fromBufferAttribute(t, i),
                  (n[i] = n[i - 1]),
                  (n[i] += fl.distanceTo(pl));
              e.setAttribute("lineDistance", new ct(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            s = e.params.Line.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            ks.copy(n.boundingSphere),
            ks.applyMatrix4(i),
            (ks.radius += s),
            e.ray.intersectsSphere(ks) === !1)
          )
            return;
          ml.copy(i).invert(), Zr.copy(e.ray).applyMatrix4(ml);
          const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new S(),
            h = new S(),
            u = new S(),
            d = new S(),
            f = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const g = n.index,
              p = n.attributes.position;
            if (g !== null) {
              const _ = Math.max(0, o.start),
                M = Math.min(g.count, o.start + o.count);
              for (let T = _, E = M - 1; T < E; T += f) {
                const w = g.getX(T),
                  R = g.getX(T + 1);
                if (
                  (c.fromBufferAttribute(p, w),
                  h.fromBufferAttribute(p, R),
                  Zr.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const y = e.ray.origin.distanceTo(d);
                y < e.near ||
                  y > e.far ||
                  t.push({
                    distance: y,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const _ = Math.max(0, o.start),
                M = Math.min(p.count, o.start + o.count);
              for (let T = _, E = M - 1; T < E; T += f) {
                if (
                  (c.fromBufferAttribute(p, T),
                  h.fromBufferAttribute(p, T + 1),
                  Zr.distanceSqToSegment(c, h, d, u) > l)
                )
                  continue;
                d.applyMatrix4(this.matrixWorld);
                const R = e.ray.origin.distanceTo(d);
                R < e.near ||
                  R > e.far ||
                  t.push({
                    distance: R,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let s = 0, o = i.length; s < o; s++) {
                  const a = i[s].name || String(s);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = s);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      cr.prototype.isLine = !0;
      const gl = new S(),
        _l = new S();
      class hr extends cr {
        constructor(e, t) {
          super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.isBufferGeometry)
            if (e.index === null) {
              const t = e.attributes.position,
                n = [];
              for (let i = 0, s = t.count; i < s; i += 2)
                gl.fromBufferAttribute(t, i),
                  _l.fromBufferAttribute(t, i + 1),
                  (n[i] = i === 0 ? 0 : n[i - 1]),
                  (n[i + 1] = n[i] + gl.distanceTo(_l));
              e.setAttribute("lineDistance", new ct(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            e.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      hr.prototype.isLineSegments = !0;
      class cc extends cr {
        constructor(e, t) {
          super(e, t), (this.type = "LineLoop");
        }
      }
      cc.prototype.isLineLoop = !0;
      class ur extends et {
        constructor(e) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new he(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      ur.prototype.isPointsMaterial = !0;
      const xl = new me(),
        po = new Pi(),
        Vs = new Wn(),
        Ws = new S();
      class hc extends Ve {
        constructor(e = new Ke(), t = new ur()) {
          super(),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            s = e.params.Points.threshold,
            o = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            Vs.copy(n.boundingSphere),
            Vs.applyMatrix4(i),
            (Vs.radius += s),
            e.ray.intersectsSphere(Vs) === !1)
          )
            return;
          xl.copy(i).invert(), po.copy(e.ray).applyMatrix4(xl);
          const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a;
          if (n.isBufferGeometry) {
            const c = n.index,
              u = n.attributes.position;
            if (c !== null) {
              const d = Math.max(0, o.start),
                f = Math.min(c.count, o.start + o.count);
              for (let g = d, m = f; g < m; g++) {
                const p = c.getX(g);
                Ws.fromBufferAttribute(u, p), yl(Ws, p, l, i, e, t, this);
              }
            } else {
              const d = Math.max(0, o.start),
                f = Math.min(u.count, o.start + o.count);
              for (let g = d, m = f; g < m; g++)
                Ws.fromBufferAttribute(u, g), yl(Ws, g, l, i, e, t, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const e = this.geometry;
          if (e.isBufferGeometry) {
            const t = e.morphAttributes,
              n = Object.keys(t);
            if (n.length > 0) {
              const i = t[n[0]];
              if (i !== void 0) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let s = 0, o = i.length; s < o; s++) {
                  const a = i[s].name || String(s);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[a] = s);
                }
              }
            }
          } else {
            const t = e.morphTargets;
            t !== void 0 &&
              t.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      hc.prototype.isPoints = !0;
      function yl(r, e, t, n, i, s, o) {
        const a = po.distanceSqToPoint(r);
        if (a < t) {
          const l = new S();
          po.closestPointToPoint(r, l), l.applyMatrix4(n);
          const c = i.ray.origin.distanceTo(l);
          if (c < i.near || c > i.far) return;
          s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      class ng extends rt {
        constructor(e, t, n, i, s, o, a, l, c) {
          super(e, t, n, i, s, o, a, l, c),
            (this.minFilter = o !== void 0 ? o : pt),
            (this.magFilter = s !== void 0 ? s : pt),
            (this.generateMipmaps = !1);
          const h = this;
          function u() {
            (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
          }
          "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      ng.prototype.isVideoTexture = !0;
      class ig extends rt {
        constructor(e, t, n) {
          super({ width: e, height: t }),
            (this.format = n),
            (this.magFilter = at),
            (this.minFilter = at),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
        }
      }
      ig.prototype.isFramebufferTexture = !0;
      class sg extends rt {
        constructor(e, t, n, i, s, o, a, l, c, h, u, d) {
          super(null, o, a, l, c, h, i, s, u, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      sg.prototype.isCompressedTexture = !0;
      class rg extends rt {
        constructor(e, t, n, i, s, o, a, l, c) {
          super(e, t, n, i, s, o, a, l, c), (this.needsUpdate = !0);
        }
      }
      rg.prototype.isCanvasTexture = !0;
      class Lt {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            s = 0;
          t.push(0);
          for (let o = 1; o <= e; o++)
            (n = this.getPoint(o / e)),
              (s += n.distanceTo(i)),
              t.push(s),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const s = n.length;
          let o;
          t ? (o = t) : (o = e * n[s - 1]);
          let a = 0,
            l = s - 1,
            c;
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - o), c < 0))
              a = i + 1;
            else if (c > 0) l = i - 1;
            else {
              l = i;
              break;
            }
          if (((i = l), n[i] === o)) return i / (s - 1);
          const h = n[i],
            d = n[i + 1] - h,
            f = (o - h) / d;
          return (i + f) / (s - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4,
            s = e + 1e-4;
          i < 0 && (i = 0), s > 1 && (s = 1);
          const o = this.getPoint(i),
            a = this.getPoint(s),
            l = t || (o.isVector2 ? new $() : new S());
          return l.copy(a).sub(o).normalize(), l;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new S(),
            i = [],
            s = [],
            o = [],
            a = new S(),
            l = new me();
          for (let f = 0; f <= e; f++) {
            const g = f / e;
            i[f] = this.getTangentAt(g, new S());
          }
          (s[0] = new S()), (o[0] = new S());
          let c = Number.MAX_VALUE;
          const h = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
          h <= c && ((c = h), n.set(1, 0, 0)),
            u <= c && ((c = u), n.set(0, 1, 0)),
            d <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            s[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], s[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((s[f] = s[f - 1].clone()),
              (o[f] = o[f - 1].clone()),
              a.crossVectors(i[f - 1], i[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const g = Math.acos(ut(i[f - 1].dot(i[f]), -1, 1));
              s[f].applyMatrix4(l.makeRotationAxis(a, g));
            }
            o[f].crossVectors(i[f], s[f]);
          }
          if (t === !0) {
            let f = Math.acos(ut(s[0].dot(s[e]), -1, 1));
            (f /= e), i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (f = -f);
            for (let g = 1; g <= e; g++)
              s[g].applyMatrix4(l.makeRotationAxis(i[g], f * g)),
                o[g].crossVectors(i[g], s[g]);
          }
          return { tangents: i, normals: s, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class dr extends Lt {
        constructor(
          e = 0,
          t = 0,
          n = 1,
          i = 1,
          s = 0,
          o = Math.PI * 2,
          a = !1,
          l = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = e),
            (this.aY = t),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = s),
            (this.aEndAngle = o),
            (this.aClockwise = a),
            (this.aRotation = l);
        }
        getPoint(e, t) {
          const n = t || new $(),
            i = Math.PI * 2;
          let s = this.aEndAngle - this.aStartAngle;
          const o = Math.abs(s) < Number.EPSILON;
          for (; s < 0; ) s += i;
          for (; s > i; ) s -= i;
          s < Number.EPSILON && (o ? (s = 0) : (s = i)),
            this.aClockwise === !0 && !o && (s === i ? (s = -i) : (s = s - i));
          const a = this.aStartAngle + e * s;
          let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
          if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation),
              u = Math.sin(this.aRotation),
              d = l - this.aX,
              f = c - this.aY;
            (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
          }
          return n.set(l, c);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.aX = this.aX),
            (e.aY = this.aY),
            (e.xRadius = this.xRadius),
            (e.yRadius = this.yRadius),
            (e.aStartAngle = this.aStartAngle),
            (e.aEndAngle = this.aEndAngle),
            (e.aClockwise = this.aClockwise),
            (e.aRotation = this.aRotation),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.aX = e.aX),
            (this.aY = e.aY),
            (this.xRadius = e.xRadius),
            (this.yRadius = e.yRadius),
            (this.aStartAngle = e.aStartAngle),
            (this.aEndAngle = e.aEndAngle),
            (this.aClockwise = e.aClockwise),
            (this.aRotation = e.aRotation),
            this
          );
        }
      }
      dr.prototype.isEllipseCurve = !0;
      class uc extends dr {
        constructor(e, t, n, i, s, o) {
          super(e, t, n, n, i, s, o), (this.type = "ArcCurve");
        }
      }
      uc.prototype.isArcCurve = !0;
      function Uo() {
        let r = 0,
          e = 0,
          t = 0,
          n = 0;
        function i(s, o, a, l) {
          (r = s),
            (e = a),
            (t = -3 * s + 3 * o - 2 * a - l),
            (n = 2 * s - 2 * o + a + l);
        }
        return {
          initCatmullRom: function (s, o, a, l, c) {
            i(o, a, c * (a - s), c * (l - o));
          },
          initNonuniformCatmullRom: function (s, o, a, l, c, h, u) {
            let d = (o - s) / c - (a - s) / (c + h) + (a - o) / h,
              f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            (d *= h), (f *= h), i(o, a, d, f);
          },
          calc: function (s) {
            const o = s * s,
              a = o * s;
            return r + e * s + t * o + n * a;
          },
        };
      }
      const qs = new S(),
        $r = new Uo(),
        Qr = new Uo(),
        eo = new Uo();
      class dc extends Lt {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = e),
            (this.closed = t),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(e, t = new S()) {
          const n = t,
            i = this.points,
            s = i.length,
            o = (s - (this.closed ? 0 : 1)) * e;
          let a = Math.floor(o),
            l = o - a;
          this.closed
            ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
            : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
          let c, h;
          this.closed || a > 0
            ? (c = i[(a - 1) % s])
            : (qs.subVectors(i[0], i[1]).add(i[0]), (c = qs));
          const u = i[a % s],
            d = i[(a + 1) % s];
          if (
            (this.closed || a + 2 < s
              ? (h = i[(a + 2) % s])
              : (qs.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (h = qs)),
            this.curveType === "centripetal" || this.curveType === "chordal")
          ) {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let g = Math.pow(c.distanceToSquared(u), f),
              m = Math.pow(u.distanceToSquared(d), f),
              p = Math.pow(d.distanceToSquared(h), f);
            m < 1e-4 && (m = 1),
              g < 1e-4 && (g = m),
              p < 1e-4 && (p = m),
              $r.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, g, m, p),
              Qr.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, g, m, p),
              eo.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, g, m, p);
          } else
            this.curveType === "catmullrom" &&
              ($r.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
              Qr.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
              eo.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
          return n.set($r.calc(l), Qr.calc(l), eo.calc(l)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (
            (e.closed = this.closed),
            (e.curveType = this.curveType),
            (e.tension = this.tension),
            e
          );
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new S().fromArray(i));
          }
          return (
            (this.closed = e.closed),
            (this.curveType = e.curveType),
            (this.tension = e.tension),
            this
          );
        }
      }
      dc.prototype.isCatmullRomCurve3 = !0;
      function vl(r, e, t, n, i) {
        const s = (n - e) * 0.5,
          o = (i - t) * 0.5,
          a = r * r,
          l = r * a;
        return (
          (2 * t - 2 * n + s + o) * l +
          (-3 * t + 3 * n - 2 * s - o) * a +
          s * r +
          t
        );
      }
      function og(r, e) {
        const t = 1 - r;
        return t * t * e;
      }
      function ag(r, e) {
        return 2 * (1 - r) * r * e;
      }
      function lg(r, e) {
        return r * r * e;
      }
      function es(r, e, t, n) {
        return og(r, e) + ag(r, t) + lg(r, n);
      }
      function cg(r, e) {
        const t = 1 - r;
        return t * t * t * e;
      }
      function hg(r, e) {
        const t = 1 - r;
        return 3 * t * t * r * e;
      }
      function ug(r, e) {
        return 3 * (1 - r) * r * r * e;
      }
      function dg(r, e) {
        return r * r * r * e;
      }
      function ts(r, e, t, n, i) {
        return cg(r, e) + hg(r, t) + ug(r, n) + dg(r, i);
      }
      class zo extends Lt {
        constructor(e = new $(), t = new $(), n = new $(), i = new $()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new $()) {
          const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
          return n.set(ts(e, i.x, s.x, o.x, a.x), ts(e, i.y, s.y, o.y, a.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      zo.prototype.isCubicBezierCurve = !0;
      class fc extends Lt {
        constructor(e = new S(), t = new S(), n = new S(), i = new S()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(e, t = new S()) {
          const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
          return (
            n.set(
              ts(e, i.x, s.x, o.x, a.x),
              ts(e, i.y, s.y, o.y, a.y),
              ts(e, i.z, s.z, o.z, a.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      }
      fc.prototype.isCubicBezierCurve3 = !0;
      class fr extends Lt {
        constructor(e = new $(), t = new $()) {
          super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new $()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t) {
          const n = t || new $();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      fr.prototype.isLineCurve = !0;
      class fg extends Lt {
        constructor(e = new S(), t = new S()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = e),
            (this.v2 = t);
        }
        getPoint(e, t = new S()) {
          const n = t;
          return (
            e === 1
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
            n
          );
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      class Ho extends Lt {
        constructor(e = new $(), t = new $(), n = new $()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new $()) {
          const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2;
          return n.set(es(e, i.x, s.x, o.x), es(e, i.y, s.y, o.y)), n;
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      Ho.prototype.isQuadraticBezierCurve = !0;
      class pc extends Lt {
        constructor(e = new S(), t = new S(), n = new S()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
        }
        getPoint(e, t = new S()) {
          const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2;
          return (
            n.set(
              es(e, i.x, s.x, o.x),
              es(e, i.y, s.y, o.y),
              es(e, i.z, s.z, o.z)
            ),
            n
          );
        }
        copy(e) {
          return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
          );
        }
      }
      pc.prototype.isQuadraticBezierCurve3 = !0;
      class Go extends Lt {
        constructor(e = []) {
          super(), (this.type = "SplineCurve"), (this.points = e);
        }
        getPoint(e, t = new $()) {
          const n = t,
            i = this.points,
            s = (i.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = i[o === 0 ? o : o - 1],
            c = i[o],
            h = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
          return n.set(vl(a, l.x, c.x, h.x, u.x), vl(a, l.y, c.y, h.y, u.y)), n;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new $().fromArray(i));
          }
          return this;
        }
      }
      Go.prototype.isSplineCurve = !0;
      var mc = Object.freeze({
        __proto__: null,
        ArcCurve: uc,
        CatmullRomCurve3: dc,
        CubicBezierCurve: zo,
        CubicBezierCurve3: fc,
        EllipseCurve: dr,
        LineCurve: fr,
        LineCurve3: fg,
        QuadraticBezierCurve: Ho,
        QuadraticBezierCurve3: pc,
        SplineCurve: Go,
      });
      class pg extends Lt {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
          e.equals(t) || this.curves.push(new fr(t, e));
        }
        getPoint(e, t) {
          const n = e * this.getLength(),
            i = this.getCurveLengths();
          let s = 0;
          for (; s < i.length; ) {
            if (i[s] >= n) {
              const o = i[s] - n,
                a = this.curves[s],
                l = a.getLength(),
                c = l === 0 ? 0 : 1 - o / l;
              return a.getPointAt(c, t);
            }
            s++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (t += this.curves[n].getLength()), e.push(t);
          return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let n;
          for (let i = 0, s = this.curves; i < s.length; i++) {
            const o = s[i],
              a = o.isEllipseCurve
                ? e * 2
                : o.isLineCurve || o.isLineCurve3
                ? 1
                : o.isSplineCurve
                ? e * o.points.length
                : e,
              l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
              const h = l[c];
              (n && n.equals(h)) || (t.push(h), (n = h));
            }
          }
          return (
            this.autoClose &&
              t.length > 1 &&
              !t[t.length - 1].equals(t[0]) &&
              t.push(t[0]),
            t
          );
        }
        copy(e) {
          super.copy(e), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone());
          }
          return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.autoClose = this.autoClose), (e.curves = []);
          for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
          for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new mc[i.type]().fromJSON(i));
          }
          return this;
        }
      }
      class mo extends pg {
        constructor(e) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new $()),
            e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const n = new fr(this.currentPoint.clone(), new $(e, t));
          return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
          const s = new Ho(this.currentPoint.clone(), new $(e, t), new $(n, i));
          return this.curves.push(s), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, s, o) {
          const a = new zo(
            this.currentPoint.clone(),
            new $(e, t),
            new $(n, i),
            new $(s, o)
          );
          return this.curves.push(a), this.currentPoint.set(s, o), this;
        }
        splineThru(e) {
          const t = [this.currentPoint.clone()].concat(e),
            n = new Go(t);
          return (
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
          );
        }
        arc(e, t, n, i, s, o) {
          const a = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absarc(e + a, t + l, n, i, s, o), this;
        }
        absarc(e, t, n, i, s, o) {
          return this.absellipse(e, t, n, n, i, s, o), this;
        }
        ellipse(e, t, n, i, s, o, a, l) {
          const c = this.currentPoint.x,
            h = this.currentPoint.y;
          return this.absellipse(e + c, t + h, n, i, s, o, a, l), this;
        }
        absellipse(e, t, n, i, s, o, a, l) {
          const c = new dr(e, t, n, i, s, o, a, l);
          if (this.curves.length > 0) {
            const u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
          }
          this.curves.push(c);
          const h = c.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
          return (
            super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
          );
        }
      }
      new S();
      new S();
      new S();
      new st();
      class ms extends mo {
        constructor(e) {
          super(e),
            (this.uuid = Rt()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(e) {
          const t = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
          super.copy(e), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          (e.uuid = this.uuid), (e.holes = []);
          for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
          for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new mo().fromJSON(i));
          }
          return this;
        }
      }
      const mg = {
        triangulate: function (r, e, t = 2) {
          const n = e && e.length,
            i = n ? e[0] * t : r.length;
          let s = gc(r, 0, i, t, !0);
          const o = [];
          if (!s || s.next === s.prev) return o;
          let a, l, c, h, u, d, f;
          if ((n && (s = vg(r, e, s, t)), r.length > 80 * t)) {
            (a = c = r[0]), (l = h = r[1]);
            for (let g = t; g < i; g += t)
              (u = r[g]),
                (d = r[g + 1]),
                u < a && (a = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            (f = Math.max(c - a, h - l)), (f = f !== 0 ? 1 / f : 0);
          }
          return ls(s, o, t, a, l, f), o;
        },
      };
      function gc(r, e, t, n, i) {
        let s, o;
        if (i === Pg(r, e, t, n) > 0)
          for (s = e; s < t; s += n) o = Ml(s, r[s], r[s + 1], o);
        else for (s = t - n; s >= e; s -= n) o = Ml(s, r[s], r[s + 1], o);
        return o && pr(o, o.next) && (hs(o), (o = o.next)), o;
      }
      function Tn(r, e) {
        if (!r) return r;
        e || (e = r);
        let t = r,
          n;
        do
          if (
            ((n = !1),
            !t.steiner && (pr(t, t.next) || $e(t.prev, t, t.next) === 0))
          ) {
            if ((hs(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
          } else t = t.next;
        while (n || t !== e);
        return e;
      }
      function ls(r, e, t, n, i, s, o) {
        if (!r) return;
        !o && s && Tg(r, n, i, s);
        let a = r,
          l,
          c;
        for (; r.prev !== r.next; ) {
          if (((l = r.prev), (c = r.next), s ? _g(r, n, i, s) : gg(r))) {
            e.push(l.i / t),
              e.push(r.i / t),
              e.push(c.i / t),
              hs(r),
              (r = c.next),
              (a = c.next);
            continue;
          }
          if (((r = c), r === a)) {
            o
              ? o === 1
                ? ((r = xg(Tn(r), e, t)), ls(r, e, t, n, i, s, 2))
                : o === 2 && yg(r, e, t, n, i, s)
              : ls(Tn(r), e, t, n, i, s, 1);
            break;
          }
        }
      }
      function gg(r) {
        const e = r.prev,
          t = r,
          n = r.next;
        if ($e(e, t, n) >= 0) return !1;
        let i = r.next.next;
        for (; i !== r.prev; ) {
          if (
            xi(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            $e(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function _g(r, e, t, n) {
        const i = r.prev,
          s = r,
          o = r.next;
        if ($e(i, s, o) >= 0) return !1;
        const a = i.x < s.x ? (i.x < o.x ? i.x : o.x) : s.x < o.x ? s.x : o.x,
          l = i.y < s.y ? (i.y < o.y ? i.y : o.y) : s.y < o.y ? s.y : o.y,
          c = i.x > s.x ? (i.x > o.x ? i.x : o.x) : s.x > o.x ? s.x : o.x,
          h = i.y > s.y ? (i.y > o.y ? i.y : o.y) : s.y > o.y ? s.y : o.y,
          u = go(a, l, e, t, n),
          d = go(c, h, e, t, n);
        let f = r.prevZ,
          g = r.nextZ;
        for (; f && f.z >= u && g && g.z <= d; ) {
          if (
            (f !== r.prev &&
              f !== r.next &&
              xi(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
              $e(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            g !== r.prev &&
              g !== r.next &&
              xi(i.x, i.y, s.x, s.y, o.x, o.y, g.x, g.y) &&
              $e(g.prev, g, g.next) >= 0)
          )
            return !1;
          g = g.nextZ;
        }
        for (; f && f.z >= u; ) {
          if (
            f !== r.prev &&
            f !== r.next &&
            xi(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
            $e(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; g && g.z <= d; ) {
          if (
            g !== r.prev &&
            g !== r.next &&
            xi(i.x, i.y, s.x, s.y, o.x, o.y, g.x, g.y) &&
            $e(g.prev, g, g.next) >= 0
          )
            return !1;
          g = g.nextZ;
        }
        return !0;
      }
      function xg(r, e, t) {
        let n = r;
        do {
          const i = n.prev,
            s = n.next.next;
          !pr(i, s) &&
            _c(i, n, n.next, s) &&
            cs(i, s) &&
            cs(s, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(s.i / t),
            hs(n),
            hs(n.next),
            (n = r = s)),
            (n = n.next);
        } while (n !== r);
        return Tn(n);
      }
      function yg(r, e, t, n, i, s) {
        let o = r;
        do {
          let a = o.next.next;
          for (; a !== o.prev; ) {
            if (o.i !== a.i && Rg(o, a)) {
              let l = xc(o, a);
              (o = Tn(o, o.next)),
                (l = Tn(l, l.next)),
                ls(o, e, t, n, i, s),
                ls(l, e, t, n, i, s);
              return;
            }
            a = a.next;
          }
          o = o.next;
        } while (o !== r);
      }
      function vg(r, e, t, n) {
        const i = [];
        let s, o, a, l, c;
        for (s = 0, o = e.length; s < o; s++)
          (a = e[s] * n),
            (l = s < o - 1 ? e[s + 1] * n : r.length),
            (c = gc(r, a, l, n, !1)),
            c === c.next && (c.steiner = !0),
            i.push(Ag(c));
        for (i.sort(Mg), s = 0; s < i.length; s++)
          bg(i[s], t), (t = Tn(t, t.next));
        return t;
      }
      function Mg(r, e) {
        return r.x - e.x;
      }
      function bg(r, e) {
        if (((e = wg(r, e)), e)) {
          const t = xc(e, r);
          Tn(e, e.next), Tn(t, t.next);
        }
      }
      function wg(r, e) {
        let t = e;
        const n = r.x,
          i = r.y;
        let s = -1 / 0,
          o;
        do {
          if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > s) {
              if (((s = d), d === n)) {
                if (i === t.y) return t;
                if (i === t.next.y) return t.next;
              }
              o = t.x < t.next.x ? t : t.next;
            }
          }
          t = t.next;
        } while (t !== e);
        if (!o) return null;
        if (n === s) return o;
        const a = o,
          l = o.x,
          c = o.y;
        let h = 1 / 0,
          u;
        t = o;
        do
          n >= t.x &&
            t.x >= l &&
            n !== t.x &&
            xi(i < c ? n : s, i, l, c, i < c ? s : n, i, t.x, t.y) &&
            ((u = Math.abs(i - t.y) / (n - t.x)),
            cs(t, r) &&
              (u < h ||
                (u === h && (t.x > o.x || (t.x === o.x && Sg(o, t))))) &&
              ((o = t), (h = u))),
            (t = t.next);
        while (t !== a);
        return o;
      }
      function Sg(r, e) {
        return $e(r.prev, r, e.prev) < 0 && $e(e.next, r, r.next) < 0;
      }
      function Tg(r, e, t, n) {
        let i = r;
        do
          i.z === null && (i.z = go(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
        while (i !== r);
        (i.prevZ.nextZ = null), (i.prevZ = null), Eg(i);
      }
      function Eg(r) {
        let e,
          t,
          n,
          i,
          s,
          o,
          a,
          l,
          c = 1;
        do {
          for (t = r, r = null, s = null, o = 0; t; ) {
            for (
              o++, n = t, a = 0, e = 0;
              e < c && (a++, (n = n.nextZ), !!n);
              e++
            );
            for (l = c; a > 0 || (l > 0 && n); )
              a !== 0 && (l === 0 || !n || t.z <= n.z)
                ? ((i = t), (t = t.nextZ), a--)
                : ((i = n), (n = n.nextZ), l--),
                s ? (s.nextZ = i) : (r = i),
                (i.prevZ = s),
                (s = i);
            t = n;
          }
          (s.nextZ = null), (c *= 2);
        } while (o > 1);
        return r;
      }
      function go(r, e, t, n, i) {
        return (
          (r = 32767 * (r - t) * i),
          (e = 32767 * (e - n) * i),
          (r = (r | (r << 8)) & 16711935),
          (r = (r | (r << 4)) & 252645135),
          (r = (r | (r << 2)) & 858993459),
          (r = (r | (r << 1)) & 1431655765),
          (e = (e | (e << 8)) & 16711935),
          (e = (e | (e << 4)) & 252645135),
          (e = (e | (e << 2)) & 858993459),
          (e = (e | (e << 1)) & 1431655765),
          r | (e << 1)
        );
      }
      function Ag(r) {
        let e = r,
          t = r;
        do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
        while (e !== r);
        return t;
      }
      function xi(r, e, t, n, i, s, o, a) {
        return (
          (i - o) * (e - a) - (r - o) * (s - a) >= 0 &&
          (r - o) * (n - a) - (t - o) * (e - a) >= 0 &&
          (t - o) * (s - a) - (i - o) * (n - a) >= 0
        );
      }
      function Rg(r, e) {
        return (
          r.next.i !== e.i &&
          r.prev.i !== e.i &&
          !Lg(r, e) &&
          ((cs(r, e) &&
            cs(e, r) &&
            Cg(r, e) &&
            ($e(r.prev, r, e.prev) || $e(r, e.prev, e))) ||
            (pr(r, e) &&
              $e(r.prev, r, r.next) > 0 &&
              $e(e.prev, e, e.next) > 0))
        );
      }
      function $e(r, e, t) {
        return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
      }
      function pr(r, e) {
        return r.x === e.x && r.y === e.y;
      }
      function _c(r, e, t, n) {
        const i = js($e(r, e, t)),
          s = js($e(r, e, n)),
          o = js($e(t, n, r)),
          a = js($e(t, n, e));
        return !!(
          (i !== s && o !== a) ||
          (i === 0 && Xs(r, t, e)) ||
          (s === 0 && Xs(r, n, e)) ||
          (o === 0 && Xs(t, r, n)) ||
          (a === 0 && Xs(t, e, n))
        );
      }
      function Xs(r, e, t) {
        return (
          e.x <= Math.max(r.x, t.x) &&
          e.x >= Math.min(r.x, t.x) &&
          e.y <= Math.max(r.y, t.y) &&
          e.y >= Math.min(r.y, t.y)
        );
      }
      function js(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function Lg(r, e) {
        let t = r;
        do {
          if (
            t.i !== r.i &&
            t.next.i !== r.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            _c(t, t.next, r, e)
          )
            return !0;
          t = t.next;
        } while (t !== r);
        return !1;
      }
      function cs(r, e) {
        return $e(r.prev, r, r.next) < 0
          ? $e(r, e, r.next) >= 0 && $e(r, r.prev, e) >= 0
          : $e(r, e, r.prev) < 0 || $e(r, r.next, e) < 0;
      }
      function Cg(r, e) {
        let t = r,
          n = !1;
        const i = (r.x + e.x) / 2,
          s = (r.y + e.y) / 2;
        do
          t.y > s != t.next.y > s &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
        while (t !== r);
        return n;
      }
      function xc(r, e) {
        const t = new _o(r.i, r.x, r.y),
          n = new _o(e.i, e.x, e.y),
          i = r.next,
          s = e.prev;
        return (
          (r.next = e),
          (e.prev = r),
          (t.next = i),
          (i.prev = t),
          (n.next = t),
          (t.prev = n),
          (s.next = n),
          (n.prev = s),
          n
        );
      }
      function Ml(r, e, t, n) {
        const i = new _o(r, e, t);
        return (
          n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function hs(r) {
        (r.next.prev = r.prev),
          (r.prev.next = r.next),
          r.prevZ && (r.prevZ.nextZ = r.nextZ),
          r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function _o(r, e, t) {
        (this.i = r),
          (this.x = e),
          (this.y = t),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function Pg(r, e, t, n) {
        let i = 0;
        for (let s = e, o = t - n; s < t; s += n)
          (i += (r[o] - r[s]) * (r[s + 1] + r[o + 1])), (o = s);
        return i;
      }
      class bn {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, s = 0; s < t; i = s++)
            n += e[i].x * e[s].y - e[s].x * e[i].y;
          return n * 0.5;
        }
        static isClockWise(e) {
          return bn.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            s = [];
          bl(e), wl(n, e);
          let o = e.length;
          t.forEach(bl);
          for (let l = 0; l < t.length; l++)
            i.push(o), (o += t[l].length), wl(n, t[l]);
          const a = mg.triangulate(n, i);
          for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
          return s;
        }
      }
      function bl(r) {
        const e = r.length;
        e > 2 && r[e - 1].equals(r[0]) && r.pop();
      }
      function wl(r, e) {
        for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
      }
      class Fi extends Ke {
        constructor(
          e = new ms([
            new $(0.5, 0.5),
            new $(-0.5, 0.5),
            new $(-0.5, -0.5),
            new $(0.5, -0.5),
          ]),
          t = {}
        ) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: e, options: t }),
            (e = Array.isArray(e) ? e : [e]);
          const n = this,
            i = [],
            s = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c);
          }
          this.setAttribute("position", new ct(i, 3)),
            this.setAttribute("uv", new ct(s, 2)),
            this.computeVertexNormals();
          function o(a) {
            const l = [],
              c = t.curveSegments !== void 0 ? t.curveSegments : 12,
              h = t.steps !== void 0 ? t.steps : 1;
            let u = t.depth !== void 0 ? t.depth : 1,
              d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
              f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
              g = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
              m = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
              p = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const _ = t.extrudePath,
              M = t.UVGenerator !== void 0 ? t.UVGenerator : Ig;
            t.amount !== void 0 &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (u = t.amount));
            let T,
              E = !1,
              w,
              R,
              P,
              y;
            _ &&
              ((T = _.getSpacedPoints(h)),
              (E = !0),
              (d = !1),
              (w = _.computeFrenetFrames(h, !1)),
              (R = new S()),
              (P = new S()),
              (y = new S())),
              d || ((p = 0), (f = 0), (g = 0), (m = 0));
            const L = a.extractPoints(c);
            let N = L.shape;
            const D = L.holes;
            if (!bn.isClockWise(N)) {
              N = N.reverse();
              for (let Y = 0, j = D.length; Y < j; Y++) {
                const te = D[Y];
                bn.isClockWise(te) && (D[Y] = te.reverse());
              }
            }
            const J = bn.triangulateShape(N, D),
              C = N;
            for (let Y = 0, j = D.length; Y < j; Y++) {
              const te = D[Y];
              N = N.concat(te);
            }
            function H(Y, j, te) {
              return (
                j || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                j.clone().multiplyScalar(te).add(Y)
              );
            }
            const B = N.length,
              V = J.length;
            function X(Y, j, te) {
              let fe, ce, Ee;
              const ve = Y.x - j.x,
                xe = Y.y - j.y,
                Je = te.x - Y.x,
                Ye = te.y - Y.y,
                b = ve * ve + xe * xe,
                x = ve * Ye - xe * Je;
              if (Math.abs(x) > Number.EPSILON) {
                const z = Math.sqrt(b),
                  Z = Math.sqrt(Je * Je + Ye * Ye),
                  le = j.x - xe / z,
                  ue = j.y + ve / z,
                  ye = te.x - Ye / Z,
                  G = te.y + Je / Z,
                  Re = ((ye - le) * Ye - (G - ue) * Je) / (ve * Ye - xe * Je);
                (fe = le + ve * Re - Y.x), (ce = ue + xe * Re - Y.y);
                const Pe = fe * fe + ce * ce;
                if (Pe <= 2) return new $(fe, ce);
                Ee = Math.sqrt(Pe / 2);
              } else {
                let z = !1;
                ve > Number.EPSILON
                  ? Je > Number.EPSILON && (z = !0)
                  : ve < -Number.EPSILON
                  ? Je < -Number.EPSILON && (z = !0)
                  : Math.sign(xe) === Math.sign(Ye) && (z = !0),
                  z
                    ? ((fe = -xe), (ce = ve), (Ee = Math.sqrt(b)))
                    : ((fe = ve), (ce = xe), (Ee = Math.sqrt(b / 2)));
              }
              return new $(fe / Ee, ce / Ee);
            }
            const U = [];
            for (
              let Y = 0, j = C.length, te = j - 1, fe = Y + 1;
              Y < j;
              Y++, te++, fe++
            )
              te === j && (te = 0),
                fe === j && (fe = 0),
                (U[Y] = X(C[Y], C[te], C[fe]));
            const W = [];
            let Q,
              K = U.concat();
            for (let Y = 0, j = D.length; Y < j; Y++) {
              const te = D[Y];
              Q = [];
              for (
                let fe = 0, ce = te.length, Ee = ce - 1, ve = fe + 1;
                fe < ce;
                fe++, Ee++, ve++
              )
                Ee === ce && (Ee = 0),
                  ve === ce && (ve = 0),
                  (Q[fe] = X(te[fe], te[Ee], te[ve]));
              W.push(Q), (K = K.concat(Q));
            }
            for (let Y = 0; Y < p; Y++) {
              const j = Y / p,
                te = f * Math.cos((j * Math.PI) / 2),
                fe = g * Math.sin((j * Math.PI) / 2) + m;
              for (let ce = 0, Ee = C.length; ce < Ee; ce++) {
                const ve = H(C[ce], U[ce], fe);
                He(ve.x, ve.y, -te);
              }
              for (let ce = 0, Ee = D.length; ce < Ee; ce++) {
                const ve = D[ce];
                Q = W[ce];
                for (let xe = 0, Je = ve.length; xe < Je; xe++) {
                  const Ye = H(ve[xe], Q[xe], fe);
                  He(Ye.x, Ye.y, -te);
                }
              }
            }
            const ee = g + m;
            for (let Y = 0; Y < B; Y++) {
              const j = d ? H(N[Y], K[Y], ee) : N[Y];
              E
                ? (P.copy(w.normals[0]).multiplyScalar(j.x),
                  R.copy(w.binormals[0]).multiplyScalar(j.y),
                  y.copy(T[0]).add(P).add(R),
                  He(y.x, y.y, y.z))
                : He(j.x, j.y, 0);
            }
            for (let Y = 1; Y <= h; Y++)
              for (let j = 0; j < B; j++) {
                const te = d ? H(N[j], K[j], ee) : N[j];
                E
                  ? (P.copy(w.normals[Y]).multiplyScalar(te.x),
                    R.copy(w.binormals[Y]).multiplyScalar(te.y),
                    y.copy(T[Y]).add(P).add(R),
                    He(y.x, y.y, y.z))
                  : He(te.x, te.y, (u / h) * Y);
              }
            for (let Y = p - 1; Y >= 0; Y--) {
              const j = Y / p,
                te = f * Math.cos((j * Math.PI) / 2),
                fe = g * Math.sin((j * Math.PI) / 2) + m;
              for (let ce = 0, Ee = C.length; ce < Ee; ce++) {
                const ve = H(C[ce], U[ce], fe);
                He(ve.x, ve.y, u + te);
              }
              for (let ce = 0, Ee = D.length; ce < Ee; ce++) {
                const ve = D[ce];
                Q = W[ce];
                for (let xe = 0, Je = ve.length; xe < Je; xe++) {
                  const Ye = H(ve[xe], Q[xe], fe);
                  E
                    ? He(Ye.x, Ye.y + T[h - 1].y, T[h - 1].x + te)
                    : He(Ye.x, Ye.y, u + te);
                }
              }
            }
            ge(), _e();
            function ge() {
              const Y = i.length / 3;
              if (d) {
                let j = 0,
                  te = B * j;
                for (let fe = 0; fe < V; fe++) {
                  const ce = J[fe];
                  be(ce[2] + te, ce[1] + te, ce[0] + te);
                }
                (j = h + p * 2), (te = B * j);
                for (let fe = 0; fe < V; fe++) {
                  const ce = J[fe];
                  be(ce[0] + te, ce[1] + te, ce[2] + te);
                }
              } else {
                for (let j = 0; j < V; j++) {
                  const te = J[j];
                  be(te[2], te[1], te[0]);
                }
                for (let j = 0; j < V; j++) {
                  const te = J[j];
                  be(te[0] + B * h, te[1] + B * h, te[2] + B * h);
                }
              }
              n.addGroup(Y, i.length / 3 - Y, 0);
            }
            function _e() {
              const Y = i.length / 3;
              let j = 0;
              k(C, j), (j += C.length);
              for (let te = 0, fe = D.length; te < fe; te++) {
                const ce = D[te];
                k(ce, j), (j += ce.length);
              }
              n.addGroup(Y, i.length / 3 - Y, 1);
            }
            function k(Y, j) {
              let te = Y.length;
              for (; --te >= 0; ) {
                const fe = te;
                let ce = te - 1;
                ce < 0 && (ce = Y.length - 1);
                for (let Ee = 0, ve = h + p * 2; Ee < ve; Ee++) {
                  const xe = B * Ee,
                    Je = B * (Ee + 1),
                    Ye = j + fe + xe,
                    b = j + ce + xe,
                    x = j + ce + Je,
                    z = j + fe + Je;
                  Le(Ye, b, x, z);
                }
              }
            }
            function He(Y, j, te) {
              l.push(Y), l.push(j), l.push(te);
            }
            function be(Y, j, te) {
              se(Y), se(j), se(te);
              const fe = i.length / 3,
                ce = M.generateTopUV(n, i, fe - 3, fe - 2, fe - 1);
              Ne(ce[0]), Ne(ce[1]), Ne(ce[2]);
            }
            function Le(Y, j, te, fe) {
              se(Y), se(j), se(fe), se(j), se(te), se(fe);
              const ce = i.length / 3,
                Ee = M.generateSideWallUV(n, i, ce - 6, ce - 3, ce - 2, ce - 1);
              Ne(Ee[0]), Ne(Ee[1]), Ne(Ee[3]), Ne(Ee[1]), Ne(Ee[2]), Ne(Ee[3]);
            }
            function se(Y) {
              i.push(l[Y * 3 + 0]), i.push(l[Y * 3 + 1]), i.push(l[Y * 3 + 2]);
            }
            function Ne(Y) {
              s.push(Y.x), s.push(Y.y);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
          return Dg(t, n, e);
        }
        static fromJSON(e, t) {
          const n = [];
          for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            n.push(a);
          }
          const i = e.options.extrudePath;
          return (
            i !== void 0 &&
              (e.options.extrudePath = new mc[i.type]().fromJSON(i)),
            new Fi(n, e.options)
          );
        }
      }
      const Ig = {
        generateTopUV: function (r, e, t, n, i) {
          const s = e[t * 3],
            o = e[t * 3 + 1],
            a = e[n * 3],
            l = e[n * 3 + 1],
            c = e[i * 3],
            h = e[i * 3 + 1];
          return [new $(s, o), new $(a, l), new $(c, h)];
        },
        generateSideWallUV: function (r, e, t, n, i, s) {
          const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[n * 3],
            h = e[n * 3 + 1],
            u = e[n * 3 + 2],
            d = e[i * 3],
            f = e[i * 3 + 1],
            g = e[i * 3 + 2],
            m = e[s * 3],
            p = e[s * 3 + 1],
            _ = e[s * 3 + 2];
          return Math.abs(a - h) < Math.abs(o - c)
            ? [
                new $(o, 1 - l),
                new $(c, 1 - u),
                new $(d, 1 - g),
                new $(m, 1 - _),
              ]
            : [
                new $(a, 1 - l),
                new $(h, 1 - u),
                new $(f, 1 - g),
                new $(p, 1 - _),
              ];
        },
      };
      function Dg(r, e, t) {
        if (((t.shapes = []), Array.isArray(r)))
          for (let n = 0, i = r.length; n < i; n++) {
            const s = r[n];
            t.shapes.push(s.uuid);
          }
        else t.shapes.push(r.uuid);
        return (
          e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
          t
        );
      }
      class ko extends Ke {
        constructor(
          e = new ms([new $(0, 0.5), new $(-0.5, -0.5), new $(0.5, -0.5)]),
          t = 12
        ) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: e, curveSegments: t });
          const n = [],
            i = [],
            s = [],
            o = [];
          let a = 0,
            l = 0;
          if (Array.isArray(e) === !1) c(e);
          else
            for (let h = 0; h < e.length; h++)
              c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
          this.setIndex(n),
            this.setAttribute("position", new ct(i, 3)),
            this.setAttribute("normal", new ct(s, 3)),
            this.setAttribute("uv", new ct(o, 2));
          function c(h) {
            const u = i.length / 3,
              d = h.extractPoints(t);
            let f = d.shape;
            const g = d.holes;
            bn.isClockWise(f) === !1 && (f = f.reverse());
            for (let p = 0, _ = g.length; p < _; p++) {
              const M = g[p];
              bn.isClockWise(M) === !0 && (g[p] = M.reverse());
            }
            const m = bn.triangulateShape(f, g);
            for (let p = 0, _ = g.length; p < _; p++) {
              const M = g[p];
              f = f.concat(M);
            }
            for (let p = 0, _ = f.length; p < _; p++) {
              const M = f[p];
              i.push(M.x, M.y, 0), s.push(0, 0, 1), o.push(M.x, M.y);
            }
            for (let p = 0, _ = m.length; p < _; p++) {
              const M = m[p],
                T = M[0] + u,
                E = M[1] + u,
                w = M[2] + u;
              n.push(T, E, w), (l += 3);
            }
          }
        }
        toJSON() {
          const e = super.toJSON(),
            t = this.parameters.shapes;
          return Fg(t, e);
        }
        static fromJSON(e, t) {
          const n = [];
          for (let i = 0, s = e.shapes.length; i < s; i++) {
            const o = t[e.shapes[i]];
            n.push(o);
          }
          return new ko(n, e.curveSegments);
        }
      }
      function Fg(r, e) {
        if (((e.shapes = []), Array.isArray(r)))
          for (let t = 0, n = r.length; t < n; t++) {
            const i = r[t];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(r.uuid);
        return e;
      }
      class yc extends et {
        constructor(e) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new he(0)),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this
          );
        }
      }
      yc.prototype.isShadowMaterial = !0;
      class vc extends Bt {
        constructor(e) {
          super(e), (this.type = "RawShaderMaterial");
        }
      }
      vc.prototype.isRawShaderMaterial = !0;
      class Ni extends et {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new he(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new he(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Gn),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      Ni.prototype.isMeshStandardMaterial = !0;
      class En extends Ni {
        constructor(e) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new $(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return ut((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.sheenColor = new he(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new he(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new he(1, 1, 1)),
            (this.specularColorMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.ior = e.ior),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      En.prototype.isMeshPhysicalMaterial = !0;
      class Mc extends et {
        constructor(e) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new he(16777215)),
            (this.specular = new he(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new he(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Gn),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = nr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      Mc.prototype.isMeshPhongMaterial = !0;
      class bc extends et {
        constructor(e) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new he(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new he(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Gn),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      bc.prototype.isMeshToonMaterial = !0;
      class wc extends et {
        constructor(e) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Gn),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      wc.prototype.isMeshNormalMaterial = !0;
      class Sc extends et {
        constructor(e) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new he(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new he(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = nr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      Sc.prototype.isMeshLambertMaterial = !0;
      class Tc extends et {
        constructor(e) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new he(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Gn),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      Tc.prototype.isMeshMatcapMaterial = !0;
      class Ec extends Xn {
        constructor(e) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
          );
        }
      }
      Ec.prototype.isLineDashedMaterial = !0;
      const Ng = {
        ShadowMaterial: yc,
        SpriteMaterial: Fo,
        RawShaderMaterial: vc,
        ShaderMaterial: Bt,
        PointsMaterial: ur,
        MeshPhysicalMaterial: En,
        MeshStandardMaterial: Ni,
        MeshPhongMaterial: Mc,
        MeshToonMaterial: bc,
        MeshNormalMaterial: wc,
        MeshLambertMaterial: Sc,
        MeshDepthMaterial: Po,
        MeshDistanceMaterial: Io,
        MeshBasicMaterial: sn,
        MeshMatcapMaterial: Tc,
        LineDashedMaterial: Ec,
        LineBasicMaterial: Xn,
        Material: et,
      };
      et.fromType = function (r) {
        return new Ng[r]();
      };
      const Ze = {
        arraySlice: function (r, e, t) {
          return Ze.isTypedArray(r)
            ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
            : r.slice(e, t);
        },
        convertArray: function (r, e, t) {
          return !r || (!t && r.constructor === e)
            ? r
            : typeof e.BYTES_PER_ELEMENT == "number"
            ? new e(r)
            : Array.prototype.slice.call(r);
        },
        isTypedArray: function (r) {
          return ArrayBuffer.isView(r) && !(r instanceof DataView);
        },
        getKeyframeOrder: function (r) {
          function e(i, s) {
            return r[i] - r[s];
          }
          const t = r.length,
            n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = i;
          return n.sort(e), n;
        },
        sortedArray: function (r, e, t) {
          const n = r.length,
            i = new r.constructor(n);
          for (let s = 0, o = 0; o !== n; ++s) {
            const a = t[s] * e;
            for (let l = 0; l !== e; ++l) i[o++] = r[a + l];
          }
          return i;
        },
        flattenJSON: function (r, e, t, n) {
          let i = 1,
            s = r[0];
          for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
          if (s === void 0) return;
          let o = s[n];
          if (o !== void 0)
            if (Array.isArray(o))
              do
                (o = s[n]),
                  o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
                  (s = r[i++]);
              while (s !== void 0);
            else if (o.toArray !== void 0)
              do
                (o = s[n]),
                  o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
                  (s = r[i++]);
              while (s !== void 0);
            else
              do
                (o = s[n]),
                  o !== void 0 && (e.push(s.time), t.push(o)),
                  (s = r[i++]);
              while (s !== void 0);
        },
        subclip: function (r, e, t, n, i = 30) {
          const s = r.clone();
          s.name = e;
          const o = [];
          for (let l = 0; l < s.tracks.length; ++l) {
            const c = s.tracks[l],
              h = c.getValueSize(),
              u = [],
              d = [];
            for (let f = 0; f < c.times.length; ++f) {
              const g = c.times[f] * i;
              if (!(g < t || g >= n)) {
                u.push(c.times[f]);
                for (let m = 0; m < h; ++m) d.push(c.values[f * h + m]);
              }
            }
            u.length !== 0 &&
              ((c.times = Ze.convertArray(u, c.times.constructor)),
              (c.values = Ze.convertArray(d, c.values.constructor)),
              o.push(c));
          }
          s.tracks = o;
          let a = 1 / 0;
          for (let l = 0; l < s.tracks.length; ++l)
            a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
          for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
          return s.resetDuration(), s;
        },
        makeClipAdditive: function (r, e = 0, t = r, n = 30) {
          n <= 0 && (n = 30);
          const i = t.tracks.length,
            s = e / n;
          for (let o = 0; o < i; ++o) {
            const a = t.tracks[o],
              l = a.ValueTypeName;
            if (l === "bool" || l === "string") continue;
            const c = r.tracks.find(function (_) {
              return _.name === a.name && _.ValueTypeName === l;
            });
            if (c === void 0) continue;
            let h = 0;
            const u = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (h = u / 3);
            let d = 0;
            const f = c.getValueSize();
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (d = f / 3);
            const g = a.times.length - 1;
            let m;
            if (s <= a.times[0]) {
              const _ = h,
                M = u - h;
              m = Ze.arraySlice(a.values, _, M);
            } else if (s >= a.times[g]) {
              const _ = g * u + h,
                M = _ + u - h;
              m = Ze.arraySlice(a.values, _, M);
            } else {
              const _ = a.createInterpolant(),
                M = h,
                T = u - h;
              _.evaluate(s), (m = Ze.arraySlice(_.resultBuffer, M, T));
            }
            l === "quaternion" &&
              new yt().fromArray(m).normalize().conjugate().toArray(m);
            const p = c.times.length;
            for (let _ = 0; _ < p; ++_) {
              const M = _ * f + d;
              if (l === "quaternion")
                yt.multiplyQuaternionsFlat(c.values, M, m, 0, c.values, M);
              else {
                const T = f - d * 2;
                for (let E = 0; E < T; ++E) c.values[M + E] -= m[E];
              }
            }
          }
          return (r.blendMode = kl), r;
        },
      };
      class on {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            s = t[n - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < i)) {
                  for (let a = n + 2; ; ) {
                    if (i === void 0) {
                      if (e < s) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, e, s)
                      );
                    }
                    if (n === a) break;
                    if (((s = i), (i = t[++n]), e < i)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (!(e >= s)) {
                  const a = t[1];
                  e < a && ((n = 2), (s = a));
                  for (let l = n - 2; ; ) {
                    if (s === void 0)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                      );
                    if (n === l) break;
                    if (((i = s), (s = t[--n - 1]), e >= s)) break t;
                  }
                  (o = n), (n = 0);
                  break n;
                }
                break e;
              }
              for (; n < o; ) {
                const a = (n + o) >>> 1;
                e < t[a] ? (o = a) : (n = a + 1);
              }
              if (((i = t[n]), (s = t[n - 1]), s === void 0))
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (i === void 0)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, s, e)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, s, i);
          }
          return this.interpolate_(n, s, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = e * i;
          for (let o = 0; o !== i; ++o) t[o] = n[s + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      on.prototype.beforeStart_ = on.prototype.copySampleValue_;
      on.prototype.afterEnd_ = on.prototype.copySampleValue_;
      class Bg extends on {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: mi, endingEnd: mi });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let s = e - 2,
            o = e + 1,
            a = i[s],
            l = i[o];
          if (a === void 0)
            switch (this.getSettings_().endingStart) {
              case gi:
                (s = e), (a = 2 * t - n);
                break;
              case Qs:
                (s = i.length - 2), (a = t + i[s] - i[s + 1]);
                break;
              default:
                (s = e), (a = n);
            }
          if (l === void 0)
            switch (this.getSettings_().endingEnd) {
              case gi:
                (o = e), (l = 2 * n - t);
                break;
              case Qs:
                (o = 1), (l = n + i[1] - i[0]);
                break;
              default:
                (o = e - 1), (l = t);
            }
          const c = (n - t) * 0.5,
            h = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - n)),
            (this._offsetPrev = s * h),
            (this._offsetNext = o * h);
        }
        interpolate_(e, t, n, i) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = this._offsetPrev,
            u = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            g = (n - t) / (i - t),
            m = g * g,
            p = m * g,
            _ = -d * p + 2 * d * m - d * g,
            M = (1 + d) * p + (-1.5 - 2 * d) * m + (-0.5 + d) * g + 1,
            T = (-1 - f) * p + (1.5 + f) * m + 0.5 * g,
            E = f * p - f * m;
          for (let w = 0; w !== a; ++w)
            s[w] = _ * o[h + w] + M * o[c + w] + T * o[l + w] + E * o[u + w];
          return s;
        }
      }
      class Ac extends on {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            h = (n - t) / (i - t),
            u = 1 - h;
          for (let d = 0; d !== a; ++d) s[d] = o[c + d] * u + o[l + d] * h;
          return s;
        }
      }
      class Og extends on {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class Xt {
        constructor(e, t, n, i) {
          if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = Ze.convertArray(t, this.TimeBufferType)),
            (this.values = Ze.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: Ze.convertArray(e.times, Array),
              values: Ze.convertArray(e.values, Array),
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new Og(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new Ac(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new Bg(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case ss:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case Ei:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case br:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return ss;
            case this.InterpolantFactoryMethodLinear:
              return Ei;
            case this.InterpolantFactoryMethodSmooth:
              return br;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let s = 0,
            o = i - 1;
          for (; s !== i && n[s] < e; ) ++s;
          for (; o !== -1 && n[o] > t; ) --o;
          if ((++o, s !== 0 || o !== i)) {
            s >= o && ((o = Math.max(o, 1)), (s = o - 1));
            const a = this.getValueSize();
            (this.times = Ze.arraySlice(n, s, o)),
              (this.values = Ze.arraySlice(this.values, s * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            s = n.length;
          s === 0 &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== s; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l
              ),
                (e = !1);
              break;
            }
            if (o !== null && o > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                o
              ),
                (e = !1);
              break;
            }
            o = l;
          }
          if (i !== void 0 && Ze.isTypedArray(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
              const c = i[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = Ze.arraySlice(this.times),
            t = Ze.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === br,
            s = e.length - 1;
          let o = 1;
          for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a],
              h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0]))
              if (i) l = !0;
              else {
                const u = a * n,
                  d = u - n,
                  f = u + n;
                for (let g = 0; g !== n; ++g) {
                  const m = t[u + g];
                  if (m !== t[d + g] || m !== t[f + g]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== o) {
                e[o] = e[a];
                const u = a * n,
                  d = o * n;
                for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
              }
              ++o;
            }
          }
          if (s > 0) {
            e[o] = e[s];
            for (let a = s * n, l = o * n, c = 0; c !== n; ++c)
              t[l + c] = t[a + c];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = Ze.arraySlice(e, 0, o)),
                (this.values = Ze.arraySlice(t, 0, o * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = Ze.arraySlice(this.times, 0),
            t = Ze.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, e, t);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      Xt.prototype.TimeBufferType = Float32Array;
      Xt.prototype.ValueBufferType = Float32Array;
      Xt.prototype.DefaultInterpolation = Ei;
      class Bi extends Xt {}
      Bi.prototype.ValueTypeName = "bool";
      Bi.prototype.ValueBufferType = Array;
      Bi.prototype.DefaultInterpolation = ss;
      Bi.prototype.InterpolantFactoryMethodLinear = void 0;
      Bi.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Rc extends Xt {}
      Rc.prototype.ValueTypeName = "color";
      class us extends Xt {}
      us.prototype.ValueTypeName = "number";
      class Ug extends on {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (n - t) / (i - t);
          let c = e * a;
          for (let h = c + a; c !== h; c += 4)
            yt.slerpFlat(s, 0, o, c - a, o, c, l);
          return s;
        }
      }
      class zn extends Xt {
        InterpolantFactoryMethodLinear(e) {
          return new Ug(this.times, this.values, this.getValueSize(), e);
        }
      }
      zn.prototype.ValueTypeName = "quaternion";
      zn.prototype.DefaultInterpolation = Ei;
      zn.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Oi extends Xt {}
      Oi.prototype.ValueTypeName = "string";
      Oi.prototype.ValueBufferType = Array;
      Oi.prototype.DefaultInterpolation = ss;
      Oi.prototype.InterpolantFactoryMethodLinear = void 0;
      Oi.prototype.InterpolantFactoryMethodSmooth = void 0;
      class ds extends Xt {}
      ds.prototype.ValueTypeName = "vector";
      class xo {
        constructor(e, t = -1, n, i = wo) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = Rt()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let o = 0, a = n.length; o !== a; ++o) t.push(Hg(n[o]).scale(i));
          const s = new this(e.name, e.duration, t, e.blendMode);
          return (s.uuid = e.uuid), s;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let s = 0, o = n.length; s !== o; ++s) t.push(Xt.toJSON(n[s]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const s = t.length,
            o = [];
          for (let a = 0; a < s; a++) {
            let l = [],
              c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            const h = Ze.getKeyframeOrder(l);
            (l = Ze.sortedArray(l, 1, h)),
              (c = Ze.sortedArray(c, 1, h)),
              !i && l[0] === 0 && (l.push(s), c.push(c[0])),
              o.push(
                new us(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, o);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            s = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = c.name.match(s);
            if (h && h.length > 1) {
              const u = h[1];
              let d = i[u];
              d || (i[u] = d = []), d.push(c);
            }
          }
          const o = [];
          for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
          return o;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (u, d, f, g, m) {
              if (f.length !== 0) {
                const p = [],
                  _ = [];
                Ze.flattenJSON(f, p, _, g),
                  p.length !== 0 && m.push(new u(d, p, _));
              }
            },
            i = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0))
              if (d[0].morphTargets) {
                const f = {};
                let g;
                for (g = 0; g < d.length; g++)
                  if (d[g].morphTargets)
                    for (let m = 0; m < d[g].morphTargets.length; m++)
                      f[d[g].morphTargets[m]] = -1;
                for (const m in f) {
                  const p = [],
                    _ = [];
                  for (let M = 0; M !== d[g].morphTargets.length; ++M) {
                    const T = d[g];
                    p.push(T.time), _.push(T.morphTarget === m ? 1 : 0);
                  }
                  i.push(new us(".morphTargetInfluence[" + m + "]", p, _));
                }
                l = f.length * o;
              } else {
                const f = ".bones[" + t[u].name + "]";
                n(ds, f + ".position", d, "pos", i),
                  n(zn, f + ".quaternion", d, "rot", i),
                  n(ds, f + ".scale", d, "scl", i);
              }
          }
          return i.length === 0 ? null : new this(s, l, i, a);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const s = this.tracks[n];
            t = Math.max(t, s.times[s.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function zg(r) {
        switch (r.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return us;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return ds;
          case "color":
            return Rc;
          case "quaternion":
            return zn;
          case "bool":
          case "boolean":
            return Bi;
          case "string":
            return Oi;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
      }
      function Hg(r) {
        if (r.type === void 0)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = zg(r.type);
        if (r.times === void 0) {
          const t = [],
            n = [];
          Ze.flattenJSON(r.keys, t, n, "value"), (r.times = t), (r.values = n);
        }
        return e.parse !== void 0
          ? e.parse(r)
          : new e(r.name, r.times, r.values, r.interpolation);
      }
      const Li = {
        enabled: !1,
        files: {},
        add: function (r, e) {
          this.enabled !== !1 && (this.files[r] = e);
        },
        get: function (r) {
          if (this.enabled !== !1) return this.files[r];
        },
        remove: function (r) {
          delete this.files[r];
        },
        clear: function () {
          this.files = {};
        },
      };
      class Gg {
        constructor(e, t, n) {
          const i = this;
          let s = !1,
            o = 0,
            a = 0,
            l;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (h) {
              a++,
                s === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
                (s = !0);
            }),
            (this.itemEnd = function (h) {
              o++,
                i.onProgress !== void 0 && i.onProgress(h, o, a),
                o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
            }),
            (this.itemError = function (h) {
              i.onError !== void 0 && i.onError(h);
            }),
            (this.resolveURL = function (h) {
              return l ? l(h) : h;
            }),
            (this.setURLModifier = function (h) {
              return (l = h), this;
            }),
            (this.addHandler = function (h, u) {
              return c.push(h, u), this;
            }),
            (this.removeHandler = function (h) {
              const u = c.indexOf(h);
              return u !== -1 && c.splice(u, 2), this;
            }),
            (this.getHandler = function (h) {
              for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u],
                  g = c[u + 1];
                if ((f.global && (f.lastIndex = 0), f.test(h))) return g;
              }
              return null;
            });
        }
      }
      const kg = new Gg();
      class an {
        constructor(e) {
          (this.manager = e !== void 0 ? e : kg),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, s) {
            n.load(e, i, t, s);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      const $t = {};
      class Vo extends an {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = Li.get(e);
          if (s !== void 0)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(s), this.manager.itemEnd(e);
              }, 0),
              s
            );
          if ($t[e] !== void 0) {
            $t[e].push({ onLoad: t, onProgress: n, onError: i });
            return;
          }
          ($t[e] = []), $t[e].push({ onLoad: t, onProgress: n, onError: i });
          const o = new Request(e, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            l = this.responseType;
          fetch(o)
            .then((c) => {
              if (c.status === 200 || c.status === 0) {
                if (
                  (c.status === 0 &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  typeof ReadableStream == "undefined" ||
                    c.body === void 0 ||
                    c.body.getReader === void 0)
                )
                  return c;
                const h = $t[e],
                  u = c.body.getReader(),
                  d = c.headers.get("Content-Length"),
                  f = d ? parseInt(d) : 0,
                  g = f !== 0;
                let m = 0;
                const p = new ReadableStream({
                  start(_) {
                    M();
                    function M() {
                      u.read().then(({ done: T, value: E }) => {
                        if (T) _.close();
                        else {
                          m += E.byteLength;
                          const w = new ProgressEvent("progress", {
                            lengthComputable: g,
                            loaded: m,
                            total: f,
                          });
                          for (let R = 0, P = h.length; R < P; R++) {
                            const y = h[R];
                            y.onProgress && y.onProgress(w);
                          }
                          _.enqueue(E), M();
                        }
                      });
                    }
                  },
                });
                return new Response(p);
              } else
                throw Error(
                  `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`
                );
            })
            .then((c) => {
              switch (l) {
                case "arraybuffer":
                  return c.arrayBuffer();
                case "blob":
                  return c.blob();
                case "document":
                  return c
                    .text()
                    .then((h) => new DOMParser().parseFromString(h, a));
                case "json":
                  return c.json();
                default:
                  if (a === void 0) return c.text();
                  {
                    const u = /charset="?([^;"\s]*)"?/i.exec(a),
                      d = u && u[1] ? u[1].toLowerCase() : void 0,
                      f = new TextDecoder(d);
                    return c.arrayBuffer().then((g) => f.decode(g));
                  }
              }
            })
            .then((c) => {
              Li.add(e, c);
              const h = $t[e];
              delete $t[e];
              for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onLoad && f.onLoad(c);
              }
            })
            .catch((c) => {
              const h = $t[e];
              if (h === void 0) throw (this.manager.itemError(e), c);
              delete $t[e];
              for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onError && f.onError(c);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class Lc extends an {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = this,
            o = Li.get(e);
          if (o !== void 0)
            return (
              s.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), s.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = as("img");
          function l() {
            h(), Li.add(e, this), t && t(this), s.manager.itemEnd(e);
          }
          function c(u) {
            h(), i && i(u), s.manager.itemError(e), s.manager.itemEnd(e);
          }
          function h() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            e.slice(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class Vg extends an {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const s = new rr(),
            o = new Lc(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let a = 0;
          function l(c) {
            o.load(
              e[c],
              function (h) {
                (s.images[c] = h),
                  a++,
                  a === 6 && ((s.needsUpdate = !0), t && t(s));
              },
              void 0,
              i
            );
          }
          for (let c = 0; c < e.length; ++c) l(c);
          return s;
        }
      }
      class Cc extends an {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const s = new rt(),
            o = new Lc(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
              },
              n,
              i
            ),
            s
          );
        }
      }
      class qt extends Ve {
        constructor(e, t = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new he(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      qt.prototype.isLight = !0;
      class Wg extends qt {
        constructor(e, t, n) {
          super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Ve.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new he(t));
        }
        copy(e) {
          return (
            qt.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
          );
        }
      }
      Wg.prototype.isHemisphereLight = !0;
      const Sl = new me(),
        Tl = new S(),
        El = new S();
      class Wo {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new $(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new me()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new or()),
            (this._frameExtents = new $(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new je(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          Tl.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(Tl),
            El.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(El),
            t.updateMatrixWorld(),
            Sl.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Sl),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class Pc extends Wo {
        constructor() {
          super(new mt(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = os * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
          (n !== t.fov || i !== t.aspect || s !== t.far) &&
            ((t.fov = n),
            (t.aspect = i),
            (t.far = s),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      Pc.prototype.isSpotLightShadow = !0;
      class Ic extends qt {
        constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 1) {
          super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(Ve.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ve()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = s),
            (this.decay = o),
            (this.shadow = new Pc());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Ic.prototype.isSpotLight = !0;
      const Al = new me(),
        ji = new S(),
        to = new S();
      class Dc extends Wo {
        constructor() {
          super(new mt(90, 1, 0.5, 500)),
            (this._frameExtents = new $(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new je(2, 1, 1, 1),
              new je(0, 1, 1, 1),
              new je(3, 1, 1, 1),
              new je(1, 1, 1, 1),
              new je(3, 0, 1, 1),
              new je(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new S(1, 0, 0),
              new S(-1, 0, 0),
              new S(0, 0, 1),
              new S(0, 0, -1),
              new S(0, 1, 0),
              new S(0, -1, 0),
            ]),
            (this._cubeUps = [
              new S(0, 1, 0),
              new S(0, 1, 0),
              new S(0, 1, 0),
              new S(0, 1, 0),
              new S(0, 0, 1),
              new S(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            s = e.distance || n.far;
          s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
            ji.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(ji),
            to.copy(n.position),
            to.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(to),
            n.updateMatrixWorld(),
            i.makeTranslation(-ji.x, -ji.y, -ji.z),
            Al.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Al);
        }
      }
      Dc.prototype.isPointLightShadow = !0;
      class Fc extends qt {
        constructor(e, t, n = 0, i = 1) {
          super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Dc());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      Fc.prototype.isPointLight = !0;
      class Nc extends Wo {
        constructor() {
          super(new ar(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Nc.prototype.isDirectionalLightShadow = !0;
      class qo extends qt {
        constructor(e, t) {
          super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(Ve.DefaultUp),
            this.updateMatrix(),
            (this.target = new Ve()),
            (this.shadow = new Nc());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      qo.prototype.isDirectionalLight = !0;
      class Bc extends qt {
        constructor(e, t) {
          super(e, t), (this.type = "AmbientLight");
        }
      }
      Bc.prototype.isAmbientLight = !0;
      class qg extends qt {
        constructor(e, t, n = 10, i = 10) {
          super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(e) {
          this.intensity = e / (this.width * this.height * Math.PI);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.width = this.width), (t.object.height = this.height), t
          );
        }
      }
      qg.prototype.isRectAreaLight = !0;
      class Oc {
        constructor() {
          this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new S());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const n = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * i),
            t.addScaledVector(o[2], 0.488603 * s),
            t.addScaledVector(o[3], 0.488603 * n),
            t.addScaledVector(o[4], 1.092548 * (n * i)),
            t.addScaledVector(o[5], 1.092548 * (i * s)),
            t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
            t.addScaledVector(o[7], 1.092548 * (n * s)),
            t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            t
          );
        }
        getIrradianceAt(e, t) {
          const n = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
          return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * i),
            t.addScaledVector(o[2], 2 * 0.511664 * s),
            t.addScaledVector(o[3], 2 * 0.511664 * n),
            t.addScaledVector(o[4], 2 * 0.429043 * n * i),
            t.addScaledVector(o[5], 2 * 0.429043 * i * s),
            t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * n * s),
            t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            t
          );
        }
        add(e) {
          for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
          return !0;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const n = e.x,
            i = e.y,
            s = e.z;
          (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * s),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * s),
            (t[6] = 0.315392 * (3 * s * s - 1)),
            (t[7] = 1.092548 * n * s),
            (t[8] = 0.546274 * (n * n - i * i));
        }
      }
      Oc.prototype.isSphericalHarmonics3 = !0;
      class Xo extends qt {
        constructor(e = new Oc(), t = 1) {
          super(void 0, t), (this.sh = e);
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (t.object.sh = this.sh.toArray()), t;
        }
      }
      Xo.prototype.isLightProbe = !0;
      class wn {
        static decodeText(e) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return typeof e != "string" || e === ""
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
      }
      class Xg extends Ke {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(e) {
          return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = super.toJSON(this);
          return (
            (e.instanceCount = this.instanceCount),
            (e.isInstancedBufferGeometry = !0),
            e
          );
        }
      }
      Xg.prototype.isInstancedBufferGeometry = !0;
      class Uc extends an {
        constructor(e) {
          super(e),
            typeof createImageBitmap == "undefined" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch == "undefined" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = this,
            o = Li.get(e);
          if (o !== void 0)
            return (
              s.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), s.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = {};
          (a.credentials =
            this.crossOrigin === "anonymous" ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (l) {
                return l.blob();
              })
              .then(function (l) {
                return createImageBitmap(
                  l,
                  Object.assign(s.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (l) {
                Li.add(e, l), t && t(l), s.manager.itemEnd(e);
              })
              .catch(function (l) {
                i && i(l), s.manager.itemError(e), s.manager.itemEnd(e);
              }),
            s.manager.itemStart(e);
        }
      }
      Uc.prototype.isImageBitmapLoader = !0;
      let Ys;
      const jg = {
        getContext: function () {
          return (
            Ys === void 0 &&
              (Ys = new (window.AudioContext || window.webkitAudioContext)()),
            Ys
          );
        },
        setContext: function (r) {
          Ys = r;
        },
      };
      class Yg extends an {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const s = this,
            o = new Vo(this.manager);
          o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (a) {
                try {
                  const l = a.slice(0);
                  jg.getContext().decodeAudioData(l, function (h) {
                    t(h);
                  });
                } catch (l) {
                  i ? i(l) : console.error(l), s.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
      }
      class Jg extends Xo {
        constructor(e, t, n = 1) {
          super(void 0, n);
          const i = new he().set(e),
            s = new he().set(t),
            o = new S(i.r, i.g, i.b),
            a = new S(s.r, s.g, s.b),
            l = Math.sqrt(Math.PI),
            c = l * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
            this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
        }
      }
      Jg.prototype.isHemisphereLightProbe = !0;
      class Kg extends Xo {
        constructor(e, t = 1) {
          super(void 0, t);
          const n = new he().set(e);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Kg.prototype.isAmbientLightProbe = !0;
      class Zg extends Ve {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            this.isPlaying === !0 &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.loop === !0 &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop() {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            this._connected === !0
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), this.source.detune !== void 0))
            return (
              this.isPlaying === !0 &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = e),
            this.isPlaying === !0 &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return this.hasPlaybackControl === !1
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = e),
            this.isPlaying === !0 && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }
      class $g {
        constructor(e, t, n) {
          (this.binding = e), (this.valueSize = n);
          let i, s, o;
          switch (t) {
            case "quaternion":
              (i = this._slerp),
                (s = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(n * 6)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (s = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(n * 5));
              break;
            default:
              (i = this._lerp),
                (s = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(n * 5));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = s),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            s = e * i + i;
          let o = this.cumulativeWeight;
          if (o === 0) {
            for (let a = 0; a !== i; ++a) n[s + a] = n[a];
            o = t;
          } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, s, 0, a, i);
          }
          this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            s < 1)
          ) {
            const l = t * this._origIndex;
            this._mixBufferRegion(n, i, l, 1 - s, t);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let l = t, c = t + t; l !== c; ++l)
            if (n[l] !== n[l + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let s = n, o = i; s !== o; ++s) t[s] = t[i + (s % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, s) {
          if (i >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[n + o];
        }
        _slerp(e, t, n, i) {
          yt.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, s) {
          const o = this._workIndex * s;
          yt.multiplyQuaternionsFlat(e, o, e, t, e, n),
            yt.slerpFlat(e, t, e, t, e, o, i);
        }
        _lerp(e, t, n, i, s) {
          const o = 1 - i;
          for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, s) {
          for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i;
          }
        }
      }
      const jo = "\\[\\]\\.:\\/",
        Qg = new RegExp("[" + jo + "]", "g"),
        Yo = "[^" + jo + "]",
        e_ = "[^" + jo.replace("\\.", "") + "]",
        t_ = /((?:WC+[\/:])*)/.source.replace("WC", Yo),
        n_ = /(WCOD+)?/.source.replace("WCOD", e_),
        i_ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Yo),
        s_ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Yo),
        r_ = new RegExp("^" + t_ + n_ + i_ + s_ + "$"),
        o_ = ["material", "materials", "bones"];
      class a_ {
        constructor(e, t, n) {
          const i = n || ke.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, s = n.length;
            i !== s;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }
      class ke {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || ke.parseTrackName(t)),
            (this.node = ke.findNode(e, this.parsedPath.nodeName) || e),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new ke.Composite(e, t, n)
            : new ke(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(Qg, "");
        }
        static parseTrackName(e) {
          const t = r_.exec(e);
          if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (i !== void 0 && i !== -1) {
            const s = n.nodeName.substring(i + 1);
            o_.indexOf(s) !== -1 &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = s));
          }
          if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            t === void 0 ||
            t === "" ||
            t === "." ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n;
          }
          if (e.children) {
            const n = function (s) {
                for (let o = 0; o < s.length; o++) {
                  const a = s[o];
                  if (a.name === t || a.uuid === t) return a;
                  const l = n(a.children);
                  if (l) return l;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let s = t.propertyIndex;
          if (
            (e ||
              ((e = ke.findNode(this.rootNode, t.nodeName) || this.rootNode),
              (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
            return;
          }
          if (n) {
            let c = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!e.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                  if (e[h].name === c) {
                    c = h;
                    break;
                  }
                break;
              default:
                if (e[n] === void 0) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                e = e[n];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
                return;
              }
              e = e[c];
            }
          }
          const o = e[i];
          if (o === void 0) {
            const c = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                c +
                "." +
                i +
                " but it wasn't found.",
              e
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            e.needsUpdate !== void 0
              ? (a = this.Versioning.NeedsUpdate)
              : e.matrixWorldNeedsUpdate !== void 0 &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let l = this.BindingType.Direct;
          if (s !== void 0) {
            if (i === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (e.geometry.isBufferGeometry) {
                if (!e.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                e.morphTargetDictionary[s] !== void 0 &&
                  (s = e.morphTargetDictionary[s]);
              } else {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
                return;
              }
            }
            (l = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = s);
          } else
            o.fromArray !== void 0 && o.toArray !== void 0
              ? ((l = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((l = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[l]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      ke.Composite = a_;
      ke.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      };
      ke.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      };
      ke.prototype.GetterByBindingType = [
        ke.prototype._getValue_direct,
        ke.prototype._getValue_array,
        ke.prototype._getValue_arrayElement,
        ke.prototype._getValue_toArray,
      ];
      ke.prototype.SetterByBindingTypeAndVersioning = [
        [
          ke.prototype._setValue_direct,
          ke.prototype._setValue_direct_setNeedsUpdate,
          ke.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          ke.prototype._setValue_array,
          ke.prototype._setValue_array_setNeedsUpdate,
          ke.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          ke.prototype._setValue_arrayElement,
          ke.prototype._setValue_arrayElement_setNeedsUpdate,
          ke.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          ke.prototype._setValue_fromArray,
          ke.prototype._setValue_fromArray_setNeedsUpdate,
          ke.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ];
      class l_ {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const s = t.tracks,
            o = s.length,
            a = new Array(o),
            l = { endingStart: mi, endingEnd: mi };
          for (let c = 0; c !== o; ++c) {
            const h = s[c].createInterpolant(null);
            (a[c] = h), (h.settings = l);
          }
          (this._interpolantSettings = l),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = zh),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const i = this._clip.duration,
              s = e._clip.duration,
              o = s / i,
              a = i / s;
            e.warp(1, o, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            e !== null &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            s = i.time,
            o = this.timeScale;
          let a = this._timeScaleInterpolant;
          a === null &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const l = a.parameterPositions,
            c = a.sampleValues;
          return (
            (l[0] = s), (l[1] = s + n), (c[0] = e / o), (c[1] = t / o), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            e !== null &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const s = this._startTime;
          if (s !== null) {
            const l = (e - s) * n;
            if (l < 0 || n === 0) return;
            (this._startTime = null), (t = n * l);
          }
          t *= this._updateTimeScale(e);
          const o = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const l = this._interpolants,
              c = this._propertyBindings;
            switch (this.blendMode) {
              case kl:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulateAdditive(a);
                break;
              case wo:
              default:
                for (let h = 0, u = l.length; h !== u; ++h)
                  l[h].evaluate(o), c[h].accumulate(i, a);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), i === 0 && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            n !== null &&
              ((t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                t === 0 ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            s = this._loopCount;
          const o = n === Hh;
          if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
          if (n === Uh) {
            s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else if (i < 0) i = 0;
              else {
                this.time = i;
                break e;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (s === -1 &&
                (e >= 0
                  ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
                  : this._setEndings(this.repetitions === 0, !0, o)),
              i >= t || i < 0)
            ) {
              const a = Math.floor(i / t);
              (i -= t * a), (s += Math.abs(a));
              const l = this.repetitions - s;
              if (l <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (l === 1) {
                  const c = e < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = s),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = i;
            if (o && (s & 1) === 1) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = gi), (i.endingEnd = gi))
            : (e
                ? (i.endingStart = this.zeroSlopeAtStart ? gi : mi)
                : (i.endingStart = Qs),
              t
                ? (i.endingEnd = this.zeroSlopeAtEnd ? gi : mi)
                : (i.endingEnd = Qs));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            s = i.time;
          let o = this._weightInterpolant;
          o === null &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const a = o.parameterPositions,
            l = o.sampleValues;
          return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = n), this;
        }
      }
      class c_ extends kn {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            s = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = n.uuid,
            c = this._bindingsByRootAndName;
          let h = c[l];
          h === void 0 && ((h = {}), (c[l] = h));
          for (let u = 0; u !== s; ++u) {
            const d = i[u],
              f = d.name;
            let g = h[f];
            if (g !== void 0) ++g.referenceCount, (o[u] = g);
            else {
              if (((g = o[u]), g !== void 0)) {
                g._cacheIndex === null &&
                  (++g.referenceCount, this._addInactiveBinding(g, l, f));
                continue;
              }
              const m = t && t._propertyBindings[u].binding.parsedPath;
              (g = new $g(
                ke.create(n, f, m),
                d.ValueTypeName,
                d.getValueSize()
              )),
                ++g.referenceCount,
                this._addInactiveBinding(g, l, f),
                (o[u] = g);
            }
            a[u].resultBuffer = g.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const n = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                s = this._actionsByClip[i];
              this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, i, n);
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const s = t[n];
              s.useCount++ === 0 &&
                (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const s = t[n];
              --s.useCount === 0 &&
                (s.restoreOriginalState(), this._takeBackBinding(s));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            s = this._actionsByClip;
          let o = s[t];
          if (o === void 0)
            (o = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (s[t] = o);
          else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            l = a.knownActions,
            c = l[l.length - 1],
            h = e._byClipCacheIndex;
          (c._byClipCacheIndex = h),
            (l[h] = c),
            l.pop(),
            (e._byClipCacheIndex = null);
          const u = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
          delete u[d],
            l.length === 0 && delete o[s],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const s = t[n];
            --s.referenceCount === 0 && this._removeInactiveBinding(s);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            s = t[i];
          (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            s = t[i];
          (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            s = this._bindings;
          let o = i[t];
          o === void 0 && ((o = {}), (i[t] = o)),
            (o[n] = e),
            (e._cacheIndex = s.length),
            s.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            s = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = t[t.length - 1],
            c = e._cacheIndex;
          (l._cacheIndex = c),
            (t[c] = l),
            t.pop(),
            delete a[s],
            Object.keys(a).length === 0 && delete o[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            s = t[i];
          (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            s = t[i];
          (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            n === void 0 &&
              ((n = new Ac(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            s = t[i];
          (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = n), (t[n] = s);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            s = i.uuid;
          let o = typeof e == "string" ? xo.findByName(i, e) : e;
          const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
          let c = null;
          if (
            (n === void 0 && (o !== null ? (n = o.blendMode) : (n = wo)),
            l !== void 0)
          ) {
            const u = l.actionByRoot[s];
            if (u !== void 0 && u.blendMode === n) return u;
            (c = l.knownActions[0]), o === null && (o = c._clip);
          }
          if (o === null) return null;
          const h = new l_(this, o, t, n);
          return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            s = typeof e == "string" ? xo.findByName(n, e) : e,
            o = s ? s.uuid : e,
            a = this._actionsByClip[o];
          return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions,
            t = this._nActiveActions;
          for (let n = t - 1; n >= 0; --n) e[n].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            s = Math.sign(e),
            o = (this._accuIndex ^= 1);
          for (let c = 0; c !== n; ++c) t[c]._update(i, e, s, o);
          const a = this._bindings,
            l = this._nActiveBindings;
          for (let c = 0; c !== l; ++c) a[c].apply(o);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            s = i[n];
          if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
              const c = o[a];
              this._deactivateAction(c);
              const h = c._cacheIndex,
                u = t[t.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (u._cacheIndex = h),
                (t[h] = u),
                t.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const o in n) {
            const a = n[o].actionByRoot,
              l = a[t];
            l !== void 0 &&
              (this._deactivateAction(l), this._removeInactiveAction(l));
          }
          const i = this._bindingsByRootAndName,
            s = i[t];
          if (s !== void 0)
            for (const o in s) {
              const a = s[o];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          n !== null &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      c_.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class h_ extends Di {
        constructor(e, t, n = 1) {
          super(e, t), (this.meshPerAttribute = n);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        clone(e) {
          const t = super.clone(e);
          return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.isInstancedInterleavedBuffer = !0),
            (t.meshPerAttribute = this.meshPerAttribute),
            t
          );
        }
      }
      h_.prototype.isInstancedInterleavedBuffer = !0;
      const gn = new S(),
        Js = new me(),
        no = new me();
      class u_ extends hr {
        constructor(e) {
          const t = zc(e),
            n = new Ke(),
            i = [],
            s = [],
            o = new he(0, 0, 1),
            a = new he(0, 1, 0);
          for (let c = 0; c < t.length; c++) {
            const h = t[c];
            h.parent &&
              h.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              s.push(o.r, o.g, o.b),
              s.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new ct(i, 3)),
            n.setAttribute("color", new ct(s, 3));
          const l = new Xn({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, l),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          no.copy(this.root.matrixWorld).invert();
          for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent &&
              a.parent.isBone &&
              (Js.multiplyMatrices(no, a.matrixWorld),
              gn.setFromMatrixPosition(Js),
              i.setXYZ(o, gn.x, gn.y, gn.z),
              Js.multiplyMatrices(no, a.parent.matrixWorld),
              gn.setFromMatrixPosition(Js),
              i.setXYZ(o + 1, gn.x, gn.y, gn.z),
              (o += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }
      function zc(r) {
        const e = [];
        r.isBone === !0 && e.push(r);
        for (let t = 0; t < r.children.length; t++)
          e.push.apply(e, zc(r.children[t]));
        return e;
      }
      class d_ extends hr {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new he(n)), (i = new he(i));
          const s = t / 2,
            o = e / t,
            a = e / 2,
            l = [],
            c = [];
          for (let d = 0, f = 0, g = -a; d <= t; d++, g += o) {
            l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
            const m = d === s ? n : i;
            m.toArray(c, f),
              (f += 3),
              m.toArray(c, f),
              (f += 3),
              m.toArray(c, f),
              (f += 3),
              m.toArray(c, f),
              (f += 3);
          }
          const h = new Ke();
          h.setAttribute("position", new ct(l, 3)),
            h.setAttribute("color", new ct(c, 3));
          const u = new Xn({ vertexColors: !0, toneMapped: !1 });
          super(h, u), (this.type = "GridHelper");
        }
      }
      const kt = new Uint32Array(512),
        Vt = new Uint32Array(512);
      for (let r = 0; r < 256; ++r) {
        const e = r - 127;
        e < -27
          ? ((kt[r] = 0),
            (kt[r | 256] = 32768),
            (Vt[r] = 24),
            (Vt[r | 256] = 24))
          : e < -14
          ? ((kt[r] = 1024 >> (-e - 14)),
            (kt[r | 256] = (1024 >> (-e - 14)) | 32768),
            (Vt[r] = -e - 1),
            (Vt[r | 256] = -e - 1))
          : e <= 15
          ? ((kt[r] = (e + 15) << 10),
            (kt[r | 256] = ((e + 15) << 10) | 32768),
            (Vt[r] = 13),
            (Vt[r | 256] = 13))
          : e < 128
          ? ((kt[r] = 31744),
            (kt[r | 256] = 64512),
            (Vt[r] = 24),
            (Vt[r | 256] = 24))
          : ((kt[r] = 31744),
            (kt[r | 256] = 64512),
            (Vt[r] = 13),
            (Vt[r | 256] = 13));
      }
      const Hc = new Uint32Array(2048),
        gs = new Uint32Array(64),
        f_ = new Uint32Array(64);
      for (let r = 1; r < 1024; ++r) {
        let e = r << 13,
          t = 0;
        for (; (e & 8388608) === 0; ) (e <<= 1), (t -= 8388608);
        (e &= -8388609), (t += 947912704), (Hc[r] = e | t);
      }
      for (let r = 1024; r < 2048; ++r) Hc[r] = 939524096 + ((r - 1024) << 13);
      for (let r = 1; r < 31; ++r) gs[r] = r << 23;
      gs[31] = 1199570944;
      gs[32] = 2147483648;
      for (let r = 33; r < 63; ++r) gs[r] = 2147483648 + ((r - 32) << 23);
      gs[63] = 3347054592;
      for (let r = 1; r < 64; ++r) r !== 32 && (f_[r] = 1024);
      Lt.create = function (r, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (r.prototype = Object.create(Lt.prototype)),
          (r.prototype.constructor = r),
          (r.prototype.getPoint = e),
          r
        );
      };
      mo.prototype.fromPoints = function (r) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(r)
        );
      };
      d_.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      };
      u_.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      };
      an.prototype.extractUrlBase = function (r) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          wn.extractUrlBase(r)
        );
      };
      an.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      };
      Ct.prototype.center = function (r) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(r)
        );
      };
      Ct.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      };
      Ct.prototype.isIntersectionBox = function (r) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(r)
        );
      };
      Ct.prototype.isIntersectionSphere = function (r) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(r)
        );
      };
      Ct.prototype.size = function (r) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(r)
        );
      };
      qn.prototype.toVector3 = function () {
        console.error(
          "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
        );
      };
      Wn.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      };
      or.prototype.setFromMatrix = function (r) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(r)
        );
      };
      dt.prototype.flattenToArrayOffset = function (r, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(r, e)
        );
      };
      dt.prototype.multiplyVector3 = function (r) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          r.applyMatrix3(this)
        );
      };
      dt.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      };
      dt.prototype.applyToBufferAttribute = function (r) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          r.applyMatrix3(this)
        );
      };
      dt.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      };
      dt.prototype.getInverse = function (r) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(r).invert()
        );
      };
      me.prototype.extractPosition = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(r)
        );
      };
      me.prototype.flattenToArrayOffset = function (r, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(r, e)
        );
      };
      me.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new S().setFromMatrixColumn(this, 3)
        );
      };
      me.prototype.setRotationFromQuaternion = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(r)
        );
      };
      me.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      me.prototype.multiplyVector3 = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          r.applyMatrix4(this)
        );
      };
      me.prototype.multiplyVector4 = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          r.applyMatrix4(this)
        );
      };
      me.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      };
      me.prototype.rotateAxis = function (r) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          r.transformDirection(this);
      };
      me.prototype.crossVector = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          r.applyMatrix4(this)
        );
      };
      me.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      me.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      me.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      me.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      me.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      me.prototype.applyToBufferAttribute = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          r.applyMatrix4(this)
        );
      };
      me.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      };
      me.prototype.makeFrustum = function (r, e, t, n, i, s) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(r, e, n, t, i, s)
        );
      };
      me.prototype.getInverse = function (r) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(r).invert()
        );
      };
      nn.prototype.isIntersectionLine = function (r) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(r)
        );
      };
      yt.prototype.multiplyVector3 = function (r) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          r.applyQuaternion(this)
        );
      };
      yt.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      };
      Pi.prototype.isIntersectionBox = function (r) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(r)
        );
      };
      Pi.prototype.isIntersectionPlane = function (r) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(r)
        );
      };
      Pi.prototype.isIntersectionSphere = function (r) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(r)
        );
      };
      st.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      };
      st.prototype.barycoordFromPoint = function (r, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(r, e)
        );
      };
      st.prototype.midpoint = function (r) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(r)
        );
      };
      st.prototypenormal = function (r) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(r)
        );
      };
      st.prototype.plane = function (r) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(r)
        );
      };
      st.barycoordFromPoint = function (r, e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          st.getBarycoord(r, e, t, n, i)
        );
      };
      st.normal = function (r, e, t, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          st.getNormal(r, e, t, n)
        );
      };
      ms.prototype.extractAllPoints = function (r) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(r)
        );
      };
      ms.prototype.extrude = function (r) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new Fi(this, r)
        );
      };
      ms.prototype.makeGeometry = function (r) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new ko(this, r)
        );
      };
      $.prototype.fromAttribute = function (r, e, t) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(r, e, t)
        );
      };
      $.prototype.distanceToManhattan = function (r) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(r)
        );
      };
      $.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      S.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      };
      S.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      };
      S.prototype.getPositionFromMatrix = function (r) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(r)
        );
      };
      S.prototype.getScaleFromMatrix = function (r) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(r)
        );
      };
      S.prototype.getColumnFromMatrix = function (r, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, r)
        );
      };
      S.prototype.applyProjection = function (r) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(r)
        );
      };
      S.prototype.fromAttribute = function (r, e, t) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(r, e, t)
        );
      };
      S.prototype.distanceToManhattan = function (r) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(r)
        );
      };
      S.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      je.prototype.fromAttribute = function (r, e, t) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(r, e, t)
        );
      };
      je.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      };
      Ve.prototype.getChildByName = function (r) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(r)
        );
      };
      Ve.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      };
      Ve.prototype.translate = function (r, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, r)
        );
      };
      Ve.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      };
      Ve.prototype.applyMatrix = function (r) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(r)
        );
      };
      Object.defineProperties(Ve.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (r) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = r);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      xt.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      };
      Object.defineProperties(xt.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              Gh
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      });
      No.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      mt.prototype.setLens = function (r, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          e !== void 0 && (this.filmGauge = e),
          this.setFocalLength(r);
      };
      Object.defineProperties(qt.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = r);
          },
        },
        shadowCameraLeft: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = r);
          },
        },
        shadowCameraRight: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = r);
          },
        },
        shadowCameraTop: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = r);
          },
        },
        shadowCameraBottom: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = r);
          },
        },
        shadowCameraNear: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = r);
          },
        },
        shadowCameraFar: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = r);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (r) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = r);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = r);
          },
        },
        shadowMapHeight: {
          set: function (r) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = r);
          },
        },
      });
      Object.defineProperties(tt.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === er
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(er);
          },
        },
      });
      tt.prototype.setDynamic = function (r) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(r === !0 ? er : rs),
          this
        );
      };
      (tt.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
        (tt.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        });
      Ke.prototype.addIndex = function (r) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(r);
      };
      Ke.prototype.addAttribute = function (r, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(r, new tt(arguments[1], arguments[2])))
            : r === "index"
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(r, e)
        );
      };
      Ke.prototype.addDrawCall = function (r, e, t) {
        t !== void 0 &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(r, e);
      };
      Ke.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      };
      Ke.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      };
      Ke.prototype.removeAttribute = function (r) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(r)
        );
      };
      Ke.prototype.applyMatrix = function (r) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(r)
        );
      };
      Object.defineProperties(Ke.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      });
      Di.prototype.setDynamic = function (r) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(r === !0 ? er : rs),
          this
        );
      };
      Di.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      };
      Fi.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      Fi.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      };
      Fi.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Do.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Object.defineProperties(et.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new he()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (r) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = r === Ol);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (r) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = r);
          },
        },
        vertexTangents: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
          set: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
        },
      });
      Object.defineProperties(Bt.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (r) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = r);
          },
        },
      });
      Xe.prototype.clearTarget = function (r, e, t, n) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(r),
          this.clear(e, t, n);
      };
      Xe.prototype.animate = function (r) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(r);
      };
      Xe.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      };
      Xe.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      };
      Xe.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      };
      Xe.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      };
      Xe.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      };
      Xe.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      };
      Xe.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      };
      Xe.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      };
      Xe.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      };
      Xe.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      };
      Xe.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      };
      Xe.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      };
      Xe.prototype.enableScissorTest = function (r) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(r);
      };
      Xe.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      Xe.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      Xe.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      Xe.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      };
      Xe.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      };
      Xe.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      };
      Xe.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      Xe.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      Xe.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      };
      Xe.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      };
      Object.defineProperties(Xe.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = r);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = r);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = r === !0 ? ze : Sn);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
        gammaFactor: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              ),
              2
            );
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          },
        },
      });
      Object.defineProperties(sc.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      });
      Object.defineProperties(St.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = r);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = r);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = r);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = r);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = r);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = r);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = r);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = r);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = r);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (r) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = r);
          },
        },
      });
      Zg.prototype.load = function (r) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new Yg().load(r, function (n) {
            e.setBuffer(n);
          }),
          this
        );
      };
      Ro.prototype.updateCubeMap = function (r, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(r, e)
        );
      };
      Ro.prototype.clear = function (r, e, t, n) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(r, e, t, n)
        );
      };
      Vn.crossOrigin = void 0;
      Vn.loadTexture = function (r, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new Cc();
        i.setCrossOrigin(this.crossOrigin);
        const s = i.load(r, t, void 0, n);
        return e && (s.mapping = e), s;
      };
      Vn.loadTextureCube = function (r, e, t, n) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new Vg();
        i.setCrossOrigin(this.crossOrigin);
        const s = i.load(r, t, void 0, n);
        return e && (s.mapping = e), s;
      };
      Vn.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      };
      Vn.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      };
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: bo } })
        );
      typeof window != "undefined" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = bo));
      class p_ extends an {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new y_(t);
            }),
            this.register(function (t) {
              return new T_(t);
            }),
            this.register(function (t) {
              return new E_(t);
            }),
            this.register(function (t) {
              return new v_(t);
            }),
            this.register(function (t) {
              return new M_(t);
            }),
            this.register(function (t) {
              return new b_(t);
            }),
            this.register(function (t) {
              return new w_(t);
            }),
            this.register(function (t) {
              return new x_(t);
            }),
            this.register(function (t) {
              return new S_(t);
            }),
            this.register(function (t) {
              return new g_(t);
            }),
            this.register(function (t) {
              return new A_(t);
            });
        }
        load(e, t, n, i) {
          const s = this;
          let o;
          this.resourcePath !== ""
            ? (o = this.resourcePath)
            : this.path !== ""
            ? (o = this.path)
            : (o = wn.extractUrlBase(e)),
            this.manager.itemStart(e);
          const a = function (c) {
              i ? i(c) : console.error(c),
                s.manager.itemError(e),
                s.manager.itemEnd(e);
            },
            l = new Vo(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
              e,
              function (c) {
                try {
                  s.parse(
                    c,
                    o,
                    function (h) {
                      t(h), s.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (h) {
                  a(h);
                }
              },
              n,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            this.pluginCallbacks.indexOf(e) === -1 &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            this.pluginCallbacks.indexOf(e) !== -1 &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let s;
          const o = {},
            a = {};
          if (typeof e == "string") s = e;
          else if (wn.decodeText(new Uint8Array(e, 0, 4)) === Gc) {
            try {
              o[Fe.KHR_BINARY_GLTF] = new R_(e);
            } catch (u) {
              i && i(u);
              return;
            }
            s = o[Fe.KHR_BINARY_GLTF].content;
          } else s = wn.decodeText(new Uint8Array(e));
          const l = JSON.parse(s);
          if (l.asset === void 0 || l.asset.version[0] < 2) {
            i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              );
            return;
          }
          const c = new G_(l, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const u = this.pluginCallbacks[h](c);
            (a[u.name] = u), (o[u.name] = !0);
          }
          if (l.extensionsUsed)
            for (let h = 0; h < l.extensionsUsed.length; ++h) {
              const u = l.extensionsUsed[h],
                d = l.extensionsRequired || [];
              switch (u) {
                case Fe.KHR_MATERIALS_UNLIT:
                  o[u] = new __();
                  break;
                case Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  o[u] = new P_();
                  break;
                case Fe.KHR_DRACO_MESH_COMPRESSION:
                  o[u] = new L_(l, this.dracoLoader);
                  break;
                case Fe.KHR_TEXTURE_TRANSFORM:
                  o[u] = new C_();
                  break;
                case Fe.KHR_MESH_QUANTIZATION:
                  o[u] = new I_();
                  break;
                default:
                  d.indexOf(u) >= 0 &&
                    a[u] === void 0 &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + u + '".'
                    );
              }
            }
          c.setExtensions(o), c.setPlugins(a), c.parse(n, i);
        }
        parseAsync(e, t) {
          const n = this;
          return new Promise(function (i, s) {
            n.parse(e, t, i, s);
          });
        }
      }
      function m_() {
        let r = {};
        return {
          get: function (e) {
            return r[e];
          },
          add: function (e, t) {
            r[e] = t;
          },
          remove: function (e) {
            delete r[e];
          },
          removeAll: function () {
            r = {};
          },
        };
      }
      const Fe = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      };
      class g_ {
        constructor(e) {
          (this.parser = e),
            (this.name = Fe.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            s.extensions &&
              s.extensions[this.name] &&
              s.extensions[this.name].light !== void 0 &&
              e._addNodeRef(this.cache, s.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let i = t.cache.get(n);
          if (i) return i;
          const s = t.json,
            l = (((s.extensions && s.extensions[this.name]) || {}).lights ||
              [])[e];
          let c;
          const h = new he(16777215);
          l.color !== void 0 && h.fromArray(l.color);
          const u = l.range !== void 0 ? l.range : 0;
          switch (l.type) {
            case "directional":
              (c = new qo(h)), c.target.position.set(0, 0, -1), c.add(c.target);
              break;
            case "point":
              (c = new Fc(h)), (c.distance = u);
              break;
            case "spot":
              (c = new Ic(h)),
                (c.distance = u),
                (l.spot = l.spot || {}),
                (l.spot.innerConeAngle =
                  l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
                (l.spot.outerConeAngle =
                  l.spot.outerConeAngle !== void 0
                    ? l.spot.outerConeAngle
                    : Math.PI / 4),
                (c.angle = l.spot.outerConeAngle),
                (c.penumbra =
                  1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
                c.target.position.set(0, 0, -1),
                c.add(c.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + l.type
              );
          }
          return (
            c.position.set(0, 0, 0),
            (c.decay = 2),
            l.intensity !== void 0 && (c.intensity = l.intensity),
            (c.name = t.createUniqueName(l.name || "light_" + e)),
            (i = Promise.resolve(c)),
            t.cache.add(n, i),
            i
          );
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            s = n.json.nodes[e],
            a = ((s.extensions && s.extensions[this.name]) || {}).light;
          return a === void 0
            ? null
            : this._loadLight(a).then(function (l) {
                return n._getNodeRef(t.cache, a, l);
              });
        }
      }
      class __ {
        constructor() {
          this.name = Fe.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return sn;
        }
        extendParams(e, t, n) {
          const i = [];
          (e.color = new he(1, 1, 1)), (e.opacity = 1);
          const s = t.pbrMetallicRoughness;
          if (s) {
            if (Array.isArray(s.baseColorFactor)) {
              const o = s.baseColorFactor;
              e.color.fromArray(o), (e.opacity = o[3]);
            }
            s.baseColorTexture !== void 0 &&
              i.push(n.assignTexture(e, "map", s.baseColorTexture, ze));
          }
          return Promise.all(i);
        }
      }
      class x_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_EMISSIVE_STRENGTH);
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = i.extensions[this.name].emissiveStrength;
          return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
        }
      }
      class y_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = i.extensions[this.name];
          if (
            (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
            o.clearcoatTexture !== void 0 &&
              s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
            o.clearcoatRoughnessFactor !== void 0 &&
              (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
            o.clearcoatRoughnessTexture !== void 0 &&
              s.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  o.clearcoatRoughnessTexture
                )
              ),
            o.clearcoatNormalTexture !== void 0 &&
              (s.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  o.clearcoatNormalTexture
                )
              ),
              o.clearcoatNormalTexture.scale !== void 0))
          ) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new $(a, a);
          }
          return Promise.all(s);
        }
      }
      class v_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_SHEEN);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = [];
          (t.sheenColor = new he(0, 0, 0)),
            (t.sheenRoughness = 0),
            (t.sheen = 1);
          const o = i.extensions[this.name];
          return (
            o.sheenColorFactor !== void 0 &&
              t.sheenColor.fromArray(o.sheenColorFactor),
            o.sheenRoughnessFactor !== void 0 &&
              (t.sheenRoughness = o.sheenRoughnessFactor),
            o.sheenColorTexture !== void 0 &&
              s.push(
                n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, ze)
              ),
            o.sheenRoughnessTexture !== void 0 &&
              s.push(
                n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
              ),
            Promise.all(s)
          );
        }
      }
      class M_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = i.extensions[this.name];
          return (
            o.transmissionFactor !== void 0 &&
              (t.transmission = o.transmissionFactor),
            o.transmissionTexture !== void 0 &&
              s.push(
                n.assignTexture(t, "transmissionMap", o.transmissionTexture)
              ),
            Promise.all(s)
          );
        }
      }
      class b_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_VOLUME);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = i.extensions[this.name];
          (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
            o.thicknessTexture !== void 0 &&
              s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
            (t.attenuationDistance = o.attenuationDistance || 0);
          const a = o.attenuationColor || [1, 1, 1];
          return (
            (t.attenuationColor = new he(a[0], a[1], a[2])), Promise.all(s)
          );
        }
      }
      class w_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_IOR);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = i.extensions[this.name];
          return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
        }
      }
      class S_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_MATERIALS_SPECULAR);
        }
        getMaterialType(e) {
          const n = this.parser.json.materials[e];
          return !n.extensions || !n.extensions[this.name] ? null : En;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = i.extensions[this.name];
          (t.specularIntensity =
            o.specularFactor !== void 0 ? o.specularFactor : 1),
            o.specularTexture !== void 0 &&
              s.push(
                n.assignTexture(t, "specularIntensityMap", o.specularTexture)
              );
          const a = o.specularColorFactor || [1, 1, 1];
          return (
            (t.specularColor = new he(a[0], a[1], a[2])),
            o.specularColorTexture !== void 0 &&
              s.push(
                n.assignTexture(
                  t,
                  "specularColorMap",
                  o.specularColorTexture,
                  ze
                )
              ),
            Promise.all(s)
          );
        }
      }
      class T_ {
        constructor(e) {
          (this.parser = e), (this.name = Fe.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const s = i.extensions[this.name],
            o = t.options.ktx2Loader;
          if (!o) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, s.source, o);
        }
      }
      class E_ {
        constructor(e) {
          (this.parser = e),
            (this.name = Fe.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[e];
          if (!s.extensions || !s.extensions[t]) return null;
          const o = s.extensions[t],
            a = i.images[o.source];
          let l = n.textureLoader;
          if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c);
          }
          return this.detectSupport().then(function (c) {
            if (c) return n.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(t.height === 1);
                    });
              })),
            this.isSupported
          );
        }
      }
      class A_ {
        constructor(e) {
          (this.name = Fe.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
              s = this.parser.getDependency("buffer", i.buffer),
              o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return Promise.all([s, o.ready]).then(function (a) {
              const l = i.byteOffset || 0,
                c = i.byteLength || 0,
                h = i.count,
                u = i.byteStride,
                d = new ArrayBuffer(h * u),
                f = new Uint8Array(a[0], l, c);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(d),
                  h,
                  u,
                  f,
                  i.mode,
                  i.filter
                ),
                d
              );
            });
          } else return null;
        }
      }
      const Gc = "glTF",
        Yi = 12,
        Rl = { JSON: 1313821514, BIN: 5130562 };
      class R_ {
        constructor(e) {
          (this.name = Fe.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, Yi);
          if (
            ((this.header = {
              magic: wn.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== Gc)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - Yi,
            i = new DataView(e, Yi);
          let s = 0;
          for (; s < n; ) {
            const o = i.getUint32(s, !0);
            s += 4;
            const a = i.getUint32(s, !0);
            if (((s += 4), a === Rl.JSON)) {
              const l = new Uint8Array(e, Yi + s, o);
              this.content = wn.decodeText(l);
            } else if (a === Rl.BIN) {
              const l = Yi + s;
              this.body = e.slice(l, l + o);
            }
            s += o;
          }
          if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class L_ {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = Fe.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            i = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
          for (const h in o) {
            const u = vo[h] || h.toLowerCase();
            a[u] = o[h];
          }
          for (const h in e.attributes) {
            const u = vo[h] || h.toLowerCase();
            if (o[h] !== void 0) {
              const d = n.accessors[e.attributes[h]],
                f = fs[d.componentType];
              (c[u] = f), (l[u] = d.normalized === !0);
            }
          }
          return t.getDependency("bufferView", s).then(function (h) {
            return new Promise(function (u) {
              i.decodeDracoFile(
                h,
                function (d) {
                  for (const f in d.attributes) {
                    const g = d.attributes[f],
                      m = l[f];
                    m !== void 0 && (g.normalized = m);
                  }
                  u(d);
                },
                a,
                c
              );
            });
          });
        }
      }
      class C_ {
        constructor() {
          this.name = Fe.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            t.texCoord !== void 0 &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.'
              ),
            (t.offset === void 0 &&
              t.rotation === void 0 &&
              t.scale === void 0) ||
              ((e = e.clone()),
              t.offset !== void 0 && e.offset.fromArray(t.offset),
              t.rotation !== void 0 && (e.rotation = t.rotation),
              t.scale !== void 0 && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class yo extends Ni {
        constructor(e) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0);
          const t = [
              "#ifdef USE_SPECULARMAP",
              "	uniform sampler2D specularMap;",
              "#endif",
            ].join(`
`),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "	uniform sampler2D glossinessMap;",
              "#endif",
            ].join(`
`),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "	vec4 texelSpecular = texture2D( specularMap, vUv );",
              "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	specularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join(`
`),
            s = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "	glossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join(`
`),
            o = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.roughness += geometryRoughness;",
              "material.roughness = min( material.roughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join(`
`),
            a = {
              specular: { value: new he().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = a),
            (this.onBeforeCompile = function (l) {
              for (const c in a) l.uniforms[c] = a[c];
              l.fragmentShader = l.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", t)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", s)
                .replace("#include <lights_physical_fragment>", o);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return a.specular.value;
                },
                set: function (l) {
                  a.specular.value = l;
                },
              },
              specularMap: {
                get: function () {
                  return a.specularMap.value;
                },
                set: function (l) {
                  (a.specularMap.value = l),
                    l
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return a.glossiness.value;
                },
                set: function (l) {
                  a.glossiness.value = l;
                },
              },
              glossinessMap: {
                get: function () {
                  return a.glossinessMap.value;
                },
                set: function (l) {
                  (a.glossinessMap.value = l),
                    l
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.specularMap = e.specularMap),
            this.specular.copy(e.specular),
            (this.glossinessMap = e.glossinessMap),
            (this.glossiness = e.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          );
        }
      }
      class P_ {
        constructor() {
          (this.name = Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
            ]);
        }
        getMaterialType() {
          return yo;
        }
        extendParams(e, t, n) {
          const i = t.extensions[this.name];
          (e.color = new he(1, 1, 1)), (e.opacity = 1);
          const s = [];
          if (Array.isArray(i.diffuseFactor)) {
            const o = i.diffuseFactor;
            e.color.fromArray(o), (e.opacity = o[3]);
          }
          if (
            (i.diffuseTexture !== void 0 &&
              s.push(n.assignTexture(e, "map", i.diffuseTexture, ze)),
            (e.emissive = new he(0, 0, 0)),
            (e.glossiness =
              i.glossinessFactor !== void 0 ? i.glossinessFactor : 1),
            (e.specular = new he(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              e.specular.fromArray(i.specularFactor),
            i.specularGlossinessTexture !== void 0)
          ) {
            const o = i.specularGlossinessTexture;
            s.push(n.assignTexture(e, "glossinessMap", o)),
              s.push(n.assignTexture(e, "specularMap", o, ze));
          }
          return Promise.all(s);
        }
        createMaterial(e) {
          const t = new yo(e);
          return (
            (t.fog = !0),
            (t.color = e.color),
            (t.map = e.map === void 0 ? null : e.map),
            (t.lightMap = null),
            (t.lightMapIntensity = 1),
            (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
            (t.aoMapIntensity = 1),
            (t.emissive = e.emissive),
            (t.emissiveIntensity =
              e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity),
            (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
            (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
            (t.bumpScale = 1),
            (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
            (t.normalMapType = Gn),
            e.normalScale && (t.normalScale = e.normalScale),
            (t.displacementMap = null),
            (t.displacementScale = 1),
            (t.displacementBias = 0),
            (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
            (t.specular = e.specular),
            (t.glossinessMap =
              e.glossinessMap === void 0 ? null : e.glossinessMap),
            (t.glossiness = e.glossiness),
            (t.alphaMap = null),
            (t.envMap = e.envMap === void 0 ? null : e.envMap),
            (t.envMapIntensity = 1),
            t
          );
        }
      }
      class I_ {
        constructor() {
          this.name = Fe.KHR_MESH_QUANTIZATION;
        }
      }
      class Hn extends on {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = e * i * 3 + i;
          for (let o = 0; o !== i; o++) t[o] = n[s + o];
          return t;
        }
      }
      Hn.prototype.beforeStart_ = Hn.prototype.copySampleValue_;
      Hn.prototype.afterEnd_ = Hn.prototype.copySampleValue_;
      Hn.prototype.interpolate_ = function (r, e, t, n) {
        const i = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = o * 2,
          l = o * 3,
          c = n - e,
          h = (t - e) / c,
          u = h * h,
          d = u * h,
          f = r * l,
          g = f - l,
          m = -2 * d + 3 * u,
          p = d - u,
          _ = 1 - m,
          M = p - u + h;
        for (let T = 0; T !== o; T++) {
          const E = s[g + T + o],
            w = s[g + T + a] * c,
            R = s[f + T + o],
            P = s[f + T] * c;
          i[T] = _ * E + M * w + m * R + p * P;
        }
        return i;
      };
      const D_ = new yt();
      class F_ extends Hn {
        interpolate_(e, t, n, i) {
          const s = super.interpolate_(e, t, n, i);
          return D_.fromArray(s).normalize().toArray(s), s;
        }
      }
      const Qt = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        fs = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        Ll = { 9728: at, 9729: pt, 9984: ao, 9985: Gl, 9986: lo, 9987: Ci },
        Cl = { 33071: Et, 33648: $s, 10497: Si },
        Pl = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        vo = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        _n = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        N_ = { CUBICSPLINE: void 0, LINEAR: Ei, STEP: ss },
        io = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
      function B_(r) {
        return (
          r.DefaultMaterial === void 0 &&
            (r.DefaultMaterial = new Ni({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: Mi,
            })),
          r.DefaultMaterial
        );
      }
      function Ji(r, e, t) {
        for (const n in t.extensions)
          r[n] === void 0 &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[n] = t.extensions[n]));
      }
      function In(r, e) {
        e.extras !== void 0 &&
          (typeof e.extras == "object"
            ? Object.assign(r.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function O_(r, e, t) {
        let n = !1,
          i = !1,
          s = !1;
        for (let c = 0, h = e.length; c < h; c++) {
          const u = e[c];
          if (
            (u.POSITION !== void 0 && (n = !0),
            u.NORMAL !== void 0 && (i = !0),
            u.COLOR_0 !== void 0 && (s = !0),
            n && i && s)
          )
            break;
        }
        if (!n && !i && !s) return Promise.resolve(r);
        const o = [],
          a = [],
          l = [];
        for (let c = 0, h = e.length; c < h; c++) {
          const u = e[c];
          if (n) {
            const d =
              u.POSITION !== void 0
                ? t.getDependency("accessor", u.POSITION)
                : r.attributes.position;
            o.push(d);
          }
          if (i) {
            const d =
              u.NORMAL !== void 0
                ? t.getDependency("accessor", u.NORMAL)
                : r.attributes.normal;
            a.push(d);
          }
          if (s) {
            const d =
              u.COLOR_0 !== void 0
                ? t.getDependency("accessor", u.COLOR_0)
                : r.attributes.color;
            l.push(d);
          }
        }
        return Promise.all([
          Promise.all(o),
          Promise.all(a),
          Promise.all(l),
        ]).then(function (c) {
          const h = c[0],
            u = c[1],
            d = c[2];
          return (
            n && (r.morphAttributes.position = h),
            i && (r.morphAttributes.normal = u),
            s && (r.morphAttributes.color = d),
            (r.morphTargetsRelative = !0),
            r
          );
        });
      }
      function U_(r, e) {
        if ((r.updateMorphTargets(), e.weights !== void 0))
          for (let t = 0, n = e.weights.length; t < n; t++)
            r.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (r.morphTargetInfluences.length === t.length) {
            r.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
              r.morphTargetDictionary[t[n]] = n;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function z_(r) {
        const e = r.extensions && r.extensions[Fe.KHR_DRACO_MESH_COMPRESSION];
        let t;
        return (
          e
            ? (t =
                "draco:" +
                e.bufferView +
                ":" +
                e.indices +
                ":" +
                Il(e.attributes))
            : (t = r.indices + ":" + Il(r.attributes) + ":" + r.mode),
          t
        );
      }
      function Il(r) {
        let e = "";
        const t = Object.keys(r).sort();
        for (let n = 0, i = t.length; n < i; n++)
          e += t[n] + ":" + r[t[n]] + ";";
        return e;
      }
      function Mo(r) {
        switch (r) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      function H_(r) {
        return r.search(/\.jpe?g($|\?)/i) > 0 ||
          r.search(/^data\:image\/jpeg/) === 0
          ? "image/jpeg"
          : r.search(/\.webp($|\?)/i) > 0 ||
            r.search(/^data\:image\/webp/) === 0
          ? "image/webp"
          : "image/png";
      }
      class G_ {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new m_()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.sourceCache = {}),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {});
          const n =
              /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
            i = navigator.userAgent.indexOf("Firefox") > -1,
            s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
          typeof createImageBitmap == "undefined" || n || (i && s < 98)
            ? (this.textureLoader = new Cc(this.options.manager))
            : (this.textureLoader = new Uc(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new Vo(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            this.options.crossOrigin === "use-credentials" &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            s = this.extensions;
          this.cache.removeAll(),
            this._invokeAll(function (o) {
              return o._markDefs && o._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (o) {
                return o.beforeRoot && o.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (o) {
                const a = {
                  scene: o[0][i.scene || 0],
                  scenes: o[0],
                  animations: o[1],
                  cameras: o[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                Ji(s, a, i),
                  In(a, i),
                  Promise.all(
                    n._invokeAll(function (l) {
                      return l.afterRoot && l.afterRoot(a);
                    })
                  ).then(function () {
                    e(a);
                  });
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
          }
          for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 &&
              (this._addNodeRef(this.meshCache, o.mesh),
              o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
              o.camera !== void 0 &&
                this._addNodeRef(this.cameraCache, o.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 &&
            (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone(),
            s = (o, a) => {
              const l = this.associations.get(o);
              l != null && this.associations.set(a, l);
              for (const [c, h] of o.children.entries()) s(h, a.children[c]);
            };
          return s(n, i), (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            s && n.push(s);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this.loadNode(t);
                break;
              case "mesh":
                i = this._invokeOne(function (s) {
                  return s.loadMesh && s.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (s) {
                  return s.loadBufferView && s.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (s) {
                  return s.loadMaterial && s.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (s) {
                  return s.loadTexture && s.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this._invokeOne(function (s) {
                  return s.loadAnimation && s.loadAnimation(t);
                });
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (s, o) {
                return n.getDependency(e, o);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && t.type !== "arraybuffer")
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Fe.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (s, o) {
            n.load(wn.resolveURL(t.uri, i.path), s, void 0, function () {
              o(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (n) {
            const i = t.byteLength || 0,
              s = t.byteOffset || 0;
            return n.slice(s, s + i);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            i = this.json.accessors[e];
          if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
          const s = [];
          return (
            i.bufferView !== void 0
              ? s.push(this.getDependency("bufferView", i.bufferView))
              : s.push(null),
            i.sparse !== void 0 &&
              (s.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              s.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(s).then(function (o) {
              const a = o[0],
                l = Pl[i.type],
                c = fs[i.componentType],
                h = c.BYTES_PER_ELEMENT,
                u = h * l,
                d = i.byteOffset || 0,
                f =
                  i.bufferView !== void 0
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                g = i.normalized === !0;
              let m, p;
              if (f && f !== u) {
                const _ = Math.floor(d / f),
                  M =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    _ +
                    ":" +
                    i.count;
                let T = t.cache.get(M);
                T ||
                  ((m = new c(a, _ * f, (i.count * f) / h)),
                  (T = new Di(m, f / h)),
                  t.cache.add(M, T)),
                  (p = new Ri(T, l, (d % f) / h, g));
              } else a === null ? (m = new c(i.count * l)) : (m = new c(a, d, i.count * l)), (p = new tt(m, l, g));
              if (i.sparse !== void 0) {
                const _ = Pl.SCALAR,
                  M = fs[i.sparse.indices.componentType],
                  T = i.sparse.indices.byteOffset || 0,
                  E = i.sparse.values.byteOffset || 0,
                  w = new M(o[1], T, i.sparse.count * _),
                  R = new c(o[2], E, i.sparse.count * l);
                a !== null &&
                  (p = new tt(p.array.slice(), p.itemSize, p.normalized));
                for (let P = 0, y = w.length; P < y; P++) {
                  const L = w[P];
                  if (
                    (p.setX(L, R[P * l]),
                    l >= 2 && p.setY(L, R[P * l + 1]),
                    l >= 3 && p.setZ(L, R[P * l + 2]),
                    l >= 4 && p.setW(L, R[P * l + 3]),
                    l >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return p;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            s = t.textures[e].source,
            o = t.images[s];
          let a = this.textureLoader;
          if (o.uri) {
            const l = n.manager.getHandler(o.uri);
            l !== null && (a = l);
          }
          return this.loadTextureImage(e, s, a);
        }
        loadTextureImage(e, t, n) {
          const i = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = this.loadImageSource(t, n)
            .then(function (h) {
              (h.flipY = !1), o.name && (h.name = o.name);
              const d = (s.samplers || {})[o.sampler] || {};
              return (
                (h.magFilter = Ll[d.magFilter] || pt),
                (h.minFilter = Ll[d.minFilter] || Ci),
                (h.wrapS = Cl[d.wrapS] || Si),
                (h.wrapT = Cl[d.wrapT] || Si),
                i.associations.set(h, { textures: e }),
                h
              );
            })
            .catch(function () {
              return null;
            });
          return (this.textureCache[l] = c), c;
        }
        loadImageSource(e, t) {
          const n = this,
            i = this.json,
            s = this.options;
          if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then((u) => u.clone());
          const o = i.images[e],
            a = self.URL || self.webkitURL;
          let l = o.uri || "",
            c = !1;
          if (o.bufferView !== void 0)
            l = n.getDependency("bufferView", o.bufferView).then(function (u) {
              c = !0;
              const d = new Blob([u], { type: o.mimeType });
              return (l = a.createObjectURL(d)), l;
            });
          else if (o.uri === void 0)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const h = Promise.resolve(l)
            .then(function (u) {
              return new Promise(function (d, f) {
                let g = d;
                t.isImageBitmapLoader === !0 &&
                  (g = function (m) {
                    const p = new rt(m);
                    (p.needsUpdate = !0), d(p);
                  }),
                  t.load(wn.resolveURL(u, s.path), g, void 0, f);
              });
            })
            .then(function (u) {
              return (
                c === !0 && a.revokeObjectURL(l),
                (u.userData.mimeType = o.mimeType || H_(o.uri)),
                u
              );
            })
            .catch(function (u) {
              throw (
                (console.error("THREE.GLTFLoader: Couldn't load texture", l), u)
              );
            });
          return (this.sourceCache[e] = h), h;
        }
        assignTexture(e, t, n, i) {
          const s = this;
          return this.getDependency("texture", n.index).then(function (o) {
            if (
              (n.texCoord !== void 0 &&
                n.texCoord != 0 &&
                !(t === "aoMap" && n.texCoord == 1) &&
                console.warn(
                  "THREE.GLTFLoader: Custom UV set " +
                    n.texCoord +
                    " for texture " +
                    t +
                    " not yet supported."
                ),
              s.extensions[Fe.KHR_TEXTURE_TRANSFORM])
            ) {
              const a =
                n.extensions !== void 0
                  ? n.extensions[Fe.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (a) {
                const l = s.associations.get(o);
                (o = s.extensions[Fe.KHR_TEXTURE_TRANSFORM].extendTexture(
                  o,
                  a
                )),
                  s.associations.set(o, l);
              }
            }
            return i !== void 0 && (o.encoding = i), (e[t] = o), o;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const i = t.attributes.tangent === void 0,
            s = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0;
          if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l ||
              ((l = new ur()),
              et.prototype.copy.call(l, n),
              l.color.copy(n.color),
              (l.map = n.map),
              (l.sizeAttenuation = !1),
              this.cache.add(a, l)),
              (n = l);
          } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l ||
              ((l = new Xn()),
              et.prototype.copy.call(l, n),
              l.color.copy(n.color),
              this.cache.add(a, l)),
              (n = l);
          }
          if (i || s || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
              i && (a += "derivative-tangents:"),
              s && (a += "vertex-colors:"),
              o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l ||
              ((l = n.clone()),
              s && (l.vertexColors = !0),
              o && (l.flatShading = !0),
              i &&
                (l.normalScale && (l.normalScale.y *= -1),
                l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
              this.cache.add(a, l),
              this.associations.set(l, this.associations.get(n))),
              (n = l);
          }
          n.aoMap &&
            t.attributes.uv2 === void 0 &&
            t.attributes.uv !== void 0 &&
            t.setAttribute("uv2", t.attributes.uv),
            (e.material = n);
        }
        getMaterialType() {
          return Ni;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            s = n.materials[e];
          let o;
          const a = {},
            l = s.extensions || {},
            c = [];
          if (l[Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const u = i[Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            (o = u.getMaterialType()), c.push(u.extendParams(a, s, t));
          } else if (l[Fe.KHR_MATERIALS_UNLIT]) {
            const u = i[Fe.KHR_MATERIALS_UNLIT];
            (o = u.getMaterialType()), c.push(u.extendParams(a, s, t));
          } else {
            const u = s.pbrMetallicRoughness || {};
            if (
              ((a.color = new he(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(u.baseColorFactor))
            ) {
              const d = u.baseColorFactor;
              a.color.fromArray(d), (a.opacity = d[3]);
            }
            u.baseColorTexture !== void 0 &&
              c.push(t.assignTexture(a, "map", u.baseColorTexture, ze)),
              (a.metalness =
                u.metallicFactor !== void 0 ? u.metallicFactor : 1),
              (a.roughness =
                u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
              u.metallicRoughnessTexture !== void 0 &&
                (c.push(
                  t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)
                ),
                c.push(
                  t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture)
                )),
              (o = this._invokeOne(function (d) {
                return d.getMaterialType && d.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (d) {
                    return (
                      d.extendMaterialParams && d.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          s.doubleSided === !0 && (a.side = On);
          const h = s.alphaMode || io.OPAQUE;
          if (
            (h === io.BLEND
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                h === io.MASK &&
                  (a.alphaTest =
                    s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
            s.normalTexture !== void 0 &&
              o !== sn &&
              (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
              (a.normalScale = new $(1, 1)),
              s.normalTexture.scale !== void 0))
          ) {
            const u = s.normalTexture.scale;
            a.normalScale.set(u, u);
          }
          return (
            s.occlusionTexture !== void 0 &&
              o !== sn &&
              (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
              s.occlusionTexture.strength !== void 0 &&
                (a.aoMapIntensity = s.occlusionTexture.strength)),
            s.emissiveFactor !== void 0 &&
              o !== sn &&
              (a.emissive = new he().fromArray(s.emissiveFactor)),
            s.emissiveTexture !== void 0 &&
              o !== sn &&
              c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, ze)),
            Promise.all(c).then(function () {
              let u;
              return (
                o === yo
                  ? (u =
                      i[
                        Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(a))
                  : (u = new o(a)),
                s.name && (u.name = s.name),
                In(u, s),
                t.associations.set(u, { materials: e }),
                s.extensions && Ji(i, u, s),
                u
              );
            })
          );
        }
        createUniqueName(e) {
          const t = ke.sanitizeNodeName(e || "");
          let n = t;
          for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
          return (this.nodeNamesUsed[n] = !0), n;
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            i = this.primitiveCache;
          function s(a) {
            return n[Fe.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(a, t)
              .then(function (l) {
                return Dl(l, a, t);
              });
          }
          const o = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              h = z_(c),
              u = i[h];
            if (u) o.push(u.promise);
            else {
              let d;
              c.extensions && c.extensions[Fe.KHR_DRACO_MESH_COMPRESSION]
                ? (d = s(c))
                : (d = Dl(new Ke(), c, t)),
                (i[h] = { primitive: c, promise: d }),
                o.push(d);
            }
          }
          return Promise.all(o);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            s = n.meshes[e],
            o = s.primitives,
            a = [];
          for (let l = 0, c = o.length; l < c; l++) {
            const h =
              o[l].material === void 0
                ? B_(this.cache)
                : this.getDependency("material", o[l].material);
            a.push(h);
          }
          return (
            a.push(t.loadGeometries(o)),
            Promise.all(a).then(function (l) {
              const c = l.slice(0, l.length - 1),
                h = l[l.length - 1],
                u = [];
              for (let f = 0, g = h.length; f < g; f++) {
                const m = h[f],
                  p = o[f];
                let _;
                const M = c[f];
                if (
                  p.mode === Qt.TRIANGLES ||
                  p.mode === Qt.TRIANGLE_STRIP ||
                  p.mode === Qt.TRIANGLE_FAN ||
                  p.mode === void 0
                )
                  (_ = s.isSkinnedMesh === !0 ? new No(m, M) : new xt(m, M)),
                    _.isSkinnedMesh === !0 &&
                      !_.geometry.attributes.skinWeight.normalized &&
                      _.normalizeSkinWeights(),
                    p.mode === Qt.TRIANGLE_STRIP
                      ? (_.geometry = Fl(_.geometry, kh))
                      : p.mode === Qt.TRIANGLE_FAN &&
                        (_.geometry = Fl(_.geometry, Vl));
                else if (p.mode === Qt.LINES) _ = new hr(m, M);
                else if (p.mode === Qt.LINE_STRIP) _ = new cr(m, M);
                else if (p.mode === Qt.LINE_LOOP) _ = new cc(m, M);
                else if (p.mode === Qt.POINTS) _ = new hc(m, M);
                else
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + p.mode
                  );
                Object.keys(_.geometry.morphAttributes).length > 0 && U_(_, s),
                  (_.name = t.createUniqueName(s.name || "mesh_" + e)),
                  In(_, s),
                  p.extensions && Ji(i, _, p),
                  t.assignFinalMaterial(_),
                  u.push(_);
              }
              for (let f = 0, g = u.length; f < g; f++)
                t.associations.set(u[f], { meshes: e, primitives: f });
              if (u.length === 1) return u[0];
              const d = new yn();
              t.associations.set(d, { meshes: e });
              for (let f = 0, g = u.length; f < g; f++) d.add(u[f]);
              return d;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            i = n[n.type];
          if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return (
            n.type === "perspective"
              ? (t = new mt(
                  lu.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : n.type === "orthographic" &&
                (t = new ar(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            In(t, n),
            Promise.resolve(t)
          );
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = { joints: t.joints };
          return t.inverseBindMatrices === void 0
            ? Promise.resolve(n)
            : this.getDependency("accessor", t.inverseBindMatrices).then(
                function (i) {
                  return (n.inverseBindMatrices = i), n;
                }
              );
        }
        loadAnimation(e) {
          const n = this.json.animations[e],
            i = [],
            s = [],
            o = [],
            a = [],
            l = [];
          for (let c = 0, h = n.channels.length; c < h; c++) {
            const u = n.channels[c],
              d = n.samplers[u.sampler],
              f = u.target,
              g = f.node !== void 0 ? f.node : f.id,
              m = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
              p = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
            i.push(this.getDependency("node", g)),
              s.push(this.getDependency("accessor", m)),
              o.push(this.getDependency("accessor", p)),
              a.push(d),
              l.push(f);
          }
          return Promise.all([
            Promise.all(i),
            Promise.all(s),
            Promise.all(o),
            Promise.all(a),
            Promise.all(l),
          ]).then(function (c) {
            const h = c[0],
              u = c[1],
              d = c[2],
              f = c[3],
              g = c[4],
              m = [];
            for (let _ = 0, M = h.length; _ < M; _++) {
              const T = h[_],
                E = u[_],
                w = d[_],
                R = f[_],
                P = g[_];
              if (T === void 0) continue;
              T.updateMatrix(), (T.matrixAutoUpdate = !0);
              let y;
              switch (_n[P.path]) {
                case _n.weights:
                  y = us;
                  break;
                case _n.rotation:
                  y = zn;
                  break;
                case _n.position:
                case _n.scale:
                default:
                  y = ds;
                  break;
              }
              const L = T.name ? T.name : T.uuid,
                N = R.interpolation !== void 0 ? N_[R.interpolation] : Ei,
                D = [];
              _n[P.path] === _n.weights
                ? T.traverse(function (J) {
                    J.morphTargetInfluences && D.push(J.name ? J.name : J.uuid);
                  })
                : D.push(L);
              let ie = w.array;
              if (w.normalized) {
                const J = Mo(ie.constructor),
                  C = new Float32Array(ie.length);
                for (let H = 0, B = ie.length; H < B; H++) C[H] = ie[H] * J;
                ie = C;
              }
              for (let J = 0, C = D.length; J < C; J++) {
                const H = new y(D[J] + "." + _n[P.path], E.array, ie, N);
                R.interpolation === "CUBICSPLINE" &&
                  ((H.createInterpolant = function (V) {
                    const X = this instanceof zn ? F_ : Hn;
                    return new X(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      V
                    );
                  }),
                  (H.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  m.push(H);
              }
            }
            const p = n.name ? n.name : "animation_" + e;
            return new xo(p, void 0, m);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return i.mesh === void 0
            ? null
            : n.getDependency("mesh", i.mesh).then(function (s) {
                const o = n._getNodeRef(n.meshCache, i.mesh, s);
                return (
                  i.weights !== void 0 &&
                    o.traverse(function (a) {
                      if (!!a.isMesh)
                        for (let l = 0, c = i.weights.length; l < c; l++)
                          a.morphTargetInfluences[l] = i.weights[l];
                    }),
                  o
                );
              });
        }
        loadNode(e) {
          const t = this.json,
            n = this.extensions,
            i = this,
            s = t.nodes[e],
            o = s.name ? i.createUniqueName(s.name) : "";
          return (function () {
            const a = [],
              l = i._invokeOne(function (c) {
                return c.createNodeMesh && c.createNodeMesh(e);
              });
            return (
              l && a.push(l),
              s.camera !== void 0 &&
                a.push(
                  i.getDependency("camera", s.camera).then(function (c) {
                    return i._getNodeRef(i.cameraCache, s.camera, c);
                  })
                ),
              i
                ._invokeAll(function (c) {
                  return c.createNodeAttachment && c.createNodeAttachment(e);
                })
                .forEach(function (c) {
                  a.push(c);
                }),
              Promise.all(a)
            );
          })().then(function (a) {
            let l;
            if (
              (s.isBone === !0
                ? (l = new Bo())
                : a.length > 1
                ? (l = new yn())
                : a.length === 1
                ? (l = a[0])
                : (l = new Ve()),
              l !== a[0])
            )
              for (let c = 0, h = a.length; c < h; c++) l.add(a[c]);
            if (
              (s.name && ((l.userData.name = s.name), (l.name = o)),
              In(l, s),
              s.extensions && Ji(n, l, s),
              s.matrix !== void 0)
            ) {
              const c = new me();
              c.fromArray(s.matrix), l.applyMatrix4(c);
            } else s.translation !== void 0 && l.position.fromArray(s.translation), s.rotation !== void 0 && l.quaternion.fromArray(s.rotation), s.scale !== void 0 && l.scale.fromArray(s.scale);
            return (
              i.associations.has(l) || i.associations.set(l, {}),
              (i.associations.get(l).nodes = e),
              l
            );
          });
        }
        loadScene(e) {
          const t = this.json,
            n = this.extensions,
            i = this.json.scenes[e],
            s = this,
            o = new yn();
          i.name && (o.name = s.createUniqueName(i.name)),
            In(o, i),
            i.extensions && Ji(n, o, i);
          const a = i.nodes || [],
            l = [];
          for (let c = 0, h = a.length; c < h; c++) l.push(kc(a[c], o, t, s));
          return Promise.all(l).then(function () {
            const c = (h) => {
              const u = new Map();
              for (const [d, f] of s.associations)
                (d instanceof et || d instanceof rt) && u.set(d, f);
              return (
                h.traverse((d) => {
                  const f = s.associations.get(d);
                  f != null && u.set(d, f);
                }),
                u
              );
            };
            return (s.associations = c(o)), o;
          });
        }
      }
      function kc(r, e, t, n) {
        const i = t.nodes[r];
        return n
          .getDependency("node", r)
          .then(function (s) {
            if (i.skin === void 0) return s;
            let o;
            return n
              .getDependency("skin", i.skin)
              .then(function (a) {
                o = a;
                const l = [];
                for (let c = 0, h = o.joints.length; c < h; c++)
                  l.push(n.getDependency("node", o.joints[c]));
                return Promise.all(l);
              })
              .then(function (a) {
                return (
                  s.traverse(function (l) {
                    if (!l.isMesh) return;
                    const c = [],
                      h = [];
                    for (let u = 0, d = a.length; u < d; u++) {
                      const f = a[u];
                      if (f) {
                        c.push(f);
                        const g = new me();
                        o.inverseBindMatrices !== void 0 &&
                          g.fromArray(o.inverseBindMatrices.array, u * 16),
                          h.push(g);
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          o.joints[u]
                        );
                    }
                    l.bind(new Oo(c, h), l.matrixWorld);
                  }),
                  s
                );
              });
          })
          .then(function (s) {
            e.add(s);
            const o = [];
            if (i.children) {
              const a = i.children;
              for (let l = 0, c = a.length; l < c; l++) {
                const h = a[l];
                o.push(kc(h, s, t, n));
              }
            }
            return Promise.all(o);
          });
      }
      function k_(r, e, t) {
        const n = e.attributes,
          i = new Ct();
        if (n.POSITION !== void 0) {
          const a = t.json.accessors[n.POSITION],
            l = a.min,
            c = a.max;
          if (l !== void 0 && c !== void 0) {
            if (
              (i.set(new S(l[0], l[1], l[2]), new S(c[0], c[1], c[2])),
              a.normalized)
            ) {
              const h = Mo(fs[a.componentType]);
              i.min.multiplyScalar(h), i.max.multiplyScalar(h);
            }
          } else {
            console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
            return;
          }
        } else return;
        const s = e.targets;
        if (s !== void 0) {
          const a = new S(),
            l = new S();
          for (let c = 0, h = s.length; c < h; c++) {
            const u = s[c];
            if (u.POSITION !== void 0) {
              const d = t.json.accessors[u.POSITION],
                f = d.min,
                g = d.max;
              if (f !== void 0 && g !== void 0) {
                if (
                  (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))),
                  l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))),
                  l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))),
                  d.normalized)
                ) {
                  const m = Mo(fs[d.componentType]);
                  l.multiplyScalar(m);
                }
                a.max(l);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          i.expandByVector(a);
        }
        r.boundingBox = i;
        const o = new Wn();
        i.getCenter(o.center),
          (o.radius = i.min.distanceTo(i.max) / 2),
          (r.boundingSphere = o);
      }
      function Dl(r, e, t) {
        const n = e.attributes,
          i = [];
        function s(o, a) {
          return t.getDependency("accessor", o).then(function (l) {
            r.setAttribute(a, l);
          });
        }
        for (const o in n) {
          const a = vo[o] || o.toLowerCase();
          a in r.attributes || i.push(s(n[o], a));
        }
        if (e.indices !== void 0 && !r.index) {
          const o = t.getDependency("accessor", e.indices).then(function (a) {
            r.setIndex(a);
          });
          i.push(o);
        }
        return (
          In(r, e),
          k_(r, e, t),
          Promise.all(i).then(function () {
            return e.targets !== void 0 ? O_(r, e.targets, t) : r;
          })
        );
      }
      function Fl(r, e) {
        let t = r.getIndex();
        if (t === null) {
          const o = [],
            a = r.getAttribute("position");
          if (a !== void 0) {
            for (let l = 0; l < a.count; l++) o.push(l);
            r.setIndex(o), (t = r.getIndex());
          } else
            return (
              console.error(
                "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
              ),
              r
            );
        }
        const n = t.count - 2,
          i = [];
        if (e === Vl)
          for (let o = 1; o <= n; o++)
            i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
        else
          for (let o = 0; o < n; o++)
            o % 2 === 0
              ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2)))
              : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n &&
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
          );
        const s = r.clone();
        return s.setIndex(i), s;
      }
      /**
       * @license
       * Copyright 2021 Google LLC.
       * SPDX-License-Identifier: Apache-2.0
       */ let Nl;
      const en = {
        tilt: 0,
        heading: 0,
        zoom: 18,
        center: { lat: 35.6594945, lng: 139.6999859 },
        mapId: "15431d2b469f209e",
        disableDefaultUI: !0,
        gestureHandling: "none",
        keyboardShortcuts: !1,
      };
      function V_() {
        const r = document.getElementById("map");
        (Nl = new google.maps.Map(r, en)), W_(Nl);
      }
      function W_(r) {
        let e, t, n, i;
        const s = new google.maps.WebGLOverlayView();
        (s.onAdd = () => {
          (e = new Do()), (n = new mt());
          const o = new Bc(16777215, 0.75);
          e.add(o);
          const a = new qo(16777215, 0.25);
          a.position.set(0.5, -1, 0.5), e.add(a), (i = new p_());
          const l =
            "https://raw.githubusercontent.com/googlemaps/js-samples/main/assets/pin.gltf";
          i.load(l, (c) => {
            c.scene.scale.set(10, 10, 10),
              (c.scene.rotation.x = Math.PI),
              e.add(c.scene);
          });
        }),
          (s.onContextRestored = ({ gl: o }) => {
            (t = new Xe({
              canvas: o.canvas,
              context: o,
              ...o.getContextAttributes(),
            })),
              (t.autoClear = !1),
              (i.manager.onLoad = () => {
                t.setAnimationLoop(() => {
                  s.requestRedraw();
                  const { tilt: a, heading: l, zoom: c } = en;
                  r.moveCamera({ tilt: a, heading: l, zoom: c }),
                    en.tilt < 67.5
                      ? (en.tilt += 0.5)
                      : en.heading <= 360
                      ? ((en.heading += 0.2), (en.zoom -= 5e-4))
                      : t.setAnimationLoop(null);
                });
              });
          }),
          (s.onDraw = ({ gl: o, transformer: a }) => {
            const l = { lat: en.center.lat, lng: en.center.lng, altitude: 100 },
              c = a.fromLatLngAltitude(l);
            (n.projectionMatrix = new me().fromArray(c)),
              s.requestRedraw(),
              t.render(e, n),
              t.resetState();
          }),
          s.setMap(r);
      }
      window.initMap = V_;
    </script>
    <style>
      #map,
      body,
      html {
        height: 100%;
      }
      body,
      html {
        margin: 0;
        padding: 0;
      }
      #map {
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="map" class="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=beta"
      defer
    ></script>
  </body>
</html>
